<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò• üõ¨ ‚ô•Ô∏è Prinsip SOLID yang Harus Diketahui Setiap Pengembang üìù üàµ üî°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pemrograman berorientasi objek telah membawa pendekatan baru untuk desain aplikasi ke dalam pengembangan perangkat lunak. Secara khusus, OOP memungkin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prinsip SOLID yang Harus Diketahui Setiap Pengembang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426413/">  Pemrograman berorientasi objek telah membawa pendekatan baru untuk desain aplikasi ke dalam pengembangan perangkat lunak.  Secara khusus, OOP memungkinkan pemrogram untuk menggabungkan entitas, disatukan oleh tujuan atau fungsi yang sama, dalam kelas yang terpisah, yang dirancang untuk memecahkan masalah independen dan independen dari bagian lain dari aplikasi.  Namun, penggunaan OOP saja tidak berarti bahwa pengembang aman dari kemungkinan membuat kode yang kabur dan membingungkan yang sulit dipertahankan.  Robert Martin, untuk membantu semua orang yang ingin mengembangkan aplikasi OOP berkualitas tinggi, mengembangkan lima prinsip pemrograman dan desain berorientasi objek, berbicara tentang itu, dengan bantuan Michael Fazers, mereka menggunakan akronim SOLID. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/46/xx/ol/46xxolpv46av7bknmyywp3ii9vs.jpeg"></a> <br><br>  Bahan, terjemahan yang kami terbitkan hari ini, didedikasikan untuk dasar-dasar SOLID dan ditujukan untuk pengembang pemula. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Apa itu SOLID?</font> </h2><br>  Berikut adalah singkatan SOLID: <br><br><ul><li>  S: Prinsip Tanggung Jawab Tunggal. </li><li>  O: Prinsip Terbuka-Tertutup. </li><li>  L: Prinsip Substitusi Liskov (Prinsip Pergantian Barbara Liskov). </li><li>  I: Prinsip Segregasi Antarmuka. </li><li>  D: Prinsip Pembalikan Ketergantungan. </li></ul><br>  Sekarang kita akan mempertimbangkan prinsip-prinsip ini dalam contoh skema.  Perhatikan bahwa tujuan utama dari contoh-contoh ini adalah untuk membantu pembaca memahami prinsip-prinsip SOLID, mempelajari cara menerapkannya, dan bagaimana mengikuti mereka ketika merancang aplikasi.  Penulis materi tidak berusaha untuk mencapai kode kerja yang dapat digunakan dalam proyek nyata. <br><br><h2>  <font color="#3AC1EF">Prinsip tanggung jawab tunggal</font> </h2><br>  <i><font color="#999999">"Satu tugas.</font></i>  <i><font color="#999999">Hanya satu hal. "</font></i>  <i><font color="#999999">- Loki menceritakan Skurge dalam film Thor: Ragnarok.</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Setiap kelas harus menyelesaikan hanya satu masalah.</font></i> <br><br>  Sebuah kelas seharusnya hanya bertanggung jawab atas satu hal.  Jika suatu kelas bertanggung jawab untuk menyelesaikan beberapa masalah, subsistemnya yang mengimplementasikan solusi dari masalah ini ternyata saling terkait satu sama lain.  Perubahan dalam satu subsistem tersebut menyebabkan perubahan yang lain. <br><br>  Perhatikan bahwa prinsip ini berlaku tidak hanya untuk kelas, tetapi juga untuk komponen perangkat lunak dalam arti yang lebih luas. <br><br>  Sebagai contoh, pertimbangkan kode ini: <br><br><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {    constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }    getAnimalName() { }    saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  Kelas <code>Animal</code> disajikan di sini menggambarkan beberapa jenis hewan.  Kelas ini melanggar prinsip tanggung jawab tunggal.  Bagaimana tepatnya prinsip ini dilanggar? <br><br>  Sesuai dengan prinsip tanggung jawab tunggal, kelas harus menyelesaikan hanya satu tugas.  Dia memecahkan keduanya dengan bekerja dengan gudang data dalam metode <code>saveAnimal</code> dan memanipulasi properti objek di konstruktor dan metode <code>getAnimalName</code> . <br><br>  Bagaimana struktur kelas seperti itu dapat menyebabkan masalah? <br><br>  Jika prosedur untuk bekerja dengan gudang data yang digunakan oleh perubahan aplikasi, maka Anda harus membuat perubahan pada semua kelas yang bekerja dengan gudang.  Arsitektur ini tidak fleksibel, perubahan dalam beberapa subsistem mempengaruhi yang lain, yang menyerupai efek domino. <br><br>  Untuk membawa kode di atas sejalan dengan prinsip tanggung jawab tunggal, kita akan membuat kelas lain yang tugasnya hanya bekerja dengan repositori, khususnya, menyimpan objek kelas <code>Animal</code> di dalamnya: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {   constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }   getAnimalName() { } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AnimalDB</span></span></span><span class="hljs-class"> {   getAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { }   saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  Inilah yang dikatakan Steve Fenton tentang ini: ‚ÄúKetika merancang kelas, kita harus berusaha untuk mengintegrasikan komponen terkait, yaitu, di mana perubahan terjadi karena alasan yang sama.  Kita harus mencoba memisahkan komponen, perubahan yang menyebabkan berbagai alasan. " <br><br>  Penerapan prinsip tanggung jawab tunggal yang benar mengarah pada konektivitas tingkat tinggi dari elemen-elemen di dalam modul, yaitu kenyataan bahwa tugas-tugas yang diselesaikan di dalamnya sesuai dengan tujuan utamanya. <br><br><h2>  <font color="#3AC1EF">Prinsip terbuka-tertutup</font> </h2><br>  <i><font color="#999999">Entitas perangkat lunak (kelas, modul, fungsi) harus terbuka untuk ekspansi, tetapi tidak untuk modifikasi.</font></i> <br><br>  Kami terus bekerja di kelas <code>Animal</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name: string){ }   getAnimalName() { } }</code> </pre> <br>  Kami ingin memilah-milah daftar hewan, yang masing-masing diwakili oleh objek dari kelas <code>Animal</code> , dan mencari tahu suara apa yang mereka buat.  Bayangkan kita memecahkan masalah ini menggunakan fungsi <code>AnimalSounds</code> : <br><br><pre> <code class="hljs powershell">//... const animals: Array&lt;Animal&gt; = [   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'lion'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'mouse'</span></span>) ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  Masalah utama dengan arsitektur ini adalah bahwa fungsi menentukan jenis suara apa yang dibuat oleh hewan ketika menganalisis objek tertentu.  Fungsi <code>AnimalSound</code> tidak sesuai dengan prinsip keterbukaan-keterbukaan, karena, misalnya, ketika jenis hewan baru muncul, kita perlu mengubahnya untuk menggunakannya untuk mengenali suara yang dibuat oleh mereka. <br><br>  Tambahkan elemen baru ke array: <br><br><pre> <code class="hljs powershell">//... const animals: Array&lt;Animal&gt; = [   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'lion'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'mouse'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'snake'</span></span>) ] //...</code> </pre> <br>  Setelah itu, kita harus mengubah kode fungsi <code>AnimalSound</code> : <br><br><pre> <code class="hljs powershell">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'snake'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hiss'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  Seperti yang Anda lihat, ketika menambahkan hewan baru ke array, Anda harus menambahkan kode fungsi.  Contohnya sangat sederhana, tetapi jika arsitektur yang serupa digunakan dalam proyek nyata, fungsinya harus terus diperluas, menambahkan ekspresi baru <code>if</code> itu. <br><br>  Bagaimana cara membawa fungsi <code>AnimalSound</code> sejalan dengan prinsip buka-tutup?  Misalnya, seperti ini: <br><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {       makeSound();       //... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;   } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Squirrel</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;   } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Snake</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hiss'</span></span>;   } } //... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       a[<span class="hljs-type"><span class="hljs-type">i</span></span>].makeSound();   } } AnimalSound(animals);</code> </pre> <br>  Anda mungkin memperhatikan bahwa kelas <code>Animal</code> sekarang memiliki metode <code>makeSound</code> virtual.  Dengan pendekatan ini, perlu bahwa kelas yang dirancang untuk menggambarkan hewan tertentu memperluas kelas <code>Animal</code> dan menerapkan metode ini. <br><br>  Akibatnya, setiap kelas yang mendeskripsikan hewan akan memiliki metode <code>makeSound</code> sendiri, dan ketika iterasi pada array dengan hewan dalam fungsi <code>AnimalSound</code> , cukup memanggil metode ini untuk setiap elemen array. <br><br>  Jika sekarang Anda menambahkan objek yang menggambarkan hewan baru ke array, Anda tidak perlu mengubah fungsi <code>AnimalSound</code> .  Kami membawanya sejalan dengan prinsip keterbukaan-kedekatan. <br><br>  Pertimbangkan contoh lain. <br><br>  Misalkan kita punya toko.  Kami memberi pelanggan diskon 20% menggunakan kelas ini: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>   } }</code> </pre> <br>  Sekarang diputuskan untuk membagi pelanggan menjadi dua kelompok.  Pelanggan favorit ( <code>fav</code> ) diberikan diskon 20%, dan pelanggan VIP ( <code>vip</code> ) - gandakan diskon, yaitu - 40%.  Untuk mengimplementasikan logika ini, diputuskan untuk memodifikasi kelas sebagai berikut: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'fav'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>;       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'vip'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.4</span></span>;       }   } }</code> </pre> <br>  Pendekatan ini melanggar prinsip keterbukaan-kedekatan.  Seperti yang Anda lihat, di sini, jika kami perlu memberikan diskon khusus kepada kelompok pelanggan tertentu, kami harus menambahkan kode baru ke kelas. <br><br>  Untuk memproses kode ini sesuai dengan prinsip keterbukaan-kedekatan, kami menambahkan kelas baru ke proyek yang memperluas kelas <code>Discount</code> .  Di kelas baru ini, kami menerapkan mekanisme baru: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Discount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  Jika Anda memutuskan untuk memberikan diskon 80% kepada pelanggan "super-VIP", seharusnya terlihat seperti ini: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperVIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIPDiscount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  Seperti yang Anda lihat, pemberdayaan kelas digunakan di sini, bukan modifikasinya. <br><br><h2>  <font color="#3AC1EF">Prinsip substitusi Barbara Liskov</font> </h2><br>  <i><font color="#999999">Sangatlah penting bahwa subclass berfungsi sebagai pengganti superclasses mereka.</font></i> <br><br>  Tujuan dari prinsip ini adalah bahwa kelas warisan dapat digunakan sebagai pengganti kelas induk dari mana mereka dibentuk tanpa mengganggu program.  Jika ternyata tipe kelas diperiksa dalam kode, maka prinsip substitusi dilanggar. <br><br>  Pertimbangkan penerapan prinsip ini, kembali ke contoh dengan kelas <code>Animal</code> .  Kami akan menulis fungsi yang dirancang untuk mengembalikan informasi tentang jumlah anggota tubuh hewan. <br><br><pre> <code class="hljs powershell">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);   } } AnimalLegCount(animals);</code> </pre> <br>  Fungsi tersebut melanggar prinsip substitusi (dan prinsip keterbukaan-penutupan).  Kode ini harus tahu tentang jenis semua objek yang diproses olehnya dan, tergantung pada jenisnya, gunakan fungsi yang sesuai untuk menghitung anggota tubuh hewan tertentu.  Akibatnya, saat membuat jenis hewan baru, fungsinya harus ditulis ulang: <br><br><pre> <code class="hljs powershell">//... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pigeon</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {      } const animals[]: Array&lt;Animal&gt; = [   //<span class="hljs-type"><span class="hljs-type">...</span></span>,   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Pigeon</span></span>(); ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Pigeon)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PigeonLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);   } } AnimalLegCount(animals);</code> </pre> <br>  Agar fungsi ini tidak melanggar prinsip substitusi, kami mengubahnya menggunakan persyaratan yang dirumuskan oleh Steve Fenton.  Mereka terdiri dalam kenyataan bahwa metode yang menerima atau mengembalikan nilai dengan jenis beberapa superclass ( <code>Animal</code> dalam kasus kami) juga harus menerima dan mengembalikan nilai yang jenisnya adalah subclass ( <code>Pigeon</code> ). <br><br>  Berbekal pertimbangan ini, kita dapat mengulang fungsi <code>AnimalLegCount</code> : <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt;= a.length; i++)</span></span></span><span class="hljs-function"> {       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;   } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animals)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Sekarang fungsi ini tidak tertarik pada jenis objek yang diteruskan ke sana.  Dia hanya memanggil metode <code>LegCount</code> mereka.  Yang dia tahu tentang tipe adalah bahwa objek yang dia proses harus milik kelas <code>Animal</code> atau subkelasnya. <br><br>  Metode <code>LegCount</code> sekarang akan muncul di kelas <code>Animal</code> : <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//...   LegCount(); }</span></span></code> </pre> <br>  Dan subclassnya perlu mengimplementasikan metode ini: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class">{   //...   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LegCount</span></span></span><span class="hljs-class">() {       //...   } } //...</span></span></code> </pre> <br>  Sebagai hasilnya, misalnya, ketika mengakses metode <code>LegCount</code> untuk instance dari kelas <code>Lion</code> , metode yang diterapkan dalam kelas ini dipanggil dan apa yang dapat diharapkan dari memanggil metode seperti itu dikembalikan. <br><br>  Sekarang fungsi <code>AnimalLegCount</code> tidak perlu tahu tentang objek subclass tertentu dari kelas <code>Animal</code> yang diproses untuk mengetahui informasi tentang jumlah anggota tubuh pada hewan yang diwakili oleh objek ini.  Fungsi ini hanya memanggil metode <code>LegCount</code> dari kelas <code>Animal</code> , karena subclass dari kelas ini harus mengimplementasikan metode ini sehingga mereka dapat digunakan sebagai gantinya, tanpa melanggar operasi program yang benar. <br><br><h2>  <font color="#3AC1EF">Prinsip pemisahan antarmuka</font> </h2><br>  <i><font color="#999999">Buat antarmuka yang sangat khusus yang dirancang untuk klien tertentu.</font></i>  <i><font color="#999999">Klien tidak harus bergantung pada antarmuka yang tidak mereka gunakan.</font></i> <br><br>  Prinsip ini bertujuan untuk mengatasi kekurangan yang terkait dengan implementasi antarmuka yang besar. <br><br>  Pertimbangkan antarmuka <code>Shape</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle(); }</code> </pre> <br>  Ini menjelaskan metode untuk menggambar lingkaran ( <code>drawCircle</code> ), kotak ( <code>drawSquare</code> ) dan persegi panjang ( <code>drawRectangle</code> ).  Akibatnya, kelas yang mengimplementasikan antarmuka ini dan mewakili bentuk geometris individual, seperti Lingkaran, Kotak, dan Persegi Panjang, harus berisi implementasi semua metode ini.  Ini terlihat seperti ini: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Circle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Square</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rectangle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } }</span></span></code> </pre> <br>  Kode aneh ternyata.  Sebagai contoh, kelas <code>Rectangle</code> mewakili metode mengimplementasikan persegi panjang ( <code>drawCircle</code> dan <code>drawSquare</code> ) yang tidak perlu sama sekali.  Hal yang sama dapat dilihat ketika menganalisis kode dua kelas lainnya. <br><br>  Misalkan kita memutuskan untuk menambahkan metode lain ke antarmuka <code>Shape</code> , <code>drawTriangle</code> , yang dirancang untuk menggambar segitiga: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle();   drawTriangle(); }</code> </pre> <br>  Ini akan menghasilkan kelas-kelas yang mewakili bentuk-bentuk geometris tertentu yang harus mengimplementasikan metode <code>drawTriangle</code> juga.  Kalau tidak, kesalahan akan terjadi. <br><br>  Seperti yang Anda lihat, dengan pendekatan ini tidak mungkin untuk membuat kelas yang mengimplementasikan metode untuk menghasilkan lingkaran, tetapi tidak menerapkan metode untuk menurunkan kotak, persegi panjang, dan segitiga.  Metode seperti itu dapat diimplementasikan sehingga ketika itu adalah output, kesalahan dilemparkan menunjukkan bahwa operasi seperti itu tidak dapat dilakukan. <br><br>  Prinsip pemisahan antarmuka memperingatkan kita untuk tidak membuat antarmuka seperti <code>Shape</code> dari contoh kita.  Klien (kami memiliki kelas <code>Circle</code> , <code>Square</code> dan <code>Rectangle</code> ) tidak boleh mengimplementasikan metode yang tidak perlu mereka gunakan.  Selain itu, prinsip ini menunjukkan bahwa antarmuka harus menyelesaikan hanya satu tugas (dalam hal ini mirip dengan prinsip tanggung jawab tunggal), oleh karena itu segala sesuatu yang melampaui ruang lingkup tugas ini harus ditransfer ke antarmuka atau antarmuka lain. <br><br>  Dalam kasus kami, antarmuka <code>Shape</code> memecahkan masalah untuk solusi yang diperlukan untuk membuat antarmuka terpisah.  Mengikuti ide ini, kami mengerjakan ulang kode dengan membuat antarmuka terpisah untuk menyelesaikan berbagai tugas yang sangat khusus: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> </span></span>{   draw(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISquare</span></span></span><span class="hljs-class"> </span></span>{   drawSquare(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IRectangle</span></span></span><span class="hljs-class"> </span></span>{   drawRectangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ITriangle</span></span></span><span class="hljs-class"> </span></span>{   drawTriangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Circle</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle() {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class Square implements ISquare {   drawSquare() {       //...   } } class Rectangle implements IRectangle {   drawRectangle() {       //...   } } class Triangle implements ITriangle {   drawTriangle() {       //...   } } class CustomShape implements Shape {  draw(){     //...  } }</span></span></code> </pre> <br>  Sekarang antarmuka <code>ICircle</code> hanya digunakan untuk menggambar lingkaran, serta antarmuka khusus lainnya untuk menggambar bentuk lainnya.  Antarmuka <code>Shape</code> dapat digunakan sebagai antarmuka universal. <br><br><h2>  <font color="#3AC1EF">Prinsip Pembalikan Ketergantungan</font> </h2><br>  <i><font color="#999999">Objek ketergantungan harus berupa abstraksi, bukan sesuatu yang spesifik.</font></i> <br><br><ol><li>  Modul tingkat atas tidak harus bergantung pada modul tingkat bawah.  Kedua jenis modul harus bergantung pada abstraksi. </li><li>  Abstraksi tidak harus bergantung pada detail.  Rinciannya harus bergantung pada abstraksi. </li></ol><br>  Dalam proses pengembangan perangkat lunak, ada saat ketika fungsionalitas aplikasi berhenti masuk dalam modul yang sama.  Ketika ini terjadi, kita harus menyelesaikan masalah dependensi modul.  Sebagai hasilnya, misalnya, mungkin ternyata komponen tingkat tinggi bergantung pada komponen tingkat rendah. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpRequestService</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   constructor(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> xmlhttpService: <span class="hljs-type"><span class="hljs-type">XMLHttpService</span></span>) { }   get(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'GE</span></span>T');   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'POS</span></span>T');   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Di sini, kelas <code>Http</code> adalah komponen tingkat tinggi, dan <code>XMLHttpService</code> adalah komponen tingkat rendah.  Arsitektur seperti itu melanggar klausa A dari prinsip inversi dependensi: ‚ÄúModul tingkat yang lebih tinggi tidak harus bergantung pada modul tingkat yang lebih rendah.  Kedua jenis modul harus bergantung pada abstraksi. " <br><br>  Kelas <code>Http</code> terpaksa bergantung pada kelas <code>XMLHttpService</code> .  Jika kami memutuskan untuk mengubah mekanisme yang digunakan oleh kelas <code>Http</code> untuk berinteraksi dengan jaringan, katakanlah itu akan menjadi layanan Node.js atau, misalnya, layanan rintisan yang digunakan untuk tujuan pengujian, kami harus mengedit semua instance dari kelas <code>Http</code> dengan mengubah kode yang sesuai.  Ini melanggar prinsip keterbukaan-kedekatan. <br><br>  Kelas <code>Http</code> seharusnya tidak tahu persis apa yang digunakan untuk membangun koneksi jaringan.  Oleh karena itu, kami akan membuat antarmuka <code>Connection</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Connection</span></span> {   request(url: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, opts:any); }</code> </pre> <br>  Antarmuka <code>Connection</code> berisi deskripsi metode <code>request</code> dan kami meneruskan argumen tipe <code>Connection</code> ke kelas <code>Http</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> httpConnection: Connection) { }   <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'GET'</span></span>);   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'POST'</span></span>);   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Sekarang, terlepas dari apa yang digunakan untuk mengatur interaksi dengan jaringan, kelas <code>Http</code> dapat menggunakan apa yang diteruskan ke sana, tanpa khawatir tentang apa yang tersembunyi di balik antarmuka <code>Connection</code> . <br><br>  Kami menulis ulang kelas <code>XMLHttpService</code> sehingga mengimplementasikan antarmuka ini: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest();   <span class="hljs-comment"><span class="hljs-comment">//...   request(url: string, opts:any) {       xhr.open();       xhr.send();   } }</span></span></code> </pre> <br>  Sebagai hasilnya, kita dapat membuat banyak kelas yang mengimplementasikan antarmuka <code>Connection</code> dan cocok untuk digunakan di kelas <code>Http</code> untuk mengatur pertukaran data melalui jaringan: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   request(url: string, opts:any) {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class MockHttpService implements Connection {   request(url: string, opts:any) {       //...   } }</span></span></code> </pre> <br>  Seperti yang Anda lihat, di sini modul tingkat tinggi dan tingkat rendah bergantung pada abstraksi.  Kelas <code>Http</code> (modul tingkat tinggi) tergantung pada antarmuka <code>Connection</code> (abstraksi).  Kelas <code>XMLHttpService</code> , <code>NodeHttpService</code> dan <code>MockHttpService</code> (modul tingkat rendah) juga bergantung pada antarmuka <code>Connection</code> . <br><br>  Selain itu, perlu dicatat bahwa mengikuti prinsip inversi ketergantungan, kami mengamati prinsip substitusi Barbara Liskov.  Yaitu, ternyata tipe-tipe <code>XMLHttpService</code> , <code>NodeHttpService</code> dan <code>MockHttpService</code> dapat berfungsi sebagai pengganti <code>Connection</code> tipe dasar. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Di sini kami melihat lima prinsip SOLID yang harus dipatuhi oleh setiap pengembang OOP.  Pada awalnya, ini mungkin tidak mudah, tetapi jika Anda berjuang untuk ini, memperkuat keinginan praktik, prinsip-prinsip ini menjadi bagian alami dari alur kerja, yang memiliki dampak positif besar pada kualitas aplikasi dan sangat memudahkan dukungan mereka. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan prinsip SOLID dalam proyek Anda? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426413/">https://habr.com/ru/post/id426413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426401/index.html">Amazon akan mengajarkan AI-nya untuk mendefinisikan emosi manusia</a></li>
<li><a href="../id426405/index.html">Peretas dalam kerangka hukum Federasi Rusia</a></li>
<li><a href="../id426407/index.html">Bagaimana membuat perjalanan ke konferensi tidak berguna</a></li>
<li><a href="../id426409/index.html">Peretas Alexei, yang melindungi router MikroTik tanpa izin dari pemiliknya, telah menjadi terkenal</a></li>
<li><a href="../id426411/index.html">Mengembangkan Kelas Deskripsi C ++ / CLI</a></li>
<li><a href="../id426415/index.html">Fintech-digest: kontrol digitalisasi oleh Bank Sentral, gaji cryptocurrency, kartu Mir dalam bentuk gelang dan gantungan kunci</a></li>
<li><a href="../id426417/index.html">Pavel 2.0: konsultan reptiloid pada JS, node.js dengan soket dan telepon</a></li>
<li><a href="../id426419/index.html">Metode overload atau jembatan terlarang di Jawa</a></li>
<li><a href="../id426421/index.html">EHCI secara manusiawi dalam bahasa Rusia</a></li>
<li><a href="../id426423/index.html">mmWave pada smartphone: bagaimana Qualcomm membuat yang tidak mungkin menjadi mungkin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>