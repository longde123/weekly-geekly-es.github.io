<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õΩÔ∏è üíÉüèª üåõ Wir schreiben unsere Strategie f√ºr das virtuelle Scrollen von Angular CDK üåπ üêá üòü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! 


 Im Angular CDK erschien in der siebten Version eine virtuelle Schriftrolle . 


 Es funktioniert hervorragend, wenn die Gr√∂√üe der einzelnen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben unsere Strategie f√ºr das virtuelle Scrollen von Angular CDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/484168/"><p>  Hallo! </p><br><p>  Im Angular CDK <a href="https://material.angular.io/cdk/scrolling/overview">erschien</a> in der siebten Version <a href="https://material.angular.io/cdk/scrolling/overview">eine virtuelle Schriftrolle</a> . </p><br><p> Es funktioniert hervorragend, wenn die Gr√∂√üe der einzelnen Elemente gleich ist - und das direkt nach dem Auspacken.  Wir stellen einfach die Gr√∂√üe in Pixel ein und geben an, zu welchem ‚Äã‚ÄãElement der Container scrollen soll, ob dies reibungslos erfolgen soll, und wir k√∂nnen auch den Index des aktuellen Elements abonnieren.  Was ist jedoch, wenn sich die Gr√∂√üe der Elemente √§ndert?  Zu diesem <a href=""><code>VirtualScrollStrategy</code></a> wird im CDK die <a href=""><code>VirtualScrollStrategy</code></a> Schnittstelle bereitgestellt, durch deren Implementierung wir dem Bildlauf beibringen, mit unserer Liste zu arbeiten. </p><br><p>  In meinem Fall musste ein Kalender f√ºr eine mobile Pr√§sentation erstellt werden, der kontinuierlich gescrollt werden kann, und die Anzahl der Wochen in einem Monat ist immer unterschiedlich.  Versuchen wir herauszufinden, was eine virtuelle Bildlaufstrategie ist, und schreiben wir Ihre eigene. </p><br><p><img src="https://habrastorage.org/webt/g9/7b/yo/g97byoqd51-wu9jd8o27awx0-bk.png" alt="Bild"></p><a name="habracut"></a><br><h2 id="raschet-razmerov">  Gr√∂√üenberechnung </h2><br><p>  Wie Sie wissen, werden Kalender alle 28 Jahre wiederholt. </p><br><p>  Dies geschieht, wenn Sie nicht ber√ºcksichtigen, dass das Jahr kein Schaltjahr ist, wenn es durch 100 teilbar ist, aber nicht durch 400. In unserem Fall ben√∂tigen wir keine Jahre vor 1900 und nach 2100. Damit der Januar auf den Montag f√§llt, beginnen wir ab 1900 mit einem geraden Konto, und wir werden es tun 196 Jahre zur√ºckziehen.  Somit gibt es in unserem Kalender 7 Wiederholungszyklen.  Die Abwesenheit des 29. Februar 1900 wird nicht schaden, da es Donnerstag w√§re. </p><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/webt/ss/rr/oq/ssrroq2ub8w57ihutm6vjo1agou.gif"></div><br><p>  Berechnungen werden w√§hrend des Bildlaufs durchgef√ºhrt. Je einfacher die Berechnungen sind, desto h√∂her ist die Leistung.  Dazu erstellen wir eine Schleifenkonstante, die aus 28 Arrays mit 12 Zahlen besteht, die f√ºr die H√∂he jedes Monats verantwortlich sind: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCycle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">label: number, week: number</span></span></span><span class="hljs-function">): ReadonlyArray&lt;ReadonlyArray&lt;number&gt;&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Array.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>({length: <span class="hljs-number"><span class="hljs-number">28</span></span>}, (_, i) =&gt; Array.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>( {length: <span class="hljs-number"><span class="hljs-number">12</span></span>}, (_, month) =&gt; label + weekCount(i, month) * week, ), ); }</code> </pre> <br><p>  Bei der Eingabe erh√§lt diese Funktion die H√∂he des Monats-Titels und die H√∂he einer Woche (64 bzw. 48 Pixel f√ºr das obige GIF).  Die Anzahl der Wochen pro Monat hilft uns dabei, eine so einfache Funktion zu berechnen: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weekCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year: number, month: number</span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstOfMonth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(year + STARTING_YEAR, month, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lastOfMonth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(year + STARTING_YEAR, month + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> days = lastOfMonth.getDate() + (firstOfMonth.getDay() || <span class="hljs-number"><span class="hljs-number">7</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.ceil(days / <span class="hljs-number"><span class="hljs-number">7</span></span>); }</code> </pre> <br><p>  Das Ergebnis wird in der Konstanten <code>const CYCLE = getCycle(64, 48);</code> gespeichert <code>const CYCLE = getCycle(64, 48);</code>  . </p><br><p>  Wir werden eine Funktion schreiben, mit der Sie die H√∂he nach Jahr und Monat innerhalb des Zyklus berechnen k√∂nnen: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceCycle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lastYear: number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">28</span></span></span></span><span class="hljs-function"><span class="hljs-params">, lastMonth: number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">12</span></span></span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CYCLE.reduce( (total, year, yearIndex) =&gt; yearIndex &lt;= lastYear ? total + year.reduce( (sum, month, monthIndex) =&gt; yearIndex &lt; lastYear || (yearIndex === lastYear &amp;&amp; monthIndex &lt; lastMonth) ? sum + month : sum, <span class="hljs-number"><span class="hljs-number">0</span></span>, ) : total, <span class="hljs-number"><span class="hljs-number">0</span></span>, ); }</code> </pre> <br><p>  Wenn wir diese Funktion ohne Argumente aufrufen, erhalten wir die Gr√∂√üe eines Zyklus und k√∂nnen in Zukunft den Einzug f√ºr jeden Monat eines Jahres aus unserem Sortiment oben im Container finden. </p><br><h2 id="virtualscrollstrategy">  VirtualScrollStrategy </h2><br><p>  Sie k√∂nnen Ihre Strategie mit einem Token an einen virtuellen Bildlauf √ºbergeben <br>  <code>VIRTUAL_SCROLL_STRATEGY</code> : </p><br><pre> <code class="cs hljs">{ provide: VIRTUAL_SCROLL_STRATEGY, useClass: MobileCalendarStrategy, },</code> </pre> <br><p>  Unsere Klasse sollte die <code>VirtualScrollStrategy</code> Schnittstelle implementieren: </p><br><pre> <code class="cs hljs">export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">VirtualScrollStrategy</span></span> { scrolledIndexChange: Observable&lt;number&gt;; attach(viewport: CdkVirtualScrollViewport): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; detach(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; onContentScrolled(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; onDataLengthChanged(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; onContentRendered(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; onRenderedOffsetChanged(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; scrollToIndex(index: number, behavior: ScrollBehavior): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }</code> </pre> <br><p>  Die Funktionen zum <code>attach</code> und <code>detach</code> sind f√ºr das Initialisieren und Herunterfahren verantwortlich.  Die f√ºr uns wichtigste <code>onContentScrolled</code> Methode wird jedes Mal aufgerufen, wenn der Benutzer einen Bildlauf durch den Container durchf√ºhrt (Entprellen √ºber <code>requestAnimationFrame</code> intern verwendet, um unn√∂tige Aufrufe zu vermeiden). </p><br><p>  <code>onDataLengthChanged</code> wird aufgerufen, wenn sich die Anzahl der Elemente in der <code>onDataLengthChanged</code> ge√§ndert hat - in unserem Fall wird dies niemals passieren.  In einer solchen Situation ist es in der Regel erforderlich, die Gesamth√∂he und die aktuell angezeigten Elemente erneut zu z√§hlen, und zwar ungef√§hr so, wie dies in der Funktion " <code>attach</code> erforderlich ist. </p><br><p>  <code>onContentRendered</code> und <code>onRenderedOffsetChanged</code> werden aufgerufen, wenn sich der angezeigte Teil der Elemente √§ndert und sich der Einzug zum ersten Element √§ndert.  <code>CdkVirtualScrollViewport</code> greift auf diese Methoden zu, wenn ihm ein neuer Bereich von angezeigten Elementen <code>CdkVirtualScrollViewport</code> und der erste einger√ºckt wird.  Dies ist nicht erforderlich, da <code>CdkVirtualScrollViewport</code> Methoden nicht <code>CdkVirtualScrollViewport</code> werden m√ºssen.  Wenn Sie es ben√∂tigen, <code>onContentRendered</code> Sie in <code>onRenderedOffsetChanged</code> einen neuen Einzug und in <code>onRenderedOffsetChanged</code> den Bereich der sichtbaren Elemente f√ºr den resultierenden Einzug berechnen. </p><br><p>  Die zweite wichtige Methode f√ºr uns - <code>scrollToIndex</code> - erm√∂glicht es Ihnen, den Container zum gew√ºnschten Element zu scrollen, und die gegen√ºberliegende - <code>scrolledIndexChange</code> - erm√∂glicht es, das aktuell sichtbare Element zu verfolgen. </p><br><p>  Zun√§chst erstellen wir alle einfachen Methoden und betrachten dann den Hauptcode: </p><br><pre> <code class="cs hljs">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MobileCalendarStrategy</span></span> <span class="hljs-title"><span class="hljs-title">implements</span></span> <span class="hljs-title"><span class="hljs-title">VirtualScrollStrategy</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> index$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;number&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> viewport: CdkVirtualScrollViewport | <span class="hljs-literal"><span class="hljs-literal">null</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; scrolledIndexChange = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.index$.pipe(distinctUntilChanged()); attach(viewport: CdkVirtualScrollViewport) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport = viewport; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport.setTotalContentSize(CYCLE_HEIGHT * <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateRenderedRange(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport); } detach() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.index$.complete(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } onContentScrolled() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateRenderedRange(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport); } } scrollToIndex(index: number, behavior: ScrollBehavior): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewport.scrollToOffset(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getOffsetForIndex(index), behavior); } } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Um mit der Schriftrolle arbeiten zu k√∂nnen, m√ºssen wir in der Lage sein, den Index eines Elements durch Einr√ºcken abzurufen und umgekehrt durch Einr√ºcken durch einen Index.  Die von <code>reduceCycle</code> Funktion <code>reduceCycle</code> ist f√ºr die erste Aufgabe geeignet: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOffsetForIndex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index: number</span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> month = index % <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> year = (index - month) / <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.computeHeight(year, month); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeHeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year: number, month: number</span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = year % <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainderHeight = reduceCycle(remainder, month); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fullCycles = (year - remainder) / <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fullCyclesHeight = fullCycles * CYCLE_HEIGHT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fullCyclesHeight + remainderHeight; }</code> </pre> <br><p>  Das hei√üt, um die H√∂he nach Index zu ermitteln, ermitteln wir, wie viele vollst√§ndige 28-Jahres-Zyklen zum aktuellen Datum passen, und addieren dann unser Array zum angegebenen Monat.  Der umgekehrte Vorgang ist etwas komplizierter: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIndexForOffset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">offset: number</span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = offset % CYCLE_HEIGHT; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> years = ((offset - remainder) / CYCLE_HEIGHT) * <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> year = <span class="hljs-number"><span class="hljs-number">0</span></span>; year &lt; CYCLE.length; year++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> month = <span class="hljs-number"><span class="hljs-number">0</span></span>; month &lt; CYCLE[year].length; month++) { accumulator += CYCLE[year][month]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (accumulator - CYCLE[year][month] / <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; remainder) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.max((years + year) * MONTHS_IN_YEAR + month, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">196</span></span>; }</code> </pre> <br><p>  Wenn wir die Gesamth√∂he der gesamten 28-Jahres-Zyklen erhalten, iterieren wir √ºber das Array und erfassen die Gesamth√∂he aller Monate, bis sie den gew√ºnschten Einzug √ºberschreitet.  Gleichzeitig √ºberpr√ºfen wir, ob die H√§lfte des Monats ( <code>CYCLE[year][month] / 2</code> ) √ºberschritten wurde, um nicht nur den h√∂chsten sichtbaren, sondern auch den am n√§chsten am oberen Rand liegenden Monat zu ermitteln.  Dies wird in Zukunft f√ºr eine reibungslose Verdrehung zu Beginn des Monats nach Fertigstellung der Schriftrolle ben√∂tigt. </p><br><p>  Es bleibt die wichtigste Funktion zu schreiben, die f√ºr das Rendern der Elemente des sichtbaren Bereichs verantwortlich ist: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRenderedRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">viewport: CdkVirtualScrollViewport</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset = viewport.measureScrollOffset(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> viewportSize = viewport.getViewportSize(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {start, end} = viewport.getRenderedRange(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataLength = viewport.getDataLength(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newRange = {start, end}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstVisibleIndex = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> startBuffer = offset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getOffsetForIndex(start); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startBuffer &lt; BUFFER &amp;&amp; start !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { newRange.start = Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset - BUFFER * <span class="hljs-number"><span class="hljs-number">2</span></span>)); newRange.end = Math.min( dataLength, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset + viewportSize + BUFFER), ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> endBuffer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getOffsetForIndex(end) - offset - viewportSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endBuffer &lt; BUFFER &amp;&amp; end !== dataLength) { newRange.start = Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset - BUFFER)); newRange.end = Math.min( dataLength, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getIndexForOffset(offset + viewportSize + BUFFER * <span class="hljs-number"><span class="hljs-number">2</span></span>), ); } } viewport.setRenderedRange(newRange); viewport.setRenderedContentOffset(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getOffsetForIndex(newRange.start)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.index$.next(firstVisibleIndex); }</code> </pre> <br><p>  Betrachten wir alles in der richtigen Reihenfolge. </p><br><p>  Wir fragen <code>CdkVirtualScrollViewport</code> aktuellen Einzug, der Containergr√∂√üe, dem angezeigten aktuellen Bereich und der Gesamtzahl der Elemente.  Dann finden wir das erste sichtbare Element und den Einzug beim allerersten gerenderten Element. </p><br><p>  Danach m√ºssen wir verstehen, wie der Bereich der aktuellen Elemente ge√§ndert und der erste einger√ºckt wird, damit der virtuelle Bildlauf die Elemente reibungslos l√§dt und beim Neuberechnen der H√∂he nicht zuckt.  Dazu haben wir die <code>BUFFER</code> Konstante, die <code>BUFFER</code> wie viele Pixel vom sichtbaren Bereich aus wir weiterhin Elemente zeichnen.  In meinem Fall verwende ich 500px.  Wenn der obere Einzug kleiner als der Puffer ist und mehr Elemente dar√ºber vorhanden sind, √§ndern wir den Bereich, indem Sie oben gen√ºgend Elemente hinzuf√ºgen, um den Puffer doppelt abzudecken.  Wir passen auch das Ende des Bereichs an.  Da wir nach oben scrollen, reicht ein Puffer unten.  Das gleiche, aber in der entgegengesetzten Richtung f√ºhren wir das Scrollen nach unten durch. </p><br><p>  Dann weisen wir <code>CdkVirtualScrollViewport</code> neuen Bereich zu und betrachten den Einzug f√ºr das erste Element.  Den aktuell sichtbaren Index verteilen. </p><br><h2 id="ispolzovanie">  Verwenden Sie </h2><br><p>  Unsere Strategie ist fertig.  F√ºgen Sie es wie oben gezeigt zu den Komponentenanbietern hinzu und verwenden Sie <code>CdkVirtualScrollViewport</code> in der Vorlage: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cdk-virtual-scroll-viewport</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">scrolledIndexChange</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"activeMonth = $event"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">section</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cdkVirtualFor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"let month of months; templateCacheSize: 10"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>{{month.name}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">our-calendar</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">month</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"month"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">our-calendar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">section</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cdk-virtual-scroll-viewport</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Es bleibt eine sanfte Drehung bis zum n√§chsten Monat am Ende der Schriftrolle zu realisieren.  Es gibt Nuancen. </p><br><p>  Tatsache ist, dass das Scrollen auf Mobilger√§ten fortgesetzt wird, nachdem der Finger die Oberfl√§che freigegeben hat.  Daher ist es f√ºr uns schwierig, den Zeitpunkt zu verstehen, an dem der aktuelle Monat abgeglichen werden muss.  Daf√ºr verwenden wir RxJs.  <code>touchstart</code> Event und warten auf das n√§chste <code>touchend</code> .  Nach dem Einsetzen verwenden wir den Rennoperator, um herauszufinden, ob das Scrollen fortgesetzt wird oder ob der Finger ohne Beschleunigung losgelassen wurde.  Wenn w√§hrend des Zeitraums <code>SCROLL_DEBOUNCE_TIME</code> keine <code>SCROLL_DEBOUNCE_TIME</code> , richten wir den aktuellen Monat aus.  Andernfalls warten wir, bis die Restrolle stoppt.  In diesem Fall m√ºssen Sie <code>takeUntil(touchstart$)</code> hinzuf√ºgen, da der Inertial-Scroll mit einer neuen Ber√ºhrung angehalten werden kann und der gesamte Stream dann zum Anfang zur√ºckkehren sollte: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> touchstart$ = touchStartFrom(monthsScrollRef.elementRef.nativeElement); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> touchend$ = touchEndFrom(monthsScrollRef.elementRef.nativeElement); <span class="hljs-comment"><span class="hljs-comment">// Smooth scroll to closest month after scrolling is done touchstart$ .pipe( switchMap(() =&gt; touchend$), switchMap(() =&gt; race( monthsScrollRef.elementScrolled(), timer(SCROLL_DEBOUNCE_TIME), ).pipe( debounceTime(SCROLL_DEBOUNCE_TIME * 2), take(1), takeUntil(touchstart$), ), ), takeUntil(this.destroy$), ) .subscribe(() =&gt; { monthsScrollRef.scrollToIndex(this.activeMonth, 'smooth'); });</span></span></code> </pre> <br><p>  Hierbei ist zu beachten, dass f√ºr ein reibungsloses Scrollen von <code>scrollToIndex</code> im Angular CDK eine native Implementierung verwendet wird und diese in Safari nicht funktioniert.  Sie k√∂nnen dieses <code>requestAnimationFrame</code> beheben, indem Sie in der Strategie, die wir in der <code>scrollToIndex</code> Methode geschrieben haben, einen glatten <code>requestAnimationFrame</code> durch <code>requestAnimationFrame</code> <code>scrollToIndex</code> . </p><br><h2 id="vyvod">  Fazit </h2><br><p>  Dank des DI und der Umsicht des Angular-Teams konnten wir eine virtuelle Schriftrolle flexibel f√ºr uns konfigurieren.  Auf den ersten Blick erscheint die Implementierung einer virtuellen Schriftrolle f√ºr Elemente mit unterschiedlichen H√∂hen als eine entmutigende Aufgabe. </p><br><p>  Wenn es jedoch m√∂glich ist, die H√∂he jedes Elements zu berechnen, hat sich das Schreiben Ihrer Strategie als recht einfach erwiesen.  Die Hauptsache ist, dass diese Berechnung schnell durchgef√ºhrt wird, da sie oft aufgerufen wird.  Wenn Sie eine gro√üe Anzahl von Karten anzeigen m√ºssen, auf denen sich m√∂glicherweise Elemente befinden, die sich auf ihre H√∂he auswirken, sollten Sie einen effektiven Algorithmus zum Ermitteln der H√∂he in Betracht ziehen und sich nicht scheuen, Ihre Strategie zu schreiben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484168/">https://habr.com/ru/post/de484168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484152/index.html">Hochgeschwindigkeits-PAC-Controller WISE-5580</a></li>
<li><a href="../de484154/index.html">Methode zur L√∂sung des Diophantingleichungssystems</a></li>
<li><a href="../de484160/index.html">Ausweichendes Talent: Russland verliert die besten IT-Experten</a></li>
<li><a href="../de484164/index.html">Die Geschichte der B√ºcher und die Zukunft der Bibliotheken</a></li>
<li><a href="../de484166/index.html">VVVVVV ??? VVVVVV !!! :)</a></li>
<li><a href="../de484170/index.html">Aktualisieren Sie Check Point von R77.30 auf 80.20</a></li>
<li><a href="../de484172/index.html">Kontinuierliche Integration in Unity: Verk√ºrzung der Montagezeit und Einsparung von Ressourcen + Gewinnlinie als Geschenk</a></li>
<li><a href="../de484174/index.html">Castle trinkt unter "extremen" Bedingungen oder wie wir an der "DOZOR" Show teilgenommen haben</a></li>
<li><a href="../de484176/index.html">Implementieren der Statusvorlage in Unity</a></li>
<li><a href="../de484178/index.html">Intelligenter Ethernet-Switch f√ºr Planet Earth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>