<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèª üìû ‚úÖ 9 Tipps zur Verwendung der Katzenbibliothek in Scala üê† üßîüèª üë®üèæ‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die funktionale Programmierung in Scala kann aufgrund einiger syntaktischer und semantischer Merkmale der Sprache schwierig zu beherrschen sein. Insbe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>9 Tipps zur Verwendung der Katzenbibliothek in Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/448128/">  Die funktionale Programmierung in Scala kann aufgrund einiger syntaktischer und semantischer Merkmale der Sprache schwierig zu beherrschen sein.  Insbesondere einige der Sprachwerkzeuge und -methoden zur Implementierung der von Ihnen geplanten Aufgaben mithilfe der Hauptbibliotheken scheinen offensichtlich zu sein, wenn Sie mit ihnen vertraut sind. Zu Beginn des Studiums, insbesondere allein, ist es jedoch nicht so einfach, sie zu erkennen. <br><br>  Aus diesem Grund habe ich beschlossen, dass es n√ºtzlich ist, einige funktionale Programmiertipps in Scala zu teilen.  Beispiele und Namen entsprechen Katzen, aber die Syntax in Scalaz sollte aufgrund der allgemeinen theoretischen Grundlage √§hnlich sein. <br><br><img src="https://habrastorage.org/webt/wf/n0/92/wfn0925sgvde-jv71ogsic_xuwk.jpeg"><br><a name="habracut"></a><br><h3>  <b>9) Konstruktoren der Erweiterungsmethode</b> </h3><br>  Beginnen wir mit den vielleicht grundlegendsten Tool-Erweiterungsmethoden aller Art, die eine Instanz in Option, Entweder usw. verwandeln, insbesondere: <br><br><ul><li> <code>.some</code> und die entsprechende <code>none</code> Konstruktor-Methode f√ºr <code>Option</code> ; </li><li>  <code>.asRight</code> , <code>.asLeft</code> f√ºr <code>.asLeft</code> ; </li><li>  <code>.valid</code> , <code>.invalid</code> , <code>.validNel</code> , <code>.invalidNel</code> f√ºr <code>Validated</code> </li></ul><br>  Zwei Hauptvorteile ihrer Verwendung: <br><br><ol><li>  Es ist kompakter und verst√§ndlicher (da die Reihenfolge der Methodenaufrufe gespeichert ist). </li><li>  Im Gegensatz zu Konstruktoroptionen werden die R√ºckgabetypen dieser Methoden auf einen Supertyp erweitert, d.h. </li></ol><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some[String] "a".some //Option[String]</span></span></code> </pre> <br>  Obwohl sich die Typinferenz im Laufe der Jahre verbessert hat und die Anzahl m√∂glicher Situationen, in denen dieses Verhalten dem Programmierer hilft, ruhig zu bleiben, abgenommen hat, sind Kompilierungsfehler aufgrund √ºberm√§√üig spezialisierter Typisierung in Scala heute noch m√∂glich.  Sehr oft entsteht bei der Arbeit mit <code>Either</code> der Wunsch, den Kopf gegen einen Tisch zu <code>Either</code> (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Scala with Cats,</u></a> Kapitel 4.4.2). <br><br>  Noch etwas zum Thema: <code>.asRight</code> und <code>.asLeft</code> noch einen Typparameter.  Beispiel: <code>"1".asRight[Int]</code> ist <code>Either[Int, String]</code> .  Wenn dieser Parameter nicht angegeben wird, versucht der Compiler, ihn auszugeben und <code>Nothing</code> .  Trotzdem ist es bequemer, als jedes Mal beide Parameter anzugeben oder auch nicht, wie im Fall von Konstruktoren. <br><br><h3>  <b>8) F√ºnfzig Farben *&gt;</b> </h3><br>  Der in einer <code>Apply</code> Methode definierte *&gt; -Operator ( <code>Monad</code> in <code>Applicative</code> , <code>Monad</code> usw.) bedeutet einfach "die anf√§ngliche Berechnung verarbeiten und das Ergebnis durch das ersetzen, was im zweiten Argument angegeben ist".  In der Code-Sprache (im Fall von <code>Monad</code> ): <br><br><pre> <code class="scala hljs">fa.flatMap(_ =&gt; fb)</code> </pre> <br>  Warum sollte ein obskurer symbolischer Operator f√ºr eine Operation verwendet werden, die keinen sp√ºrbaren Effekt hat?  Wenn Sie ApplicativeError und / oder MonadError verwenden, werden Sie feststellen, dass der Vorgang den Fehlereffekt f√ºr den gesamten Workflow beibeh√§lt.  Nehmen Sie <code>Either</code> als Beispiel: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success1 = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success2 = <span class="hljs-string"><span class="hljs-string">"b"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] success1 *&gt; success2 <span class="hljs-comment"><span class="hljs-comment">//Right(b) success2 *&gt; success1 //Right(a) success1 *&gt; failure //Left(400) failure *&gt; success1 //Left(400)</span></span></code> </pre> <br>  Wie Sie sehen, bleibt die Berechnung auch im Fehlerfall kurzgeschlossen.  *&gt; hilft Ihnen bei der Arbeit mit verz√∂gerten Berechnungen in <code>Monix</code> , <code>IO</code> und dergleichen. <br><br>  Es gibt eine symmetrische Operation &lt;*.  Im Fall des vorherigen Beispiels: <br><br><pre> <code class="scala hljs">success1 &lt;* success2 <span class="hljs-comment"><span class="hljs-comment">//Right(a)</span></span></code> </pre> <br>  Wenn Ihnen die Verwendung von Symbolen fremd ist, m√ºssen Sie nicht darauf zur√ºckgreifen.  *&gt; Ist nur ein Alias ‚Äã‚Äãf√ºr <code>productR</code> und * &lt;ist ein Alias ‚Äã‚Äãf√ºr <code>productL</code> . <br><br><h3>  <b>Hinweis</b> </h3><br>  In einem pers√∂nlichen Gespr√§ch bemerkte Adam Warski (danke, Adam!) Zu Recht, dass es neben *&gt; ( <code>productR</code> ) auch &gt;&gt; von <code>FlatMapSyntax</code> .  &gt;&gt; wird wie <code>fa.flatMap(_ =&gt; fb)</code> , jedoch mit zwei Nuancen: <br><br><ul><li>  Es wird unabh√§ngig von <code>productR</code> definiert. Wenn sich daher aus irgendeinem Grund der Vertrag dieser Methode √§ndert (theoretisch kann es ge√§ndert werden, ohne die monadischen Gesetze zu verletzen, aber ich bin mir bei <code>MonadError</code> nicht sicher), werden Sie nicht leiden. </li><li>  was noch wichtiger ist, &gt;&gt; hat einen zweiten Operanden, der durch Call-by-Name aufgerufen wird, d.h.  <code>fb: =&gt; F[B]</code> .  Der Unterschied in der Semantik wird grundlegend, wenn Sie Berechnungen durchf√ºhren, die zu einer Stapelexplosion f√ºhren k√∂nnen. </li></ul><br>  Aus diesem Grund habe ich *&gt; h√§ufiger verwendet.  Vergessen Sie auf die eine oder andere Weise nicht die oben aufgef√ºhrten Faktoren. <br><br><h3>  <b>7) Segel setzen!</b> </h3><br>  Viele nehmen sich Zeit, um das <code>lift</code> in den Kopf zu bekommen.  Aber wenn Sie Erfolg haben, werden Sie feststellen, dass er √ºberall ist. <br><br>  Wie viele Begriffe, die in der Luft der funktionalen Programmierung aufsteigen, stammt der <code>lift</code> aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kategorietheorie</a> .  Ich werde versuchen zu erkl√§ren: Nehmen Sie eine Operation vor und √§ndern Sie die Signatur ihres Typs so, dass sie in direktem Zusammenhang mit dem abstrakten Typ F steht. <br><br>  In Cats ist das einfachste Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Functor</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lift</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = map(_)(f)</code> </pre> <br>  Dies bedeutet: √Ñndern Sie diese Funktion so, dass sie auf den angegebenen Funktortyp F wirkt. <br><br>  Die Lift-Funktion ist h√§ufig gleichbedeutend mit verschachtelten Konstruktoren f√ºr einen bestimmten Typ.  Also ist <code>EitherT.liftF</code> im Wesentlichen <code>EitherT.right.</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel aus Scaladoc</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">EitherT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">EitherT</span></span>.liftF(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some) <span class="hljs-comment"><span class="hljs-comment">//EitherT(Some(Right(a))) EitherT.liftF(none[String]) //EitherT(None)</span></span></code> </pre> <br>  Kirsche auf dem Kuchen: <code>lift</code> √ºberall in der Scala-Standardbibliothek vorhanden.  Das beliebteste (und vielleicht n√ºtzlichste Beispiel f√ºr die t√§gliche Arbeit) ist <code>PartialFunction</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intMatcher: <span class="hljs-type"><span class="hljs-type">PartialFunction</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"jak siƒô masz!"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> liftedIntMatcher: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = intMatcher.lift liftedIntMatcher(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some(jak siƒô masz!) liftedIntMatcher(0) //None intMatcher(1) //jak siƒô masz! intMatcher(0) //Exception in thread "main" scala.MatchError: 0</span></span></code> </pre> <br>  Jetzt k√∂nnen wir zu dringlicheren Themen √ºbergehen. <br><br><h3>  <b>6) mapN</b> </h3><br>  <code>mapN</code> ist eine n√ºtzliche <code>mapN</code> f√ºr die Arbeit mit Tupeln.  Auch dies ist keine Neuheit, sondern ein Ersatz f√ºr den guten alten Operator <code>|@|</code>  Er ist ein Schrei. <br><br>  So sieht mapN bei einem Tupel aus zwei Elementen aus: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// where t2: Tuple2[F[A0], F[A1]] def mapN[Z](f: (A0, A1) =&gt; Z)(implicit functor: Functor[F], semigroupal: Semigroupal[F]): F[Z] = Semigroupal.map2(t2._1, t2._2)(f)</span></span></code> </pre> <br>  Im Wesentlichen k√∂nnen wir Werte innerhalb eines Tupels von jedem F abbilden, das eine Halbgruppe (Produkt) und ein Funktor (Zuordnung) ist.  Also: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ (<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-string"><span class="hljs-string">"b"</span></span>.some).mapN(_ ++ _) <span class="hljs-comment"><span class="hljs-comment">//Some(ab) (List(1, 2), List(3, 4), List(0, 2).mapN(_ * _ * _)) //List(0, 6, 0, 8, 0, 12, 0, 16)</span></span></code> </pre> <br>  Vergessen Sie √ºbrigens nicht, dass Sie bei Katzen eine Karte und eine <code>leftmap</code> f√ºr Tupel erhalten: <br><br><pre> <code class="scala hljs">(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-string"><span class="hljs-string">"b"</span></span>,<span class="hljs-string"><span class="hljs-string">"c"</span></span>).mapN(_ ++ _)) <span class="hljs-comment"><span class="hljs-comment">//won't compile, because outer type is not the same ("a".some, List("b", "c")).leftMap(_.toList).mapN(_ ++ _) //List(ab, ac)</span></span></code> </pre> <br>  Eine weitere n√ºtzliche <code>.mapN</code> Funktion ist das Instanziieren von <code>.mapN</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mead</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, honeyRatio: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-class"><span class="hljs-params">, agingYears: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span></span><span class="hljs-class">) (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">"p√≥≈Çtorak".some, 0.5.some, 3d.some</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapN</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//Some</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span><span class="hljs-class"><span class="hljs-params">(p√≥≈Çtorak,0.5,3.0</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br>  Nat√ºrlich verwenden Sie hierf√ºr lieber den for-Schleifenoperator, aber mapN vermeidet in einfachen F√§llen monadische Transformatoren. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.effect.<span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-comment"><span class="hljs-comment">//interchangable with eg Monix's Task type Query[T] = IO[Option[T]] def defineMead(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = (for { name &lt;- OptionT(qName) honeyRatio &lt;- OptionT(qHoneyRatio) agingYears &lt;- OptionT(qAgingYears) } yield Mead(name, honeyRatio, agingYears)).value def defineMead2(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = for { name &lt;- qName honeyRatio &lt;- qHoneyRatio agingYears &lt;- qAgingYears } yield (name, honeyRatio, agingYears).mapN(Mead)</span></span></code> </pre> <br>  Methoden haben √§hnliche Ergebnisse, aber letztere verzichten auf monadische Transformatoren. <br><br><h3>  <b>5) Verschachtelt</b> </h3><br>  <code>Nested</code> ist im Wesentlichen ein verallgemeinertes Doppel von Monadentransformatoren.  Wie der Name schon sagt, k√∂nnen Sie unter bestimmten Bedingungen Anhangsvorg√§nge ausf√ºhren.  Hier ist ein Beispiel f√ºr <code>.map(_.map( :</code> <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">Nested</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someValue: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]] = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight.some <span class="hljs-type"><span class="hljs-type">Nested</span></span>(someValue).map(_ * <span class="hljs-number"><span class="hljs-number">3</span></span>).value <span class="hljs-comment"><span class="hljs-comment">//Some(Right(aaa))</span></span></code> </pre> <br>  Zus√§tzlich zu <code>Functor</code> verallgemeinert <code>Nested</code> <code>Applicative</code> , <code>ApplicativeError</code> und <code>Traverse</code> .  Weitere Informationen und Beispiele finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  <b>4) .recover / .recoverWith / .handleError / .handleErrorWith / .valueOr</b> </h3><br>  Die funktionale Programmierung in Scala hat viel mit der Behandlung des Fehlereffekts zu tun.  <code>ApplicativeError</code> und <code>MonadError</code> verf√ºgen √ºber einige n√ºtzliche Methoden, und es kann hilfreich sein, die subtilen Unterschiede zwischen den vier Hauptmethoden herauszufinden.  Also, mit <code>ApplicativeError F[A]:</code> <br><br><ul><li>  <code>handleError</code> konvertiert <u>alle</u> Fehler am <code>handleError</code> gem√§√ü der angegebenen Funktion in A. </li><li>  <code>recover</code> funktioniert auf √§hnliche Weise, akzeptiert jedoch Teilfunktionen und kann daher von Ihnen ausgew√§hlte Fehler in A konvertieren. </li><li>  <code>handleErrorWith</code> √§hnelt <code>handleError</code> , das Ergebnis sollte jedoch wie <code>F[A]</code> aussehen. Dies bedeutet, dass Sie Fehler konvertieren k√∂nnen. </li><li>  <code>recoverWith</code> wie "Wiederherstellen", erfordert jedoch als Ergebnis auch <code>F[A]</code> . </li></ul><br>  Wie Sie sehen, k√∂nnen <code>handleErrorWith</code> auf die <code>handleErrorWith</code> von <code>handleErrorWith</code> und <code>recoverWith</code> , die alle m√∂glichen Funktionen abdecken.  Jede Methode hat jedoch ihre Vorteile und ist auf ihre Weise bequem. <br><br>  Im Allgemeinen empfehle ich Ihnen, sich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ApplicativeError-</a> API vertraut zu machen, die eine der reichsten an Katzen ist und von MonadError geerbt wird. Dies bedeutet, dass sie in <code>cats.effect.IO</code> , <code>monix.Task</code> usw. unterst√ºtzt wird. <br><br>  Es gibt eine andere Methode f√ºr <code>Either/EitherT</code> , <code>Validated</code> und <code>Ior</code> - <code>.valueOr</code> .  Im Wesentlichen funktioniert es wie <code>.getOrElse</code> f√ºr <code>Option</code> , ist jedoch generisch f√ºr Klassen, die etwas ‚Äûlinks‚Äú enthalten. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] failure.valueOr(code =&gt; <span class="hljs-string"><span class="hljs-string">s"Got error code </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$code</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//"Got error code 400"</span></span></code> </pre> <br><h3>  <b>3) Gassenkatzen</b> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gassenkatzen</a> sind eine bequeme L√∂sung f√ºr zwei F√§lle: <br><br><ul><li>  F√§lle von Kachelklassen, die ihren Gesetzen nicht zu 100% entsprechen; </li><li>  Ungew√∂hnliche Hilfstypklassik, die richtig verwendet werden kann. </li></ul><br>  Historisch gesehen ist die Monadeninstanz f√ºr <code>Try</code> beliebteste in diesem Projekt, da <code>Try</code> , wie Sie wissen, nicht alle monadischen Gesetze in Bezug auf schwerwiegende Fehler erf√ºllt.  Jetzt ist er wirklich mit Katzen bekannt. <br><br>  Trotzdem empfehle ich Ihnen, sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>diesem Modul</u></a> vertraut zu machen. Es scheint Ihnen n√ºtzlich zu sein. <br><br><h3>  <b>2) Importe verantwortungsbewusst behandeln</b> </h3><br>  Sie m√ºssen aus der Dokumentation, dem Buch oder von einem anderen Ort wissen, dass Katzen eine bestimmte Importhierarchie verwenden: <br><br>  <code>cats.x</code> f√ºr grundlegende (Kernel-) Typen; <br>  <code>cats.data</code> f√ºr Datentypen wie Validiert, Monadentransformatoren usw.; <br>  cat.syntax.x._ zur Unterst√ºtzung von Erweiterungsmethoden, damit Sie sth.asRight, sth.pure usw. aufrufen k√∂nnen; <br> <code>cats.instances.x.</code>  _ um die Implementierung verschiedener Typklassen direkt in den impliziten Bereich f√ºr einzelne spezifische Typen zu importieren, sodass beim Aufrufen von beispielsweise sth.pure der Fehler "implizit nicht gefunden" nicht auftritt. <br><br>  Nat√ºrlich haben Sie den Import von <code>cats.implicits._</code> bemerkt, der die gesamte Syntax und alle Instanzen der Typklasse im impliziten Bereich importiert. <br><br>  Grunds√§tzlich sollten Sie bei der Entwicklung mit Cats mit einer bestimmten Reihenfolge von Importen aus den FAQ beginnen, n√§mlich: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._</code> </pre> <br>  Wenn Sie die Bibliothek besser kennenlernen, k√∂nnen Sie sie nach Ihrem Geschmack kombinieren.  Befolgen Sie eine einfache Regel: <br><br><ul><li>  <code>cats.syntax.x</code> bietet eine Erweiterungssyntax f√ºr x. </li><li>  <code>cats.instances.x</code> bietet <code>cats.instances.x</code> . </li></ul><br>  Wenn Sie beispielsweise <code>.asRight</code> ben√∂tigen, eine Erweiterungsmethode f√ºr <code>Either</code> , gehen Sie wie folgt vor: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.either._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Right[Int, String](a)</span></span></code> </pre> <br>  Um <code>Option.pure</code> zu erhalten, <code>Option.pure</code> Sie jedoch <code>cats.syntax.monad</code> <b>AND</b> <code>cats.instances.option</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.applicative._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.instances.option._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.pure[<span class="hljs-type"><span class="hljs-type">Option</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Some(a)</span></span></code> </pre> <br>  Durch manuelles Optimieren Ihres Imports begrenzen Sie implizite Bereiche in Ihren Scala-Dateien und reduzieren dadurch die Kompilierungszeit. <br><br>  Bitte tun Sie dies jedoch nicht, wenn die folgenden Bedingungen nicht erf√ºllt sind: <br><br><ul><li>  Sie haben Cats bereits gut gemeistert </li><li>  Ihr Team besitzt die Bibliothek auf derselben Ebene </li></ul><br>  Warum?  Weil: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   `pure`, //    import cats.implicits._ import cats.instances.option._ "a".pure[Option] //could not find implicit value for parameter F: cats.Applicative[Option]</span></span></code> </pre> <br>  Dies liegt daran, dass sowohl <code>cats.implicits</code> als auch <code>cats.instances.option</code> Erweiterungen von <code>cats.instances.OptionInstances</code> .  Tats√§chlich importieren wir den impliziten Bereich zweimal, als wir den Compiler verwirren. <br><br>  Dar√ºber hinaus gibt es keine Magie in der Hierarchie der Impliziten - dies ist eine klare Folge von Typerweiterungen.  Sie m√ºssen sich nur auf die Definition von <code>cats.implicits</code> beziehen und die <code>cats.implicits</code> untersuchen. <br><br>  F√ºr 10-20 Minuten k√∂nnen Sie es genug studieren, um Probleme wie diese zu vermeiden - glauben Sie mir, diese Investition wird sich definitiv auszahlen. <br><br><h3>  <b>1) Vergessen Sie nicht die Katzen-Updates!</b> </h3><br>  Sie denken vielleicht, Ihre FP-Bibliothek ist zeitlos, aber tats√§chlich werden <code>cats</code> und <code>scalaz</code> aktiv aktualisiert.  Nehmen Sie als Beispiel Katzen.  Hier sind nur die neuesten √Ñnderungen: <br><br><ul><li>  Jetzt m√ºssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie bei Verwendung von raiseError keine Throwable-Ausnahme zuweisen</a> . </li><li>  Jetzt gibt es Instanzen f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Duration</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FiniteDuration. Dies</a> bedeutet, dass Sie d1&gt; d2 verwenden k√∂nnen, ohne externe Bibliotheken zu verwenden. </li><li>  sowie eine Reihe anderer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleiner und gro√üer Innovationen</a> . </li></ul><br>  Vergessen Sie daher bei der Arbeit mit Projekten nicht, die Bibliotheksversion zu √ºberpr√ºfen, die Hinweise f√ºr neue Versionen zu lesen und rechtzeitig zu aktualisieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448128/">https://habr.com/ru/post/de448128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448118/index.html">SEO und kontextbezogene Werbung - f√ºhrt f√ºr 175.000 Rubel pro Tag in Ischewsk</a></li>
<li><a href="../de448120/index.html">√úber die N√§he der Gipfel</a></li>
<li><a href="../de448122/index.html">Wie ReactJS funktioniert Reaktionspaket</a></li>
<li><a href="../de448124/index.html">Mikrotik. SMS-Steuerung √ºber WEB-Server</a></li>
<li><a href="../de448126/index.html">Geheimnisse der API von Android-Ger√§ten. Yandex-Bericht</a></li>
<li><a href="../de448130/index.html">Deckbuilding-Design f√ºr Videospiele</a></li>
<li><a href="../de448136/index.html">Anleitung: Testen von Ansible-Rollen und Informieren √ºber Probleme vor der Produktion</a></li>
<li><a href="../de448140/index.html">SNA Hackathon 2019 - Ergebnisse</a></li>
<li><a href="../de448142/index.html">Wo Beweise, Fakten und Vorstellungskraft zusammenlaufen</a></li>
<li><a href="../de448144/index.html">NASA: Genetische Ver√§nderungen durch Raumfahrt sind vor√ºbergehend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>