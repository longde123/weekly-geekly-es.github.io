<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏻 📞 ✅ 9 Tipps zur Verwendung der Katzenbibliothek in Scala 🐠 🧔🏻 👨🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die funktionale Programmierung in Scala kann aufgrund einiger syntaktischer und semantischer Merkmale der Sprache schwierig zu beherrschen sein. Insbe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>9 Tipps zur Verwendung der Katzenbibliothek in Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/448128/">  Die funktionale Programmierung in Scala kann aufgrund einiger syntaktischer und semantischer Merkmale der Sprache schwierig zu beherrschen sein.  Insbesondere einige der Sprachwerkzeuge und -methoden zur Implementierung der von Ihnen geplanten Aufgaben mithilfe der Hauptbibliotheken scheinen offensichtlich zu sein, wenn Sie mit ihnen vertraut sind. Zu Beginn des Studiums, insbesondere allein, ist es jedoch nicht so einfach, sie zu erkennen. <br><br>  Aus diesem Grund habe ich beschlossen, dass es nützlich ist, einige funktionale Programmiertipps in Scala zu teilen.  Beispiele und Namen entsprechen Katzen, aber die Syntax in Scalaz sollte aufgrund der allgemeinen theoretischen Grundlage ähnlich sein. <br><br><img src="https://habrastorage.org/webt/wf/n0/92/wfn0925sgvde-jv71ogsic_xuwk.jpeg"><br><a name="habracut"></a><br><h3>  <b>9) Konstruktoren der Erweiterungsmethode</b> </h3><br>  Beginnen wir mit den vielleicht grundlegendsten Tool-Erweiterungsmethoden aller Art, die eine Instanz in Option, Entweder usw. verwandeln, insbesondere: <br><br><ul><li> <code>.some</code> und die entsprechende <code>none</code> Konstruktor-Methode für <code>Option</code> ; </li><li>  <code>.asRight</code> , <code>.asLeft</code> für <code>.asLeft</code> ; </li><li>  <code>.valid</code> , <code>.invalid</code> , <code>.validNel</code> , <code>.invalidNel</code> für <code>Validated</code> </li></ul><br>  Zwei Hauptvorteile ihrer Verwendung: <br><br><ol><li>  Es ist kompakter und verständlicher (da die Reihenfolge der Methodenaufrufe gespeichert ist). </li><li>  Im Gegensatz zu Konstruktoroptionen werden die Rückgabetypen dieser Methoden auf einen Supertyp erweitert, d.h. </li></ol><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some[String] "a".some //Option[String]</span></span></code> </pre> <br>  Obwohl sich die Typinferenz im Laufe der Jahre verbessert hat und die Anzahl möglicher Situationen, in denen dieses Verhalten dem Programmierer hilft, ruhig zu bleiben, abgenommen hat, sind Kompilierungsfehler aufgrund übermäßig spezialisierter Typisierung in Scala heute noch möglich.  Sehr oft entsteht bei der Arbeit mit <code>Either</code> der Wunsch, den Kopf gegen einen Tisch zu <code>Either</code> (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>Scala with Cats,</u></a> Kapitel 4.4.2). <br><br>  Noch etwas zum Thema: <code>.asRight</code> und <code>.asLeft</code> noch einen Typparameter.  Beispiel: <code>"1".asRight[Int]</code> ist <code>Either[Int, String]</code> .  Wenn dieser Parameter nicht angegeben wird, versucht der Compiler, ihn auszugeben und <code>Nothing</code> .  Trotzdem ist es bequemer, als jedes Mal beide Parameter anzugeben oder auch nicht, wie im Fall von Konstruktoren. <br><br><h3>  <b>8) Fünfzig Farben *&gt;</b> </h3><br>  Der in einer <code>Apply</code> Methode definierte *&gt; -Operator ( <code>Monad</code> in <code>Applicative</code> , <code>Monad</code> usw.) bedeutet einfach "die anfängliche Berechnung verarbeiten und das Ergebnis durch das ersetzen, was im zweiten Argument angegeben ist".  In der Code-Sprache (im Fall von <code>Monad</code> ): <br><br><pre> <code class="scala hljs">fa.flatMap(_ =&gt; fb)</code> </pre> <br>  Warum sollte ein obskurer symbolischer Operator für eine Operation verwendet werden, die keinen spürbaren Effekt hat?  Wenn Sie ApplicativeError und / oder MonadError verwenden, werden Sie feststellen, dass der Vorgang den Fehlereffekt für den gesamten Workflow beibehält.  Nehmen Sie <code>Either</code> als Beispiel: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success1 = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success2 = <span class="hljs-string"><span class="hljs-string">"b"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] success1 *&gt; success2 <span class="hljs-comment"><span class="hljs-comment">//Right(b) success2 *&gt; success1 //Right(a) success1 *&gt; failure //Left(400) failure *&gt; success1 //Left(400)</span></span></code> </pre> <br>  Wie Sie sehen, bleibt die Berechnung auch im Fehlerfall kurzgeschlossen.  *&gt; hilft Ihnen bei der Arbeit mit verzögerten Berechnungen in <code>Monix</code> , <code>IO</code> und dergleichen. <br><br>  Es gibt eine symmetrische Operation &lt;*.  Im Fall des vorherigen Beispiels: <br><br><pre> <code class="scala hljs">success1 &lt;* success2 <span class="hljs-comment"><span class="hljs-comment">//Right(a)</span></span></code> </pre> <br>  Wenn Ihnen die Verwendung von Symbolen fremd ist, müssen Sie nicht darauf zurückgreifen.  *&gt; Ist nur ein Alias ​​für <code>productR</code> und * &lt;ist ein Alias ​​für <code>productL</code> . <br><br><h3>  <b>Hinweis</b> </h3><br>  In einem persönlichen Gespräch bemerkte Adam Warski (danke, Adam!) Zu Recht, dass es neben *&gt; ( <code>productR</code> ) auch &gt;&gt; von <code>FlatMapSyntax</code> .  &gt;&gt; wird wie <code>fa.flatMap(_ =&gt; fb)</code> , jedoch mit zwei Nuancen: <br><br><ul><li>  Es wird unabhängig von <code>productR</code> definiert. Wenn sich daher aus irgendeinem Grund der Vertrag dieser Methode ändert (theoretisch kann es geändert werden, ohne die monadischen Gesetze zu verletzen, aber ich bin mir bei <code>MonadError</code> nicht sicher), werden Sie nicht leiden. </li><li>  was noch wichtiger ist, &gt;&gt; hat einen zweiten Operanden, der durch Call-by-Name aufgerufen wird, d.h.  <code>fb: =&gt; F[B]</code> .  Der Unterschied in der Semantik wird grundlegend, wenn Sie Berechnungen durchführen, die zu einer Stapelexplosion führen können. </li></ul><br>  Aus diesem Grund habe ich *&gt; häufiger verwendet.  Vergessen Sie auf die eine oder andere Weise nicht die oben aufgeführten Faktoren. <br><br><h3>  <b>7) Segel setzen!</b> </h3><br>  Viele nehmen sich Zeit, um das <code>lift</code> in den Kopf zu bekommen.  Aber wenn Sie Erfolg haben, werden Sie feststellen, dass er überall ist. <br><br>  Wie viele Begriffe, die in der Luft der funktionalen Programmierung aufsteigen, stammt der <code>lift</code> aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kategorietheorie</a> .  Ich werde versuchen zu erklären: Nehmen Sie eine Operation vor und ändern Sie die Signatur ihres Typs so, dass sie in direktem Zusammenhang mit dem abstrakten Typ F steht. <br><br>  In Cats ist das einfachste Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Functor</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lift</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = map(_)(f)</code> </pre> <br>  Dies bedeutet: Ändern Sie diese Funktion so, dass sie auf den angegebenen Funktortyp F wirkt. <br><br>  Die Lift-Funktion ist häufig gleichbedeutend mit verschachtelten Konstruktoren für einen bestimmten Typ.  Also ist <code>EitherT.liftF</code> im Wesentlichen <code>EitherT.right.</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel aus Scaladoc</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">EitherT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">EitherT</span></span>.liftF(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some) <span class="hljs-comment"><span class="hljs-comment">//EitherT(Some(Right(a))) EitherT.liftF(none[String]) //EitherT(None)</span></span></code> </pre> <br>  Kirsche auf dem Kuchen: <code>lift</code> überall in der Scala-Standardbibliothek vorhanden.  Das beliebteste (und vielleicht nützlichste Beispiel für die tägliche Arbeit) ist <code>PartialFunction</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intMatcher: <span class="hljs-type"><span class="hljs-type">PartialFunction</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"jak się masz!"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> liftedIntMatcher: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = intMatcher.lift liftedIntMatcher(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some(jak się masz!) liftedIntMatcher(0) //None intMatcher(1) //jak się masz! intMatcher(0) //Exception in thread "main" scala.MatchError: 0</span></span></code> </pre> <br>  Jetzt können wir zu dringlicheren Themen übergehen. <br><br><h3>  <b>6) mapN</b> </h3><br>  <code>mapN</code> ist eine nützliche <code>mapN</code> für die Arbeit mit Tupeln.  Auch dies ist keine Neuheit, sondern ein Ersatz für den guten alten Operator <code>|@|</code>  Er ist ein Schrei. <br><br>  So sieht mapN bei einem Tupel aus zwei Elementen aus: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// where t2: Tuple2[F[A0], F[A1]] def mapN[Z](f: (A0, A1) =&gt; Z)(implicit functor: Functor[F], semigroupal: Semigroupal[F]): F[Z] = Semigroupal.map2(t2._1, t2._2)(f)</span></span></code> </pre> <br>  Im Wesentlichen können wir Werte innerhalb eines Tupels von jedem F abbilden, das eine Halbgruppe (Produkt) und ein Funktor (Zuordnung) ist.  Also: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ (<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-string"><span class="hljs-string">"b"</span></span>.some).mapN(_ ++ _) <span class="hljs-comment"><span class="hljs-comment">//Some(ab) (List(1, 2), List(3, 4), List(0, 2).mapN(_ * _ * _)) //List(0, 6, 0, 8, 0, 12, 0, 16)</span></span></code> </pre> <br>  Vergessen Sie übrigens nicht, dass Sie bei Katzen eine Karte und eine <code>leftmap</code> für Tupel erhalten: <br><br><pre> <code class="scala hljs">(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-string"><span class="hljs-string">"b"</span></span>,<span class="hljs-string"><span class="hljs-string">"c"</span></span>).mapN(_ ++ _)) <span class="hljs-comment"><span class="hljs-comment">//won't compile, because outer type is not the same ("a".some, List("b", "c")).leftMap(_.toList).mapN(_ ++ _) //List(ab, ac)</span></span></code> </pre> <br>  Eine weitere nützliche <code>.mapN</code> Funktion ist das Instanziieren von <code>.mapN</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mead</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, honeyRatio: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-class"><span class="hljs-params">, agingYears: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span></span><span class="hljs-class">) (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">"półtorak".some, 0.5.some, 3d.some</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapN</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//Some</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span><span class="hljs-class"><span class="hljs-params">(półtorak,0.5,3.0</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br>  Natürlich verwenden Sie hierfür lieber den for-Schleifenoperator, aber mapN vermeidet in einfachen Fällen monadische Transformatoren. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.effect.<span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-comment"><span class="hljs-comment">//interchangable with eg Monix's Task type Query[T] = IO[Option[T]] def defineMead(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = (for { name &lt;- OptionT(qName) honeyRatio &lt;- OptionT(qHoneyRatio) agingYears &lt;- OptionT(qAgingYears) } yield Mead(name, honeyRatio, agingYears)).value def defineMead2(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = for { name &lt;- qName honeyRatio &lt;- qHoneyRatio agingYears &lt;- qAgingYears } yield (name, honeyRatio, agingYears).mapN(Mead)</span></span></code> </pre> <br>  Methoden haben ähnliche Ergebnisse, aber letztere verzichten auf monadische Transformatoren. <br><br><h3>  <b>5) Verschachtelt</b> </h3><br>  <code>Nested</code> ist im Wesentlichen ein verallgemeinertes Doppel von Monadentransformatoren.  Wie der Name schon sagt, können Sie unter bestimmten Bedingungen Anhangsvorgänge ausführen.  Hier ist ein Beispiel für <code>.map(_.map( :</code> <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">Nested</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someValue: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]] = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight.some <span class="hljs-type"><span class="hljs-type">Nested</span></span>(someValue).map(_ * <span class="hljs-number"><span class="hljs-number">3</span></span>).value <span class="hljs-comment"><span class="hljs-comment">//Some(Right(aaa))</span></span></code> </pre> <br>  Zusätzlich zu <code>Functor</code> verallgemeinert <code>Nested</code> <code>Applicative</code> , <code>ApplicativeError</code> und <code>Traverse</code> .  Weitere Informationen und Beispiele finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  <b>4) .recover / .recoverWith / .handleError / .handleErrorWith / .valueOr</b> </h3><br>  Die funktionale Programmierung in Scala hat viel mit der Behandlung des Fehlereffekts zu tun.  <code>ApplicativeError</code> und <code>MonadError</code> verfügen über einige nützliche Methoden, und es kann hilfreich sein, die subtilen Unterschiede zwischen den vier Hauptmethoden herauszufinden.  Also, mit <code>ApplicativeError F[A]:</code> <br><br><ul><li>  <code>handleError</code> konvertiert <u>alle</u> Fehler am <code>handleError</code> gemäß der angegebenen Funktion in A. </li><li>  <code>recover</code> funktioniert auf ähnliche Weise, akzeptiert jedoch Teilfunktionen und kann daher von Ihnen ausgewählte Fehler in A konvertieren. </li><li>  <code>handleErrorWith</code> ähnelt <code>handleError</code> , das Ergebnis sollte jedoch wie <code>F[A]</code> aussehen. Dies bedeutet, dass Sie Fehler konvertieren können. </li><li>  <code>recoverWith</code> wie "Wiederherstellen", erfordert jedoch als Ergebnis auch <code>F[A]</code> . </li></ul><br>  Wie Sie sehen, können <code>handleErrorWith</code> auf die <code>handleErrorWith</code> von <code>handleErrorWith</code> und <code>recoverWith</code> , die alle möglichen Funktionen abdecken.  Jede Methode hat jedoch ihre Vorteile und ist auf ihre Weise bequem. <br><br>  Im Allgemeinen empfehle ich Ihnen, sich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ApplicativeError-</a> API vertraut zu machen, die eine der reichsten an Katzen ist und von MonadError geerbt wird. Dies bedeutet, dass sie in <code>cats.effect.IO</code> , <code>monix.Task</code> usw. unterstützt wird. <br><br>  Es gibt eine andere Methode für <code>Either/EitherT</code> , <code>Validated</code> und <code>Ior</code> - <code>.valueOr</code> .  Im Wesentlichen funktioniert es wie <code>.getOrElse</code> für <code>Option</code> , ist jedoch generisch für Klassen, die etwas „links“ enthalten. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] failure.valueOr(code =&gt; <span class="hljs-string"><span class="hljs-string">s"Got error code </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$code</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//"Got error code 400"</span></span></code> </pre> <br><h3>  <b>3) Gassenkatzen</b> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gassenkatzen</a> sind eine bequeme Lösung für zwei Fälle: <br><br><ul><li>  Fälle von Kachelklassen, die ihren Gesetzen nicht zu 100% entsprechen; </li><li>  Ungewöhnliche Hilfstypklassik, die richtig verwendet werden kann. </li></ul><br>  Historisch gesehen ist die Monadeninstanz für <code>Try</code> beliebteste in diesem Projekt, da <code>Try</code> , wie Sie wissen, nicht alle monadischen Gesetze in Bezug auf schwerwiegende Fehler erfüllt.  Jetzt ist er wirklich mit Katzen bekannt. <br><br>  Trotzdem empfehle ich Ihnen, sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>diesem Modul</u></a> vertraut zu machen. Es scheint Ihnen nützlich zu sein. <br><br><h3>  <b>2) Importe verantwortungsbewusst behandeln</b> </h3><br>  Sie müssen aus der Dokumentation, dem Buch oder von einem anderen Ort wissen, dass Katzen eine bestimmte Importhierarchie verwenden: <br><br>  <code>cats.x</code> für grundlegende (Kernel-) Typen; <br>  <code>cats.data</code> für Datentypen wie Validiert, Monadentransformatoren usw.; <br>  cat.syntax.x._ zur Unterstützung von Erweiterungsmethoden, damit Sie sth.asRight, sth.pure usw. aufrufen können; <br> <code>cats.instances.x.</code>  _ um die Implementierung verschiedener Typklassen direkt in den impliziten Bereich für einzelne spezifische Typen zu importieren, sodass beim Aufrufen von beispielsweise sth.pure der Fehler "implizit nicht gefunden" nicht auftritt. <br><br>  Natürlich haben Sie den Import von <code>cats.implicits._</code> bemerkt, der die gesamte Syntax und alle Instanzen der Typklasse im impliziten Bereich importiert. <br><br>  Grundsätzlich sollten Sie bei der Entwicklung mit Cats mit einer bestimmten Reihenfolge von Importen aus den FAQ beginnen, nämlich: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._</code> </pre> <br>  Wenn Sie die Bibliothek besser kennenlernen, können Sie sie nach Ihrem Geschmack kombinieren.  Befolgen Sie eine einfache Regel: <br><br><ul><li>  <code>cats.syntax.x</code> bietet eine Erweiterungssyntax für x. </li><li>  <code>cats.instances.x</code> bietet <code>cats.instances.x</code> . </li></ul><br>  Wenn Sie beispielsweise <code>.asRight</code> benötigen, eine Erweiterungsmethode für <code>Either</code> , gehen Sie wie folgt vor: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.either._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Right[Int, String](a)</span></span></code> </pre> <br>  Um <code>Option.pure</code> zu erhalten, <code>Option.pure</code> Sie jedoch <code>cats.syntax.monad</code> <b>AND</b> <code>cats.instances.option</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.applicative._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.instances.option._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.pure[<span class="hljs-type"><span class="hljs-type">Option</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Some(a)</span></span></code> </pre> <br>  Durch manuelles Optimieren Ihres Imports begrenzen Sie implizite Bereiche in Ihren Scala-Dateien und reduzieren dadurch die Kompilierungszeit. <br><br>  Bitte tun Sie dies jedoch nicht, wenn die folgenden Bedingungen nicht erfüllt sind: <br><br><ul><li>  Sie haben Cats bereits gut gemeistert </li><li>  Ihr Team besitzt die Bibliothek auf derselben Ebene </li></ul><br>  Warum?  Weil: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   `pure`, //    import cats.implicits._ import cats.instances.option._ "a".pure[Option] //could not find implicit value for parameter F: cats.Applicative[Option]</span></span></code> </pre> <br>  Dies liegt daran, dass sowohl <code>cats.implicits</code> als auch <code>cats.instances.option</code> Erweiterungen von <code>cats.instances.OptionInstances</code> .  Tatsächlich importieren wir den impliziten Bereich zweimal, als wir den Compiler verwirren. <br><br>  Darüber hinaus gibt es keine Magie in der Hierarchie der Impliziten - dies ist eine klare Folge von Typerweiterungen.  Sie müssen sich nur auf die Definition von <code>cats.implicits</code> beziehen und die <code>cats.implicits</code> untersuchen. <br><br>  Für 10-20 Minuten können Sie es genug studieren, um Probleme wie diese zu vermeiden - glauben Sie mir, diese Investition wird sich definitiv auszahlen. <br><br><h3>  <b>1) Vergessen Sie nicht die Katzen-Updates!</b> </h3><br>  Sie denken vielleicht, Ihre FP-Bibliothek ist zeitlos, aber tatsächlich werden <code>cats</code> und <code>scalaz</code> aktiv aktualisiert.  Nehmen Sie als Beispiel Katzen.  Hier sind nur die neuesten Änderungen: <br><br><ul><li>  Jetzt müssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie bei Verwendung von raiseError keine Throwable-Ausnahme zuweisen</a> . </li><li>  Jetzt gibt es Instanzen für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Duration</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FiniteDuration. Dies</a> bedeutet, dass Sie d1&gt; d2 verwenden können, ohne externe Bibliotheken zu verwenden. </li><li>  sowie eine Reihe anderer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleiner und großer Innovationen</a> . </li></ul><br>  Vergessen Sie daher bei der Arbeit mit Projekten nicht, die Bibliotheksversion zu überprüfen, die Hinweise für neue Versionen zu lesen und rechtzeitig zu aktualisieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448128/">https://habr.com/ru/post/de448128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448118/index.html">SEO und kontextbezogene Werbung - führt für 175.000 Rubel pro Tag in Ischewsk</a></li>
<li><a href="../de448120/index.html">Über die Nähe der Gipfel</a></li>
<li><a href="../de448122/index.html">Wie ReactJS funktioniert Reaktionspaket</a></li>
<li><a href="../de448124/index.html">Mikrotik. SMS-Steuerung über WEB-Server</a></li>
<li><a href="../de448126/index.html">Geheimnisse der API von Android-Geräten. Yandex-Bericht</a></li>
<li><a href="../de448130/index.html">Deckbuilding-Design für Videospiele</a></li>
<li><a href="../de448136/index.html">Anleitung: Testen von Ansible-Rollen und Informieren über Probleme vor der Produktion</a></li>
<li><a href="../de448140/index.html">SNA Hackathon 2019 - Ergebnisse</a></li>
<li><a href="../de448142/index.html">Wo Beweise, Fakten und Vorstellungskraft zusammenlaufen</a></li>
<li><a href="../de448144/index.html">NASA: Genetische Veränderungen durch Raumfahrt sind vorübergehend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>