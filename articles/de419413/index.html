<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ∑Ô∏è üòõ üè∞ Mei√üel - (nicht ganz) ein neuer Ansatz zur Entwicklung der digitalen Logik ü•© üëÇüèΩ üò°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit der Entwicklung der Mikroelektronik sind RTL-Designs immer mehr geworden. Die Wiederverwendbarkeit von Verilog-Code ist selbst bei Generierungs-, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mei√üel - (nicht ganz) ein neuer Ansatz zur Entwicklung der digitalen Logik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419413/"><p><img src="https://habrastorage.org/webt/ka/wc/b5/kawcb52amqtfs9chlivqku8sj-a.jpeg"></p><br><p>  Mit der Entwicklung der Mikroelektronik sind RTL-Designs immer mehr geworden.  Die Wiederverwendbarkeit von Verilog-Code ist selbst bei Generierungs-, Makro- und System-Verilog-Chips sehr unpraktisch.  Chisel erm√∂glicht es jedoch, die volle Leistungsf√§higkeit der Objekt- und Funktionsprogrammierung auf die RTL-Entwicklung anzuwenden. Dies ist ein lang erwarteter Schritt, der die Lungen von ASIC- und FPGA-Entwicklern mit frischer Luft f√ºllen kann. </p><br><p>  Dieser Artikel gibt einen kurzen √úberblick √ºber die Hauptfunktionen und ber√ºcksichtigt einige Anwendungsf√§lle der Benutzer. Wir werden auch auf die M√§ngel dieser Sprache eingehen.  Wenn das Thema in Zukunft interessant ist, setzen wir den Artikel in detaillierteren Tutorials fort. </p><a name="habracut"></a><br><h3 id="sistemnye-trebovaniya">  Systemanforderungen </h3><br><ul><li>  Scala Basisniveau </li><li>  Verilog und die Grundprinzipien f√ºr die Erstellung digitaler Designs. </li><li>  Halten Sie die Mei√üeldokumentation bereit </li></ul><br><p>  Ich werde versuchen, die Grundlagen des Mei√üelns anhand einfacher Beispiele zu verstehen, aber wenn etwas nicht klar ist, k√∂nnen Sie hier einen Blick darauf werfen. </p><br><p>  Was Scala betrifft, kann dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spickzettel</a> f√ºr einen schnellen Tauchgang hilfreich sein. </p><br><p>  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt einen</a> √§hnlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºr Mei√üel</a> . </p><br><p>  Den vollst√§ndigen Artikelcode (in Form eines Scala-Sbt-Projekts) finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> . </p><br><h3 id="prostoy-schetchik">  Einfacher Z√§hler </h3><br><p>  Wie der Name schon sagt, ist der Mei√üel "Hardware in einer eingebetteten Scala erstellen" eine Hardwarebeschreibungssprache, die auf der Scala aufbaut. </p><br><p>  Kurz gesagt, wie alles funktioniert: Aus der RTL-Beschreibung auf dem Mei√üel wird ein Hardware-Diagramm erstellt, das sich wiederum in eine Zwischenbeschreibung in der Firrtl-Sprache verwandelt. Anschlie√üend wird der integrierte Backend-Interpreter aus dem Firrtl-Verilog generiert. </p><br><p>  Schauen wir uns zwei Implementierungen eines einfachen Z√§hlers an. </p><br><p>  Verilog: </p><br><pre><code class="plaintext hljs">module SimpleCounter #( parameter WIDTH = 8 )( input clk, input reset, input wire enable, output wire [WIDTH-1:0] out ); reg [WIDTH-1:0] counter; assign out = counter; always @(posedge clk) if (reset) begin counter &lt;= {(WIDTH){1'b0}}; end else if (enable) begin counter &lt;= counter + 1; end endmodule</code> </pre> <br><p>  Mei√üel: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleCounter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">width: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enable = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(width.<span class="hljs-type"><span class="hljs-type">W</span></span>)) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counter = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(width.<span class="hljs-type"><span class="hljs-type">W</span></span>)) io.out &lt;&gt; counter when(io.enable) { counter := counter + <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span> } }</code> </pre> <br><p>  Ein bisschen √ºber Mei√üel: </p><br><ul><li>  <code>Module</code> - Container f√ºr die Beschreibung des RTL-Moduls </li><li>  <code>Bundle</code> ist eine Datenstruktur in Mei√üel, die haupts√§chlich zum Definieren von Schnittstellen verwendet wird. </li><li>  <code>io</code> - Variable zur Bestimmung von Ports </li><li>  <code>Bool</code> - Datentyp, einfaches Einzelbit-Signal </li><li>  <code>UInt(width: Width)</code> - Ganzzahl ohne Vorzeichen, der Konstruktor akzeptiert die Bittiefe des Signals als Eingabe. </li><li>  <code>RegInit[T &lt;: Data](init: T)</code> ist ein Registerkonstruktor, der einen R√ºcksetzwert als Eingabe verwendet und denselben Datentyp hat. </li><li>  <code>&lt;&gt;</code> - universeller Signalverbindungsoperator </li><li>  <code>when(cond: =&gt; Bool) { /*...*/ }</code> - das <code>if</code> Analogon in Verilog </li></ul><br><p>  Wir werden etwas sp√§ter dar√ºber sprechen, welcher Verilog Mei√üel erzeugt.  Vergleichen Sie nun einfach diese beiden Designs.  Wie Sie sehen k√∂nnen, werden <code>clk</code> und <code>reset</code> Signale im Mei√üel nicht erw√§hnt.  Tatsache ist, dass Mei√üel diese Signale standardm√§√üig zum Modul hinzuf√ºgt.  Der R√ºcksetzwert f√ºr das <code>RegInit</code> mit dem <code>RegInit</code> Reset <code>RegInit</code> Registerkonstruktor <code>RegInit</code> .  Chisel unterst√ºtzt Module mit vielen Taktsignalen, aber etwas sp√§ter. </p><br><h3 id="schetchik-chut-poslozhnee">  Der Z√§hler ist etwas komplizierter </h3><br><p>  Gehen wir weiter und komplizieren die Aufgabe zum Beispiel ein wenig - wir erstellen einen Mehrkanalz√§hler mit einem Eingabeparameter in Form einer Folge von Bits f√ºr jeden Kanal. </p><br><p>  Beginnen wir jetzt mit der Mei√üelversion </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiChannelCounter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">width: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">] = </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">(32, 16, 8, 4</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enable = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Vec</span></span>(width.length, <span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(width.sum.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOut</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">UInt</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> right = width.dropRight(width.length - i).sum <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.out(right + width(i) - <span class="hljs-number"><span class="hljs-number">1</span></span>, right) } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counters: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">SimpleCounter</span></span>] = width.map(x =&gt; <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SimpleCounter</span></span>(x)) ) io.out &lt;&gt; util.<span class="hljs-type"><span class="hljs-type">Cat</span></span>(counters.map(_.io.out)) width.indices.foreach { i =&gt; counters(i).io.enable &lt;&gt; io.enable(i) } }</code> </pre> <br><p>  Ein bisschen √ºber Scala: </p><br><ul><li>  <code>width: Seq[Int]</code> - Eingabeparameter f√ºr den Konstruktor der <code>MultiChannelCounter</code> Klasse vom Typ <code>Seq[Int]</code> - eine Sequenz mit ganzzahligen Elementen. </li><li>  <code>Seq</code> ist eine der Arten von Sammlungen in Scala mit einer genau definierten Folge von Elementen. </li><li>  <code>.map</code> ist eine vertraute Funktion f√ºr Sammlungen f√ºr alle, die aufgrund derselben Operation f√ºr jedes Element eine Sammlung in eine andere konvertieren kann. In unserem Fall wird aus einer Folge ganzzahliger Werte eine Folge von <code>SimpleCounter</code> mit der entsprechenden Bittiefe. </li></ul><br><p>  Ein bisschen √ºber Mei√üel: </p><br><ul><li>  <code>Vec[T &lt;: Data](gen: T, n: Int): Vec[T]</code> Datentyp <code>Vec[T &lt;: Data](gen: T, n: Int): Vec[T]</code> - Mei√üel ist ein Analogon des Arrays. </li><li>  <code>Module[T &lt;: BaseModule](bc: =&gt; T): T</code> ist die erforderliche Wrapper-Methode f√ºr instanziierbare Module. </li><li>  <code>util.Cat[T &lt;: Bits](r: Seq[T]): UInt</code> - Verkettungsfunktion, analog <code>{1'b1, 2'b01, 4'h0}</code> in Verilog </li></ul><br><p>  Achten Sie auf die H√§fen: <br>  <code>enable</code> - bereits in <code>Vec[Bool]</code> * implementiert, grob gesagt, in einem Array von Ein-Bit-Signalen, eines f√ºr jeden Kanal, war es m√∂glich, <code>UInt(width.length.W)</code> . <br>  <code>out</code> - erweitert auf die Summe der Breiten aller unserer Kan√§le. </p><br><p>  Die variablen <code>counters</code> sind ein Array unserer Z√§hler.  Wir verbinden das <code>enable</code> jedes Z√§hlers mit dem entsprechenden Eingangsport und kombinieren alle Ausgangssignale mithilfe der integrierten <code>util.Cat</code> Funktion zu einem und leiten es an den Ausgang weiter. </p><br><p>  Wir bemerken auch die Funktion <code>getOut(i: Int)</code> - diese Funktion berechnet und gibt den <code>getOut(i: Int)</code> im <code>getOut(i: Int)</code> f√ºr den <code>i</code> Kanal zur√ºck.  Es wird bei der weiteren Arbeit mit einem solchen Z√§hler sehr n√ºtzlich sein.  Die Implementierung von so etwas in Verilog funktioniert nicht </p><br><p>  * <code>Vec</code> sollte nicht mit <code>Vector</code> verwechselt werden, das erste ist ein Array von Daten in Mei√üel, das zweite ist eine Sammlung in Scala. </p><br><p>  Lassen Sie uns nun versuchen, dieses Modul auf Verilog zu schreiben, um es sogar auf systemVerilog zu vereinfachen. </p><br><p>  Nachdem ich nachgedacht hatte, kam ich zu dieser Option (h√∂chstwahrscheinlich ist sie nicht die einzig wahre und optimalste, aber Sie k√∂nnen Ihre Implementierung immer in den Kommentaren vorschlagen). </p><br><div class="spoiler">  <b class="spoiler_title">Verilog</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module MultiChannelCounter #( parameter TOTAL = 4, parameter integer WIDTH_SEQ [TOTAL] = {32, 16, 8, 4} )(clk, reset, enable, out); localparam OUT_WIDTH = get_sum(TOTAL, WIDTH_SEQ); input clk; input reset; input wire [TOTAL - 1 : 0] enable; output wire [OUT_WIDTH - 1 :0] out; genvar j; generate for(j = 0; j &lt; TOTAL; j = j + 1) begin : counter_generation localparam OUT_INDEX = get_sum(j, WIDTH_SEQ); SimpleCounter #( WIDTH_SEQ[j] ) SimpleCounter_unit ( .clk(clk), .reset(reset), .enable(enable[j]), .out(out[OUT_INDEX + WIDTH_SEQ[j] - 1: OUT_INDEX]) ); end endgenerate function automatic integer get_sum; input integer array_width; input integer array [TOTAL]; integer counter = 0; integer i; begin for(i = 0; i &lt; array_width; i = i + 1) counter = counter + array[i]; get_sum = counter; end endfunction endmodule</code> </pre> </div></div><br><p>  Es sieht schon viel beeindruckender aus.  Was aber, wenn wir weiter gehen und die beliebte Querlenkerschnittstelle mit Registerzugriff anschrauben. </p><br><h3 id="bundle-interfeysy">  B√ºndelschnittstellen </h3><br><p>  Wishbone ist ein kleiner Bus √§hnlich wie AMBA APB, der haupts√§chlich f√ºr Open Source IP-Kerne verwendet wird. </p><br><p>  Weitere Details im Wiki: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://ru.wikipedia.org/wiki/Wishbone</a> </p><br><p>  Weil  chisel stellt uns <code>Bundle</code> Typ <code>Bundle</code> . Es ist sinnvoll, den Bus in einen Container zu wickeln, der sp√§ter in beliebigen Mei√üelprojekten verwendet werden kann. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneMasterSignals</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, gotTag: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = false</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adr = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(addrWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dat_master = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(dataWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dat_slave = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(dataWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stb = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> we = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cyc = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sel = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>((dataWidth / <span class="hljs-number"><span class="hljs-number">8</span></span>).<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ack_master = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ack_slave = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag_master: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gotTag) <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag_slave: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gotTag) <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbTransaction</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = cyc &amp;&amp; stb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbWrite</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = wbTransaction &amp;&amp; we <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbRead</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = wbTransaction &amp;&amp; !we <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneMasterSignals.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth, dataWidth, gotTag).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  Ein bisschen √ºber Scala: </p><br><ul><li>  <code>Option</code> - ein optionaler Daten-Wrapper in Scala, der entweder ein Element oder <code>None</code> kann. <code>Option[UInt]</code> ist entweder <code>Some(UInt(/*...*/))</code> oder <code>None</code> , was bei der Parametrisierung von Signalen hilfreich ist. </li></ul><br><p>  Es scheint nichts Ungew√∂hnliches.  Nur eine Beschreibung der Schnittstelle durch den Assistenten, mit Ausnahme einiger Signale und Methoden: </p><br><p>  <code>tag_master</code> und <code>tag_slave</code> sind optionale Allzweck-Signale im Wishbone-Protokoll. Wir werden sie sehen, wenn der <code>gotTag</code> Parameter <code>true</code> . </p><br><p>  <code>wbTransaction</code> , <code>wbWrite</code> , <code>wbRead</code> - Funktionen zur Vereinfachung der Arbeit mit dem Bus. </p><br><p>  <code>cloneType</code> - erforderliche <code>cloneType</code> f√ºr alle parametrisierten <code>[T &lt;: Bundle]</code> -Klassen </p><br><p>  Wir brauchen aber auch eine Slave-Schnittstelle. Mal sehen, wie sie implementiert werden kann. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlave</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, tagWidht: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 0</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb = <span class="hljs-type"><span class="hljs-type">Flipped</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth , dataWidth, tagWidht)) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneSlave.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(addrWidth, dataWidth, tagWidht).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  Die <code>Flipped</code> Methode dreht, wie Sie vielleicht anhand des Namens erraten haben, die Schnittstelle um, und jetzt, da unsere Assistentenschnittstelle zu einem Slave geworden ist, f√ºgen wir dieselbe Klasse f√ºr den Assistenten hinzu. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneMaster</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, tagWidht: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 0</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth , dataWidth, tagWidht) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneMaster.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMaster(addrWidth, dataWidth, tagWidht).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  Nun, das war's, die Schnittstelle ist fertig.  Bevor wir jedoch einen Handler schreiben, wollen wir sehen, wie wir diese Schnittstellen verwenden k√∂nnen, falls wir einen Switch oder etwas mit einer gro√üen Anzahl von Wishbone-Schnittstellen vornehmen m√ºssen. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneCrossbarIo</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">n: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> slaves = <span class="hljs-type"><span class="hljs-type">Vec</span></span>(n, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(addrWidth, dataWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> master = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMaster(addrWidth, dataWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WBCrossBar</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">WishboneCrossbarIo</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>)) io.master &lt;&gt; io.slaves(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Dies ist ein kleines Leerzeichen f√ºr den Schalter.  Es ist praktisch, eine Schnittstelle vom Typ <code>Vec[wishboneSlave]</code> zu deklarieren, und Sie k√∂nnen die Schnittstellen mit demselben <code>&lt;&gt;</code> Operator verbinden.  N√ºtzliche Mei√üelchips, wenn es darum geht, eine gro√üe Anzahl von Signalen zu verwalten. </p><br><h3 id="universalnyy-kontroller-shiny">  Universelle Bussteuerung </h3><br><p>  Wie bereits erw√§hnt, werden wir versuchen, diese auf die Leistungsf√§higkeit der Funktions- und Objektprogrammierung anzuwenden.  Weiter werden wir √ºber die Implementierung des universellen Wishbone-Bus-Controllers in Form eines <code>trait</code> sprechen. Es wird eine Art Mixin f√ºr jedes Modul mit dem <code>wishboneSlave</code> Bus sein. F√ºr das Modul m√ºssen Sie lediglich eine Speicherkarte definieren und den <code>trait</code> Controller w√§hrend der Generierung mit diesem mischen. </p><br><h4 id="realizaciya">  Implementierung </h4><br><div class="spoiler">  <b class="spoiler_title">F√ºr diejenigen, die immer noch begeistert sind</b> <div class="spoiler_text"><p>  Fahren wir mit der Implementierung des Handlers fort.  Es ist einfach und reagiert sofort auf einzelne Transaktionen. Wenn Sie aus dem Adresspool herausfallen, geben Sie Null zur√ºck. </p><br><p>  Lassen Sie uns in Teilen analysieren: </p><br><ul><li><p>  Jede Transaktion muss mit Best√§tigung beantwortet werden </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io : wishboneSlave = <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_ack = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) when(io.wb.wbTransaction) { wb_ack := <span class="hljs-literal"><span class="hljs-literal">true</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> }.otherwise { wb_ack := <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> } wb_ack &lt;&gt; io.wb.ack_slave</code> </pre> <br></li><li>  Wir antworten auf das Lesen mit Daten <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_dat = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(io.wb.dat_slave.getWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// getWidth   when(io.wb.wbRead) { wb_dat := MuxCase(default = 0.U, Seq( (io.wb.addr === ADDR_1) -&gt; data_1, (io.wb.addr === ADDR_3) -&gt; data_2, (io.wb.addr === ADDR_3) -&gt; data_2 )) } wb_dat &lt;&gt; io.wb.dat_slave</span></span></code> </pre> <br><ul><li>  <code>MuxCase[T &lt;: Data] (default: T, mapping: Seq[(Bool, T)]): T</code> ist das in Verilog * integrierte Koordinationsschema des Falltyps. </li></ul></li></ul><br><p>  Wie w√ºrde es in Verilog aussehen: </p><br><pre> <code class="plaintext hljs"> always @(posedge clock) if(reset) wb_dat_o &lt;= 0; else if(wb_read) case (wb_adr_i) `ADDR_1 : wb_dat_o &lt;= data_1; `ADDR_2 : wb_dat_o &lt;= data_2; `ADDR_3 : wb_dat_o &lt;= data_3; default : wb_dat_o &lt;= 0; endcase }</code> </pre> <br><p>  * Im Allgemeinen ist dies in diesem Fall ein kleiner Hack zur Parametrisierung. Mei√üel hat ein Standarddesign, das besser zu verwenden ist, wenn Sie etwas Einfacheres schreiben. </p><br><pre> <code class="scala hljs">switch(x) { is(value1) { <span class="hljs-comment"><span class="hljs-comment">// ... } is(value2) { // ... } }</span></span></code> </pre> <br><p>  Nun, die Aufzeichnung </p><br><pre> <code class="scala hljs"> when(io.wb.wbWrite) { data_4 := <span class="hljs-type"><span class="hljs-type">Mux</span></span>(io.wb.addr === <span class="hljs-type"><span class="hljs-type">ADDR_4</span></span>, io.wb.dat_master, data_4) }</code> </pre> <br><ul><li>  <code>Mux[T &lt;: Data](cond: Bool, con: T, alt: T): T</code> - regul√§rer Multiplexer </li></ul><br><p>  Wir binden etwas √Ñhnliches wie unseren Mehrkanalz√§hler ein, h√§ngen Register f√ºr die Kanalverwaltung und einen Hut auf.  Aber hier liegt es in der N√§he des universellen WB-Bus-Controllers, auf den wir eine Speicherkarte dieser Art √ºbertragen werden: </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  F√ºr eine solche Aufgabe hilft uns das <code>trait</code> - so etwas wie Mixins in Sala.  Die Hauptaufgabe besteht darin, <code>readMemMap: [Int, Data]</code> wie <code>Seq( -&gt; )</code> aussehen zu lassen, und es w√§re auch sch√∂n, wenn Sie die Basisadresse und das Datenarray innerhalb der Speicherkarte √ºbertragen k√∂nnten </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Was wird in etwas √Ñhnliches erweitert, wobei WB_DAT_WIDTH die Breite der Daten in Bytes ist </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_0</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_2</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_3</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Um dies zu implementieren, schreiben wir eine Konverterfunktion von <code>Map[Int, Any]</code> nach <code>Seq[(Bool, UInt)]</code> .  Sie m√ºssen Scala Pattern Mathcing verwenden. </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseMemMap</span></span></span></span>(memMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = memMap.flatMap { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(addr, data) =&gt; data <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a: <span class="hljs-type"><span class="hljs-type">UInt</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Seq</span></span>((io.wb.adr === addr.<span class="hljs-type"><span class="hljs-type">U</span></span>) -&gt; a) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] =&gt; a.map(x =&gt; (io.wb.adr === (addr + io.wb.dat_slave.getWidth / <span class="hljs-number"><span class="hljs-number">8</span></span>).<span class="hljs-type"><span class="hljs-type">U</span></span>) -&gt; x) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"WRONG MEM MAP!!!"</span></span>) } }.toSeq</code> </pre> <br><p>  Schlie√ülich wird unser Merkmal so aussehen: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlaveDriver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io : wishboneSlave <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedReadMap: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = parseMemMap(readMemMap) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedWriteMap: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = parseMemMap(writeMemMap) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_ack = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_dat = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(io.wb.dat_slave.getWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) when(io.wb.wbTransaction) { wb_ack := <span class="hljs-literal"><span class="hljs-literal">true</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> }.otherwise { wb_ack := <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> } when(io.wb.wbRead) { wb_dat := <span class="hljs-type"><span class="hljs-type">MuxCase</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> = <span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>, parsedReadMap) } when(io.wb.wbWrite) { parsedWriteMap.foreach { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(addrMatched, data) =&gt; data := <span class="hljs-type"><span class="hljs-type">Mux</span></span>(addrMatched, io.wb.dat_master, data) } } wb_dat &lt;&gt; io.wb.dat_slave wb_ack &lt;&gt; io.wb.ack_slave <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseMemMap</span></span></span></span>(memMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = { <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>} }</code> </pre> <br><p>  Ein bisschen √ºber Scala: </p><br><ul><li>  <code>io , readMemMap, writeMemMap</code> sind die abstrakten Felder unseres <code>trait</code> 'a, die in der Klasse definiert werden m√ºssen, in die wir es mischen werden. </li></ul></div></div><br><h4 id="kak-im-polzovatsya">  Wie man es benutzt </h4><br><p>  Um unser <code>trait</code> mit dem Modul zu mischen, m√ºssen mehrere Bedingungen erf√ºllt sein: </p><br><ul><li>  <code>io</code> sollte von der <code>wishboneSlave</code> Klasse erben </li><li>  m√ºssen zwei Speicherkarten <code>readMemMap</code> und <code>writeMemMap</code> </li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneMultiChannelCounter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BASE</span></span> = <span class="hljs-number"><span class="hljs-number">0x11A00000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">OUT</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">S_EN</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">H_EN</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000300</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbAddrWidth = <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbDataWidth = <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbTagWidth = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> width = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(wbAddrWidth, wbDataWidth, wbTagWidth) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hardwareEnable: <span class="hljs-type"><span class="hljs-type">Vec</span></span>[<span class="hljs-type"><span class="hljs-type">Bool</span></span>] = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Vec</span></span>(width.length, <span class="hljs-type"><span class="hljs-type">Bool</span></span>())) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counter = <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MultiChannelCounter</span></span>(width)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> softwareEnable = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(width.length.<span class="hljs-type"><span class="hljs-type">W</span></span>)) width.indices.foreach(i =&gt; counter.io.enable(i) := io.hardwareEnable(i) &amp;&amp; softwareEnable(i)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">OUT</span></span> -&gt; width.indices.map(counter.io.getOut), <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">S_EN</span></span> -&gt; softwareEnable, <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">H_EN</span></span> -&gt; io.hardwareEnable.asUInt ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">S_EN</span></span> -&gt; softwareEnable ) }</code> </pre> <br><p>  Wir erstellen das <code>softwareEnable</code> Register, es wird durch das <code>hardwareEnable</code> Eingangssignal zu 'und' hinzugef√ºgt und aktiviert den <code>counter[MultiChannelCounter]</code> . </p><br><p>  Wir deklarieren zwei Speicherkarten zum Lesen und Schreiben: <code>readMemMap</code> <code>writeMemMap</code> . Weitere Informationen zur Struktur finden Sie im obigen Kapitel. <br>  Auf der Lesespeicherkarte √ºbertragen wir den Z√§hlerwert jedes Kanals *, <code>softwareEnable</code> und <code>hardwareEnable</code> .  Und f√ºr die Aufzeichnung geben wir nur das <code>softwareEnable</code> Register. </p><br><p>  * <code>width.indices.map(counter.io.getOut)</code> - ein seltsames Design, das wir in Teilen analysieren werden. </p><br><ul><li>  <code>width.indices</code> - gibt ein Array mit Elementindizes zur√ºck, d. <code>width.indices</code>  wenn <code>width.length == 4</code> dann <code>width.indices = {0, 1, 2, 3}</code> </li><li>  <code>{0, 1, 2, 3}.map(counter.io.getOut)</code> - gibt <code>{0, 1, 2, 3}.map(counter.io.getOut)</code> : <br> <code>{ counter.io.getOut(0), counter.io.getOut(1), /*...*/ }</code> </li> </ul><br><p>  Jetzt k√∂nnen wir f√ºr jedes Modul auf Mei√üel mit Speicherkarten zum Lesen und Schreiben deklarieren und beim Generieren einfach unseren universellen Querlenker-Bus-Controller anschlie√üen. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishbone_multicahnnel_counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneMultiChannelCounter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlaveDriver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">countersDriver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">Driver</span></span>.execute(<span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-string"><span class="hljs-string">"-td"</span></span>, <span class="hljs-string"><span class="hljs-string">"./src/generated"</span></span>), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishbone_multicahnnel_counter ) }</code> </pre> <br><p>  <code>wishboneSlaveDriver</code> - das ist genau der Trait-Mix, den wir unter dem Spoiler beschrieben haben. </p><br><p>  Nat√ºrlich ist diese Version des Universal-Controllers alles andere als endg√ºltig, sondern im Gegenteil eher grob.  Ihr Hauptziel ist es, einen der m√∂glichen Ans√§tze zur Entwicklung von RTL auf Mei√üel aufzuzeigen.  Mit all den M√∂glichkeiten von Scala k√∂nnen solche Ans√§tze viel gr√∂√üer sein, sodass jeder Entwickler sein eigenes Feld f√ºr Kreativit√§t hat.  Richtig, besonders nirgendwo, wo man sich besonders inspirieren l√§sst, au√üer: </p><br><ul><li>  In der nativen Mei√üel-Utils-Bibliothek, √ºber die Sie etwas weiter unten die Vererbung von Modulen und Schnittstellen betrachten k√∂nnen </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/freechipsproject/rocket-chip</a> - risc-v Der gesamte Kernel ist auf Mei√üel implementiert, vorausgesetzt, Sie kennen Scala sehr gut. F√ºr Anf√§nger ohne einen halben Liter, wie sie sagen, wird das Verst√§ndnis sehr lange dauern.  Es gibt keine offizielle Dokumentation zur internen Struktur des Projekts. </li></ul><br><h3 id="multiclockdomain">  MultiClockDomain </h3><br><p>  Was ist, wenn wir die Uhr manuell steuern und die Signale im Mei√üel zur√ºcksetzen m√∂chten?  Bis vor kurzem war dies nicht m√∂glich, aber mit einer der neuesten Versionen wurde die Unterst√ºtzung von <code>withClock {}</code> , <code>withReset {}</code> und <code>withClockAndReset {}</code> .  Schauen wir uns ein Beispiel an: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DoubleClockModule</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> in = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outB = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClock = <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) regClock &lt;&gt; io.out <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockB = withClock(io.clockB) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockB &lt;&gt; io.outB }</code> </pre> <br><ul><li>  <code>regClock</code> - Ein Register, das vom Standardtaktsignal <code>clock</code> und vom Standardreset <code>reset</code> </li><li>  <code>regClockB</code> - dasselbe Register wird vom <code>io.clockB</code> Signal getaktet, Sie haben es erraten, aber der Standard-Reset wird verwendet. </li></ul><br><p>  Wenn wir die Standarduhr entfernen und die Signale vollst√§ndig <code>reset</code> m√∂chten, k√∂nnen wir die experimentelle Funktion - <code>RawModule</code> (Modul ohne Standarduhr- und R√ºcksetzsignale, jeder muss manuell gesteuert werden) verwenden.  Ein Beispiel: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiClockModule</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockA = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resetA = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resetB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> in = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outA = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outB = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockA = withClockAndReset(io.clockA, io.resetA) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockA &lt;&gt; io.outA <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockB = withClockAndReset (io.clockB, io.resetB) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockB &lt;&gt; io.outB }</code> </pre> <br><h3 id="utils-biblioteka">  Utils Bibliothek </h3><br><p>  Die angenehmen Boni des Mei√üels enden hier nicht.  Die Entwickler haben hart gearbeitet und eine kleine, aber sehr n√ºtzliche Bibliothek mit kleinen Schnittstellen, Modulen und Funktionen geschrieben.  Seltsamerweise gibt es im Wiki keine Beschreibung der Bibliothek, aber Sie k√∂nnen den Spickzettel-Link sehen, auf den ganz am Anfang verwiesen wird (es gibt zwei letzte Abschnitte). </p><br><p>  Schnittstellen: </p><br><ul><li>  <code>DecoupledIO</code> ist die h√§ufig verwendete Ready / Valid-Schnittstelle. <br>  <code>DecoupledIO(UInt(32.W))</code> - enth√§lt Signale: <br> <code>val ready = Input(Bool())</code> <br> <code>val valid = Output(Bool())</code> <br> <code>val data = Output(UInt(32.W))</code> </li> <li>  <code>ValidIO</code> - wie <code>DecoupledIO</code> nur ohne <code>ready</code> </li></ul><br><p>  Module: </p><br><ul><li>  <code>Queue</code> - Das synchrone FIFO-Modul ist eine sehr n√ºtzliche Sache. Die Schnittstelle sieht so aus <br>  <code>val enq: DecoupledIO[T]</code> - invertiertes <code>DecoupledIO</code> <br>  <code>val deq: DecoupledIO[T]</code> - regul√§res <code>DecoupledIO</code> <br>  <code>val count: UInt</code> - Datenmenge in der Warteschlange </li><li>  <code>Pipe</code> , f√ºgt die n-te Anzahl von Registerscheiben ein </li><li>  <code>Arbiter</code> - Arbiter auf <code>DecoupledIO</code> Schnittstellen, hat viele Unterarten, die sich in der Art der Arbitrierung unterscheiden <br>  <code>val in: Vec[DecoupledIO[T]]</code> - Array von Eingangsschnittstellen <br> <code>val out: DecoupledIO[T]</code> <br>  <code>val chosen: UInt</code> - Zeigt den ausgew√§hlten Kanal an </li></ul><br><p>  Soweit Sie aus der Diskussion √ºber Github verstehen k√∂nnen, haben die globalen Pl√§ne eine bedeutende Erweiterung dieser Modulbibliothek: wie asynchrones FIFO, LSFSR, Frequenzteiler, PLL-Vorlagen f√ºr FPGA;  verschiedene Schnittstellen;  Controller f√ºr sie und vieles mehr. </p><br><h3 id="chisel-io-teseters">  Mei√üel-Io-Teseter </h3><br><p>  Die M√∂glichkeit, in Mei√üel zu testen, sollte erw√§hnt werden. Derzeit gibt es zwei M√∂glichkeiten, dies zu testen: </p><br><ul><li>  <code>peekPokeTesters</code> - reine Simulationstests, die die Logik Ihres Designs testen </li><li><p>  <code>hardwareIOTeseters</code> ist seitdem schon interessanter  Mit diesem Ansatz erhalten Sie eine generierte Testbank mit Tests, die Sie auf Mei√üel geschrieben haben, und selbst wenn Sie einen Verilator haben, erhalten Sie sogar eine Zeitleiste. </p><br><p>  Bisher wurde der Testansatz jedoch noch nicht abgeschlossen, und die Diskussion ist noch nicht abgeschlossen.  In Zukunft wird h√∂chstwahrscheinlich ein universelles Werkzeug erscheinen, zum Testen und Testen wird es auch m√∂glich sein, auf Mei√üel zu schreiben.  Aber jetzt k√∂nnen Sie sich ansehen, was bereits vorhanden ist und wie Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es hier verwenden k√∂nnen</a> . </p><br></li></ul><br><h3 id="nedostatki-chisel">  Nachteile des Mei√üels </h3><br><p>  Dies bedeutet nicht, dass Mei√üel ein universelles Werkzeug ist und dass jeder darauf umsteigen sollte.  Er hat, wie vielleicht alle Projekte in der Entwicklungsphase, seine Nachteile, die der Vollst√§ndigkeit halber erw√§hnenswert sind. </p><br><p>  Der erste und vielleicht wichtigste Nachteil ist das Fehlen asynchroner Sp√ºlungen.  Gewichtig genug, aber es kann auf verschiedene Arten gel√∂st werden. Eines davon sind Skripte √ºber Verilog, die das synchrone Zur√ºcksetzen in asynchrones umwandeln.  Das ist einfach, weil  Alle Konstruktionen im generierten Verilog mit sind <code>always</code> ziemlich einheitlich. </p><br><p>  Der zweite Nachteil ist nach Ansicht vieler die Unlesbarkeit des generierten Verilogs und infolgedessen die Komplikation des Debuggens.  Aber schauen wir uns den generierten Code aus dem Beispiel mit einem einfachen Z√§hler an </p><br><div class="spoiler">  <b class="spoiler_title">Verilog generiert</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">`ifdef RANDOMIZE_GARBAGE_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_INVALID_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_REG_INIT `define RANDOMIZE `endif `ifdef RANDOMIZE_MEM_INIT `define RANDOMIZE `endif module SimpleCounter( input clock, input reset, input io_enable, output [7:0] io_out ); reg [7:0] counter; reg [31:0] _RAND_0; wire [8:0] _T_7; wire [7:0] _T_8; wire [7:0] _GEN_0; assign _T_7 = counter + 8'h1; assign _T_8 = _T_7[7:0]; assign _GEN_0 = io_enable ? _T_8 : counter; assign io_out = counter; `ifdef RANDOMIZE integer initvar; initial begin `ifndef verilator #0.002 begin end `endif `ifdef RANDOMIZE_REG_INIT _RAND_0 = {1{$random}}; counter = _RAND_0[7:0]; `endif // RANDOMIZE_REG_INIT end `endif // RANDOMIZE always @(posedge clock) begin if (reset) begin counter &lt;= 8'h0; end else begin if (io_enable) begin counter &lt;= _T_8; end end end endmodule</code> </pre> </div></div><br><p>  Auf den ersten Blick kann sich der generierte Verilog auch in einem mittelgro√üen Design wegschieben, aber werfen wir einen Blick darauf. </p><br><ul><li>  RANDOMIZE-Definitionen - (kann beim Testen mit Mei√üeltestern n√ºtzlich sein) - sind im Allgemeinen nutzlos, st√∂ren jedoch nicht besonders </li><li>  Wie Sie den Namen unserer H√§fen und das Register sehen k√∂nnen </li><li>  _GEN_0 ist eine nutzlose Variable f√ºr uns, aber notwendig, damit firrtl an den Interpreter Verilog generiert.  Wir achten auch nicht darauf. </li><li>  Es verbleiben _T_7 und _T_8, die gesamte Kombinationslogik im generierten Verilog wird Schritt f√ºr Schritt in Form von Variablen _T dargestellt. </li></ul><br><p>  Am wichtigsten ist, dass alle zum Debuggen erforderlichen Ports, Register und Dr√§hte ihre Namen vom Mei√üel fernhalten.  Und wenn Sie sich nicht nur Verilog, sondern auch Mei√üel ansehen, wird der Debugging-Prozess bald so einfach wie mit reinem Verilog. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  In der modernen Realit√§t hat sich die Entwicklung von RTL, ob asic oder fpga au√üerhalb des akademischen Umfelds, l√§ngst von der Verwendung von rein handgeschriebenem Verilog-Code zu der einen oder anderen Art von Generierungsskript entwickelt, sei es ein kleines tcl-Skript oder eine gesamte IDE mit einer Reihe von Funktionen. </p><br><p>  Mei√üel wiederum ist die logische Entwicklung von Sprachen f√ºr die Entwicklung und Erprobung digitaler Logik.  Nehmen wir an, dass er zu diesem Zeitpunkt alles andere als perfekt ist, aber bereits M√∂glichkeiten bietet, f√ºr die Sie seine M√§ngel in Kauf nehmen k√∂nnen.      ,                   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419413/">https://habr.com/ru/post/de419413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419401/index.html">Java-Befehlszeilenschnittstellen: picocli</a></li>
<li><a href="../de419405/index.html">Wie sieht es mit IPv6 aus oder was behindert den √úbergang zu einer neuen Version des Protokolls? Besprechen Sie die Situation</a></li>
<li><a href="../de419407/index.html">Eine detaillierte Analyse der Dota 2-√úbereinstimmung zwischen OpenAI und Personen im 5x5-Format. Menschen verloren</a></li>
<li><a href="../de419409/index.html">Neue Intel NUCs basierend auf Coffee Lake Prozessoren</a></li>
<li><a href="../de419411/index.html">√úber das Feuer in einem Wolkenkratzer. Kino und Realit√§t</a></li>
<li><a href="../de419415/index.html">Mattermost und Powershell - gro√üe Leistung oder kleine Automatisierung im Haushalt</a></li>
<li><a href="../de419417/index.html">GDPR: Datenmapping oder wie Kunden l√§ngst vergessene Laptops finden</a></li>
<li><a href="../de419419/index.html">UI-Autotests: Wie es geht, lohnt sich nicht</a></li>
<li><a href="../de419423/index.html">Uns wird ein Echtzeitvideo ohne Friese und Zuckungen versprochen</a></li>
<li><a href="../de419425/index.html">Sicherheitswoche 29. Hacking Reddit, eine Brieftasche f√ºr Kryptow√§hrung und MikroTik-Router</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>