<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛴 🚀 🤹🏼 Comment empêcher le dépassement de mémoire lors de l'utilisation de collections Java 🌐 📻 👩‍❤️‍💋‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! 

 Notre expérience avec les étapes du cours Java Developer se poursuit et, curieusement, même avec un certain succès (en quelque sort...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment empêcher le dépassement de mémoire lors de l'utilisation de collections Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/420245/"> Bonjour à tous! <br><br>  Notre expérience avec les étapes du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Developer se</a> poursuit et, curieusement, même avec un certain succès (en quelque sorte): comme il s'est avéré, planifier un effet de levier de quelques mois avec la prochaine transition vers une nouvelle étape à tout moment opportun est beaucoup plus pratique que si Allouez près de six mois à un cours aussi difficile.  On soupçonne donc que ce sont précisément les cours complexes que nous allons bientôt commencer à transférer lentement vers un tel système. <br><br>  Mais c'est moi pour le nôtre, pour otusovsky, je suis désolé.  Comme toujours, nous continuons à étudier des sujets intéressants qui, bien qu'ils ne soient pas abordés dans notre programme, mais qui sont discutés avec nous, nous avons donc préparé une traduction de l'article le plus intéressant à notre avis sur l'une des questions que nos professeurs ont posées. <br><br>  C'est parti! <br><br><img src="https://habrastorage.org/webt/gg/pb/_w/ggpb_wvr4ihy5kk_wj9wm0awrea.png"><a name="habracut"></a><br><br>  Les collections du JDK sont les implémentations de bibliothèque standard de listes et de cartes.  Si vous regardez un instantané d'une grande application Java typique, vous verrez des milliers voire des millions d'instances de <code>java.util.ArrayList</code> , <code>java.util.HashMap</code> , etc. Les collections sont indispensables pour stocker et manipuler des données.  Mais vous êtes-vous déjà demandé si toutes les collections de votre application font un usage optimal de la mémoire?  En d'autres termes, si votre application se bloque avec la honteuse <code>OutOfMemoryError</code> ou provoque de longues pauses dans le garbage collector, avez-vous déjà vérifié les collections utilisées pour les fuites. <br><br>  Tout d'abord, il convient de noter que les collections internes de JDK ne sont pas une sorte de magie.  Ils sont écrits en Java.  Leur code source est fourni avec le JDK, vous pouvez donc l'ouvrir dans votre IDE.  Leur code peut également être facilement trouvé sur Internet.  Et, il s'avère que la plupart des collections ne sont pas très élégantes en termes d'optimisation de la quantité de mémoire consommée. <br><br>  Prenons, par exemple, l'une des collections les plus simples et les plus populaires - la classe <code>java.util.ArrayList</code> .  En interne, chaque <code>ArrayList</code> fonctionne avec un tableau de <code>Object[] elementData</code> .  C'est là que les éléments de la liste sont stockés.  Voyons comment ce tableau est traité. <br><br>  Lorsque vous créez un <code>ArrayList</code> avec le constructeur par défaut, c'est-à-dire appelez <code>new ArrayList()</code> , <code>elementData</code> pointe vers un tableau générique de taille zéro ( <code>elementData</code> peut également être défini sur <code>null</code> , mais le tableau offre quelques avantages mineurs d'implémentation).  Lorsque vous ajoutez le premier élément à la liste, un véritable tableau unique de <code>elementData</code> et l'objet fourni y est inséré.  Afin d'éviter de changer la taille du tableau à chaque fois, lors de l'ajout d'un nouvel élément, il est créé avec une longueur égale à 10 («capacité par défaut»).  Il s'avère donc que si vous n'ajoutez plus d'éléments à ce <code>ArrayList</code> , 9 emplacements sur 10 dans le tableau <code>elementData</code> resteront vides.  Et même si vous effacez la liste, la taille du tableau interne ne sera pas réduite.  Voici un diagramme de ce cycle de vie: <br><br><img src="https://habrastorage.org/webt/mu/3n/hd/mu3nhdbrmajrdvphqi1kyj6nhii.png"><br><br>  Combien de mémoire est gaspillée ici?  En termes absolus, elle est calculée comme (la taille du pointeur d'objet).  Si vous utilisez le JVM HotSpot (fourni avec le JDK Oracle), la taille du pointeur dépendra de la taille de segment de mémoire maximale (pour plus de détails, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://blog.codecentric.de/en/2014/02/35gb-heap-less- 32 Go-java-jvm-mémoire-bizarreries /</a> ).  En règle générale, si vous spécifiez <code>-Xmx</code> moins de 32 gigaoctets, la taille du pointeur sera de 4 octets;  pour les gros tas - 8 octets.  Ainsi, une <code>ArrayList</code> , initialisée par le constructeur par défaut, avec l'ajout d'un seul élément, gaspille 36 ou 72 octets. <br><br>  En fait, une <code>ArrayList</code> vide gaspille également de la mémoire car elle ne porte aucune charge de travail, mais la taille de la <code>ArrayList</code> elle-même n'est pas nulle et plus grande que vous ne le pensez probablement.  En effet, d'une part, chaque objet géré par la JVM HotSpot possède un en-tête de 12 ou 16 octets, qui est utilisé par la JVM à des fins internes.  De plus, la plupart des objets de la collection contiennent un champ de <code>size</code> , un pointeur vers un tableau interne ou un autre objet «workload media», un champ <code>modCount</code> pour suivre les changements de contenu, etc. Ainsi, même le plus petit objet possible représentant une collection vide aura probablement besoin d'au moins 32 octets de mémoire.  Certains, comme <code>ConcurrentHashMap</code> , en prennent beaucoup plus. <br><br>  Prenons une autre collection courante - la classe <code>java.util.HashMap</code> .  Son cycle de vie est similaire au cycle de vie d' <code>ArrayList</code> : <br><br><img src="https://habrastorage.org/webt/qu/ov/lm/quovlmld5clm9w8f0x3v7a_kor8.png"><br><br>  Comme vous pouvez le voir, un <code>HashMap</code> contenant une seule paire clé-valeur dépense 15 cellules internes du tableau, ce qui correspond à 60 ou 120 octets.  Ces nombres sont faibles, mais l'étendue de la perte de mémoire est importante pour toutes les collections de votre application.  Et il s'avère que certaines applications peuvent dépenser beaucoup de mémoire de cette façon.  Par exemple, certains des composants Hadoop open source populaires que l'auteur a analysés perdent environ 20% de leur tas dans certains cas!  Pour les produits développés par des ingénieurs moins expérimentés qui ne sont pas soumis à des évaluations régulières des performances, la perte de mémoire peut être encore plus élevée.  Il y a suffisamment de cas où, par exemple, 90% des nœuds dans une immense arborescence ne contiennent qu'un ou deux descendants (ou rien du tout), et d'autres situations où le tas est obstrué par des collections à 0, 1 ou 2 éléments. <br><br>  Si vous trouvez des collections inutilisées ou sous-utilisées dans votre application, comment les corriger?  Voici quelques recettes courantes.  Ici, on suppose que notre collection problématique est une <code>ArrayList</code> référencée par le champ de données <code>Foo.list</code> . <br><br>  Si la plupart des instances de la liste ne sont jamais utilisées, essayez de l'initialiser paresseusement.  Donc, le code qui ressemblait auparavant ... <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ list.add(x); }</code> </pre> <br>  ... devrait être refait en quelque chose comme <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ getOrCreateList().add(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> list </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,         if (list == null) list = new ArrayList(); return list; }</span></span></code> </pre> <br>  Gardez à l'esprit que, parfois, vous devrez prendre des mesures supplémentaires pour lutter contre la concurrence potentielle.  Par exemple, si vous prenez en charge <code>ConcurrentHashMap</code> , qui peut être mis à jour simultanément par plusieurs threads, le code qui l'initialise ne doit pas autoriser deux threads à créer deux copies de cette carte de manière aléatoire: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (map == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//,       synchronized (this) { if (map == null) map = new ConcurrentHashMap(); } } return map; }</span></span></code> </pre> <br>  Si la plupart des instances de votre liste ou carte ne contiennent que quelques éléments, essayez de les initialiser avec une capacité initiale plus appropriée, par exemple. <br><br><pre> <code class="java hljs">list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       4</span></span></code> </pre> <br>  Si vos collections sont vides ou contiennent un seul élément (ou une paire clé-valeur) dans la plupart des cas, vous pouvez envisager une forme extrême d'optimisation.  Cela ne fonctionne que si la collection est entièrement gérée dans la classe actuelle, c'est-à-dire qu'aucun autre code ne peut y accéder directement.  L'idée est que vous modifiez le type de votre champ de données, par exemple, de Liste à un Objet plus général, de sorte qu'il puisse désormais pointer soit vers une vraie liste, soit directement vers un seul élément de liste.  Voici un bref croquis: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ***   *** private List&lt;Foo&gt; list = new ArrayList&lt;&gt;(); void addToList(Foo foo) { list.add(foo); } // ***   *** //   ,    null.      , //      .       //   ArrayList. private Object listOrSingleEl; void addToList(Foo foo) { if (listOrSingleEl == null) { //   listOrSingleEl = foo; } else if (listOrSingleEl instanceof Foo) { //  Foo firstEl = (Foo) listOrSingleEl; ArrayList&lt;Foo&gt; list = new ArrayList&lt;&gt;(); listOrSingleEl = list; list.add(firstEl); list.add(foo); } else { //      ((ArrayList&lt;Foo&gt;) listOrSingleEl).add(foo); } }</span></span></code> </pre> <br>  De toute évidence, le code avec cette optimisation est moins clair et plus difficile à maintenir.  Mais cela peut être utile si vous êtes sûr que cela économisera beaucoup de mémoire ou supprimera les longues pauses du ramasse-miettes. <br><br>  Vous vous êtes probablement déjà demandé: comment savoir quelles collections de mon application utilisent de la mémoire et combien? <br><br>  En bref: il est difficile de le savoir sans les bons outils.  Essayer de deviner la quantité de mémoire utilisée ou dépensée par les structures de données dans une grande application complexe ne mènera presque jamais à rien.  Et, ne sachant pas exactement où va la mémoire, vous pouvez passer beaucoup de temps à poursuivre les mauvais objectifs, tandis que votre application continue obstinément à <code>OutOfMemoryError</code> avec <code>OutOfMemoryError</code> . <br><br>  Par conséquent, vous devez vérifier un tas d'applications à l'aide d'un outil spécial.  Par expérience, la façon la plus optimale d'analyser la mémoire JVM (mesurée en fonction de la quantité d'informations disponibles par rapport à l'effet de cet outil sur les performances des applications) est d'obtenir un vidage de tas et de le visualiser hors ligne.  Un vidage de tas est essentiellement un instantané complet du tas.  Vous pouvez l'obtenir à tout moment en appelant l'utilitaire jmap, ou vous pouvez configurer la machine <code>OutOfMemoryError</code> pour qu'elle se décharge automatiquement si l'application se bloque avec <code>OutOfMemoryError</code> .  Si vous recherchez «vidage de tas JVM» sur Google, vous verrez immédiatement un grand nombre d'articles qui expliquent en détail comment obtenir un vidage. <br><br>  Un vidage de tas est un fichier binaire de la taille d'un tas JVM, il ne peut donc être lu et analysé qu'à l'aide d'outils spéciaux.  Il existe plusieurs outils, à la fois open source et commerciaux.  L'outil open source le plus populaire est le MAT Eclipse;  il existe également VisualVM et quelques outils moins puissants et moins connus.  Les outils commerciaux comprennent des profileurs Java à usage général: JProfiler et YourKit, ainsi qu'un outil spécialement conçu pour l'analyse de vidage de tas - JXRay (avertissement: dernière mise au point par l'auteur). <br><br>  Contrairement à d'autres outils, JXRay analyse immédiatement le vidage de tas pour un grand nombre de problèmes courants, tels que des lignes répétées et d'autres objets, ainsi que des structures de données insuffisamment efficaces.  Les problèmes avec les collections décrites ci-dessus entrent dans cette dernière catégorie.  L'outil génère un rapport avec toutes les informations collectées au format HTML.  L'avantage de cette approche est que vous pouvez visualiser les résultats d'analyse n'importe où et à tout moment et les partager facilement avec d'autres.  Vous pouvez également exécuter l'outil sur n'importe quelle machine, y compris les machines grandes et puissantes, mais «sans tête» dans le centre de données. <br><br>  JXRay calcule la surcharge (combien de mémoire vous économiserez si vous vous débarrassez d'un problème particulier) en octets et en pourcentage du tas utilisé.  Il combine des collections de la même classe qui ont le même problème ... <br><br><img src="https://habrastorage.org/webt/qm/_n/44/qm_n44hqttg315sv5h8wv3ujefc.png"><br><br>  ... puis regroupe les collections problématiques accessibles à partir d'une racine du ramasse-miettes via la même chaîne de liens, comme dans l'exemple ci-dessous <br><br><img src="https://habrastorage.org/webt/4o/is/ib/4oisibqplc6cj55ojwossuycohs.png"><br><br>  Savoir quelles chaînes de liens et / ou champs de données individuels (par exemple, <code>INodeDirectory.children</code> ci-dessus) indiquent que les collections qui dépensent la majeure partie de leur mémoire vous permet d'identifier rapidement et avec précision le code responsable du problème, puis d'apporter les modifications nécessaires. <br><br>  Ainsi, des collections Java insuffisamment configurées peuvent gaspiller beaucoup de mémoire.  Dans de nombreuses situations, ce problème est facile à résoudre, mais parfois vous devrez peut-être modifier votre code de manière non triviale pour obtenir une amélioration significative.  Il est très difficile de deviner quelles collections doivent être optimisées afin d'avoir le plus grand impact.  Afin de ne pas perdre de temps à optimiser les mauvaises parties du code, vous devez obtenir un vidage de tas JVM et l'analyser à l'aide de l'outil approprié. <br><br>  LA FIN <br><br>  Comme toujours, nous sommes intéressés par vos opinions et vos questions, que vous pouvez laisser ici ou laisser passer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une leçon ouverte</a> et demander à nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">professeurs</a> là-bas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420245/">https://habr.com/ru/post/fr420245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420233/index.html">UE4 | Équipement pour multijoueur # 5 | Transfert d'informations entre le serveur et le client</a></li>
<li><a href="../fr420235/index.html">Zenject: comment un conteneur IoC peut tuer l'injection de dépendance sur votre projet</a></li>
<li><a href="../fr420237/index.html">Enveloppe Qt autour du framework gRPC en C ++</a></li>
<li><a href="../fr420239/index.html">Développement mobile. Swift: le mystère des protocoles</a></li>
<li><a href="../fr420243/index.html">Philanthropie révolutionnaire: projets de percée humanitaire</a></li>
<li><a href="../fr420251/index.html">Apple affirme que le complexe du siège social de l'entreprise ne coûte que 200 $</a></li>
<li><a href="../fr420253/index.html">Comment les API bancaires ouvertes changent le monde financier</a></li>
<li><a href="../fr420257/index.html">Installez-vous toujours Windows 2008? Moi aussi, et c'est pourquoi</a></li>
<li><a href="../fr420259/index.html">Panneau de diagnostic du vieillissement à Singapour</a></li>
<li><a href="../fr420261/index.html">Que mesurerons-nous? Comment choisir les bonnes métriques ML pour les tâches métier</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>