<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌞 🚼 🎄 PVS-Studio for Java 🍢 ⛹🏿 👩🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在PVS-Studio静态分析器的第七版中，我们添加了对Java语言的支持。 现在该简要介绍一下我们如何开始支持Java语言，取得了多大的发展以及进一步计划中的内容。 当然，本文将列出在开源项目上进行的首批分析仪试用。 

 PVS工作室 
 这是PVS-Studio的简短描述，适用于以前从未听说过...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio for Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436496/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio for Java"></div><br> 在PVS-Studio静态分析器的第七版中，我们添加了对Java语言的支持。 现在该简要介绍一下我们如何开始支持Java语言，取得了多大的发展以及进一步计划中的内容。 当然，本文将列出在开源项目上进行的首批分析仪试用。 <br><a name="habracut"></a><br><h2>  PVS工作室 </h2><br> 这是PVS-Studio的简短描述，适用于以前从未听说过的Java开发人员。 <br><br> 此工具旨在检测用C，C ++，C＃和Java编写的程序源代码中的错误和潜在漏洞。 它适用于Windows，Linux和macOS环境。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>执行静态代码分析并生成报告，以帮助开发人员发现并消除缺陷。 对于那些对PVS-Studio如何精确搜索错误感兴趣的人，建议阅读一下文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio代码分析器中用于查找错误和潜在漏洞的技术</a> ”。 <br><br><h2> 开始 </h2><br> 我本可以想出一个聪明的故事，说明我们一直在猜测PVS-Studio支持哪种下一代语言。 关于Java的明智选择，它基于这种语言的高度流行等。 <br><br> 然而，正如生活中发生的那样，选择不是通过深入的分析，而是通过实验来做出的:)。 是的，我们考虑了PVS-Studio分析仪进一步发展的方向。 我们考虑了以下语言，例如：Java，PHP，Python，JavaScript，IBM RPG。 我们甚至倾向于Java语言，但最终选择没有做出。 对于那些对陌生的IBM RPG感兴趣的人，我想引导您阅读本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a> ，所有内容都将从中变得清晰。 <br><br>  2017年底，我的同事Egor Bredikhin审查了现成的解析代码库（换句话说，就是解析器）以寻找新的开发方向，这对我们很感兴趣。 最终，他遇到了多个用于解析Java代码的项目。 他设法通过基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spoon</a>的几个诊断程序快速创建了一个分析器原型。 而且，很明显，我们将能够在Java分析器中使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SWIG</a>来使用C ++分析器的某些机制。 我们查看了所得到的内容，并意识到我们的下一个分析器将用于Java。 <br><br> 我们要感谢Egor在Java分析器方面所做的努力和辛勤工作。 他在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开发新的静态分析器：PVS-Studio Java</a> ”中描述了开发过程本身。 <br><br><h2> 竞争对手呢？ </h2><br> 全球有许多免费的和商用的Java静态代码分析器。 没有必要在文章中将它们全部列出。 我将仅保留指向“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">静态代码分析工具列表</a> ”的链接（请参阅Java和多语言部分）。 <br><br> 但是，我知道首先要问我们关于IntelliJ IDEA，FindBugs和SonarQube（SonarJava）的问题。 <br><br>  <b>IntelliJ IDEA</b> <br><br>  IntelliJ IDEA内置了功能非常强大的静态代码分析器。 此外，分析仪正在不断发展，其作者密切关注我们的活动。 因此，IntelliJ IDEA对我们来说是一个艰难的曲奇。 至少到目前为止，我们无法在诊断能力上超过IntelliJ IDEA。 因此，我们将专注于我们的其他优势。 <br><br>  IntelliJ IDEA中的静态分析主要是环境的功能之一，这对其施加了某些限制。 对于我们来说，我们可以自由地使用分析仪。 例如，我们可以快速使其适应特定的客户需求。 快速而深入的支持是我们的竞争优势。 我们的客户直接与开发人员联系，在PVS-Studio的一个或另一部分上工作。 <br><br> 在PVS-Studio中，有很多机会可以将其集成到开发大型旧项目的周期中。 例如，这是我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">与SonarQube</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集成</a> 。 它还包括对分析器警告的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">批量抑制</a> ，这使您可以立即在大型项目中开始使用该工具来仅跟踪新代码或修改后的代码中的错误。  PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以</a>在持续集成过程中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构建</a> 。 我认为这些功能和其他功能将帮助我们的分析仪在Java世界中找到太阳之下的位置。 <br><br>  <b>虫子</b> <br><br>  FindBugs项目被放弃。 尽管如此，我们还是应该提到它，因为它也许是最著名的Java代码免费静态分析器。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SpotBugs</a>可以称为FindBugs的后继者。 但是，它不那么受欢迎，并且尚不清楚会发生什么。 <br><br> 总体而言，我们认为，尽管FindBugs一直并且仍然非常受欢迎，并且除了免费的分析器之外，我们不应该再赘述。 这个项目将悄然成为历史。 <br><br>  PS：顺便说一下，现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a>开放项目时，PVS-Studio也可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">免费使用</a> 。 <br><br>  <b>SonarQube（SonarJava）</b> <br><br> 我们相信我们不会与SonarQube竞争，而是对其进行补充。  PVS-Studio集成在SonarQube中，这使开发人员可以在他们的项目中发现更多的错误和潜在的安全漏洞。 我们定期告诉我们如何在不同会议上举行的大师班上将PVS-Studio工具和其他分析仪集成在SonarQube中。 <br><br><h2> 如何为Java运行PVS-Studio </h2><br> 我们为用户提供了构建系统中最流行的分析仪集成方式： <br><br><ul><li>  Maven插件； </li><li>  Gradle插件； </li><li>  IntelliJ IDEA的插件 </li></ul><br> 在测试阶段，我们遇到了许多拥有自行编写的构建系统的用户，尤其是在移动开发领域。 他们享受了直接运行分析器的机会，列出了源代码和类路径。 <br><br> 您可以在文档页面“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何运行PVS-Studio Java</a> ”中找到有关运行分析仪的所有方法的详细信息。 <br><br> 我们无法回避在Java开发人员中非常流行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SonarQube</a>代码质量控制平台，因此我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SonarQube插件中</a>添加了对Java语言的支持。 <br><br><h2> 进一步的计划 </h2><br> 我们有很多想法可能需要进一步研究，但是我们的任何分析仪都固有一些特定的计划，如下所示： <br><br><ul><li> 创建新的诊断并改进现有诊断； </li><li> 改进数据流分析； </li><li> 可靠性和可用性的提高。 </li></ul><br> 也许，我们会花时间将IntelliJ IDEA插件用于CLion。 向了解Java分析器的C ++开发人员问好：-) <br><br><h2> 开源项目中发现的错误示例 </h2><br> 如果我没有在文章中显示新的分析仪发现的一些错误，则不寒而栗！ 好吧，我们可以像往常一样做一个大型开源Java项目并写一篇经典文章来回顾错误。 <br><br> 但是，我立即想到有关在IntelliJ IDEA，FindBugs等项目中可以找到的内容的问题。 因此，除了开始这些项目之外，我别无选择。 因此，我决定快速检查并写出以下项目中一些有趣的错误示例： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IntelliJ IDEA社区版</a> 。 我认为无需解释为什么选择此项目:)。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SpotBugs</a> 如我先前所写，FindBugs项目没有进展。 因此，让我们看一下SpotBugs项目，它是FindBugs的后继项目。  SpotBugs是经典的Java代码静态分析器。 </li><li>  SonarSource公司的项目，该公司开发了用于连续监视代码质量的软件。 现在，让我们看一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SonarQube</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SonarJava</a> 。 </li></ul><br> 撰写有关这些项目的错误的知识是一个挑战。 事实是这些项目的质量很高。 实际上，这并不奇怪。 我们的观察表明，静态代码分析器始终使用其他工具进行了良好的测试和验证。 <br><br> 尽管如此，我还是必须从这些项目开始。 我没有第二次机会写关于他们的文章。 我确信，PVS-Studio for Java发行后，列出的项目的开发人员将把PVS-Studio拿到船上，并开始将其用于定期检查（至少是偶尔检查其代码）。 例如，我知道JetBrains的开发者之一Tagir Valeev（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">lany</a> ）正在IntelliJ IDEA静态代码分析器上工作，而当我正在撰写本文时，该文章已经在使用Beta版本的PVS-Studio。 。 他给我们写了大约15封电子邮件，其中包含错误报告和建议。 谢谢，塔吉尔！ <br><br> 幸运的是，我不需要在一个特定项目中发现那么多错误。 目前，我的任务是证明Java的PVS-Studio分析器没有白费，并且将能够填充其他旨在提高代码质量的工具。 我只是浏览了分析器报告，并列出了一些看起来很有趣的错误。 如果可能，我尝试引用不同类型的错误。 让我们看看结果如何。 <br><br><h3>  IntelliJ IDEA，整数部 </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  PVS-Studio警告：V6011 [CWE-682]将'double'类型的'0.2'文字与'int'类型的值进行比较。  TitleCapitalizationInspection.java 169 <br><br> 关键是，如果少于20％的单词以大写字母开头，则该函数应返回true。 实际上，该检查不起作用，因为发生了整数除法。 作为除法的结果，我们只能获得两个值：0或1。 <br><br> 仅当所有单词都以大写字母开头时，该函数才会返回false。 在所有其他情况下，除法运算将得出0，并且该函数将返回true。 <br><br><h3>  IntelliJ IDEA，可疑循环 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  PVS-Studio警告：V6007 [CWE-571]表达式'index&gt; = 0'始终为true。  Updater.java 184 <br><br> 首先，查看条件<i>（0 &lt;= current &amp;&amp; current &lt;count）</i> 。 仅当<i>计数</i>变量值大于0时才执行。 <br><br> 现在看一下循环： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br> 变量<i>索引</i>用表达式<i>count-1</i>初始化。 当<i>计数</i>变量大于0时， <i>索引</i>变量的初始值将始终大于或等于0。事实证明，将执行循环，直到<i>索引</i>变量发生溢出为止。 <br><br> 最有可能的是，这只是一个错字，并且必须执行减量而不是变量的增量： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IntelliJ IDEA，复制粘贴 </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  PVS-Studio警告：V6001 [CWE-570]在“ ||”的左侧和右侧有相同的子表达式“ LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase（str）”。 操作员。 检查行：127，128。ExtensionOrderConverter.java 127 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最后一行效果</a>不错。 一个开发人员跳了开枪，并增加了代码行，却忘了修复它。 结果，将<i>str</i>字符串与<i>BEFORE_STR_OLD</i>比较两次。 最有可能的比较之一必须是与<i>AFTER_STR_OLD</i>进行比较。 <br><br><h3>  IntelliJ IDEA，错字 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  PVS-Studio警告：V6001 [CWE-571]在'&amp;&amp;'运算符的左侧和右侧有相同的子表达式'！StringUtil.endsWithChar（name，'“'）'。JsonNamesValidator.java 27 <br><br> 此代码段检查名称是否用单引号或双引号引起来。 如果不是这样，则会自动添加双引号。 <br><br> 由于输入错误，仅检查名称的末尾是否包含双引号。 结果，单引号中的名称将被错误地处理。 <br><br> 名字 <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br> 由于添加额外的双引号将变成： <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA，针对阵列溢出的错误保护 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  PVS-Studio警告：V6007 [CWE-571]表达式'i &lt;endOffset'始终为true。  EnterAfterJavadocTagHandler.java 183 <br><br>  <i>如果if</i>运算符没有意义， <i>则</i>子表达式<i>i &lt;endOffset</i> 。 在任何情况下， <i>i</i>变量始终小于<i>endOffset</i> ，这<i>取决于</i>循环执行的条件。 <br><br> 开发人员很可能希望在调用函数时防止字符串溢出： <br><br><ul><li>  text.charAt（i + 1） </li><li>  CharArrayUtil.regionMatches（文本，i + 2，endOffset，startTag） </li></ul><br> 在这种情况下，用于检查索引的子表达式必须为： <i>（i）&lt;endOffset-2</i> 。 <br><br><h3>  IntelliJ IDEA，重复检查 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  PVS-Studio警告：V6007 [CWE-571]表达式'buffer.length（）&gt; 0'始终为true。  DeleteUtil.java 62 <br><br> 这可能是无害的冗余代码，也可能是严重错误。 <br><br> 如果重复检查意外出现（例如在重构过程中），则没有任何问题。 您只需删除第二张支票即可。 <br><br> 另一种情况也是可能的。 第二次检查必须完全不同，并且代码的行为也不符合预期。 那是一个真正的错误。 <br><br>  <b>注意事项</b> 顺便说一下，有很多各种各样的冗余检查。 好吧，通常很明显这不是错误。 但是，我们不能将分析仪警告视为误报。 作为解释，我想举一个例子，也取自IntelliJ IDEA： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br> 分析器说函数<i>text.contains（“ \ r \ n”）</i>始终返回false。 确实，如果找不到字符“ \ n”和“ \ r”，则没有必要搜索“ \ r \ n”。 这不是错误，并且代码不好是因为它的工作速度稍慢，对子字符串进行无意义的搜索。 <br><br> 在每种情况下，如何处理此类代码都是开发人员的问题。 在撰写文章时，我通​​常不关注此类代码。 <br><br><h3>  IntelliJ IDEA，出现了问题 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  PVS-Studio警告：V6007 [CWE-570]表达式'“ 0” .equals（text）'始终为false。  ConvertIntegerToDecimalPredicate.java 46 <br><br> 该代码肯定包含逻辑错误。 我发现很难说程序员到底要检查什么以及如何纠正缺陷。 因此，在这里，我将指向毫无意义的检查。 <br><br> 首先，必须检查字符串是否包含至少两个符号。 如果不是这样，则该函数返回<i>false</i> 。 <br><br> 接下来是校验<i>“ 0” .equals（文本）</i> 。 这是没有意义的，因为任何字符串只能包含一个字符。 <br><br> 因此，这里有些问题，并且代码应该固定。 <br><br><h3>  SpotBugs（FindBugs的后继者），迭代次数限制错误 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  PVS-Studio警告：V6007 [CWE-571]表达式'count &lt;4'始终为true。 实用程序394 <br><br> 理论上，必须仅在文件的前四行中搜索xml标记。 但是由于这一事实，一个忘记增加<i>计数</i>变量，整个文件将被读取。 <br><br> 首先，这可能是一个非常慢的操作，其次，在文件中间的某个位置，可能会发现一些被视为xml标记而不是它的标记。 <br><br><h3>  SpotBugs（FindBugs的后继者），清除值 </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  PVS-Studio警告：V6021 [CWE-563]该值已分配给“优先级”变量，但未使用。  FindNonShortCircuit.java 197 <br><br> 根据变量<i>sawNullTestVeryOld</i>的值设置<i>优先级</i>变量的值。 但是，这并不重要。 之后，在任何情况下都将为<i>优先级</i>变量分配另一个值。 函数逻辑中明显的错误。 <br><br><h3>  SonarQube，复制粘贴 </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio：V6032奇怪的是，方法“ setUpdatedAtFromDefinition”的主体完全等效于另一种方法“ setUpdatedAtFromMetadata”的主体。 检查行：396，405。RuleDto.java 396 <br><br> 在<i>setUpdatedAtFromMetadata</i>方法中使用了一个<i>定义</i>字段。 最有可能应使用<i>元数据</i>字段。 这与复制粘贴失败的效果非常相似。 <br><br><h3>  SonarJava，初始化地图时重复 </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  PVS-Studio警告：V6033 [CWE-462]已添加带有相同键“ JavaPunctuator.PLUSEQU”的项目。 检查行：104、100。KindMaps.java 104 <br><br> 在地图中两次设置了相同的键值对。 最有可能的是，它无意间发生了，实际上没有真正的错误。 但是，无论如何都必须检查此代码，因为也许一个人忘记添加任何其他对。 <br><br><h2> 结论 </h2><br> 为什么要写结论如此明显？ 我建议大家立即下载PVS-Studio并尝试检查Java语言上的工作项目！  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载PVS-Studio</a> 。 <br><br> 谢谢大家的关注。 我希望不久以后，我们会为读者提供一系列有关检查各种开源Java项目的文章。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436496/">https://habr.com/ru/post/zh-CN436496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436486/index.html">音频播客市场正在发生什么</a></li>
<li><a href="../zh-CN436488/index.html">C ++ 14中的咖喱和部分应用</a></li>
<li><a href="../zh-CN436490/index.html">摩托罗拉计划推出Razr v3版本</a></li>
<li><a href="../zh-CN436492/index.html">我们正在寻找第十届DIY Mitap的演讲者2019年2月17日</a></li>
<li><a href="../zh-CN436494/index.html">更换磁盘同时保持CEPH中的正确编号</a></li>
<li><a href="../zh-CN436498/index.html">Software AG：不仅是ARIS</a></li>
<li><a href="../zh-CN436500/index.html">古墓丽影：崛起的框架如何呈现</a></li>
<li><a href="../zh-CN436502/index.html">订阅纵容或如何向相同的客户销售更多商品</a></li>
<li><a href="../zh-CN436504/index.html">系统级封装还是芯片封装下的封装？</a></li>
<li><a href="../zh-CN436506/index.html">如何轻松创建AI种族主义者</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>