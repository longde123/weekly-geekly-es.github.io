<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚕 🗃️ 🎓 Android Go est le futur milliard d'appareils et une limite de 50 Mo. Conférence Yandex 🎆 👩🏾‍🚒 ⛳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nouvelles directions pour le développement d'une plateforme déjà familière - c'est toujours intéressant. D'une part, vous élargissez la clientèle, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android Go est le futur milliard d'appareils et une limite de 50 Mo. Conférence Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/423493/">  De nouvelles directions pour le développement d'une plateforme déjà familière - c'est toujours intéressant.  D'une part, vous élargissez la clientèle, d'autre part, vous n'investissez pas dans la création de logiciels à partir de zéro, mais en utilisant les développements existants.  Mais si la direction est vraiment nouvelle, avec ses spécificités, alors il ne sera pas possible de gérer avec très peu de sang.  Lors de la prochaine réunion de la communauté Mosdroid dans notre bureau, le développeur Arthur Vasilov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Arturka a</a> parlé de l'adaptation de l'application Yandex au système Android Go. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VYcLRPoA4Bk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote>  En moyenne, si vous n'écrivez pas de calculatrice, de réveil, etc., alors soit vous êtes très cool, bien fait et avez tout bien fait, soit votre application prend 150-170 mégaoctets. </blockquote><br><a name="habracut"></a>  - Je m'appelle Arthur, je suis développeur Android, je travaille sur l'application Yandex.  Aujourd'hui, je vais partager avec vous une histoire sur la façon dont nous nous sommes adaptés à Android Go.  Je vais vous dire sur quel type de râteau nous sommes tombés, ce qui n'a pas fonctionné pour nous et comment tout cela fonctionne, pourquoi il est nécessaire. <br><br>  Une petite digression sur ce dont il s'agit.  Android Go est une version spéciale d'Android conçue pour les appareils à bas prix.  Ils coûtent de 60 à 100 dollars et sont donc très faibles, lents, ralentis.  Google a donc décidé pour eux de créer leur propre système afin qu'ils fonctionnent au moins normalement.  Il a été annoncé sur Google I / O en 2017, soit un an et plusieurs mois se sont écoulés.  Par conséquent, lorsque le mitap a été annoncé, une question logique a été soulevée: "Êtes-vous toujours en vie, ou quoi?"  J'ai alors dit que tout va bien, tout va bien, je vais le dire.  Et maintenant, en tant que héros Internet typique, je répondrai a posteriori pourquoi cela s'est produit. <br><br><img src="https://habrastorage.org/webt/h2/qw/6g/h2qw6gttth_hx-niydwklvvcb8u.jpeg"><br>  Que s'est-il passé exactement?  Google a déclaré: "Nous créons un tel système."  Puis il a dit: "D'accord, nous avons besoin de temps pour finaliser" et tout ça.  Après cela, les fournisseurs ont toujours un certain retard dans l'adaptation de cette version pour eux-mêmes.  Et la nouvelle version avec nous est déjà sortie au plus tôt un an plus tard, il n'y a donc rien de surprenant ici.  De plus, ils devaient décider de faire une telle chose: ils parlent d'appareils bon marché et il n'est pas clair s'ils en profiteront ou non.  De plus, cet appareil doit être neuf, il faut le faire, apprendre à vendre, comprendre comment il fonctionnera. <br><br>  Le premier smartphone avec Android Go est apparu il n'y a pas si longtemps.  Quelque part en avril, les ventes ont probablement commencé, ou peut-être en mai.  C'est Nokia 1, il est vendu partout.  Je traîne ici.  Maintenant, à mon avis, il n'y a que neuf de ces smartphones sur le marché, mais à la fin de l'année, ils promettent plus d'une centaine.  Et en principe, aucun des principaux acteurs tels que Huawei, Samsung et d'autres n'ont dit leur mot, alors ils ajouteront autre chose, ils ne pourront pas rester à l'écart d'un marché aussi important. <br><br>  Avant le rapport, je suis allé sur la page Android Go et j'ai vu qu'ils faisaient l'édition Android Pie Go.  Mais ils n'y ont rien fait, ils ont simplement réduit à l'avance le nombre d'applications installées et leur poids.  Ils ont dit: - "Vous avez maintenant deux fois plus d'espace libre."  Et les excuses standard: correction de bugs, amélioration des performances, tout.  Mais au moins, ils ont appelé, ce qui signifie qu'ils n'ont pas oublié. <br><br>  Quelles sont les limites de ces appareils, en particulier?  Premièrement, ils ont 512 mégaoctets ou 1 gigaoctet de RAM, 8 ou 16 gigaoctets de stockage.  Il est clair que dans de telles conditions, ils sont extrêmement inhibés et toutes les applications normales sur eux fonctionneront approximativement de la même manière.  Pour que les applications fonctionnent avec une adéquation minimale, Google a déclaré: «Introduisons les exigences suivantes.»  Ils sont assez logiques, découlent de ce qui était sur la diapositive précédente. <br><br><img src="https://habrastorage.org/webt/ci/xm/ht/cixmhtwrdwbu_gkczbo0vk3-k8e.jpeg"><br><br>  Tout d'abord, c'est une bonne performance abstraite.  Votre application doit fonctionner correctement et rapidement sur un tel appareil.  Nous sommes: «Génial.  Nous travaillons. " <br><br>  De plus, il existe déjà des numéros spécifiques auxquels nous devons correspondre.  L'espace occupé après le déballage et l'installation de l'APK ne dépasse pas 40 mégaoctets.  Parfois, c'est un problème car quelqu'un et l'APK pèsent tous les 80 mégaoctets.  Ça va faire mal.  De plus, cela ne peut pas être correctement pris et mesuré.  Autrement dit, vous ne pouvez pas dire: "Je sais que mon APK pèse tellement, donc après l'installation, l'application prendra tellement."  Tout cela dépend beaucoup du fournisseur, de la version de l'appareil, d'Android, etc. Mais si votre APK prend 10 mégaoctets, alors, en principe, tout va bien et vous ne dépasserez jamais ce nombre. <br><br>  Et maintenant, l'exigence la plus amusante et la plus cool: la RAM consommée lors du travail avec l'application ne doit pas dépasser 50 mégaoctets. <br><br>  Qui sait combien de RAM sa demande prend en moyenne pendant le fonctionnement?  Qui s'est jamais interrogé sur cette question?  Y a-t-il quelqu'un avec moins de 100 mégaoctets?  Beau.  Mais peut-être que vous mentez.  En général, en moyenne, si vous n'écrivez pas de calculatrice, de réveil et ainsi de suite, alors soit vous êtes très cool, bien fait et vous avez tout bien fait, soit votre application prend 150-170 mégaoctets.  Le mettre dans 50 mégaoctets est très difficile.  Par conséquent, le reste du temps, nous en parlerons, nous discuterons de la façon de mettre le globe en hibou, etc. <br><br><img src="https://habrastorage.org/webt/6k/el/g1/6kelg1qxjmzqgltficsia2dk1p0.jpeg"><br>  Que comprend notre conversation sur la mémoire?  Il est directement nécessaire de comprendre ce que nous mesurons exactement, puis quelle est la meilleure façon de le mesurer.  Aussi pour les appareils Android Go, il y a une spécificité qui doit être prise en compte, et nous en parlerons également.  Et je vais également vous dire des choses générales, des conseils généraux que vous n'auriez peut-être pas devinés, mais ils peuvent vraiment vous manger beaucoup de mémoire. <br><br>  En 2018, après le passage des E / S Google, vous devez commencer l'histoire de la mémoire en faisant référence à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce rapport</a> .  Qui l'a regardé? <br><br>  Super.  Les 180 personnes restantes savent quoi faire dans un avenir proche.  À mon avis, c'est l'un des meilleurs rapports sur Google I / O.  Mec a dit des choses incroyablement cool.  Il a tout raconté sur les étagères, enfin, et avec beaucoup de détails profonds.  Ceux qui l'ont regardé et qui s'en souviennent bien remarqueront probablement que j'ai copié certaines choses à partir de là, car c'est impossible autrement, il a tout dit, alors je vais le répéter. <br><br>  Que mesurons-nous?  Il y avait une telle chose appelée PSS (Proportional Set Size).  Autrement dit, la RAM dans Android est représentée par environ 40 blocs de kilo-octets, et ces blocs peuvent appartenir entièrement à l'application ou fouiller entre les processus et les applications. <br><br>  Et la question est: comment comprendre exactement à quelle application relier cette mémoire partagée?  Il existe plusieurs approches, elles sont assez logiques.  PSS dit que si la mémoire tente entre N processus, nous supposerons que votre application possède 1 / N de cette mémoire.  Et exactement de la même manière, il y a la taille de l'ensemble résidentiel et la taille de l'ensemble unique, qui disent que «Aucune de la mémoire partagée ne m'appartient» et «Tout appartient».  En principe, PSS est le plus logique ici. <br><br>  Comment pouvez-vous mesurer exactement la mémoire consommée?  Ici, tout est simple.  Soit c'est un profileur dans Android Studio, soit c'est dumpsys.  Il existe bien sûr d'autres outils.  Ils peuvent vous donner des résultats plus détaillés, quelque chose de plus compliqué, mais le problème est que pour comprendre leurs résultats, les utiliser tout cela est très, très difficile.  Souvent, vous avez besoin de root ou d'une version personnalisée d'Android.  Et en gros vous n'en avez pas besoin, les deux premiers outils suffisent. <br><br><img src="https://habrastorage.org/webt/0r/--/pr/0r--prgyak0-hltivshg-dxeuqc.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien depuis la diapositive</a></sup></sub> </h5><br>  Je ne parlerai pas du profileur dans Android Studio, je pense que beaucoup de gens l'ont utilisé.  Qui n'a pas utilisé, assurez-vous de pousser.  En particulier, j'ai fourni le lien ci-dessous - juste un bon article de la documentation avec vidéo, comment l'utiliser, avec des démos.  Et, en principe, tout est clair.  Il montre où va votre mémoire, le montre en temps réel.  La seule chose à retenir est qu'elle impose néanmoins certaines erreurs qui découlent du fait que nous mesurons constamment cette mémoire.  Mais ils sont dans des limites acceptables. <br><br><img src="https://habrastorage.org/webt/gb/fv/wn/gbfvwnjxm6fcggr66eoyzmcvnni.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien depuis la diapositive</a></sup></sub> </h5><br>  Dumpsys est une console simple qui ne nécessite rien de vous, juste un téléphone connecté et un adb.  Et vous pouvez exécuter cette commande: appelez dumpsys meminfo, passez-lui le paquet et il vous renverra quelque chose comme ça.  Et si nous sommes intéressés par la consommation de notre application, nous pouvons examiner spécifiquement TOTAL, qui indique que "votre application consomme environ 168 mégaoctets".  Beaucoup, mais que faire? <br><br><img src="https://habrastorage.org/webt/lm/yo/xw/lmyoxwiahsbeey_ru-3zvdtd8y0.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien depuis la diapositive</a></sup></sub> </h5><br>  Il vous montre également une ventilation exacte de la quantité de mémoire nécessaire dans cette mémoire consommée.  Il y a différentes sections ici, elles sont complexes, nous en parlerons plus loin, mais pour l'instant nous pouvons remarquer l'essentiel - ce sont Java Heap, nos objets Java, et tout est plus compliqué. <br><br>  Quoi d'autre est important?  La mémoire est une chose très sensible à toutes sortes de tests et à toutes sortes de conditions externes.  Autrement dit, tous les tests que vous devez effectuer autant que possible dans les mêmes conditions.  Il est clair que cela devrait idéalement être un seul appareil, car la mémoire dépend de la version d'Android.  Il suffit de rappeler les différences entre les quatre et les cinq.  Cela dépend de la taille ou de la résolution de l'écran, car plus la taille de l'écran est grande, plus le contenu s'introduit, plus vous avez besoin de mémoire pour tout dessiner.  Plus la résolution est élevée, plus votre bitmap occupe de pixels et plus de mémoire est nécessaire pour les stocker. <br><br>  Le scénario d'application affecte également les tests.  Vous pouvez lire le texte ou faire défiler la galerie avec un tas d'images.  Et il est clair où il y aura plus de mémoire. <br><br>  Une autre chose importante est la charge sur l'appareil.  Autrement dit, vous pouvez tout avoir de la même façon, mais dans un cas, votre application est la seule qui fonctionne pour vous, et dans l'autre cas, vous avez un tas d'applications qui font quelque chose en arrière-plan, téléchargent quelque chose, le suppriment, travaillent au premier plan , et en même temps, votre mémoire est simplement épuisée, car vous devez la donner à d'autres applications.  Par conséquent, idéalement, il est préférable de prendre et de tuer d'abord toutes les autres applications qui fonctionnent, pas la vôtre.  Tout ce que vous pouvez atteindre, puis tuer.  Juste dans ce cas, et PSS vous remerciera certainement, car il ne sera pas nécessaire de tâtonner la mémoire entre les processus. <br><br><img src="https://habrastorage.org/webt/lm/yo/xw/lmyoxwiahsbeey_ru-3zvdtd8y0.jpeg"><br>  Vous pouvez, par exemple, prendre et voir les informations actuelles sur la mémoire libre, sur la mémoire occupée.  Il vous apportera quelque chose comme un signe qui dit: «Ici, j'ai tellement de mémoire libre, tellement de mémoire en cache, tellement de mémoire occupée.»  Et si vous avez 200 à 250 mégaoctets de mémoire libre pour votre bien-aimé là-bas, alors c'est bien, très probablement, alors rien n'affectera vos tests. <br><br>  Peut-être que quelqu'un a maintenant la question "Pourquoi ai-je besoin de tout cela?"  C'est un tel casse-tête dans lequel je dirai en outre la motivation de tout cela. <br><br>  Premièrement, même si vous ne faites rien sous Android Go maintenant et pensez qu'il est mort, il pourrait bien se développer, venir à vous, et à un moment donné, vous devrez faire face à tout cela. <br><br>  La deuxième chose que je considère très importante est que vous pouvez simplement faire des tests de régression à partir de la mémoire.  Autrement dit, vous pouvez simplement écrire un script qui exécutera l'application, fera des vidages, prendra de telles mesures et observera comment ces indicateurs changent entre les versions.  Un tel script peut être écrit en quelques heures, l'infrastructure peut être configurée plus longtemps, mais il me semble que c'est une bonne chose. <br><br>  Si nous parlons des spécificités d'Android Go - notre troisième point dans la lutte contre la mémoire - alors il y a de bonnes nouvelles.  Tout d'abord, personne ne vous oblige vraiment à respecter ces restrictions.  Autrement dit, vous pouvez utiliser l'application telle quelle, la mettre sur l'appareil avec Android Go, et tout va bien.  Le problème est que l'utilisateur est très susceptible de vous retirer car vous prenez beaucoup de place.  Votre application peut également s'exécuter lentement et avoir beaucoup de mémoire, oui.  Mais jusqu'à présent, personne ne l'a interdit, car sinon il n'y aurait eu aucune application autre que les applications Google sur Android Go.  Mais si cette chose se développe, beaucoup s'adapteront à de telles conditions, puis, au final, votre application peut simplement être réduite dans l'émission Android Go, ou dire comment l'utilisateur installe l'application sur son smartphone Android Go, ils peuvent lui montrer Alert : "Mec, l'application ne fonctionne pas bien avec Android Go.  Peut-être que vous ne le mettrez pas? " <br><br>  Il y a un autre point - vous pouvez exclure manuellement les appareils Android Go de Google Play, c'est-à-dire que l'application ne peut pas être installée sur les appareils Android Go.  Il est apparu il n'y a pas si longtemps. <br><br>  Et Google est également assez intelligent, et les 50 mégaoctets qui sonnaient dans le titre du rapport ne sont pas un nombre fixe, cela dépend de la résolution de l'appareil, de la taille de l'écran et, en outre, du type d'application.  Par exemple, les jeux sont alloués plus, à mon avis, 115 mégaoctets.  En principe, cela est compréhensible. <br><br><img src="https://habrastorage.org/webt/gu/yj/0s/guyj0sbre79wfwrlzgupt009xn0.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien depuis la diapositive</a></sup></sub> </h5><br>  Et si nous parlons directement de ce test?  Il y a un autre point, qui nous préoccupe beaucoup en particulier: travailler avec des préréglages.  Lorsque les fournisseurs fabriquent un nouveau téléphone, ils y mettent souvent un ensemble d'applications préinstallées.  En particulier, nous y sommes très impliqués, et le problème est qu'ils y exécutent des choses comme Compatibility Test Suite.  Ce sont des tests google, ils les exécutent.  Et là, si votre application ne correspond pas à ces 50 mégaoctets, alors tout est mauvais, et votre application ne peut pas être préinstallée sur un tel appareil. <br><br>  Malheureusement, les tests que Google fait ne sont pas open source, je ne peux pas leur dire, ils sont sous le NDA, mais de bons développeurs de Google ont écrit un tel article sur Android Go, et là, en principe, il y a des recommandations qui sont assez bonnes <br><br>  Autrement dit, tout est banal.  Nous lançons l'application.  Nous attendons 5 secondes pour que tout se charge.  Nous faisons dumpsys, écrivons la valeur TOTALE, exécutons un tas de fois, nous obtenons le résultat.  Tout est très simple et banal. <br><br><img src="https://habrastorage.org/webt/zq/ma/de/zqmadexusg3whja0-dsz0d4w7gk.jpeg"><br>  La seule chose est qu'ils n'ont pas pris en compte une si petite fonctionnalité dans leur article, ou, peut-être, n'en ont pas parlé - il existe une chose telle que travailler dans un autre processus, et ils le font souvent afin de lutter contre la consommation de mémoire. <br><br>  Qui pense que c'est bon pour Android Go?  Et qui pense que c'est mauvais?  Bravement. <br><br><img src="https://habrastorage.org/webt/_c/4p/h5/_c4ph5f7gcnhakefypwspum8d_y.jpeg"><br>  Le problème est que, oui, c'est mauvais, car au final, la mémoire de votre application consommée est comptée dans tous les processus.  Si nous faisons un tel processus vide sans rien et prenons des vidages de ce processus particulier, nous verrons qu'il faut 7 mégaoctets.  5-8 mégaoctets - c'est une telle surcharge de la création du processus.  Par conséquent, lorsque nous nous battons pour que chaque mégaoctet comprenne tout en 50, une telle chose nous est très mal donnée.  En particulier, supposons que Yandex possède la bibliothèque Yandex.Metrica la plus populaire, elle fonctionne également dans un processus différent, ce qui peut également nous faire mal. <br><br><img src="https://habrastorage.org/webt/qu/os/fu/quosfu3kccdztjv7cp6ujn4rxhg.jpeg"><br>  Par conséquent, si certaines bibliothèques externes viennent à vous, par exemple, vous pouvez simplement dire: «Mec, veuillez travailler dans le processus principal.  Je suis d'accord que cela peut être plus lent, mais cela ne consommera pas de mémoire inutile. »  C'est donc aussi un point subtil. <br><br><img src="https://habrastorage.org/webt/ci/6b/9c/ci6b9cbpebgounzlbc87xids-xi.jpeg"><br><br>  Si nous parlons de consommation de mémoire, passons à cette plaque, qui est là.  Nous prenons un projet vide, et exécutons ce dumpsys, démarrons cette entreprise, et nous voyons que 23 mégaoctets de 50 sont déjà pris.  Vide "Bonjour, monde!"  sans rien, il suffit d'activer avec le texte.  Ça devient assez triste.  Il devient encore plus triste de constater que nous pouvons influencer directement un paramètre tel que Java Heap, c'est-à-dire que ce sont directement nos objets Java que nous pouvons suivre explicitement, que nous pouvons supprimer, réduire et au moins interagir d'une manière ou d'une autre. <br><br>  Et il est difficile d'interagir normalement avec tout cela, car il s'agit de tout code cadre et directement à partir de Java, vous n'avez tout simplement pas d'outils normaux pour comprendre comment tout cela est utilisé.  Mais la bonne nouvelle est que nous pouvons influencer tout cela indirectement, alors parlons de ce qui existe. <br><br><img src="https://habrastorage.org/webt/pa/p_/qp/pap_qprhxuqhr59pnjx8kxrqwos.jpeg"><br>  Qu'est-ce que Java Heap est compréhensible.  Ce qui est Native Heap est également assez logique à assumer.  Ce sont les mêmes allocations, seulement positives.  Ils proviennent du framework et de vos bibliothèques natives, des fichiers .so, etc. <br><br>  Le code est directement lié au stockage de code.  C'est la taille de votre .dex, c'est votre .so, ce sont les ressources, les fichiers mmap et tout ça.  Autrement dit, moins il y a de code, mieux c'est.  La vérité la plus simple qui fonctionne en général sur tout. <br><br>  Stack est une pile de threads Java / C ++.  C'est-à-dire que chaque thread a sa propre pile d'appels, donc chaque thread crée une zone de mémoire spécifique pour stocker tout cela. <br><br>  Les graphiques sont un rendu d'interface utilisateur.  Il y a des bitmaps partiellement stockés qui sont dessinés et ce qui y est lié. <br><br>  Autre privé, Système - c'est quelque chose que nous ne pouvons pas influencer du tout, et, en fait, tout le reste qui n'est pas très catégorisable. <br><br><img src="https://habrastorage.org/webt/ut/mv/ft/utmvfteatf-vvzdda5_a8f-iyvi.jpeg"><br><br>  Si nous parlons de bibliothèques natives, alors, disons que vous pouvez prendre une application vide ... vous pouvez prendre l'application habituelle que nous avons et en prendre des dumpsys, voir que cela prend 146 mégaoctets.  Et si vous allez couper quelque chose ... en particulier, j'ai pris et scié les deux plus grandes bibliothèques natives, dont nous avons un total de 15 mégaoctets, et prenez dumpsys après cela, vous pouvez facilement voir que nous avons perdu la consommation du tas natif et du code.  Autrement dit, avec un geste si simple, nous nous sommes économisés environ 35 mégaoctets.  Pas assez mal. <br><br><img src="https://habrastorage.org/webt/zn/9r/9v/zn9r9v35dja5ndfyz4nwinzshys.jpeg"><br><br>  Streams.  Faisons le test le plus simple.  Il y a une application vide, et il y a la même application vide, où nous prenons et faisons une boucle qui fera le nouveau Thread (), dormira dedans pendant cinq secondes et démarrera ce thread.  Vous pouvez voir que dans ce cas, la pile est considérablement reconstituée.  Autrement dit, nous pouvons influencer tout cela, mais indirectement, en réduisant le nombre de threads dans le code Java.  Autrement dit, grâce à des objets Java, y compris influencer tous ces emplacements qui se trouvent dans d'autres éléments. <br><br><img src="https://habrastorage.org/webt/4i/ed/mo/4iedmo77bys7vs6hv-f65oiuta0.jpeg"><br><br>  Si vous continuez à parler des threads, vous pouvez facilement voir ce que vous avez pour les threads, ce qu'ils font dans l'application.  Il existe différents outils.  Vous pouvez utiliser le même systrace, vous pouvez simplement utiliser la console pour trouver l'id de votre processus et saisir ps par quels threads se trouvent dans le système. <br><br>  Si vous vous débrouillez bien et utilisez toutes sortes de ThreadFactory pour nommer vos threads, alors vous pouvez comprendre ce que vous devriez avoir, ce qui ne devrait pas l'être, et ainsi réduire le tout, car avoir 100 threads dans l'application n'a pas de sens. <br><br>  Que peut-on faire d'autre?  Il existe un ensemble bien connu de conseils sur l'accordéon: surveillez les fuites, utilisez des pools, ne créez pas d'objets lorsque vous n'en avez pas besoin, et toutes ces bêtises, tout cela s'applique.  Super. <br><br>  Il existe une bonne corrélation entre la quantité de mémoire utilisée par votre application et sa taille.  Autrement dit, plus votre application est grande, plus elle consommera de mémoire, donc, d'une manière simple, réduisez le poids de l'APK, réduisez le poids de .dex, réduisez .so, supprimez tout ce qui peut être supprimé. <br><br>       . ,      ,     ,    .      ,     ?   —         —    ,      .   ,     ,        .       .   —   . <br><br><img src="https://habrastorage.org/webt/3s/mv/wk/3smvwkzryvrsm1klctrsmnxtx4i.jpeg"><br>    dumpsys,   ,      ,    . ,   ,   View,  WebView,  Assets,    . <br><br><img src="https://habrastorage.org/webt/yd/m_/92/ydm_92wzagxi-1a9zpwzkeqbe8o.jpeg"><br>  ,      , , ,     ,    SharedPreference  SQLite  - , , ,   . <br><br><img src="https://habrastorage.org/webt/1f/fs/ct/1ffsctcvhhohxpwiysekmopqwzk.jpeg"><br><br> , ,      Assets.  ,  ,    – .     1,5 . -,      ,         .    . <br><br><img src="https://habrastorage.org/webt/q5/7g/ki/q57gkiv47412jj1q9_aye3k_4e8.jpeg"><br>    —  WebView.    ,  WebView,   ,  dumpsys,  100 ,  .  , , - ,   ,  300  — .    ,  WebView ,    . -. <br><br><img src="https://habrastorage.org/webt/o9/pj/z8/o9pjz8exyayhtg1varn-wtsmw8i.jpeg"><br><br> Google   .    .      WebView,     Google,    - .     WebView.  D'accord. <br><br><img src="https://habrastorage.org/webt/nt/lp/-q/ntlp-qwbjnysaljhmmahewkcdeq.jpeg"><br><br>    Google Go,    Android Go-.       ,     - layout    ,      .  ,      ,      ,   Chrome Tabs,  Chrome    .   . <br><br>       Android Go,    ?    ,      Android Go,      . <br><br><img src="https://habrastorage.org/webt/rm/jz/cf/rmjzcfwjkfponuuzuljvu0r088q.jpeg"><br>  Il y a plusieurs façons. -,      ,    ,       Android Go   .     ,    , .         ,   , ,  - build ,  - ,    ,  - .        APK,       ,  —  uses-feature «low-memory»,      APK. <br><br>       ,     ,      Android Go.   Google. ,  ,  Go-   . <br><br>   ,   ?  ,      ,      -       ,   : «,  -  .   ».           .   ,     ,    ,      ,   ,    - ,      ,  -    .     , ,  ,    ,    Google,    Google     ,      .        ,      ,  ,   Android Go  ,       ,       . <br><br>   ,       ,       ,  -.   . <br><br><img src="https://habrastorage.org/webt/6r/wd/i-/6rwdi-8mzeuwfvvw00dh0nmdf48.jpeg"><br><h5> <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a></sup></sub> </h5><br>       ,    Google I/O:   ,          -    . ,      ,    ,  ,   ,    - ,        .    ,  «       ,      .  ».     .        ,  .    ,  . <br><br>    ? ,      .  —  ,    ,     98% .  ,         , ,    . .       -    Android Go-.  ,  YouTube Go       .    YouTube   , ,  ,   .  .   ,    Android Go    , , ,     —    .     — Facebook Lite, Twitter Lite,   . Lite,      -   . -,  ,      .    Facebook,    .       ,      ,    . ,    —   ,     Android Go. <br><br>    ?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>  Stack Overflow,    1000 .      .  ,    ,    ,     . ,  ,    —  dumpsys. <br><br>      ,  Android    ,   512   ,    Android 4.4.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> API</a>     ,     . <br><br>     ,    .    ,        .   —   ,    . <br><br>     , : « ».  : «».  .  —  ,  .  - 170 .  .  -  .    ?      , ,  ,     ,    - .     -  —   .  105 .  . <br><br><img src="https://habrastorage.org/webt/mv/qk/gj/mvqkgjfuippyzhhhcv0tmkosqzw.jpeg"><br>     .   build-   -.  densitySplit,     , resConfig,       .   ,  ,    — . ProGuard   .  ,  ProGuard  ,     ,  , ,  ,       stacktraces. <br><br>      .     ,      ,      Android Go-       . <br><br>    - 64 .  : «,   ».  14 ,  4 ,  60 .     ,   .  .  ,     .         —    ,  ,  ,     ,    .     , ,  ,     Android Go,    . 10 , APK     ,  , .   ,    ,      . <br><br>  ,    —   .        ,    . ,      ,     - ,    ,     .    .     , ,   .  . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423493/">https://habr.com/ru/post/fr423493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423483/index.html">Trouver la bonne façon de séparer le contenu d'un site Web à l'aide de Webpack</a></li>
<li><a href="../fr423485/index.html">Chargement d'images paresseuses à l'aide d'IntersectionObserver</a></li>
<li><a href="../fr423487/index.html">Node.js sans node_modules</a></li>
<li><a href="../fr423489/index.html">Je suis médecin urgentiste et je veux parler du nouvel électrocardiogramme Apple Watch</a></li>
<li><a href="../fr423491/index.html">PHP Digest n ° 139 (du 3 au 17 septembre 2018)</a></li>
<li><a href="../fr423495/index.html">Que contient XGBoost et qu'est-ce que Go a à voir avec cela?</a></li>
<li><a href="../fr423497/index.html">Essayons de parler des machines à états hiérarchiques en général et de leur support dans SObjectizer-5 en particulier</a></li>
<li><a href="../fr423499/index.html">DevBoy - comment j'ai créé un projet d'appareil open source et lancé un projet sur Kickstarter</a></li>
<li><a href="../fr423501/index.html">Recherche et création de style visuel pour un projet de design</a></li>
<li><a href="../fr423503/index.html">Mon expérience de déménagement, de vie et d'études en Allemagne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>