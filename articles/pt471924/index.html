<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥜 🍸 🧑🏼‍🤝‍🧑🏻 Introdução aos módulos Sass 👩🏾‍🎤 🕺🏻 🏔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Apresento a você a tradução do artigo “Introducing Sass Modules”, de Miriam Suzanne. 

 Recentemente, um recurso apareceu no Sass que você c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdução aos módulos Sass</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471924/"> Olá Habr!  Apresento a você a tradução do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“Introducing Sass Modules”,</a> de Miriam Suzanne. <br><br>  Recentemente, um recurso apareceu no Sass que você conhece em outros idiomas: um <b>sistema modular</b> .  Este é um grande passo em frente para o <code>@import</code> , uma das funções mais usadas no Sass.  Apesar de a diretiva <code>@import</code> existente permitir conectar pacotes de terceiros e separar seus estilos em elementos suportados, ela ainda possui várias limitações <a name="habracut"></a>  : <br><br><ul><li>  <code>@import</code> também existe em CSS, e qualquer diferença em seu comportamento pode ser confusa. </li><li>  Se você <code>@import</code> várias vezes para um arquivo, isso pode diminuir a compilação, causar conflitos de redefinição e obter código duplicado na saída. </li><li>  Tudo está no escopo global, incluindo pacotes de terceiros - é assim que minha função de <code>color</code> pode substituir sua função de <code>color</code> existente ou vice-versa. </li><li>  Quando você usa uma função como <code>color</code> , é impossível saber exatamente onde ela está definida.  Que <code>@import</code> conectou? </li></ul><br>  Os autores dos pacotes Sass (como eu) tentaram contornar os problemas do espaço para nome definindo manualmente prefixos para variáveis ​​e funções - mas os módulos Sass são uma solução muito mais poderosa.  Em resumo, <code>@import</code> está <code>@import</code> substituído por <code>@forward</code> e <code>@forward</code> mais explícitas.  Nos próximos anos, o <code>@import</code> em Sass será preterido e removido.  Você ainda pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>CSS Import</code> 's</a> , mas eles não serão compilados pelo Sass.  Mas não se preocupe, existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma ferramenta de migração</a> que ajudará você a atualizar. <br><br><h2>  Importar arquivos usando <code>@use</code> </h2><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br>  O novo <code>@use</code> é semelhante ao <code>@import</code> , mas possui algumas diferenças notáveis: <br><br><ul><li>  O arquivo é importado uma vez, não importa quantas vezes você use <code>@use</code> no projeto. </li><li>  Variáveis, mixins e funções (chamadas de "membros" no Sass) que começam com um sublinhado ( <code>_</code> ) ou hífen ( <code>-</code> ) são consideradas privadas e não são importadas. </li><li>  Os membros do arquivo conectado via <code>@use</code> (no nosso caso <code>buttons.scss</code> ) são acessíveis apenas localmente e não são transferidos para importação subsequente. </li><li>  Da mesma forma, <code>@extends</code> será aplicado apenas a montante;  isto é, a extensão se aplica apenas aos estilos importados e não aos estilos importados. </li><li>  Todos os membros importados têm seu próprio <i>espaço</i> para <i>nome</i> por padrão. </li></ul><br>  Quando anexamos o arquivo via <code>@use</code> , o Sass gera automaticamente um espaço para nome com base no nome do arquivo. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    `buttons`*/</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    `forms`*/</span></span></code> </pre><br>  Agora, temos acesso aos membros dos arquivos <code>buttons.scss</code> e <code>forms.scss</code> , mas esse acesso não é transferido entre as importações: <code>forms.scss</code> ainda não tem acesso às variáveis ​​definidas em <code>buttons.scss</code> .  Como as entidades importadas têm um espaço para nome, devemos usar a nova sintaxe delimitada por pontos para acessá-las: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* : &lt;namespace&gt;.$variable */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttons</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">input-border</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* : &lt;namespace&gt;.function() */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-background</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttons</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.background</span></span>(); $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.border</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/* : @include &lt;namespace&gt;.mixin() */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> buttons.submit(); @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.input();</code> </pre><br>  Podemos alterar ou remover o espaço para nome padrão adicionando <code>as &lt;name&gt;</code> à importação. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> as *; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span> as <span class="hljs-string"><span class="hljs-string">'f'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-color</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* buttons.$color    */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">input-border</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* forms.$input-border    */</span></span></code> </pre><br>  Usar <code>as *</code> adiciona o módulo ao espaço para nome raiz, portanto, o prefixo não é necessário, mas seus membros ainda são limitados localmente pelo documento atual. <br><br><h2>  Importar módulos incorporados Sass </h2><br>  Os recursos internos do Sass também foram transferidos para um sistema modular, para que tenhamos controle total sobre o espaço para nome global.  Existem vários módulos <code>math</code> - <code>math</code> , <code>color</code> , <code>string</code> , <code>list</code> , <code>map</code> , <code>selector</code> e <code>meta</code> - que devem ser importados explicitamente no arquivo antes do uso. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:math'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">half</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">math</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.percentage</span></span>(1/2);</code> </pre><br>  Os módulos incorporados também podem ser importados para o espaço global: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:math'</span></span> as *; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">half</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">percentage</span></span>(1/2);</code> </pre><br>  Funções internas que já possuem nomes de prefixo, como <code>map-get</code> ou <code>str-index</code> , podem ser usadas sem duplicar este prefixo: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:map'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:string'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">map-get</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">map</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.get</span></span>(('<span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span>': '<span class="hljs-selector-tag"><span class="hljs-selector-tag">value</span></span>'), '<span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span>'); $<span class="hljs-selector-tag"><span class="hljs-selector-tag">str-index</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.index</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span>', '<span class="hljs-selector-tag"><span class="hljs-selector-tag">i</span></span>');</code> </pre><br>  Você pode encontrar uma lista completa dos módulos internos, funções e alterações de nome na <a href="">especificação do módulo Sass</a> . <br><br><h2>  Recursos principais novos e alterados </h2><br>  Como um benefício adicional, isso significa que o Sass pode adicionar novos mixins e funções internos com segurança, sem causar conflitos de nome.  O exemplo mais surpreendente é o <code>load-css</code> <code>sass:meta</code> do módulo <code>sass:meta</code> .  Funciona de maneira semelhante a <code>@use</code> , mas retorna apenas o CSS gerado e funciona dinamicamente em qualquer lugar do seu código: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:meta'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">theme-name</span></span>: '<span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>'; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-theme='#{$theme-name}']</span></span> { @include meta.load-css($theme-name); }</code> </pre><br>  O primeiro argumento é a URL do módulo (como em <code>@use</code> ), mas pode ser alterada dinamicamente usando uma variável, mesmo usando interpolação, por exemplo, <code>theme-#{$name}</code> .  O segundo argumento (opcional) usa uma estrutura de <code>map</code> com a configuração: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*   $base-color  'theme/dark'   */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> meta.load-css( <span class="hljs-string"><span class="hljs-string">'theme/dark'</span></span>, $with: (<span class="hljs-string"><span class="hljs-string">'base-color'</span></span>: rebeccapurple) );</code> </pre><br>  O argumento <code>$with</code> permite configurar qualquer variável no módulo carregado usando a estrutura do <code>map</code> , e essa variável deve atender às condições: <br><br><ul><li>  Não é uma variável privada que começa com <code>_</code> ou <code>-</code> </li><li>  Marcado com a diretiva <code>!default</code> Default </li></ul><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* theme/_dark.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">base-color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> $_<span class="hljs-selector-tag"><span class="hljs-selector-tag">private</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,      !default */</span></span></code> </pre><br>  Observe que a tecla <code>'base-color'</code> define a variável <code>$base-color</code> . <br><br>  Existem mais algumas funções novas no módulo <code>sass:meta</code> : <code>module-variables()</code> e <code>module-functions()</code> .  Cada um deles retorna uma estrutura de <code>map</code> com nomes e valores de um módulo já importado.  Eles usam um argumento correspondente ao espaço para nome do módulo: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-vars</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">module-variables</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>'); <span class="hljs-comment"><span class="hljs-comment">/* ( button-color: blue, input-border: thin, ) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-functions</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">module-functions</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>'); <span class="hljs-comment"><span class="hljs-comment">/* ( background: get-function('background'), border: get-function('border'), ) */</span></span></code> </pre><br>  Várias outras funções do <code>sass:meta</code> - <code>global-variable-exists()</code> , <code>function-exists()</code> , <code>mixin-exists()</code> e <code>get-function()</code> - receberão argumentos adicionais do <code>$module</code> que nos permitem verificar explicitamente cada namespace. <br><br><h3>  Ajustar e dimensionar cores </h3><br>  O módulo <code>sass:color</code> também possui algumas reservas interessantes sobre a resolução de alguns de nossos problemas antigos.  Muitas das funções herdadas, como <code>lighten()</code> ou <code>adjust-hue()</code> não <code>adjust-hue()</code> mais recomendadas para uso em favor das funções explícitas <code>color.adjust()</code> e <code>color.scale()</code> : <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*  lighten(red, 20%) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">light-red</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.adjust</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">lightness</span></span>: 20%); <span class="hljs-comment"><span class="hljs-comment">/*  adjust-hue(red, 180deg) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">complement</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.adjust</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">hue</span></span>: 180<span class="hljs-selector-tag"><span class="hljs-selector-tag">deg</span></span>);</code> </pre><br><br>  Algumas dessas funções descontinuadas (por exemplo, <code>adjust-hue</code> ) são redundantes e desnecessárias.  Outros - como <code>lighten</code> , <code>darken</code> , <code>saturate</code> etc.  - precisa de re-implementação para melhorar a lógica interna.  As funções originais foram baseadas em <code>adjust()</code> , que usa matemática linear: adicionando <code>20%</code> à luminosidade atual do <code>red</code> no nosso exemplo acima.  Na maioria dos casos, queremos alterar ( <code>scale()</code> ) a cor em uma determinada porcentagem em relação ao valor atual: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*        20,   0.2,     */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">light-red</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scale</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">lightness</span></span>: 20%);</code> </pre><br>  Após serem completamente reprovadas e removidas, essas funções eventualmente reaparecerão em <code>sass:color</code> com um novo comportamento baseado em <code>color.scale()</code> , não <code>color.adjust()</code> .  Isso acontecerá gradualmente para evitar problemas repentinos de compatibilidade com versões anteriores.  Enquanto isso, recomendo verificar manualmente seu código para ver onde <code>color.scale()</code> pode ser mais útil. <br><br><h2>  Configurar bibliotecas importadas </h2><br>  Bibliotecas de terceiros ou reutilizáveis ​​geralmente vêm com variáveis ​​com alguns valores padrão que você pode substituir.  Fizemos isso com variáveis ​​antes da importação: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _buttons.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">blue</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* old.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br>  Como ao usar módulos, não há mais acesso a variáveis ​​locais, precisamos de uma nova maneira de definir valores.  Podemos fazer isso passando as configurações via <code>map</code> para <code>@use</code> : <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> with ( $color: red, $style: <span class="hljs-string"><span class="hljs-string">'flat'</span></span>, );</code> </pre><br>  Isso é semelhante ao argumento <code>$with</code> em <code>load-css()</code> , mas em vez de usar nomes de variáveis ​​como chaves, usamos as próprias variáveis ​​com o símbolo <code>$</code> . <br><br>  Eu gosto de quão explícita a configuração se tornou, mas há uma regra que me confundiu várias vezes: um <b>módulo só pode ser configurado uma vez no primeiro uso</b> .  A ordem de conexão sempre foi importante para o Sass, mesmo com o <code>@import</code> , mas esses problemas passaram despercebidos.  Agora temos um erro claro, e isso é bom e um pouco inesperado.  Certifique-se de conectar as bibliotecas via <code>@use</code> e configurá-las no ponto de entrada de arquivo (o documento central que importa todos os outros arquivos) para que essas configurações sejam compiladas antes de outras conexões de biblioteca via <code>@use</code> . <br><br>  Não é possível (no momento) “unir” as configurações, mantendo-as editáveis, mas você pode agrupar o módulo configurado e transferi-lo como um novo módulo. <br><br><h2>  Transferindo arquivos com <code>@forward</code> </h2><br>  Nem sempre precisamos usar o arquivo e nos referir a seus membros.  Às vezes, queremos apenas repassá-lo para importações subsequentes.  Suponha que temos vários arquivos associados a formulários e queremos conectá-los todos juntos como um espaço para nome.  Podemos fazer isso com o <code>@forward</code> : <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* forms/_index.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'textarea'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'select'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br>  Os membros desses arquivos encaminhados não estão disponíveis no documento atual e nenhum espaço para nome é criado, mas essas variáveis, funções e mixins estarão disponíveis quando outro arquivo os conectar via <code>@use</code> ou <code>@use</code> coleção inteira através do <code>@forward</code> .  Se os arquivos individuais enviados contiverem CSS real, eles também serão transmitidos sem gerá-lo diretamente até que o próprio pacote seja usado.  Nesta fase, tudo isso será considerado como um módulo com um espaço para nome: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* styles.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        `forms` */</span></span></code> </pre><br>  <b>Nota</b> : Se você pedir ao Sass para anexar uma pasta, ele procurará o arquivo de <code>index</code> ou <code>_index</code> nela. <br><br>  Por padrão, todos os membros públicos serão encaminhados junto com o módulo.  Mas podemos ser mais seletivos usando as condições <code>show</code> and <code>hide</code> e especificando membros específicos que queremos adicionar ou excluir. <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*    `border()`   `$border-color`   `input` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span> show border, $border-color; <span class="hljs-comment"><span class="hljs-comment">/*     `buttons`    `gradient()` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> hide gradient;</code> </pre><br>  <b>Nota</b> : quando funções e mixins têm um nome comum, elas são adicionadas e ocultas também. <br><br>  Para esclarecer as fontes ou evitar conflitos de nomes de módulos encaminhados, podemos adicionar prefixos aos membros do arquivo conectado usando <code>as</code> : <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* forms/_index.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* @forward "&lt;url&gt;" as &lt;prefix&gt;-*; */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ,      `background()` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span> as input-*; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> as btn-*; <span class="hljs-comment"><span class="hljs-comment">/* style.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.input-background(); @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.btn-background();</code> </pre><br>  E, se precisarmos, sempre podemos usar via <code>@use</code> e <code>@forward</code> o mesmo módulo por <code>@forward</code> , adicionando as duas regras: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>;</code> </pre><br>  Isso é especialmente útil se você deseja pré-configurar a biblioteca ou adicionar ferramentas adicionais antes de transferi-la para outros arquivos.  Isso pode ajudar a simplificar os caminhos de conexão: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _tools.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'accoutrement/sass/tools'</span></span> with ( $font-path: <span class="hljs-string"><span class="hljs-string">'../fonts/'</span></span>, ); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'accoutrement/sass/tools'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* -  ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* _anywhere-else.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'tools'</span></span>;</code> </pre><br>  <code>@use</code> e <code>@forward</code> devem ser declarados na raiz do documento (não aninhada) e no início do arquivo.  Somente <code>@charset</code> e definições de variáveis ​​simples podem aparecer antes das diretivas de importação. <br><br><h2>  Transição para um sistema modular </h2><br>  Para testar a nova sintaxe, criei uma nova biblioteca Sass de código aberto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cascading Color Systems</a> ) e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">novo site para o meu grupo</a> - ambos ainda em desenvolvimento.  Eu precisava entender os módulos do ponto de vista do autor da biblioteca e do ponto de vista do desenvolvedor do site.  Vamos começar com a experiência do "usuário final" ao escrever estilos de sites usando a sintaxe do módulo ... <br><br><h3>  Estilos de suporte e escrita </h3><br>  O uso dos módulos no site foi agradável.  A nova sintaxe suporta a arquitetura de código que eu já uso.  Todas as minhas importações de configurações e ferramentas globais estão no mesmo diretório (eu chamo de <code>config</code> ) com um arquivo de índice que transfere tudo o que eu preciso: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* config/_index.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'tools'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'fonts'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'scale'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'colors'</span></span>;</code> </pre><br>  Ao desenvolver outras partes do site, posso importar essas ferramentas e configurações sempre que precisar: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* layout/_banner.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'../config'</span></span>; <span class="hljs-selector-class"><span class="hljs-selector-class">.page-title</span></span> { @include config.font-family('header'); }</code> </pre><br>  Até funciona junto com minhas bibliotecas existentes, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Accoutrement</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Herman</a> , que ainda usam a antiga sintaxe <code>@import</code> .  Como a regra <code>@import</code> não será substituída em todos os lugares ao mesmo tempo, os desenvolvedores do Sass deram algum tempo para a transição.  Os módulos estão disponíveis agora, mas o <code>@import</code> não <code>@import</code> mais um ou dois anos - e será removido do idioma apenas um ano depois.  Ao mesmo tempo, os dois sistemas funcionarão juntos de qualquer maneira: <br><br><ul><li>  Se executarmos <code>@import</code> para um arquivo que contenha a nova sintaxe <code>@use/@forward</code> , apenas membros públicos serão importados sem um espaço para nome. </li><li>  Se executarmos <code>@use</code> ou <code>@forward</code> para um arquivo que contenha a sintaxe <code>@import</code> antiga, obteremos acesso a todas as importações aninhadas como um único espaço para nome. </li></ul><br>  Isso significa que você pode começar a usar imediatamente a nova sintaxe do módulo, sem aguardar o lançamento de uma nova versão de suas bibliotecas favoritas: e posso gastar algum tempo atualizando todas as minhas bibliotecas! <br><br><h3>  Ferramenta de migração </h3><br>  A atualização não levará muito tempo se usarmos a ferramenta de migração criada por Jennifer Thakar.  Pode ser instalado usando NPM, Chocolatey ou Homebrew: <br><br><pre> <code class="bash hljs">npm install -g sass-migrator choco install sass-migrator brew install sass/sass/migrator</code> </pre><br>  Esta não é uma ferramenta única para migrar para módulos.  Agora que o Sass está de volta ao desenvolvimento ativo (veja abaixo), a ferramenta de migração também receberá atualizações regulares para ajudar a portar cada novo recurso.  É uma boa ideia instalar essa ferramenta globalmente e salvá-la para uso futuro. <br><br>  O migrador pode ser iniciado a partir da linha de comando e, esperançosamente, será adicionado a aplicativos de terceiros, como o CodeKit e o Scout.  Aponte-o para um único arquivo Sass, por exemplo <code>style.scss</code> e diga a ele quais migrações aplicar.  No momento, há apenas uma migração chamada <code>module</code> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># sass-migrator &lt;migration&gt; &lt;entrypoint.scss...&gt; sass-migrator module style.scss</span></span></code> </pre><br>  Por padrão, o migrador atualiza apenas um arquivo, mas na maioria dos casos, queremos atualizar o arquivo principal e todas as suas dependências: quaisquer elementos conectados via <code>@import</code> , <code>@forward</code> ou <code>@use</code> .  Podemos fazer isso especificando cada arquivo individualmente ou simplesmente adicionando o <code>--migrate-deps</code> . <br><br><pre> <code class="bash hljs">sass-migrator --migrate-deps module style.scss</code> </pre><br>  Para uma execução de teste, podemos adicionar <code>--dry-run --verbose</code> (ou no formato abreviado <code>-nv</code> ) e ver os resultados sem alterar os arquivos de origem.  Há várias outras opções que podemos usar para configurar a migração - há ainda uma que foi projetada especificamente para ajudar os autores da biblioteca a excluir antigos espaços para nome criados manualmente - mas não descreverei todos eles aqui.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A ferramenta de migração está totalmente documentada</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site da Sass</a> . <br><br><h3>  Atualizando bibliotecas publicadas </h3><br>  Encontrei vários problemas no lado da biblioteca, em particular, quando tentei disponibilizar as configurações do usuário para vários arquivos e encontrar uma solução para as configurações "em cadeia" ausentes.  Os erros relacionados a pedidos podem ser difíceis de depurar, mas os resultados valem o esforço, e acho que veremos algumas correções adicionais em breve.  Ainda preciso experimentar a ferramenta de migração em pacotes complexos e talvez escrever um artigo adicional para os autores da biblioteca. <br><br>  O importante a saber agora é que Sass nos forneceu proteção durante a transição.  Não apenas as importações e os módulos antigos podem trabalhar juntos, como também podemos criar arquivos “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">somente importação</a> ” para fornecer um trabalho mais conveniente aos usuários que ainda conectam nossas bibliotecas via <code>@import</code> .  Na maioria dos casos, essa será uma versão alternativa do arquivo do pacote principal e você deseja que eles estejam próximos: <code>&lt;name&gt;.scss</code> para usuários do módulo e <code>&lt;name&gt;.import.scss</code> para usuários antigos.  Sempre que o usuário chama <code>@import &lt;name&gt;</code> , ele carrega a <code>.import</code> arquivo: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*  `_forms.scss` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  `_forms.import.scss` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>;</code> </pre><br><br>  Isso é especialmente útil para adicionar prefixos para desenvolvedores que não usam módulos: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _forms.import.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span> as forms-*;</code> </pre><br><br><h2>  Atualização Sass </h2><br>  Você deve se lembrar que, há vários anos, o Sass congelou a adição de novas funções, para que suas várias implementações (LibSass, Node Sass, Dart Sass) acompanhem a implementação original do Ruby, a fim de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">abandoná-la completamente</a> .  O congelamento terminou no ano passado com vários novos recursos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discussões e desenvolvimento ativos</a> no GitHub - mas não tão solenemente.  Se você perdeu esses lançamentos, pode ler o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog Sass</a> : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Importações e compatibilidade com CSS</a> (Dart Sass v1.11) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parâmetros da diretiva de conteúdo e funções de cores (Dart Sass v1.15)</a> </li></ul><br>  Atualmente, o Dart Sass é uma implementação canônica e geralmente é a primeira a introduzir novos recursos.  Eu recomendo mudar para ele, se você deseja receber as últimas novidades.  Você pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instalar o Dart Sass</a> usando NPM, Chocolatey ou Homebrew.  Também funciona muito bem com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gulp-sass</a> . <br><br>  Como o CSS (começando com CSS3), não há mais um número de versão para novos lançamentos.  Todas as implementações do Sass funcionam com a mesma especificação, mas cada uma delas possui um cronograma e numeração de versão exclusivos, que são refletidos nas informações de suporte em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma bela e nova documentação</a> projetada por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jina</a> . <br><br><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1400,f_auto,q_auto/v1570122240/sass-modules-01_gapdpb.png" alt="imagem"><br><br>  Os módulos Sass estão disponíveis a partir de <b>1 de outubro de 2019</b> no <b>Dart Sass 1.23.0</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471924/">https://habr.com/ru/post/pt471924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471906/index.html">Os perigos de otimizações impróprias</a></li>
<li><a href="../pt471908/index.html">A inesperada beleza dos números primos</a></li>
<li><a href="../pt471912/index.html">Aprendendo inglês: 7 maneiras práticas de expandir seu vocabulário</a></li>
<li><a href="../pt471914/index.html">Como o sistema gráfico Sega Mega Drive funcionava: Processador de vídeo</a></li>
<li><a href="../pt471918/index.html">SwiftUI: Conhecimento</a></li>
<li><a href="../pt471928/index.html">Restaurar automaticamente a última configuração salva nos roteadores Mikrotik</a></li>
<li><a href="../pt471930/index.html">Projeto atômico mitap - letras, cores, uniformes, equipe e dinheiro</a></li>
<li><a href="../pt471938/index.html">Notas de layout: extensões úteis do Google Chrome em 2019</a></li>
<li><a href="../pt471940/index.html">Como reduzir o risco de inadimplência em assentamentos diferidos: fatoração para empresas</a></li>
<li><a href="../pt471942/index.html">De acordo com suas necessidades: teste profissional dos SSDs Kingston DC500R e DC500M</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>