<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏽 👞 🌵 Sederhana dan dalam C ++. Userver Basics - Kerangka kerja untuk menulis layanan microsoft asinkron 👂🏻 💓 👴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yandex.Taxi menganut arsitektur microservice. Dengan peningkatan jumlah layanan-mikro, kami memperhatikan bahwa pengembang menghabiskan banyak waktu p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sederhana dan dalam C ++. Userver Basics - Kerangka kerja untuk menulis layanan microsoft asinkron</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/474438/">  Yandex.Taxi menganut arsitektur microservice.  Dengan peningkatan jumlah layanan-mikro, kami memperhatikan bahwa pengembang menghabiskan banyak waktu pada pelat-pelat dan masalah-masalah tipikal, sementara solusi tidak selalu berhasil dengan optimal. <br><br>  Kami memutuskan untuk membuat kerangka kerja kami sendiri, dengan C ++ 17 dan coroutine.  Beginilah tampilan kode microservice biasa: <br><br><pre><code class="cpp hljs">Response View::Handle(Request&amp;&amp; request, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dependencies&amp; dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cluster = dependencies.pg-&gt;GetCluster(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> trx = cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* statement = <span class="hljs-string"><span class="hljs-string">"SELECT ok, baz FROM some WHERE id = $1 LIMIT 1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = psql::Execute(trx, statement, request.id)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row[<span class="hljs-string"><span class="hljs-string">"ok"</span></span>].As&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;()) { LOG_DEBUG() &lt;&lt; request.id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; GetSomeInfoFromDb(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response400(); } psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar); trx.Commit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response200{row[<span class="hljs-string"><span class="hljs-string">"baz"</span></span>].As&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()}; }</code> </pre> <br>  Dan inilah mengapa ini sangat efektif dan cepat - kami akan menjelaskannya. <br><a name="habracut"></a><br><h2>  Userver - Asynchronous </h2><br>  Tim kami tidak hanya terdiri dari pengembang C ++ yang berpengalaman: ada trainee, pengembang junior, dan bahkan orang-orang yang tidak terlalu terbiasa menulis dalam C ++.  Oleh karena itu, desain pengguna didasarkan pada kemudahan penggunaan.  Namun, dengan volume dan muatan data kami, kami juga tidak mampu memboroskan sumber daya besi secara tidak efisien. <br><br>  Layanan-layanan microser dicirikan oleh ekspektasi input / output: seringkali respon dari sebuah layanan-mikro dibentuk dari beberapa tanggapan dari layanan-layanan dan basis data mikro lainnya.  Masalah menunggu I / O yang efisien diselesaikan melalui metode asinkron dan callback: dengan operasi asinkron, tidak perlu untuk membuat utas eksekusi, dan karenanya, tidak ada overhead yang besar untuk beralih aliran ... hanya kode yang cukup sulit untuk ditulis dan dipelihara: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> View::Handle(Request&amp;&amp; request, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dependencies&amp; dependencies, Response response) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cluster = dependencies.pg-&gt;GetCluster(); cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster, [request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request), response](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; trx) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* statement = <span class="hljs-string"><span class="hljs-string">"SELECT ok, baz FROM some WHERE id = $1 LIMIT 1"</span></span>; psql::Execute(trx, statement, request.id, [request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request), response, trx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(trx)](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; res) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = res[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row[<span class="hljs-string"><span class="hljs-string">"ok"</span></span>].As&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LogDebug()) { GetSomeInfoFromDb([id = request.id](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> info) { LOG_DEBUG() &lt;&lt; id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; info; }); } *response = Response400{}; } psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar, [row = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(row), trx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(trx), response]() { trx.Commit([row = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(row), response]() { *response = Response200{row[<span class="hljs-string"><span class="hljs-string">"baz"</span></span>].As&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()}; }); }); }); }); }</code> </pre><br>  Dan di sini stackfull-coroutine datang untuk menyelamatkan.  Pengguna kerangka berpikir bahwa ia menulis kode sinkron biasa: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = psql::Execute(trx, queries::kGetRules, request.id)[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre><br>  Namun, kira-kira hal berikut terjadi di bawah tenda: <br><br><ol><li>  Paket TCP dihasilkan dan dikirim dengan permintaan ke database; </li><li>  eksekusi coroutine, di mana fungsi View :: Handle sedang berjalan, ditangguhkan; </li><li>  kami mengatakan kepada kernel OS: "" Masukkan coroutine yang ditangguhkan dalam antrian tugas yang siap untuk dieksekusi segera setelah cukup paket TCP dari database "; </li><li>  tanpa menunggu langkah sebelumnya, kami mengambil dan meluncurkan coroutine lain yang siap dieksekusi dari antrian. </li></ol><br>  Dengan kata lain, fungsi dari contoh pertama bekerja secara sinkron dan dekat dengan kode tersebut menggunakan C ++ 20 Coroutines: <br><br><pre> <code class="cpp hljs">Response View::Handle(Request&amp;&amp; request, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dependencies&amp; dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cluster = dependencies.pg-&gt;GetCluster(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> trx = co_await cluster-&gt;Begin(storages::postgres::ClusterHostType::kMaster); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* statement = <span class="hljs-string"><span class="hljs-string">"SELECT ok, baz FROM some WHERE id = $1 LIMIT 1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = co_await psql::Execute(trx, statement, request.id)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row[<span class="hljs-string"><span class="hljs-string">"ok"</span></span>].As&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;()) { LOG_DEBUG() &lt;&lt; request.id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; <span class="hljs-function"><span class="hljs-function">co_await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeInfoFromDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; co_return Response400{<span class="hljs-string"><span class="hljs-string">"NOT_OK"</span></span>, <span class="hljs-string"><span class="hljs-string">"Please provide different ID"</span></span>}; } co_await psql::Execute(trx, queries::kUpdateRules, request.foo, request.bar); co_await trx.Commit(); co_return Response200{row[<span class="hljs-string"><span class="hljs-string">"baz"</span></span>].As&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()}; }</code> </pre><br>  Itu hanya pengguna tidak perlu berpikir tentang co_await dan co_return, semuanya berfungsi "sendiri". <br><br>  Dalam kerangka kami, beralih di antara coroutine lebih cepat daripada memanggil std :: this_thread :: yield ().  Seluruh layanan microsecer biayanya sangat sedikit. <br><br>  Saat ini, userver berisi driver asinkron: <br>  * untuk soket OS; <br>  * http dan https (klien dan server); <br>  * PostgreSQL; <br>  * MongoDB; <br>  * Redis; <br>  * bekerja dengan file; <br>  * pengatur waktu; <br>  * primitif untuk menyinkronkan dan meluncurkan coroutine baru. <br><br>  Pendekatan asinkron di atas untuk menyelesaikan tugas-tugas yang terikat I / O harus akrab bagi pengembang Go.  Tetapi, tidak seperti Go, kami tidak mendapatkan overhead untuk memori dan CPU dari pengumpul sampah.  Pengembang dapat menggunakan bahasa yang lebih kaya, dengan berbagai wadah dan perpustakaan berkinerja tinggi, tanpa menderita kurangnya konsistensi, RAII atau templat. <br><br><h2>  Pengguna - komponen </h2><br>  Tentu saja, kerangka kerja yang lengkap bukan hanya coroutine.  Tugas pengembang di Taxi sangat beragam, dan masing-masing membutuhkan seperangkat alat sendiri untuk dipecahkan.  Karena itu, userver memiliki semua yang Anda butuhkan: <br>  * untuk logging; <br>  * caching; <br>  * bekerja dengan berbagai format data; <br>  * bekerja dengan konfigurasi dan memperbarui konfigurasi tanpa memulai kembali layanan; <br>  * kunci terdistribusi; <br>  * pengujian; <br>  * otorisasi dan otentikasi; <br>  * membuat dan mengirim metrik; <br>  * menulis penangan REST; <br>  + pembuatan kode dan dukungan dependensi (dibuat di bagian terpisah dari kerangka kerja). <br><br><h2>  Pengguna - pembuatan kode </h2><br>  Mari kita kembali ke baris pertama dari contoh kita dan melihat apa yang tersembunyi di balik Respons dan Permintaan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request&amp;&amp; request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Dependencies&amp; dependencies)</span></span></span></span>;</code> </pre><br>  Dengan userver, Anda dapat menulis layanan microser apa pun, tetapi ada persyaratan untuk layanan microser kami bahwa API mereka harus didokumentasikan (dijelaskan melalui skema swagger). <br><br>  Misalnya, untuk Pegangan dari contoh, diagram kesombongan mungkin terlihat seperti ini: <br><br><pre> <code class="json hljs">paths: /some/sample/{bar}: post: description: |     Habr. summary: | ,  -   . parameters: - in: query name: id type: string required: <span class="hljs-literal"><span class="hljs-literal">true</span></span> - in: header name: foo type: string enum: - foo<span class="hljs-number"><span class="hljs-number">1</span></span> - foo<span class="hljs-number"><span class="hljs-number">2</span></span> required: <span class="hljs-literal"><span class="hljs-literal">true</span></span> - in: path name: bar type: string required: <span class="hljs-literal"><span class="hljs-literal">true</span></span> responses: '<span class="hljs-number"><span class="hljs-number">200</span></span>': description: OK schema: type: object additionalProperties: <span class="hljs-literal"><span class="hljs-literal">false</span></span> required: - baz properties: baz: type: string '<span class="hljs-number"><span class="hljs-number">400</span></span>': $ref: '#/responses/ResponseCommonError'</code> </pre><br>  Nah, karena pengembang sudah memiliki skema dengan deskripsi permintaan dan tanggapan, lalu mengapa tidak menghasilkan permintaan dan jawaban ini berdasarkan itu?  Pada saat yang sama, tautan ke file protobuf / flatbuffer / ... juga dapat ditunjukkan dalam skema - pembuatan kode dari permintaan itu sendiri akan mendapatkan segalanya, memvalidasi data input sesuai dengan skema dan menguraikannya ke dalam bidang struktur Respons.  Pengguna hanya perlu menulis fungsionalitas dalam metode Handle, tanpa terganggu oleh boilerplate dengan parsing permintaan dan serialisasi respons. <br><br>  Pada saat yang sama, pembuatan kode berfungsi untuk pelanggan layanan.  Anda dapat menunjukkan bahwa layanan Anda membutuhkan klien yang bekerja sesuai dengan skema tersebut, dan menyiapkan kelas yang siap digunakan untuk membuat permintaan asinkron: <br><br><pre> <code class="cpp hljs">Request req; req.id = id; req.foo = foo; req.bar = bar; dependencies.sample_client.SomeSampleBarPost(req);</code> </pre><br>  Pendekatan ini memiliki kelebihan lainnya: selalu merupakan dokumentasi terbaru.  Jika pengembang tiba-tiba mencoba menggunakan parameter yang tidak ada dalam dokumentasi, ia akan mendapatkan kesalahan kompilasi. <br><br><h2>  Pengguna - logging </h2><br>  Kami suka menulis log.  Jika Anda hanya mencatat informasi yang paling penting, maka beberapa terabyte log per jam akan berjalan.  Oleh karena itu, tidak mengherankan bahwa penebangan kami memiliki triknya sendiri: <br>  * tidak sinkron (tentu saja :-)); <br>  * kita dapat mencatat bypassing std :: locale dan std :: ostream; <br>  * kita dapat mengganti level logging dengan cepat (tanpa memulai kembali layanan); <br>  * kami tidak mengeksekusi kode pengguna jika hanya diperlukan untuk logging. <br><br>  Misalnya, selama operasi normal dari layanan microser, level logging akan diatur ke INFO, dan seluruh ekspresi <br><br><pre> <code class="cpp hljs"> LOG_DEBUG() &lt;&lt; request.id &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is not OK of "</span></span> &lt;&lt; GetSomeInfoFromDb();</code> </pre><br>  tidak akan dihitung.  Termasuk panggilan ke fungsi intensif sumber daya GetSomeInfoFromDb () tidak akan terjadi. <br><br>  Jika tiba-tiba layanan mulai “bodoh”, pengembang selalu dapat memberi tahu layanan yang berfungsi: “Masuk dalam mode DEBUG”.  Dan dalam hal ini entri "tidak apa-apa" akan mulai muncul di log, fungsi GetSomeInfoFromDb () akan dieksekusi. <br><br><h2>  Alih-alih total </h2><br>  Dalam satu artikel tidak mungkin untuk mengetahui sekaligus tentang semua fitur dan trik.  Karena itu, kami mulai dengan pengantar singkat.  Tulis di komentar tentang hal-hal apa dari pengguna yang Anda ingin pelajari dan baca. <br><br>  Sekarang kami sedang mempertimbangkan apakah akan memposting kerangka kerja dalam sumber terbuka.  Jika kita memutuskan ya, menyiapkan kerangka kerja untuk membuka sumber akan membutuhkan banyak upaya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474438/">https://habr.com/ru/post/id474438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474424/index.html">Pelatihan campuran - apa itu dan bagaimana cara kerjanya</a></li>
<li><a href="../id474426/index.html">Serial animasi "Lingkaran Matematika"</a></li>
<li><a href="../id474430/index.html">DevOpsDays Moscow - sebuah konferensi yang dibuat komunitas untuk komunitas tersebut</a></li>
<li><a href="../id474434/index.html">Bot Telegram sendiri untuk melacak uptime servernya dengan python dan docker</a></li>
<li><a href="../id474436/index.html">GitLab karena kebijakan menghentikan perekrutan insinyur dari Rusia dan Cina</a></li>
<li><a href="../id474440/index.html">Kesulitan dalam menghitung pendapatan dari langganan yang dapat diperbarui secara otomatis dalam aplikasi iOS</a></li>
<li><a href="../id474442/index.html">Kisah Ekstensi Kehidupan Irlandia</a></li>
<li><a href="../id474444/index.html">5 proyek pelatihan lebih berani untuk pengembang (Layer, Squoosh, Kalkulator, Crawler Situs Web, Music Player)</a></li>
<li><a href="../id474448/index.html">Apa yang mampu dimiliki otak seorang siswa di dunia komputer</a></li>
<li><a href="../id474450/index.html">Berhenti menggunakan TTL yang sangat kecil untuk DNS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>