<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèº üêÖ ü§µüèΩ Mendengarkan Komunikasi VoIP Terenkripsi üßë üñêüèª üì§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Telephony VoIP secara bertahap mendapatkan tanah dengan sistem telepon kawat tembaga tradisional, karena memberikan throughput yang lebih tinggi denga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mendengarkan Komunikasi VoIP Terenkripsi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461759/"><p> Telephony VoIP secara bertahap mendapatkan tanah dengan sistem telepon kawat tembaga tradisional, karena memberikan throughput yang lebih tinggi dengan biaya penyebaran yang lebih rendah.  Pada tahun 2013, jumlah pelanggan VoIP berjumlah lebih dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">150 juta</a> , yang jumlahnya banyak;  dan pada 2017, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hampir 1 miliar</a> .  Tapi bagaimana dengan privasi panggilan VoIP?  Apakah enkripsi end-to-end yang digunakan dalam perangkat lunak VoIP mampu memberikan privasi yang sama?  Masalah-masalah tersebut menjadi sangat hangat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setelah wahyu Snowden</a> , yang memberi tahu dunia tentang penyadapan total, yang dilakukan oleh badan intelijen pemerintah seperti NSA (Badan Keamanan Nasional) dan DSP (pusat komunikasi pemerintah) menggunakan spyware PRISM dan BULLRUN, yang juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendengarkan percakapan terenkripsi.</a> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Apa yang dapat diekstrak oleh penyerang dari aliran audio terenkripsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Serangan pada VoIP melalui saluran bypass</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Beberapa kata tentang algoritma DTW</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Prinsip pengoperasian mesin HMM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Prinsip pengoperasian mesin-mesin PHMM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Dari teori ke praktik: pengakuan bahasa percakapan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Mendengarkan aliran audio terenkripsi Skype</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Dan jika Anda mematikan mode VBR?</a> </p><br><p><img src="https://habrastorage.org/webt/8x/rp/cn/8xrpcnovcl7t8arr5etlbgidpw4.jpeg"></p><a name="habracut"></a><br><p>  Bagaimana PRISM, BULLRUN, dan perangkat lunak sejenis lainnya mengekstrak informasi dari aliran suara yang dikirim melalui saluran terenkripsi?  Untuk memahami jawaban atas pertanyaan ini, Anda harus terlebih dahulu memahami bagaimana lalu lintas suara ditransmisikan dalam VoIP.  Saluran data dalam sistem VoIP biasanya diterapkan melalui protokol UDP, dan paling sering bekerja menggunakan protokol SRTP (Secure Transport Real-time Protocol; protokol transfer data real-time secure), yang mendukung pengemasan (melalui audio codec) dan enkripsi stream audio.  Dalam hal ini, aliran terenkripsi yang diterima pada output adalah ukuran yang sama dengan aliran audio input.  Seperti yang akan ditunjukkan di bawah ini, kebocoran informasi yang tampaknya tidak signifikan tersebut dapat digunakan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendengarkan percakapan VoIP "terenkripsi"</a> . </p><br><a name="a1"></a><br><h1 id="chto-zloumyshlennik-mozhet-izvlech-iz-zashifrovannogo-audio-potoka">  Apa yang dapat diekstrak oleh penyerang dari aliran audio terenkripsi </h1><br><p>  Sebagian besar codec audio yang digunakan dalam sistem VoIP didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma CELP</a> (Code-Excited Linear Prediction; prediksi kode linier), blok fungsional yang ditunjukkan pada Gambar 1. Untuk mencapai kualitas suara yang lebih baik, tanpa menambah beban per saluran data, perangkat lunak VoIP biasanya menggunakan codec audio dalam mode VBR (laju bit variabel; aliran audio dengan laju bit variabel).  Dengan prinsip ini, misalnya, audio codec Speex berfungsi. </p><br><p><img src="https://habrastorage.org/webt/hf/lb/z1/hflbz1g-twhwgpswakwncjk3nxc.png"><br>  <em><strong>Gambar 1.</strong> Blok fungsional dari algoritma CELP</em> </p><br><p>  Apa yang menyebabkan hal ini dalam hal kerahasiaan?  Contoh sederhana ... Speex, yang bekerja dalam mode VBR, mengemas konsonan mendesis dengan laju bit lebih rendah daripada vokal;  dan lebih jauh lagi, bahkan vokal dan konsonan tertentu dikemas dengan bitrate khusus untuknya (lihat Gambar 2.a).  Grafik pada Gambar 2.b menunjukkan distribusi panjang paket - untuk frasa yang memiliki konsonan mendesis: "Speed ‚Äã‚Äãskaters sprint to the finish".  Depresi yang dalam pada grafik jatuh tepat pada fragmen frasa yang mendesis ini.  Gambar 2.c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan</a> dinamika input audio stream, bit rate dan ukuran paket output (terenkripsi), - ditumpangkan pada skala waktu umum;  kesamaan yang mencolok dari grafik kedua dan ketiga - dapat dilihat dengan mata telanjang. </p><br><p><img src="https://habrastorage.org/webt/ic/rn/wt/icrnwtrltw-jni9fa4qvgme8n24.png"><br>  <em><strong>Gambar 2.</strong> Bagaimana suara mendesis mempengaruhi ukuran paket</em> </p><br><p>  Plus, jika Anda melihat Gambar 2 melalui prisma alat matematika pemrosesan sinyal digital (yang digunakan dalam tugas pengenalan suara), seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin PHMM</a> (Profile Hidden Markov Models; versi diperpanjang dari model Markov tersembunyi), Anda dapat melihat lebih dari sekadar perbedaan antara vokal dan konsonan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Termasuk</a> , mengidentifikasi jenis kelamin, usia, bahasa dan emosi pembicara. </p><br><a name="a2"></a><br><h1 id="ataka-na-voip-po-obhodnym-kanalam">  Abaikan serangan VoIP </h1><br><p>  Mesin PHMM melakukan pekerjaan yang sangat baik dalam memproses rantai numerik, membandingkannya satu sama lain dan menemukan pola di antara mereka.  Itulah sebabnya mesin PHMM banyak digunakan dalam memecahkan masalah pengenalan ucapan. </p><br><p>  Mesin PHMM juga berguna dalam tugas mendengarkan aliran audio yang dienkripsi.  Tetapi tidak secara langsung, tetapi melalui saluran bypass.  Dengan kata lain, mesin PHMM tidak dapat langsung menjawab pertanyaan: "Frasa apa dalam rantai paket audio terenkripsi ini?", Tetapi mesin itu dapat secara akurat menjawab pertanyaan: "Apakah frasa seperti itu terdapat di tempat ini dan itu?" adalah aliran audio terenkripsi? " </p><br><p>  T.O.  Mesin PHMM hanya dapat mengenali frasa yang pada awalnya dilatih.  Namun, teknologi pembelajaran mendalam modern begitu kuat sehingga mereka mampu melatih mesin PHMM sedemikian rupa sehingga untuk itu, garis antara dua pertanyaan yang disuarakan di atas terhapus.  Untuk menghargai kekuatan penuh dari pendekatan ini, Anda perlu menyelam sedikit ke material. </p><br><a name="a3"></a><br><h1 id="neskolko-slov-o-dtw-algoritme">  Beberapa kata tentang algoritma DTW </h1><br><p>  Algoritma DTW (Dynamic Time Warping; transformasi dinamis dari timeline) hingga saat ini telah banyak digunakan dalam menyelesaikan masalah identifikasi pembicara dan pengenalan suara.  Dia dapat menemukan kesamaan antara dua rantai numerik yang dihasilkan sesuai dengan hukum yang sama - bahkan ketika rantai ini dihasilkan pada kecepatan yang berbeda dan terletak di tempat yang berbeda pada skala waktu.  Inilah yang terjadi ketika mendigitalkan aliran audio: misalnya, pembicara dapat mengucapkan frasa yang sama dengan aksen yang sama, tetapi pada saat yang sama lebih cepat atau lebih lambat dengan suara latar yang berbeda.  Tapi ini tidak mencegah algoritma DTW dari menemukan kesamaan antara opsi pertama dan kedua.  Untuk menggambarkan hal ini dengan contoh, pertimbangkan dua rantai bilangan bulat: </p><br><p>  0 0 0 4 7 14 26 23 8 3 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br>  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 6 13 25 24 9 4 2 0 0 0 0 0 0 </p><br><p>  Jika kita membandingkan dua rantai ini "di dahi", maka mereka tampaknya sangat berbeda satu sama lain.  Namun, jika kita membandingkan karakteristik mereka, kita akan melihat bahwa rantai pasti memiliki beberapa kesamaan: keduanya terdiri dari 8 bilangan bulat;  keduanya memiliki nilai puncak yang sama (25-26).  Perbandingan "frontal", mulai dari titik masuk mereka, mengabaikan karakteristik penting mereka.  Tetapi algoritma DTW, membandingkan dua rantai, memperhitungkan ini dan karakteristik lainnya.  Namun, kami tidak akan banyak fokus pada algoritma DTW, karena hari ini ada alternatif yang lebih efektif - mesin-mesin PHMM.  Secara eksperimental <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditetapkan</a> bahwa mesin-mesin PHMM "mengenali" frasa dari aliran audio terenkripsi dengan akurasi 90 persen;  sedangkan algoritma DTW hanya memberikan jaminan 80 persen.  Oleh karena itu, algoritma DTW (yang pada masa jayanya merupakan alat yang populer dalam menyelesaikan masalah pengenalan suara) disebutkan hanya untuk menunjukkan seberapa jauh lebih baik, dibandingkan dengan itu, mesin PHMM (khususnya dalam memecahkan masalah mengenali aliran audio yang dienkripsi) .  Tentu saja, algoritma DTW, dibandingkan dengan mesin PHMM, belajar lebih cepat.  Keuntungan ini tidak bisa dipungkiri.  Namun, dengan kekuatan komputasi modern, keunggulan ini tidak mendasar. </p><br><a name="a4"></a><br><h1 id="princip-deystviya-hmm-avtomatov">  Prinsip pengoperasian mesin HMM </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HMM</a> (hanya HMM, bukan PHMM) adalah alat pemodelan statistik yang menghasilkan rantai numerik mengikuti sistem yang ditentukan oleh mesin keadaan terbatas deterministik, yang masing-masing memiliki fungsi transisi yang disebut  "Proses Markov."  Pengoperasian otomat ini (lihat Gambar 3) selalu dimulai dengan status "B" (mulai) dan diakhiri dengan status "E" (ujung).  Pilihan kondisi selanjutnya yang akan dilakukan transisi dari arus akan dilakukan sesuai dengan fungsi transisi dari kondisi saat ini.  Saat Anda bergerak di antara status, mesin HMM pada setiap langkah menghasilkan satu angka, dari mana rantai output angka dibentuk langkah demi langkah.  Ketika mesin HMM dalam kondisi "E", rantai berakhir.  Menggunakan mesin HMM, seseorang dapat menemukan pola dalam rantai yang terlihat acak sejak awal.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sebagai contoh, di sini</a> keunggulan mesin HMM ini digunakan untuk menemukan pola antara rantai panjang paket dan frasa target, yang keberadaannya kami periksa dalam aliran VoIP terenkripsi. </p><br><p><img src="https://habrastorage.org/webt/t5/dy/pg/t5dypgnizwgysqvdq573548wcwi.png"><br>  <em><strong>Gambar 3.</strong> Contoh mesin HMM</em> </p><br><p>  Meskipun ada sejumlah besar cara yang memungkinkan di mana mesin HMM dapat beralih dari titik "B" ke titik "E" (dalam kasus kami, saat mengemas fragmen audio tunggal), masih untuk setiap kasus tertentu (bahkan untuk kasus acak seperti " Proses Markov ‚Äù) ada satu <strong>cara terbaik</strong> tunggal, satu rantai terbaik tunggal.  Dia adalah kandidat yang paling mungkin, yang kemungkinan besar akan memilih codec audio ketika mengemas fragmen audio yang sesuai (karena keunikannya dinyatakan juga dalam kenyataan bahwa dia cenderung lebih baik untuk mengepak daripada yang lain).  "Rantai terbaik" tersebut dapat ditemukan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Viterbi</a> (seperti yang dilakukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> misalnya). </p><br><p>  Selain itu, dalam tugas pengenalan suara (termasuk dari aliran data terenkripsi, seperti dalam kasus kami), selain mampu menemukan jalur terbaik untuk rantai yang diamati, juga berguna untuk dapat menghitung seberapa besar kemungkinan rantai yang dipilih akan dihasilkan oleh mesin HMM.  Solusi singkat untuk masalah ini diberikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ;  itu bergantung pada algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Forward-Back</a> dan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baum-Welsh</a> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini,</a> berdasarkan otomasi HMM, metode untuk mengidentifikasi bahasa di mana percakapan sedang dikembangkan dikembangkan;  dengan akurasi 66%.  Tetapi akurasi rendah seperti itu tidak terlalu mengesankan, oleh karena itu ada modifikasi yang lebih maju dari mesin HMM - PHMM, yang menarik lebih banyak pola dari aliran audio terenkripsi.  Jadi, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dijelaskan secara rinci cara mengidentifikasi kata dan frasa menggunakan mesin PHMM dalam lalu lintas terenkripsi (dan tugas ini akan lebih sulit daripada hanya mengidentifikasi bahasa di mana percakapan sedang dilakukan);  dengan akurasi 90%. </p><br><a name="a5"></a><br><h1 id="princip-deystviya-phmm-avtomatov">  Prinsip pengoperasian mesin-mesin PHMM </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHMM</a> adalah modifikasi yang diperbaiki dari mesin HMM, di mana (lihat Gambar 4.a), selain status "korespondensi" (kotak dengan huruf M), ada juga status "penyisipan" (berlian dengan huruf I) dan "hapus" (lingkaran) dengan huruf D).  Berkat dua status baru ini, PHMM-automata, berbeda dengan HMM-automata, mampu mengenali rantai hipotetis "ABCD", bahkan jika tidak sepenuhnya ada (misalnya, "ABD") atau sebuah sisipan dibuat ke dalamnya (misalnya, "ABXCD").  Dalam memecahkan masalah mengenali aliran audio terenkripsi, kedua inovasi mesin PHMM ini sangat berguna.  Karena output dari codec audio jarang cocok bahkan ketika input audio sangat mirip (ketika, misalnya, orang yang sama mengatakan frasa yang sama).  T.O.  model paling sederhana dari mesin PHMM terdiri dari tiga rantai status yang saling berhubungan ("korespondensi", "penyisipan", dan "penghapusan") yang menggambarkan panjang paket jaringan yang diharapkan pada setiap posisi rantai (paket lalu lintas VoIP terenkripsi untuk frasa yang dipilih). </p><br><p><img src="https://habrastorage.org/webt/se/mh/rc/semhrcn2mppf5jn_blda7rcfk84.png"><br>  <em><strong>Gambar 4.</strong> Contoh mesin PHMM</em> </p><br><p>  Namun, karena paket jaringan di mana frasa target dikemas dalam aliran audio terenkripsi biasanya dikelilingi oleh paket jaringan lainnya (sisa percakapan), kita memerlukan mesin PHMM yang lebih canggih.  Salah satu yang dapat mengisolasi frasa target dari suara lain di sekitarnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini,</a> untuk ini, 5 status baru ditambahkan ke mesin PHMM asli (lihat Gambar 4.b).  Yang paling penting dari lima status tambahan ini adalah "acak" (berlian dengan huruf R).  Mesin PHMM (setelah selesainya tahap pelatihan) masuk ke keadaan ini ketika paket-paket yang bukan merupakan bagian dari frase yang kami tertarik untuk mendapatkannya.  Status PS (Profil Mulai) dan PE (Profil Profil) - memberikan transisi antara keadaan acak dan bagian profil model.  Modifikasi yang lebih baik dari otomat PHMM ini mampu mengenali bahkan frasa-frasa itu yang ‚Äútidak didengar‚Äù oleh otomat pada tahap pelatihan (lihat Gambar 5). </p><br><p><img src="https://habrastorage.org/webt/xw/q-/_j/xwq-_jiudwemmnnsxnxztbukmog.png"><br>  <em><strong>Gambar 5.</strong> Mesin PHMM memecahkan masalah pengenalan aliran audio terenkripsi</em> </p><br><a name="a6"></a><br><h1 id="ot-teorii-k-praktike-raspoznavanie-yazyka-na-kotorom-idyot-razgovor">  Dari teori ke praktik: mengenali bahasa percakapan </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut</a> ini adalah pengaturan eksperimental yang didasarkan pada mesin PHMM (lihat Gambar 6), yang digunakan untuk menganalisis stream audio terenkripsi dengan ucapan dari 2.000 penutur asli dari 20 kelompok bahasa yang berbeda.  Setelah proses pelatihan selesai, mesin PHMM mengidentifikasi bahasa percakapan dengan akurasi 60 hingga 90%: untuk 14 dari 20 bahasa, akurasi identifikasi melebihi 90%, untuk sisanya - 60%. </p><br><p>  Pengaturan eksperimental yang ditunjukkan pada Gambar 6 termasuk dua PC Linux dengan perangkat lunak OpenSource VoIP.  Salah satu mesin berfungsi sebagai server dan mendengarkan panggilan SIP di jaringan.  Setelah menerima panggilan, server secara otomatis menjawab pelanggan, menginisialisasi saluran ucapan ke mode "Speex over RTP".  Harus disebutkan di sini bahwa saluran kontrol dalam sistem VoIP biasanya diimplementasikan melalui protokol TCP, dan berfungsi baik pada beberapa protokol yang tersedia untuk umum dengan arsitektur terbuka (SIP, XMPP, H.323), atau memiliki arsitektur tertutup khusus untuk tertentu aplikasi (seperti di Skype, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">misalnya</a> ). </p><br><p><img src="https://habrastorage.org/webt/sc/k5/-x/sck5-xyvo7liteu9xz8pocns6ya.png"><br>  <em><strong>Gambar 6.</strong> Pengaturan eksperimental untuk bekerja dengan mesin PHMM</em> </p><br><p>  Ketika saluran suara diinisialisasi, server memutar file ke pemanggil dan kemudian mengakhiri koneksi SIP.  Pelanggan, yang merupakan mesin lain di jaringan lokal kami, melakukan panggilan SIP ke server, dan kemudian, menggunakan sniffer, "mendengarkan" ke file yang dimainkan server: ia mendengarkan rantai paket jaringan dengan lalu lintas audio terenkripsi yang datang dari server.  Selanjutnya, pelanggan melatih mesin PHMM untuk mengidentifikasi bahasa percakapan (menggunakan peralatan matematika yang dijelaskan di bagian sebelumnya), atau "bertanya" mesin PHMM: "Bahasa apa yang digunakan dalam percakapan?"  Seperti yang telah disebutkan, pengaturan eksperimental ini memastikan keakuratan identifikasi bahasa - hingga 90%.  Proses pelatihan mesin PHMM akan dijelaskan secara rinci di bagian selanjutnya (dalam contoh dengan Skype). </p><br><a name="a7"></a><br><h1 id="proslushivanie-shifrovannogo-audio-potoka-skype">  Mendengarkan aliran audio terenkripsi Skype </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini</a> menunjukkan bagaimana menyelesaikan masalah yang lebih kompleks menggunakan mesin PHMM: mengenali aliran audio terenkripsi yang dihasilkan oleh Skype (yang menggunakan codec audio Opus / NGC dalam mode VBR; dan enkripsi AES 256-bit).  Pengembangan yang disajikan bekerja sesuai dengan prinsip yang ditunjukkan pada Gambar 5. Untuk ini, ia menggunakan pengaturan eksperimental seperti yang ditunjukkan pada Gambar 6. Tetapi hanya dengan Skype codec Opus. </p><br><p>  Untuk melatih mesin PHMM mereka, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peneliti menggunakan</a> urutan langkah-langkah berikut: 1) pertama-tama mereka mengumpulkan seperangkat trek suara, termasuk semua frasa yang menarik bagi mereka;  2) kemudian menginstal sniffer paket jaringan, dan memulai percakapan suara antara dua akun Skype (manipulasi ini menyebabkan generasi lalu lintas UDP terenkripsi antara dua mesin, dalam mode P2P);  3) kemudian mereka memainkan masing-masing trek suara yang dikumpulkan dalam sesi Skype menggunakan media player;  dengan interval hening selama lima detik;  4) Sementara itu, sniffer paket dikonfigurasikan untuk mendaftarkan semua lalu lintas yang memasuki mesin kedua dari pengaturan eksperimental (lihat Gbr. 6).  Setelah mengumpulkan semua data pelatihan, rantai panjang paket UDP diekstraksi menggunakan pengurai otomatis untuk file PCAP.  Rantai yang dihasilkan, terdiri dari panjang paket payload, kemudian digunakan untuk melatih model PHMM, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Baum-Welsh</a> . </p><br><a name="a8"></a><br><h1 id="a-esli-otklyuchit-vbr-rezhim">  Dan jika Anda mematikan mode VBR? </h1><br><p>  Tampaknya masalah kebocoran tersebut dapat diselesaikan dengan mengalihkan codec audio ke mode bitrate konstan (meskipun solusi macam apa itu - bandwidth dari ini berkurang tajam), tetapi bahkan dalam kasus ini, keamanan aliran audio yang dienkripsi masih menyisakan banyak yang diinginkan.  Bagaimanapun, eksploitasi panjang paket trafik VBR hanyalah salah satu contoh serangan pada saluran bypass.  Tetapi ada beberapa contoh serangan lainnya, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelacakan jeda antar kata</a> . </p><br><p>  Tugas ini tentu tidak trivial, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cukup bisa dipecahkan</a> .  Mengapa ini tidak sepele?  Karena di Skype, misalnya, untuk mengoordinasikan operasi protokol UDP dan NAT (terjemahan alamat jaringan; terjemahan alamat jaringan);  dan juga untuk meningkatkan kualitas suara yang ditransmisikan - pengiriman paket jaringan tidak berhenti bahkan ketika ada jeda dalam percakapan.  Ini mempersulit tugas mengidentifikasi jeda dalam pidato. </p><br><p>  Namun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, di sini</a> algoritma nilai ambang batas adaptif dikembangkan, yang memungkinkan untuk membedakan keheningan dari ucapan dengan akurasi lebih dari 80%;  metode yang diusulkan didasarkan pada kenyataan bahwa aktivitas bicara sangat berkorelasi dengan ukuran paket terenkripsi: lebih banyak informasi dikodekan dalam paket suara ketika pengguna berbicara daripada selama keheningan pengguna.  Dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (dengan penekanan pada Google Talk, Lella dan Bettati) pembicara diidentifikasi, bahkan ketika tidak ada kebocoran terjadi melalui ukuran paket (bahkan ketika mode VBR dinonaktifkan).  Di sini, peneliti mengandalkan pengukuran interval waktu antara penerimaan paket.  Metode yang dijelaskan bergantung pada fase diam, yang dikodekan dalam paket yang lebih kecil, dengan interval waktu yang lebih lama - untuk memisahkan kata dari satu sama lain. </p><br><p>  T.O.  bahkan kriptografi paling modern tidak dapat melindungi komunikasi VoIP terenkripsi dari mendengarkan, bahkan jika kriptografi ini diterapkan dengan benar, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mungkin terjadi</a> dengan sendirinya.    ,              (PHMM-),       - (       PRISM  BULLRUN).        .          ‚Äì       . </p><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><ol><li> Charles Wright, Lucas Ballard. Language Identification of Encrypted VoIP Traffic // Proceedings of the 16th USENIX Security Symposium. 2007. pp. 43-54. </li><li> Charles Wright, Lucas Ballard. Uncovering Spoken Phrases in Encrypted VoIP Conversations // Proceedings of the IEEE Symposium on Security and Privacy. 2008. pp. 35-49. </li><li> Benoit Dupasquier, Stefan Burschka. Analysis of information leakage from encrypted Skype conversations // International Journal of Information Security. 9(5), 2010. pp. 313-325. </li><li> Shaun Colley. Practical Attacks Against Encrypted VoIP Communications // HITB Magazine. 4(19), 2014. pp. 30-41. </li><li> Global VoIP subscriber numbers and net growth // Point Topic. 2013. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://point-topic.com/free-analysis/global-voip-subscriber-numbers-q1-2013/</a> ( : 25  2018). </li><li> World Broadband Statistics ‚Äì Q3 2017 // Point Topic. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://point-topic.com/free-analysis/world-broadband-statistics-q3-2017/</a> ( : 25  2018). </li><li> James Ball. Revealed: how US and UK spy agencies defeat internet privacy and security // Guardian. 2013. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.theguardian.com/world/2013/sep/05/nsa-gchq-encryption-codes-security</a> ( : 25  2018). </li><li> Hiddem Markov Model // Wikipedia. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://en.wikipedia.org/wiki/Hidden_Markov_model</a> ( : 25  2018). </li><li> Forward‚Äìbackward algorithm // Wikipedia. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://en.wikipedia.org/wiki/Forward%E2%80%93backward_algorithm</a> ( : 25  2018). </li><li> Leonard Baum, Norman Weiss. A maximization technique occurring in the statistical analysis of probabilistic functions of Markov chains // Annals of Mathematical Statistics. 41(1), 1970. pp. 164-171. </li><li> Andrew Viterbi. Error bounds for convolutional codes and an asymptotically optimum decoding algorithm // IEEE Transactions on Information Theory. 13(2), 1967. pp. 260-267. </li><li> Manfred Schroeder. Code-excited linear prediction(CELP): High-quality speech at very low bit rates // Proceedings of the 1985 IEEE International Conference on Acoustics, Speech, and Signal Processing. v.10, 1985. pp, 937-940. </li><li> S. Eddy. Multiple alignment using hidden Markov models // Proceedings of the Third International Conference on Intelligent Systems for Molecular Biology. 1995. pp. 114-120. </li><li> Yu-Chun Chang. Inferring speech activity from encrypted Skype traffic // Proceedings of IEEE Globecom. 2008. </li><li> Tuneesh Lella. Privacy of encrypted voice-over-IP // Proceedings of the 2007 IEEE International Conference on Systems, Man and Cybernetics. 2007. pp. 3063-3068. </li><li> Charles Wright. Language identification of encrypted VoIP traffic: Alejandra y Roberto or Alice and Bob? // Proceedings of the 16th USENIX Security Symposium. 2007. pp. 1-12. </li><li>  ..     :  SSL/TLS-    // . ‚Ññ228. 2018. </li><li>  ..   // . 2015. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habrahabr.ru/post/272385/</a> ( : 25  2018). </li></ol></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461759/">https://habr.com/ru/post/id461759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461747/index.html">Bagaimana kami menerapkan ML dalam aplikasi dengan hampir 50 juta pengguna. Pengalaman Sberbank</a></li>
<li><a href="../id461749/index.html">Keindahan di mata yang melihatnya</a></li>
<li><a href="../id461751/index.html">Kontribusi desainer untuk pengembangan aplikasi seluler</a></li>
<li><a href="../id461753/index.html">InterSystems, Transaksi Global IRIS</a></li>
<li><a href="../id461755/index.html">The Psychology of Sound Vision. Svetlana Lebedeva menceritakan bagaimana orang diajari cara pandang yang baru</a></li>
<li><a href="../id461761/index.html">DPKI: mengatasi kelemahan PKI terpusat dengan blockchain</a></li>
<li><a href="../id461763/index.html">Dapatkah agen periklanan mematikan bisnis pada awal perjalanan</a></li>
<li><a href="../id461765/index.html">Kami melintasi k8 dengan Kafka, menyimpan kontainer, melarikan diri dari sampah di Ansible: 10 laporan teratas dari DevOops 2018</a></li>
<li><a href="../id461767/index.html">Algoritma Mesin Pencari SVLAB</a></li>
<li><a href="../id461769/index.html">Bagaimana saya membuat (hampir) streaming webcam Javascript yang tidak berguna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>