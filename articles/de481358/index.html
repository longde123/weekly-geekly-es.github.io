<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎓 🗼 🗡️ C ++ Russland: wie es war 🤶🏻 🤳🏿 🚡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie zu Beginn des Stücks sagen, dass C ++ - Code an der Wand hängt, sollte er Sie am Ende mit Sicherheit in den Fuß schießen. 

 Bjarne Stroustru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ Russland: wie es war</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/481358/">  <i>Wenn Sie zu Beginn des Stücks sagen, dass C ++ - Code an der Wand hängt, sollte er Sie am Ende mit Sicherheit in den Fuß schießen.</i> <i><br><br></i>  <i>Bjarne Stroustrup</i> <i><br></i> <br>  Vom 31. Oktober bis 1. November war St. Petersburg Gastgeber der C ++ Russia Piter Conference, einer der größten von der JUG Ru Group organisierten Programmierkonferenzen in Russland.  Zu den eingeladenen Rednern gehören Mitglieder des C ++ - Standardisierungskomitees, Redner bei CppCon, Autoren von O'Reilly-Büchern sowie Projektbetreuer wie LLVM, libc ++ und Boost.  Die Konferenz richtet sich an erfahrene C ++ - Entwickler, die ihr Fachwissen vertiefen und Erfahrungen in der Live-Kommunikation austauschen möchten.  Studenten, Doktoranden und Universitätsprofessoren erhalten sehr angenehme Rabatte. <br><br>  Die Moskauer Ausgabe der Konferenz kann bereits im April nächsten Jahres besucht werden, aber im Moment werden unsere Studenten Ihnen erzählen, welche interessanten Dinge sie bei der letzten Veranstaltung gelernt haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a73/7bf/78f/a737bf78fa7a626dc60d87aae2d2ce88.png"><br><a name="habracut"></a><br>  <i>Foto aus <a href="https://vk.com/album-77278886_270140987">dem Konferenzalbum</a></i> <br><br><h2>  Über uns </h2><br>  Zwei Studenten der Hochschule für Wirtschaft - St. Petersburg, arbeiteten an diesem Beitrag: <br><br><ul><li>  Lisa Vasilenko studiert im vierten Studienjahr im Rahmen des Programms „Angewandte Mathematik und Informatik“ die Richtung „Programmiersprachen“.  Im ersten Studienjahr mit der C ++ - Sprache vertraut gemacht, anschließend in Praktika in der Industrie Erfahrungen damit gesammelt.  Die Leidenschaft für Programmiersprachen im Allgemeinen und die funktionale Programmierung im Besonderen haben ihre Spuren in der Auswahl der Berichte auf der Konferenz hinterlassen. <br></li><li>  Danya Smirnov studiert im ersten Studienjahr im Masterstudiengang „Datenprogrammierung und -analyse“.  Noch in der Schule schrieb er Probleme mit der Olympiade in C ++, und dann kam es irgendwie vor, dass die Sprache in pädagogischen Aktivitäten ständig auftauchte und infolgedessen zur Hauptarbeitssprache wurde.  Ich beschloss, an der Konferenz teilzunehmen, um mein Wissen zu erweitern und neue Möglichkeiten kennenzulernen. <br></li></ul><br>  Im Newsletter teilen die Leiter der Fakultäten häufig Informationen zu Bildungsveranstaltungen mit Bezug zu unserem Fachgebiet.  Im September sahen wir Informationen über C ++ Russia und beschlossen, uns als Zuhörer zu registrieren.  Dies ist unsere erste Erfahrung mit der Teilnahme an solchen Konferenzen. <br><br><h2>  Konferenzstruktur </h2><br><ul><li><h3>  Berichte </h3></li></ul><br>  Innerhalb von zwei Tagen lasen die Experten 30 Berichte, in denen viele wichtige Themen behandelt wurden: witzige Anwendungen von Sprachfunktionen zur Lösung angewandter Probleme, bevorstehende Sprachupdates aufgrund des neuen Standards, Kompromisse beim C ++ - Design und Vorsichtsmaßnahmen bei der Arbeit mit ihren Konsequenzen, Beispiele für interessante Projektarchitekturen, sowie einige Engine-Teile der Sprachinfrastruktur.  Zur gleichen Zeit fanden 3 Vorstellungen statt, meistens zwei in russischer und eine in englischer Sprache. <br><br><ul><li><h3>  Diskussionszonen </h3></li></ul><br>  Nach der Rede wurden alle unbeantworteten Fragen und unvollständigen Diskussionen an speziell dafür vorgesehene Kommunikationsbereiche mit Sprechern, die mit Markierungstafeln ausgestattet waren, weitergeleitet.  Ein guter Weg, um die Pause zwischen den Auftritten für ein angenehmes Gespräch zu verbringen. <br><br><ul><li><h3>  Blitzgespräche und informelle Diskussionen </h3></li></ul><br>  Wenn Sie einen kurzen Bericht verfassen möchten, können Sie sich für einen abendlichen Lightning Talk an einer Pinnwand anmelden und haben fünf Minuten Zeit, um über alles zum Thema der Konferenz zu sprechen.  Zum Beispiel eine kurze Einführung in Desinfektionsmittel für C ++ (was sich für einige als neu herausstellte) oder eine Geschichte über einen Fehler bei der Erzeugung einer Sinuskurve, die Sie nur hören, aber nicht sehen können. <br><br>  Ein weiteres Format ist die Podiumsdiskussion „With the Soul Committee“.  Auf der Bühne gibt es einige Mitglieder des Standardisierungskomitees, auf dem Projektor gibt es einen Kamin (offiziell - um eine gefühlvolle Atmosphäre zu schaffen, aber der Grund, "weil ALLES AUF FEUER" lustiger erscheint), die Fragen betreffen den Standard und die allgemeine Vision von C ++, ohne heiße technische Diskussionen und Holivars.  Es stellte sich heraus, dass auch lebende Menschen im Ausschuss sitzen, die sich vielleicht nicht ganz sicher sind oder etwas nicht wissen. <br><br>  Für Holivar-Enthusiasten blieb die dritte Veranstaltung - die BOF-Session „Go against C ++“.  Wir nehmen einen Go-Liebhaber, einen C ++ - Liebhaber, vor Beginn der Sitzung bereiten sie zusammen 100500 Folien zum Thema vor (wie Probleme mit Paketen in C ++ oder fehlende Generika in Go), und dann diskutieren sie lebhaft untereinander und mit dem Publikum, und das Publikum versucht, zwei Standpunkte gleichzeitig zu verstehen .  Wenn der holivar nicht in Betrieb genommen wird, greift der Moderator ein und versöhnt die Parteien.  Dieses Format macht süchtig: Wenige Stunden nach dem Start war nur die Hälfte der Folien fertig.  Das Ende musste stark beschleunigt werden. <br><br><ul><li><h3>  Partner Stände </h3></li></ul><br>  Die Konferenzpartner waren in den Hallen vertreten - sie sprachen an den Ständen über aktuelle Projekte, boten Praktika und Jobs an, veranstalteten Quiz und kleine Wettbewerbe und spielten auch schöne Preise.  Einige Unternehmen boten jedoch sogar an, die ersten Phasen der Befragung zu durchlaufen, was für diejenigen von Nutzen sein kann, die nicht nur Berichte anhören wollten. <br><br><h2>  Technische Details der Berichte </h2><br>  Wir haben uns beide Tage Berichte angehört.  Manchmal war es schwierig, aus den parallel laufenden Berichten einen auszuwählen - wir waren uns einig, das in den Pausen gewonnene Wissen zu teilen und auszutauschen.  Trotzdem scheint vieles verloren gegangen zu sein.  Hier möchten wir über den Inhalt einiger Berichte sprechen, die uns am interessantesten erschienen <br><br><h3>  Ausnahmen in C ++ durch das Prisma der Compileroptimierungen, Roman Rusyaev </h3><br><br><img src="https://habrastorage.org/webt/dc/0q/rl/dc0qrlgt1peqimzact93fvh8zb0.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">Präsentationsfolie</a></i> <br><br>  Wie der Name schon sagt, untersuchte Roman die Arbeit mit Ausnahmen am Beispiel der LLVM.  Gleichzeitig kann der Bericht für diejenigen, die Clang nicht in ihrer Arbeit verwenden, eine Vorstellung davon geben, wie der Code potenziell optimiert werden kann.  Dies liegt daran, dass Entwickler von Compilern und entsprechenden Standardbibliotheken miteinander kommunizieren und viele erfolgreiche Lösungen zusammenfallen können. <br><br>  Um die Ausnahme zu behandeln, müssen Sie viele Aktionen ausführen: Rufen Sie den Verarbeitungscode (falls vorhanden) auf oder setzen Sie Ressourcen auf der aktuellen Ebene frei und wickeln Sie den Stapel höher ab.  All dies führt dazu, dass der Compiler zusätzliche Anweisungen für das Auslösen von Aufrufen hinzufügt.  Wenn tatsächlich keine Ausnahme verursacht wird, führt das Programm dennoch unnötige Aktionen aus.  Um die Gemeinkosten zu senken, verfügt LLVM über verschiedene Heuristiken, mit denen Sie Situationen ermitteln können, in denen Sie keinen Ausnahmebehandlungscode hinzufügen müssen oder die Anzahl der "unnötigen" Anweisungen verringern können. <br><br>  Der Redner betrachtet etwa ein Dutzend davon und zeigt sowohl Situationen, in denen sie zur Beschleunigung der Programmausführung beitragen, als auch Situationen, in denen diese Methoden nicht anwendbar sind. <br><br>  So führt Roman Rusyaev die Zuhörer zu dem Schluss, dass Code, der Arbeiten mit Ausnahmen enthält, keinesfalls immer ohne Mehraufwand ausgeführt werden kann, und gibt die folgenden Tipps: <br><br><ul><li>  Bei der Entwicklung von Bibliotheken sollten Sie grundsätzlich auf Ausnahmen verzichten. </li><li>  Wenn Sie weiterhin Ausnahmen benötigen, sollten Sie nach Möglichkeit Modifikatoren noexcept (und const) hinzufügen, damit der Compiler so weit wie möglich optimieren kann. </li></ul><br>  Im Allgemeinen bekräftigte der Redner die Auffassung, dass Ausnahmen am besten auf ein Minimum beschränkt oder sogar aufgegeben werden. <br><br>  Die Berichtsfolien finden Sie unter: <a href="https://assets.ctfassets.net/oxjq45e8ilak/6Q09SPvX2Rsveiayc1VkcC/ce9e2b8eb22d6693eb4c3b06968bedc0/100693_477384438_Roman_Rusyayev_Isklyucheniya_C_cherez_prizmu_kompilyatornykh_optimizatsiy.pdf">[„C ++ - Ausnahmen durch das Prisma der LLVM-Compileroptimierung“]</a> <br><br><h3>  Generatoren, Koroutinen und andere hirnabbauende Süßigkeiten, Adi Shavit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d20/0c4/4a6/d200c44a65058c3b50a29d0b551a9cc0.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">Präsentationsfolie</a></i> <br><br>  Einer der vielen Berichte dieser Konferenz über die Neuerungen von C ++ 20 wurde nicht nur durch seine farbenfrohe Präsentation in Erinnerung gerufen, sondern auch durch die eindeutige Bezeichnung der Probleme mit der Verarbeitungslogik der Sammlung (für Rückrufschleife). <br><br>  Adi Shavit hebt Folgendes hervor: Derzeit verfügbare Methoden durchlaufen die gesamte Sammlung und gewähren keinen Zugriff auf einen internen Zwischenzustand (oder geben bei Rückrufen, aber mit vielen unangenehmen Nebenwirkungen, wie der gleichen Rückruf-Hölle).  Es scheint, dass es Iteratoren gibt, aber bei ihnen ist nicht alles reibungslos: Es gibt keine gemeinsamen Einstiegs- und Ausstiegspunkte (Anfang → Ende versus Anfang → Ende usw.). Es ist unklar, wie oft wir überhaupt iterieren werden.  Ab C ++ 20 sind diese Probleme behoben! <br><br>  Die erste Option: Bereiche.  Durch den Wrapper auf Iteratoren erhalten wir eine gemeinsame Schnittstelle für den Beginn und das Ende der Iteration sowie die Möglichkeit der Komposition.  All dies macht es einfach, vollwertige Datenverarbeitungs-Pipelines zu erstellen.  Aber nicht alles ist so reibungslos: Ein Teil der Berechnungslogik besteht in der Implementierung eines bestimmten Iterators, der den Code für die Wahrnehmung und das Debuggen erschweren kann. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/a7d/09d/f41a7d09d24a823a3397aa27a552f254.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">Präsentationsfolie</a></i> <br><br>  In diesem Fall wurden in C ++ 20 Coroutinen hinzugefügt (Funktionen, die sich ähnlich wie Generatoren in Python verhalten): Die Ausführung kann verzögert werden, indem ein aktueller Wert zurückgegeben wird, während der Zwischenzustand beibehalten wird.  Auf diese Weise arbeiten wir nicht nur mit Daten, wie sie angezeigt werden, sondern kapseln auch die gesamte Logik in einer bestimmten Coroutine. <br><br>  Die Salbe hat jedoch ein Problem: Momentan werden sie nur teilweise von vorhandenen Compilern unterstützt, und sie werden auch nicht so genau implementiert, wie wir es uns wünschen: Beispielsweise sollten Links und temporäre Objekte nicht in Coroutinen verwendet werden.  Außerdem gibt es einige Einschränkungen für mögliche Coroutinen. Constexpr-Funktionen, Konstruktoren / Destruktoren und auch main sind in dieser Liste nicht enthalten. <br><br>  Somit lösen die Koroutinen einen wesentlichen Teil der Probleme mit der Einfachheit der Datenverarbeitungslogik, aber ihre gegenwärtigen Implementierungen erfordern eine Verfeinerung. <br><br>  Material: <br><br><ul><li>  Folien mit C ++ Russia - <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">["Generatoren, Koroutinen und andere gehirnentrollende Süße"]</a> </li><li>  <a href="https://youtu.be/qYHDERleSL8">Videobericht von der CppCon 2019</a> </li></ul><br><h3>  C ++ Tricks von Yandex.Taxi, Anton Polukhin </h3><br>  In seiner beruflichen Tätigkeit muss man manchmal nur Hilfsdinge implementieren: einen Wrapper zwischen der internen Schnittstelle und der API einer Bibliothek, Protokollierung oder Analyse.  In der Regel ist jedoch keine zusätzliche Optimierung erforderlich.  Aber was ist, wenn diese Komponenten in einigen der beliebtesten Dienste in Runet verwendet werden?  In einer solchen Situation müssen Sie nur Terabyte pro Stunde an Protokollen verarbeiten!  Dann zählt jede Millisekunde und deshalb muss man auf verschiedene Tricks zurückgreifen - Anton Polukhin hat darüber gesprochen. <br><br>  Das vielleicht interessanteste Beispiel war die Implementierung des Pimpl-Musters (Pointer-to-Implementation). <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;third_party/json.hpp&gt; //PROBLEMS! struct Value { Value() = default; Value(Value&amp;&amp; other) = default; Value&amp; operator=(Value&amp;&amp; other) = default; ~Value() = default; std::size_t Size() const { return data_.size(); } private: third_party::Json data_; };</span></span></span></span></code> </pre> <br>  In diesem Beispiel möchten Sie zuerst die Header-Dateien externer Bibliotheken entfernen. Sie werden schneller kompiliert und können sich vor möglichen Namenskonflikten und ähnlichen Fehlern schützen. <br><br>  Ok, #include in die .cpp-Datei verschoben: Sie benötigen die Forward-Deklaration der umschlossenen API sowie std :: unique_ptr.  Jetzt haben wir dynamische Zuweisungen und andere unangenehme Dinge, wie Daten, die über einen Haufen verstreut sind, und reduzierte Garantien.  Bei alledem kann std :: aligned_storage helfen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... private: using JsonNative = third_party::Json; const JsonNative* Ptr() const noexcept; JsonNative* Ptr() noexcept; constexpr std::size_t kImplSize = 32; constexpr std::size_t kImplAlign = 8; std::aligned_storage_t&lt;kImplSize, kImplAlign&gt; data_; };</span></span></code> </pre> <br>  Das einzige Problem: Sie müssen die Größe und Ausrichtung für jeden Wrapper angeben - wir erstellen unsere Pimpl-Vorlage mit den Parametern &lt;T, SizeT, AlignmentT&gt;, verwenden einige beliebige Werte und fügen dem Destruktor eine Überprüfung hinzu, dass wir alles erraten haben: <br><br><pre> <code class="cpp hljs">~FastPimpl() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { validate&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt;(); Ptr()-&gt;~T(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualSize, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualAlignment&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Size == ActualSize, <span class="hljs-string"><span class="hljs-string">"Size and sizeof(T) mismatch"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Alignment == ActualAlignment, <span class="hljs-string"><span class="hljs-string">"Alignment and alignof(T) mismatch"</span></span> ); }</code> </pre> <br>  Da T bereits während der Verarbeitung des Destruktors definiert wurde, wird dieser Code korrekt analysiert und zeigt in der Kompilierungsphase die erforderlichen Größen- und Ausrichtungswerte an, die in Form von Fehlern eingegeben werden müssen.  Auf diese Weise wird auf Kosten eines zusätzlichen Kompilierungsbeginns die dynamische Zuordnung von umschlossenen Klassen aufgehoben, die API in einer CPP-Datei mit der Implementierung ausgeblendet und ein Entwurf erstellt, der für das Caching durch den Prozessor besser geeignet ist. <br><br>  Protokollierung und Analyse schienen weniger beeindruckend und werden daher in diesem Test nicht erwähnt. <br><br>  Die Berichtsfolien sind unter folgendem Link verfügbar: <a href="https://assets.ctfassets.net/oxjq45e8ilak/4rkoaQV6ancsfvzYx1fOCF/087dda7d63101cc225d706d03d7c5075/100566_2093066332_Anton_Polukhin_C_tryuki_iz_Taksi.pdf">[“C ++ Taxi Tricks”]</a> <br><br><h3>  Moderne Techniken, um Ihren Code trocken zu halten, Björn Fahller </h3><br>  Björn Fahller zeigt in diesem Vortrag verschiedene Möglichkeiten auf, mit Stilfehlern umzugehen, wie beispielsweise wiederholte bedingte Prüfungen: <br><br><pre> <code class="cpp hljs">assert(a == IDLE || a == CONNECTED || a == DISCONNECTED);</code> </pre> <br>  Ist das bekannt  Mit mehreren leistungsstarken C ++ - Techniken, die in den letzten Standards verwendet wurden, können Sie dieselbe Funktionalität ohne den geringsten Leistungsverlust ordnungsgemäß implementieren.  Vergleichen Sie: <br><br><pre> <code class="cpp hljs">assert(a == any_of(IDLE, CONNECTED, DISCONNECTED));</code> </pre> <br>  Um eine unbegrenzte Anzahl von Schecks zu verarbeiten, werden Sie sofort aufgefordert, verschiedene Vorlagen und Falzausdrücke zu verwenden.  Angenommen, wir möchten die Gleichheit mehrerer Variablen mit dem Element enum'a state_type überprüfen.  Das erste, was mir in den Sinn kommt, ist, die Hilfsfunktion is_any_of zu schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> state_type { IDLE, CONNECTED, DISCONNECTED }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp; ... ts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((s == ts) || ...); }</code> </pre><br>  Ein solches Zwischenergebnis ist enttäuschend.  Bisher wird der Code nicht lesbar: <br><br><pre> <code class="cpp hljs">assert(is_any_of(state, IDLE, DISCONNECTING, DISCONNECTED));</code> </pre> <br>  Nicht typisierte Vorlagenparameter tragen dazu bei, die Situation ein wenig zu verbessern.  Mit ihrer Hilfe übertragen wir die aufgezählten Aufzählungselemente in die Liste der Vorlagenparameter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;state_type ... states&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == states) | ...); } assert(is_any_of&lt;IDLE, DISCONNECTING, DISCONNECTED&gt;(state));</code> </pre> <br>  Bei Verwendung von auto in einem nicht typischen Vorlagenparameter (C ++ 17) wird der Ansatz einfach auf Vergleiche nicht nur mit state_type-Elementen, sondern auch mit primitiven Typen verallgemeinert, die als nicht typisierte Vorlagenparameter verwendet werden können: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ... alternatives, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == alternatives) | ...); }</code> </pre> <br>  Durch diese inkrementellen Verbesserungen wird die gewünschte Cursorsyntax für die Überprüfung erreicht: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any_of</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts ...&gt; { <span class="hljs-comment"><span class="hljs-comment">//      tuple        using std::tuple&lt;Ts ...&gt;::tuple;        template &lt;typename T&gt;        bool operator ==(const T&amp; t) const {                return std::apply(                        [&amp;t](const auto&amp; ... ts) {                                return ((ts == t) || ...);                        },                        static_cast&lt;const std::tuple&lt;Ts ...&gt;&amp;&gt;(*this));        } }; template &lt;class ... Ts&gt; any_of(Ts ...) -&gt; any_of&lt;Ts ... &gt;; assert(any_of(IDLE, DISCONNECTING, DISCONNECTED) == state);</span></span></code> </pre><br>  In diesem Beispiel dient der Ableitungsleitfaden dazu, die gewünschten Vorlagenstrukturparameter an einen Compiler weiterzuleiten, der die Typen der Konstruktorargumente kennt. <br><br>  Interessanter.  Björn lehrt, den resultierenden Code zusätzlich zu == für Vergleichsoperatoren und dann für beliebige Operationen zu verallgemeinern.  Zusammen mit dem Anwendungsfall werden Funktionen wie das Attribut no_unique_address (C ++ 20) und Vorlagenparameter in Lambda-Funktionen (C ++ 20) erläutert.  (Ja, jetzt ist die Lambda-Syntax noch einfacher zu merken - das sind vier aufeinanderfolgende Paare von Klammern aller Art.) Die endgültige Lösung, die Funktionen als Konstruktorteile verwendet, erwärmt meine Seele wirklich, ganz zu schweigen vom Tupelausdruck in den besten Traditionen der Lambda-Rechnung. <br><br>  Vergessen Sie am Ende nicht, einen Glanz zu setzen: <br><br><ul><li>  Denken Sie daran, dass Lambdas constexpr kostenlos sind; </li><li>  Fügen Sie eine perfekte Weiterleitung hinzu und sehen Sie sich die hässliche Syntax für das Parameterpaket in Lambda Closure an. </li><li>  Lassen Sie uns dem Compiler mehr Optionen für Optimierungen mit der Bedingung noexcept geben. </li><li>  Aufgrund der expliziten Rückgabewerte von Lambdas sorgen wir für eine deutlichere Fehlerausgabe in Vorlagen.  Dadurch wird der Compiler gezwungen, weitere Überprüfungen durchzuführen, bevor die Vorlagenfunktion tatsächlich aufgerufen wird - in der Phase der Typüberprüfung. </li></ul><br>  Einzelheiten entnehmen Sie bitte den Vorlesungsunterlagen: <br><br><ul><li>  Berichtsfolien: <a href="https://assets.ctfassets.net/oxjq45e8ilak/7lP3ueTFEJnmdVjGGjrgHI/e30dfcbff0630fb63389f3f3e734a1a3/100644_2039674689_Bjrn_Fahller_Modern_techniques_for_keeping_your_code_dry.pdf">[Moderne Techniken, um Ihren Code trocken zu halten]</a> </li><li>  <a href="https://github.com/rollbear/dry-comparisons">Github-Quellcode</a> </li><li>  <a href="https://playfulprogramming.blogspot.com/2018/07/dry-multicomparisons.html">Blogartikel des Autors</a> </li></ul><br><h2>  Unsere Eindrücke </h2><br>  Unsere erste Teilnahme an C ++ Russia wurde für seinen Reichtum in Erinnerung gerufen.  Es gab einen Eindruck von C ++ Russland als emotionales Ereignis, bei dem die Grenze zwischen Lernen und Live-Kommunikation fast nicht erkennbar ist.  Alles, von der Stimmung der Redner bis zu den Wettbewerben der Partner der Veranstaltung, ist förderlich für hitzige Diskussionen.  Der Inhalt der Konferenz, die aus Berichten besteht, deckt ein ziemlich breites Themenspektrum ab, einschließlich C ++ - Innovationen, Beispielen aus der Praxis großer Projekte und ideologischen architektonischen Überlegungen.  Es wäre jedoch unfair, die Aufmerksamkeit der sozialen Komponente der Veranstaltung zu entziehen, was dazu beiträgt, Sprachbarrieren nicht nur in Bezug auf C ++ zu überwinden. <br><br>  Wir danken den Organisatoren der Konferenz für die Möglichkeit, an einer solchen Veranstaltung teilzunehmen! <br>  Den Beitrag der Organisatoren über Vergangenheit, Gegenwart und Zukunft von C ++ Russia können Sie <a href="https://habr.com/ru/company/jugru/blog/480584/">auf dem JUG Ru-Blog sehen</a> . <br><br>  Vielen Dank fürs Lesen und wir hoffen, dass sich unsere Nacherzählung der Ereignisse als nützlich erwiesen hat! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481358/">https://habr.com/ru/post/de481358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481348/index.html">Pentest Active Directory. Teil 1</a></li>
<li><a href="../de481350/index.html">Wer arbeitet am Kosmodrom Plesetsk?</a></li>
<li><a href="../de481352/index.html">DBA: Löschen von Klonsätzen aus einer Tabelle ohne PK</a></li>
<li><a href="../de481354/index.html">TelegramBot. Die Grundfunktionalität. Fliegen getrennt, Schnitzel getrennt. (Teil 2)</a></li>
<li><a href="../de481356/index.html">Vielen Dank, 2019</a></li>
<li><a href="../de481360/index.html">Die Ergebnisse der Woche: Rambler und Twitch waren sich einig, in der Russischen Föderation wird die elektronische Arbeit eingeführt und Facebook wird ein eigenes Betriebssystem erstellen</a></li>
<li><a href="../de481362/index.html">SSL Zertifikat für Docker Web-App</a></li>
<li><a href="../de481364/index.html">Sensibles Zuhause ersetzt intelligentes Zuhause</a></li>
<li><a href="../de481366/index.html">RICE: Einfache Priorisierung für Produktmanager</a></li>
<li><a href="../de481368/index.html">Blindkameratest: iPhone, Pixel, Samsung und Huawei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>