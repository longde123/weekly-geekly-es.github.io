<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüéì üóº üó°Ô∏è C ++ Russland: wie es war ü§∂üèª ü§≥üèø üö°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie zu Beginn des St√ºcks sagen, dass C ++ - Code an der Wand h√§ngt, sollte er Sie am Ende mit Sicherheit in den Fu√ü schie√üen. 

 Bjarne Stroustru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ Russland: wie es war</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/481358/">  <i>Wenn Sie zu Beginn des St√ºcks sagen, dass C ++ - Code an der Wand h√§ngt, sollte er Sie am Ende mit Sicherheit in den Fu√ü schie√üen.</i> <i><br><br></i>  <i>Bjarne Stroustrup</i> <i><br></i> <br>  Vom 31. Oktober bis 1. November war St. Petersburg Gastgeber der C ++ Russia Piter Conference, einer der gr√∂√üten von der JUG Ru Group organisierten Programmierkonferenzen in Russland.  Zu den eingeladenen Rednern geh√∂ren Mitglieder des C ++ - Standardisierungskomitees, Redner bei CppCon, Autoren von O'Reilly-B√ºchern sowie Projektbetreuer wie LLVM, libc ++ und Boost.  Die Konferenz richtet sich an erfahrene C ++ - Entwickler, die ihr Fachwissen vertiefen und Erfahrungen in der Live-Kommunikation austauschen m√∂chten.  Studenten, Doktoranden und Universit√§tsprofessoren erhalten sehr angenehme Rabatte. <br><br>  Die Moskauer Ausgabe der Konferenz kann bereits im April n√§chsten Jahres besucht werden, aber im Moment werden unsere Studenten Ihnen erz√§hlen, welche interessanten Dinge sie bei der letzten Veranstaltung gelernt haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a73/7bf/78f/a737bf78fa7a626dc60d87aae2d2ce88.png"><br><a name="habracut"></a><br>  <i>Foto aus <a href="https://vk.com/album-77278886_270140987">dem Konferenzalbum</a></i> <br><br><h2>  √úber uns </h2><br>  Zwei Studenten der Hochschule f√ºr Wirtschaft - St. Petersburg, arbeiteten an diesem Beitrag: <br><br><ul><li>  Lisa Vasilenko studiert im vierten Studienjahr im Rahmen des Programms ‚ÄûAngewandte Mathematik und Informatik‚Äú die Richtung ‚ÄûProgrammiersprachen‚Äú.  Im ersten Studienjahr mit der C ++ - Sprache vertraut gemacht, anschlie√üend in Praktika in der Industrie Erfahrungen damit gesammelt.  Die Leidenschaft f√ºr Programmiersprachen im Allgemeinen und die funktionale Programmierung im Besonderen haben ihre Spuren in der Auswahl der Berichte auf der Konferenz hinterlassen. <br></li><li>  Danya Smirnov studiert im ersten Studienjahr im Masterstudiengang ‚ÄûDatenprogrammierung und -analyse‚Äú.  Noch in der Schule schrieb er Probleme mit der Olympiade in C ++, und dann kam es irgendwie vor, dass die Sprache in p√§dagogischen Aktivit√§ten st√§ndig auftauchte und infolgedessen zur Hauptarbeitssprache wurde.  Ich beschloss, an der Konferenz teilzunehmen, um mein Wissen zu erweitern und neue M√∂glichkeiten kennenzulernen. <br></li></ul><br>  Im Newsletter teilen die Leiter der Fakult√§ten h√§ufig Informationen zu Bildungsveranstaltungen mit Bezug zu unserem Fachgebiet.  Im September sahen wir Informationen √ºber C ++ Russia und beschlossen, uns als Zuh√∂rer zu registrieren.  Dies ist unsere erste Erfahrung mit der Teilnahme an solchen Konferenzen. <br><br><h2>  Konferenzstruktur </h2><br><ul><li><h3>  Berichte </h3></li></ul><br>  Innerhalb von zwei Tagen lasen die Experten 30 Berichte, in denen viele wichtige Themen behandelt wurden: witzige Anwendungen von Sprachfunktionen zur L√∂sung angewandter Probleme, bevorstehende Sprachupdates aufgrund des neuen Standards, Kompromisse beim C ++ - Design und Vorsichtsma√ünahmen bei der Arbeit mit ihren Konsequenzen, Beispiele f√ºr interessante Projektarchitekturen, sowie einige Engine-Teile der Sprachinfrastruktur.  Zur gleichen Zeit fanden 3 Vorstellungen statt, meistens zwei in russischer und eine in englischer Sprache. <br><br><ul><li><h3>  Diskussionszonen </h3></li></ul><br>  Nach der Rede wurden alle unbeantworteten Fragen und unvollst√§ndigen Diskussionen an speziell daf√ºr vorgesehene Kommunikationsbereiche mit Sprechern, die mit Markierungstafeln ausgestattet waren, weitergeleitet.  Ein guter Weg, um die Pause zwischen den Auftritten f√ºr ein angenehmes Gespr√§ch zu verbringen. <br><br><ul><li><h3>  Blitzgespr√§che und informelle Diskussionen </h3></li></ul><br>  Wenn Sie einen kurzen Bericht verfassen m√∂chten, k√∂nnen Sie sich f√ºr einen abendlichen Lightning Talk an einer Pinnwand anmelden und haben f√ºnf Minuten Zeit, um √ºber alles zum Thema der Konferenz zu sprechen.  Zum Beispiel eine kurze Einf√ºhrung in Desinfektionsmittel f√ºr C ++ (was sich f√ºr einige als neu herausstellte) oder eine Geschichte √ºber einen Fehler bei der Erzeugung einer Sinuskurve, die Sie nur h√∂ren, aber nicht sehen k√∂nnen. <br><br>  Ein weiteres Format ist die Podiumsdiskussion ‚ÄûWith the Soul Committee‚Äú.  Auf der B√ºhne gibt es einige Mitglieder des Standardisierungskomitees, auf dem Projektor gibt es einen Kamin (offiziell - um eine gef√ºhlvolle Atmosph√§re zu schaffen, aber der Grund, "weil ALLES AUF FEUER" lustiger erscheint), die Fragen betreffen den Standard und die allgemeine Vision von C ++, ohne hei√üe technische Diskussionen und Holivars.  Es stellte sich heraus, dass auch lebende Menschen im Ausschuss sitzen, die sich vielleicht nicht ganz sicher sind oder etwas nicht wissen. <br><br>  F√ºr Holivar-Enthusiasten blieb die dritte Veranstaltung - die BOF-Session ‚ÄûGo against C ++‚Äú.  Wir nehmen einen Go-Liebhaber, einen C ++ - Liebhaber, vor Beginn der Sitzung bereiten sie zusammen 100500 Folien zum Thema vor (wie Probleme mit Paketen in C ++ oder fehlende Generika in Go), und dann diskutieren sie lebhaft untereinander und mit dem Publikum, und das Publikum versucht, zwei Standpunkte gleichzeitig zu verstehen .  Wenn der holivar nicht in Betrieb genommen wird, greift der Moderator ein und vers√∂hnt die Parteien.  Dieses Format macht s√ºchtig: Wenige Stunden nach dem Start war nur die H√§lfte der Folien fertig.  Das Ende musste stark beschleunigt werden. <br><br><ul><li><h3>  Partner St√§nde </h3></li></ul><br>  Die Konferenzpartner waren in den Hallen vertreten - sie sprachen an den St√§nden √ºber aktuelle Projekte, boten Praktika und Jobs an, veranstalteten Quiz und kleine Wettbewerbe und spielten auch sch√∂ne Preise.  Einige Unternehmen boten jedoch sogar an, die ersten Phasen der Befragung zu durchlaufen, was f√ºr diejenigen von Nutzen sein kann, die nicht nur Berichte anh√∂ren wollten. <br><br><h2>  Technische Details der Berichte </h2><br>  Wir haben uns beide Tage Berichte angeh√∂rt.  Manchmal war es schwierig, aus den parallel laufenden Berichten einen auszuw√§hlen - wir waren uns einig, das in den Pausen gewonnene Wissen zu teilen und auszutauschen.  Trotzdem scheint vieles verloren gegangen zu sein.  Hier m√∂chten wir √ºber den Inhalt einiger Berichte sprechen, die uns am interessantesten erschienen <br><br><h3>  Ausnahmen in C ++ durch das Prisma der Compileroptimierungen, Roman Rusyaev </h3><br><br><img src="https://habrastorage.org/webt/dc/0q/rl/dc0qrlgt1peqimzact93fvh8zb0.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">Pr√§sentationsfolie</a></i> <br><br>  Wie der Name schon sagt, untersuchte Roman die Arbeit mit Ausnahmen am Beispiel der LLVM.  Gleichzeitig kann der Bericht f√ºr diejenigen, die Clang nicht in ihrer Arbeit verwenden, eine Vorstellung davon geben, wie der Code potenziell optimiert werden kann.  Dies liegt daran, dass Entwickler von Compilern und entsprechenden Standardbibliotheken miteinander kommunizieren und viele erfolgreiche L√∂sungen zusammenfallen k√∂nnen. <br><br>  Um die Ausnahme zu behandeln, m√ºssen Sie viele Aktionen ausf√ºhren: Rufen Sie den Verarbeitungscode (falls vorhanden) auf oder setzen Sie Ressourcen auf der aktuellen Ebene frei und wickeln Sie den Stapel h√∂her ab.  All dies f√ºhrt dazu, dass der Compiler zus√§tzliche Anweisungen f√ºr das Ausl√∂sen von Aufrufen hinzuf√ºgt.  Wenn tats√§chlich keine Ausnahme verursacht wird, f√ºhrt das Programm dennoch unn√∂tige Aktionen aus.  Um die Gemeinkosten zu senken, verf√ºgt LLVM √ºber verschiedene Heuristiken, mit denen Sie Situationen ermitteln k√∂nnen, in denen Sie keinen Ausnahmebehandlungscode hinzuf√ºgen m√ºssen oder die Anzahl der "unn√∂tigen" Anweisungen verringern k√∂nnen. <br><br>  Der Redner betrachtet etwa ein Dutzend davon und zeigt sowohl Situationen, in denen sie zur Beschleunigung der Programmausf√ºhrung beitragen, als auch Situationen, in denen diese Methoden nicht anwendbar sind. <br><br>  So f√ºhrt Roman Rusyaev die Zuh√∂rer zu dem Schluss, dass Code, der Arbeiten mit Ausnahmen enth√§lt, keinesfalls immer ohne Mehraufwand ausgef√ºhrt werden kann, und gibt die folgenden Tipps: <br><br><ul><li>  Bei der Entwicklung von Bibliotheken sollten Sie grunds√§tzlich auf Ausnahmen verzichten. </li><li>  Wenn Sie weiterhin Ausnahmen ben√∂tigen, sollten Sie nach M√∂glichkeit Modifikatoren noexcept (und const) hinzuf√ºgen, damit der Compiler so weit wie m√∂glich optimieren kann. </li></ul><br>  Im Allgemeinen bekr√§ftigte der Redner die Auffassung, dass Ausnahmen am besten auf ein Minimum beschr√§nkt oder sogar aufgegeben werden. <br><br>  Die Berichtsfolien finden Sie unter: <a href="https://assets.ctfassets.net/oxjq45e8ilak/6Q09SPvX2Rsveiayc1VkcC/ce9e2b8eb22d6693eb4c3b06968bedc0/100693_477384438_Roman_Rusyayev_Isklyucheniya_C_cherez_prizmu_kompilyatornykh_optimizatsiy.pdf">[‚ÄûC ++ - Ausnahmen durch das Prisma der LLVM-Compileroptimierung‚Äú]</a> <br><br><h3>  Generatoren, Koroutinen und andere hirnabbauende S√º√üigkeiten, Adi Shavit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d20/0c4/4a6/d200c44a65058c3b50a29d0b551a9cc0.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">Pr√§sentationsfolie</a></i> <br><br>  Einer der vielen Berichte dieser Konferenz √ºber die Neuerungen von C ++ 20 wurde nicht nur durch seine farbenfrohe Pr√§sentation in Erinnerung gerufen, sondern auch durch die eindeutige Bezeichnung der Probleme mit der Verarbeitungslogik der Sammlung (f√ºr R√ºckrufschleife). <br><br>  Adi Shavit hebt Folgendes hervor: Derzeit verf√ºgbare Methoden durchlaufen die gesamte Sammlung und gew√§hren keinen Zugriff auf einen internen Zwischenzustand (oder geben bei R√ºckrufen, aber mit vielen unangenehmen Nebenwirkungen, wie der gleichen R√ºckruf-H√∂lle).  Es scheint, dass es Iteratoren gibt, aber bei ihnen ist nicht alles reibungslos: Es gibt keine gemeinsamen Einstiegs- und Ausstiegspunkte (Anfang ‚Üí Ende versus Anfang ‚Üí Ende usw.). Es ist unklar, wie oft wir √ºberhaupt iterieren werden.  Ab C ++ 20 sind diese Probleme behoben! <br><br>  Die erste Option: Bereiche.  Durch den Wrapper auf Iteratoren erhalten wir eine gemeinsame Schnittstelle f√ºr den Beginn und das Ende der Iteration sowie die M√∂glichkeit der Komposition.  All dies macht es einfach, vollwertige Datenverarbeitungs-Pipelines zu erstellen.  Aber nicht alles ist so reibungslos: Ein Teil der Berechnungslogik besteht in der Implementierung eines bestimmten Iterators, der den Code f√ºr die Wahrnehmung und das Debuggen erschweren kann. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/a7d/09d/f41a7d09d24a823a3397aa27a552f254.png"><br>  <i><a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">Pr√§sentationsfolie</a></i> <br><br>  In diesem Fall wurden in C ++ 20 Coroutinen hinzugef√ºgt (Funktionen, die sich √§hnlich wie Generatoren in Python verhalten): Die Ausf√ºhrung kann verz√∂gert werden, indem ein aktueller Wert zur√ºckgegeben wird, w√§hrend der Zwischenzustand beibehalten wird.  Auf diese Weise arbeiten wir nicht nur mit Daten, wie sie angezeigt werden, sondern kapseln auch die gesamte Logik in einer bestimmten Coroutine. <br><br>  Die Salbe hat jedoch ein Problem: Momentan werden sie nur teilweise von vorhandenen Compilern unterst√ºtzt, und sie werden auch nicht so genau implementiert, wie wir es uns w√ºnschen: Beispielsweise sollten Links und tempor√§re Objekte nicht in Coroutinen verwendet werden.  Au√üerdem gibt es einige Einschr√§nkungen f√ºr m√∂gliche Coroutinen. Constexpr-Funktionen, Konstruktoren / Destruktoren und auch main sind in dieser Liste nicht enthalten. <br><br>  Somit l√∂sen die Koroutinen einen wesentlichen Teil der Probleme mit der Einfachheit der Datenverarbeitungslogik, aber ihre gegenw√§rtigen Implementierungen erfordern eine Verfeinerung. <br><br>  Material: <br><br><ul><li>  Folien mit C ++ Russia - <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">["Generatoren, Koroutinen und andere gehirnentrollende S√º√üe"]</a> </li><li>  <a href="https://youtu.be/qYHDERleSL8">Videobericht von der CppCon 2019</a> </li></ul><br><h3>  C ++ Tricks von Yandex.Taxi, Anton Polukhin </h3><br>  In seiner beruflichen T√§tigkeit muss man manchmal nur Hilfsdinge implementieren: einen Wrapper zwischen der internen Schnittstelle und der API einer Bibliothek, Protokollierung oder Analyse.  In der Regel ist jedoch keine zus√§tzliche Optimierung erforderlich.  Aber was ist, wenn diese Komponenten in einigen der beliebtesten Dienste in Runet verwendet werden?  In einer solchen Situation m√ºssen Sie nur Terabyte pro Stunde an Protokollen verarbeiten!  Dann z√§hlt jede Millisekunde und deshalb muss man auf verschiedene Tricks zur√ºckgreifen - Anton Polukhin hat dar√ºber gesprochen. <br><br>  Das vielleicht interessanteste Beispiel war die Implementierung des Pimpl-Musters (Pointer-to-Implementation). <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;third_party/json.hpp&gt; //PROBLEMS! struct Value { Value() = default; Value(Value&amp;&amp; other) = default; Value&amp; operator=(Value&amp;&amp; other) = default; ~Value() = default; std::size_t Size() const { return data_.size(); } private: third_party::Json data_; };</span></span></span></span></code> </pre> <br>  In diesem Beispiel m√∂chten Sie zuerst die Header-Dateien externer Bibliotheken entfernen. Sie werden schneller kompiliert und k√∂nnen sich vor m√∂glichen Namenskonflikten und √§hnlichen Fehlern sch√ºtzen. <br><br>  Ok, #include in die .cpp-Datei verschoben: Sie ben√∂tigen die Forward-Deklaration der umschlossenen API sowie std :: unique_ptr.  Jetzt haben wir dynamische Zuweisungen und andere unangenehme Dinge, wie Daten, die √ºber einen Haufen verstreut sind, und reduzierte Garantien.  Bei alledem kann std :: aligned_storage helfen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... private: using JsonNative = third_party::Json; const JsonNative* Ptr() const noexcept; JsonNative* Ptr() noexcept; constexpr std::size_t kImplSize = 32; constexpr std::size_t kImplAlign = 8; std::aligned_storage_t&lt;kImplSize, kImplAlign&gt; data_; };</span></span></code> </pre> <br>  Das einzige Problem: Sie m√ºssen die Gr√∂√üe und Ausrichtung f√ºr jeden Wrapper angeben - wir erstellen unsere Pimpl-Vorlage mit den Parametern &lt;T, SizeT, AlignmentT&gt;, verwenden einige beliebige Werte und f√ºgen dem Destruktor eine √úberpr√ºfung hinzu, dass wir alles erraten haben: <br><br><pre> <code class="cpp hljs">~FastPimpl() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { validate&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt;(); Ptr()-&gt;~T(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualSize, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualAlignment&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Size == ActualSize, <span class="hljs-string"><span class="hljs-string">"Size and sizeof(T) mismatch"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Alignment == ActualAlignment, <span class="hljs-string"><span class="hljs-string">"Alignment and alignof(T) mismatch"</span></span> ); }</code> </pre> <br>  Da T bereits w√§hrend der Verarbeitung des Destruktors definiert wurde, wird dieser Code korrekt analysiert und zeigt in der Kompilierungsphase die erforderlichen Gr√∂√üen- und Ausrichtungswerte an, die in Form von Fehlern eingegeben werden m√ºssen.  Auf diese Weise wird auf Kosten eines zus√§tzlichen Kompilierungsbeginns die dynamische Zuordnung von umschlossenen Klassen aufgehoben, die API in einer CPP-Datei mit der Implementierung ausgeblendet und ein Entwurf erstellt, der f√ºr das Caching durch den Prozessor besser geeignet ist. <br><br>  Protokollierung und Analyse schienen weniger beeindruckend und werden daher in diesem Test nicht erw√§hnt. <br><br>  Die Berichtsfolien sind unter folgendem Link verf√ºgbar: <a href="https://assets.ctfassets.net/oxjq45e8ilak/4rkoaQV6ancsfvzYx1fOCF/087dda7d63101cc225d706d03d7c5075/100566_2093066332_Anton_Polukhin_C_tryuki_iz_Taksi.pdf">[‚ÄúC ++ Taxi Tricks‚Äù]</a> <br><br><h3>  Moderne Techniken, um Ihren Code trocken zu halten, Bj√∂rn Fahller </h3><br>  Bj√∂rn Fahller zeigt in diesem Vortrag verschiedene M√∂glichkeiten auf, mit Stilfehlern umzugehen, wie beispielsweise wiederholte bedingte Pr√ºfungen: <br><br><pre> <code class="cpp hljs">assert(a == IDLE || a == CONNECTED || a == DISCONNECTED);</code> </pre> <br>  Ist das bekannt  Mit mehreren leistungsstarken C ++ - Techniken, die in den letzten Standards verwendet wurden, k√∂nnen Sie dieselbe Funktionalit√§t ohne den geringsten Leistungsverlust ordnungsgem√§√ü implementieren.  Vergleichen Sie: <br><br><pre> <code class="cpp hljs">assert(a == any_of(IDLE, CONNECTED, DISCONNECTED));</code> </pre> <br>  Um eine unbegrenzte Anzahl von Schecks zu verarbeiten, werden Sie sofort aufgefordert, verschiedene Vorlagen und Falzausdr√ºcke zu verwenden.  Angenommen, wir m√∂chten die Gleichheit mehrerer Variablen mit dem Element enum'a state_type √ºberpr√ºfen.  Das erste, was mir in den Sinn kommt, ist, die Hilfsfunktion is_any_of zu schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> state_type { IDLE, CONNECTED, DISCONNECTED }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp; ... ts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((s == ts) || ...); }</code> </pre><br>  Ein solches Zwischenergebnis ist entt√§uschend.  Bisher wird der Code nicht lesbar: <br><br><pre> <code class="cpp hljs">assert(is_any_of(state, IDLE, DISCONNECTING, DISCONNECTED));</code> </pre> <br>  Nicht typisierte Vorlagenparameter tragen dazu bei, die Situation ein wenig zu verbessern.  Mit ihrer Hilfe √ºbertragen wir die aufgez√§hlten Aufz√§hlungselemente in die Liste der Vorlagenparameter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;state_type ... states&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == states) | ...); } assert(is_any_of&lt;IDLE, DISCONNECTING, DISCONNECTED&gt;(state));</code> </pre> <br>  Bei Verwendung von auto in einem nicht typischen Vorlagenparameter (C ++ 17) wird der Ansatz einfach auf Vergleiche nicht nur mit state_type-Elementen, sondern auch mit primitiven Typen verallgemeinert, die als nicht typisierte Vorlagenparameter verwendet werden k√∂nnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ... alternatives, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == alternatives) | ...); }</code> </pre> <br>  Durch diese inkrementellen Verbesserungen wird die gew√ºnschte Cursorsyntax f√ºr die √úberpr√ºfung erreicht: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any_of</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts ...&gt; { <span class="hljs-comment"><span class="hljs-comment">//      tuple        using std::tuple&lt;Ts ...&gt;::tuple;        template &lt;typename T&gt;        bool operator ==(const T&amp; t) const {                return std::apply(                        [&amp;t](const auto&amp; ... ts) {                                return ((ts == t) || ...);                        },                        static_cast&lt;const std::tuple&lt;Ts ...&gt;&amp;&gt;(*this));        } }; template &lt;class ... Ts&gt; any_of(Ts ...) -&gt; any_of&lt;Ts ... &gt;; assert(any_of(IDLE, DISCONNECTING, DISCONNECTED) == state);</span></span></code> </pre><br>  In diesem Beispiel dient der Ableitungsleitfaden dazu, die gew√ºnschten Vorlagenstrukturparameter an einen Compiler weiterzuleiten, der die Typen der Konstruktorargumente kennt. <br><br>  Interessanter.  Bj√∂rn lehrt, den resultierenden Code zus√§tzlich zu == f√ºr Vergleichsoperatoren und dann f√ºr beliebige Operationen zu verallgemeinern.  Zusammen mit dem Anwendungsfall werden Funktionen wie das Attribut no_unique_address (C ++ 20) und Vorlagenparameter in Lambda-Funktionen (C ++ 20) erl√§utert.  (Ja, jetzt ist die Lambda-Syntax noch einfacher zu merken - das sind vier aufeinanderfolgende Paare von Klammern aller Art.) Die endg√ºltige L√∂sung, die Funktionen als Konstruktorteile verwendet, erw√§rmt meine Seele wirklich, ganz zu schweigen vom Tupelausdruck in den besten Traditionen der Lambda-Rechnung. <br><br>  Vergessen Sie am Ende nicht, einen Glanz zu setzen: <br><br><ul><li>  Denken Sie daran, dass Lambdas constexpr kostenlos sind; </li><li>  F√ºgen Sie eine perfekte Weiterleitung hinzu und sehen Sie sich die h√§ssliche Syntax f√ºr das Parameterpaket in Lambda Closure an. </li><li>  Lassen Sie uns dem Compiler mehr Optionen f√ºr Optimierungen mit der Bedingung noexcept geben. </li><li>  Aufgrund der expliziten R√ºckgabewerte von Lambdas sorgen wir f√ºr eine deutlichere Fehlerausgabe in Vorlagen.  Dadurch wird der Compiler gezwungen, weitere √úberpr√ºfungen durchzuf√ºhren, bevor die Vorlagenfunktion tats√§chlich aufgerufen wird - in der Phase der Typ√ºberpr√ºfung. </li></ul><br>  Einzelheiten entnehmen Sie bitte den Vorlesungsunterlagen: <br><br><ul><li>  Berichtsfolien: <a href="https://assets.ctfassets.net/oxjq45e8ilak/7lP3ueTFEJnmdVjGGjrgHI/e30dfcbff0630fb63389f3f3e734a1a3/100644_2039674689_Bjrn_Fahller_Modern_techniques_for_keeping_your_code_dry.pdf">[Moderne Techniken, um Ihren Code trocken zu halten]</a> </li><li>  <a href="https://github.com/rollbear/dry-comparisons">Github-Quellcode</a> </li><li>  <a href="https://playfulprogramming.blogspot.com/2018/07/dry-multicomparisons.html">Blogartikel des Autors</a> </li></ul><br><h2>  Unsere Eindr√ºcke </h2><br>  Unsere erste Teilnahme an C ++ Russia wurde f√ºr seinen Reichtum in Erinnerung gerufen.  Es gab einen Eindruck von C ++ Russland als emotionales Ereignis, bei dem die Grenze zwischen Lernen und Live-Kommunikation fast nicht erkennbar ist.  Alles, von der Stimmung der Redner bis zu den Wettbewerben der Partner der Veranstaltung, ist f√∂rderlich f√ºr hitzige Diskussionen.  Der Inhalt der Konferenz, die aus Berichten besteht, deckt ein ziemlich breites Themenspektrum ab, einschlie√ülich C ++ - Innovationen, Beispielen aus der Praxis gro√üer Projekte und ideologischen architektonischen √úberlegungen.  Es w√§re jedoch unfair, die Aufmerksamkeit der sozialen Komponente der Veranstaltung zu entziehen, was dazu beitr√§gt, Sprachbarrieren nicht nur in Bezug auf C ++ zu √ºberwinden. <br><br>  Wir danken den Organisatoren der Konferenz f√ºr die M√∂glichkeit, an einer solchen Veranstaltung teilzunehmen! <br>  Den Beitrag der Organisatoren √ºber Vergangenheit, Gegenwart und Zukunft von C ++ Russia k√∂nnen Sie <a href="https://habr.com/ru/company/jugru/blog/480584/">auf dem JUG Ru-Blog sehen</a> . <br><br>  Vielen Dank f√ºrs Lesen und wir hoffen, dass sich unsere Nacherz√§hlung der Ereignisse als n√ºtzlich erwiesen hat! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481358/">https://habr.com/ru/post/de481358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481348/index.html">Pentest Active Directory. Teil 1</a></li>
<li><a href="../de481350/index.html">Wer arbeitet am Kosmodrom Plesetsk?</a></li>
<li><a href="../de481352/index.html">DBA: L√∂schen von Klons√§tzen aus einer Tabelle ohne PK</a></li>
<li><a href="../de481354/index.html">TelegramBot. Die Grundfunktionalit√§t. Fliegen getrennt, Schnitzel getrennt. (Teil 2)</a></li>
<li><a href="../de481356/index.html">Vielen Dank, 2019</a></li>
<li><a href="../de481360/index.html">Die Ergebnisse der Woche: Rambler und Twitch waren sich einig, in der Russischen F√∂deration wird die elektronische Arbeit eingef√ºhrt und Facebook wird ein eigenes Betriebssystem erstellen</a></li>
<li><a href="../de481362/index.html">SSL Zertifikat f√ºr Docker Web-App</a></li>
<li><a href="../de481364/index.html">Sensibles Zuhause ersetzt intelligentes Zuhause</a></li>
<li><a href="../de481366/index.html">RICE: Einfache Priorisierung f√ºr Produktmanager</a></li>
<li><a href="../de481368/index.html">Blindkameratest: iPhone, Pixel, Samsung und Huawei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>