<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò† üëâüèª üìÇ Plugin yang fantastis, vol. 2. Berlatih üë®‚Äçüî¨ üë©üèΩ‚Äçü§ù‚Äçüë®üèª üë±üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di sini Anda dapat membaca artikel pertama dengan teori plug-in engineering. 


 Dan pada bagian ini saya akan memberi tahu Anda masalah apa yang kami...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plugin yang fantastis, vol. 2. Berlatih</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/463611/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat membaca artikel pertama dengan teori plug-in engineering. </p><br><p>  Dan pada bagian ini saya akan memberi tahu Anda masalah apa yang kami temui selama pembuatan plugin dan bagaimana kami mencoba menyelesaikannya. <br><img src="https://habrastorage.org/webt/db/cn/c-/dbcnc-m5gfz68a0hpvnt2qjdcgw.png" alt="gambar"></p><a name="habracut"></a><br><h1 id="o-chem-budu-govorit">  Apa yang akan saya bicarakan? </h1><br><ul><li>  Bagian praktis <br><ul><li>  UI Multipage </li><li>  DI dalam plugin </li><li>  Pembuatan kode </li><li>  Modifikasi kode </li></ul></li><li>  Apa yang harus dilakukan selanjutnya? <br><ul><li>  Kiat </li><li>  Faq </li></ul></li></ul><br><h2 id="mnogostranichnyy-ui">  UI Multipage </h2><br><p>  Hal pertama yang perlu kami lakukan adalah membuat UI multi-halaman.  Kami membuat formulir kompleks pertama dengan sekelompok tanda centang, bidang input.  Beberapa saat kemudian, kami memutuskan untuk menambahkan kemampuan untuk memilih daftar modul yang dapat disambungkan pengguna ke modul baru.  Dan kami juga ingin memilih modul aplikasi yang kami rencanakan untuk menghubungkan modul yang dibuat. </p><br><p>  Memiliki begitu banyak kontrol pada satu formulir sangat tidak nyaman, sehingga mereka membuat tiga halaman terpisah, tiga pemotong cookie terpisah.  Singkatnya, dialog Wizard. </p><br><p><img src="https://habrastorage.org/webt/hd/jw/wf/hdjwwfojlb6w7gj_sacdswi802g.png" alt="gambar"></p><br><p>  Tetapi karena membuat multi-halaman UI dalam plugin sangat menyakitkan, saya ingin menemukan sesuatu yang siap.  Dan di perut IDEA, kami menemukan kelas yang disebut <em>WizardDialog</em> . </p><br><p><img src="https://habrastorage.org/webt/tl/gr/6z/tlgr6ztp3yro6-yyyqyhjsd55ky.png" alt="gambar"></p><br><p>  Ini adalah kelas pembungkus di atas dialog reguler, yang secara mandiri memantau kemajuan pengguna dalam panduan, dan menunjukkan tombol yang diperlukan (Sebelumnya, Berikutnya, Selesai, dll.).  Sebuah <em>WizardModel</em> khusus dilampirkan ke <em>WizardDialog</em> , di mana WizardSteps ditambahkan.  Setiap <em>WizardStep</em> adalah formulir terpisah. </p><br><p>  Dalam bentuknya yang paling sederhana, implementasi dialog adalah sebagai berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Wisaya dialog</b> <div class="spoiler_text"><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWizardDialog</span></span></span></span>( model: MyWizardModel, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onFinishButtonClickedListener: (MyWizardModel) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ): WizardDialog&lt;MyWizardModel&gt;(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, model) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onWizardGoalAchieved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onWizardGoalAchieved() onFinishButtonClickedListener.invoke(myModel) } }</code> </pre> </div></div><br><p>  <em>Kami akan mewarisi</em> dari kelas <em>WizardDialog</em> , parameterisasi dengan kelas <em>WizardModel</em> kami.  Kelas ini memiliki panggilan balik khusus ( <em>onWizardGoalAchanted</em> ), yang memberi tahu kami bahwa pengguna melewati wizard hingga akhir dan mengklik tombol "Selesai". <br>  Penting untuk dicatat bahwa dari dalam kelas ini ada peluang untuk hanya menjangkau <em>Model Wizard</em> .  Ini berarti bahwa semua data yang akan dikumpulkan pengguna selama berlalunya wizard, Anda harus menambahkan di <em>WizardModel</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Model pemandu</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWizardModel</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WizardModel</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"Title for my wizard"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(MyWizardStep1()) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(MyWizardStep2()) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(MyWizardStep3()) } }</code> </pre> </div></div><br><p>  Modelnya adalah sebagai berikut: kita mewarisi dari kelas <em>WizardModel</em> dan menggunakan metode <em>tambahkan</em> <em>bawaan</em> <em>menambahkan</em> <em>WizardSteps</em> terpisah ke dialog. </p><br><div class="spoiler">  <b class="spoiler_title">Langkah Wizard</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWizardStep1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WizardStep</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyWizardModel</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentPanel: JPanel <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">WizardNavigationState</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: JComponent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentPanel } }</code> </pre> </div></div><br><p>  <em>WizardSteps</em> juga sederhana: kami mewarisi dari kelas <em>WizardStep</em> , <em>mengukurnya</em> dengan kelas model kami, dan, yang paling penting, mendefinisikan kembali metode persiapan, yang mengembalikan komponen root dari formulir masa depan Anda. </p><br><p>  Secara sederhana, ini benar-benar terlihat seperti ini.  Tetapi di dunia nyata, kemungkinan besar bentuk Anda akan menyerupai sesuatu seperti ini: </p><br><p><img src="https://habrastorage.org/webt/as/6d/mc/as6dmcznqssdt7zwhdz7ndebuv8.png" alt="gambar"></p><br><p>  Di sini Anda dapat mengingat saat-saat ketika kita di dunia Android belum tahu apa itu Arsitektur Bersih, MVP dan menulis semua kode dalam satu Kegiatan.  Ada bidang baru untuk pertempuran arsitektur, dan jika Anda ingin bingung, Anda dapat menerapkan arsitektur Anda sendiri untuk plugin. </p><br><h3 id="vyvod">  Kesimpulan </h3><br><p>  Jika Anda memerlukan UI multi-halaman, gunakan <em>WizardDialog</em> - itu akan lebih mudah. </p><br><p>  Kami beralih ke topik berikutnya - DI dalam plugin. </p><br><h2 id="di-v-plaginah">  DI dalam plugin </h2><br><p>  Mengapa Injeksi Ketergantungan di dalam plugin diperlukan? <br>  Alasan pertama adalah organisasi arsitektur di dalam plugin. </p><br><p>  Tampaknya, mengapa umumnya mengamati beberapa jenis arsitektur di dalam plugin?  Plug-in adalah hal yang bermanfaat, begitu saya menulisnya, dan itu saja, saya lupa. <br>  Ya, tapi tidak. <br>  Ketika plugin Anda tumbuh, ketika Anda menulis banyak kode, pertanyaan tentang kode terstruktur muncul dengan sendirinya.  Di sini DI mungkin berguna. </p><br><p>  Alasan kedua, yang lebih penting - dengan bantuan DI Anda dapat menjangkau komponen yang ditulis oleh pengembang plugin lain.  Ini bisa berupa bus acara, penebang dan banyak lagi. </p><br><p>  Terlepas dari kenyataan bahwa Anda bebas menggunakan kerangka kerja DI (Spring, Dagger, dll), di dalam IntelliJ IDEA ada kerangka kerja DI Anda sendiri, yang didasarkan pada tiga tingkat abstraksi pertama, yang sudah saya bicarakan: <em>Aplikasi</em> , <em>Proyek</em> dan <em>Modul</em> . </p><br><p><img src="https://habrastorage.org/webt/ix/kh/dk/ixkhdkerqkc0sapkdvgj5qsg_44.png" alt="gambar"></p><br><p>  Masing-masing level ini memiliki abstraksi sendiri yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Komponen</em></a> .  Komponen level yang diperlukan dibuat per instance dari objek level ini.  Jadi <em>ApplicationComponent</em> dibuat sekali untuk setiap instance dari kelas <em>Application</em> , mirip dengan <em>ProjectComponent</em> untuk instance <em>Project</em> , dan seterusnya. </p><br><p>  Apa yang perlu dilakukan untuk menggunakan kerangka DI? </p><br><p>  Pertama, buat kelas yang mengimplementasikan salah satu komponen antarmuka yang diperlukan - misalnya, kelas yang mengimplementasikan <em>ApplicationComponent</em> , atau <em>ProjectComponent</em> , atau <em>ModuleComponent</em> .  Pada saat yang sama, kami memiliki kesempatan untuk menyuntikkan objek tingkat yang antarmuka kami laksanakan.  Itu, misalnya, di <em>ProjectComponent</em> Anda bisa menyuntikkan objek kelas <em>Project</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Membuat kelas komponen</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAppComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> application: Application, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anotherApplicationComponent: AnotherAppComponent ): ApplicationComponent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyProjectComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project: Project, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anotherProjectComponent: AnotherProjectComponent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myAppComponent: MyAppComponent ): ProjectComponent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModuleComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> module: Module, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anotherModuleComponent: AnotherModuleComponent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myProjectComponent: MyProjectComponent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myAppComponent: MyAppComponent ): ModuleComponent</code> </pre> </div></div><br><p>  Kedua, dimungkinkan untuk menyuntikkan komponen lain pada level yang sama atau lebih tinggi.  Misalnya, di <em>ProjectComponent</em> Anda dapat menyuntikkan <em>ProjectComponent</em> atau <em>ApplicationComponent lainnya</em> .  Di sinilah Anda dapat mengakses instance komponen "alien". </p><br><p>  Pada saat yang sama, IDEA menjamin bahwa seluruh grafik dependensi akan dirakit dengan benar, semua objek akan dibuat dalam urutan yang benar dan diinisialisasi dengan benar. </p><br><p>  Hal selanjutnya yang harus dilakukan adalah mendaftarkan komponen dalam file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>plugin.xml</em></a> .  Segera setelah Anda mengimplementasikan salah satu antarmuka Komponen (misalnya, <em>ApplicationComponent</em> ), IDEA akan segera menawarkan untuk mendaftarkan komponen Anda di plugin.xml. </p><br><div class="spoiler">  <b class="spoiler_title">Daftarkan komponen di plugin.xml</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project-components</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">component</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface-class</span></span></span><span class="hljs-tag">&gt;</span></span> com.experiment.MyProjectComponent <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface-class</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">implementation-class</span></span></span><span class="hljs-tag">&gt;</span></span> com.experiments.MyProjectComponentImpl <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">implementation-class</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">component</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project-components</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p>  Bagaimana ini dilakukan?  Tag <em>&lt;project-component&gt; khusus</em> muncul ( <em>&lt;aplikasi-komponen&gt;</em> , <em>&lt;module-komponen&gt;</em> - tergantung level).  Ada sebuah tag di dalamnya <em>, ia memiliki dua tag lagi: <em>&lt;interface-class&gt;</em> , di mana nama antarmuka komponen Anda ditunjukkan, dan <em>&lt;implementation-class&gt;</em> , di mana kelas implementasi diindikasikan.</em>  <em>Satu dan kelas yang sama dapat berupa antarmuka komponen atau implementasinya, sehingga Anda dapat melakukannya dengan satu <em>tag &lt;implementation-class&gt;</em> .</em> <br></p><p>  Hal terakhir yang harus dilakukan adalah mendapatkan komponen dari objek yang sesuai, yaitu, kita mendapatkan <em>ApplicationComponent</em> dari instance <em>Application</em> , <em>ProjectComponent</em> dari <em>Project</em> , dll. </p><br><div class="spoiler">  <b class="spoiler_title">Dapatkan komponennya</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myAppComponent = application.getComponent(MyAppComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myProjectComponent</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">project</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getComponent</span></span></span></span>(MyProjectComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myModuleComponent</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getComponent</span></span></span></span>(MyModuleComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre> </div></div><br><h3 id="vyvody">  Kesimpulan </h3><br><ol><li>  Ada kerangka kerja DI di dalam IDEA - tidak perlu menyeret apa pun pada Anda sendiri: baik Dagger maupun Spring.  Meskipun tentu saja bisa. </li><li>  Dengan DI ini, Anda dapat menjangkau komponen yang sudah jadi, dan ini adalah jus itu sendiri. </li></ol><br><p>  Mari kita beralih ke tugas ketiga - pembuatan kode. </p><br><h2 id="generaciya-koda">  Pembuatan kode </h2><br><p>  Ingat, dalam daftar periksa kami memiliki tugas menghasilkan banyak file?  Setiap kali kita membuat modul baru, kita membuat banyak file: interaksor, penyaji, fragmen.  Saat membuat modul baru, komponen-komponen ini sangat mirip satu sama lain, dan saya ingin belajar cara membuat kerangka kerja ini secara otomatis. </p><br><h3 id="shablony">  Pola </h3><br><p>  Apa cara termudah untuk menghasilkan satu ton kode serupa?  Gunakan pola.  Pertama, Anda perlu melihat templat Anda dan memahami persyaratan apa yang diajukan untuk pembuat kode. </p><br><div class="spoiler">  <b class="spoiler_title">Sepotong templat file build.gradle</b> <div class="spoiler_text"><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.library'</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isKotlinProject) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android'</span></span> apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isModuleWithUI) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android-extensions'</span></span> }&gt; }&gt; ... android { ... &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isMoxyEnabled) { kapt { arguments { arg(<span class="hljs-string"><span class="hljs-string">"moxyReflectorPackage"</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;include var="packageName"&gt;'</span></span>) } } }&gt; ... } ... dependencies { <span class="hljs-function"><span class="hljs-function">compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':common'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':core-utils'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(moduleName in enabledModules)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'&lt;include var="moduleName"&gt;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }&gt; ... }</span></span></code> </pre> </div></div><br><p>  Pertama: kami ingin dapat menggunakan kondisi di dalam pola ini.  Saya memberi contoh: jika plugin entah bagaimana terhubung dengan UI, kami ingin menghubungkan Gradle-plugin khusus <em>kotlin-android-extensions</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Kondisi di dalam templat</b> <div class="spoiler_text"><pre> <code class="java hljs">&lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isKotlinProject) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android'</span></span> apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isModuleWithUI) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android-extensions'</span></span> }&gt; }&gt;</code> </pre> </div></div><br><p>  Hal kedua yang kita inginkan adalah kemampuan untuk menggunakan variabel di dalam template ini.  Misalnya, ketika kami mengonfigurasi kapt untuk Moxy, kami ingin menyisipkan nama paket sebagai argumen ke prosesor anotasi. </p><br><div class="spoiler">  <b class="spoiler_title">Ganti nilai variabel di dalam templat</b> <div class="spoiler_text"><pre> <code class="java hljs">kapt { arguments { arg(<span class="hljs-string"><span class="hljs-string">"moxyReflectorPackage"</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;include var="packageName"&gt;'</span></span>) } }</code> </pre> </div></div><br><p>  Hal lain yang kita butuhkan adalah kemampuan untuk menangani loop di dalam template.  Ingat formulir tempat kami memilih daftar modul yang ingin kami sambungkan ke modul baru yang sedang dibuat?  Kami ingin mengelilingi mereka dalam satu lingkaran dan menambahkan baris yang sama. </p><br><div class="spoiler">  <b class="spoiler_title">Gunakan loop dalam template.</b> <div class="spoiler_text"><pre> <code class="java hljs">&lt;<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (moduleName in enabledModules) { <span class="hljs-function"><span class="hljs-function">compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'&lt;include var="moduleName"&gt;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }&gt;</span></span></code> </pre> </div></div><br><p>  Jadi, kami mengajukan tiga syarat untuk pembuat kode: </p><br><ul><li>  Kami ingin menggunakan kondisinya </li><li>  Kemampuan untuk mengganti nilai variabel </li><li>  Kita membutuhkan loop dalam pola </li></ul><br><h3 id="generatory-koda">  Pembuat kode </h3><br><p>  Apa saja opsi untuk mengimplementasikan pembuat kode?  Anda dapat, misalnya, menulis pembuat kode Anda sendiri.  Misalnya, orang-orang dari Uber melakukan ini: mereka menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plug-in</a> mereka sendiri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk menghasilkan riblets</a> (yang disebut unit arsitektur).  Mereka datang dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa templat mereka sendiri</a> , di mana mereka hanya menggunakan kemampuan untuk memasukkan variabel.  Mereka membawa kondisi ke <a href="">tingkat generator</a> .  Tetapi kami berpikir bahwa kami tidak akan melakukan itu. </p><br><p>  Opsi kedua adalah menggunakan kelas utilitas FileTemplateManager yang dibangun di IDEA, tetapi saya tidak akan merekomendasikan melakukan ini.  Karena dia memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Velocity</a> sebagai mesin, yang memiliki beberapa masalah dengan meneruskan objek Java ke template.  Selain itu, <em>FileTemplateManager</em> tidak dapat menghasilkan file selain Java atau XML dari kotak.  Dan kami perlu membuat file Groovy, Kotlin, Proguard, dan jenis file lainnya. </p><br><p>  Opsi ketiga adalah ... <em>FreeMarker</em> .  Jika Anda memiliki template <em>FreeMarker yang sudah jadi</em> , jangan buru-buru membuangnya - mereka dapat berguna bagi Anda di dalam plugin. </p><br><p>  Apa yang perlu dilakukan, apa yang harus digunakan <em>FreeMarker</em> di dalam plugin?  Pertama, tambahkan templat file.  Anda dapat membuat folder <em>/ templat</em> di dalam folder <em>/ resources</em> dan menambahkan semua templat kami di sana untuk semua file - presenter, fragmen, dll. </p><br><p><img src="https://habrastorage.org/webt/gk/ww/fe/gkwwfelyl443hdze6vd6a99ecmw.png" alt="gambar"></p><br><p>  Setelah itu, Anda perlu menambahkan ketergantungan pada perpustakaan FreeMarker.  Karena plugin menggunakan Gradle, menambahkan dependensi sangatlah mudah. </p><br><div class="spoiler">  <b class="spoiler_title">Tambahkan ketergantungan pada perpustakaan FreeMarker</b> <div class="spoiler_text"><pre> <code class="java hljs">dependencies { ... compile <span class="hljs-string"><span class="hljs-string">'org.freemarker:freemarker:2.3.28'</span></span> }</code> </pre> </div></div><br><p>  Setelah itu, konfigurasikan FreeMarker di dalam plugin kami.  Saya menyarankan Anda untuk hanya menyalin konfigurasi ini di sini - itu disiksa, diderita, salin, dan semuanya berfungsi. </p><br><div class="spoiler">  <b class="spoiler_title">Konfigurasi FreeMarker</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplatesFactory</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project: Project) : ProjectComponent { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> freeMarkerConfig <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { Configuration(Configuration.VERSION_2_3_28).apply { setClassForTemplateLoading( TemplatesFactory::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">"/templates" ) defaultEncoding = Charsets.UTF_8.name</span></span></span></span>() templateExceptionHandler = TemplateExceptionHandler.RETHROW_HANDLER logTemplateExceptions = <span class="hljs-literal"><span class="hljs-literal">false</span></span> wrapUncheckedExceptions = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ...</code> </pre> </div></div><br><p>  Saatnya membuat file menggunakan <em>FreeMarker</em> .  Untuk melakukan ini, kita mendapatkan templat dari konfigurasi berdasarkan namanya dan menggunakan <em>FileWriter</em> biasa membuat file dengan teks yang diinginkan langsung pada disk. </p><br><div class="spoiler">  <b class="spoiler_title">Membuat file melalui FileWriter</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplatesFactory</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project: Project) : ProjectComponent { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pathToFile: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, templateFileName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt; )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> template = freeMarkerConfig.getTemplate(templateFileName) FileWriter(pathToFile, <span class="hljs-literal"><span class="hljs-literal">false</span></span>).use { writer -&gt; template.process(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, writer) } } }</code> </pre> </div></div><br><p>  Dan tugas itu tampaknya diselesaikan, tetapi tidak.  Pada bagian teoretis, saya menyebutkan bahwa seluruh IDEA diserap dengan struktur PSI, dan ini harus diperhitungkan.  Jika Anda membuat file yang melewati struktur PSI (misalnya, melalui FileWriter), maka IDEA tidak akan mengerti bahwa Anda membuat sesuatu dan tidak akan menampilkan file di pohon proyek.  Kami menunggu sekitar tujuh menit sebelum IDEA diindeks dan melihat file yang dibuat. </p><br><p>  Kesimpulan - lakukan dengan benar, buat file, dengan mempertimbangkan struktur PSI. </p><br><h3 id="sozdaem-psi-strukturu-dlya-faylov">  Buat struktur PSI untuk file </h3><br><p>  Untuk memulai, <a href="">mari kita lihat</a> struktur folder menggunakan <a href="">PsiDirectory</a> .  Direktori awal proyek dapat diperoleh dengan menggunakan fungsi ekstensi <em>guessProjectDir</em> dan <em>toPsiDirectory</em> : </p><br><div class="spoiler">  <b class="spoiler_title">Dapatkan Proyek PsiDirectory</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> projectPsiDirectory = project.guessProjectDir()?.toPsiDirectory(project)</code> </pre> </div></div><br><p>  Direktori selanjutnya dapat ditemukan menggunakan metode kelas <em>PsiDirectory</em> <em>findSubdirectory</em> , atau dibuat menggunakan metode <em>createSubdirectory</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Temukan dan buat PsiDirectory</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coreModuleDir = projectPsiDirectory.findSubdirectory(<span class="hljs-string"><span class="hljs-string">"core"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newModulePsiDir = coreModuleDir.createSubdirectory(config.mainParams.moduleName)</code> </pre> </div></div><br><p>  Saya juga menyarankan Anda membuat <em>Peta</em> dari mana Anda bisa mendapatkan semua struktur folder <em>PsiDirectory</em> menggunakan kunci string, dan kemudian menambahkan file yang dibuat ke salah satu folder ini. </p><br><div class="spoiler">  <b class="spoiler_title">Buat peta struktur folder</b> <div class="spoiler_text"><p>  return mutableMapOf &lt;String, PsiDirectory?&gt; (). apply { <br>  ini ["root"] = modulePsiDir <br>  this ["src"] = modulePsiDir.createSubdirectory ("src") <br>  this ["main"] = this ["src"]?. createSubdirectory ("main") <br>  this ["java"] = this ["main"]?. createSubdirectory ("java") <br>  this ["res"] = this ["main"]? createSubdirectory ("res") </p><br><pre> <code class="plaintext hljs">//   PsiDirectory   package name: // ru.hh.feature_worknear ‚Üí ru / hh / feature_worknear createPackageNameFolder(config) // data this["data"] = this["package"]?.createSubdirectory("data") // ...</code> </pre> <br><p>  } </p></div></div><br><p>  Folder dibuat.  Kami akan membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PsiFiles</a> menggunakan <a href="">PsiFileFactory</a> .  Kelas ini memiliki metode khusus yang disebut <em>createFileFromText</em> .  Metode menerima tiga parameter sebagai input: nama (String fileName), teks (String text) dan ketik (FileType fileType) dari file output.  Dua dari tiga parameter jelas di mana mendapatkannya: kita tahu namanya sendiri, kita mendapatkan teks dari FreeMarker.  Dan dari mana mendapatkan <em>FileType</em> ?  Dan tentang apa semua ini? </p><br><h3 id="filetype">  Jenis file </h3><br><p>  <a href=""><em>FileType</em></a> adalah kelas khusus yang menunjukkan jenis file.  Hanya dua FileType yang tersedia bagi kita dari "kotak": JavaFileType dan XmlFileType, masing-masing untuk file Java dan file XML.  Tetapi muncul pertanyaan: di mana mendapatkan jenis untuk file <em>build.gradle</em> , untuk file <em>Kotlin</em> , untuk <em>Proguard</em> , untuk <em>.gitignore</em> , akhirnya?! </p><br><p>  Pertama, sebagian besar <em>FileType</em> ini dapat diambil dari plugin lain yang sudah ditulis oleh seseorang.  GroovyFileType dapat diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin Groovy</a> , KotlinFileType dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin Kotlin</a> , Proguard dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin Android</a> . </p><br><p>  Bagaimana kita menambahkan ketergantungan plugin lain ke plugin kita?  Kami menggunakan <em>gradle-intellij-plugin</em> .  Ia menambahkan blok intellij khusus ke file build.gradle dari plugin, di dalamnya terdapat properti khusus - <em>plugin</em> .  Di properti ini, Anda dapat mencantumkan daftar pengidentifikasi plugin yang ingin kami andalkan. </p><br><div class="spoiler">  <b class="spoiler_title">Tambahkan dependensi pada plugin lain</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle  intellij { ‚Ä¶ plugins = ['android', 'Groovy', 'kotlin'] }</span></span></code> </pre> </div></div><br><p>  Kami mengambil kunci dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori plugin JetBrains</a> resmi.  Untuk plugin yang dibangun di IDEA (yaitu Groovy, Kotlin, dan Android), nama folder plugin di dalam IDEA sudah cukup.  Untuk selebihnya, Anda perlu pergi ke halaman plugin tertentu di repositori plugin JetBrains resmi, properti <em>XML ID Plugin</em> akan ditunjukkan di sana, serta versi (misalnya, di sini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman dari plugin Docker</a> ).  Baca lebih lanjut tentang menghubungkan plugin lain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> . </p><br><p>  Kedua, Anda perlu menambahkan deskripsi ketergantungan ke file <em>plugin.xml</em> .  Ini dilakukan menggunakan tag <em>.</em> <br></p><div class="spoiler">  <b class="spoiler_title">Kami menghubungkan plugin di plugin.xml</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.jetbrains.android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.jetbrains.kotlin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.intellij.groovy<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p>  Setelah kami menyinkronkan proyek, kami akan memperketat dependensi dari plugin lain, dan kami akan dapat menggunakannya. </p><br><p>  Tetapi bagaimana jika kita tidak ingin bergantung pada plugin lain?  Dalam hal ini, kita dapat membuat tulisan rintisan untuk jenis file yang kita butuhkan.  Untuk melakukan ini, pertama buat kelas yang akan mewarisi dari kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Bahasa</em></a> .  Pengidentifikasi unik bahasa pemrograman kami akan diteruskan ke kelas ini (dalam kasus kami - <strong>"ru.hh.plugins.Ignore"</strong> ). </p><br><div class="spoiler">  <b class="spoiler_title">Buat bahasa untuk file GitIgnore</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IgnoreLanguage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>() : Language(<span class="hljs-string"><span class="hljs-string">"ru.hh.plugins.Ignore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ignore"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), InjectableLanguage { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> INSTANCE = IgnoreLanguage() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDisplayName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Ignore() (</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">)"</span></span> } }</code> </pre> </div></div><br><p>  Ada fitur di sini: beberapa pengembang menambahkan garis non-unik sebagai pengidentifikasi.  Karena itu, integrasi plugin Anda dengan plugin lain mungkin rusak.  Kami hebat, kami memiliki garis yang unik. </p><br><p>  Hal selanjutnya yang harus dilakukan setelah kami membuat <em>Bahasa</em> adalah membuat <em>FileType</em> .  Kami mewarisi dari kelas <em>LanguageFileType</em> , menggunakan instance bahasa yang kami definisikan untuk menginisialisasi, menimpa beberapa metode yang sangat sederhana.  Selesai  Sekarang kita bisa menggunakan <em>FileType yang</em> baru dibuat. </p><br><div class="spoiler">  <b class="spoiler_title">Buat FileType Anda sendiri untuk .gitignore</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IgnoreFileType</span></span></span></span>(language: Language) : LanguageFileType(language) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> INSTANCE = IgnoreFileType(IgnoreLanguage.INSTANCE) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"gitignore file"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"gitignore files"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDefaultExtension</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"gitignore"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIcon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Icon? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre></div></div><br><h3 id="zavershaem-sozdanie-fayla">  Selesai membuat file </h3><br><p>  Setelah Anda menemukan semua <em>FileType yang</em> diperlukan, saya sarankan membuat wadah khusus yang disebut <em>TemplateData</em> - itu akan berisi semua data tentang templat dari mana Anda ingin membuat kode.  Ini akan berisi nama file template, nama file <em>output</em> yang Anda dapatkan setelah membuat kode, <em>FileType yang</em> diinginkan <em>,</em> dan akhirnya <em>PsiDirectory</em> , tempat Anda menambahkan file yang dibuat. </p><br><div class="spoiler">  <b class="spoiler_title">TemplateData</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateData</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> templateFileName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputFileName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputFileType: FileType, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputFilePsiDirectory: PsiDirectory? )</code> </pre> </div></div><br><p>  Kemudian kita kembali ke <em>FreeMarker</em> - kita mendapatkan file templat darinya, menggunakan <em>StringWriter</em> kita mendapatkan teks, di <em>PsiFileFactory kita</em> menghasilkan <em>PsiFile</em> dengan teks dan jenis yang diinginkan.  File yang dibuat ditambahkan ke direktori yang diinginkan. </p><br><div class="spoiler">  <b class="spoiler_title">Buat PsiFile di folder yang diinginkan</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">FileTemplateData</span></span></span></span><span class="hljs-function"><span class="hljs-params">, properties: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt;)</span></span></span></span>: PsiFile { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> template = freeMarkerConfig.getTemplate(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.templateFileName) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = StringWriter().use { writer -&gt; template.process(properties, writer) writer.buffer.toString() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> psiFileFactory.createFileFromText(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.outputFileName, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.outputFileType, text) }</code> </pre> </div></div><br><p>  Dengan demikian, struktur PSI diperhitungkan, dan IDEA, serta plugin lainnya, akan melihat apa yang telah kami lakukan.  Mungkin ada untung dari ini: misalnya, jika plugin untuk Git melihat bahwa Anda telah menambahkan file baru, itu akan secara otomatis menampilkan kotak dialog yang menanyakan apakah Anda ingin menambahkan file-file ini ke Git? </p><br><h3 id="vyvody-pro-generaciyu-koda">  Kesimpulan Pembuatan Kode </h3><br><ul><li>  File teks dapat dihasilkan oleh FreeMarker.  Sangat nyaman </li><li>  Saat membuat file, Anda perlu mempertimbangkan struktur PSI, jika tidak semuanya akan salah. </li><li>  Jika Anda ingin membuat file menggunakan PsiFileFactory, Anda harus menemukan FileType di suatu tempat. </li></ul><br><p>  Nah, sekarang kita beralih ke bagian terakhir, bagian praktis paling enak - ini adalah modifikasi kodenya. </p><br><h2 id="modifikaciya-koda">  Modifikasi kode </h2><br><p>  Sebenarnya, membuat plugin hanya untuk menghasilkan kode adalah omong kosong, karena Anda dapat menghasilkan kode dengan alat lain, dan <em>FreeMarker yang</em> sama.  Tapi yang tidak bisa dilakukan <em>FreeMarker</em> adalah memodifikasi kodenya. </p><br><p>  Daftar periksa kami memiliki beberapa tugas yang berkaitan dengan memodifikasi kode, mari kita mulai dengan yang paling sederhana - memodifikasi file <em>settings.gradle</em> . </p><br><h3 id="modifikaciya-settingsgradle">  Pengaturan modifikasi .gradle </h3><br><p>  Biarkan saya mengingatkan Anda apa yang ingin kami lakukan: kami perlu menambahkan beberapa baris ke file ini yang akan menjelaskan jalur ke modul yang baru dibuat: </p><br><div class="spoiler">  <b class="spoiler_title">Deskripsi jalur ke modul</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// settings.gradle include ':analytics project(':analytics').projectDir = new File(settingsDir, 'core/framework-metrics/analytics) ... include ':feature-worknear' project(':feature-worknear').projectDir = new File(settingsDir, 'feature/feature-worknear')</span></span></code> </pre> </div></div><br><p>  Saya takut Anda sedikit sebelumnya bahwa Anda harus selalu mempertimbangkan struktur PSI ketika bekerja dengan file, jika tidak <del>  semuanya akan terbakar </del>  tidak akan bekerja  Bahkan, dalam tugas-tugas sederhana, seperti menambahkan beberapa baris ke akhir file, ini bisa dihilangkan.  Anda dapat menambahkan beberapa baris ke file menggunakan <em>java.io.File</em> biasa.  Untuk melakukan ini, kami menemukan path ke file, membuat contoh <em>java.io.File</em> , dan menggunakan fungsi <em>ekstensi</em> Kotlin menambahkan dua baris ke akhir file ini.  Anda dapat melakukan ini, IDEA akan melihat perubahan Anda. </p><br><div class="spoiler">  <b class="spoiler_title">Menambahkan baris ke file settings.gradle</b> <div class="spoiler_text"><p>  val projectBaseDirPath = project.basePath ?: return <br>  val settingsPathFile = projectBaseDirPath + "/settings.gradle" </p><br><p>  val settingsFile = File (settingsPathFile) </p><br><p>  settingsFile.appendText ("include ': $ moduleName'") <br>  settingsFile.appendText ( <br>  "project (': $ moduleName'). projectDir = File baru (settingsDir, '$ folderPath')" <br>  ) </p></div></div><br><p>  Yah, idealnya, tentu saja, lebih baik melalui struktur PSI - lebih dapat diandalkan. </p><br><h3 id="donastroyka-kapt-a-dlya-toothpick">  Kapt tala untuk Tusuk Gigi </h3><br><p>  Sekali lagi, saya mengingatkan Anda tentang masalah: di modul aplikasi ada file <em>build.gradle</em> , dan di dalamnya ada pengaturan prosesor penjelasan.  Dan kami ingin menambahkan paket modul yang kami buat ke tempat tertentu. </p><br><div class="spoiler">  <b class="spoiler_title">Kemana kemana?</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/jt/hv/1b/jthv1bxuiigvexnvwnrvzs41wh8.png" alt="gambar"></p></div></div><br><p>  Tujuan kami adalah untuk menemukan <em>PsiElement</em> tertentu, setelah itu kami berencana untuk menambahkan baris kami.  Pencarian elemen dimulai dengan pencarian <em>PsiFile</em> , yang menunjukkan file <em>build.gradle</em> dari modul aplikasi.  Dan untuk ini, Anda perlu menemukan modul di dalamnya kita akan mencari file. </p><br><div class="spoiler">  <b class="spoiler_title">Kami mencari modul dengan nama</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = ModuleManager.getInstance(project) .modules.toList() .first { it.name == <span class="hljs-string"><span class="hljs-string">"headhunter-applicant"</span></span> }</code> </pre> </div></div><br><p>  Selanjutnya, menggunakan kelas utilitas <em>FilenameIndex,</em> Anda dapat menemukan <em>PsiFile</em> dengan namanya, menentukan modul yang ditemukan sebagai area pencarian. </p><br><div class="spoiler">  <b class="spoiler_title">Mencari PsiFile dengan Nama</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> buildGradlePsiFile = FilenameIndex.getFilesByName( appModule.project, <span class="hljs-string"><span class="hljs-string">"build.gradle"</span></span>, appModule.moduleContentScope ).first()</code> </pre> </div></div><br><p>  Setelah kami menemukan PsiFile, kami dapat mulai mencari PsiElement.   ,      ‚Äì <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PSI Viewer</a> .     IDEA  ,    PSI-  . </p><br><p><img src="https://habrastorage.org/webt/sd/nl/ac/sdnlac9nrqcqqt14wtrhohr9pf8.png" alt="gambar"></p><br><p>    -  (, build.gradle)        ,      PSI-   . </p><br><p><img src="https://habrastorage.org/webt/gt/et/xo/gtetxo8_4hbk0gzzfty7p_zmawu.png" alt="gambar"></p><br><p>    ‚Äì   ,        <em>PsiFile</em> -. </p><br><p>    .   <em>PsiFile</em> .            . </p><br><div class="spoiler"> <b class="spoiler_title">  PsiElement</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> toothpickRegistryPsiElement = buildGradlePsiFile.originalFile .collectDescendantsOfType&lt;GrAssignmentExpression&gt;() .firstOrNull { it.text.startsWith(<span class="hljs-string"><span class="hljs-string">"arguments"</span></span>) } ?.lastChild ?.children?.firstOrNull { it.text.startsWith(<span class="hljs-string"><span class="hljs-string">"toothpick_registry_children_package_names"</span></span>) } ?.collectDescendantsOfType&lt;GrListOrMap&gt;() ?.first() ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> </div></div><br><p><del>  ?.. </del>   ?          PSI-.        <em>GrAssignmentExpression</em> ,   ,    <em>arguments = [ ‚Ä¶ ]</em> .      ,      <em>toothpick_registry_children_package_names = [...]</em> ,       Groovy-. </p><br><p>    <em>PsiElement</em> ,   .            .      . </p><br><p>     PSI- ,       <em>PsiElementFactory</em>   ,    .  Java-?    Java-.   Groovy?  <em>GroovyPsiElementFactory</em> .  Dan sebagainya. </p><br><p>  <em>PsiElementFactory</em>       .       Groovy  Kotlin ,        . </p><br><div class="spoiler"> <b class="spoiler_title"> PsiElement  package name</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> factory = GroovyPsiElementFactory.getInstance(buildGradlePsiFile.project) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> packageName = config.mainParams.packageName <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newArgumentItem = factory.createStringLiteralForReference(packageName)</code> </pre> </div></div><br><p>         <em>PsiElement</em> . </p><br><div class="spoiler"> <b class="spoiler_title">   Map-</b> <div class="spoiler_text"><pre> <code class="kotlin hljs">targetPsiElement.add(newArgumentItem)</code> </pre> </div></div><br><h3 id="donastroyka-kapt-a-dlya-moxy-v-application-module">  kapt-  Moxy  application  </h3><br><p>    -,    , ‚Äì  kapt-  Moxy  application .  :          <em>@RegisterMoxyReflectorPackages</em> . </p><br><div class="spoiler"> <b class="spoiler_title">-?</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/us/17/in/us17inlvgteb4k9pmegkurtl7y8.png" alt="gambar"></p></div></div><br><p>         ,  :  <em>PsiFile</em> ,  <em>PsiElement</em> ,  ‚Ä¶      ,         <em>PsiElement</em> -. </p><br><p>     :  ,    <em>@RegisterMoxyReflectorPackages</em> ,       <em>value</em>  ,          . </p><br><p>    ,       . ,     <em>PsiManager</em> ,   <em>PsiClass</em>  . </p><br><div class="spoiler"> <b class="spoiler_title"> PsiClass  @RegisterMoxyReflectorPackages</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = ModuleManager.getInstance(project) .modules.toList() .first { it.name == <span class="hljs-string"><span class="hljs-string">"headhunter-applicant"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> psiManager = PsiManager.getInstance(appModule.project) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> annotationPsiClass = ClassUtil.findPsiClass( psiManager, <span class="hljs-string"><span class="hljs-string">"com.arellomobile.mvp.RegisterMoxyReflectorPackages"</span></span> ) ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> </div></div><br><p>     <em>AnnotatedMembersSearch</em>   ,      . </p><br><div class="spoiler"> <b class="spoiler_title"> ,  </b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> annotatedPsiClass = AnnotatedMembersSearch.search( annotationPsiClass, appModule.moduleContentScope ).findAll() ?.firstOrNull() ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> </div></div><br><p>  ,  <em>PsiElement</em>  ,        value.     ,      . </p><br><div class="spoiler"> <b class="spoiler_title">      </b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> annotationPsiElement = (annotatedPsiClass .annotations .first() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> KtLightAnnotationForSourceEntry ).kotlinOrigin <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> packagesPsiElements = annotationPsiElement .collectDescendantsOfType&lt;KtValueArgumentList&gt;() .first() .collectDescendantsOfType&lt;KtValueArgument&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updatedPackagesList = packagesPsiElements .mapTo(mutableListOf()) { it.text } .apply { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> += <span class="hljs-string"><span class="hljs-string">"\"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${config.packageName}</span></span></span><span class="hljs-string">\""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newAnnotationValue = updatedPackagesList.joinToString(separator = <span class="hljs-string"><span class="hljs-string">",\n"</span></span>)</code> </pre> </div></div><br><p>   <em>KtPsiFactory</em>   <em>PsiElement</em> ‚Äì          . </p><br><div class="spoiler"> <b class="spoiler_title">      </b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kotlinPsiFactory = KtPsiFactory(project) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newAnnotationPsiElement = kotlinPsiFactory.createAnnotationEntry( <span class="hljs-string"><span class="hljs-string">"@RegisterMoxyReflectorPackages(\n</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$newAnnotationValue</span></span></span><span class="hljs-string">\n)"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> replaced = annotationPsiElement.replace(newAnnotationPsiElement)</code> </pre> </div></div><br><p>  . </p><br><p>     ?    code style.  ,      IDEA    : CodeStyleManager. </p><br><div class="spoiler"> <b class="spoiler_title"> code style</b> <div class="spoiler_text"><pre> <code class="kotlin hljs">CodeStyleManager.getInstance(module.project).reformat(replacedElement)</code> </pre> </div></div><br><p>    -  ,     . </p><br><h3 id="vyvody-1">  Kesimpulan </h3><br><ul><li>     ,      PSI-,      . </li><li> ,  PSI     ,    ,    PsiElement-. </li></ul><br><h1 id="chto-delat-dalshe">   ? </h1><br><p>   . </p><br><ul><li>      ‚Äì    ,       . </li><li>       .       .   :            . </li><li>     ?      .  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   IDEA</a>   ,   .       ,        . ‚Äî   -  ,    GitHub  .  ,    ,  . </li><li>    -   ‚Äì    IntelliJ IDEA   .  ,   <em>Util</em>  <em>Manager</em> ,  ,    ,    . </li><li>   :     .  ,  <em>runIde</em> ,     IDEA,   .   ,           hh.ru,       . </li></ul><br><p>  Itu saja. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,  ,   ‚Äì . </p><br><h2 id="faq">  Faq </h2><br><ul><li>       ? </li></ul><br><p>       ,       .      ,   2  3 . </p><br><ul><li>       IDEA   ,   -  ? </li></ul><br><p> ,    IDEA   IDEA SDK ,   deprecated,   ,  .   SDK-   ,   ,     . </p><br><ul><li>         ? </li></ul><br><p>    ‚Äì    gitignore .   -   . </p><br><ul><li>          ? </li></ul><br><p>      Android Studio  Mac OS,    Ubuntu,   . ,     Windows,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463611/">https://habr.com/ru/post/id463611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463599/index.html">"Ini adalah mimpi buruk": para astronot berbagi pendapat tentang kesalahan yang dilakukan Hollywood ketika membuat film tentang ruang</a></li>
<li><a href="../id463601/index.html">Pisahkan metode logging di Java / logback</a></li>
<li><a href="../id463605/index.html">Intelektual teknis - dari luar angkasa</a></li>
<li><a href="../id463607/index.html">Alternatif bawaan redux dengan Bereaksi Konteks dan kait</a></li>
<li><a href="../id463609/index.html">Sistem rekomendasi untuk Directum Club. Bagian Satu, Kolaboratif</a></li>
<li><a href="../id463613/index.html">Gambar Docker juga dapat dibangun di werf menggunakan Dockerfile biasa</a></li>
<li><a href="../id463617/index.html">Fitur pengujian MMO seluler</a></li>
<li><a href="../id463619/index.html">Bekerja dari jarak jauh: pengalaman kami</a></li>
<li><a href="../id463623/index.html">Kami dipilih dari hutan tes: kami sedang membangun jalan singkat dari perlengkapan ke pengujian</a></li>
<li><a href="../id463625/index.html">Pemantauan jaringan dan deteksi aktivitas jaringan abnormal menggunakan solusi Flowmon Networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>