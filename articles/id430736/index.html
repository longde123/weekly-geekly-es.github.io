<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏻 🕖 🏏 Kembangkan browser Anda dari awal. Bagian Satu: HTML 🧛🏽 💪🏼 🤾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 


 Kami melanjutkan serangkaian artikel tentang pengembangan mesin peramban. 


 Pada artikel ini saya akan memberi tahu Anda cara mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kembangkan browser Anda dari awal. Bagian Satu: HTML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430736/"><p><img src="https://habrastorage.org/webt/qu/3l/02/qu3l02mug029as5w74y2zznn0yc.jpeg"></p><br><p>  Halo semuanya! </p><br><p>  Kami melanjutkan serangkaian artikel tentang pengembangan mesin peramban. </p><br><p>  Pada artikel ini saya akan memberi tahu Anda cara membuat parser HTML tercepat dengan DOM.  Kami akan melihat spesifikasi HTML dan mengapa itu buruk mengenai kinerja dan konsumsi sumber daya saat parsing HTML. </p><br><p>  Dengan topik ini, saya melaporkan HighLoad ++ sebelumnya.  Tidak semua orang dapat menghadiri konferensi, plus artikel tersebut memiliki lebih banyak detail. </p><br><p>  Saya berasumsi bahwa pembaca memiliki pengetahuan dasar tentang HTML: tag, node, elemen, namespace. </p><a name="habracut"></a><br><h2 id="specifikaciya-html">  Spesifikasi HTML </h2><br><p>  Sebelum Anda mulai menyentuh implementasi parser HTML, Anda perlu memahami spesifikasi HTML apa yang harus dipercaya. </p><br><p>  Ada dua spesifikasi HTML: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WHATWG</a> <br><ul><li> Apple, Mozilla, Google, Microsoft </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">W3c</a> <br><ul><li>  Daftar besar perusahaan </li></ul></li></ol><br><p> Secara alami, pilihan jatuh pada pemimpin industri - <strong><code>WHATWG</code></strong> .  Standar hidup, perusahaan besar masing-masing dengan browser / mesin browser mereka sendiri. </p><br><p>  UPDATE: Sayangnya, tautan yang diberikan ke spesifikasi tidak terbuka dari Rusia.  Rupanya, "gema perang" dengan telegram. </p><br><h2 id="process-parsinga-html">  Proses penguraian HTML </h2><br><p>  Proses membangun pohon HTML dapat dibagi menjadi empat bagian: </p><br><ol><li>  Dekoder </li><li>  Pretreatment </li><li>  Tokenizer </li><li>  Membangun pohon </li></ol><br><p>  Kami mempertimbangkan setiap tahap secara terpisah. </p><br><h3 id="dekoder">  Dekoder </h3><br><p>  Tokenizer menerima karakter Unicode (titik kode) sebagai input.  Oleh karena itu, kita perlu mengkonversi aliran byte saat ini ke karakter Unicode.  Untuk melakukan ini, gunakan spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengkodean</a> . </p><br><p>  Jika kita memiliki HTML dengan pengkodean yang tidak dikenal (tanpa header HTTP), maka kita perlu menentukannya sebelum memulai pengkodean.  Untuk melakukan ini, kita akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma sniffing pengodean</a> . </p><br><p>  Jika sangat singkat, inti dari algoritma ini adalah kita menunggu <strong><code>500</code></strong> atau <strong><code>1024 </code></strong> pertama dari aliran byte dan menjalankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prescan</a> algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aliran byte untuk menentukan pengodeannya</a> yang mencoba menemukan <strong><code>&lt;meta&gt;</code></strong> dengan atribut <strong><code>http-equiv</code></strong> , <strong><code>content</code></strong> atau <strong><code>charset</code></strong> dan percobaan memahami pengkodean yang ditunjukkan pengembang HTML. </p><br><p>  Spesifikasi <strong><code>Encoding</code></strong> menetapkan set minimum penyandian yang didukung oleh mesin browser (total 21): UTF-8, ISO-8859-2, ISO-8859-7, ISO-8859-8, windows-874, windows-1250, windows-1251, windows -1252, windows-1254, windows-1255, windows-1256, windows-1257, windows-1258, gb18030, Big5, ISO-2022-JP, Shift_JIS, EUC-KR, UTF-16BE, UTF-16LE dan x-user -didefinisikan. </p><br><h3 id="predvaritelnaya-obrabotka">  Pretreatment </h3><br><p>  Setelah kita mendekodekan byte menjadi karakter Unicode, kita perlu "membersihkan".  Yaitu, ganti semua karakter pengembalian carriage ( <strong><code>\r</code></strong> ) diikuti oleh karakter umpan baris ( <strong><code>\n</code></strong> ) dengan karakter carriage return ( <strong><code>\r</code></strong> ).  Lalu, ganti semua karakter carriage return dengan karakter baris baru ( <strong><code>\n</code></strong> ). </p><br><p>  Demikian diuraikan dalam spesifikasinya.  Yaitu, <strong><code>\r\n</code></strong> =&gt; <strong><code>\r</code></strong> , <strong><code>\r</code></strong> =&gt; <strong><code>\n</code></strong> . </p><br><p>  Tetapi, pada kenyataannya, tidak ada yang melakukannya.  Buat lebih mudah: </p><br><p>  Jika Anda mendapatkan karakter pengembalian carriage ( <strong><code>\r</code></strong> ), lihat untuk melihat apakah ada karakter umpan baris ( <strong><code>\n</code></strong> ).  Jika ada, maka kami mengubah kedua karakter ke karakter umpan baris ( <strong><code>\n</code></strong> ), jika tidak, maka kami hanya mengubah karakter pertama ( <strong><code>\r</code></strong> ) ke umpan baris ( <strong><code>\n</code></strong> ). </p><br><p>  Ini melengkapi pemrosesan data awal.  Ya, Anda hanya perlu menyingkirkan simbol carriage return agar tidak jatuh ke tokenizer.  Tokenizer tidak mengharapkan dan tidak tahu apa yang harus dilakukan dengan simbol carriage return. </p><br><h3 id="oshibki-parsinga">  Kesalahan parsing </h3><br><p>  Sehingga di masa depan tidak ada pertanyaan, Anda harus segera memberi tahu apa itu <code> </code> ( <strong><code>parse error</code></strong> ). </p><br><p>  Tidak ada yang salah.  Kedengarannya mengancam, tetapi sebenarnya ini hanya peringatan bahwa kami mengharapkan satu, tetapi kami memiliki yang lain. </p><br><p>  Kesalahan parsing tidak akan menghentikan pemrosesan data atau pembuatan pohon.  Ini adalah pesan yang menandakan bahwa kita tidak memiliki HTML yang valid. </p><br><p>  Kesalahan Parsig dapat diperoleh untuk pasangan pengganti, <code>\0</code> , lokasi tag salah, salah <strong><code>&lt;!DOCTYPE&gt;</code></strong> dan segala macam hal lainnya. </p><br><p>  Omong-omong, beberapa kesalahan penguraian menyebabkan konsekuensi.  Misalnya, jika Anda menetapkan "buruk" <strong><code>&lt;!DOCTYPE&gt;</code></strong> maka pohon HTML akan ditandai sebagai <strong><code>QUIRKS</code></strong> dan logika beberapa fungsi DOM akan berubah. </p><br><h3 id="tokenizator">  Tokenizer </h3><br><p>  Seperti disebutkan sebelumnya, tokenizer menerima karakter Unicode sebagai input.  Ini adalah mesin negara yang memiliki <strong><code>80</code></strong> negara.  Di setiap negara bagian, ketentuan untuk karakter Unicode.  Tergantung pada karakter yang diterima, tokenizer dapat: </p><br><ol><li>  Ubah status Anda </li><li>  Buat token dan ubah status </li><li>  Jangan lakukan apa-apa, tunggu karakter selanjutnya </li></ol><br><p>  Tokenizer membuat enam jenis token: DOCTYPE, Tag Awal, Tag Akhir, Komentar, Karakter, End-Of-File.  Yang memasuki tahap membangun pohon. </p><br><p>  Perlu dicatat bahwa tokenizer tidak tahu tentang semua statusnya, tetapi di mana sekitar 40% (mengambil dari langit-langit, misalnya).  "Kenapa sisanya?"  - kamu bertanya.  Sekitar 60% sisanya mengetahui tahap membangun pohon. </p><br><p>  Ini dilakukan untuk mem-parsing tag dengan benar seperti <strong><code>&lt;textarea&gt;</code></strong> , <strong><code>&lt;style&gt;</code></strong> , <strong><code>&lt;script&gt;</code></strong> , <strong><code>&lt;title&gt;</code></strong> dan sebagainya.  Artinya, biasanya tag tersebut di mana kita tidak mengharapkan tag lain, tetapi hanya menutup diri kita sendiri. </p><br><p>  Misalnya, <strong><code>&lt;title&gt;</code></strong> tidak dapat berisi tag lain.  Tag apa pun di <strong><code>&lt;title&gt;</code></strong> akan dianggap sebagai teks sampai bertemu dengan tag penutup untuk dirinya sendiri <strong><code>&lt;/title&gt;</code></strong> . </p><br><p>  Mengapa ini dilakukan?  Lagipula, Anda bisa memberi tahu tokenizer bahwa jika kami memenuhi <strong><code>&lt;title&gt;</code></strong> maka kami menyusuri "jalur yang kami butuhkan."  Dan itu akan benar jika bukan ruang nama!  Ya, namespace mempengaruhi perilaku tahap pembuatan pohon, yang pada gilirannya mengubah perilaku tokenizer. </p><br><p>  Sebagai contoh, pertimbangkan perilaku <strong><code>&lt;title&gt;</code></strong> dalam ruang nama HTML dan SVG: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Hasil membangun pohon: </p><br><pre> <code class="plaintext hljs">&lt;title&gt; "&lt;span&gt;&lt;/span&gt;"</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Hasil membangun pohon: </p><br><pre> <code class="plaintext hljs">&lt;svg&gt; &lt;title&gt; &lt;span&gt; ""</code> </pre> <br><p>  Kita melihat bahwa dalam kasus pertama (HTML namespace) <strong><code>&lt;span&gt;</code></strong> adalah teks, elemen <strong><code>span</code></strong> tidak dibuat.  Dalam kasus kedua (ruang nama SVG), sebuah elemen dibuat berdasarkan tag <strong><code>&lt;span&gt;</code></strong> .  Artinya, tergantung pada namespace, tag berperilaku berbeda. </p><br><p>  Tapi itu belum semuanya.  Kue pada "perayaan kehidupan" ini adalah fakta bahwa tokenizer itu sendiri harus tahu di namespace apa tahap konstruksi pohon berada.  Dan ini diperlukan hanya untuk menangani <strong><code>CDATA</code></strong> dengan benar. </p><br><p>  Pertimbangkan dua contoh dengan <strong><code>CDATA</code></strong> , dua ruang nama: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Hasil membangun pohon: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;!--[CDATA[  ]]--&gt;</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Hasil membangun pohon: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;svg&gt; "  "</code> </pre> <br><p>  Dalam kasus pertama (HTML namespace), tokenizer mengambil <strong><code>CDATA</code></strong> untuk dikomentari.  Dalam kasus kedua, tokenizer membongkar struktur <strong><code>CDATA</code></strong> dan menerima data darinya.  Secara umum, aturannya adalah ini: jika kita bertemu <strong><code>CDATA</code></strong> tidak dalam ruang nama HTML, maka kita menguraikannya, kalau tidak kita menganggapnya sebagai komentar. </p><br><p>  Ini adalah hubungan yang erat antara tokenizer dan konstruksi pohon.  Tokenizer harus tahu di mana namespace tahap pembangunan pohon saat ini berada, dan tahap konstruksi pohon dapat mengubah keadaan tokenizer. </p><br><h3 id="tokeny">  Token </h3><br><p>  Di bawah ini kami akan mempertimbangkan keenam jenis token yang dibuat oleh tokenizer.  Perlu dicatat bahwa semua token telah menyiapkan data, yaitu, sudah diproses dan "siap digunakan".  Ini berarti bahwa semua referensi karakter bernama, seperti <strong><code>&amp;copy</code></strong> , akan dikonversi ke karakter unicode. </p><br><h3 id="doctype-token">  Token DOCTYPE </h3><br><p>  Token DOCTYPE memiliki struktur sendiri yang tidak mirip dengan tag lain.  Token berisi: </p><br><ol><li>  Nama depan </li><li>  Pengidentifikasi publik </li><li>  Pengidentifikasi sistem </li></ol><br><p>  Dalam HTML modern, satu-satunya DOCTYPE yang valid / valid akan terlihat seperti ini: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span></code> </pre> <br><p>  Semua yang lain <strong><code>&lt;!DOCTYPE&gt;</code></strong> akan dianggap sebagai kesalahan penguraian. </p><br><h3 id="start-tag-token">  Mulai token tag </h3><br><p>  Tag pembuka dapat berisi: </p><br><ol><li>  Nama tag </li><li>  Atribut </li><li>  Bendera </li></ol><br><p>  Misalnya, </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  Tag pembuka dapat berisi bendera yang <strong><code>self-closing</code></strong> .  Bendera ini tidak memengaruhi penutupan tag, tetapi dapat menyebabkan kesalahan penguraian untuk elemen yang tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">batal</a> . </p><br><h3 id="end-tag-token">  Token tag akhir </h3><br><p>  Tag penutup.  Ia memiliki semua properti token dari tag pembuka, tetapi memiliki garis miring <strong><code>/</code></strong> di depan nama tag. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  Tag penutup dapat berisi bendera yang <strong><code>self-closing</code></strong> yang akan menyebabkan kesalahan penguraian.  Juga, kesalahan parsing akan disebabkan oleh atribut dari tag penutup.  Mereka akan diurai dengan benar, tetapi dibuang pada tahap konstruksi pohon. </p><br><h3 id="comment-token">  Token komentar </h3><br><p>  Token komentar berisi seluruh teks komentar.  Artinya, sepenuhnya disalin dari aliran ke token. </p><br><p>  Contoh </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span></code> </pre> <br><h3 id="character-token">  Token karakter </h3><br><p>  Mungkin token paling menarik.  Simbol Token Unicode.  Dapat mengandung satu (hanya satu) karakter. </p><br><p>  Token akan dibuat untuk setiap karakter dalam HTML dan dikirim ke tahap konstruksi pohon.  Ini sangat mahal. <br>  Mari kita lihat cara kerjanya. </p><br><p>  Ambil data HTML: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> ! &amp;reg;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Menurut Anda, berapa banyak token yang akan dibuat untuk contoh ini?  Jawab: 22. </p><br><p>  Pertimbangkan daftar token yang dibuat: </p><br><pre> <code class="plaintext hljs">Start tag token: &lt;span&gt; Character token:  Character token:  Character token:  Character token:  Character token:  Character token: Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token: ! Character token: Character token: End tag token: &lt;/span&gt; End-of-file token</code> </pre> <br><p>  Tidak nyaman, bukan?  Tetapi, tentu saja, banyak pembuat parser HTML sebenarnya hanya memiliki satu token selama pemrosesan.  Jalankan dalam lingkaran dan timpa dengan data baru setiap kali. </p><br><p>  Mari kita maju dan menjawab pertanyaan: mengapa ini dilakukan?  Mengapa tidak mengambil teks ini dalam satu bagian?  Jawabannya terletak pada fase konstruksi pohon. </p><br><p>  Tokenizer tidak berguna tanpa tahap membangun pohon HTML.  Pada tahap membangun pohon, teks direkatkan dengan kondisi yang berbeda. </p><br><p>  Syaratnya kira-kira sebagai berikut: </p><br><ol><li>  Jika token karakter dengan <strong><code>U+0000</code></strong> ( <strong><code>NULL</code></strong> ) tiba, maka kami menyebabkan kesalahan penguraian dan mengabaikan token. </li><li>  Jika salah satu dari <strong><code>U+0009</code></strong> ( <strong><code>CHARACTER TABULATION</code></strong> ), <strong><code>U+000A</code></strong> ( <strong><code>LINE FEED (LF)</code></strong> ), <strong><code>U+000C</code></strong> ( <strong><code>FORM FEED (FF)</code></strong> ) atau token karakter <strong><code>U+0020</code></strong> ( <strong><code>SPACE</code></strong> ) datang maka panggil algoritma untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengembalikan elemen format aktif</a> dan masukkan token ke pohon. </li></ol><br><p>  Token simbol ditambahkan ke pohon sesuai dengan algoritma: </p><br><ol><li>  Jika posisi penyisipan saat ini bukan simpul teks, maka buat simpul teks, masukkan ke dalam pohon dan tambahkan data dari token ke sana. </li><li>  Jika tidak, tambahkan data dari token ke simpul teks yang ada. </li></ol><br><p>  Perilaku ini menciptakan banyak masalah.  Perlunya setiap simbol untuk membuat token dan mengirim untuk analisis ke tahap membangun pohon.  Kami tidak tahu ukuran simpul teks dan kami harus mengalokasikan banyak memori di muka atau membuat realoks.  Semua ini sangat mahal dari ingatan atau waktu. </p><br><h3 id="end-of-file-token">  Token akhir file </h3><br><p>  Token sederhana dan jelas.  Data sudah selesai - biarkan kami memberi tahu Anda tentang tahap konstruksi pohon ini. </p><br><h3 id="postroenie-dereva">  Membangun pohon </h3><br><p>  Bangunan pohon adalah mesin negara dengan <strong><code>23</code></strong> negara dengan banyak syarat untuk token (tag, teks).  Tahap membangun pohon adalah yang terbesar, menempati bagian penting dari spesifikasi, dan juga mampu menyebabkan tidur lesu dan iritasi. </p><br><p>  Semuanya diatur dengan sangat sederhana.  Token diterima pada input dan, tergantung pada token, keadaan konstruksi pohon diaktifkan.  Pada output, kami memiliki DOM nyata. </p><br><h2 id="problemy">  Masalah? </h2><br><p>  Masalah-masalah berikut tampaknya cukup jelas: </p><br><p>  <strong>Penyalinan karakter-per-karakter</strong> </p><br><p>  Setiap keadaan tokenizer menerima satu karakter pada input, yang disalin / dikonversi bila perlu: nama tag, atribut, komentar, simbol. </p><br><p>  Ini sangat boros baik dalam memori maupun waktu.  Kami dipaksa untuk melakukan pra-alokasi jumlah memori yang tidak diketahui untuk setiap atribut, nama tag, komentar, dan sebagainya.  Dan ini, karenanya, mengarah ke realoks, dan realoks menyebabkan waktu yang hilang. </p><br><p>  Dan jika Anda bayangkan HTML berisi 1000 tag, dan setiap tag memiliki setidaknya satu atribut, maka kami mendapatkan pengurai yang sangat lambat. </p><br><p>  <strong>Token karakter</strong> </p><br><p>  Masalah kedua adalah token karakter.  Ternyata kami membuat token untuk setiap simbol dan memberikannya untuk membangun pohon.  Membangun pohon tidak tahu berapa banyak token yang akan kita miliki dan tidak dapat segera mengalokasikan memori untuk jumlah karakter yang diperlukan.  Dengan demikian, di sini semua realoks yang sama + cek konstan untuk keberadaan simpul teks dalam keadaan pohon saat ini. </p><br><p>  <strong>Sistem monolitik</strong> </p><br><p>  Masalah besar adalah ketergantungan segalanya pada segalanya.  Artinya, tokenizer tergantung pada keadaan membangun pohon, dan konstruksi pohon dapat mengendalikan tokenizer.  Dan semuanya harus disalahkan untuk namespace (ruang nama). </p><br><h2 id="kak-budem-reshat-problemy">  Bagaimana kita memecahkan masalah? </h2><br><p>  Selanjutnya, saya akan menjelaskan implementasi parser HTML di proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lexbor</a> saya, serta solusi untuk semua masalah yang disuarakan. </p><br><h3 id="predvaritelnaya-obrabotka-1">  Pretreatment </h3><br><p>  Kami menghapus pemrosesan data awal.  Kami akan melatih tokenizer untuk memahami carriage return ( <strong><code>\r</code></strong> ) sebagai karakter spasi.  Dengan demikian, dia akan dilemparkan ke panggung membangun pohon di mana kita akan mengetahuinya. </p><br><h3 id="tokeny-1">  Token </h3><br><p>  Dengan gerakan pergelangan tangan, kami menyatukan semua token.  Kami akan memiliki satu token untuk semuanya.  Secara umum, hanya akan ada satu token di seluruh proses parsing. </p><br><p>  Token terpadu kami akan berisi bidang-bidang berikut: </p><br><ol><li>  Tag id </li><li>  Mulai </li><li>  Akhir </li><li>  Atribut </li><li>  Bendera </li></ol><br><h4 id="tag-id">  Tag id </h4><br><p>  Kami tidak akan bekerja dengan representasi tekstual dari nama tag.  Kami menerjemahkan semuanya menjadi angka.  Jumlahnya mudah dibandingkan, lebih mudah untuk dikerjakan. </p><br><p>  Kami membuat tabel hash statis dari semua tag yang dikenal.  Kami membuat enum dari semua tag yang dikenal.  Artinya, kita perlu menetapkan pengidentifikasi untuk setiap tag secara kaku.  Dengan demikian, dalam tabel hash, kuncinya adalah nama tag, dan nilainya ditulis dari enumerasi. </p><br><p>  Sebagai contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_TAG__UNDEF = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_TAG__END_OF_FILE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_TAG__TEXT = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_TAG__DOCUMENT = <span class="hljs-number"><span class="hljs-number">0x0003</span></span>, LXB_TAG__EM_COMMENT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_TAG__EM_DOCTYPE = <span class="hljs-number"><span class="hljs-number">0x0005</span></span>, LXB_TAG_A = <span class="hljs-number"><span class="hljs-number">0x0006</span></span>, LXB_TAG_ABBR = <span class="hljs-number"><span class="hljs-number">0x0007</span></span>, LXB_TAG_ACRONYM = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_TAG_ADDRESS = <span class="hljs-number"><span class="hljs-number">0x0009</span></span>, LXB_TAG_ALTGLYPH = <span class="hljs-number"><span class="hljs-number">0x000a</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Seperti yang Anda lihat dari contoh, kami membuat tag untuk token <strong>END-OF-FILE</strong> , untuk teks, untuk dokumen.  Semua ini demi kenyamanan lebih lanjut.  Membuka tirai, saya akan mengatakan bahwa di simpul ( <strong><code>DOM Node Interface</code></strong> ) kita akan memiliki <strong><code>Tag ID</code></strong> .  Ini dilakukan agar tidak membuat dua perbandingan: pada jenis node dan pada elemen.  Artinya, jika kita membutuhkan elemen <strong><code>DIV</code></strong> , maka kita melakukan satu pemeriksaan di simpul: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Best code */</span></span> }</code> </pre> <br><p>  Tetapi, tentu saja, Anda dapat melakukan ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == LXB_DOM_NODE_TYPE_ELEMENT &amp;&amp; node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Oh, code */</span></span> }</code> </pre> <br><p>  <strong><code>LXB_TAG__</code></strong> dua garis bawah dalam <strong><code>LXB_TAG__</code></strong> untuk memisahkan tag umum dari tag sistem.  Dengan kata lain, pengguna dapat membuat tag dengan <strong><code>text</code></strong> nama atau <strong><code>end-of-file</code></strong> dan jika kita mencari berdasarkan nama tag, maka tidak akan terjadi kesalahan.  Semua tag sistem dimulai dengan <strong><code>#</code></strong> . </p><br><p>  Tapi tetap saja, sebuah node dapat menyimpan representasi tekstual dari nama tag.  Untuk 98,99999% node, parameter ini akan menjadi <strong><code>NULL</code></strong> .  Di beberapa ruang nama, kita perlu menentukan awalan atau nama tag dengan register tetap.  Misalnya, <strong><code>baseProfile</code></strong> di ruang nama SVG. </p><br><p>  Logikanya sederhana.  Jika kami memiliki tag dengan register yang jelas maka: </p><br><ol><li>  Tambahkan ke basis umum tag dalam huruf kecil.  Dapatkan id tag. </li><li>  Tambahkan pengenal tag dan nama tag asli dalam representasi teks ke node. </li></ol><br><p>  <strong>Tag khusus</strong> </p><br><p>  Pengembang dapat membuat tag apa pun dalam HTML.  Karena kita hanya memiliki tag yang kita ketahui di tabel hash statis, dan pengguna dapat membuat tag, kita membutuhkan tabel hash dinamis. </p><br><p>  Semuanya terlihat sangat sederhana.  Ketika tag datang kepada kita, kita akan melihat apakah tag itu ada di tabel hash statis.  Jika tidak ada tag, maka mari kita lihat yang dinamis, jika tidak ada di sana, maka kami menambah penghitung pengenal dengan satu dan menambahkan tag ke tabel dinamis. </p><br><p>  Semua yang dijelaskan terjadi pada tahap tokenizer.  Di dalam tokenizer dan setelah semua perbandingan pergi dengan <strong><code>Tag ID</code></strong> (dengan pengecualian langka). </p><br><h4 id="begin-and-end">  Mulai dan akhiri </h4><br><p>  Sekarang di tokenizer kita tidak akan memiliki pemrosesan data.  Kami tidak akan menyalin dan mengonversi apa pun.  Kami hanya membawa petunjuk ke awal dan akhir data. </p><br><p>  Semua pemrosesan data, seperti tautan simbolik, akan berlangsung pada tahap pembangunan pohon. <br>  Dengan demikian, kita akan mengetahui ukuran data untuk alokasi memori selanjutnya. </p><br><h4 id="attributes">  Atribut </h4><br><p>  Semuanya sesederhana di sini.  Kami tidak menyalin apa pun, tetapi hanya menyimpan pointer ke awal / akhir nama dan nilai atribut.  Semua transformasi terjadi pada saat pohon dibangun. </p><br><h4 id="flags">  Bendera </h4><br><p>  Karena kami memiliki token yang disatukan, kami perlu memberi tahu bangunan pohon tentang jenis token.  Untuk melakukan ini, gunakan bidang bitmap Bendera. </p><br><p>  Bidang dapat berisi nilai-nilai berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_HTML_TOKEN_TYPE_OPEN = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE_SELF = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_HTML_TOKEN_TYPE_TEXT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_HTML_TOKEN_TYPE_DATA = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_HTML_TOKEN_TYPE_RCDATA = <span class="hljs-number"><span class="hljs-number">0x0010</span></span>, LXB_HTML_TOKEN_TYPE_CDATA = <span class="hljs-number"><span class="hljs-number">0x0020</span></span>, LXB_HTML_TOKEN_TYPE_NULL = <span class="hljs-number"><span class="hljs-number">0x0040</span></span>, LXB_HTML_TOKEN_TYPE_FORCE_QUIRKS = <span class="hljs-number"><span class="hljs-number">0x0080</span></span>, LXB_HTML_TOKEN_TYPE_DONE = <span class="hljs-number"><span class="hljs-number">0x0100</span></span> };</code> </pre> <br><p>  Selain jenis token yang membuka atau menutup, ada nilai untuk konverter data.  Hanya tokenizer yang tahu cara mengonversi data dengan benar.  Oleh karena itu, tokenizer menandai di token bagaimana data harus diproses. </p><br><h4 id="character-token-1">  Token karakter </h4><br><p>  Dari yang dijelaskan sebelumnya, kita dapat menyimpulkan bahwa simbol token telah menghilang dari kita.  Ya, sekarang kami memiliki jenis token baru: <strong><code>LXB_HTML_TOKEN_TYPE_TEXT</code></strong> .  Sekarang kita membuat token untuk seluruh teks di antara tag, menandai bagaimana itu harus diproses di masa depan. </p><br><p>  Karena itu, kita harus mengubah kondisi dalam pembangunan pohon.  Kita perlu melatihnya untuk bekerja bukan dengan token simbolik, tetapi dengan token teks: konversi, hapus karakter yang tidak perlu, lewati spasi dan sebagainya. </p><br><p>  Tapi, tidak ada yang rumit.  Pada tahap membangun pohon, perubahannya akan minimal.  Tetapi tokenizer sekarang tidak cocok dengan spesifikasi dari kata sama sekali.  Tapi kami tidak membutuhkannya, itu normal.  Tugas kami adalah untuk mendapatkan pohon HTML / DOM yang sepenuhnya sesuai dengan spesifikasi. </p><br><h3 id="stadii-tokenizatora">  Tahapan Tokenizer </h3><br><p>  Untuk memastikan pemrosesan data kecepatan tinggi dalam tokenizer, kami akan menambahkan iterator kami ke setiap tahap.  Menurut spesifikasi, setiap tahap menerima satu simbol untuk kami dan, tergantung pada simbol yang telah tiba, membuat keputusan.  Tapi, kenyataannya sangat mahal. </p><br><p>  Misalnya, untuk berpindah dari tahap <strong><code>ATTRIBUTE_NAME</code></strong> ke tahap <strong><code>ATTRIBUTE_VALUE</code></strong> kita perlu menemukan spasi putih di nama atribut, yang akan menunjukkan akhirnya.  Menurut spesifikasinya, kita harus memberi makan berdasarkan karakter ke panggung <strong><code>ATTRIBUTE_NAME</code></strong> hingga karakter spasi putih <strong><code>ATTRIBUTE_NAME</code></strong> , dan tahap ini tidak beralih ke yang lain.  Ini sangat mahal, biasanya ini diterapkan melalui pemanggilan fungsi untuk setiap karakter atau panggilan balik seperti "tkz-&gt; next_code_point ()". </p><br><p>  Kami menambahkan loop ke tahap <strong><code>ATTRIBUTE_NAME</code></strong> dan meneruskan seluruh buffer yang masuk.  Dalam loop, kita mencari simbol yang kita butuhkan untuk beralih dan terus bekerja pada tahap selanjutnya.  Di sini kita mendapatkan banyak kemenangan, bahkan optimasi kompiler. </p><br><p>  Tapi!  Yang terburuk adalah kami dengan demikian mematahkan dukungan bongkahan (bongkahan) di luar kotak.  Berkat pemrosesan karakter-oleh-simbol di setiap tahap tokenizer, kami memiliki dukungan untuk bongkahan, dan sekarang kami telah memecahkannya. </p><br><p>  Bagaimana cara memperbaikinya?  Bagaimana cara mengimplementasikan dukungan untuk bongkahan?!  Sederhana saja, kami memperkenalkan konsep buffer yang masuk (Buffer Masuk). </p><br><h3 id="incoming-buffer">  Buffer masuk </h3><br><p>  Seringkali HTML mem-parsing dalam potongan.  Misalnya, jika kita menerima data melalui jaringan.  Agar tidak diam saat menunggu data yang tersisa, kami dapat mengirim data yang sudah diterima untuk diproses / diurai.  Secara alami, data dapat dirobek di mana saja.  Sebagai contoh, kami memiliki dua buffer: </p><br><p>  <strong>Pertama</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">clas</span></span></span></span></code> </pre> <br><p>  <strong>Kedua</strong> </p><br><pre> <code class="html hljs xml">s="oh-no-oh-no"&gt;</code> </pre> <br><p>  Karena kami tidak menyalin apa pun pada tahap tokenization, tetapi hanya mengambil petunjuk ke awal dan akhir data, kami memiliki masalah.  Pointer ke buffer pengguna yang berbeda.    ,                     . </p><br><p>               . <br>   : </p><br><ol><li>              (Incoming Buffer). </li><li>     ( )  ,        ?  ,          .       ,           .  99%        . </li></ol><br><p>  "  "  .      . </p><br><p> ,      .      ,       ( )          .     . ,  ,   ,  .         . </p><br><h3 id="problema-dannye-v-tokene"> :    </h3><br><p>      ,  . ,        :          .     .             (    ),      .              . </p><br><p>    :      .  ,                . </p><br><h2 id="stadiya-postroeniya-dereva">    </h2><br><p>   . </p><br><p>      ,    . ,         . </p><br><p>    : </p><br><p> <strong> </strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error, ignore token */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == whitespaces) { <span class="hljs-comment"><span class="hljs-comment">/* Insert element */</span></span><span class="hljs-string"><span class="hljs-string">' } /* ... */ }</span></span></code> </pre> <br><p> <strong> Lexbor HTML</strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">lexbor_str_t</span></span> str = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">lxb_html_parser_char_t</span></span> pc = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; pc.drop_null = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; tree-&gt;status = lxb_html_token_parse_data(token, &amp;pc, &amp;str, tree-&gt;document-&gt;mem-&gt;text); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token-&gt;type &amp; LXB_HTML_TOKEN_TYPE_NULL) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* Insert element if not empty */</span></span> }</code> </pre> <br><p>   ,               .           : </p><br><pre> <code class="cpp hljs">pc.replace_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0'    (REPLACEMENT CHARACTER (U+FFFD)) */</span></span> pc.drop_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0' */</span></span> pc.is_attribute <span class="hljs-comment"><span class="hljs-comment">/*          " " */</span></span> pc.state <span class="hljs-comment"><span class="hljs-comment">/*  .        . */</span></span></code> </pre> <br><p>           . -   <strong><code>\0</code></strong> ,  -    <strong><code>REPLACEMENT CHARACTER</code></strong> . -    ,  - .        . </p><br><p>  ,     .      .  ,       <strong><code>&lt;head&gt;</code></strong>   .  ,           ,   : "    ".              ,           . </p><br><div class="spoiler"> <b class="spoiler_title">  &lt;sarcasm&gt;</b> <div class="spoiler_text"><p>  HTML  (   )    <strong><code>sarcasm</code></strong> .            . </p><br><pre> <code class="plaintext hljs">An end tag whose tag name is "sarcasm" Take a deep breath, then act as described in the "any other end tag" entry below.</code> </pre> <br><p>   . </p></div></div><br><h2 id="itog">  </h2><br><p>            HTML    DOM/HTML Interfaces   HTML/DOM    HTML . </p><br><p>    ,   : </p><br><ol><li>    (  ) </li><li>  <br><ul><li>  Incoming Buffer </li><li>   </li><li>   Tag ID </li><li> ̆ :  ,  N+  </li><li> ̆     </li><li>      </li><li>    ̈ </li></ul></li><li>   <br><ul><li>      </li></ul></li></ol><br><p>  i7 2012 ,   ,      235MB   (Amazon-). </p><br><p>  ,        1.5/2 ,     . ,    . ,    CSS     (Grammar,  ,       Grammar).     HTML,  CSS  ,    "". </p><br><h2 id="ishodniki">  Kode sumber </h2><br><p>      HTML    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lexbor HTML</a> . </p><br><h2 id="ps"> PS </h2><br><p>      CSS  Grammar.  ,     .  - 6-8 . </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p>    .  ,        . <br>      (      ).    . </p></div></div><br><p>  Terima kasih atas perhatian anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430736/">https://habr.com/ru/post/id430736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430724/index.html">DEFCON 21. Konferensi DNS dapat berbahaya bagi kesehatan Anda. Bagian 1</a></li>
<li><a href="../id430728/index.html">Ajari saya untuk memberikan umpan balik</a></li>
<li><a href="../id430730/index.html">Apa yang dilakukan R&D ABBYY: NLP Advanced Research Group</a></li>
<li><a href="../id430732/index.html">Untuk pertanyaan pembagian dan TI</a></li>
<li><a href="../id430734/index.html">Pembaruan pintar vs kontrak pintar</a></li>
<li><a href="../id430738/index.html">Jadilah seorang ninja keamanan: tingkat rahasia</a></li>
<li><a href="../id430740/index.html">Cara memerah susu sapi dengan robot dan membuat startup industri di atasnya. Sejarah Pengembangan R-SEPT</a></li>
<li><a href="../id430742/index.html">Olimpiade Siswa "Saya seorang Profesional": arah "Pemrograman dan Teknologi Informasi"</a></li>
<li><a href="../id430746/index.html">Mengapa baterai Tesla tidak akan berfungsi di taksi udara</a></li>
<li><a href="../id430748/index.html">Perjuangan untuk sumber daya, bagian 6: cpuset atau Berbagi tidak selalu benar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>