<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöß üë©üèº‚Äç‚öïÔ∏è üêÑ Hexagon-Karten in Unity: Nebel des Krieges, Kartenforschung, prozedurale Generierung üë®üèª‚Äçüíª üë©üèø‚Äçüî¨ ü•†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenh√∂hen 

 Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen 

 Teile 8-11: Wasser, Landformen und W√§lle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hexagon-Karten in Unity: Nebel des Krieges, Kartenforschung, prozedurale Generierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427003/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenh√∂hen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und W√§lle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 20: Der Nebel des Krieges </h1><br><ul><li>  Speichern Sie die Zellendaten in der Textur. </li><li>  Reliefarten ohne Triangulation √§ndern. </li><li>  Wir verfolgen die Sichtbarkeit. </li><li>  Verdunkeln Sie alles Unsichtbare. </li></ul><br>  In diesem Teil werden wir der Karte den Nebel des Kriegseffekts hinzuf√ºgen. <br><br>  Jetzt wird die Serie auf Unity 2017.1.0 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg"></div><br>  <i>Jetzt sehen wir, dass wir sehen k√∂nnen und nicht sehen k√∂nnen.</i> <br><a name="habracut"></a><br><h2>  Zellendaten im Shader </h2><br>  Viele Strategiespiele verwenden das Konzept des Nebel des Krieges.  Dies bedeutet, dass die Sicht des Spielers eingeschr√§nkt ist.  Er kann nur sehen, was sich in der N√§he seiner Einheiten oder seines kontrollierten Bereichs befindet.  Obwohl wir die Erleichterung sehen k√∂nnen, wissen wir nicht, was dort passiert.  Normalerweise wird das unsichtbare Gel√§nde dunkler.  Um dies zu realisieren, m√ºssen wir die Sichtbarkeit der Zelle verfolgen und entsprechend rendern. <br><br>  Die einfachste M√∂glichkeit, das Erscheinungsbild ausgeblendeter Zellen zu √§ndern, besteht darin, den Netzdaten eine Sichtbarkeitsmetrik hinzuzuf√ºgen.  Gleichzeitig m√ºssen wir jedoch eine neue Relieftriangulation mit einer √Ñnderung der Sichtbarkeit beginnen.  Dies ist eine schlechte Entscheidung, da sich die Sichtbarkeit w√§hrend des Spiels st√§ndig √§ndert. <br><br>  Oft wird die Technik des Renderns √ºber der Topographie einer durchscheinenden Oberfl√§che verwendet, bei der f√ºr den Spieler unsichtbare Zellen teilweise maskiert werden.  Diese Methode eignet sich f√ºr relativ flaches Gel√§nde in Kombination mit einem begrenzten Betrachtungswinkel.  Da unser Gel√§nde jedoch sehr unterschiedliche H√∂hen und Objekte enthalten kann, die aus verschiedenen Winkeln betrachtet werden k√∂nnen, ben√∂tigen wir hierf√ºr ein sehr detailliertes Netz, das der Form des Gel√§ndes entspricht.  Diese Methode ist teurer als der oben erw√§hnte einfachste Ansatz. <br><br>  Ein anderer Ansatz besteht darin, die Daten der Zellen beim Rendern getrennt vom Reliefnetz an den Shader zu √ºbertragen.  Dadurch k√∂nnen wir die Triangulation nur einmal durchf√ºhren.  Zellendaten k√∂nnen mit Textur √ºbertragen werden.  Das √Ñndern der Textur ist viel einfacher als das Triangulieren des Gel√§ndes.  Dar√ºber hinaus ist das Ausf√ºhren mehrerer zus√§tzlicher Texturmuster schneller als das Rendern einer einzelnen durchscheinenden Ebene. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist mit Shader-Arrays?</b> <div class="spoiler_text">  Sie k√∂nnen Zellendaten auch mithilfe eines Vektorarrays an den Shader √ºbertragen.  Shader-Arrays haben jedoch eine Gr√∂√üenbeschr√§nkung, die in Tausenden von Bytes gemessen wird, und Texturen k√∂nnen Millionen von Pixeln enthalten.  Zur Unterst√ºtzung gro√üer Karten verwenden wir Texturen. </div></div><br><h3>  Zelldatenverwaltung </h3><br>  Wir brauchen eine M√∂glichkeit, die Textur zu steuern, die die Zelldaten enth√§lt.  Erstellen wir eine neue <code>HexCellShaderData</code> Komponente, die dies <code>HexCellShaderData</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; }</code> </pre> <br>  Beim Erstellen oder Laden einer neuen Karte m√ºssen wir eine neue Textur mit der richtigen Gr√∂√üe erstellen.  Daher f√ºgen wir eine Initialisierungsmethode hinzu, die eine Textur erstellt.  Wir verwenden eine RGBA-Textur ohne Mip-Texturen und linearen Farbraum.  Wir m√ºssen keine Zelldaten mischen, daher verwenden wir die Punktfilterung.  Au√üerdem sollten Daten nicht reduziert werden.  Jedes Pixel in der Textur enth√§lt Daten aus einer Zelle. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Sollte die Texturgr√∂√üe mit der Gr√∂√üe der Karte √ºbereinstimmen?</b> <div class="spoiler_text">  Nein, es m√ºssen nur gen√ºgend Pixel vorhanden sein, um alle Zellen aufzunehmen.  Bei exakter √úbereinstimmung mit der Gr√∂√üe der Karte wird h√∂chstwahrscheinlich eine Textur mit Gr√∂√üen erstellt, die keine Zweierpotenzen sind (Nicht-Zweierpotenzen, NPOT), und dieses Texturformat ist nicht das effektivste.  Obwohl wir den Code so konfigurieren k√∂nnen, dass er mit Texturen der Gr√∂√üe einer Zweierpotenz arbeitet, ist dies eine geringf√ºgige Optimierung, die den Zugriff auf Zellendaten erschwert. </div></div><br>  Tats√§chlich m√ºssen wir nicht jedes Mal eine neue Textur erstellen, wenn wir eine neue Karte erstellen.  Es reicht aus, die Gr√∂√üe der Textur zu √§ndern, wenn sie bereits vorhanden ist.  Wir m√ºssen nicht einmal √ºberpr√ºfen, ob wir bereits die richtige Gr√∂√üe haben, da <code>Texture2D.Resize</code> intelligent genug ist, um dies f√ºr uns zu tun. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( cellCountX, cellCountZ, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; } }</code> </pre> <br>  Anstatt die Zelldaten pixelweise anzuwenden, verwenden wir einen Farbpuffer und wenden die Daten aller Zellen gleichzeitig an.  Dazu verwenden wir das <code>Color32</code> Array.  Bei Bedarf erstellen wir am Ende von <code>Initialize</code> eine neue Array-Instanz.  Wenn wir bereits ein Array mit der richtigen Gr√∂√üe haben.  dann l√∂schen wir seinen Inhalt. <br><br><pre> <code class="cs hljs"> Texture2D cellTexture; Color32[] cellTextureData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || cellTextureData.Length != x * z) { cellTextureData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32[x * z]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellTextureData.Length; i++) { cellTextureData[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was ist color32?</b> <div class="spoiler_text">  Standardm√§√üige unkomprimierte RGBA-Texturen enthalten 4-Byte-Pixel.  Jeder der vier Farbkan√§le empf√§ngt ein Byte, dh sie haben 256 m√∂gliche Werte.  Bei Verwendung der Unity <code>Color</code> Struktur werden die Gleitkommakomponenten im Intervall 0‚Äì1 im Intervall 0‚Äì255 in Bytes konvertiert.  Beim Abtasten f√ºhrt die GPU die inverse Transformation durch. <br><br>  Die <code>Color32</code> Struktur arbeitet direkt mit Bytes, sodass sie weniger Platz beanspruchen und keine Konvertierung erfordern, was die Effizienz ihrer Verwendung erh√∂ht.  Da wir Zellendaten anstelle von Farben speichern, ist es logischer, direkt mit Rohtexturdaten und nicht mit <code>Color</code> . </div></div><br>  <code>HexGrid</code> sollte sich mit der Erstellung und Initialisierung dieser Zellen im Shader befassen.  Daher f√ºgen wir ihm ein <code>cellShaderData</code> Feld hinzu und erstellen eine Komponente in <code>Awake</code> . <br><br><pre> <code class="cs hljs"> HexCellShaderData cellShaderData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); CreateMap(cellCountX, cellCountZ); }</code> </pre> <br>  Beim Erstellen einer neuen Karte sollte auch <code>cellShaderData</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; cellShaderData.Initialize(cellCountX, cellCountZ); CreateChunks(); CreateCells(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Zellendaten bearbeiten </h3><br>  Bisher war es beim √Ñndern der Eigenschaften einer Zelle erforderlich, ein oder mehrere Fragmente zu aktualisieren. Jetzt m√ºssen m√∂glicherweise die Daten der Zellen aktualisiert werden.  Dies bedeutet, dass Zellen eine Verkn√ºpfung zu den Zellendaten im Shader haben m√ºssen.  <code>HexCell</code> dazu <code>HexCell</code> eine Eigenschaft <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCellShaderData ShaderData { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  In <code>HexGrid.CreateCell</code> weisen wir dieser Eigenschaft eine Shader-Datenkomponente zu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.ShaderData = cellShaderData; ‚Ä¶ }</code> </pre> <br>  Jetzt k√∂nnen wir Zellen dazu bringen, ihre Shader-Daten zu aktualisieren.  W√§hrend wir die Sichtbarkeit nicht verfolgen, k√∂nnen wir Shader-Daten f√ºr etwas anderes verwenden.  Der Relieftyp der Zelle bestimmt die Textur, mit der sie gerendert wird.  Dies hat keinen Einfluss auf die Geometrie der Zelle, sodass wir den Elevationstypindex in den Zellendaten und nicht in den Netzdaten speichern k√∂nnen.  Auf diese Weise k√∂nnen wir die Notwendigkeit einer Triangulation beseitigen, wenn wir die Art des Reliefs der Zelle √§ndern. <br><br>  F√ºgen Sie <code>HexCellShaderData</code> eine <code>HexCellShaderData</code> Methode <code>RefreshTerrain</code> , um diese Aufgabe f√ºr eine bestimmte Zelle zu vereinfachen.  Lassen wir diese Methode vorerst leer. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  √Ñndern Sie <code>HexCell.TerrainTypeIndex</code> so, dass diese Methode <code>HexCell.TerrainTypeIndex</code> wird und die Fragmente nicht aktualisiert werden sollen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Refresh(); ShaderData.RefreshTerrain(this); } } }</span></span></code> </pre> <br>  Wir werden es auch in <code>HexCell.Load</code> nachdem wir den Typ der <code>HexCell.Load</code> erhalten haben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); RefreshPosition(); ‚Ä¶ }</code> </pre> <br><h3>  Zellindex </h3><br>  Um diese Zellen zu √§ndern, m√ºssen wir den Index der Zelle kennen.  Der einfachste Weg, dies zu tun, besteht darin, die <code>Index</code> Eigenschaft zu <code>HexCell</code> .  Es zeigt den Index der Zelle in der Liste der Zellen in der Karte an, der dem Index in den angegebenen Zellen im Shader entspricht. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Dieser Index befindet sich bereits in <code>HexGrid.CreateCell</code> also einfach der erstellten Zelle zu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; ‚Ä¶ }</code> </pre> <br>  Jetzt kann <code>HexCellShaderData.RefreshTerrain</code> diesen Index verwenden, um <code>HexCellShaderData.RefreshTerrain</code> anzugeben.  Speichern Sie den Elevationstypindex in der Alpha-Komponente des Pixels, indem Sie den Typ einfach in Byte konvertieren.  Dies wird bis zu 256 Gel√§ndetypen unterst√ºtzen, was f√ºr uns ausreichen wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; }</code> </pre> <br>  Um Daten auf eine Textur anzuwenden und an die GPU zu √ºbergeben, m√ºssen Sie <code>Texture2D.SetPixels32</code> und dann <code>Texture2D.Apply</code> .  Wie bei Fragmenten werden wir diese Vorg√§nge auf <code>LateUpdate</code> sodass sie unabh√§ngig von der Anzahl der ge√§nderten Zellen nicht √∂fter als einmal pro Frame ausgef√ºhrt werden k√∂nnen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Aktivieren Sie die Komponente nach der Initialisierung, um sicherzustellen, dass die Daten nach dem Erstellen einer neuen Karte aktualisiert werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Triangulation von Zellindizes </h3><br>  Da wir jetzt den Elevationstypindex in diesen Zellen speichern, m√ºssen wir sie nicht mehr in den Triangulationsprozess einbeziehen.  Um jedoch Zellendaten verwenden zu k√∂nnen, muss der Shader wissen, welche Indizes verwendet werden sollen.  Daher m√ºssen Sie Zellindizes in den Netzdaten speichern und die H√∂henindizes ersetzen.  Au√üerdem ben√∂tigen wir noch den Farbkanal des Netzes, um Zellen zu mischen, wenn diese Zellen verwendet werden. <br><br>  Wir <code>HexMesh</code> veralteten allgemeinen Felder <code>useColors</code> und <code>useTerrainTypes</code> .  Ersetzen Sie sie durch ein <code>useCellData</code> Feld. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public bool useCollider, useColors, useUVCoordinates, useUV2Coordinates; // public bool useTerrainTypes; public bool useCollider, useCellData, useUVCoordinates, useUV2Coordinates;</span></span></code> </pre><br>  Wir √ºberarbeiten die Umbenennung der <code>cellIndices</code> Liste in <code>cellIndices</code> .  Lassen Sie uns auch <code>colors</code> in <code>cellWeights</code> umbenennen - dieser Name ist besser <code>cellWeights</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes; // [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;Vector3&gt; vertices, cellIndices; [NonSerialized] List&lt;Color&gt; cellWeights; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; [NonSerialized] List&lt;int&gt; triangles;</span></span></code> </pre><br>  √Ñndern Sie <code>Clear</code> damit bei Verwendung dieser Zellen zwei Listen zusammen und nicht getrennt angezeigt werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { cellWeights = ListPool&lt;Color&gt;.Get(); cellIndices = ListPool&lt;Vector3&gt;.Get(); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // colors = ListPool&lt;Color&gt;.Get(); // } if (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } if (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } // if (useTerrainTypes) { // terrainTypes = ListPool&lt;Vector3&gt;.Get(); // } triangles = ListPool&lt;int&gt;.Get(); }</span></span></code> </pre> <br>  F√ºhren Sie dieselbe Gruppierung in <code>Apply</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { hexMesh.SetColors(cellWeights); ListPool&lt;Color&gt;.Add(cellWeights); hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, cellIndices); ListPool&lt;Vector3&gt;.Add(cellIndices); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // hexMesh.SetColors(colors); // ListPool&lt;Color&gt;.Add(colors); // } if (useUVCoordinates) { hexMesh.SetUVs(0, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } if (useUV2Coordinates) { hexMesh.SetUVs(1, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } // if (useTerrainTypes) { // hexMesh.SetUVs(2, terrainTypes); // ListPool&lt;Vector3&gt;.Add(terrainTypes); // } hexMesh.SetTriangles(triangles, 0); ListPool&lt;int&gt;.Add(triangles); hexMesh.RecalculateNormals(); if (useCollider) { meshCollider.sharedMesh = hexMesh; } }</span></span></code> </pre> <br>  Entfernen <code>AddTriangleColor</code> <code>AddTriangleTerrainTypes</code> <code>AddTriangleColor</code> und <code>AddTriangleTerrainTypes</code> .  Ersetzen Sie sie durch die entsprechenden <code>AddTriangleCellData</code> Methoden, die jeweils Indizes und Gewichte hinzuf√ºgen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddTriangleCellData(indices, weights, weights, weights); }</code> </pre> <br>  Machen Sie dasselbe in der entsprechenden <code>AddQuad</code> Methode. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3, Color weights4 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); cellWeights.Add(weights4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2 </span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights1, weights1, weights2, weights2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights, weights, weights, weights); }</code> </pre> <br><h3>  HexGridChunk Refactoring </h3><br>  Zu diesem Zeitpunkt werden in <code>HexGridChunk</code> viele Compilerfehler <code>HexGridChunk</code> , die <code>HexGridChunk</code> .  Aus Gr√ºnden der Konsistenz werden statische Farben zun√§chst in Gewichte umbenannt. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br>  Beginnen wir mit der Korrektur von <code>TriangulateEdgeFan</code> .  Fr√ºher brauchte er einen Typ, jetzt braucht er einen Zellindex.  <code>AddTriangleColor</code> Code <code>AddTriangleColor</code> und <code>AddTriangleTerrainTypes</code> durch den entsprechenden Code <code>AddTriangleCellData</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); terrain.AddTriangle(center, edge.v2, edge.v3); terrain.AddTriangle(center, edge.v3, edge.v4); terrain.AddTriangle(center, edge.v4, edge.v5); Vector3 indices; indices.x = indices.y = indices.z = index; terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = type; // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  Diese Methode wird an mehreren Stellen aufgerufen.  Lassen Sie uns sie durchgehen und sicherstellen, dass der Index der Zelle dorthin √ºbertragen wird und nicht die Art des Gel√§ndes. <br><br><pre> <code class="cs hljs"> TriangulateEdgeFan(center, e, cell.Index);</code> </pre> <br>  Als n√§chstes kommt <code>TriangulateEdgeStrip</code> .  Hier ist alles etwas komplizierter, aber wir verwenden den gleichen Ansatz.  <code>w1</code> <code>w2</code> die Parameternamen <code>c1</code> und <code>c2</code> in <code>w1</code> und <code>w2</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color w1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, EdgeVertices e2, Color w2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); Vector3 indices; indices.x = indices.z = index1; indices.y = index2; terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // Vector3 types; // types.x = types.z = type1; // types.y = type2; // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); if (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</span></span></code> </pre> <br>  √Ñndern Sie die Aufrufe dieser Methode so, dass der Zellenindex an sie √ºbergeben wird.  Wir halten auch die Variablennamen konsistent. <br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip( m, weights1, cell.Index, e, weights1, cell.Index ); ‚Ä¶ TriangulateEdgeStrip( e1, weights1, cell.Index, e2, weights2, neighbor.Index, hasRoad ); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w2 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i1 = beginCell.Index; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i2 = endCell.Index; TriangulateEdgeStrip(begin, weights1, i1, e2, w2, i2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color w1 = w2; e2 = EdgeVertices.TerraceLerp(begin, end, i); w2 = HexMetrics.TerraceLerp(weights1, weights2, i); TriangulateEdgeStrip(e1, w1, i1, e2, w2, i2, hasRoad); } TriangulateEdgeStrip(e2, w2, i1, end, weights2, i2, hasRoad); }</code> </pre> <br>  Nun kommen wir zu den Winkelmethoden.  Diese √Ñnderungen sind einfach, m√ºssen jedoch in einer gro√üen Menge Code vorgenommen werden.  Zuerst bei <code>TriangulateCorner</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); Vector3 indices; indices.x = bottomCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangleCellData(indices, weights1, weights2, weights3); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, weights2, weights3); // Vector3 types; // types.x = bottomCell.TerrainTypeIndex; // types.y = leftCell.TerrainTypeIndex; // types.z = rightCell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</span></span></code> </pre> <br>  Kommen zu <code>TriangulateCornerTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w3 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w4 = HexMetrics.TerraceLerp(weights1, weights3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleCellData(indices, weights1, w3, w4); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, w3, w4); // terrain.AddTriangleTerrainTypes(indices); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color w1 = w3; Color w2 = w4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); w3 = HexMetrics.TerraceLerp(weights1, weights2, i); w4 = HexMetrics.TerraceLerp(weights1, weights3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadCellData(indices, w1, w2, w3, w4); // terrain.AddQuadColor(w1, w2, w3, w4); // terrain.AddQuadTerrainTypes(indices); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadCellData(indices, w3, w4, weights2, weights3); // terrain.AddQuadColor(w3, w4, weights2, weights3); // terrain.AddQuadTerrainTypes(indices); }</span></span></code> </pre> <br>  Dann in <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryWeights = Color.Lerp(weights1, weights3, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( begin, weights1, left, weights2, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryColor); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Und etwas anders in <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryWeights = Color.Lerp(weights1, weights2, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( right, weights3, begin, weights1, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryWeights); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Die beiden vorherigen Methoden verwenden das <code>TriangulateBoundaryTriangle</code> , das ebenfalls aktualisiert werden muss. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginWeights, Vector3 left, Color leftWeights, Vector3 boundary, Color boundaryWeights, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleCellData(indices, beginWeights, w2, boundaryWeights); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(beginColor, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color w1 = w2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleCellData(indices, w1, w2, boundaryWeights); // terrain.AddTriangleColor(c1, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleCellData(indices, w2, leftWeights, boundaryWeights); // terrain.AddTriangleColor(c2, leftColor, boundaryColor); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  Die letzte Methode, die ge√§ndert werden muss, ist <code>TriangulateWithRiver</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ terrain.AddTriangle(centerL, m.v1, m.v2); terrain.AddQuad(centerL, center, m.v2, m.v3); terrain.AddQuad(center, centerR, m.v3, m.v4); terrain.AddTriangle(centerR, m.v4, m.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; terrain.AddTriangleCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = cell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); ‚Ä¶ }</span></span></code> </pre> <br>  Damit alles funktioniert, m√ºssen wir angeben, dass wir die Zelldaten f√ºr das untergeordnete Element des Reliefs des vorgefertigten Fragments verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/b8c/731/919b8c7317b2aa3c06f1077eef27fe96.png"></div><br>  <i>Das Relief verwendet Zelldaten.</i> <br><br>  Zu diesem Zeitpunkt enth√§lt das Netz Zellindizes anstelle von H√∂henindizes.  Da der Elevation Shader sie immer noch als Elevation-Indizes interpretiert, werden wir sehen, dass die erste Zelle mit der ersten Textur usw. gerendert wird, bis die letzte Relief-Textur erreicht ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/a23/ce8/8a5a23ce850af789e759dde6879f93eb.png"></div><br>  <i>Verwenden von Zellindizes als H√∂hentexturindizes.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Ich kann den √ºberarbeiteten Code nicht zum Laufen bringen.</b>  <b class="spoiler_title">Was mache ich falsch?</b> <div class="spoiler_text">  Zu einer Zeit haben wir eine gro√üe Menge an Triangulationscode ge√§ndert, sodass eine hohe Wahrscheinlichkeit f√ºr Fehler oder Versehen besteht.  Wenn Sie den Fehler nicht finden k√∂nnen, laden Sie das Paket aus diesem Abschnitt herunter und extrahieren Sie die entsprechenden Dateien.  Sie k√∂nnen sie in ein separates Projekt importieren und mit Ihrem eigenen Code vergleichen. </div></div><br><h3>  √úbertragen Sie Zellendaten an einen Shader </h3><br>  Um diese Zellen verwenden zu k√∂nnen, muss der Terrain Shader Zugriff darauf haben.  Dies kann √ºber die Shader-Eigenschaft implementiert werden.  Dazu muss <code>HexCellShaderData</code> die Materialeigenschaft des Reliefs <code>HexCellShaderData</code> .  Oder wir k√∂nnen die Textur dieser Zellen f√ºr alle Shader global sichtbar machen.  Dies ist praktisch, da wir es in mehreren Shadern ben√∂tigen, sodass wir diesen Ansatz verwenden werden. <br><br>  Rufen Sie nach dem Erstellen der <code>Shader.SetGlobalTexture</code> die statische <code>Shader.SetGlobalTexture</code> Methode auf, um sie global als <em>_HexCellData</em> sichtbar zu <em>machen</em> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } ‚Ä¶ }</code> </pre> <br>  Bei Verwendung der Shader-Eigenschaft stellt Unity dem Shader die <em>Texturgr√∂√üe</em> √ºber die Variable <em>texturName_TexelSize</em> zur <em>Verf√ºgung</em> .  Dies ist ein Vier-Komponenten-Vektorisierer, der Werte enth√§lt, die invers zur Breite und H√∂he sowie zur Breite und H√∂he selbst sind.  Beim Festlegen der globalen Textur wird dies jedoch nicht ausgef√ºhrt.  Daher werden wir es selbst mit dem <code>Shader.SetGlobalVector</code> nachdem wir die <code>Shader.SetGlobalVector</code> erstellt oder ihre <code>Shader.SetGlobalVector</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } Shader.SetGlobalVector( <span class="hljs-string"><span class="hljs-string">"_HexCellData_TexelSize"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(<span class="hljs-number"><span class="hljs-number">1f</span></span> / x, <span class="hljs-number"><span class="hljs-number">1f</span></span> / z, x, z) );</code> </pre> <br><h3>  Shader-Datenzugriff </h3><br>  Erstellen Sie eine neue Shader-Include-Datei im Materialordner mit dem Namen <em>HexCellData</em> .  Darin definieren wir Variablen f√ºr Informationen √ºber die Textur und Gr√∂√üe dieser Zellen.  Wir erstellen auch eine Funktion, um die Zellendaten f√ºr die angegebenen Scheitelpunktnetzdaten abzurufen. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _HexCellData; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> _HexCellData_TexelSize; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> GetCellData (appdata_full v) { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/604/dbc/a64604dbc7d3ad5ff1e1578bd0c84eec.png"></div><br>  <i>Neue Include-Datei.</i> <br><br>  <code>v.texcoord2</code> werden in <code>v.texcoord2</code> gespeichert, wie dies bei Gel√§ndetypen der Fall war.  Beginnen wir mit dem ersten Index - <code>v.texcoord2.x</code> .  Leider k√∂nnen wir den Index nicht direkt verwenden, um die Textur dieser Zellen abzutasten.  Wir m√ºssen es in UV-Koordinaten umwandeln. <br><br>  Der erste Schritt beim Erstellen der U-Koordinate besteht darin, den Zellenindex durch die Breite der Textur zu teilen.  Wir k√∂nnen dies tun, indem wir es mit <code>_HexCellData_TexelSize.x</code> multiplizieren. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">appdata_full v</span></span></span><span class="hljs-function">)</span></span> { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis ist eine Zahl in der Form ZU, wobei Z der Zeilenindex und U die Koordinate der U-Zelle ist. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Zeichenfolge extrahieren, indem wir die Zahl abrunden und dann von der Zahl subtrahieren, um die U-Koordinate zu erhalten.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die V-Koordinate teilt die Linie durch die H√∂he der Textur. </font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir die Textur abtasten, m√ºssen wir die Koordinaten in der Mitte der Pixel verwenden, nicht an ihren Kanten. </font><font style="vertical-align: inherit;">Auf diese Weise garantieren wir, dass die richtigen Pixel abgetastet werden. </font><font style="vertical-align: inherit;">F√ºgen Sie daher nach dem Teilen durch die Gr√∂√üe der Textur ¬Ω hinzu.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = (v.texcoord2.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies gibt uns die richtigen UV-Koordinaten f√ºr den Index der ersten Zelle, die in den Scheitelpunktdaten gespeichert ist. </font><font style="vertical-align: inherit;">Aber obendrein k√∂nnen wir bis zu drei verschiedene Indizes haben. </font><font style="vertical-align: inherit;">Daher werden wir daf√ºr sorgen, dass es </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr jeden Index funktioniert. </font><font style="vertical-align: inherit;">F√ºgen Sie einen ganzzahligen Parameter hinzu </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem wir auf die Vektorkomponente mit dem Zellenindex zugreifen.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir alle erforderlichen Koordinaten f√ºr diese Zellen haben, k√∂nnen wir eine Stichprobe erstellen </font></font><code>_HexCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da wir die Textur im Vertex-Programm abtasten, m√ºssen wir dem Shader explizit mitteilen, welche Mip-Textur verwendet werden soll. </font><font style="vertical-align: inherit;">Dies kann mit einer Funktion erfolgen </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Koordinaten von vier Texturen erfordert. </font><font style="vertical-align: inherit;">Da diese Zellen keine Mip-Texturen haben, weisen wir den zus√§tzlichen Koordinaten Nullwerte zu.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> data = tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vierte Datenkomponente enth√§lt einen H√∂henindex, den wir direkt als Bytes speichern. </font><font style="vertical-align: inherit;">Die GPU konvertierte sie jedoch automatisch in einen Gleitkommawert im Bereich von 0 bis 1. </font><font style="vertical-align: inherit;">Um es wieder in den richtigen Wert zu konvertieren, multiplizieren Sie es mit 255. Danach k√∂nnen Sie die Daten zur√ºckgeben.</font></font><br><br><pre> <code class="hljs kotlin"> float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = tex2Dlod(_HexCellData, float4(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.w *= <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Funktionalit√§t zu nutzen, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktivieren Sie HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da ich diesen Shader in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materials / Terrain platziert habe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , muss ich den relativen Pfad </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">../HexCellData.cginc verwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs lisp"> #include <span class="hljs-string"><span class="hljs-string">"../HexCellData.cginc"</span></span> UNITY_DECLARE_TEX2DARRAY(<span class="hljs-name"><span class="hljs-name">_MainTex</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Vertex-Programm erhalten wir Zelldaten f√ºr alle drei in den Vertex-Daten gespeicherten Zellindizes. </font><font style="vertical-align: inherit;">Weisen Sie dann </font></font><code>data.terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ihre H√∂henindizes zu.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); // data.terrain = v.texcoord2.xyz; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.terrain.x = cell0.w; data.terrain.y = cell1.w; data.terrain.z = cell2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt zeigte die Karte wieder das richtige Gel√§nde an. </font><font style="vertical-align: inherit;">Der gro√üe Unterschied besteht darin, dass das Bearbeiten nur von Gel√§ndetypen nicht mehr zu neuen Triangulationen f√ºhrt. </font><font style="vertical-align: inherit;">Wenn w√§hrend der Bearbeitung andere Zellendaten ge√§ndert werden, wird die Triangulation wie gewohnt durchgef√ºhrt. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Basis dieser Zellen erstellt haben, k√∂nnen wir fortfahren, um die Sichtbarkeit zu unterst√ºtzen. </font><font style="vertical-align: inherit;">Dazu verwenden wir den Shader, die Zellen selbst und die Objekte, die die Sichtbarkeit bestimmen. </font><font style="vertical-align: inherit;">Beachten Sie, dass der Triangulationsprozess absolut nichts dar√ºber wei√ü.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir damit, dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader die </font><font style="vertical-align: inherit;">Sichtbarkeit zu erl√§utern. </font><font style="vertical-align: inherit;">Es empf√§ngt Sichtbarkeitsdaten vom Scheitelpunktprogramm und √ºbergibt sie unter Verwendung der Struktur an das Fragmentprogramm </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da wir drei separate H√∂henindizes √ºbergeben, √ºbergeben wir auch drei Sichtbarkeitswerte.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float4 color : <span class="hljs-type"><span class="hljs-type">COLOR</span></span>; float3 worldPos; float3 terrain; float3 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Sichtbarkeit zu speichern, verwenden wir die erste Komponente dieser Zellen. </font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { UNITY_INITIALIZE_OUTPUT(Input, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); float4 cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); float4 cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); float4 cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.x = cell0.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.y = cell1.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.z = cell2.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Sichtbarkeit von 0 bedeutet, dass die Zelle derzeit unsichtbar ist. </font><font style="vertical-align: inherit;">Wenn es sichtbar w√§re, h√§tte es den Wert von Sichtbarkeit 1. Daher k√∂nnen wir das Gel√§nde abdunkeln, indem wir das Ergebnis </font></font><code>GetTerrainColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem entsprechenden Sichtbarkeitsvektor </font><font style="vertical-align: inherit;">multiplizieren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher modulieren wir die Relieffarbe jeder gemischten Zelle individuell.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/183/e69/1bf183e695a42f4691f63cec72255993.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zellen wurden schwarz.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√∂nnen wir nicht stattdessen die Sichtbarkeit in einem Vertex-Programm kombinieren?</font></font></b> <div class="spoiler_text">   ,           .              .           .        ,      .   ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollst√§ndige Dunkelheit ist eine B√ºste f√ºr vor√ºbergehend unsichtbare Zellen. </font><font style="vertical-align: inherit;">Damit wir das Relief noch sehen k√∂nnen, m√ºssen wir den Indikator f√ºr versteckte Zellen erh√∂hen. </font><font style="vertical-align: inherit;">Wechseln wir von 0‚Äì1 zu ¬º - 1, was mit der Funktion </font></font><code>lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende des Scheitelpunktprogramms erfolgen kann.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/090/3e2/a200903e2f31f3bdcd0c996d42f91a02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schattierte Zellen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfolgung der Sichtbarkeit von Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Sichtbarkeit funktioniert, m√ºssen die Zellen ihre Sichtbarkeit verfolgen. Aber wie bestimmt eine Zelle, ob sie sichtbar ist? Wir k√∂nnen dies tun, indem wir die Anzahl der Entit√§ten verfolgen, die es sehen. Wenn jemand eine Zelle sieht, muss er diese Zelle melden. Und wenn jemand aufh√∂rt, die Zelle zu sehen, muss er sie auch dar√ºber informieren. Die Zelle verfolgt einfach die Anzahl der Beobachter, unabh√§ngig davon, um welche Entit√§ten es sich handelt. Wenn eine Zelle einen Sichtbarkeitswert von mindestens 1 hat, ist sie sichtbar, andernfalls ist sie unsichtbar. Um dieses Verhalten zu implementieren, f√ºgen wir der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen zwei Methoden und eine Eigenschaft hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visibility; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie als N√§chstes der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die genau das Gleiche wie </font></font><code>RefreshTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus Gr√ºnden der Sichtbarkeit </font><font style="vertical-align: inherit;">tut </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Speichern Sie die Daten in der Komponente R der Datenzellen. </font><font style="vertical-align: inherit;">Da wir mit Bytes arbeiten, die in die Werte 0‚Äì1 konvertiert werden, geben wir die Sichtbarkeit an </font></font><code>(byte)255</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden diese Methode mit zunehmender und abnehmender Sichtbarkeit aufrufen und den Wert zwischen 0 und 1 √§ndern. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Squad-Sichtbarkeit schaffen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen wir es so, dass die Einheiten die Zelle sehen k√∂nnen, die sie besetzen. </font><font style="vertical-align: inherit;">Dies wird durch einen Anruf </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an den neuen Standort des Ger√§ts w√§hrend der Aufgabe erreicht </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir rufen auch nach dem alten Standort (falls vorhanden) </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.IncreaseVisibility(); transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/f95/a07/7bcf95a07fdf4c10ed1d53055dddf6a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheiten k√∂nnen sehen, wo sie sind. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endlich haben wir Sichtbarkeit genutzt! </font><font style="vertical-align: inherit;">Beim Hinzuf√ºgen zu einer Karte machen Einheiten ihre Zelle sichtbar. </font><font style="vertical-align: inherit;">Au√üerdem wird ihr Umfang teleportiert, wenn sie an ihren neuen Standort umziehen. </font><font style="vertical-align: inherit;">Ihr Umfang bleibt jedoch aktiv, wenn Einheiten von der Karte entfernt werden. </font><font style="vertical-align: inherit;">Um dies zu beheben, reduzieren wir die Sichtbarkeit ihres Standorts, wenn Einheiten zerst√∂rt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); } location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbereich </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher sehen wir nur die Zelle, in der sich die Abl√∂sung befindet, und dies schr√§nkt die M√∂glichkeiten ein. Zumindest m√ºssen wir benachbarte Zellen sehen. Im allgemeinen Fall k√∂nnen Einheiten alle Zellen in einem bestimmten Abstand sehen, der von der Einheit abh√§ngt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir der </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu, um alle von einer Zelle aus sichtbaren Zellen unter Ber√ºcksichtigung des Bereichs zu finden. Wir k√∂nnen diese Methode durch Duplizieren und √Ñndern erstellen </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. √Ñndern Sie die Parameter und geben Sie eine Liste der Zellen zur√ºck, f√ºr die Sie den Listenpool verwenden k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei jeder Iteration wird die aktuelle Zelle zur Liste hinzugef√ºgt. Es gibt keine endg√ºltige Zelle mehr, sodass die Suche niemals endet, wenn sie diesen Punkt erreicht. Wir werden auch die Logik der Umz√ºge und die Kosten des Umzugs los. Machen Sie die Eigenschaften</font></font><code>PathFrom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie wurden nicht mehr gefragt, weil wir sie nicht brauchen und wir den Weg entlang des Gitters nicht st√∂ren wollen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei jedem Schritt erh√∂ht sich der Abstand einfach um 1. Wenn er den Bereich √ºberschreitet, wird diese Zelle √ºbersprungen. </font><font style="vertical-align: inherit;">Und wir brauchen keine Suchheuristik, also initialisieren wir sie mit einem Wert von 0. Das hei√üt, wir sind im Wesentlichen zum Dijkstra-Algorithmus zur√ºckgekehrt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; visibleCells = ListPool&lt;HexCell&gt;.Get(); searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; visibleCells.Add(current); <span class="hljs-comment"><span class="hljs-comment">// if (current == toCell) { // return true; // } // int currentTurn = (current.Distance - 1) / speed; for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); if ( neighbor == null || neighbor.SearchPhase &gt; searchFrontierPhase ) { continue; } // ‚Ä¶ // int moveCost; // ‚Ä¶ int distance = current.Distance + 1; if (distance &gt; range) { continue; } // int turn = (distance - 1) / speed; // if (turn &gt; currentTurn) { // distance = turn * speed + moveCost; // } if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; // neighbor.PathFrom = current; neighbor.SearchHeuristic = 0; searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); } } } return visibleCells; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√∂nnen wir nicht einen einfacheren Algorithmus verwenden, um alle Zellen in Reichweite zu finden?</font></font></b> <div class="spoiler_text"> ,          ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie auch </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methoden </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und hinzu </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie erhalten die Zelle und den Bereich, nehmen eine Liste der entsprechenden Zellen und erh√∂hen / verringern ihre Sichtbarkeit. </font><font style="vertical-align: inherit;">Wenn Sie fertig sind, sollten Sie die Liste wieder in ihren Pool zur√ºckbringen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].IncreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].DecreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Methoden verwenden zu k√∂nnen, </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss auf das Raster zugegriffen werden. F√ºgen Sie ihm daher eine Eigenschaft hinzu </font></font><code>Grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einem Raster einen Trupp hinzuf√ºgen, wird dieser Eigenschaft ein Raster zugewiesen </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst reicht ein Sichtbarkeitsbereich von drei Zellen aus. </font><font style="vertical-align: inherit;">Dazu f√ºgen wir die </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstante hinzu, die sich in Zukunft immer in eine Variable verwandeln kann. </font><font style="vertical-align: inherit;">Dann werden wir den Trupp dazu bringen, Methoden f√ºr das Gitter aufzurufen </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch seinen Sichtbarkeitsbereich zu √ºbertragen, und nicht nur an diesen Ort gehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visionRange = <span class="hljs-number"><span class="hljs-number">3</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { <span class="hljs-comment"><span class="hljs-comment">// location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); location.Unit = null; } location = value; value.Unit = this; // value.IncreaseVisibility(); Grid.IncreaseVisibility(value, visionRange); transform.localPosition = value.Position; } } ‚Ä¶ public void Die () { if (location) { // location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); } location.Unit = null; Destroy(gameObject); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/c45/ccb/8cdc45ccb01449b3c7d50a7bef9b249c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheiten mit Sichtbereich, die sich √ºberlappen k√∂nnen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit beim Bewegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Moment wird der Sichtbereich des Trupps nach dem Bewegungsbefehl sofort zum Endpunkt teleportiert. </font><font style="vertical-align: inherit;">Es h√§tte besser ausgesehen, wenn sich das Ger√§t und sein Sichtfeld zusammen bewegt h√§tten. </font><font style="vertical-align: inherit;">Der erste Schritt dazu ist, dass wir die Eigenschaft </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font><font style="vertical-align: inherit;">nicht mehr festlegen </font></font><code>HexUnit.Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen √§ndern wir das Feld direkt </font></font><code>location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und vermeiden den Eigenschaftscode. </font><font style="vertical-align: inherit;">Daher werden wir den alten Standort manuell l√∂schen und einen neuen Standort konfigurieren. </font><font style="vertical-align: inherit;">Die Sicht bleibt unver√§ndert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Location = path[path.Count - 1]; location.Unit = null; location = path[path.Count - 1]; location.Unit = this; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Innerhalb von Coroutinen </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduzieren wir die Sichtbarkeit der ersten Zelle erst nach Fertigstellung </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach, bevor wir zu einer neuen Zelle wechseln, erh√∂hen wir die Sichtbarkeit dieser Zelle. </font><font style="vertical-align: inherit;">Nachdem wir damit fertig sind, reduzieren wir erneut die Sichtbarkeit. </font><font style="vertical-align: inherit;">Erh√∂hen Sie schlie√ülich die Sichtbarkeit der letzten Zelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// transform.localPosition = c; yield return LookAt(pathToTravel[1].Position); Grid.DecreaseVisibility(pathToTravel[0], visionRange); float t = Time.deltaTime * travelSpeed; for (int i = 1; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - 1].Position; c = (b + pathToTravel[i].Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { ‚Ä¶ } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= 1f; } a = c; b = location.Position; // We can simply use the destination here. c = b; Grid.IncreaseVisibility(location, visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sichtbarkeit in Bewegung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All dies funktioniert, au√üer wenn in dem Moment, in dem sich die Abteilung bewegt, ein neuer Befehl erteilt wird. </font><font style="vertical-align: inherit;">Dies f√ºhrt zu einer Teleportation, die auch f√ºr die Sichtbarkeit gelten sollte. </font><font style="vertical-align: inherit;">Um dies zu realisieren, m√ºssen wir den aktuellen Standort des Teams verfolgen, w√§hrend wir uns bewegen.</font></font><br><br><pre> <code class="cs hljs"> HexCell location, currentTravelLocation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diesen Ort jedes Mal aktualisieren, wenn wir w√§hrend der Bewegung eine neue Zelle treffen, bis der Trupp die letzte Zelle erreicht. </font><font style="vertical-align: inherit;">Dann muss es zur√ºckgesetzt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + currentTravelLocation.Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Grid.IncreaseVisibility(pathToTravel[i], visionRange); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Abschluss der Abzweigung k√∂nnen </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir nun √ºberpr√ºfen, ob der alte Zwischenort des Pfades bekannt ist. </font><font style="vertical-align: inherit;">Wenn ja, m√ºssen Sie die Sichtbarkeit in dieser Zelle und nicht am Anfang des Pfads verringern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; Grid.DecreaseVisibility( currentTravelLocation ? currentTravelLocation : pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>], visionRange ); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen auch die Sichtbarkeit nach der Neukompilierung korrigieren, die w√§hrend der Bewegung des Trupps aufgetreten ist. </font><font style="vertical-align: inherit;">Wenn der Zwischenort noch bekannt ist, verringern Sie die Sichtbarkeit darin und erh√∂hen Sie die Sichtbarkeit am Endpunkt. Setzen Sie dann den Zwischenort zur√ºck.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTravelLocation) { Grid.IncreaseVisibility(location, visionRange); Grid.DecreaseVisibility(currentTravelLocation, visionRange); currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit von Stra√üen und Wasser </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl √Ñnderungen der Relieffarbe auf der Sichtbarkeit basieren, hat dies keine Auswirkungen auf Stra√üen und Wasser. </font><font style="vertical-align: inherit;">Sie sehen f√ºr unsichtbare Zellen zu hell aus. </font><font style="vertical-align: inherit;">Um die Sichtbarkeit auf Stra√üen und Wasser anzuwenden, m√ºssen wir Zellindizes hinzuf√ºgen und Gewichte zu ihren Netzdaten mischen. </font><font style="vertical-align: inherit;">Daher werden wir die Kinder der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use Cell Data</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fl√ºsse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√ºndungen des</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertighausfragments √ºberpr√ºfen.</font></font><br><br><h3>  Stra√üen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden von den Stra√üen starten. </font><font style="vertical-align: inherit;">Die Methode wird </font></font><code>HexGridChunk.TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet, um einen kleinen Teil der Stra√üe in der Mitte der Zelle zu erstellen, sodass ein Zellenindex erforderlich ist. </font><font style="vertical-align: inherit;">F√ºgen Sie einen Parameter hinzu und generieren Sie Zellendaten f√ºr das Dreieck.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); Vector3 indices; indices.x = indices.y = indices.z = index; roads.AddTriangleCellData(indices, weights1); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere einfache M√∂glichkeit, Stra√üen zu erstellen, ist </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wird sowohl innerhalb als auch zwischen Zellen verwendet, daher sollte es mit zwei verschiedenen Indizes funktionieren. </font><font style="vertical-align: inherit;">Hierzu ist es zweckm√§√üig, den Indexvektorparameter zu verwenden. </font><font style="vertical-align: inherit;">Da Stra√üensegmente Teile von Leisten sein k√∂nnen, m√ºssen auch Gewichte durch Parameter gef√ºhrt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6, Color w1, Color w2, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadCellData(indices, w1, w2); roads.AddQuadCellData(indices, w1, w2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahren wir nun mit fort </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch Stra√üen innerhalb der Zellen erstellt werden. </font><font style="vertical-align: inherit;">Es ben√∂tigt auch einen Indexparameter. </font><font style="vertical-align: inherit;">Er √ºbergibt diese Daten an die von ihm aufgerufenen Stra√üenmethoden und f√ºgt sie den von ihm erstellten Dreiecken hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 indices; indices.x = indices.y = indices.z = index; Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment( mL, mC, mR, e.v2, e.v3, e.v4, weights1, weights1, indices ); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleCellData(indices, weights1); roads.AddTriangleCellData(indices, weights1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR, index); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt die erforderliche Verfahren Argumente hinzuzuf√ºgen </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all Compiler - </font><font style="vertical-align: inherit;">Fehler zu korrigieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction), cell.Index ); } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL, cell.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center, cell.Index); } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ‚Ä¶ </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment( e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4, w1, w2, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sind die Netzdaten korrekt und wir werden mit dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader fortfahren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es ben√∂tigt ein Vertex-Programm und muss </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthalten </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">decal</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:blend</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">HexCellData</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cginc</span></span>"</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da wir nicht mehrere Materialien mischen, reicht es aus, einen Indikator f√ºr die Sichtbarkeit in das Fragmentprogramm zu √ºbergeben. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> {</span></span> float2 uv_MainTex; float3 worldPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es reicht aus, wenn ein neues Vertex-Programm Daten von zwei Zellen empf√§ngt. </font><font style="vertical-align: inherit;">Wir mischen sofort ihre Sichtbarkeit, passen sie an und erg√§nzen die Ausgabe.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im Fragmentprogramm m√ºssen wir der Farbe nur Sichtbarkeit hinzuf√ºgen. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/92f/46e/af892f46e364906cc547aaecb4e50e3a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üen mit Sichtbarkeit.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Offenes Wasser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es mag den Anschein haben, dass die Sicht das Wasser bereits beeintr√§chtigt hat, aber dies ist nur die Oberfl√§che eines in Wasser getauchten Gel√§ndes. </font><font style="vertical-align: inherit;">Beginnen wir mit der Sichtbarkeit auf offenes Wasser. </font><font style="vertical-align: inherit;">Daf√ºr m√ºssen wir uns √§ndern </font></font><code>HexGridChunk.TriangulateOpenWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ water.AddTriangle(center, c1, c2); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ‚Ä¶ water.AddQuad(c1, c2, e1, e2); indices.y = neighbor.Index; water.AddQuadCellData(indices, weights1, weights2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { ‚Ä¶ water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); indices.z = nextNeighbor.Index; water.AddTriangleCellData( indices, weights1, weights2, weights3 ); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir m√ºssen auch den F√§chern der Dreiecke in K√ºstenn√§he Zelldaten hinzuf√ºgen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">muss auf die gleiche Weise wie der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader ge√§ndert werden </font><font style="vertical-align: inherit;">, muss jedoch die Sichtbarkeit von nicht zwei, sondern drei Zellen kombinieren.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a4/c52/36c/6a4c5236c52eaae78cbde54fb2fdeeac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offenes Wasser mit Sicht.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> K√ºste und M√ºndung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die K√ºste zu unterst√ºtzen, m√ºssen wir uns wieder √§ndern </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir haben bereits einen Indexvektor erstellt, aber nur einen Zellindex f√ºr offenes Wasser verwendet. </font><font style="vertical-align: inherit;">Die K√ºste ben√∂tigt auch einen Nachbarindex, √§ndern Sie also den Code.</font></font><br><br><pre> <code class="cs hljs"> Vector3 indices; <span class="hljs-comment"><span class="hljs-comment">// indices.x = indices.y = indices.z = cell.Index; indices.x = indices.z = cell.Index; indices.y = neighbor.Index;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie die Zellendaten zu den Quads und dem Dreieck der K√ºste hinzu. </font><font style="vertical-align: inherit;">Wir √ºbergeben auch die Indizes beim Aufruf </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ‚Ä¶ waterShore.AddTriangleUV( ‚Ä¶ ); indices.z = nextNeighbor.Index; waterShore.AddTriangleCellData( indices, weights1, weights2, weights3 ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Zellen f√ºr die K√ºste und den Mund hinzu und k√ºmmern Sie sich um sie. </font><font style="vertical-align: inherit;">Vergessen Sie nicht, dass der Mund aus Trapez mit zwei Dreiecken der K√ºste an den Seiten besteht. </font><font style="vertical-align: inherit;">Wir sorgen daf√ºr, dass die Gewichte in der richtigen Reihenfolge √ºbertragen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadCellData( indices, weights2, weights1, weights2, weights1 ); estuaries.AddTriangleCellData(indices, weights1, weights2, weights2); estuaries.AddQuadCellData(indices, weights1, weights2); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WaterShore-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader m√ºssen </font><em><font style="vertical-align: inherit;">Sie</font></em><font style="vertical-align: inherit;"> dieselben √Ñnderungen wie im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader vornehmen und </font><font style="vertical-align: inherit;">die Sichtbarkeit der drei Zellen mischen.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader mischt die Sichtbarkeit von zwei Zellen, genau wie der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er hat bereits ein Scheitelpunktprogramm, weil wir ihn brauchen, um die UV-Koordinaten der Fl√ºsse zu √ºbertragen.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.visibility = cell0.x * v.color.x + cell1.x * v.color.y; o.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, o.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88f/829/254/88f829254235a293040ac755d8318bc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√ºste und M√ºndung mit Sichtbarkeit.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzten Wasserregionen, mit denen gearbeitet wird, sind die Fl√ºsse. </font><font style="vertical-align: inherit;">F√ºgen Sie dem </font></font><code>HexGridChunk.TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter einen Indexvektor hinzu und f√ºgen Sie ihn dem Netz hinzu, damit die Sichtbarkeit von zwei Zellen erhalten bleibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed, indices); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br> <code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt Flussendpunkte mit einem Quad und einem Dreieck in der Mitte der Zelle. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu die notwendigen Zellendaten hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; Vector3 indices; indices.x = indices.y = indices.z = cell.Index; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); ‚Ä¶ rivers.AddTriangleCellData(indices, weights1); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben diese Zellindizes bereits in </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, also geben wir sie einfach beim Anruf weiter </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed, indices ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir f√ºgen auch Wasserf√§llen, die in tiefes Wasser m√ºnden, Indexunterst√ºtzung hinzu. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schlie√ülich √§ndern Sie es </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es die erforderlichen Indizes an die Methoden von Fl√ºssen und Wasserf√§llen weitergibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { e2.v3.y = neighbor.StreamBedY; Vector3 indices; indices.x = indices.z = cell.Index; indices.y = neighbor.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY, indices ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY, indices ); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">muss dieselben √Ñnderungen vornehmen wie der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ef/db6/76a/1efdb676afe28b61b73f317d25158505.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fl√ºsse mit Sichtbarkeit. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekte und Sichtbarkeit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt funktioniert die Sichtbarkeit f√ºr das gesamte prozedural generierte Gel√§nde, hat jedoch bisher keine Auswirkungen auf die Gel√§ndemerkmale. Geb√§ude, Farmen und B√§ume werden aus Fertigh√§usern und nicht aus prozeduraler Geometrie erstellt. Daher k√∂nnen wir keine Zellindizes hinzuf√ºgen und Gewichte mit ihren Scheitelpunkten mischen. Da jedes dieser Objekte nur zu einer Zelle geh√∂rt, m√ºssen wir bestimmen, in welcher Zelle sie sich befinden. Wenn wir dies tun k√∂nnen, erhalten wir Zugriff auf die Daten der entsprechenden Zellen und wenden die Sichtbarkeit an.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die XZ-Positionen der Welt bereits in Zellindizes umwandeln. Diese Transformation wurde verwendet, um das Gel√§nde zu bearbeiten und Trupps zu verwalten. Der entsprechende Code ist jedoch nicht trivial. Es verwendet ganzzahlige Operationen und erfordert Logik, um mit Kanten zu arbeiten. Dies ist f√ºr einen Shader unpraktisch, daher k√∂nnen wir den Gro√üteil der Logik in einer Textur backen und verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden bereits eine Textur mit einem sechseckigen Muster, um das Gitter √ºber die Topographie zu projizieren. Diese Textur definiert eine Zellfl√§che von 2 √ó 2. Daher k√∂nnen wir leicht berechnen, in welchem ‚Äã‚ÄãGebiet wir uns befinden. Danach k√∂nnen Sie eine Textur mit X- und Z-Offsets f√ºr die Zellen in diesem Bereich anwenden und diese Daten verwenden, um die Zelle zu berechnen, in der wir uns befinden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist eine √§hnliche Textur. Der X-Offset wird in seinem roten Kanal und der Z-Offset in seinem gr√ºnen Kanal gespeichert. Da es den Bereich von 2 √ó 2 Zellen abdeckt, ben√∂tigen wir Offsets von 0 und 2. Solche Daten k√∂nnen nicht im Farbkanal gespeichert werden, sodass die Offsets um die H√§lfte reduziert werden. Wir brauchen keine klaren Kanten der Zellen, daher reicht eine kleine Textur aus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/63c/d3c/79563cd3c22e7aa2ca66e40b5ffe3f7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Textur der Gitterkoordinaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem Projekt eine Textur hinzu. </font><font style="vertical-align: inherit;">Stellen Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wrap-Modus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie bei der anderen </font><em><font style="vertical-align: inherit;">Netzstruktur</font></em><font style="vertical-align: inherit;"> auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir brauchen keine Vermischung, so dass der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischmodus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Wert w√§hlen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punkt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Deaktivieren Sie auch die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komprimierung,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> damit die Daten nicht verzerrt werden. </font><font style="vertical-align: inherit;">Deaktivieren Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sRGB-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modus, </font><font style="vertical-align: inherit;">damit beim Rendern im linearen Modus keine Farbraumkonvertierungen durchgef√ºhrt werden. </font><font style="vertical-align: inherit;">Und schlie√ülich brauchen wir keine Mip-Texturen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/866/aa9/de3/866aa9de36f6953f54d4fb8197fb75ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optionen zum Importieren von Texturen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Object Shader mit Sichtbarkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen neuen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">, um Objekten Sichtbarkeitsunterst√ºtzung hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">Dies ist ein einfacher Oberfl√§chen-Shader mit einem Vertex-Programm. </font><font style="vertical-align: inherit;">F√ºgen Sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData hinzu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und √ºbergeben Sie die Sichtbarkeitsanzeige an das Fragmentprogramm. Betrachten Sie sie wie gewohnt in Farbe. </font><font style="vertical-align: inherit;">Der Unterschied besteht darin, dass wir es nicht verwenden </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen, da die erforderlichen Netzdaten nicht vorhanden sind. </font><font style="vertical-align: inherit;">Stattdessen haben wir eine Position in der Welt. </font><font style="vertical-align: inherit;">Lassen Sie die Sichtbarkeit jedoch vorerst gleich 1.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Feature" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> [NoTilingOffset] _GridCoordinates ("Grid Coordinates", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" sampler2D _MainTex, _GridCoordinates; half _Glossiness; half _Metallic; fixed4 _Color; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñndern Sie alle Materialien der Objekte so, dass sie den neuen Shader verwenden, und weisen Sie ihnen die Textur der Gitterkoordinaten zu. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/fad/546/e35fad5469e6c9e5c6a31626ba182ec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urban mit Mesh-Textur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zugriff auf Zellendaten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Textur der Gitterkoordinaten im Scheitelpunktprogramm abzutasten, ben√∂tigen wir erneut </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen vierkomponentigen Texturkoordinatenvektor. </font><font style="vertical-align: inherit;">Die ersten beiden Koordinaten sind die Position der XZ-Welt. </font><font style="vertical-align: inherit;">Die anderen beiden sind wie zuvor gleich Null.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">strecken wir die UV-Koordinaten so, dass die Textur das richtige Seitenverh√§ltnis aufweist, das dem Sechseckgitter entspricht.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen herausfinden, in welchem ‚Äã‚ÄãTeil der 2 √ó 2-Zellen wir uns befinden, indem wir den Wert der abgerundeten UV-Koordinaten nehmen. </font><font style="vertical-align: inherit;">Dies bildet die Basis f√ºr die Koordinaten der Zellen.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); float2 cellDataCoordinates = floor(gridUV.xy);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Koordinaten der Zelle zu finden, in der wir uns befinden, f√ºgen wir die in der Textur gespeicherten Verschiebungen hinzu. </font></font><br><br><pre> <code class="hljs pgsql"> float2 cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da ein Teil des Gitters 2 √ó 2 gro√ü ist und die Offsets halbiert sind, m√ºssen wir das Ergebnis verdoppeln, um die endg√ºltigen Koordinaten zu erhalten. </font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">float2</span></span> cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg; <span class="hljs-attribute"><span class="hljs-attribute">cellDataCoordinates</span></span> *= <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir die XZ-Koordinaten des Zellgitters, die wir in die UV-Koordinaten dieser Zellen umwandeln m√ºssen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem einfach in die Mitte der Pixel verschoben und diese dann in Texturgr√∂√üen unterteilt werden. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> also der </font><em><font style="vertical-align: inherit;">HexCellData-</font></em><font style="vertical-align: inherit;"> Include-Datei eine </font><font style="vertical-align: inherit;">Funktion </font><em><font style="vertical-align: inherit;">hinzu</font></em><font style="vertical-align: inherit;"> , die auch das Sampling √ºbernimmt.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { float2 uv = cellDataCoordinates + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; uv.x *= _HexCellData_TexelSize.x; uv.y *= _HexCellData_TexelSize.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir dies in dem Vertex - </font><font style="vertical-align: inherit;">Shader - </font><font style="vertical-align: inherit;">Programm verwenden </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Eigenschaft</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs haskell"> cellDataCoordinates *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCellData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cellDataCoordinates</span></span></span><span class="hljs-class">).x; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/9c9/7ed/1ed9c97ed37aa88aaee6c0efd9d075d7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte mit Sichtbarkeit.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schlie√ülich wirkt sich die Sichtbarkeit auf die gesamte Karte aus, mit Ausnahme der Einheiten, die immer sichtbar sind. Da wir die Sichtbarkeit von Objekten f√ºr jeden Scheitelpunkt bestimmen, wird f√ºr das Objekt, das die Zellgrenze √ºberschreitet, die Sichtbarkeit der Zellen, die es schlie√üt, gemischt. Die Objekte sind jedoch so klein, dass sie st√§ndig in ihrer Zelle verbleiben, selbst unter Ber√ºcksichtigung von Positionsverzerrungen. Einige k√∂nnen jedoch Teil der Eckpunkte in einer anderen Zelle sein. Daher ist unser Ansatz billig, aber unvollkommen. Dies macht sich vor allem bei W√§nden bemerkbar, deren Sichtbarkeit zwischen den Sichtbarkeiten benachbarter Zellen variiert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/421/1c7/f7d/4211c7f7dea80bbbd13664586074c43a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde mit wechselnder Sichtbarkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Wandsegmente prozedural generiert werden, k√∂nnen wir ihrem Netz Zelldaten hinzuf√ºgen und den Ansatz verwenden, den wir f√ºr das Relief verwendet haben. </font><font style="vertical-align: inherit;">Leider sind die T√ºrme vorgefertigt, so dass wir immer noch Inkonsistenzen haben werden. </font><font style="vertical-align: inherit;">Im Allgemeinen sieht der vorhandene Ansatz f√ºr die von uns verwendete einfache Geometrie gut genug aus. </font><font style="vertical-align: inherit;">In Zukunft werden wir detailliertere Modelle und W√§nde betrachten, daher werden wir die Methode zum Mischen ihrer Sichtbarkeit verbessern. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 21: Kartenforschung </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir zeigen alles w√§hrend der Bearbeitung an. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verfolgen die untersuchten Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verstecken, was noch unbekannt ist. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir zwingen Einheiten, unerforschte Gebiete zu meiden. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im vorherigen Teil haben wir den Nebel des Krieges hinzugef√ºgt, den wir nun verfeinern werden, um Kartenforschung durchzuf√ºhren. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81d/40e/bff/81d40ebff615fc7c4e39a15d88da016d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind bereit, die Welt zu erkunden.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie die gesamte Karte im Bearbeitungsmodus an </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedeutung der Studie ist, dass bis die Zellen nicht gesehen werden, sie als unbekannt und daher unsichtbar angesehen werden. </font><font style="vertical-align: inherit;">Sie sollten nicht verdeckt, aber √ºberhaupt nicht angezeigt werden. </font><font style="vertical-align: inherit;">Daher werden wir vor dem Hinzuf√ºgen von Forschungsunterst√ºtzung die Sichtbarkeit im Bearbeitungsmodus aktivieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeitsumschaltung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Schl√ºsselwort k√∂nnen wir steuern, ob die Shader die Sichtbarkeit verwenden, wie dies mit der √úberlagerung im Raster geschehen ist. </font><font style="vertical-align: inherit;">Verwenden Sie das Schl√ºsselwort </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">um den Status des Bearbeitungsmodus anzuzeigen. </font><font style="vertical-align: inherit;">Da mehrere Shader √ºber dieses Schl√ºsselwort Bescheid wissen sollten, definieren wir es global mit statischen Methoden </font></font><code>Shader.EnableKeyWord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Shader.DisableKeyword</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden die entsprechende Methode aufrufen, </font></font><code>HexGameUI.SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">den Bearbeitungsmodus √§ndern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (toggle) { Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Shader.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bearbeitungsmodus-Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert ist, ignorieren Shader die Sichtbarkeit. </font><font style="vertical-align: inherit;">Dies l√§uft darauf hinaus, dass die Sichtbarkeit </font><font style="vertical-align: inherit;">von Zellen </font><font style="vertical-align: inherit;">immer als gleich 1 betrachtet wird. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir eine </font><font style="vertical-align: inherit;">Funktion hinzu, um die Daten von Zellen abh√§ngig vom Schl√ºsselwort </font><font style="vertical-align: inherit;">am Anfang der </font><em><font style="vertical-align: inherit;">HexCellData-</font></em><font style="vertical-align: inherit;"> Include-Datei zu </font><em><font style="vertical-align: inherit;">filtern</font></em><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs kotlin">sampler2D _HexCellData; float4 _HexCellData_TexelSize; float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir durchlaufen diese Funktion als Ergebnis beider Funktionen, </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bevor </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">sie zur√ºckgeben.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(data); } <span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit alles funktioniert, m√ºssen alle relevanten Shader die Anweisung multi_compile erhalten, um Optionen zu erstellen, falls das Schl√ºsselwort </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert ist. </font><font style="vertical-align: inherit;">F√ºgen Sie den Shadern von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zwischen der Zielrichtlinie und der ersten Include-Direktive </font><font style="vertical-align: inherit;">die entsprechende Linie hinzu </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie jetzt in den Kartenbearbeitungsmodus wechseln, verschwindet der Nebel des Krieges. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellforschung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardm√§√üig sollten Zellen als unerforscht betrachtet werden. </font><font style="vertical-align: inherit;">Sie werden erforscht, wenn ein Trupp sie sieht. </font><font style="vertical-align: inherit;">Danach bleiben sie weiterhin untersucht, ob eine Abteilung sie sehen kann.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfolgung des Studienstatus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die √úberwachung des Status von Studien zu unterst√ºtzen, f√ºgen wir die </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeine Eigenschaft hinzu </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Stand der Studie wird von der Zelle selbst bestimmt. </font><font style="vertical-align: inherit;">Daher sollte diese Eigenschaft nur festgelegt werden </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um diese Einschr√§nkung hinzuzuf√ºgen, setzen wir den Setter auf privat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Sichtbarkeit der Zelle zum ersten Mal gr√∂√üer als Null wird, wird die Zelle als untersucht betrachtet. Daher sollte </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Wert zugewiesen werden </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tats√§chlich reicht es aus, die Zelle einfach als gepr√ºft zu markieren, wenn die Sichtbarkeit auf 1 steigt. Dies muss vor dem Anruf erfolgen </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { IsExplored = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úbertragung des Forschungsstatus auf Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei der Sichtbarkeit von Zellen √ºbertragen wir ihren Forschungsstatus √ºber die Shader-Daten auf die Shader. </font><font style="vertical-align: inherit;">Am Ende ist es nur eine andere Art der Sichtbarkeit. </font></font><code>HexCellShaderData.RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichert den Sichtbarkeitsstatus im Datenkanal R. </font><font style="vertical-align: inherit;">Lassen Sie uns den Stand der Studie in Kanal G-Daten beibehalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwarzes unerforschtes Relief </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir Shader verwenden, um den Stand der Zellforschung zu visualisieren. </font><font style="vertical-align: inherit;">Um sicherzustellen, dass alles so funktioniert, wie es sollte, machen wir das unerforschte Gel√§nde nur schwarz. </font><font style="vertical-align: inherit;">Um den Bearbeitungsmodus zu aktivieren, √§ndern Sie ihn zun√§chst </font></font><code>FilterCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass die Forschungsdaten herausgefiltert werden.</font></font><br><br><pre> <code class="hljs kotlin">float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.xy = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">√ºbergibt die Sichtbarkeitsdaten aller drei m√∂glichen Zellen an das Fragmentprogramm. </font><font style="vertical-align: inherit;">Im Falle des Forschungszustands kombinieren wir sie im Vertex-Programm und √ºbertragen den einzigen Wert in das Fragment-Programm. </font><font style="vertical-align: inherit;">F√ºgen Sie der Eingabe die </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vierte Komponente hinzu, damit wir einen Platz daf√ºr haben.</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; <span class="hljs-type"><span class="hljs-type">float4</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jetzt im Vertex-Programm den Sichtbarkeitsindex √§ndern, m√ºssen wir explizit darauf zugreifen </font></font><code>data.visibility.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { ‚Ä¶ data.visibility.xyz = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.xyz); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach kombinieren wir die Zust√§nde der Studie und schreiben das Ergebnis in </font></font><code>data.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies √§hnelt dem Kombinieren der Sichtbarkeit in anderen Shadern, verwendet jedoch die Komponente Y dieser Zellen.</font></font><br><br><pre> <code class="hljs haskell"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.xyz = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xyz</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.w = cell0.y * v.color.x + cell1.y * v.color.y + cell2.y * v.color.z;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Forschungsstatus ist jetzt im Fragmentprogramm durch verf√ºgbar </font></font><code>IN.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ber√ºcksichtigen Sie dies bei der Berechnung der Albedo.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/de4/c18/b2dde4c1831a9ecc637550b2b8e2e134.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die unerforschte Topographie ist jetzt schwarz. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Relief von unerforschten Zellen hat jetzt eine schwarze Farbe. </font><font style="vertical-align: inherit;">Objekte, Stra√üen und Wasser sind davon jedoch noch nicht betroffen. </font><font style="vertical-align: inherit;">Dies reicht jedoch aus, um sicherzustellen, dass die Studie funktioniert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forschungsstatus speichern und laden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Forschungsunterst√ºtzung hinzugef√ºgt haben, m√ºssen wir sicherstellen, dass der Forschungsstatus beim Speichern und Laden von Karten ber√ºcksichtigt wird. </font><font style="vertical-align: inherit;">Daher m√ºssen wir die Version der Kartendateien auf 3 erh√∂hen. Um diese √Ñnderungen bequemer zu gestalten, f√ºgen wir hierf√ºr eine </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstante hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Konstante beim Schreiben der Dateiversion in </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und beim Einchecken der Dateisupport verwenden </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(mapFileVersion); hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= mapFileVersion) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als letzten Schritt </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeichnen wir den Status der Studie auf.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ writer.Write(IsExplored); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wir werden es am Ende lesen </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach rufen wir </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an, falls sich der Stand der Studie vom vorherigen unterscheidet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ IsExplored = reader.ReadBoolean(); ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Abw√§rtskompatibilit√§t mit alten Sicherungsdateien aufrechtzuerhalten, m√ºssen wir das Lesen des Sicherungsstatus √ºberspringen, wenn die Dateiversion kleiner als 3 ist. In diesem Fall haben die Zellen standardm√§√üig den Status "unerforscht". </font><font style="vertical-align: inherit;">Dazu m√ºssen wir </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header-Daten </font><font style="vertical-align: inherit;">als Parameter hinzuf√ºgen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ IsExplored = header &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen die </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header-Daten √ºbergeben werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Speichern und Laden von Karten wird nun der Erkundungsstatus der Zellen ber√ºcksichtigt. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unbekannte Zellen verstecken </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegenw√§rtig sind unerforschte Zellen visuell durch ein schwarzes Relief gekennzeichnet. </font><font style="vertical-align: inherit;">In Wirklichkeit wollen wir, dass diese Zellen unsichtbar sind, weil sie unbekannt sind. </font><font style="vertical-align: inherit;">Wir k√∂nnen die undurchsichtige Geometrie transparent machen, damit sie nicht sichtbar ist. </font><font style="vertical-align: inherit;">Das Unity Surface Shader Framework wurde jedoch ohne diese M√∂glichkeit entwickelt. </font><font style="vertical-align: inherit;">Anstatt echte Transparenz zu verwenden, werden wir die Shader so √§ndern, dass sie dem Hintergrund entsprechen, wodurch sie auch unsichtbar werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Relief wirklich schwarz machen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl das untersuchte Relief schwarz ist, k√∂nnen wir es immer noch erkennen, da es immer noch spiegelnde Beleuchtung hat. Um die Beleuchtung loszuwerden, m√ºssen wir sie perfekt mattschwarz machen. Um andere Oberfl√§cheneigenschaften nicht zu beeintr√§chtigen, ist es am einfachsten, die Spiegelfarbe in Schwarz zu √§ndern. Dies ist m√∂glich, wenn Sie einen Oberfl√§chen-Shader verwenden, der mit Specular funktioniert. Jetzt verwenden wir jedoch das Standard-Metallic. Beginnen wir also damit, den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">auf Specular umzustellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ersetzen Sie </font><font style="vertical-align: inherit;">die Farbeigenschaft </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Metallic</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Eigenschaft </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Specular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Standardm√§√üig sollte der Farbwert gleich (0,2, 0,2, 0,2) sein. Wir garantieren also, dass es zum Erscheinungsbild der Metallic-Version passt.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie auch die entsprechenden Shader-Variablen. </font><font style="vertical-align: inherit;">Die Farbe von spiegelnden Oberfl√§chen-Shadern ist definiert als </font></font><code>fixed3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, also verwenden wir sie.</font></font><br><br><pre> <code class="hljs objectivec"> half _Glossiness; <span class="hljs-comment"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie die Pragma-Oberfl√§chenbrandung von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StandardSpecular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dadurch wird Unity gezwungen, Shader mithilfe von Specular zu generieren.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ben√∂tigt die Funktion </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den zweiten Parameter vom Typ </font></font><code>SurfaceOutputStandardSpecular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au√üerdem m√ºssen Sie jetzt den Wert nicht zuweisen </font></font><code>o.Metallic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sondern </font></font><code>o.Specular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; // o.Metallic = _Metallic; o.Specular = _Specular; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Glanzlichter verdecken, indem wir die Spiegelfarbe ber√ºcksichtigen </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs"> o.Specular = _Specular * explored;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/d05/128/289d0512816a7d6f692b0e7639e882eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unerforschtes Gel√§nde ohne reflektierte Beleuchtung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie auf dem Bild sehen k√∂nnen, sieht das unerforschte Relief jetzt mattschwarz aus. </font><font style="vertical-align: inherit;">Bei Betrachtung in einem Tangentenwinkel verwandeln sich die Oberfl√§chen jedoch in einen Spiegel, wodurch das Relief beginnt, die Umgebung, dh die Skybox, zu reflektieren.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum werden Oberfl√§chen zu Spiegeln?</font></font></b> <div class="spoiler_text">    .  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering</a> . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/255/d63/627/255d636278eb947c27117d6c596a9489.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unerforschte Gebiete spiegeln immer noch die Umwelt wider. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Reflexionen loszuwerden, betrachten wir das unerforschte Relief als vollst√§ndig schattiert. </font><font style="vertical-align: inherit;">Dies wird erreicht, indem </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Okklusionsparameter </font><font style="vertical-align: inherit;">ein Wert </font><font style="vertical-align: inherit;">zugewiesen wird, den wir als Reflexionsmaske verwenden.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/ab6/a5a/118ab6a5a91711eda2165433a7b99513.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne Reflexionen unerforscht.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passender Hintergrund </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da das unerforschte Gel√§nde die gesamte Beleuchtung ignoriert, m√ºssen Sie es an den Hintergrund anpassen. </font><font style="vertical-align: inherit;">Da unsere Kamera immer von oben schaut, ist der Hintergrund immer grau. </font><em><font style="vertical-align: inherit;">F√ºgen Sie die</font></em><font style="vertical-align: inherit;"> Eigenschaft </font><em><font style="vertical-align: inherit;">_BackgroundColor hinzu</font></em><font style="vertical-align: inherit;"> , die standardm√§√üig Schwarz ist, </font><font style="vertical-align: inherit;">um dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader mitzuteilen, </font><font style="vertical-align: inherit;">welche Farbe verwendet werden soll </font><font style="vertical-align: inherit;">.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><pre> <code class="hljs dos"> Properties { ‚Ä¶ _BackgroundColor ("Background <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>", <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) } ‚Ä¶ half _Glossiness; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Farbe zu verwenden, f√ºgen wir sie als emittierendes Licht hinzu. </font><font style="vertical-align: inherit;">Dies wird </font></font><code>o.Emission</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erreicht, indem ein Hintergrundfarbwert multipliziert mit einem minus erkundet zugewiesen wird.</font></font><br><br><pre> <code class="hljs"> o.Occlusion = explored; o.Emission = _BackgroundColor * (1 - explored);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir die Standard-Skybox verwenden, ist die sichtbare Hintergrundfarbe tats√§chlich nicht dieselbe. </font><font style="vertical-align: inherit;">Im Allgemeinen w√§re ein leicht r√∂tliches Grau die beste Farbe. </font><font style="vertical-align: inherit;">Beim Einrichten des Reliefmaterials k√∂nnen Sie den </font><font style="vertical-align: inherit;">Code 68615BFF </font><font style="vertical-align: inherit;">f√ºr </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Color verwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/307/7dd/eeb3077dd097a7649575a371cbb361f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reliefmaterial mit grauer Hintergrundfarbe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen funktioniert dies, obwohl Sie, wenn Sie wissen, wo Sie suchen m√ºssen, sehr schwache Silhouetten bemerken werden. </font><font style="vertical-align: inherit;">Damit der Player sie nicht sehen kann, k√∂nnen Sie der Kamera anstelle der Skybox eine einheitliche Hintergrundfarbe von 68615BFF zuweisen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b9/8cc/ec9/7b98ccec9228ac333cc23ec19cc6f28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamera mit einheitlicher Hintergrundfarbe.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht die Skybox entfernen?</font></font></b> <div class="spoiler_text">   ,   ,     environmental lighting .     ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir den Unterschied zwischen dem Hintergrund und unerforschten Zellen nicht finden. </font><font style="vertical-align: inherit;">Eine hohe unerforschte Topographie kann eine niedrige erforschte Topographie bei niedrigen Kamerawinkeln immer noch verdecken. </font><font style="vertical-align: inherit;">Dar√ºber hinaus werfen unerforschte Teile immer noch Schatten auf die Erkundeten. </font><font style="vertical-align: inherit;">Diese minimalen Hinweise k√∂nnen jedoch vernachl√§ssigt werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f88/764/d67/f88764d67aec0bf90267d273e1a248d5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht erforschte Zellen sind nicht mehr sichtbar.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn Sie keine einheitliche Hintergrundfarbe verwenden?</font></font></b> <div class="spoiler_text">    ,        ,      .        .      ,          .       ,     ,  ,  UV-           . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reliefobjekte verstecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir nur noch das Netz des Reliefs versteckt. </font><font style="vertical-align: inherit;">Der Rest der Studie ist noch nicht betroffen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/282/c0c/a0f/282c0ca0fb55bf26ee0bb1d43cadd42f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher ist nur das Relief verborgen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader √§ndern </font><font style="vertical-align: inherit;">, der ein undurchsichtiger Shader wie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain ist</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Verwandeln Sie es in einen Spiegel-Shader und f√ºgen Sie die Hintergrundfarbe hinzu. </font><font style="vertical-align: inherit;">Beginnen wir mit den Eigenschaften.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Albedo (RGB)"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [NoScaleOffset] _GridCoordinates (<span class="hljs-string"><span class="hljs-string">"Grid Coordinates"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weitere Pragma-Oberfl√§che und Variablen wie zuvor. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert ‚Ä¶ half _Glossiness; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</span></span></span></span></code> </pre> <br> <code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Komponente ist ebenfalls erforderlich. </font><font style="vertical-align: inherit;">Da </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature die</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit f√ºr jeden Scheitelpunkt kombiniert, wurde nur ein Gleitkommawert ben√∂tigt. </font><font style="vertical-align: inherit;">Jetzt brauchen wir zwei.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float2 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie es </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es explizit f√ºr die Sichtbarkeitsdaten verwendet wird </font></font><code>data.visibility.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und weisen Sie dann den </font></font><code>data.visibility.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert der Studiendaten zu.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { ‚Ä¶ float4 cellData = GetCellData(cellDataCoordinates); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cellData.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cellData.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie es </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es die neuen Daten wie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain verwendet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x * explored); // o.Metallic = _Metallic; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Emission = _BackgroundColor * (<span class="hljs-number"><span class="hljs-number">1</span></span> - explored); o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d13/863/dc6/d13863dc60bbb92750cd5c8f8b69d82b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versteckte Reliefobjekte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasser verstecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes kommen die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beginnen wir mit der Konvertierung in Spiegel-Shader. </font><font style="vertical-align: inherit;">Sie ben√∂tigen jedoch keine Hintergrundfarbe, da es sich um transparente Shader handelt. </font><font style="vertical-align: inherit;">F√ºgen Sie nach </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Konvertierung </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine weitere Komponente hinzu und √§ndern Sie sie entsprechend </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beide Shader kombinieren Daten aus drei Zellen.</font></font><br><br><pre> <code class="hljs dos"> struct Input { ‚Ä¶ float2 visibility; }; ‚Ä¶ void vert (inout appdata_full v, out Input data) { ‚Ä¶ data.visibility.x = cell0.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; data.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.x); data.visibility.y = cell0.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; }</code> </pre> <br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasserufer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºhren </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unterschiedliche Vorg√§nge aus, stellen jedoch ihre Oberfl√§cheneigenschaften auf dieselbe Weise ein. </font><font style="vertical-align: inherit;">Da sie transparent sind, werden wir sie </font></font><code>explore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Alphakanal </font><font style="vertical-align: inherit;">ber√ºcksichtigen </font><font style="vertical-align: inherit;">und keine Emissionen festlegen.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/e39/390/15ae39390ccbe91f3d12f068992a7c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verstecktes Wasser.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verstecken Flussm√ºndungen, Fl√ºsse und Stra√üen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben immer noch die Shader f√ºr </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√ºndung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluss</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stra√üe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Alle drei sind transparent und kombinieren die Daten zweier Zellen. </font><font style="vertical-align: inherit;">Schalten Sie sie alle auf spiegelnd um und f√ºgen Sie sie dann den </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forschungsdaten hinzu.</font></font><br><br><pre> <code class="hljs kotlin"> struct Input { ‚Ä¶ float2 visibility; }; ‚Ä¶ void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x * v.color.x + cell1.x * v.color.y; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell0.y * v.color.x + cell1.y * v.color.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie die Funktion der </font><em><font style="vertical-align: inherit;">Flussm√ºndungs-</font></em><font style="vertical-align: inherit;"> und </font><em><font style="vertical-align: inherit;">Fluss-</font></em></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">so, dass die neuen Daten verwendet werden. </font><font style="vertical-align: inherit;">Beide m√ºssen die gleichen √Ñnderungen vornehmen.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road ist</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etwas anders, da sie eine zus√§tzliche Mischmetrik verwendet.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x); <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend *= noise.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend); <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = blend * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/1d2/c65/1c61d2c652b436385b42188c39476c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles ist versteckt. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie unerforschte Zellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl alles Unbekannte visuell verborgen ist, wird der Stand der Studie bei der Suche nach einem Pfad nicht ber√ºcksichtigt. </font><font style="vertical-align: inherit;">Infolgedessen k√∂nnen Einheiten angewiesen werden, sich durch und durch unerforschte Zellen zu bewegen, wodurch auf magische Weise bestimmt wird, in welche Richtung sie sich bewegen sollen. </font><font style="vertical-align: inherit;">Wir m√ºssen Einheiten zwingen, um unerforschte Zellen zu vermeiden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca9/eb9/f22/ca9eb9f22cd36b917bd5f0c38028bce7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigieren Sie durch unerforschte Zellen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trupps bestimmen die Umzugskosten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir unerforschte Zellen in Angriff nehmen, wiederholen wir den Code, um die Kosten f√ºr den Wechsel von </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach zu √ºbertragen </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies vereinfacht die Unterst√ºtzung f√ºr Einheiten mit unterschiedlichen Bewegungsregeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Methode hinzu </font></font><code>GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Umzugskosten zu bestimmen. </font><font style="vertical-align: inherit;">Er muss wissen, welche Zellen sich zwischen ihnen bewegen und in welche Richtung. </font><font style="vertical-align: inherit;">Wir kopieren den entsprechenden Code f√ºr die Kosten der Umstellung </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf diese Methode und √§ndern die Variablennamen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode sollte die Umzugskosten zur√ºckgeben. </font><font style="vertical-align: inherit;">Ich habe den alten Code verwendet, um ung√ºltige Z√ºge zu √ºberspringen </font></font><code>continue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber dieser Ansatz funktioniert hier nicht. </font><font style="vertical-align: inherit;">Wenn eine Bewegung nicht m√∂glich ist, erstatten wir die negativen Umzugskosten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir beim Finden des Pfades nicht nur die Geschwindigkeit, sondern auch die ausgew√§hlte Einheit kennen. </font><font style="vertical-align: inherit;">√Ñndern Sie entsprechend </font></font><code>HexGameUI.DoPathFinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, selectedUnit); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir weiterhin Zugriff auf die Geschwindigkeit des Trupps ben√∂tigen, werden wir die </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft erweitern </font></font><code>Speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">W√§hrend es einen konstanten Wert von 24 zur√ºckgibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Speed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver√§nderung </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so , </font><font style="vertical-align: inherit;">dass sie mit unserem neuen Ansatz arbeiten k√∂nnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, unit); ShowPath(unit.Speed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> speed = unit.Speed; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir aus dem </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alten Code </font><font style="vertical-align: inherit;">entfernen </font><font style="vertical-align: inherit;">, der bestimmt hat, ob es m√∂glich ist, zur n√§chsten Zelle zu wechseln, und was die Kosten f√ºr den Umzug sind. </font><font style="vertical-align: inherit;">Stattdessen werden wir anrufen </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>HexUnit.GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden die Zelle √ºberspringen, wenn die Umzugskosten negativ sind.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (neighbor.IsUnderwater || neighbor.Unit) { // continue; // } // HexEdgeType edgeType = current.GetEdgeType(neighbor); // if (edgeType == HexEdgeType.Cliff) { // continue; // } // int moveCost; // if (current.HasRoadThroughEdge(d)) { // moveCost = 1; // } // else if (current.Walled != neighbor.Walled) { // continue; // } // else { // moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; // moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + // neighbor.PlantLevel; // } if (!unit.IsValidDestination(neighbor)) { continue; } int moveCost = unit.GetMoveCost(current, neighbor, d); if (moveCost &lt; 0) { continue; } int distance = current.Distance + moveCost; int turn = (distance - 1) / speed; if (turn &gt; currentTurn) { distance = turn * speed + moveCost; } ‚Ä¶ }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umgehen Sie unerforschte Gebiete </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um unerforschte Zellen zu vermeiden, m√ºssen wir sicherstellen, dass wir </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√ºfen, ob die Zelle untersucht wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.IsExplored &amp;&amp; !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a84/831/2c6/a848312c6231a168a966e4cdafc2df38.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Einheiten k√∂nnen nicht zu unerforschten Zellen gelangen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da unerforschte Zellen keine g√ºltigen Endpunkte mehr sind, werden sie von Trupps beim Verschieben zum Endpunkt vermieden. </font><font style="vertical-align: inherit;">Das hei√üt, unerforschte Gebiete wirken als Barrieren, die den Weg verl√§ngern oder sogar unm√∂glich machen. </font><font style="vertical-align: inherit;">Wir m√ºssen die Einheiten n√§her an ein unbekanntes Gel√§nde bringen, um zuerst die Gegend zu erkunden.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn w√§hrend des Umzugs ein k√ºrzerer Pfad angezeigt wird?</font></font></b> <div class="spoiler_text">                .           ,        .       . <br><br>   ,        ,            .            ,    . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 22: Verbesserte Sichtbarkeit </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñndern Sie die Sichtbarkeit reibungslos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie die H√∂he der Zelle, um den Bereich zu bestimmen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verstecke den Rand der Karte. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch Hinzuf√ºgen von Unterst√ºtzung f√ºr die Kartenerkundung werden wir die Berechnungen und √úberg√§nge des Bereichs verbessern. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/c4a/793/2d2c4a7939e75fe09298f96ff6125478.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um weiter zu sehen, klettere h√∂her.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeits√ºberg√§nge </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zelle ist entweder sichtbar oder unsichtbar, da sie sich entweder im Bereich der Abl√∂sung befindet oder nicht. </font><font style="vertical-align: inherit;">Selbst wenn es so aussieht, als w√ºrde eine Einheit einige Zeit brauchen, um sich zwischen Zellen zu bewegen, springt ihr Bereich sofort von Zelle zu Zelle. </font><font style="vertical-align: inherit;">Infolgedessen √§ndert sich die Sichtbarkeit der umgebenden Zellen dramatisch. </font><font style="vertical-align: inherit;">Die Bewegung des Trupps scheint reibungslos zu sein, aber die Sichtbarkeit √§ndert sich pl√∂tzlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealerweise sollte sich auch die Sichtbarkeit reibungslos √§ndern. </font><font style="vertical-align: inherit;">Sobald Sie sich im Sichtfeld befinden, sollten die Zellen allm√§hlich beleuchtet und allm√§hlich dunkel werden. </font><font style="vertical-align: inherit;">Oder bevorzugen Sie sofortige √úberg√§nge? </font><font style="vertical-align: inherit;">F√ºgen wir der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft </font><font style="vertical-align: inherit;">hinzu, die </font><font style="vertical-align: inherit;">sofortige √úberg√§nge wechselt. </font><font style="vertical-align: inherit;">Standardm√§√üig sind √úberg√§nge glatt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transition Cell Tracking </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst wenn glatte √úberg√§nge angezeigt werden, bleiben die tats√§chlichen Sichtbarkeitsdaten bin√§r, dh der Effekt ist nur visuell. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sichtbarkeits√ºberg√§nge behandelt werden m√ºssen </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden ihm eine Liste von Zellen geben, in denen der √úbergang durchgef√ºhrt wird. </font><font style="vertical-align: inherit;">Stellen Sie sicher, dass es bei jeder Initialisierung leer ist.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; Color32[] cellTextureData; List&lt;HexCell&gt; transitioningCells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transitioningCells.Clear(); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Moment setzen wir Zellendaten </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direkt. </font><font style="vertical-align: inherit;">Dies ist f√ºr den Sofort√ºbergangsmodus immer noch korrekt, aber wenn er deaktiviert ist, m√ºssen wir der Liste der √úbergangszellen eine Zelle hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Sichtbarkeit scheint nicht mehr zu funktionieren, da wir derzeit nichts mit den Zellen in der Liste tun. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchlaufen Sie Zellen in einer Schleife </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die entsprechenden Werte sofort auf 255 oder 0 einzustellen, werden diese Werte schrittweise erh√∂ht / verringert. </font><font style="vertical-align: inherit;">Die Gl√§tte des √úbergangs h√§ngt von der √Ñnderungsrate ab. </font><font style="vertical-align: inherit;">Es sollte nicht sehr schnell und nicht sehr langsam sein. </font><font style="vertical-align: inherit;">Ein guter Kompromiss zwischen sch√∂nen √úberg√§ngen und der Bequemlichkeit des Spiels besteht darin, sich innerhalb einer Sekunde zu √§ndern. </font><font style="vertical-align: inherit;">Stellen wir hierf√ºr eine Konstante ein, um das √Ñndern zu erleichtern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transitionSpeed = <span class="hljs-number"><span class="hljs-number">255f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen wir das Delta definieren, das auf die Werte angewendet wird. </font><font style="vertical-align: inherit;">Multiplizieren Sie dazu das Zeitdelta mit der Geschwindigkeit. </font><font style="vertical-align: inherit;">Es muss eine ganze Zahl sein, da wir nicht wissen, wie gro√ü sie sein kann. </font><font style="vertical-align: inherit;">Ein starker Abfall der Bildrate kann dazu f√ºhren, dass das Delta mehr als 255 betr√§gt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem m√ºssen wir aktualisieren, solange √úbergangszellen vorhanden sind. </font><font style="vertical-align: inherit;">Daher sollte der Code enthalten sein, solange sich etwas in der Liste befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = transitioningCells.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auch theoretisch m√∂glich sehr hohe Bildraten. </font><font style="vertical-align: inherit;">In Kombination mit einer niedrigen √úbergangsgeschwindigkeit kann dies ein Delta von 0 ergeben. Damit die √Ñnderung stattfindet, erzwingen wir, dass das Delta-Minimum 1 ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir das Delta erhalten haben, k√∂nnen wir alle √úbergangszellen durchlaufen und ihre Daten aktualisieren. </font><font style="vertical-align: inherit;">Nehmen wir an, wir haben eine Methode daf√ºr </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, deren Parameter die entsprechende Zelle und das Delta sind.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { UpdateCellData(transitioningCells[i], delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irgendwann sollte der Zell√ºbergang abgeschlossen sein. </font><font style="vertical-align: inherit;">Angenommen, die Methode gibt Informationen dar√ºber zur√ºck, ob der √úbergang noch l√§uft. </font><font style="vertical-align: inherit;">Wenn es nicht mehr l√§uft, k√∂nnen wir die Zelle aus der Liste entfernen. </font><font style="vertical-align: inherit;">Danach m√ºssen wir den Iterator dekrementieren, um die Zellen nicht zu √ºberspringen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells.RemoveAt(i--); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Reihenfolge, in der die √úbergangszellen verarbeitet werden, ist nicht wichtig. </font><font style="vertical-align: inherit;">Daher m√ºssen wir die Zelle nicht am aktuellen Index l√∂schen, wodurch </font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle Zellen gezwungen </font><font style="vertical-align: inherit;">w√ºrden, </font><font style="vertical-align: inherit;">sich danach </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">bewegen. </font><font style="vertical-align: inherit;">Stattdessen verschieben wir die letzte Zelle in den aktuellen Index und l√∂schen dann die letzte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells[i--] = transitioningCells[transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; transitioningCells.RemoveAt(transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir eine Methode erstellen </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um seine Arbeit zu erledigen, ben√∂tigt er einen Index und Zellendaten. Beginnen wir also damit, diese abzurufen. </font><font style="vertical-align: inherit;">Es sollte auch festgelegt werden, ob die Aktualisierung der Zelle fortgesetzt werden soll. </font><font style="vertical-align: inherit;">Standardm√§√üig gehen wir davon aus, dass dies nicht erforderlich ist. </font><font style="vertical-align: inherit;">Nach Abschluss der Arbeiten m√ºssen die ge√§nderten Daten √ºbernommen und der Status "Das Update wird fortgesetzt" zur√ºckgegeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; Color32 data = cellTextureData[index]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellendaten aktualisieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir eine Zelle, die sich im √úbergang befindet oder diese bereits fertiggestellt hat. </font><font style="vertical-align: inherit;">Lassen Sie uns zun√§chst den Status der Zellsonde √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Wenn die Zelle untersucht wird, ihr G-Wert jedoch noch nicht 255 betr√§gt, befindet sie sich im √úbergangsprozess, sodass wir dies √ºberwachen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } cellTextureData[index] = data;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den √úbergang durchzuf√ºhren, f√ºgen wir dem G-Wert der Zelle ein Delta hinzu. </font><font style="vertical-align: inherit;">Arithmetische Operationen funktionieren nicht mit Bytes, sondern werden zuerst in Ganzzahlen konvertiert. </font><font style="vertical-align: inherit;">Daher hat die Summe das Ganzzahlformat, das in Byte konvertiert werden muss.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vor der Konvertierung m√ºssen Sie jedoch sicherstellen, dass der Wert 255 nicht √ºberschreitet. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als n√§chstes m√ºssen wir dasselbe f√ºr die Sichtbarkeit tun, die den Wert von R verwendet. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible &amp;&amp; data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da die Zelle wieder unsichtbar werden kann, m√ºssen wir pr√ºfen, ob der Wert von R verringert werden muss. Dies geschieht, wenn die Zelle unsichtbar ist, R jedoch gr√∂√üer als Null ist. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r - delta; data.r = t &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist es </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fertig und die Sichtbarkeits√ºberg√§nge werden korrekt ausgef√ºhrt.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sichtbarkeits√ºberg√§nge.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schutz vor doppelten √úbergangselementen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberg√§nge funktionieren, aber m√∂glicherweise werden doppelte Elemente in der Liste angezeigt. </font><font style="vertical-align: inherit;">Dies geschieht, wenn sich der Sichtbarkeitsstatus der Zelle √§ndert, w√§hrend sie sich noch im √úbergang befindet. </font><font style="vertical-align: inherit;">Zum Beispiel, wenn die Zelle w√§hrend der Bewegung des Trupps nur f√ºr kurze Zeit sichtbar ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund des Auftretens doppelter Elemente wird der Zellen√ºbergang mehrmals pro Frame aktualisiert, was zu schnelleren √úberg√§ngen und zus√§tzlicher Arbeit f√ºhrt. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies verhindern, indem wir vor dem Hinzuf√ºgen einer Zelle pr√ºfen, ob sie bereits in der Liste enthalten ist. </font><font style="vertical-align: inherit;">Eine Listensuche bei jedem Anruf</font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kostspielig, insbesondere wenn mehrere Zell√ºberg√§nge durchgef√ºhrt werden. </font><font style="vertical-align: inherit;">Verwenden wir stattdessen einen anderen Kanal, der noch nicht verwendet wurde, um anzugeben, ob sich die Zelle im √úbergangsprozess befindet, z. B. Wert B. Wenn wir der Liste eine Zelle hinzuf√ºgen, weisen wir ihr den Wert 255 zu und f√ºgen nur die Zellen hinzu, deren Wert nicht 255 entspricht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData[index].b != <span class="hljs-number"><span class="hljs-number">255</span></span>) { cellTextureData[index].b = <span class="hljs-number"><span class="hljs-number">255</span></span>; transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Damit dies funktioniert, m√ºssen wir den Wert von B nach Abschluss des Zell√ºbergangs zur√ºcksetzen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stillUpdating) { data.b = <span class="hljs-number"><span class="hljs-number">0</span></span>; } cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberg√§nge ohne Duplikate.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit sofort laden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñnderungen der Sichtbarkeit sind jetzt immer schrittweise, auch beim Laden einer Karte. </font><font style="vertical-align: inherit;">Dies ist unlogisch, da die Karte den Zustand beschreibt, in dem die Zellen bereits sichtbar sind, sodass der √úbergang hier unangemessen ist. </font><font style="vertical-align: inherit;">Dar√ºber hinaus kann das Durchf√ºhren von √úberg√§ngen f√ºr die vielen sichtbaren Zellen einer gro√üen Karte das Spiel nach dem Laden verlangsamen. </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wechseln </font><font style="vertical-align: inherit;">wir daher vor dem Laden von Zellen und Trupps </font><font style="vertical-align: inherit;">in den Sofort√ºbergangsmodus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher definieren wir die anf√§ngliche Einstellung des Sofort√ºbergangsmodus neu, unabh√§ngig davon, wie er aussieht. </font><font style="vertical-align: inherit;">M√∂glicherweise ist es bereits ausgeschaltet oder es wurde eine Konfigurationsoption vorgenommen, sodass wir uns an den Anfangsmodus erinnern und nach Abschluss der Arbeiten darauf umschalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> originalImmediateMode = cellShaderData.ImmediateMode; cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ‚Ä¶ cellShaderData.ImmediateMode = originalImmediateMode; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> H√∂henabh√§ngiger Bereich </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir f√ºr alle Einheiten einen konstanten Umfang von drei verwendet, aber in Wirklichkeit ist dies komplizierter. Im allgemeinen Fall k√∂nnen wir das Objekt aus zwei Gr√ºnden nicht sehen: Entweder hindert uns ein Hindernis daran, es zu sehen, oder das Objekt ist zu klein oder zu weit. In unserem Spiel implementieren wir nur die Bereichsbeschr√§nkung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen nicht sehen, was sich auf der gegen√ºberliegenden Seite der Erde befindet, weil der Planet uns verdeckt. Wir k√∂nnen nur bis zum Horizont sehen. Da der Planet ungef√§hr als Kugel betrachtet werden kann, gilt: Je h√∂her der Blickwinkel, desto mehr Oberfl√§che k√∂nnen wir sehen, dh der Horizont h√§ngt von der H√∂he ab.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/788/208/0717882082a42e92b14e158876c6e28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Horizont h√§ngt von der H√∂he des Aussichtspunkts ab. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die eingeschr√§nkte Sichtbarkeit unserer Einheiten ahmt den Horizonteffekt nach, der durch die Kr√ºmmung der Erde erzeugt wird. </font><font style="vertical-align: inherit;">Die Reichweite ihrer √úberpr√ºfung h√§ngt von der Gr√∂√üe des Planeten und dem Ma√üstab der Karte ab. </font><font style="vertical-align: inherit;">Zumindest ist das die logische Erkl√§rung. </font><font style="vertical-align: inherit;">Der Hauptgrund f√ºr die Reduzierung des Umfangs ist jedoch das Gameplay. Dies ist eine Einschr√§nkung, die als Nebel des Krieges bezeichnet wird. </font><font style="vertical-align: inherit;">Wenn wir jedoch die dem Sichtfeld zugrunde liegende Physik verstehen, k√∂nnen wir daraus schlie√üen, dass ein hoher Standpunkt einen strategischen Wert haben sollte, da er sich vom Horizont entfernt und es Ihnen erm√∂glicht, niedrigere Hindernisse zu betrachten. </font><font style="vertical-align: inherit;">Aber bisher haben wir es nicht umgesetzt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> H√∂he zur √úberpr√ºfung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die H√∂he bei der Bestimmung des Umfangs zu ber√ºcksichtigen, m√ºssen wir die H√∂he kennen. </font><font style="vertical-align: inherit;">Dies ist die √ºbliche H√∂he oder der √ºbliche Wasserstand, je nachdem, ob es sich um eine Landzelle oder um Wasser handelt. </font><font style="vertical-align: inherit;">F√ºgen wir dies der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ViewElevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation &gt;= waterLevel ? elevation : waterLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich die H√∂he jedoch auf den Bereich auswirkt, kann sich bei einer √Ñnderung der Betrachtungsh√∂he der Zelle auch die Sichtbarkeitssituation √§ndern. </font><font style="vertical-align: inherit;">Da die Zelle den Umfang mehrerer Einheiten blockiert hat oder jetzt blockiert, ist es nicht so einfach zu bestimmen, was ge√§ndert werden muss. </font><font style="vertical-align: inherit;">Die Zelle selbst kann dieses Problem nicht l√∂sen. Lassen Sie sie daher eine √Ñnderung der Situation melden </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Angenommen, Sie </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben eine Methode daf√ºr </font></font><code>ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden es bei </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bedarf </font><font style="vertical-align: inherit;">bei Abtretung anrufen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das gilt auch f√ºr </font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } ValidateRivers(); Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit zur√ºcksetzen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir eine Methode erstellen </font></font><code>HexCellShaderData.ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Ermitteln, wie sich eine allgemeine Sichtbarkeitssituation √§ndert, ist eine komplexe Aufgabe, insbesondere wenn mehrere Zellen gleichzeitig ge√§ndert werden. </font><font style="vertical-align: inherit;">Daher werden wir keine Tricks finden, sondern einfach planen, die Sichtbarkeit aller Zellen zur√ºckzusetzen. </font><font style="vertical-align: inherit;">F√ºgen Sie ein boolesches Feld hinzu, um zu verfolgen, ob dies geschehen soll. </font><font style="vertical-align: inherit;">Innerhalb der Methode setzen wir sie einfach auf true und schlie√üen die Komponente ein. </font><font style="vertical-align: inherit;">Unabh√§ngig von der Anzahl der Zellen, die sich gleichzeitig ge√§ndert haben, f√ºhrt dies zu einem einzelnen Reset.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> needsVisibilityReset; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewElevationChanged</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Sichtbarkeitswerte aller Zellen zur√ºckzusetzen, m√ºssen Sie Zugriff auf diese haben, √ºber die Sie </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht verf√ºgen. </font><font style="vertical-align: inherit;">Lassen Sie uns diese Verantwortung delegieren </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dazu m√ºssen Sie der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft etwas </font><font style="vertical-align: inherit;">hinzuf√ºgen, </font><font style="vertical-align: inherit;">damit Sie auf das Raster verweisen k√∂nnen. </font><font style="vertical-align: inherit;">Dann k√∂nnen wir es verwenden </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um einen Reset anzufordern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needsVisibilityReset) { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Grid.ResetVisibility(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahren wir fort mit </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Setzen Sie den Link zum Raster, </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nachdem Sie die Shader-Daten erstellt haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); cellShaderData.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; CreateMap(cellCountX, cellCountZ); }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte auch eine Methode erhalten </font></font><code>ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um alle Zellen zu verwerfen. </font><font style="vertical-align: inherit;">Lassen Sie es einfach alle Zellen in der Schleife umgehen und delegieren Sie das Zur√ºcksetzen an sich selbst.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir die </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">erg√§nzen </font></font><code>ResetVisibilty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Sichtbarkeit wird einfach auf Null gesetzt und die Sichtbarkeitsaktualisierung ausgel√∂st. </font><font style="vertical-align: inherit;">Dies muss erfolgen, wenn die Sichtbarkeit der Zelle gr√∂√üer als Null ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { visibility = <span class="hljs-number"><span class="hljs-number">0</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem er alle Sichtbarkeitsdaten zur√ºckgesetzt hat, </font></font><code>HexGrid.ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss er erneut Sichtbarkeit auf alle Trupps anwenden, f√ºr die er den Umfang jedes Trupps kennen muss. </font><font style="vertical-align: inherit;">Angenommen, es kann mit der Eigenschaft abgerufen werden </font></font><code>VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { HexUnit unit = units[i]; IncreaseVisibility(unit.Location, unit.VisionRange); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit dies funktioniert, werden wir die Umbenennung </font></font><code>HexUnit.visionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font><font style="vertical-align: inherit;">umgestalten </font></font><code>HexUnit.VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und in eine Eigenschaft umwandeln. </font><font style="vertical-align: inherit;">Es wird zwar einen konstanten Wert von 3 erhalten, aber in Zukunft wird es sich √§ndern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VisionRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesem Grund werden die Sichtbarkeitsdaten zur√ºckgesetzt und bleiben nach dem √Ñndern der Zellenbetrachtungsh√∂he korrekt. </font><font style="vertical-align: inherit;">Es ist jedoch wahrscheinlich, dass wir die Regeln f√ºr die Bestimmung des Bereichs √§ndern und die Neukompilierung im Wiedergabemodus ausf√ºhren. </font><font style="vertical-align: inherit;">Damit sich der Bereich unabh√§ngig √§ndert, f√ºhren wir einen Reset durch, </font></font><code>HexGrid.OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn eine Neukompilierung erkannt wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { ‚Ä¶ ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen Sie den Scope-Code √§ndern und die Ergebnisse anzeigen, w√§hrend Sie im Wiedergabemodus bleiben. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Den Horizont erweitern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Berechnung des Umfangs wird festgelegt </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Damit sich die H√∂he auf den Bereich auswirkt, k√∂nnen wir einfach die Betrachtungsh√∂he verwenden, indem wir </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den √ºbertragenen Bereich vor√ºbergehend neu definieren. </font><font style="vertical-align: inherit;">So k√∂nnen wir leicht √ºberpr√ºfen, ob dies funktioniert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ range = fromCell.ViewElevation; fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/032/6d3/7270326d379796f2b4f2f3c3ca65512c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die H√∂he als Zielfernrohr.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindernisse f√ºr die Sichtbarkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Anwenden einer Betrachtungsh√∂he als Bereich funktioniert nur dann ordnungsgem√§√ü, wenn sich alle anderen Zellen auf der H√∂he Null befinden. </font><font style="vertical-align: inherit;">Wenn jedoch alle Zellen dieselbe H√∂he wie der Blickwinkel haben, sollte das Sichtfeld Null sein. </font><font style="vertical-align: inherit;">Au√üerdem sollten Zellen mit hohen H√∂hen die Sichtbarkeit der niedrigen Zellen dahinter blockieren. </font><font style="vertical-align: inherit;">Bisher wurde nichts davon implementiert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/7be/a6f/de87bea6f4b88cd61765450a63f738f9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Umfang st√∂rt nicht. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der korrekteste Weg, um den Umfang zu bestimmen, w√§re die √úberpr√ºfung durch die Emission von Strahlen, aber es w√ºrde schnell teuer werden und immer noch seltsame Ergebnisse liefern. </font><font style="vertical-align: inherit;">Wir brauchen eine schnelle L√∂sung, die gut genug Ergebnisse liefert, die nicht perfekt sein m√ºssen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus ist es wichtig, dass die Regeln zur Bestimmung des Umfangs f√ºr die Spieler einfach, intuitiv und vorhersehbar sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere L√∂sung lautet wie folgt: Wenn Sie die Sichtbarkeit einer Zelle bestimmen, addieren wir die Betrachtungsh√∂he der benachbarten Zelle zur zur√ºckgelegten Entfernung. </font><font style="vertical-align: inherit;">Tats√§chlich verringert dies den Umfang, wenn wir diese Zellen betrachten, und wenn sie √ºbersprungen werden, k√∂nnen wir die Zellen hinter ihnen nicht erreichen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/44c/efe/77444cefe82d428ee32e094213e82a1a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hohe Zellen blockieren die Ansicht.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollten wir in der Ferne keine hohen Zellen sehen?</font></font></b> <div class="spoiler_text">      ,     ,   ,   .       ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauen Sie nicht um die Ecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt scheint es, dass hohe Zellen die Sicht auf niedrig blockieren, aber manchmal durchdringt der Bereich sie, obwohl es so scheint, dass dies nicht sein sollte. </font><font style="vertical-align: inherit;">Dies geschieht, weil der Suchalgorithmus immer noch einen Pfad zu diesen Zellen findet und die blockierenden Zellen umgeht. </font><font style="vertical-align: inherit;">Infolgedessen sieht es so aus, als ob unser Sichtbereich Hindernisse umgehen kann. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, m√ºssen wir sicherstellen, dass bei der Bestimmung der Zellsichtbarkeit nur die k√ºrzesten Pfade ber√ºcksichtigt werden. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem Pfade gel√∂scht werden, die l√§nger als n√∂tig werden.</font></font><br><br><pre> <code class="cs hljs"> HexCoordinates fromCoordinates = fromCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range || distance &gt; fromCoordinates.DistanceTo(neighbor.coordinates) ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/bfa/1c2/30dbfa1c2df2fb6119249f00cdc3d8d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir benutzen nur die k√ºrzesten Wege.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also haben wir die meisten offensichtlich fehlerhaften F√§lle behoben. F√ºr nahe gelegene Zellen funktioniert dies gut, da es nur k√ºrzeste Wege zu ihnen gibt. Weiter entfernte Zellen haben mehr Optionen f√ºr Pfade, daher kann √ºber gro√üe Entfernungen immer noch eine Sichtbarkeitsh√ºlle auftreten. Dies ist kein Problem, wenn die Sichtbereiche klein bleiben und die Unterschiede in benachbarten H√∂hen nicht zu gro√ü sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schlie√ülich f√ºgen wir, anstatt das √ºbertragene Sichtfeld zu ersetzen, die H√∂he der Sicht hinzu. Das eigene Sichtfeld des Trupps zeigt seine H√∂he, Flugh√∂he oder Aufkl√§rungsf√§higkeiten an.</font></font><br><br><pre> <code class="cs hljs"> range += fromCell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ff/1ce/a2b/3ff1cea2b833bda69990576fa8323aec.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansicht mit vollem Sichtfeld bei niedriger Sicht. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, die endg√ºltigen Sichtbarkeitsregeln gelten f√ºr das Sehen, wenn Sie sich auf dem k√ºrzesten Weg zum Sichtfeld bewegen, wobei der Unterschied in der Zellenh√∂he relativ zum Blickwinkel ber√ºcksichtigt wird. </font><font style="vertical-align: inherit;">Wenn eine Zelle au√üerhalb des G√ºltigkeitsbereichs liegt, blockiert sie alle Pfade durch sie. </font><font style="vertical-align: inherit;">Infolgedessen werden hohe Beobachtungspunkte, von denen aus nichts die Sicht behindert, strategisch wertvoll.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit der Behinderung der Sichtbarkeit von Objekten?</font></font></b> <div class="spoiler_text">  ,        ,  . ,  ,        .          . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen, die nicht erforscht werden k√∂nnen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das letzte Problem mit der Sichtbarkeit betrifft die Kanten der Karte. </font><font style="vertical-align: inherit;">Das Relief endet abrupt und ohne √úberg√§nge, weil die Zellen am Rand keine Nachbarn haben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/217/fbb/587217fbb248ae8a13759a33e22e25ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Markierter Rand der Karte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Idealfall sollte die visuelle Anzeige von unerforschten Bereichen und Kanten der Karte identisch sein. Wir k√∂nnen dies erreichen, indem wir Sonderf√§lle hinzuf√ºgen, wenn Kanten trianguliert werden, wenn sie keine Nachbarn haben. Dies erfordert jedoch zus√§tzliche Logik und wir m√ºssen mit fehlenden Zellen arbeiten. Daher ist eine solche L√∂sung nicht trivial. Ein alternativer Ansatz besteht darin, zu erzwingen, dass die Grenzzellen der Karte nicht erforscht werden, selbst wenn sie sich im Bereich des Trupps befinden. Dieser Ansatz ist viel einfacher, also verwenden wir ihn. Au√üerdem k√∂nnen Sie diese als unerforschte und andere Zellen markieren, wodurch die Erstellung ungleichm√§√üiger Kanten der Karte erleichtert wird. Dar√ºber hinaus k√∂nnen Sie mit versteckten Zellen an den R√§ndern Stra√üen und Fl√ºsse erstellen, die in die Karte des Flusses und der Stra√üe eintreten und diese verlassen, da ihre Endpunkte au√üerhalb des Bereichs liegen.Mithilfe dieser L√∂sung k√∂nnen Sie auch Einheiten hinzuf√ºgen, die die Karte betreten und verlassen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir markieren Zellen als untersucht </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft </font><font style="vertical-align: inherit;">hinzu, dass eine Zelle untersucht werden kann </font></font><code>Explorable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Explorable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt kann eine Zelle sichtbar sein, wenn es sich um eine untersuchte handelt. </font></font><code>IsVisible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher </font><font style="vertical-align: inherit;">√§ndern </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">die Eigenschaft </font><font style="vertical-align: inherit;">, um dies zu ber√ºcksichtigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Explorable; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleiches gilt f√ºr </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hierzu haben wir jedoch die Standardeigenschaft untersucht. </font><font style="vertical-align: inherit;">Wir m√ºssen es in eine explizite Eigenschaft konvertieren, um die Logik seines Getters √§ndern zu k√∂nnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> explored &amp;&amp; Explorable; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { explored = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> explored;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verstecke den Rand der Karte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen den Rand einer rechteckigen Karte in der Methode ausblenden </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zellen, die sich nicht am Rand befinden, werden untersucht, der Rest ist unerforscht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sind die Karten an den R√§ndern abgedunkelt und verstecken sich hinter ihnen riesige unerforschte R√§ume. </font><font style="vertical-align: inherit;">Infolgedessen nimmt die Gr√∂√üe des untersuchten Kartenbereichs in jeder Dimension um zwei ab.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/594/19f/353/59419f35345fa4eac3380c4e16461baf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unerforschter Rand der Karte.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es m√∂glich, den Forschungszustand bearbeitbar zu machen?</font></font></b> <div class="spoiler_text"> ,  ,     .          . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unerforschte Zellen beeintr√§chtigen die Sichtbarkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Zelle nicht untersucht werden kann, sollte sie die Sichtbarkeit beeintr√§chtigen. </font><font style="vertical-align: inherit;">√Ñndern Sie dies </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um dies zu ber√ºcksichtigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase || !neighbor.Explorable ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 23: Land erzeugen </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºllen Sie neue Karten mit generierten Landschaften. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir erheben Land √ºber Wasser, wir √ºberfluten einige. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir kontrollieren die Menge des geschaffenen Landes, seine H√∂he und Unebenheiten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bieten Unterst√ºtzung f√ºr verschiedene Konfigurationsoptionen zum Erstellen von Variablenzuordnungen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir machen es so, dass dieselbe Karte erneut generiert werden kann. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Teil des Tutorials ist der Beginn einer Reihe zur prozeduralen Kartengenerierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Teil wurde in Unity 2017.1.0 erstellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/798/7bb/99e7987bbcb46f1f961b72ba76a78aa0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine der vielen generierten Karten.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartengenerierung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir jede Karte erstellen k√∂nnen, dauert es sehr lange. Es w√§re praktisch, wenn die Anwendung dem Designer helfen k√∂nnte, indem er Karten f√ºr ihn generiert, die er dann nach seinem Geschmack √§ndern kann. Sie k√∂nnen einen weiteren Schritt unternehmen und das manuelle Erstellen des Entwurfs vollst√§ndig vermeiden, indem Sie die Verantwortung f√ºr das Generieren der fertigen Karte vollst√§ndig auf die Anwendung √ºbertragen. Aus diesem Grund kann das Spiel jedes Mal mit einer neuen Karte gespielt werden und jede Spielsitzung ist anders. Damit dies alles m√∂glich ist, m√ºssen wir einen Algorithmus zur Kartengenerierung erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Art von Generierungsalgorithmus Sie ben√∂tigen, h√§ngt von der Art der Karte ab, die Sie ben√∂tigen. Es gibt keinen richtigen Ansatz, man muss immer nach einem Kompromiss zwischen Glaubw√ºrdigkeit und Spielbarkeit suchen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit eine Karte glaubw√ºrdig ist, muss sie dem Spieler durchaus m√∂glich und real erscheinen. Dies bedeutet nicht, dass die Karte wie ein Teil unseres Planeten aussehen sollte. Es kann ein anderer Planet oder eine v√∂llig andere Realit√§t sein. Aber wenn es das Relief der Erde anzeigen soll, dann muss es ihm zumindest teilweise √§hneln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Spielbarkeit h√§ngt davon ab, wie die Karten dem Gameplay entsprechen. Manchmal widerspricht es der Glaubw√ºrdigkeit. Zum Beispiel k√∂nnen Bergketten, obwohl sie sch√∂n aussehen k√∂nnen, gleichzeitig die Bewegung und Sicht von Einheiten stark einschr√§nken. Wenn dies unerw√ºnscht ist, m√ºssen Sie auf Berge verzichten, was die Glaubw√ºrdigkeit verringert und die Ausdruckskraft des Spiels einschr√§nkt. Oder wir k√∂nnen die Berge retten, aber ihre Auswirkungen auf das Gameplay verringern, was auch die Glaubw√ºrdigkeit verringern kann.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus muss die Machbarkeit ber√ºcksichtigt werden. Sie k√∂nnen beispielsweise einen sehr realistischen erd√§hnlichen Planeten erstellen, indem Sie tektonische Platten, Erosion, Regen, Vulkanausbr√ºche, die Auswirkungen von Meteoriten und Mond usw. simulieren. Die Entwicklung eines solchen Systems wird jedoch viel Zeit in Anspruch nehmen. Dar√ºber hinaus kann es lange dauern, einen solchen Planeten zu generieren, und die Spieler werden nicht einige Minuten warten wollen, bevor sie ein neues Spiel starten. Das hei√üt, Simulation ist ein m√§chtiges Werkzeug, aber es hat einen Preis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spiele verwenden h√§ufig Kompromisse zwischen Glaubw√ºrdigkeit, Spielbarkeit und Durchf√ºhrbarkeit. Manchmal sind solche Kompromisse unsichtbar und scheinen v√∂llig normal zu sein, und manchmal sehen sie zuf√§llig, inkonsistent oder chaotisch aus, abh√§ngig von den Entscheidungen, die w√§hrend des Entwicklungsprozesses getroffen werden. Dies gilt nicht nur f√ºr die Kartengenerierung, sondern Sie m√ºssen bei der Entwicklung eines prozeduralen Kartengenerators besonders darauf achten. Sie k√∂nnen viel Zeit damit verbringen, einen Algorithmus zu erstellen, der wundersch√∂ne Karten generiert, die sich f√ºr das von Ihnen erstellte Spiel als nutzlos herausstellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Tutorialserie werden wir ein land√§hnliches Relief erstellen. </font><font style="vertical-align: inherit;">Es sollte interessant aussehen, mit gro√üer Variabilit√§t und dem Fehlen gro√üer homogener Bereiche. </font><font style="vertical-align: inherit;">Der Reliefma√üstab wird gro√ü sein, Karten werden einen oder mehrere Kontinente, Regionen der Ozeane oder sogar einen ganzen Planeten abdecken. </font><font style="vertical-align: inherit;">Wir brauchen Kontrolle √ºber die Geographie, einschlie√ülich Landmassen, Klima, Anzahl der Regionen und Gel√§ndeunebenheiten. </font><font style="vertical-align: inherit;">In diesem Teil legen wir den Grundstein f√ºr die Herstellung von Sushi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erste Schritte im Bearbeitungsmodus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden uns auf die Karte konzentrieren, nicht auf das Gameplay, daher ist es bequemer, die Anwendung im Bearbeitungsmodus zu starten. </font><font style="vertical-align: inherit;">Dank dessen k√∂nnen wir die Karten sofort sehen. </font><font style="vertical-align: inherit;">Daher √§ndern wir </font></font><code>HexMapEditor.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Bearbeitungsmodus auf true und aktivieren das Shader-Schl√ºsselwort dieses Modus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartengenerator </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da zum Generieren von prozeduralen Maps ziemlich viel Code ben√∂tigt wird, werden wir ihn nicht direkt hinzuf√ºgen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen erstellen wir eine neue Komponente </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wissen nichts dar√ºber. </font><font style="vertical-align: inherit;">Dies vereinfacht den √úbergang zu einem anderen Algorithmus, wenn wir ihn ben√∂tigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Generator ben√∂tigt eine Verkn√ºpfung zum Raster, daher f√ºgen wir ihm ein allgemeines Feld hinzu. </font><font style="vertical-align: inherit;">Zus√§tzlich f√ºgen wir eine allgemeine Methode hinzu </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die sich mit der Arbeit des Algorithmus befasst. </font><font style="vertical-align: inherit;">Wir geben ihm die Abmessungen der Karte als Parameter und erzwingen dann, dass sie zum Erstellen einer neuen leeren Karte verwendet wird.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Szene ein Objekt mit einer Komponente hinzu </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verbinden Sie es mit dem Raster.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/b6e/fd2/932b6efd2dd1809893af27ec7a91c620.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kartengeneratorobjekt.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñndern Sie das Men√º einer neuen Karte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden es </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so </font><font style="vertical-align: inherit;">√§ndern </font><font style="vertical-align: inherit;">, dass es Karten erzeugen kann, nicht nur leere. </font><font style="vertical-align: inherit;">Wir werden seine Funktionalit√§t √ºber ein Boolesches Feld steuern </font></font><code>generateMaps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das standardm√§√üig einen Wert hat </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lassen Sie uns eine allgemeine Methode zum Festlegen dieses Felds erstellen, wie wir es getan haben, um Optionen zu wechseln </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen Sie dem Men√º den entsprechenden Schalter hinzu und verbinden Sie ihn mit der Methode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> generateMaps = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleMapGeneration</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { generateMaps = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc9/9c7/0c9/fc99c70c99095b3565104ef42254859d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√º einer neuen Karte mit einem Schalter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geben Sie dem Men√º einen Link zum Kartengenerator. </font><font style="vertical-align: inherit;">Dann werden wir ihn zwingen, bei Bedarf die </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatormethode </font><font style="vertical-align: inherit;">aufzurufen </font><font style="vertical-align: inherit;">und nicht nur das </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raster </font><font style="vertical-align: inherit;">auszuf√ºhren </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMapGenerator mapGenerator; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d1/e98/3d9/7d1e983d927d912b75d9b245219659f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschluss an den Generator.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellenzugriff </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit der Generator funktioniert, muss er auf die Zellen zugreifen k√∂nnen. </font><font style="vertical-align: inherit;">Wir </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben bereits g√§ngige Methoden , </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die oder Positionsvektor erfordern, oder Sechseck - </font><font style="vertical-align: inherit;">Koordinaten. </font><font style="vertical-align: inherit;">Der Generator muss weder mit dem einen noch mit dem anderen arbeiten, daher f√ºgen wir zwei praktische Methoden hinzu </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die mit den Koordinaten des Versatzes oder des Index der Zelle arbeiten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zOffset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[xOffset + zOffset * cellCountX]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[cellIndex]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann es Zellen direkt empfangen. </font><font style="vertical-align: inherit;">Nach dem Erstellen einer neuen Karte kann er beispielsweise Graskoordinaten verwenden, um Gras als Relief der mittleren Zellenspalte festzulegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; z; i++) { grid.GetCell(x / <span class="hljs-number"><span class="hljs-number">2</span></span>, i).TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/aee/119/860aee119f0e000ef290f6c87e61ad05.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grass√§ule auf einer kleinen Karte. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sushi machen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Erstellung einer Karte beginnen wir komplett ohne Land. </font><font style="vertical-align: inherit;">Man kann sich vorstellen, dass die ganze Welt von einem riesigen Ozean √ºberflutet ist. </font><font style="vertical-align: inherit;">Ein Land entsteht, wenn ein Teil des Meeresbodens so weit nach oben gedr√ºckt wird, dass er sich √ºber das Wasser erhebt. </font><font style="vertical-align: inherit;">Wir m√ºssen entscheiden, wie viel Land auf diese Weise geschaffen werden soll, wo es erscheinen wird und welche Form es haben wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erh√∂hen Sie die Erleichterung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fangen wir klein an - heben Sie ein St√ºck Land √ºber das Wasser. </font><font style="vertical-align: inherit;">Dazu erstellen wir eine Methode </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Parameter zur Steuerung der Gr√∂√üe des Plots. </font><font style="vertical-align: inherit;">Rufen Sie diese Methode auf </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ersetzen Sie den vorherigen Testcode. </font><font style="vertical-align: inherit;">Beginnen wir mit einem kleinen St√ºck Land, das aus sieben Zellen besteht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; z; i++) { // grid.GetCell(x / 2, i).TerrainTypeIndex = 1; // } RaiseTerrain(7); } void RaiseTerrain (int chunkSize) {}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher verwenden wir das Relief ‚ÄûGras‚Äú, um das erh√∂hte Land zu bezeichnen, und das urspr√ºngliche Relief ‚ÄûSand‚Äú bezieht sich auf den Ozean. </font><font style="vertical-align: inherit;">Lassen Sie uns </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine zuf√§llige Zelle nehmen und die Art ihres Reliefs √§ndern, bis wir die richtige Menge Land erhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine zuf√§llige Zelle zu erhalten, f√ºgen wir eine Methode hinzu </font></font><code>GetRandomCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die einen zuf√§lligen Zellenindex bestimmt und die entsprechende Zelle aus dem Raster erh√§lt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunkSize; i++) { GetRandomCell().TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, grid.cellCountX * grid.cellCountZ)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/fb8/ce6/396fb8ce67de74961b31562e275bd81a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sieben zuf√§llige Sushi-Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir am Ende m√∂glicherweise viele zuf√§llige Zellen ben√∂tigen oder alle Zellen mehrmals durchlaufen m√ºssen, verfolgen wir die Anzahl der Zellen in der Zelle selbst </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, cellCount)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellung einer Site </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher verwandeln wir sieben zuf√§llige Zellen in Land, und sie k√∂nnen √ºberall sein. </font><font style="vertical-align: inherit;">H√∂chstwahrscheinlich bilden sie keine einzige Landfl√§che. </font><font style="vertical-align: inherit;">Au√üerdem k√∂nnen wir dieselben Zellen mehrmals ausw√§hlen, sodass wir weniger Land erhalten. </font><font style="vertical-align: inherit;">Um beide Probleme ohne Einschr√§nkungen zu l√∂sen, w√§hlen wir nur die erste Zelle aus. </font><font style="vertical-align: inherit;">Danach sollten wir nur die Zellen ausw√§hlen, die sich neben den zuvor ausgew√§hlten befinden. </font><font style="vertical-align: inherit;">Diese Einschr√§nkungen √§hneln den Einschr√§nkungen der Pfadsuche, daher verwenden wir hier denselben Ansatz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir f√ºgen </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unser eigenes Eigentum und den Z√§hler der Phase der Suchgrenze hinzu, wie es war </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberpr√ºfen Sie, ob die Priorit√§tswarteschlange vorhanden ist, bevor wir sie ben√∂tigen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Erstellen einer neuen Karte ist die Suchgrenze f√ºr alle Zellen Null. Wenn wir jedoch bei der Kartengenerierung nach Zellen suchen, werden wir deren Suchgrenze in diesem Prozess erh√∂hen. Wenn wir viele Suchvorg√§nge ausf√ºhren, liegen diese m√∂glicherweise vor der Phase der aufgezeichneten Suchgrenze </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies kann die Suche nach Einheitenpfaden beeintr√§chtigen. Um dies zu vermeiden, setzen wir am Ende des Kartengenerierungsprozesses die Suchphase aller Zellen auf Null zur√ºck.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt muss ich </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach den entsprechenden Zellen suchen und sie nicht zuf√§llig ausw√§hlen. Dieser Vorgang ist der Suchmethode in sehr √§hnlich </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir werden Zellen jedoch nicht mehr als einmal besuchen, sodass es ausreicht, die Phase des Suchrahmens um 1 statt um 2 zu erh√∂hen. Dann initialisieren wir den Rand mit der ersten Zelle, die zuf√§llig ausgew√§hlt wird. Zus√§tzlich zum Festlegen der Suchphase weisen wir wie √ºblich den Abstand und die Heuristik auf Null zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; chunkSize; i++) { // GetRandomCell().TerrainTypeIndex = 1; // } searchFrontierPhase += 1; HexCell firstCell = GetRandomCell(); firstCell.SearchPhase = searchFrontierPhase; firstCell.Distance = 0; firstCell.SearchHeuristic = 0; searchFrontier.Enqueue(firstCell); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach ist uns die Suchschleife gr√∂√ütenteils vertraut. </font><font style="vertical-align: inherit;">Um die Suche fortzusetzen, bis der Rand leer ist, m√ºssen wir au√üerdem anhalten, wenn das Fragment die gew√ºnschte Gr√∂√üe erreicht hat, damit wir es verfolgen k√∂nnen. </font><font style="vertical-align: inherit;">Bei jeder Iteration extrahieren wir die n√§chste Zelle aus der Warteschlange, legen den Typ des Reliefs fest, erh√∂hen die Gr√∂√üe und umgehen dann die Nachbarn dieser Zelle. </font><font style="vertical-align: inherit;">Alle Nachbarn werden einfach zur Grenze hinzugef√ºgt, wenn sie dort noch nicht hinzugef√ºgt wurden. </font><font style="vertical-align: inherit;">Wir m√ºssen keine √Ñnderungen oder Vergleiche vornehmen. </font><font style="vertical-align: inherit;">Nach Abschluss m√ºssen Sie die Grenze l√∂schen.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } } searchFrontier.Clear();</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97a/f44/023/97af440236cb6909130d6a8bfaab3f5a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Reihe von Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben ein einzelnes Grundst√ºck der richtigen Gr√∂√üe. </font><font style="vertical-align: inherit;">Es wird nur kleiner, wenn nicht gen√ºgend Zellen vorhanden sind. </font><font style="vertical-align: inherit;">Aufgrund der Art und Weise, wie die Grenze gef√ºllt ist, besteht das Grundst√ºck immer aus einer Linie, die nach Nordwesten verl√§uft. </font><font style="vertical-align: inherit;">Es √§ndert die Richtung nur, wenn es den Rand der Karte erreicht.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verbinden Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Landfl√§chen √§hneln selten Linien, und wenn doch, sind sie nicht immer gleich ausgerichtet. </font><font style="vertical-align: inherit;">Um die Form der Site zu √§ndern, m√ºssen wir die Priorit√§ten der Zellen √§ndern. </font><font style="vertical-align: inherit;">Die erste Zufallszelle kann als Mittelpunkt des Diagramms verwendet werden. </font><font style="vertical-align: inherit;">Dann ist der Abstand zu allen anderen Zellen relativ zu diesem Punkt. </font><font style="vertical-align: inherit;">Daher werden wir Zellen, die n√§her am Zentrum liegen, eine h√∂here Priorit√§t einr√§umen, damit die Site nicht als Linie, sondern um das Zentrum herum w√§chst.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); HexCoordinates center = firstCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/117/149/84111714960a293415b1d24edf92f56b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ansammlung von Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich sind unsere sieben Zellen jetzt wundersch√∂n in einem kompakten sechseckigen Bereich verpackt, wenn die zentrale Zelle nicht am Rand der Karte angezeigt wird. </font><font style="vertical-align: inherit;">Versuchen wir jetzt, eine Plotgr√∂√üe von 30 zu verwenden.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/893/c36/13e/893c3613edfe02b457cc4ee6d191072c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sushi-Masse in 30 Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben wieder die gleiche Form, obwohl es nicht gen√ºgend Zellen gab, um das richtige Sechseck zu erhalten. </font><font style="vertical-align: inherit;">Da der Radius des Diagramms gr√∂√üer ist, ist es wahrscheinlicher, dass es sich nahe am Rand der Karte befindet, wodurch eine andere Form angenommen wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sushi Randomisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√∂chten nicht, dass alle Bereiche gleich aussehen, daher √§ndern wir die Zellenpriorit√§ten geringf√ºgig. </font><font style="vertical-align: inherit;">Jedes Mal, wenn wir eine benachbarte Zelle zum Rand hinzuf√ºgen </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird die Heuristik dieser Zelle nicht 0, sondern 1 </font><font style="vertical-align: inherit;">, wenn die n√§chste Zahl </font><font style="vertical-align: inherit;">kleiner als ein bestimmter Schwellenwert ist. Verwenden wir den Wert 0,5 als Schwellenwert, dh es wirkt sich h√∂chstwahrscheinlich auf die H√§lfte der Zellen aus.</font></font><br><br><pre> <code class="cs hljs"> neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/aec/793/43eaec79315f68e0618fe71c0f93c3f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzerrter Bereich.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch Erh√∂hen der Suchheuristik der Zelle haben wir sie sp√§ter als erwartet besucht. Gleichzeitig werden andere Zellen, die sich einen Schritt weiter vom Zentrum entfernt befinden, fr√ºher besucht, sofern sie nicht auch die Heuristik erh√∂hen. Dies bedeutet, dass wenn wir die Heuristik aller Zellen um einen Wert erh√∂hen, dies keine Auswirkungen auf die Karte hat. Das hei√üt, Schwelle 1 hat keine Auswirkung wie Schwelle 0. Und Schwelle 0,8 entspricht 0,2. Das hei√üt, die Wahrscheinlichkeit von 0,5 macht den Suchvorgang zum "zitterndsten". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das geeignete Ma√ü an Schwingung h√§ngt vom gew√ºnschten Gel√§ndetyp ab. Machen wir es also anpassbar. F√ºgen Sie dem Generator ein generisches Float-Feld </font></font><code>jitterProbability</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Attribut hinzu</font></font><code>Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">begrenzt im Bereich von 0 bis 0,5. </font><font style="vertical-align: inherit;">Geben wir einen Standardwert an, der dem Durchschnitt dieses Intervalls entspricht, d. H. 0,25. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen wir den Generator im Unity-Inspektorfenster konfigurieren.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitterProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/b50/381/795b50381d8c9cda219ff092cf64cee5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wahrscheinlichkeit von Schwankungen. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kannst du es in der Benutzeroberfl√§che des Spiels anpassbar machen?</font></font></b> <div class="spoiler_text">  ,       .           UI,       .          ,      UI.  ,     .         ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um nun zu entscheiden, wann die Heuristik gleich 1 sein soll, verwenden wir die Wahrscheinlichkeit anstelle eines konstanten Werts. </font></font><br><br><pre> <code class="cs hljs"> neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; jitterProbability ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verwenden die heuristischen Werte 0 und 1. Obwohl gr√∂√üere Werte verwendet werden k√∂nnen, verschlechtert dies die Verformung der Abschnitte erheblich und verwandelt sie h√∂chstwahrscheinlich in ein B√ºndel von Streifen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erhebe etwas Land </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden uns nicht auf die Erzeugung eines St√ºcks Land beschr√§nken. </font><font style="vertical-align: inherit;">Zum Beispiel platzieren wir einen Aufruf </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">innerhalb einer Schleife, um f√ºnf Abschnitte zu erhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d42/83f/acd/d4283facd88705107d705290c3d8e78b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºnf Grundst√ºcke. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir jetzt f√ºnf Parzellen mit jeweils 30 Zellen erzeugen, erhalten wir nicht unbedingt genau 150 Zellen Land. </font><font style="vertical-align: inherit;">Da jede Site separat erstellt wird, kennen sie sich nicht, sodass sie sich √ºberschneiden k√∂nnen. </font><font style="vertical-align: inherit;">Dies ist normal, da dadurch interessantere Landschaften als nur einzelne Abschnitte erstellt werden k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Variabilit√§t des Landes zu erh√∂hen, k√∂nnen wir auch die Gr√∂√üe jedes Grundst√ºcks √§ndern. </font><font style="vertical-align: inherit;">F√ºgen Sie zwei ganzzahlige Felder hinzu, um die minimale und maximale Gr√∂√üe der Diagramme zu steuern. </font><font style="vertical-align: inherit;">Weisen Sie ihnen ein ausreichend gro√ües Intervall zu, z. B. 20-200. </font><font style="vertical-align: inherit;">Ich werde das Standardminimum auf 30 und das Standardmaximum auf 100 setzen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(20, 200)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMin = <span class="hljs-number"><span class="hljs-number">30</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMax = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/026/e43/9ea026e43e949f571be0358332447de5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√∂√üenintervall. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese Felder, um die Gr√∂√üe des Bereichs beim Aufruf zuf√§llig zu bestimmen </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/124/dab/0df124dab1f706825f75304d2862aea3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºnf zuf√§llig gro√üe Abschnitte auf der mittleren Karte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstelle genug Sushi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwar k√∂nnen wir die Menge des erzeugten Landes nicht besonders kontrollieren. </font><font style="vertical-align: inherit;">Obwohl wir die Konfigurationsoption f√ºr die Anzahl der Diagramme hinzuf√ºgen k√∂nnen, sind die Diagramme selbst zuf√§llig gro√ü und k√∂nnen sich geringf√ºgig oder stark √ºberlappen. </font><font style="vertical-align: inherit;">Daher garantiert die Anzahl der Standorte nicht den Erhalt der erforderlichen Landmenge auf der Karte. </font><font style="vertical-align: inherit;">F√ºgen wir eine Option hinzu, um den Prozentsatz des Landes, der als Ganzzahl ausgedr√ºckt wird, direkt zu steuern. </font><font style="vertical-align: inherit;">Da 100% Land oder Wasser nicht sehr interessant sind, beschr√§nken wir es auf das Intervall 5‚Äì95 mit einem Standardwert von 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(5, 95)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/281/912/21e281912ad5a4a5378c5e55514c639c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozentsatz von Sushi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Schaffung der richtigen Menge Land zu gew√§hrleisten, m√ºssen wir nur weiterhin Gebiete des Gel√§ndes anheben, bis wir eine ausreichende Menge erhalten. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir den Prozess kontrollieren, der die Erzeugung von Land erschwert. </font><font style="vertical-align: inherit;">Ersetzen wir daher den vorhandenen Zyklus zum Erh√∂hen von Websites durch Aufrufen einer neuen Methode </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das erste, was diese Methode macht, ist die Anzahl der Zellen zu berechnen, die Land werden sollen. </font><font style="vertical-align: inherit;">Diese Menge ist unsere Gesamtsumme der Sushi-Zellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; 5; i++) { // RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + 1)); // } CreateLand(); for (int i = 0; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = 0; } } void CreateLand () { int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f); }</span></span></code> </pre> <br> <code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird verursachen, </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis wir die gesamte Menge an Zellen ausgegeben haben. </font><font style="vertical-align: inherit;">Um den Betrag nicht zu √ºberschreiten, √§ndern wir ihn </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass er den Betrag als zus√§tzlichen Parameter erh√§lt. </font><font style="vertical-align: inherit;">Nach Beendigung der Arbeit muss er den Restbetrag zur√ºckgeben.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void RaiseTerrain (int chunkSize) { int RaiseTerrain (int chunkSize, int budget) { ‚Ä¶ return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Menge sollte jedes Mal abnehmen, wenn die Zelle von der Grenze entfernt und in Land umgewandelt wird. </font><font style="vertical-align: inherit;">Wenn danach der gesamte Betrag ausgegeben wird, m√ºssen wir die Suche beenden und die Site vervollst√§ndigen. </font><font style="vertical-align: inherit;">Au√üerdem sollte dies nur erfolgen, wenn die aktuelle Zelle noch nicht gelandet ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann es Land anheben, bis es die gesamte Menge an Zellen verbraucht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { landBudget = RaiseTerrain( Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>), landBudget ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d15/34e/7f4/d1534e7f47ba4cf87f3dbeed60aa7d00.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genau die H√§lfte der Karte wurde Land. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ber√ºcksichtigen Sie die H√∂he </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Land ist nicht nur eine flache Platte, die durch die K√ºste begrenzt ist. </font><font style="vertical-align: inherit;">Sie hat eine wechselnde H√∂he mit H√ºgeln, Bergen, T√§lern, Seen und so weiter. </font><font style="vertical-align: inherit;">Aufgrund des Zusammenspiels sich langsam bewegender tektonischer Platten bestehen gro√üe H√∂henunterschiede. </font><font style="vertical-align: inherit;">Obwohl wir es nicht simulieren werden, sollten unsere Landfl√§chen in gewisser Weise solchen Platten √§hneln. </font><font style="vertical-align: inherit;">Websites bewegen sich nicht, k√∂nnen sich jedoch √ºberschneiden. </font><font style="vertical-align: inherit;">Und das k√∂nnen wir nutzen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schieben Sie das Land nach oben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Grundst√ºck repr√§sentiert einen Teil des Landes, der aus dem Meeresboden herausgedr√ºckt wurde. </font><font style="vertical-align: inherit;">Erh√∂hen wir daher st√§ndig die H√∂he der aktuellen Zelle </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sehen, was passiert.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f6e/d3e/b3cf6ed3e71eb737ea7246c92bdd5624.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lande mit H√∂hen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die H√∂hen, aber es ist schwer zu sehen. </font><font style="vertical-align: inherit;">Sie k√∂nnen sie besser lesbar machen, wenn Sie f√ºr jede H√∂henstufe einen eigenen Gel√§ndetyp verwenden, z. B. eine geografische Schichtung. </font><font style="vertical-align: inherit;">Wir werden dies nur tun, damit die H√∂hen besser erkennbar sind, sodass Sie die H√∂henebene einfach als H√∂henindex verwenden k√∂nnen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was passiert, wenn die H√∂he die Anzahl der Gel√§ndetypen √ºberschreitet?</font></font></b> <div class="spoiler_text">        .        ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt den Gel√§ndetyp der Zelle bei jeder H√∂hen√§nderung zu aktualisieren, erstellen wir eine separate Methode </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um alle Gel√§ndetypen nur einmal festzulegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); cell.TerrainTypeIndex = cell.Elevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden diese Methode nach dem Erstellen von Sushi aufrufen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateLand(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann </font><font style="vertical-align: inherit;">er </font><font style="vertical-align: inherit;">sich nicht mehr mit der Art der Erleichterung befassen und sich auf H√∂hen konzentrieren. </font><font style="vertical-align: inherit;">Dazu m√ºssen Sie die Logik √§ndern. </font><font style="vertical-align: inherit;">Wenn die neue H√∂he der aktuellen Zelle 1 ist, ist sie gerade zu Land geworden, sodass die Summe der Zellen abgenommen hat, was zum Abschluss des Wachstums des Standorts f√ºhren kann.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (current.TerrainTypeIndex == 0) { // current.TerrainTypeIndex = 1; // if (--budget == 0) { // break; // } // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/eec/b9e/ee0eecb9e59f527bd27f0275e230de0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schichtung der Schichten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasser hinzuf√ºgen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns explizit angeben, welche Zellen Wasser oder Land sind, und den Wasserstand f√ºr alle Zellen auf 1 einstellen. F√ºhren Sie dies aus, </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bevor Sie Land erstellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = <span class="hljs-number"><span class="hljs-number">1</span></span>; } CreateLand(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr die Bezeichnung von Landschichten k√∂nnen wir nun alle Gel√§ndearten verwenden. </font><font style="vertical-align: inherit;">Alle U-Boot-Zellen bleiben Sand, ebenso wie die niedrigsten Landzellen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem der Wasserstand von der H√∂he abgezogen und der Wert als Index f√ºr den Relieftyp verwendet wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { cell.TerrainTypeIndex = cell.Elevation - cell.WaterLevel; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b5/449/bc3/1b5449bc37b1c677d908484c7bcd0286.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Land und Wasser.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erh√∂hen Sie den Wasserstand </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind nicht auf einen Wasserstand beschr√§nkt. </font><font style="vertical-align: inherit;">Machen wir es anpassbar, indem wir ein gemeinsames Feld mit einem Intervall von 1 bis 5 und einem Standardwert von 3 verwenden. </font><font style="vertical-align: inherit;">Verwenden Sie diese Ebene beim Initialisieren der Zellen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 5)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel = <span class="hljs-number"><span class="hljs-number">3</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/9cf/82f/c329cf82f9a847ac01f2754cc3252500.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/c9d/fe4/850c9dfe4694834486bf4be64ac1783a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasserstand 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Wasserstand 3 ist, bekommen wir weniger Land als erwartet. </font><font style="vertical-align: inherit;">Dies liegt daran </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dass </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">immer noch glaubt, dass der Wasserstand 1 ist. Lassen Sie es uns beheben.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung h√∂herer Wasserst√§nde f√ºhrt dazu. </font><font style="vertical-align: inherit;">dass die Zellen nicht sofort landen. </font><font style="vertical-align: inherit;">Wenn der Wasserstand 2 ist, bleibt der erste Abschnitt immer noch unter Wasser. </font><font style="vertical-align: inherit;">Der Meeresboden ist gestiegen, bleibt aber immer noch unter Wasser. </font><font style="vertical-align: inherit;">Ein Land wird nur am Schnittpunkt von mindestens zwei Abschnitten gebildet. </font><font style="vertical-align: inherit;">Je h√∂her der Wasserstand, desto mehr Standorte m√ºssen √ºberquert werden, um Land zu schaffen. </font><font style="vertical-align: inherit;">Mit steigendem Wasserstand wird das Land daher chaotischer. </font><font style="vertical-align: inherit;">Wenn mehr Grundst√ºcke ben√∂tigt werden, ist es au√üerdem wahrscheinlicher, dass sie sich auf bereits vorhandenem Land kreuzen, wodurch Berge h√§ufiger vorkommen, und flaches Land weniger wahrscheinlich, wie im Fall der Verwendung kleinerer Grundst√ºcke.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c39/f02/abf/c39f02abf2bfa93f01395208da92ae9a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/01f/4e2/5a901f4e2785456e0784f33508be4ede.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/816/cc1/863816cc19c0fd7cbf172905962970d9.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/412/190/fd041219043df072443b00d6799f3946.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wasserstand betr√§gt 2‚Äì5, Sushi immer 50%. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertikale Bewegung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bisher haben wir die Grundst√ºcke jeweils um eine Ebene angehoben, m√ºssen uns aber nicht darauf beschr√§nken. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hohe Standorte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl jeder Abschnitt die H√∂he seiner Zellen um eine Ebene erh√∂ht, k√∂nnen Ausschnitte auftreten. </font><font style="vertical-align: inherit;">Dies geschieht, wenn sich die Kanten zweier Abschnitte ber√ºhren. </font><font style="vertical-align: inherit;">Dies kann zu isolierten Klippen f√ºhren, aber lange Klippenlinien sind selten. </font><font style="vertical-align: inherit;">Wir k√∂nnen die H√§ufigkeit ihres Auftretens erh√∂hen, indem wir die H√∂he des Diagramms um mehr als einen Schritt erh√∂hen. </font><font style="vertical-align: inherit;">Dies muss jedoch nur f√ºr einen bestimmten Anteil der Websites erfolgen. </font><font style="vertical-align: inherit;">Wenn alle Bereiche hoch ansteigen, ist es sehr schwierig, sich im Gel√§nde zu bewegen. </font><font style="vertical-align: inherit;">Lassen Sie uns diesen Parameter mithilfe eines Wahrscheinlichkeitsfelds mit einem Standardwert von 0,25 anpassbar machen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highRiseProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/485/8d7/cb64858d7531bb31842aebdd49b68304.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahrscheinlichkeit eines starken Anstiegs der Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir jede H√∂henerh√∂hung f√ºr hohe Bereiche verwenden k√∂nnen, ger√§t dies schnell au√üer Kontrolle. </font><font style="vertical-align: inherit;">Der H√∂henunterschied 2 erzeugt bereits Klippen, das ist also genug. </font><font style="vertical-align: inherit;">Da Sie eine H√∂he √ºberspringen k√∂nnen, die dem Wasserstand entspricht, m√ºssen wir die Art und Weise √§ndern, in der wir feststellen, ob eine Zelle zu Land geworden ist. </font><font style="vertical-align: inherit;">Wenn es unter dem Wasserspiegel lag und jetzt auf dem gleichen oder einem h√∂heren Niveau liegt, haben wir eine neue Landzelle erstellt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rise = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; current.Elevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b31/8c1/ea5/b318c1ea557ced17d2cb0d9a951bcfc3.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ba/353/78b/4ba35378bc60e74b624e136b90a4a7eb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/8ac/b0a/ea38acb0a5cf12835c2ba177e41d6178.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/018/0df/bd9/0180dfbd9869a0d0e0d5a1712af34fb3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahrscheinlichkeiten eines starken H√∂henanstiegs betragen 0,25, 0,50, 0,75 und 1.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Senke das Land </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Land steigt nicht immer, manchmal f√§llt es. </font><font style="vertical-align: inherit;">Wenn das Land tief genug f√§llt, f√ºllt es Wasser und es geht verloren. </font><font style="vertical-align: inherit;">Bisher machen wir das nicht. </font><font style="vertical-align: inherit;">Da wir nur die Gebiete nach oben schieben, sieht das Land normalerweise aus wie eine Reihe ziemlich runder Gebiete, die miteinander vermischt sind. </font><font style="vertical-align: inherit;">Wenn wir den Bereich manchmal absenken, erhalten wir unterschiedlichere Formen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/95e/d81/9e495ed818dfffc39e5a238f273c8c5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gro√üe Karte ohne versunkenes Sushi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die H√§ufigkeit der Landabsenkung mithilfe eines anderen Wahrscheinlichkeitsfelds steuern. </font><font style="vertical-align: inherit;">Da das Absenken Land zerst√∂ren kann, sollte die Wahrscheinlichkeit des Absenkens immer geringer sein als die Wahrscheinlichkeit des Anhebens. </font><font style="vertical-align: inherit;">Andernfalls kann es sehr lange dauern, bis der richtige Prozentsatz an Land erreicht ist. </font><font style="vertical-align: inherit;">Verwenden wir daher eine maximale Absenkungswahrscheinlichkeit von 0,4 mit einem Standardwert von 0,2.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.4f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sinkProbability = <span class="hljs-number"><span class="hljs-number">0.2f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/997/e82/a11997e824700a045e9faaedaafeb121.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wahrscheinlichkeit des Absenkens. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Absenken der Site √§hnelt dem Anheben mit einigen Unterschieden. </font><font style="vertical-align: inherit;">Daher duplizieren wir die Methode </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und √§ndern ihren Namen in </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anstatt die Gr√∂√üe des Anstiegs zu bestimmen, ben√∂tigen wir einen Absenkungswert, der dieselbe Logik verwenden kann. </font><font style="vertical-align: inherit;">Gleichzeitig m√ºssen Vergleiche durchgef√ºhrt werden, um zu √ºberpr√ºfen, ob wir die Wasseroberfl√§che passiert haben. </font><font style="vertical-align: inherit;">Au√üerdem sind wir beim Absenken des Reliefs nicht auf die Summe der Zellen beschr√§nkt. </font><font style="vertical-align: inherit;">Stattdessen gibt jede verlorene Sushi-Zelle den daf√ºr ausgegebenen Betrag zur√ºck, sodass wir ihn erh√∂hen und weiterarbeiten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; current.Elevation &lt; waterLevel <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; --budget == 0 ) { // break; budget += 1; } size += 1; ‚Ä¶ } searchFrontier.Clear(); return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen wir </font><font style="vertical-align: inherit;">bei jeder Iteration im Inneren </font><font style="vertical-align: inherit;">das Land entweder senken oder erh√∂hen, abh√§ngig von der Wahrscheinlichkeit des Absenkens.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/c5e/762/d6bc5e76274e4aa9c8a692f90fde3646.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/8ae/3e3/c2f8ae3e3a4b814b6ae954d40225149e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/f5d/461/1e3f5d461421feddbb145d4e1d56c000.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33b/39d/462/33b39d462682688fc2a8094556e4fc91.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahrscheinlichkeit eines Abfalls betr√§gt 0,1, 0,2, 0,3 und 0,4.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> H√∂he begrenzen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegenw√§rtig k√∂nnen wir m√∂glicherweise viele Abschnitte √ºberlappen, manchmal mit mehreren H√∂henerh√∂hungen, von denen einige nach unten und dann wieder nach oben gehen k√∂nnen. </font><font style="vertical-align: inherit;">Gleichzeitig k√∂nnen wir sehr hohe und manchmal sehr niedrige H√∂hen schaffen, insbesondere wenn ein hoher Prozentsatz an Land ben√∂tigt wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/c2e/359/f3fc2e359db04b4411f2bcd06b81888b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riesige H√∂hen bei 90% Land. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die H√∂he zu begrenzen, f√ºgen wir ein benutzerdefiniertes Minimum und Maximum hinzu. </font><font style="vertical-align: inherit;">Ein vern√ºnftiges Minimum liegt irgendwo zwischen -4 und 0, und ein akzeptables Maximum kann im Bereich von 6 bis 10 liegen. </font><font style="vertical-align: inherit;">Die Standardwerte sind -2 und 8. Wenn Sie die Karte manuell bearbeiten, liegen sie au√üerhalb des zul√§ssigen Grenzwerts, sodass Sie den Schieberegler der Benutzeroberfl√§che des Editors √§ndern oder unver√§ndert lassen k√∂nnen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(-4, 0)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMinimum = <span class="hljs-number"><span class="hljs-number">-2</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMaximum = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/20b/efc/bcb20befc496cd2c5bffbc94b0a9d267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimale und maximale H√∂he. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen wir sicherstellen, dass die H√∂he das zul√§ssige Maximum nicht √ºberschreitet. </font><font style="vertical-align: inherit;">Dies kann durch √úberpr√ºfen erfolgen, ob die aktuellen Zellen zu hoch sind. </font><font style="vertical-align: inherit;">Wenn ja, √ºberspringen wir sie, ohne die H√∂he zu √§ndern und ihre Nachbarn hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">Dies f√ºhrt dazu, dass Landfl√§chen Gebiete meiden, die eine maximale H√∂he erreicht haben, und um sie herum wachsen.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &gt; elevationMaximum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; newElevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen Sie dasselbe in </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber f√ºr eine minimale H√∂he.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = current.Elevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &lt; elevationMinimum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; newElevation &lt; waterLevel ) { budget += <span class="hljs-number"><span class="hljs-number">1</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/cbe/339/4afcbe339d0d697779ff0649f6c2c125.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begrenzte H√∂he mit 90% Land.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erhalt der negativen H√∂he </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt kann der Speicher- und Ladecode keine negativen H√∂hen verarbeiten, da die H√∂he als Byte gespeichert wird. </font><font style="vertical-align: inherit;">Eine negative Zahl wird beim Speichern in eine gro√üe positive Zahl umgewandelt. </font><font style="vertical-align: inherit;">Daher k√∂nnen beim Speichern und Laden der generierten Karte sehr hohe Karten anstelle der urspr√ºnglichen Unterwasserzellen angezeigt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen negative H√∂hen unterst√ºtzen, indem wir sie als Ganzzahl und nicht als Byte speichern. </font><font style="vertical-align: inherit;">Wir m√ºssen jedoch immer noch nicht mehrere H√∂henstufen unterst√ºtzen. </font><font style="vertical-align: inherit;">Zus√§tzlich k√∂nnen wir den gespeicherten Wert durch Hinzuf√ºgen von 127 versetzen. Dadurch k√∂nnen wir H√∂hen im Bereich von ‚Äì127‚Äì128 innerhalb eines Bytes korrekt speichern. </font><font style="vertical-align: inherit;">√Ñndern Sie </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entsprechend.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(elevation + <span class="hljs-number"><span class="hljs-number">127</span></span>)); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir die Art und Weise, wie wir Kartendaten speichern, ge√§ndert haben, erh√∂hen wir sie </font></font><code>SaveLoadMenu.mapFileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">schlie√ülich </font><font style="vertical-align: inherit;">so, dass 127 von den aus Dateien der Version 4 geladenen H√∂hen abgezogen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { elevation -= <span class="hljs-number"><span class="hljs-number">127</span></span>; } ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die gleiche Karte neu erstellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir eine Vielzahl von Karten erstellen. </font><font style="vertical-align: inherit;">Bei der Generierung wird jedes neue Ergebnis zuf√§llig sein. </font><font style="vertical-align: inherit;">Mit den Konfigurationsoptionen k√∂nnen wir nur die Eigenschaften der Karte steuern, nicht jedoch die genaueste Form. </font><font style="vertical-align: inherit;">Aber manchmal m√ºssen wir genau dieselbe Karte erneut erstellen. </font><font style="vertical-align: inherit;">Zum Beispiel, um eine sch√∂ne Karte mit einem Freund zu teilen oder nach der manuellen Bearbeitung erneut zu beginnen. </font><font style="vertical-align: inherit;">Es ist auch n√ºtzlich f√ºr den Spieleentwicklungsprozess. F√ºgen wir diese Funktion hinzu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden von Seed </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Kartengenerierungsprozess unvorhersehbar zu machen, verwenden wir </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um wieder dieselbe pseudozuf√§llige Folge von Zahlen zu erhalten, m√ºssen Sie denselben Startwert verwenden. </font><font style="vertical-align: inherit;">Wir haben bereits zuvor einen √§hnlichen Ansatz gew√§hlt </font></font><code>HexMetrics.InitializeHashGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zun√§chst wird der aktuelle Status des mit einem bestimmten Startwert initialisierten Zahlengenerators gespeichert und anschlie√üend der urspr√ºngliche Status wiederhergestellt. </font><font style="vertical-align: inherit;">Wir k√∂nnen den gleichen Ansatz f√ºr verwenden </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir k√∂nnen uns wieder an den alten Zustand erinnern und ihn nach Abschluss wiederherstellen, um nichts anderes zu st√∂ren, was verwendet wird </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; ‚Ä¶ Random.state = originalRandomState; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes m√ºssen wir den Startwert zur Verf√ºgung stellen, mit dem die letzte Karte generiert wurde. </font><font style="vertical-align: inherit;">Dies erfolgt mithilfe eines gemeinsamen Ganzzahlfelds.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/3b5/538/41d3b553898698698636b6bada081aa6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startwert anzeigen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt brauchen wir den Startwert zum Initialisieren </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um zuf√§llige Karten zu erstellen, m√ºssen Sie einen zuf√§lligen Startwert verwenden. </font><font style="vertical-align: inherit;">Der einfachste Ansatz besteht darin, einen beliebigen Startwert zum Generieren zu verwenden </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Damit der anf√§ngliche Zufallszustand nicht beeinflusst wird, m√ºssen wir dies nach dem Speichern tun.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); Random.InitState(seed); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir nach Abschluss einen zuf√§lligen Zustand wiederherstellen, erhalten wir, wenn wir sofort eine andere Karte generieren, den gleichen Startwert. </font><font style="vertical-align: inherit;">Au√üerdem wissen wir nicht, wie der anf√§ngliche Zufallszustand initialisiert wurde. </font><font style="vertical-align: inherit;">Obwohl es als willk√ºrlicher Ausgangspunkt dienen kann, ben√∂tigen wir daher etwas mehr, um es bei jedem Aufruf zuf√§llig zu ordnen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt verschiedene M√∂glichkeiten, Zufallszahlengeneratoren zu initialisieren. </font><font style="vertical-align: inherit;">In diesem Fall k√∂nnen Sie einfach mehrere beliebige Werte kombinieren, die √ºber einen weiten Bereich variieren. Das hei√üt, die Wahrscheinlichkeit, dieselbe Karte erneut zu generieren, ist gering. </font><font style="vertical-align: inherit;">Zum Beispiel verwenden wir die unteren 32 Bits der Systemzeit, ausgedr√ºckt in Zyklen, plus die aktuelle Laufzeit der Anwendung. </font><font style="vertical-align: inherit;">Kombinieren Sie diese Werte mit der bitweisen exklusiven ODER-Verkn√ºpfung, damit das Ergebnis nicht sehr gro√ü ist.</font></font><br><br><pre> <code class="cs hljs"> seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die resultierende Zahl kann negativ sein, was f√ºr einen Startwert mit √∂ffentlichem Wert nicht sehr gut aussieht. </font><font style="vertical-align: inherit;">Wir k√∂nnen es streng positiv machen, indem wir eine bitweise Maskierung mit einem maximalen ganzzahligen Wert verwenden, der das Vorzeichenbit zur√ºcksetzt.</font></font><br><br><pre> <code class="cs hljs"> seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; Random.InitState(seed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wiederverwendbarer Samen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir generieren immer noch zuf√§llige Karten, aber jetzt k√∂nnen wir sehen, welcher Startwert f√ºr jede von ihnen verwendet wurde. </font><font style="vertical-align: inherit;">Um dieselbe Karte erneut zu erstellen, m√ºssen wir den Generator anweisen, denselben Startwert erneut zu verwenden, anstatt einen neuen zu erstellen. </font><font style="vertical-align: inherit;">Wir werden dies tun, indem wir einen Schalter unter Verwendung eines Booleschen Feldes hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useFixedSeed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/200/4c6/eed/2004c6eed8c2244bdfe660bf477d2fa3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option zur Verwendung eines konstanten Samens. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein konstanter Startwert ausgew√§hlt ist, √ºberspringen wir einfach die Generierung des neuen Startwerts in </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir das Startfeld nicht manuell √§ndern, ist das Ergebnis wieder dieselbe Karte.</font></font><br><br><pre> <code class="cs hljs"> Random.State originalRandomState = Random.state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!useFixedSeed) { seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.time; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir den Startwert der gew√ºnschten Karte kopieren und irgendwo speichern, um ihn in Zukunft erneut zu generieren. </font><font style="vertical-align: inherit;">Vergessen Sie nicht, dass wir nur dann dieselbe Karte erhalten, wenn wir genau dieselben Generatorparameter verwenden, dh dieselbe Kartengr√∂√üe sowie alle anderen Konfigurationsoptionen. </font><font style="vertical-align: inherit;">Selbst eine kleine √Ñnderung dieser Wahrscheinlichkeiten kann eine v√∂llig andere Karte erzeugen. </font><font style="vertical-align: inherit;">Daher m√ºssen wir uns zus√§tzlich zum Startwert alle Einstellungen merken.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/cd2/279/7ffcd2279b4dd882db924d8e1fc61d0e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/486/6db/156/4866db15628d75936b7e19fa4841f2f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gro√üe Karten mit Startwerten 0 und 929396788, Standardparameter. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427003/">https://habr.com/ru/post/de427003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426991/index.html">Startup Digest: 10 bevorstehende IT-Events in Moskau</a></li>
<li><a href="../de426993/index.html">Muss ich C lernen, um zu verstehen, wie ein Computer funktioniert?</a></li>
<li><a href="../de426995/index.html">Recycling schadet sowohl Produkten als auch Mitarbeitern</a></li>
<li><a href="../de426997/index.html">So erstellen Sie benutzerdefinierte Formen mit MaterialShapeDrawable</a></li>
<li><a href="../de426999/index.html">Den Trends folgen oder sich in Richtung RxJava und LiveData bewegen</a></li>
<li><a href="../de427005/index.html">KI-Entwickler - der Beruf der Million√§re?</a></li>
<li><a href="../de427009/index.html">"Gehen" eines Elektrons: Manipulationen mit einer Ladung innerhalb der Struktur unges√§ttigter Bindungen</a></li>
<li><a href="../de427011/index.html">Meine "Hallo Welt!" auf FPGA oder der n√§chsten Version von UART</a></li>
<li><a href="../de427013/index.html">Von Angesicht zu Angesicht NeoQUEST-2018: Denken Sie daran, wie es war</a></li>
<li><a href="../de427015/index.html">Warum ben√∂tigen kommerzielle intelligente Rechenzentren intelligente PDUs?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>