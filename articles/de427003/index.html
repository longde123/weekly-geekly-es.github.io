<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚧 👩🏼‍⚕️ 🐄 Hexagon-Karten in Unity: Nebel des Krieges, Kartenforschung, prozedurale Generierung 👨🏻‍💻 👩🏿‍🔬 🥠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenhöhen 

 Teile 4-7: Unebenheiten, Flüsse und Straßen 

 Teile 8-11: Wasser, Landformen und Wälle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hexagon-Karten in Unity: Nebel des Krieges, Kartenforschung, prozedurale Generierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427003/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenhöhen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Flüsse und Straßen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und Wälle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 20: Der Nebel des Krieges </h1><br><ul><li>  Speichern Sie die Zellendaten in der Textur. </li><li>  Reliefarten ohne Triangulation ändern. </li><li>  Wir verfolgen die Sichtbarkeit. </li><li>  Verdunkeln Sie alles Unsichtbare. </li></ul><br>  In diesem Teil werden wir der Karte den Nebel des Kriegseffekts hinzufügen. <br><br>  Jetzt wird die Serie auf Unity 2017.1.0 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg"></div><br>  <i>Jetzt sehen wir, dass wir sehen können und nicht sehen können.</i> <br><a name="habracut"></a><br><h2>  Zellendaten im Shader </h2><br>  Viele Strategiespiele verwenden das Konzept des Nebel des Krieges.  Dies bedeutet, dass die Sicht des Spielers eingeschränkt ist.  Er kann nur sehen, was sich in der Nähe seiner Einheiten oder seines kontrollierten Bereichs befindet.  Obwohl wir die Erleichterung sehen können, wissen wir nicht, was dort passiert.  Normalerweise wird das unsichtbare Gelände dunkler.  Um dies zu realisieren, müssen wir die Sichtbarkeit der Zelle verfolgen und entsprechend rendern. <br><br>  Die einfachste Möglichkeit, das Erscheinungsbild ausgeblendeter Zellen zu ändern, besteht darin, den Netzdaten eine Sichtbarkeitsmetrik hinzuzufügen.  Gleichzeitig müssen wir jedoch eine neue Relieftriangulation mit einer Änderung der Sichtbarkeit beginnen.  Dies ist eine schlechte Entscheidung, da sich die Sichtbarkeit während des Spiels ständig ändert. <br><br>  Oft wird die Technik des Renderns über der Topographie einer durchscheinenden Oberfläche verwendet, bei der für den Spieler unsichtbare Zellen teilweise maskiert werden.  Diese Methode eignet sich für relativ flaches Gelände in Kombination mit einem begrenzten Betrachtungswinkel.  Da unser Gelände jedoch sehr unterschiedliche Höhen und Objekte enthalten kann, die aus verschiedenen Winkeln betrachtet werden können, benötigen wir hierfür ein sehr detailliertes Netz, das der Form des Geländes entspricht.  Diese Methode ist teurer als der oben erwähnte einfachste Ansatz. <br><br>  Ein anderer Ansatz besteht darin, die Daten der Zellen beim Rendern getrennt vom Reliefnetz an den Shader zu übertragen.  Dadurch können wir die Triangulation nur einmal durchführen.  Zellendaten können mit Textur übertragen werden.  Das Ändern der Textur ist viel einfacher als das Triangulieren des Geländes.  Darüber hinaus ist das Ausführen mehrerer zusätzlicher Texturmuster schneller als das Rendern einer einzelnen durchscheinenden Ebene. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist mit Shader-Arrays?</b> <div class="spoiler_text">  Sie können Zellendaten auch mithilfe eines Vektorarrays an den Shader übertragen.  Shader-Arrays haben jedoch eine Größenbeschränkung, die in Tausenden von Bytes gemessen wird, und Texturen können Millionen von Pixeln enthalten.  Zur Unterstützung großer Karten verwenden wir Texturen. </div></div><br><h3>  Zelldatenverwaltung </h3><br>  Wir brauchen eine Möglichkeit, die Textur zu steuern, die die Zelldaten enthält.  Erstellen wir eine neue <code>HexCellShaderData</code> Komponente, die dies <code>HexCellShaderData</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; }</code> </pre> <br>  Beim Erstellen oder Laden einer neuen Karte müssen wir eine neue Textur mit der richtigen Größe erstellen.  Daher fügen wir eine Initialisierungsmethode hinzu, die eine Textur erstellt.  Wir verwenden eine RGBA-Textur ohne Mip-Texturen und linearen Farbraum.  Wir müssen keine Zelldaten mischen, daher verwenden wir die Punktfilterung.  Außerdem sollten Daten nicht reduziert werden.  Jedes Pixel in der Textur enthält Daten aus einer Zelle. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Sollte die Texturgröße mit der Größe der Karte übereinstimmen?</b> <div class="spoiler_text">  Nein, es müssen nur genügend Pixel vorhanden sein, um alle Zellen aufzunehmen.  Bei exakter Übereinstimmung mit der Größe der Karte wird höchstwahrscheinlich eine Textur mit Größen erstellt, die keine Zweierpotenzen sind (Nicht-Zweierpotenzen, NPOT), und dieses Texturformat ist nicht das effektivste.  Obwohl wir den Code so konfigurieren können, dass er mit Texturen der Größe einer Zweierpotenz arbeitet, ist dies eine geringfügige Optimierung, die den Zugriff auf Zellendaten erschwert. </div></div><br>  Tatsächlich müssen wir nicht jedes Mal eine neue Textur erstellen, wenn wir eine neue Karte erstellen.  Es reicht aus, die Größe der Textur zu ändern, wenn sie bereits vorhanden ist.  Wir müssen nicht einmal überprüfen, ob wir bereits die richtige Größe haben, da <code>Texture2D.Resize</code> intelligent genug ist, um dies für uns zu tun. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( cellCountX, cellCountZ, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; } }</code> </pre> <br>  Anstatt die Zelldaten pixelweise anzuwenden, verwenden wir einen Farbpuffer und wenden die Daten aller Zellen gleichzeitig an.  Dazu verwenden wir das <code>Color32</code> Array.  Bei Bedarf erstellen wir am Ende von <code>Initialize</code> eine neue Array-Instanz.  Wenn wir bereits ein Array mit der richtigen Größe haben.  dann löschen wir seinen Inhalt. <br><br><pre> <code class="cs hljs"> Texture2D cellTexture; Color32[] cellTextureData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || cellTextureData.Length != x * z) { cellTextureData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32[x * z]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellTextureData.Length; i++) { cellTextureData[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was ist color32?</b> <div class="spoiler_text">  Standardmäßige unkomprimierte RGBA-Texturen enthalten 4-Byte-Pixel.  Jeder der vier Farbkanäle empfängt ein Byte, dh sie haben 256 mögliche Werte.  Bei Verwendung der Unity <code>Color</code> Struktur werden die Gleitkommakomponenten im Intervall 0–1 im Intervall 0–255 in Bytes konvertiert.  Beim Abtasten führt die GPU die inverse Transformation durch. <br><br>  Die <code>Color32</code> Struktur arbeitet direkt mit Bytes, sodass sie weniger Platz beanspruchen und keine Konvertierung erfordern, was die Effizienz ihrer Verwendung erhöht.  Da wir Zellendaten anstelle von Farben speichern, ist es logischer, direkt mit Rohtexturdaten und nicht mit <code>Color</code> . </div></div><br>  <code>HexGrid</code> sollte sich mit der Erstellung und Initialisierung dieser Zellen im Shader befassen.  Daher fügen wir ihm ein <code>cellShaderData</code> Feld hinzu und erstellen eine Komponente in <code>Awake</code> . <br><br><pre> <code class="cs hljs"> HexCellShaderData cellShaderData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); CreateMap(cellCountX, cellCountZ); }</code> </pre> <br>  Beim Erstellen einer neuen Karte sollte auch <code>cellShaderData</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; cellShaderData.Initialize(cellCountX, cellCountZ); CreateChunks(); CreateCells(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Zellendaten bearbeiten </h3><br>  Bisher war es beim Ändern der Eigenschaften einer Zelle erforderlich, ein oder mehrere Fragmente zu aktualisieren. Jetzt müssen möglicherweise die Daten der Zellen aktualisiert werden.  Dies bedeutet, dass Zellen eine Verknüpfung zu den Zellendaten im Shader haben müssen.  <code>HexCell</code> dazu <code>HexCell</code> eine Eigenschaft <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCellShaderData ShaderData { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  In <code>HexGrid.CreateCell</code> weisen wir dieser Eigenschaft eine Shader-Datenkomponente zu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.ShaderData = cellShaderData; … }</code> </pre> <br>  Jetzt können wir Zellen dazu bringen, ihre Shader-Daten zu aktualisieren.  Während wir die Sichtbarkeit nicht verfolgen, können wir Shader-Daten für etwas anderes verwenden.  Der Relieftyp der Zelle bestimmt die Textur, mit der sie gerendert wird.  Dies hat keinen Einfluss auf die Geometrie der Zelle, sodass wir den Elevationstypindex in den Zellendaten und nicht in den Netzdaten speichern können.  Auf diese Weise können wir die Notwendigkeit einer Triangulation beseitigen, wenn wir die Art des Reliefs der Zelle ändern. <br><br>  Fügen Sie <code>HexCellShaderData</code> eine <code>HexCellShaderData</code> Methode <code>RefreshTerrain</code> , um diese Aufgabe für eine bestimmte Zelle zu vereinfachen.  Lassen wir diese Methode vorerst leer. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Ändern Sie <code>HexCell.TerrainTypeIndex</code> so, dass diese Methode <code>HexCell.TerrainTypeIndex</code> wird und die Fragmente nicht aktualisiert werden sollen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Refresh(); ShaderData.RefreshTerrain(this); } } }</span></span></code> </pre> <br>  Wir werden es auch in <code>HexCell.Load</code> nachdem wir den Typ der <code>HexCell.Load</code> erhalten haben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); RefreshPosition(); … }</code> </pre> <br><h3>  Zellindex </h3><br>  Um diese Zellen zu ändern, müssen wir den Index der Zelle kennen.  Der einfachste Weg, dies zu tun, besteht darin, die <code>Index</code> Eigenschaft zu <code>HexCell</code> .  Es zeigt den Index der Zelle in der Liste der Zellen in der Karte an, der dem Index in den angegebenen Zellen im Shader entspricht. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Dieser Index befindet sich bereits in <code>HexGrid.CreateCell</code> also einfach der erstellten Zelle zu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; … }</code> </pre> <br>  Jetzt kann <code>HexCellShaderData.RefreshTerrain</code> diesen Index verwenden, um <code>HexCellShaderData.RefreshTerrain</code> anzugeben.  Speichern Sie den Elevationstypindex in der Alpha-Komponente des Pixels, indem Sie den Typ einfach in Byte konvertieren.  Dies wird bis zu 256 Geländetypen unterstützen, was für uns ausreichen wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; }</code> </pre> <br>  Um Daten auf eine Textur anzuwenden und an die GPU zu übergeben, müssen Sie <code>Texture2D.SetPixels32</code> und dann <code>Texture2D.Apply</code> .  Wie bei Fragmenten werden wir diese Vorgänge auf <code>LateUpdate</code> sodass sie unabhängig von der Anzahl der geänderten Zellen nicht öfter als einmal pro Frame ausgeführt werden können. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Aktivieren Sie die Komponente nach der Initialisierung, um sicherzustellen, dass die Daten nach dem Erstellen einer neuen Karte aktualisiert werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Triangulation von Zellindizes </h3><br>  Da wir jetzt den Elevationstypindex in diesen Zellen speichern, müssen wir sie nicht mehr in den Triangulationsprozess einbeziehen.  Um jedoch Zellendaten verwenden zu können, muss der Shader wissen, welche Indizes verwendet werden sollen.  Daher müssen Sie Zellindizes in den Netzdaten speichern und die Höhenindizes ersetzen.  Außerdem benötigen wir noch den Farbkanal des Netzes, um Zellen zu mischen, wenn diese Zellen verwendet werden. <br><br>  Wir <code>HexMesh</code> veralteten allgemeinen Felder <code>useColors</code> und <code>useTerrainTypes</code> .  Ersetzen Sie sie durch ein <code>useCellData</code> Feld. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public bool useCollider, useColors, useUVCoordinates, useUV2Coordinates; // public bool useTerrainTypes; public bool useCollider, useCellData, useUVCoordinates, useUV2Coordinates;</span></span></code> </pre><br>  Wir überarbeiten die Umbenennung der <code>cellIndices</code> Liste in <code>cellIndices</code> .  Lassen Sie uns auch <code>colors</code> in <code>cellWeights</code> umbenennen - dieser Name ist besser <code>cellWeights</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes; // [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;Vector3&gt; vertices, cellIndices; [NonSerialized] List&lt;Color&gt; cellWeights; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; [NonSerialized] List&lt;int&gt; triangles;</span></span></code> </pre><br>  Ändern Sie <code>Clear</code> damit bei Verwendung dieser Zellen zwei Listen zusammen und nicht getrennt angezeigt werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { cellWeights = ListPool&lt;Color&gt;.Get(); cellIndices = ListPool&lt;Vector3&gt;.Get(); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // colors = ListPool&lt;Color&gt;.Get(); // } if (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } if (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } // if (useTerrainTypes) { // terrainTypes = ListPool&lt;Vector3&gt;.Get(); // } triangles = ListPool&lt;int&gt;.Get(); }</span></span></code> </pre> <br>  Führen Sie dieselbe Gruppierung in <code>Apply</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { hexMesh.SetColors(cellWeights); ListPool&lt;Color&gt;.Add(cellWeights); hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, cellIndices); ListPool&lt;Vector3&gt;.Add(cellIndices); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // hexMesh.SetColors(colors); // ListPool&lt;Color&gt;.Add(colors); // } if (useUVCoordinates) { hexMesh.SetUVs(0, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } if (useUV2Coordinates) { hexMesh.SetUVs(1, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } // if (useTerrainTypes) { // hexMesh.SetUVs(2, terrainTypes); // ListPool&lt;Vector3&gt;.Add(terrainTypes); // } hexMesh.SetTriangles(triangles, 0); ListPool&lt;int&gt;.Add(triangles); hexMesh.RecalculateNormals(); if (useCollider) { meshCollider.sharedMesh = hexMesh; } }</span></span></code> </pre> <br>  Entfernen <code>AddTriangleColor</code> <code>AddTriangleTerrainTypes</code> <code>AddTriangleColor</code> und <code>AddTriangleTerrainTypes</code> .  Ersetzen Sie sie durch die entsprechenden <code>AddTriangleCellData</code> Methoden, die jeweils Indizes und Gewichte hinzufügen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddTriangleCellData(indices, weights, weights, weights); }</code> </pre> <br>  Machen Sie dasselbe in der entsprechenden <code>AddQuad</code> Methode. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3, Color weights4 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); cellWeights.Add(weights4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2 </span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights1, weights1, weights2, weights2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights, weights, weights, weights); }</code> </pre> <br><h3>  HexGridChunk Refactoring </h3><br>  Zu diesem Zeitpunkt werden in <code>HexGridChunk</code> viele Compilerfehler <code>HexGridChunk</code> , die <code>HexGridChunk</code> .  Aus Gründen der Konsistenz werden statische Farben zunächst in Gewichte umbenannt. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br>  Beginnen wir mit der Korrektur von <code>TriangulateEdgeFan</code> .  Früher brauchte er einen Typ, jetzt braucht er einen Zellindex.  <code>AddTriangleColor</code> Code <code>AddTriangleColor</code> und <code>AddTriangleTerrainTypes</code> durch den entsprechenden Code <code>AddTriangleCellData</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); terrain.AddTriangle(center, edge.v2, edge.v3); terrain.AddTriangle(center, edge.v3, edge.v4); terrain.AddTriangle(center, edge.v4, edge.v5); Vector3 indices; indices.x = indices.y = indices.z = index; terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = type; // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  Diese Methode wird an mehreren Stellen aufgerufen.  Lassen Sie uns sie durchgehen und sicherstellen, dass der Index der Zelle dorthin übertragen wird und nicht die Art des Geländes. <br><br><pre> <code class="cs hljs"> TriangulateEdgeFan(center, e, cell.Index);</code> </pre> <br>  Als nächstes kommt <code>TriangulateEdgeStrip</code> .  Hier ist alles etwas komplizierter, aber wir verwenden den gleichen Ansatz.  <code>w1</code> <code>w2</code> die Parameternamen <code>c1</code> und <code>c2</code> in <code>w1</code> und <code>w2</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color w1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, EdgeVertices e2, Color w2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); Vector3 indices; indices.x = indices.z = index1; indices.y = index2; terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // Vector3 types; // types.x = types.z = type1; // types.y = type2; // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); if (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</span></span></code> </pre> <br>  Ändern Sie die Aufrufe dieser Methode so, dass der Zellenindex an sie übergeben wird.  Wir halten auch die Variablennamen konsistent. <br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip( m, weights1, cell.Index, e, weights1, cell.Index ); … TriangulateEdgeStrip( e1, weights1, cell.Index, e2, weights2, neighbor.Index, hasRoad ); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w2 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i1 = beginCell.Index; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i2 = endCell.Index; TriangulateEdgeStrip(begin, weights1, i1, e2, w2, i2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color w1 = w2; e2 = EdgeVertices.TerraceLerp(begin, end, i); w2 = HexMetrics.TerraceLerp(weights1, weights2, i); TriangulateEdgeStrip(e1, w1, i1, e2, w2, i2, hasRoad); } TriangulateEdgeStrip(e2, w2, i1, end, weights2, i2, hasRoad); }</code> </pre> <br>  Nun kommen wir zu den Winkelmethoden.  Diese Änderungen sind einfach, müssen jedoch in einer großen Menge Code vorgenommen werden.  Zuerst bei <code>TriangulateCorner</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); Vector3 indices; indices.x = bottomCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangleCellData(indices, weights1, weights2, weights3); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, weights2, weights3); // Vector3 types; // types.x = bottomCell.TerrainTypeIndex; // types.y = leftCell.TerrainTypeIndex; // types.z = rightCell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</span></span></code> </pre> <br>  Kommen zu <code>TriangulateCornerTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w3 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w4 = HexMetrics.TerraceLerp(weights1, weights3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleCellData(indices, weights1, w3, w4); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, w3, w4); // terrain.AddTriangleTerrainTypes(indices); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color w1 = w3; Color w2 = w4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); w3 = HexMetrics.TerraceLerp(weights1, weights2, i); w4 = HexMetrics.TerraceLerp(weights1, weights3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadCellData(indices, w1, w2, w3, w4); // terrain.AddQuadColor(w1, w2, w3, w4); // terrain.AddQuadTerrainTypes(indices); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadCellData(indices, w3, w4, weights2, weights3); // terrain.AddQuadColor(w3, w4, weights2, weights3); // terrain.AddQuadTerrainTypes(indices); }</span></span></code> </pre> <br>  Dann in <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryWeights = Color.Lerp(weights1, weights3, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( begin, weights1, left, weights2, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryColor); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Und etwas anders in <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryWeights = Color.Lerp(weights1, weights2, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( right, weights3, begin, weights1, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryWeights); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Die beiden vorherigen Methoden verwenden das <code>TriangulateBoundaryTriangle</code> , das ebenfalls aktualisiert werden muss. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginWeights, Vector3 left, Color leftWeights, Vector3 boundary, Color boundaryWeights, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleCellData(indices, beginWeights, w2, boundaryWeights); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(beginColor, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color w1 = w2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleCellData(indices, w1, w2, boundaryWeights); // terrain.AddTriangleColor(c1, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleCellData(indices, w2, leftWeights, boundaryWeights); // terrain.AddTriangleColor(c2, leftColor, boundaryColor); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  Die letzte Methode, die geändert werden muss, ist <code>TriangulateWithRiver</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … terrain.AddTriangle(centerL, m.v1, m.v2); terrain.AddQuad(centerL, center, m.v2, m.v3); terrain.AddQuad(center, centerR, m.v3, m.v4); terrain.AddTriangle(centerR, m.v4, m.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; terrain.AddTriangleCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = cell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); … }</span></span></code> </pre> <br>  Damit alles funktioniert, müssen wir angeben, dass wir die Zelldaten für das untergeordnete Element des Reliefs des vorgefertigten Fragments verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/b8c/731/919b8c7317b2aa3c06f1077eef27fe96.png"></div><br>  <i>Das Relief verwendet Zelldaten.</i> <br><br>  Zu diesem Zeitpunkt enthält das Netz Zellindizes anstelle von Höhenindizes.  Da der Elevation Shader sie immer noch als Elevation-Indizes interpretiert, werden wir sehen, dass die erste Zelle mit der ersten Textur usw. gerendert wird, bis die letzte Relief-Textur erreicht ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/a23/ce8/8a5a23ce850af789e759dde6879f93eb.png"></div><br>  <i>Verwenden von Zellindizes als Höhentexturindizes.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Ich kann den überarbeiteten Code nicht zum Laufen bringen.</b>  <b class="spoiler_title">Was mache ich falsch?</b> <div class="spoiler_text">  Zu einer Zeit haben wir eine große Menge an Triangulationscode geändert, sodass eine hohe Wahrscheinlichkeit für Fehler oder Versehen besteht.  Wenn Sie den Fehler nicht finden können, laden Sie das Paket aus diesem Abschnitt herunter und extrahieren Sie die entsprechenden Dateien.  Sie können sie in ein separates Projekt importieren und mit Ihrem eigenen Code vergleichen. </div></div><br><h3>  Übertragen Sie Zellendaten an einen Shader </h3><br>  Um diese Zellen verwenden zu können, muss der Terrain Shader Zugriff darauf haben.  Dies kann über die Shader-Eigenschaft implementiert werden.  Dazu muss <code>HexCellShaderData</code> die Materialeigenschaft des Reliefs <code>HexCellShaderData</code> .  Oder wir können die Textur dieser Zellen für alle Shader global sichtbar machen.  Dies ist praktisch, da wir es in mehreren Shadern benötigen, sodass wir diesen Ansatz verwenden werden. <br><br>  Rufen Sie nach dem Erstellen der <code>Shader.SetGlobalTexture</code> die statische <code>Shader.SetGlobalTexture</code> Methode auf, um sie global als <em>_HexCellData</em> sichtbar zu <em>machen</em> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } … }</code> </pre> <br>  Bei Verwendung der Shader-Eigenschaft stellt Unity dem Shader die <em>Texturgröße</em> über die Variable <em>texturName_TexelSize</em> zur <em>Verfügung</em> .  Dies ist ein Vier-Komponenten-Vektorisierer, der Werte enthält, die invers zur Breite und Höhe sowie zur Breite und Höhe selbst sind.  Beim Festlegen der globalen Textur wird dies jedoch nicht ausgeführt.  Daher werden wir es selbst mit dem <code>Shader.SetGlobalVector</code> nachdem wir die <code>Shader.SetGlobalVector</code> erstellt oder ihre <code>Shader.SetGlobalVector</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } Shader.SetGlobalVector( <span class="hljs-string"><span class="hljs-string">"_HexCellData_TexelSize"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(<span class="hljs-number"><span class="hljs-number">1f</span></span> / x, <span class="hljs-number"><span class="hljs-number">1f</span></span> / z, x, z) );</code> </pre> <br><h3>  Shader-Datenzugriff </h3><br>  Erstellen Sie eine neue Shader-Include-Datei im Materialordner mit dem Namen <em>HexCellData</em> .  Darin definieren wir Variablen für Informationen über die Textur und Größe dieser Zellen.  Wir erstellen auch eine Funktion, um die Zellendaten für die angegebenen Scheitelpunktnetzdaten abzurufen. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _HexCellData; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> _HexCellData_TexelSize; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> GetCellData (appdata_full v) { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/604/dbc/a64604dbc7d3ad5ff1e1578bd0c84eec.png"></div><br>  <i>Neue Include-Datei.</i> <br><br>  <code>v.texcoord2</code> werden in <code>v.texcoord2</code> gespeichert, wie dies bei Geländetypen der Fall war.  Beginnen wir mit dem ersten Index - <code>v.texcoord2.x</code> .  Leider können wir den Index nicht direkt verwenden, um die Textur dieser Zellen abzutasten.  Wir müssen es in UV-Koordinaten umwandeln. <br><br>  Der erste Schritt beim Erstellen der U-Koordinate besteht darin, den Zellenindex durch die Breite der Textur zu teilen.  Wir können dies tun, indem wir es mit <code>_HexCellData_TexelSize.x</code> multiplizieren. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">appdata_full v</span></span></span><span class="hljs-function">)</span></span> { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis ist eine Zahl in der Form ZU, wobei Z der Zeilenindex und U die Koordinate der U-Zelle ist. </font><font style="vertical-align: inherit;">Wir können die Zeichenfolge extrahieren, indem wir die Zahl abrunden und dann von der Zahl subtrahieren, um die U-Koordinate zu erhalten.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die V-Koordinate teilt die Linie durch die Höhe der Textur. </font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir die Textur abtasten, müssen wir die Koordinaten in der Mitte der Pixel verwenden, nicht an ihren Kanten. </font><font style="vertical-align: inherit;">Auf diese Weise garantieren wir, dass die richtigen Pixel abgetastet werden. </font><font style="vertical-align: inherit;">Fügen Sie daher nach dem Teilen durch die Größe der Textur ½ hinzu.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = (v.texcoord2.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies gibt uns die richtigen UV-Koordinaten für den Index der ersten Zelle, die in den Scheitelpunktdaten gespeichert ist. </font><font style="vertical-align: inherit;">Aber obendrein können wir bis zu drei verschiedene Indizes haben. </font><font style="vertical-align: inherit;">Daher werden wir dafür sorgen, dass es </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für jeden Index funktioniert. </font><font style="vertical-align: inherit;">Fügen Sie einen ganzzahligen Parameter hinzu </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem wir auf die Vektorkomponente mit dem Zellenindex zugreifen.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir alle erforderlichen Koordinaten für diese Zellen haben, können wir eine Stichprobe erstellen </font></font><code>_HexCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da wir die Textur im Vertex-Programm abtasten, müssen wir dem Shader explizit mitteilen, welche Mip-Textur verwendet werden soll. </font><font style="vertical-align: inherit;">Dies kann mit einer Funktion erfolgen </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Koordinaten von vier Texturen erfordert. </font><font style="vertical-align: inherit;">Da diese Zellen keine Mip-Texturen haben, weisen wir den zusätzlichen Koordinaten Nullwerte zu.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> data = tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vierte Datenkomponente enthält einen Höhenindex, den wir direkt als Bytes speichern. </font><font style="vertical-align: inherit;">Die GPU konvertierte sie jedoch automatisch in einen Gleitkommawert im Bereich von 0 bis 1. </font><font style="vertical-align: inherit;">Um es wieder in den richtigen Wert zu konvertieren, multiplizieren Sie es mit 255. Danach können Sie die Daten zurückgeben.</font></font><br><br><pre> <code class="hljs kotlin"> float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = tex2Dlod(_HexCellData, float4(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.w *= <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Funktionalität zu nutzen, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktivieren Sie HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da ich diesen Shader in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materials / Terrain platziert habe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , muss ich den relativen Pfad </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">../HexCellData.cginc verwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs lisp"> #include <span class="hljs-string"><span class="hljs-string">"../HexCellData.cginc"</span></span> UNITY_DECLARE_TEX2DARRAY(<span class="hljs-name"><span class="hljs-name">_MainTex</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Vertex-Programm erhalten wir Zelldaten für alle drei in den Vertex-Daten gespeicherten Zellindizes. </font><font style="vertical-align: inherit;">Weisen Sie dann </font></font><code>data.terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ihre Höhenindizes zu.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); // data.terrain = v.texcoord2.xyz; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.terrain.x = cell0.w; data.terrain.y = cell1.w; data.terrain.z = cell2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt zeigte die Karte wieder das richtige Gelände an. </font><font style="vertical-align: inherit;">Der große Unterschied besteht darin, dass das Bearbeiten nur von Geländetypen nicht mehr zu neuen Triangulationen führt. </font><font style="vertical-align: inherit;">Wenn während der Bearbeitung andere Zellendaten geändert werden, wird die Triangulation wie gewohnt durchgeführt. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Basis dieser Zellen erstellt haben, können wir fortfahren, um die Sichtbarkeit zu unterstützen. </font><font style="vertical-align: inherit;">Dazu verwenden wir den Shader, die Zellen selbst und die Objekte, die die Sichtbarkeit bestimmen. </font><font style="vertical-align: inherit;">Beachten Sie, dass der Triangulationsprozess absolut nichts darüber weiß.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir damit, dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader die </font><font style="vertical-align: inherit;">Sichtbarkeit zu erläutern. </font><font style="vertical-align: inherit;">Es empfängt Sichtbarkeitsdaten vom Scheitelpunktprogramm und übergibt sie unter Verwendung der Struktur an das Fragmentprogramm </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da wir drei separate Höhenindizes übergeben, übergeben wir auch drei Sichtbarkeitswerte.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float4 color : <span class="hljs-type"><span class="hljs-type">COLOR</span></span>; float3 worldPos; float3 terrain; float3 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Sichtbarkeit zu speichern, verwenden wir die erste Komponente dieser Zellen. </font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { UNITY_INITIALIZE_OUTPUT(Input, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); float4 cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); float4 cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); float4 cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.x = cell0.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.y = cell1.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.z = cell2.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Sichtbarkeit von 0 bedeutet, dass die Zelle derzeit unsichtbar ist. </font><font style="vertical-align: inherit;">Wenn es sichtbar wäre, hätte es den Wert von Sichtbarkeit 1. Daher können wir das Gelände abdunkeln, indem wir das Ergebnis </font></font><code>GetTerrainColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem entsprechenden Sichtbarkeitsvektor </font><font style="vertical-align: inherit;">multiplizieren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher modulieren wir die Relieffarbe jeder gemischten Zelle individuell.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/183/e69/1bf183e695a42f4691f63cec72255993.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zellen wurden schwarz.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Können wir nicht stattdessen die Sichtbarkeit in einem Vertex-Programm kombinieren?</font></font></b> <div class="spoiler_text">   ,           .              .           .        ,      .   ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Dunkelheit ist eine Büste für vorübergehend unsichtbare Zellen. </font><font style="vertical-align: inherit;">Damit wir das Relief noch sehen können, müssen wir den Indikator für versteckte Zellen erhöhen. </font><font style="vertical-align: inherit;">Wechseln wir von 0–1 zu ¼ - 1, was mit der Funktion </font></font><code>lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende des Scheitelpunktprogramms erfolgen kann.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/090/3e2/a200903e2f31f3bdcd0c996d42f91a02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schattierte Zellen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfolgung der Sichtbarkeit von Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Sichtbarkeit funktioniert, müssen die Zellen ihre Sichtbarkeit verfolgen. Aber wie bestimmt eine Zelle, ob sie sichtbar ist? Wir können dies tun, indem wir die Anzahl der Entitäten verfolgen, die es sehen. Wenn jemand eine Zelle sieht, muss er diese Zelle melden. Und wenn jemand aufhört, die Zelle zu sehen, muss er sie auch darüber informieren. Die Zelle verfolgt einfach die Anzahl der Beobachter, unabhängig davon, um welche Entitäten es sich handelt. Wenn eine Zelle einen Sichtbarkeitswert von mindestens 1 hat, ist sie sichtbar, andernfalls ist sie unsichtbar. Um dieses Verhalten zu implementieren, fügen wir der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen zwei Methoden und eine Eigenschaft hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } } … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visibility; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie als Nächstes der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die genau das Gleiche wie </font></font><code>RefreshTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus Gründen der Sichtbarkeit </font><font style="vertical-align: inherit;">tut </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Speichern Sie die Daten in der Komponente R der Datenzellen. </font><font style="vertical-align: inherit;">Da wir mit Bytes arbeiten, die in die Werte 0–1 konvertiert werden, geben wir die Sichtbarkeit an </font></font><code>(byte)255</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden diese Methode mit zunehmender und abnehmender Sichtbarkeit aufrufen und den Wert zwischen 0 und 1 ändern. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Squad-Sichtbarkeit schaffen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen wir es so, dass die Einheiten die Zelle sehen können, die sie besetzen. </font><font style="vertical-align: inherit;">Dies wird durch einen Anruf </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an den neuen Standort des Geräts während der Aufgabe erreicht </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir rufen auch nach dem alten Standort (falls vorhanden) </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.IncreaseVisibility(); transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/f95/a07/7bcf95a07fdf4c10ed1d53055dddf6a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheiten können sehen, wo sie sind. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endlich haben wir Sichtbarkeit genutzt! </font><font style="vertical-align: inherit;">Beim Hinzufügen zu einer Karte machen Einheiten ihre Zelle sichtbar. </font><font style="vertical-align: inherit;">Außerdem wird ihr Umfang teleportiert, wenn sie an ihren neuen Standort umziehen. </font><font style="vertical-align: inherit;">Ihr Umfang bleibt jedoch aktiv, wenn Einheiten von der Karte entfernt werden. </font><font style="vertical-align: inherit;">Um dies zu beheben, reduzieren wir die Sichtbarkeit ihres Standorts, wenn Einheiten zerstört werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); } location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbereich </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher sehen wir nur die Zelle, in der sich die Ablösung befindet, und dies schränkt die Möglichkeiten ein. Zumindest müssen wir benachbarte Zellen sehen. Im allgemeinen Fall können Einheiten alle Zellen in einem bestimmten Abstand sehen, der von der Einheit abhängt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir der </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu, um alle von einer Zelle aus sichtbaren Zellen unter Berücksichtigung des Bereichs zu finden. Wir können diese Methode durch Duplizieren und Ändern erstellen </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ändern Sie die Parameter und geben Sie eine Liste der Zellen zurück, für die Sie den Listenpool verwenden können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei jeder Iteration wird die aktuelle Zelle zur Liste hinzugefügt. Es gibt keine endgültige Zelle mehr, sodass die Suche niemals endet, wenn sie diesen Punkt erreicht. Wir werden auch die Logik der Umzüge und die Kosten des Umzugs los. Machen Sie die Eigenschaften</font></font><code>PathFrom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie wurden nicht mehr gefragt, weil wir sie nicht brauchen und wir den Weg entlang des Gitters nicht stören wollen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei jedem Schritt erhöht sich der Abstand einfach um 1. Wenn er den Bereich überschreitet, wird diese Zelle übersprungen. </font><font style="vertical-align: inherit;">Und wir brauchen keine Suchheuristik, also initialisieren wir sie mit einem Wert von 0. Das heißt, wir sind im Wesentlichen zum Dijkstra-Algorithmus zurückgekehrt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; visibleCells = ListPool&lt;HexCell&gt;.Get(); searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; visibleCells.Add(current); <span class="hljs-comment"><span class="hljs-comment">// if (current == toCell) { // return true; // } // int currentTurn = (current.Distance - 1) / speed; for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); if ( neighbor == null || neighbor.SearchPhase &gt; searchFrontierPhase ) { continue; } // … // int moveCost; // … int distance = current.Distance + 1; if (distance &gt; range) { continue; } // int turn = (distance - 1) / speed; // if (turn &gt; currentTurn) { // distance = turn * speed + moveCost; // } if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; // neighbor.PathFrom = current; neighbor.SearchHeuristic = 0; searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); } } } return visibleCells; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Können wir nicht einen einfacheren Algorithmus verwenden, um alle Zellen in Reichweite zu finden?</font></font></b> <div class="spoiler_text"> ,          ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie auch </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methoden </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und hinzu </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie erhalten die Zelle und den Bereich, nehmen eine Liste der entsprechenden Zellen und erhöhen / verringern ihre Sichtbarkeit. </font><font style="vertical-align: inherit;">Wenn Sie fertig sind, sollten Sie die Liste wieder in ihren Pool zurückbringen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].IncreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].DecreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Methoden verwenden zu können, </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss auf das Raster zugegriffen werden. Fügen Sie ihm daher eine Eigenschaft hinzu </font></font><code>Grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einem Raster einen Trupp hinzufügen, wird dieser Eigenschaft ein Raster zugewiesen </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst reicht ein Sichtbarkeitsbereich von drei Zellen aus. </font><font style="vertical-align: inherit;">Dazu fügen wir die </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstante hinzu, die sich in Zukunft immer in eine Variable verwandeln kann. </font><font style="vertical-align: inherit;">Dann werden wir den Trupp dazu bringen, Methoden für das Gitter aufzurufen </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch seinen Sichtbarkeitsbereich zu übertragen, und nicht nur an diesen Ort gehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visionRange = <span class="hljs-number"><span class="hljs-number">3</span></span>; … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { <span class="hljs-comment"><span class="hljs-comment">// location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); location.Unit = null; } location = value; value.Unit = this; // value.IncreaseVisibility(); Grid.IncreaseVisibility(value, visionRange); transform.localPosition = value.Position; } } … public void Die () { if (location) { // location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); } location.Unit = null; Destroy(gameObject); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/c45/ccb/8cdc45ccb01449b3c7d50a7bef9b249c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheiten mit Sichtbereich, die sich überlappen können.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit beim Bewegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Moment wird der Sichtbereich des Trupps nach dem Bewegungsbefehl sofort zum Endpunkt teleportiert. </font><font style="vertical-align: inherit;">Es hätte besser ausgesehen, wenn sich das Gerät und sein Sichtfeld zusammen bewegt hätten. </font><font style="vertical-align: inherit;">Der erste Schritt dazu ist, dass wir die Eigenschaft </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font><font style="vertical-align: inherit;">nicht mehr festlegen </font></font><code>HexUnit.Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen ändern wir das Feld direkt </font></font><code>location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und vermeiden den Eigenschaftscode. </font><font style="vertical-align: inherit;">Daher werden wir den alten Standort manuell löschen und einen neuen Standort konfigurieren. </font><font style="vertical-align: inherit;">Die Sicht bleibt unverändert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Location = path[path.Count - 1]; location.Unit = null; location = path[path.Count - 1]; location.Unit = this; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Innerhalb von Coroutinen </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduzieren wir die Sichtbarkeit der ersten Zelle erst nach Fertigstellung </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach, bevor wir zu einer neuen Zelle wechseln, erhöhen wir die Sichtbarkeit dieser Zelle. </font><font style="vertical-align: inherit;">Nachdem wir damit fertig sind, reduzieren wir erneut die Sichtbarkeit. </font><font style="vertical-align: inherit;">Erhöhen Sie schließlich die Sichtbarkeit der letzten Zelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// transform.localPosition = c; yield return LookAt(pathToTravel[1].Position); Grid.DecreaseVisibility(pathToTravel[0], visionRange); float t = Time.deltaTime * travelSpeed; for (int i = 1; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - 1].Position; c = (b + pathToTravel[i].Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { … } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= 1f; } a = c; b = location.Position; // We can simply use the destination here. c = b; Grid.IncreaseVisibility(location, visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { … } … }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sichtbarkeit in Bewegung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All dies funktioniert, außer wenn in dem Moment, in dem sich die Abteilung bewegt, ein neuer Befehl erteilt wird. </font><font style="vertical-align: inherit;">Dies führt zu einer Teleportation, die auch für die Sichtbarkeit gelten sollte. </font><font style="vertical-align: inherit;">Um dies zu realisieren, müssen wir den aktuellen Standort des Teams verfolgen, während wir uns bewegen.</font></font><br><br><pre> <code class="cs hljs"> HexCell location, currentTravelLocation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diesen Ort jedes Mal aktualisieren, wenn wir während der Bewegung eine neue Zelle treffen, bis der Trupp die letzte Zelle erreicht. </font><font style="vertical-align: inherit;">Dann muss es zurückgesetzt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + currentTravelLocation.Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Grid.IncreaseVisibility(pathToTravel[i], visionRange); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Abschluss der Abzweigung können </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir nun überprüfen, ob der alte Zwischenort des Pfades bekannt ist. </font><font style="vertical-align: inherit;">Wenn ja, müssen Sie die Sichtbarkeit in dieser Zelle und nicht am Anfang des Pfads verringern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; Grid.DecreaseVisibility( currentTravelLocation ? currentTravelLocation : pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>], visionRange ); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen auch die Sichtbarkeit nach der Neukompilierung korrigieren, die während der Bewegung des Trupps aufgetreten ist. </font><font style="vertical-align: inherit;">Wenn der Zwischenort noch bekannt ist, verringern Sie die Sichtbarkeit darin und erhöhen Sie die Sichtbarkeit am Endpunkt. Setzen Sie dann den Zwischenort zurück.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTravelLocation) { Grid.IncreaseVisibility(location, visionRange); Grid.DecreaseVisibility(currentTravelLocation, visionRange); currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit von Straßen und Wasser </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl Änderungen der Relieffarbe auf der Sichtbarkeit basieren, hat dies keine Auswirkungen auf Straßen und Wasser. </font><font style="vertical-align: inherit;">Sie sehen für unsichtbare Zellen zu hell aus. </font><font style="vertical-align: inherit;">Um die Sichtbarkeit auf Straßen und Wasser anzuwenden, müssen wir Zellindizes hinzufügen und Gewichte zu ihren Netzdaten mischen. </font><font style="vertical-align: inherit;">Daher werden wir die Kinder der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use Cell Data</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flüsse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mündungen des</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertighausfragments überprüfen.</font></font><br><br><h3>  Straßen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden von den Straßen starten. </font><font style="vertical-align: inherit;">Die Methode wird </font></font><code>HexGridChunk.TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet, um einen kleinen Teil der Straße in der Mitte der Zelle zu erstellen, sodass ein Zellenindex erforderlich ist. </font><font style="vertical-align: inherit;">Fügen Sie einen Parameter hinzu und generieren Sie Zellendaten für das Dreieck.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); Vector3 indices; indices.x = indices.y = indices.z = index; roads.AddTriangleCellData(indices, weights1); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere einfache Möglichkeit, Straßen zu erstellen, ist </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wird sowohl innerhalb als auch zwischen Zellen verwendet, daher sollte es mit zwei verschiedenen Indizes funktionieren. </font><font style="vertical-align: inherit;">Hierzu ist es zweckmäßig, den Indexvektorparameter zu verwenden. </font><font style="vertical-align: inherit;">Da Straßensegmente Teile von Leisten sein können, müssen auch Gewichte durch Parameter geführt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6, Color w1, Color w2, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadCellData(indices, w1, w2); roads.AddQuadCellData(indices, w1, w2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahren wir nun mit fort </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch Straßen innerhalb der Zellen erstellt werden. </font><font style="vertical-align: inherit;">Es benötigt auch einen Indexparameter. </font><font style="vertical-align: inherit;">Er übergibt diese Daten an die von ihm aufgerufenen Straßenmethoden und fügt sie den von ihm erstellten Dreiecken hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 indices; indices.x = indices.y = indices.z = index; Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment( mL, mC, mR, e.v2, e.v3, e.v4, weights1, weights1, indices ); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleCellData(indices, weights1); roads.AddTriangleCellData(indices, weights1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR, index); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt die erforderliche Verfahren Argumente hinzuzufügen </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all Compiler - </font><font style="vertical-align: inherit;">Fehler zu korrigieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction), cell.Index ); } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL, cell.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center, cell.Index); } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> … </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment( e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4, w1, w2, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sind die Netzdaten korrekt und wir werden mit dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader fortfahren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es benötigt ein Vertex-Programm und muss </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthalten </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">decal</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:blend</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">HexCellData</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cginc</span></span>"</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da wir nicht mehrere Materialien mischen, reicht es aus, einen Indikator für die Sichtbarkeit in das Fragmentprogramm zu übergeben. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> {</span></span> float2 uv_MainTex; float3 worldPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es reicht aus, wenn ein neues Vertex-Programm Daten von zwei Zellen empfängt. </font><font style="vertical-align: inherit;">Wir mischen sofort ihre Sichtbarkeit, passen sie an und ergänzen die Ausgabe.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im Fragmentprogramm müssen wir der Farbe nur Sichtbarkeit hinzufügen. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/92f/46e/af892f46e364906cc547aaecb4e50e3a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßen mit Sichtbarkeit.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Offenes Wasser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es mag den Anschein haben, dass die Sicht das Wasser bereits beeinträchtigt hat, aber dies ist nur die Oberfläche eines in Wasser getauchten Geländes. </font><font style="vertical-align: inherit;">Beginnen wir mit der Sichtbarkeit auf offenes Wasser. </font><font style="vertical-align: inherit;">Dafür müssen wir uns ändern </font></font><code>HexGridChunk.TriangulateOpenWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … water.AddTriangle(center, c1, c2); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … water.AddQuad(c1, c2, e1, e2); indices.y = neighbor.Index; water.AddQuadCellData(indices, weights1, weights2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { … water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); indices.z = nextNeighbor.Index; water.AddTriangleCellData( indices, weights1, weights2, weights3 ); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir müssen auch den Fächern der Dreiecke in Küstennähe Zelldaten hinzufügen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">muss auf die gleiche Weise wie der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader geändert werden </font><font style="vertical-align: inherit;">, muss jedoch die Sichtbarkeit von nicht zwei, sondern drei Zellen kombinieren.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a4/c52/36c/6a4c5236c52eaae78cbde54fb2fdeeac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offenes Wasser mit Sicht.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Küste und Mündung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Küste zu unterstützen, müssen wir uns wieder ändern </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir haben bereits einen Indexvektor erstellt, aber nur einen Zellindex für offenes Wasser verwendet. </font><font style="vertical-align: inherit;">Die Küste benötigt auch einen Nachbarindex, ändern Sie also den Code.</font></font><br><br><pre> <code class="cs hljs"> Vector3 indices; <span class="hljs-comment"><span class="hljs-comment">// indices.x = indices.y = indices.z = cell.Index; indices.x = indices.z = cell.Index; indices.y = neighbor.Index;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie die Zellendaten zu den Quads und dem Dreieck der Küste hinzu. </font><font style="vertical-align: inherit;">Wir übergeben auch die Indizes beim Aufruf </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … waterShore.AddTriangleUV( … ); indices.z = nextNeighbor.Index; waterShore.AddTriangleCellData( indices, weights1, weights2, weights3 ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Zellen für die Küste und den Mund hinzu und kümmern Sie sich um sie. </font><font style="vertical-align: inherit;">Vergessen Sie nicht, dass der Mund aus Trapez mit zwei Dreiecken der Küste an den Seiten besteht. </font><font style="vertical-align: inherit;">Wir sorgen dafür, dass die Gewichte in der richtigen Reihenfolge übertragen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadCellData( indices, weights2, weights1, weights2, weights1 ); estuaries.AddTriangleCellData(indices, weights1, weights2, weights2); estuaries.AddQuadCellData(indices, weights1, weights2); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WaterShore-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader müssen </font><em><font style="vertical-align: inherit;">Sie</font></em><font style="vertical-align: inherit;"> dieselben Änderungen wie im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader vornehmen und </font><font style="vertical-align: inherit;">die Sichtbarkeit der drei Zellen mischen.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader mischt die Sichtbarkeit von zwei Zellen, genau wie der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er hat bereits ein Scheitelpunktprogramm, weil wir ihn brauchen, um die UV-Koordinaten der Flüsse zu übertragen.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.visibility = cell0.x * v.color.x + cell1.x * v.color.y; o.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, o.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88f/829/254/88f829254235a293040ac755d8318bc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Küste und Mündung mit Sichtbarkeit.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flüsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzten Wasserregionen, mit denen gearbeitet wird, sind die Flüsse. </font><font style="vertical-align: inherit;">Fügen Sie dem </font></font><code>HexGridChunk.TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter einen Indexvektor hinzu und fügen Sie ihn dem Netz hinzu, damit die Sichtbarkeit von zwei Zellen erhalten bleibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed, indices); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { … rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br> <code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt Flussendpunkte mit einem Quad und einem Dreieck in der Mitte der Zelle. </font><font style="vertical-align: inherit;">Fügen Sie dazu die notwendigen Zellendaten hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; Vector3 indices; indices.x = indices.y = indices.z = cell.Index; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); … rivers.AddTriangleCellData(indices, weights1); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben diese Zellindizes bereits in </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, also geben wir sie einfach beim Anruf weiter </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed, indices ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir fügen auch Wasserfällen, die in tiefes Wasser münden, Indexunterstützung hinzu. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { … rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schließlich ändern Sie es </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es die erforderlichen Indizes an die Methoden von Flüssen und Wasserfällen weitergibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { e2.v3.y = neighbor.StreamBedY; Vector3 indices; indices.x = indices.z = cell.Index; indices.y = neighbor.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY, indices ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY, indices ); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">muss dieselben Änderungen vornehmen wie der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ef/db6/76a/1efdb676afe28b61b73f317d25158505.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flüsse mit Sichtbarkeit. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekte und Sichtbarkeit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt funktioniert die Sichtbarkeit für das gesamte prozedural generierte Gelände, hat jedoch bisher keine Auswirkungen auf die Geländemerkmale. Gebäude, Farmen und Bäume werden aus Fertighäusern und nicht aus prozeduraler Geometrie erstellt. Daher können wir keine Zellindizes hinzufügen und Gewichte mit ihren Scheitelpunkten mischen. Da jedes dieser Objekte nur zu einer Zelle gehört, müssen wir bestimmen, in welcher Zelle sie sich befinden. Wenn wir dies tun können, erhalten wir Zugriff auf die Daten der entsprechenden Zellen und wenden die Sichtbarkeit an.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die XZ-Positionen der Welt bereits in Zellindizes umwandeln. Diese Transformation wurde verwendet, um das Gelände zu bearbeiten und Trupps zu verwalten. Der entsprechende Code ist jedoch nicht trivial. Es verwendet ganzzahlige Operationen und erfordert Logik, um mit Kanten zu arbeiten. Dies ist für einen Shader unpraktisch, daher können wir den Großteil der Logik in einer Textur backen und verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden bereits eine Textur mit einem sechseckigen Muster, um das Gitter über die Topographie zu projizieren. Diese Textur definiert eine Zellfläche von 2 × 2. Daher können wir leicht berechnen, in welchem ​​Gebiet wir uns befinden. Danach können Sie eine Textur mit X- und Z-Offsets für die Zellen in diesem Bereich anwenden und diese Daten verwenden, um die Zelle zu berechnen, in der wir uns befinden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist eine ähnliche Textur. Der X-Offset wird in seinem roten Kanal und der Z-Offset in seinem grünen Kanal gespeichert. Da es den Bereich von 2 × 2 Zellen abdeckt, benötigen wir Offsets von 0 und 2. Solche Daten können nicht im Farbkanal gespeichert werden, sodass die Offsets um die Hälfte reduziert werden. Wir brauchen keine klaren Kanten der Zellen, daher reicht eine kleine Textur aus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/63c/d3c/79563cd3c22e7aa2ca66e40b5ffe3f7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Textur der Gitterkoordinaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie dem Projekt eine Textur hinzu. </font><font style="vertical-align: inherit;">Stellen Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wrap-Modus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie bei der anderen </font><em><font style="vertical-align: inherit;">Netzstruktur</font></em><font style="vertical-align: inherit;"> auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir brauchen keine Vermischung, so dass der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischmodus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Wert wählen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punkt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Deaktivieren Sie auch die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komprimierung,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> damit die Daten nicht verzerrt werden. </font><font style="vertical-align: inherit;">Deaktivieren Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sRGB-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modus, </font><font style="vertical-align: inherit;">damit beim Rendern im linearen Modus keine Farbraumkonvertierungen durchgeführt werden. </font><font style="vertical-align: inherit;">Und schließlich brauchen wir keine Mip-Texturen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/866/aa9/de3/866aa9de36f6953f54d4fb8197fb75ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optionen zum Importieren von Texturen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Object Shader mit Sichtbarkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen neuen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">, um Objekten Sichtbarkeitsunterstützung hinzuzufügen. </font><font style="vertical-align: inherit;">Dies ist ein einfacher Oberflächen-Shader mit einem Vertex-Programm. </font><font style="vertical-align: inherit;">Fügen Sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData hinzu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und übergeben Sie die Sichtbarkeitsanzeige an das Fragmentprogramm. Betrachten Sie sie wie gewohnt in Farbe. </font><font style="vertical-align: inherit;">Der Unterschied besteht darin, dass wir es nicht verwenden </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können, da die erforderlichen Netzdaten nicht vorhanden sind. </font><font style="vertical-align: inherit;">Stattdessen haben wir eine Position in der Welt. </font><font style="vertical-align: inherit;">Lassen Sie die Sichtbarkeit jedoch vorerst gleich 1.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Feature" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> [NoTilingOffset] _GridCoordinates ("Grid Coordinates", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" sampler2D _MainTex, _GridCoordinates; half _Glossiness; half _Metallic; fixed4 _Color; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ändern Sie alle Materialien der Objekte so, dass sie den neuen Shader verwenden, und weisen Sie ihnen die Textur der Gitterkoordinaten zu. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/fad/546/e35fad5469e6c9e5c6a31626ba182ec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urban mit Mesh-Textur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zugriff auf Zellendaten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Textur der Gitterkoordinaten im Scheitelpunktprogramm abzutasten, benötigen wir erneut </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen vierkomponentigen Texturkoordinatenvektor. </font><font style="vertical-align: inherit;">Die ersten beiden Koordinaten sind die Position der XZ-Welt. </font><font style="vertical-align: inherit;">Die anderen beiden sind wie zuvor gleich Null.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">strecken wir die UV-Koordinaten so, dass die Textur das richtige Seitenverhältnis aufweist, das dem Sechseckgitter entspricht.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können herausfinden, in welchem ​​Teil der 2 × 2-Zellen wir uns befinden, indem wir den Wert der abgerundeten UV-Koordinaten nehmen. </font><font style="vertical-align: inherit;">Dies bildet die Basis für die Koordinaten der Zellen.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); float2 cellDataCoordinates = floor(gridUV.xy);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die Koordinaten der Zelle zu finden, in der wir uns befinden, fügen wir die in der Textur gespeicherten Verschiebungen hinzu. </font></font><br><br><pre> <code class="hljs pgsql"> float2 cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da ein Teil des Gitters 2 × 2 groß ist und die Offsets halbiert sind, müssen wir das Ergebnis verdoppeln, um die endgültigen Koordinaten zu erhalten. </font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">float2</span></span> cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg; <span class="hljs-attribute"><span class="hljs-attribute">cellDataCoordinates</span></span> *= <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir die XZ-Koordinaten des Zellgitters, die wir in die UV-Koordinaten dieser Zellen umwandeln müssen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem einfach in die Mitte der Pixel verschoben und diese dann in Texturgrößen unterteilt werden. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> also der </font><em><font style="vertical-align: inherit;">HexCellData-</font></em><font style="vertical-align: inherit;"> Include-Datei eine </font><font style="vertical-align: inherit;">Funktion </font><em><font style="vertical-align: inherit;">hinzu</font></em><font style="vertical-align: inherit;"> , die auch das Sampling übernimmt.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { float2 uv = cellDataCoordinates + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; uv.x *= _HexCellData_TexelSize.x; uv.y *= _HexCellData_TexelSize.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir dies in dem Vertex - </font><font style="vertical-align: inherit;">Shader - </font><font style="vertical-align: inherit;">Programm verwenden </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Eigenschaft</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs haskell"> cellDataCoordinates *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCellData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cellDataCoordinates</span></span></span><span class="hljs-class">).x; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/9c9/7ed/1ed9c97ed37aa88aaee6c0efd9d075d7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte mit Sichtbarkeit.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schließlich wirkt sich die Sichtbarkeit auf die gesamte Karte aus, mit Ausnahme der Einheiten, die immer sichtbar sind. Da wir die Sichtbarkeit von Objekten für jeden Scheitelpunkt bestimmen, wird für das Objekt, das die Zellgrenze überschreitet, die Sichtbarkeit der Zellen, die es schließt, gemischt. Die Objekte sind jedoch so klein, dass sie ständig in ihrer Zelle verbleiben, selbst unter Berücksichtigung von Positionsverzerrungen. Einige können jedoch Teil der Eckpunkte in einer anderen Zelle sein. Daher ist unser Ansatz billig, aber unvollkommen. Dies macht sich vor allem bei Wänden bemerkbar, deren Sichtbarkeit zwischen den Sichtbarkeiten benachbarter Zellen variiert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/421/1c7/f7d/4211c7f7dea80bbbd13664586074c43a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände mit wechselnder Sichtbarkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Wandsegmente prozedural generiert werden, können wir ihrem Netz Zelldaten hinzufügen und den Ansatz verwenden, den wir für das Relief verwendet haben. </font><font style="vertical-align: inherit;">Leider sind die Türme vorgefertigt, so dass wir immer noch Inkonsistenzen haben werden. </font><font style="vertical-align: inherit;">Im Allgemeinen sieht der vorhandene Ansatz für die von uns verwendete einfache Geometrie gut genug aus. </font><font style="vertical-align: inherit;">In Zukunft werden wir detailliertere Modelle und Wände betrachten, daher werden wir die Methode zum Mischen ihrer Sichtbarkeit verbessern. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 21: Kartenforschung </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir zeigen alles während der Bearbeitung an. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verfolgen die untersuchten Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verstecken, was noch unbekannt ist. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir zwingen Einheiten, unerforschte Gebiete zu meiden. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im vorherigen Teil haben wir den Nebel des Krieges hinzugefügt, den wir nun verfeinern werden, um Kartenforschung durchzuführen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81d/40e/bff/81d40ebff615fc7c4e39a15d88da016d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind bereit, die Welt zu erkunden.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie die gesamte Karte im Bearbeitungsmodus an </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedeutung der Studie ist, dass bis die Zellen nicht gesehen werden, sie als unbekannt und daher unsichtbar angesehen werden. </font><font style="vertical-align: inherit;">Sie sollten nicht verdeckt, aber überhaupt nicht angezeigt werden. </font><font style="vertical-align: inherit;">Daher werden wir vor dem Hinzufügen von Forschungsunterstützung die Sichtbarkeit im Bearbeitungsmodus aktivieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeitsumschaltung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Schlüsselwort können wir steuern, ob die Shader die Sichtbarkeit verwenden, wie dies mit der Überlagerung im Raster geschehen ist. </font><font style="vertical-align: inherit;">Verwenden Sie das Schlüsselwort </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">um den Status des Bearbeitungsmodus anzuzeigen. </font><font style="vertical-align: inherit;">Da mehrere Shader über dieses Schlüsselwort Bescheid wissen sollten, definieren wir es global mit statischen Methoden </font></font><code>Shader.EnableKeyWord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Shader.DisableKeyword</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden die entsprechende Methode aufrufen, </font></font><code>HexGameUI.SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">den Bearbeitungsmodus ändern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (toggle) { Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Shader.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bearbeitungsmodus-Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert ist, ignorieren Shader die Sichtbarkeit. </font><font style="vertical-align: inherit;">Dies läuft darauf hinaus, dass die Sichtbarkeit </font><font style="vertical-align: inherit;">von Zellen </font><font style="vertical-align: inherit;">immer als gleich 1 betrachtet wird. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir eine </font><font style="vertical-align: inherit;">Funktion hinzu, um die Daten von Zellen abhängig vom Schlüsselwort </font><font style="vertical-align: inherit;">am Anfang der </font><em><font style="vertical-align: inherit;">HexCellData-</font></em><font style="vertical-align: inherit;"> Include-Datei zu </font><em><font style="vertical-align: inherit;">filtern</font></em><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs kotlin">sampler2D _HexCellData; float4 _HexCellData_TexelSize; float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir durchlaufen diese Funktion als Ergebnis beider Funktionen, </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bevor </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">sie zurückgeben.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(data); } <span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit alles funktioniert, müssen alle relevanten Shader die Anweisung multi_compile erhalten, um Optionen zu erstellen, falls das Schlüsselwort </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert ist. </font><font style="vertical-align: inherit;">Fügen Sie den Shadern von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zwischen der Zielrichtlinie und der ersten Include-Direktive </font><font style="vertical-align: inherit;">die entsprechende Linie hinzu </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie jetzt in den Kartenbearbeitungsmodus wechseln, verschwindet der Nebel des Krieges. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellforschung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardmäßig sollten Zellen als unerforscht betrachtet werden. </font><font style="vertical-align: inherit;">Sie werden erforscht, wenn ein Trupp sie sieht. </font><font style="vertical-align: inherit;">Danach bleiben sie weiterhin untersucht, ob eine Abteilung sie sehen kann.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfolgung des Studienstatus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Überwachung des Status von Studien zu unterstützen, fügen wir die </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeine Eigenschaft hinzu </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Stand der Studie wird von der Zelle selbst bestimmt. </font><font style="vertical-align: inherit;">Daher sollte diese Eigenschaft nur festgelegt werden </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um diese Einschränkung hinzuzufügen, setzen wir den Setter auf privat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Sichtbarkeit der Zelle zum ersten Mal größer als Null wird, wird die Zelle als untersucht betrachtet. Daher sollte </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Wert zugewiesen werden </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tatsächlich reicht es aus, die Zelle einfach als geprüft zu markieren, wenn die Sichtbarkeit auf 1 steigt. Dies muss vor dem Anruf erfolgen </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { IsExplored = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Übertragung des Forschungsstatus auf Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei der Sichtbarkeit von Zellen übertragen wir ihren Forschungsstatus über die Shader-Daten auf die Shader. </font><font style="vertical-align: inherit;">Am Ende ist es nur eine andere Art der Sichtbarkeit. </font></font><code>HexCellShaderData.RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichert den Sichtbarkeitsstatus im Datenkanal R. </font><font style="vertical-align: inherit;">Lassen Sie uns den Stand der Studie in Kanal G-Daten beibehalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwarzes unerforschtes Relief </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir Shader verwenden, um den Stand der Zellforschung zu visualisieren. </font><font style="vertical-align: inherit;">Um sicherzustellen, dass alles so funktioniert, wie es sollte, machen wir das unerforschte Gelände nur schwarz. </font><font style="vertical-align: inherit;">Um den Bearbeitungsmodus zu aktivieren, ändern Sie ihn zunächst </font></font><code>FilterCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass die Forschungsdaten herausgefiltert werden.</font></font><br><br><pre> <code class="hljs kotlin">float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.xy = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">übergibt die Sichtbarkeitsdaten aller drei möglichen Zellen an das Fragmentprogramm. </font><font style="vertical-align: inherit;">Im Falle des Forschungszustands kombinieren wir sie im Vertex-Programm und übertragen den einzigen Wert in das Fragment-Programm. </font><font style="vertical-align: inherit;">Fügen Sie der Eingabe die </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vierte Komponente hinzu, damit wir einen Platz dafür haben.</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; <span class="hljs-type"><span class="hljs-type">float4</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jetzt im Vertex-Programm den Sichtbarkeitsindex ändern, müssen wir explizit darauf zugreifen </font></font><code>data.visibility.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { … data.visibility.xyz = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.xyz); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach kombinieren wir die Zustände der Studie und schreiben das Ergebnis in </font></font><code>data.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ähnelt dem Kombinieren der Sichtbarkeit in anderen Shadern, verwendet jedoch die Komponente Y dieser Zellen.</font></font><br><br><pre> <code class="hljs haskell"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.xyz = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xyz</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.w = cell0.y * v.color.x + cell1.y * v.color.y + cell2.y * v.color.z;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Forschungsstatus ist jetzt im Fragmentprogramm durch verfügbar </font></font><code>IN.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Berücksichtigen Sie dies bei der Berechnung der Albedo.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/de4/c18/b2dde4c1831a9ecc637550b2b8e2e134.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die unerforschte Topographie ist jetzt schwarz. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Relief von unerforschten Zellen hat jetzt eine schwarze Farbe. </font><font style="vertical-align: inherit;">Objekte, Straßen und Wasser sind davon jedoch noch nicht betroffen. </font><font style="vertical-align: inherit;">Dies reicht jedoch aus, um sicherzustellen, dass die Studie funktioniert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forschungsstatus speichern und laden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Forschungsunterstützung hinzugefügt haben, müssen wir sicherstellen, dass der Forschungsstatus beim Speichern und Laden von Karten berücksichtigt wird. </font><font style="vertical-align: inherit;">Daher müssen wir die Version der Kartendateien auf 3 erhöhen. Um diese Änderungen bequemer zu gestalten, fügen wir hierfür eine </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstante hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Konstante beim Schreiben der Dateiversion in </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und beim Einchecken der Dateisupport verwenden </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(mapFileVersion); hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= mapFileVersion) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als letzten Schritt </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeichnen wir den Status der Studie auf.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { … writer.Write(IsExplored); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wir werden es am Ende lesen </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach rufen wir </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an, falls sich der Stand der Studie vom vorherigen unterscheidet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { … IsExplored = reader.ReadBoolean(); ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Abwärtskompatibilität mit alten Sicherungsdateien aufrechtzuerhalten, müssen wir das Lesen des Sicherungsstatus überspringen, wenn die Dateiversion kleiner als 3 ist. In diesem Fall haben die Zellen standardmäßig den Status "unerforscht". </font><font style="vertical-align: inherit;">Dazu müssen wir </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header-Daten </font><font style="vertical-align: inherit;">als Parameter hinzufügen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … IsExplored = header &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen die </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header-Daten übergeben werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Speichern und Laden von Karten wird nun der Erkundungsstatus der Zellen berücksichtigt. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unbekannte Zellen verstecken </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegenwärtig sind unerforschte Zellen visuell durch ein schwarzes Relief gekennzeichnet. </font><font style="vertical-align: inherit;">In Wirklichkeit wollen wir, dass diese Zellen unsichtbar sind, weil sie unbekannt sind. </font><font style="vertical-align: inherit;">Wir können die undurchsichtige Geometrie transparent machen, damit sie nicht sichtbar ist. </font><font style="vertical-align: inherit;">Das Unity Surface Shader Framework wurde jedoch ohne diese Möglichkeit entwickelt. </font><font style="vertical-align: inherit;">Anstatt echte Transparenz zu verwenden, werden wir die Shader so ändern, dass sie dem Hintergrund entsprechen, wodurch sie auch unsichtbar werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Relief wirklich schwarz machen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl das untersuchte Relief schwarz ist, können wir es immer noch erkennen, da es immer noch spiegelnde Beleuchtung hat. Um die Beleuchtung loszuwerden, müssen wir sie perfekt mattschwarz machen. Um andere Oberflächeneigenschaften nicht zu beeinträchtigen, ist es am einfachsten, die Spiegelfarbe in Schwarz zu ändern. Dies ist möglich, wenn Sie einen Oberflächen-Shader verwenden, der mit Specular funktioniert. Jetzt verwenden wir jedoch das Standard-Metallic. Beginnen wir also damit, den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">auf Specular umzustellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ersetzen Sie </font><font style="vertical-align: inherit;">die Farbeigenschaft </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Metallic</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Eigenschaft </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Specular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Standardmäßig sollte der Farbwert gleich (0,2, 0,2, 0,2) sein. Wir garantieren also, dass es zum Erscheinungsbild der Metallic-Version passt.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie auch die entsprechenden Shader-Variablen. </font><font style="vertical-align: inherit;">Die Farbe von spiegelnden Oberflächen-Shadern ist definiert als </font></font><code>fixed3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, also verwenden wir sie.</font></font><br><br><pre> <code class="hljs objectivec"> half _Glossiness; <span class="hljs-comment"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie die Pragma-Oberflächenbrandung von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StandardSpecular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dadurch wird Unity gezwungen, Shader mithilfe von Specular zu generieren.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt benötigt die Funktion </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den zweiten Parameter vom Typ </font></font><code>SurfaceOutputStandardSpecular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Außerdem müssen Sie jetzt den Wert nicht zuweisen </font></font><code>o.Metallic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sondern </font></font><code>o.Specular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; // o.Metallic = _Metallic; o.Specular = _Specular; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Glanzlichter verdecken, indem wir die Spiegelfarbe berücksichtigen </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs"> o.Specular = _Specular * explored;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/d05/128/289d0512816a7d6f692b0e7639e882eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unerforschtes Gelände ohne reflektierte Beleuchtung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie auf dem Bild sehen können, sieht das unerforschte Relief jetzt mattschwarz aus. </font><font style="vertical-align: inherit;">Bei Betrachtung in einem Tangentenwinkel verwandeln sich die Oberflächen jedoch in einen Spiegel, wodurch das Relief beginnt, die Umgebung, dh die Skybox, zu reflektieren.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum werden Oberflächen zu Spiegeln?</font></font></b> <div class="spoiler_text">    .  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering</a> . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/255/d63/627/255d636278eb947c27117d6c596a9489.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unerforschte Gebiete spiegeln immer noch die Umwelt wider. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Reflexionen loszuwerden, betrachten wir das unerforschte Relief als vollständig schattiert. </font><font style="vertical-align: inherit;">Dies wird erreicht, indem </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Okklusionsparameter </font><font style="vertical-align: inherit;">ein Wert </font><font style="vertical-align: inherit;">zugewiesen wird, den wir als Reflexionsmaske verwenden.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/ab6/a5a/118ab6a5a91711eda2165433a7b99513.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne Reflexionen unerforscht.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passender Hintergrund </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da das unerforschte Gelände die gesamte Beleuchtung ignoriert, müssen Sie es an den Hintergrund anpassen. </font><font style="vertical-align: inherit;">Da unsere Kamera immer von oben schaut, ist der Hintergrund immer grau. </font><em><font style="vertical-align: inherit;">Fügen Sie die</font></em><font style="vertical-align: inherit;"> Eigenschaft </font><em><font style="vertical-align: inherit;">_BackgroundColor hinzu</font></em><font style="vertical-align: inherit;"> , die standardmäßig Schwarz ist, </font><font style="vertical-align: inherit;">um dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader mitzuteilen, </font><font style="vertical-align: inherit;">welche Farbe verwendet werden soll </font><font style="vertical-align: inherit;">.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><pre> <code class="hljs dos"> Properties { … _BackgroundColor ("Background <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>", <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) } … half _Glossiness; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Farbe zu verwenden, fügen wir sie als emittierendes Licht hinzu. </font><font style="vertical-align: inherit;">Dies wird </font></font><code>o.Emission</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erreicht, indem ein Hintergrundfarbwert multipliziert mit einem minus erkundet zugewiesen wird.</font></font><br><br><pre> <code class="hljs"> o.Occlusion = explored; o.Emission = _BackgroundColor * (1 - explored);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir die Standard-Skybox verwenden, ist die sichtbare Hintergrundfarbe tatsächlich nicht dieselbe. </font><font style="vertical-align: inherit;">Im Allgemeinen wäre ein leicht rötliches Grau die beste Farbe. </font><font style="vertical-align: inherit;">Beim Einrichten des Reliefmaterials können Sie den </font><font style="vertical-align: inherit;">Code 68615BFF </font><font style="vertical-align: inherit;">für </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Color verwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/307/7dd/eeb3077dd097a7649575a371cbb361f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reliefmaterial mit grauer Hintergrundfarbe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen funktioniert dies, obwohl Sie, wenn Sie wissen, wo Sie suchen müssen, sehr schwache Silhouetten bemerken werden. </font><font style="vertical-align: inherit;">Damit der Player sie nicht sehen kann, können Sie der Kamera anstelle der Skybox eine einheitliche Hintergrundfarbe von 68615BFF zuweisen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b9/8cc/ec9/7b98ccec9228ac333cc23ec19cc6f28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamera mit einheitlicher Hintergrundfarbe.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht die Skybox entfernen?</font></font></b> <div class="spoiler_text">   ,   ,     environmental lighting .     ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir den Unterschied zwischen dem Hintergrund und unerforschten Zellen nicht finden. </font><font style="vertical-align: inherit;">Eine hohe unerforschte Topographie kann eine niedrige erforschte Topographie bei niedrigen Kamerawinkeln immer noch verdecken. </font><font style="vertical-align: inherit;">Darüber hinaus werfen unerforschte Teile immer noch Schatten auf die Erkundeten. </font><font style="vertical-align: inherit;">Diese minimalen Hinweise können jedoch vernachlässigt werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f88/764/d67/f88764d67aec0bf90267d273e1a248d5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht erforschte Zellen sind nicht mehr sichtbar.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn Sie keine einheitliche Hintergrundfarbe verwenden?</font></font></b> <div class="spoiler_text">    ,        ,      .        .      ,          .       ,     ,  ,  UV-           . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reliefobjekte verstecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir nur noch das Netz des Reliefs versteckt. </font><font style="vertical-align: inherit;">Der Rest der Studie ist noch nicht betroffen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/282/c0c/a0f/282c0ca0fb55bf26ee0bb1d43cadd42f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher ist nur das Relief verborgen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader ändern </font><font style="vertical-align: inherit;">, der ein undurchsichtiger Shader wie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain ist</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Verwandeln Sie es in einen Spiegel-Shader und fügen Sie die Hintergrundfarbe hinzu. </font><font style="vertical-align: inherit;">Beginnen wir mit den Eigenschaften.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Albedo (RGB)"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [NoScaleOffset] _GridCoordinates (<span class="hljs-string"><span class="hljs-string">"Grid Coordinates"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weitere Pragma-Oberfläche und Variablen wie zuvor. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert … half _Glossiness; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</span></span></span></span></code> </pre> <br> <code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Komponente ist ebenfalls erforderlich. </font><font style="vertical-align: inherit;">Da </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature die</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit für jeden Scheitelpunkt kombiniert, wurde nur ein Gleitkommawert benötigt. </font><font style="vertical-align: inherit;">Jetzt brauchen wir zwei.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float2 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie es </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es explizit für die Sichtbarkeitsdaten verwendet wird </font></font><code>data.visibility.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und weisen Sie dann den </font></font><code>data.visibility.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert der Studiendaten zu.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … float4 cellData = GetCellData(cellDataCoordinates); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cellData.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cellData.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie es </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es die neuen Daten wie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain verwendet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x * explored); // o.Metallic = _Metallic; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Emission = _BackgroundColor * (<span class="hljs-number"><span class="hljs-number">1</span></span> - explored); o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d13/863/dc6/d13863dc60bbb92750cd5c8f8b69d82b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versteckte Reliefobjekte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasser verstecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes kommen die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beginnen wir mit der Konvertierung in Spiegel-Shader. </font><font style="vertical-align: inherit;">Sie benötigen jedoch keine Hintergrundfarbe, da es sich um transparente Shader handelt. </font><font style="vertical-align: inherit;">Fügen Sie nach </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Konvertierung </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine weitere Komponente hinzu und ändern Sie sie entsprechend </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beide Shader kombinieren Daten aus drei Zellen.</font></font><br><br><pre> <code class="hljs dos"> struct Input { … float2 visibility; }; … void vert (inout appdata_full v, out Input data) { … data.visibility.x = cell0.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; data.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.x); data.visibility.y = cell0.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; }</code> </pre> <br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasserufer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> führen </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unterschiedliche Vorgänge aus, stellen jedoch ihre Oberflächeneigenschaften auf dieselbe Weise ein. </font><font style="vertical-align: inherit;">Da sie transparent sind, werden wir sie </font></font><code>explore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Alphakanal </font><font style="vertical-align: inherit;">berücksichtigen </font><font style="vertical-align: inherit;">und keine Emissionen festlegen.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/e39/390/15ae39390ccbe91f3d12f068992a7c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verstecktes Wasser.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verstecken Flussmündungen, Flüsse und Straßen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben immer noch die Shader für </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mündung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluss</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straße</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Alle drei sind transparent und kombinieren die Daten zweier Zellen. </font><font style="vertical-align: inherit;">Schalten Sie sie alle auf spiegelnd um und fügen Sie sie dann den </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forschungsdaten hinzu.</font></font><br><br><pre> <code class="hljs kotlin"> struct Input { … float2 visibility; }; … void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x * v.color.x + cell1.x * v.color.y; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell0.y * v.color.x + cell1.y * v.color.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie die Funktion der </font><em><font style="vertical-align: inherit;">Flussmündungs-</font></em><font style="vertical-align: inherit;"> und </font><em><font style="vertical-align: inherit;">Fluss-</font></em></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">so, dass die neuen Daten verwendet werden. </font><font style="vertical-align: inherit;">Beide müssen die gleichen Änderungen vornehmen.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road ist</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etwas anders, da sie eine zusätzliche Mischmetrik verwendet.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x); <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend *= noise.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend); <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = blend * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/1d2/c65/1c61d2c652b436385b42188c39476c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles ist versteckt. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie unerforschte Zellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl alles Unbekannte visuell verborgen ist, wird der Stand der Studie bei der Suche nach einem Pfad nicht berücksichtigt. </font><font style="vertical-align: inherit;">Infolgedessen können Einheiten angewiesen werden, sich durch und durch unerforschte Zellen zu bewegen, wodurch auf magische Weise bestimmt wird, in welche Richtung sie sich bewegen sollen. </font><font style="vertical-align: inherit;">Wir müssen Einheiten zwingen, um unerforschte Zellen zu vermeiden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca9/eb9/f22/ca9eb9f22cd36b917bd5f0c38028bce7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigieren Sie durch unerforschte Zellen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trupps bestimmen die Umzugskosten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir unerforschte Zellen in Angriff nehmen, wiederholen wir den Code, um die Kosten für den Wechsel von </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach zu übertragen </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies vereinfacht die Unterstützung für Einheiten mit unterschiedlichen Bewegungsregeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Methode hinzu </font></font><code>GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Umzugskosten zu bestimmen. </font><font style="vertical-align: inherit;">Er muss wissen, welche Zellen sich zwischen ihnen bewegen und in welche Richtung. </font><font style="vertical-align: inherit;">Wir kopieren den entsprechenden Code für die Kosten der Umstellung </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf diese Methode und ändern die Variablennamen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode sollte die Umzugskosten zurückgeben. </font><font style="vertical-align: inherit;">Ich habe den alten Code verwendet, um ungültige Züge zu überspringen </font></font><code>continue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber dieser Ansatz funktioniert hier nicht. </font><font style="vertical-align: inherit;">Wenn eine Bewegung nicht möglich ist, erstatten wir die negativen Umzugskosten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir beim Finden des Pfades nicht nur die Geschwindigkeit, sondern auch die ausgewählte Einheit kennen. </font><font style="vertical-align: inherit;">Ändern Sie entsprechend </font></font><code>HexGameUI.DoPathFinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, selectedUnit); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir weiterhin Zugriff auf die Geschwindigkeit des Trupps benötigen, werden wir die </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft erweitern </font></font><code>Speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Während es einen konstanten Wert von 24 zurückgibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Speed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veränderung </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so , </font><font style="vertical-align: inherit;">dass sie mit unserem neuen Ansatz arbeiten können.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, unit); ShowPath(unit.Speed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> speed = unit.Speed; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir aus dem </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alten Code </font><font style="vertical-align: inherit;">entfernen </font><font style="vertical-align: inherit;">, der bestimmt hat, ob es möglich ist, zur nächsten Zelle zu wechseln, und was die Kosten für den Umzug sind. </font><font style="vertical-align: inherit;">Stattdessen werden wir anrufen </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>HexUnit.GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden die Zelle überspringen, wenn die Umzugskosten negativ sind.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (neighbor.IsUnderwater || neighbor.Unit) { // continue; // } // HexEdgeType edgeType = current.GetEdgeType(neighbor); // if (edgeType == HexEdgeType.Cliff) { // continue; // } // int moveCost; // if (current.HasRoadThroughEdge(d)) { // moveCost = 1; // } // else if (current.Walled != neighbor.Walled) { // continue; // } // else { // moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; // moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + // neighbor.PlantLevel; // } if (!unit.IsValidDestination(neighbor)) { continue; } int moveCost = unit.GetMoveCost(current, neighbor, d); if (moveCost &lt; 0) { continue; } int distance = current.Distance + moveCost; int turn = (distance - 1) / speed; if (turn &gt; currentTurn) { distance = turn * speed + moveCost; } … }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umgehen Sie unerforschte Gebiete </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um unerforschte Zellen zu vermeiden, müssen wir sicherstellen, dass wir </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prüfen, ob die Zelle untersucht wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.IsExplored &amp;&amp; !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a84/831/2c6/a848312c6231a168a966e4cdafc2df38.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Einheiten können nicht zu unerforschten Zellen gelangen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da unerforschte Zellen keine gültigen Endpunkte mehr sind, werden sie von Trupps beim Verschieben zum Endpunkt vermieden. </font><font style="vertical-align: inherit;">Das heißt, unerforschte Gebiete wirken als Barrieren, die den Weg verlängern oder sogar unmöglich machen. </font><font style="vertical-align: inherit;">Wir müssen die Einheiten näher an ein unbekanntes Gelände bringen, um zuerst die Gegend zu erkunden.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn während des Umzugs ein kürzerer Pfad angezeigt wird?</font></font></b> <div class="spoiler_text">                .           ,        .       . <br><br>   ,        ,            .            ,    . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 22: Verbesserte Sichtbarkeit </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ändern Sie die Sichtbarkeit reibungslos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie die Höhe der Zelle, um den Bereich zu bestimmen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verstecke den Rand der Karte. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch Hinzufügen von Unterstützung für die Kartenerkundung werden wir die Berechnungen und Übergänge des Bereichs verbessern. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/c4a/793/2d2c4a7939e75fe09298f96ff6125478.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um weiter zu sehen, klettere höher.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeitsübergänge </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zelle ist entweder sichtbar oder unsichtbar, da sie sich entweder im Bereich der Ablösung befindet oder nicht. </font><font style="vertical-align: inherit;">Selbst wenn es so aussieht, als würde eine Einheit einige Zeit brauchen, um sich zwischen Zellen zu bewegen, springt ihr Bereich sofort von Zelle zu Zelle. </font><font style="vertical-align: inherit;">Infolgedessen ändert sich die Sichtbarkeit der umgebenden Zellen dramatisch. </font><font style="vertical-align: inherit;">Die Bewegung des Trupps scheint reibungslos zu sein, aber die Sichtbarkeit ändert sich plötzlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealerweise sollte sich auch die Sichtbarkeit reibungslos ändern. </font><font style="vertical-align: inherit;">Sobald Sie sich im Sichtfeld befinden, sollten die Zellen allmählich beleuchtet und allmählich dunkel werden. </font><font style="vertical-align: inherit;">Oder bevorzugen Sie sofortige Übergänge? </font><font style="vertical-align: inherit;">Fügen wir der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft </font><font style="vertical-align: inherit;">hinzu, die </font><font style="vertical-align: inherit;">sofortige Übergänge wechselt. </font><font style="vertical-align: inherit;">Standardmäßig sind Übergänge glatt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transition Cell Tracking </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst wenn glatte Übergänge angezeigt werden, bleiben die tatsächlichen Sichtbarkeitsdaten binär, dh der Effekt ist nur visuell. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sichtbarkeitsübergänge behandelt werden müssen </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden ihm eine Liste von Zellen geben, in denen der Übergang durchgeführt wird. </font><font style="vertical-align: inherit;">Stellen Sie sicher, dass es bei jeder Initialisierung leer ist.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; Color32[] cellTextureData; List&lt;HexCell&gt; transitioningCells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … transitioningCells.Clear(); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Moment setzen wir Zellendaten </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direkt. </font><font style="vertical-align: inherit;">Dies ist für den Sofortübergangsmodus immer noch korrekt, aber wenn er deaktiviert ist, müssen wir der Liste der Übergangszellen eine Zelle hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Sichtbarkeit scheint nicht mehr zu funktionieren, da wir derzeit nichts mit den Zellen in der Liste tun. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchlaufen Sie Zellen in einer Schleife </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die entsprechenden Werte sofort auf 255 oder 0 einzustellen, werden diese Werte schrittweise erhöht / verringert. </font><font style="vertical-align: inherit;">Die Glätte des Übergangs hängt von der Änderungsrate ab. </font><font style="vertical-align: inherit;">Es sollte nicht sehr schnell und nicht sehr langsam sein. </font><font style="vertical-align: inherit;">Ein guter Kompromiss zwischen schönen Übergängen und der Bequemlichkeit des Spiels besteht darin, sich innerhalb einer Sekunde zu ändern. </font><font style="vertical-align: inherit;">Stellen wir hierfür eine Konstante ein, um das Ändern zu erleichtern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transitionSpeed = <span class="hljs-number"><span class="hljs-number">255f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können wir das Delta definieren, das auf die Werte angewendet wird. </font><font style="vertical-align: inherit;">Multiplizieren Sie dazu das Zeitdelta mit der Geschwindigkeit. </font><font style="vertical-align: inherit;">Es muss eine ganze Zahl sein, da wir nicht wissen, wie groß sie sein kann. </font><font style="vertical-align: inherit;">Ein starker Abfall der Bildrate kann dazu führen, dass das Delta mehr als 255 beträgt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem müssen wir aktualisieren, solange Übergangszellen vorhanden sind. </font><font style="vertical-align: inherit;">Daher sollte der Code enthalten sein, solange sich etwas in der Liste befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = transitioningCells.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auch theoretisch möglich sehr hohe Bildraten. </font><font style="vertical-align: inherit;">In Kombination mit einer niedrigen Übergangsgeschwindigkeit kann dies ein Delta von 0 ergeben. Damit die Änderung stattfindet, erzwingen wir, dass das Delta-Minimum 1 ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir das Delta erhalten haben, können wir alle Übergangszellen durchlaufen und ihre Daten aktualisieren. </font><font style="vertical-align: inherit;">Nehmen wir an, wir haben eine Methode dafür </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, deren Parameter die entsprechende Zelle und das Delta sind.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { UpdateCellData(transitioningCells[i], delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irgendwann sollte der Zellübergang abgeschlossen sein. </font><font style="vertical-align: inherit;">Angenommen, die Methode gibt Informationen darüber zurück, ob der Übergang noch läuft. </font><font style="vertical-align: inherit;">Wenn es nicht mehr läuft, können wir die Zelle aus der Liste entfernen. </font><font style="vertical-align: inherit;">Danach müssen wir den Iterator dekrementieren, um die Zellen nicht zu überspringen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells.RemoveAt(i--); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Reihenfolge, in der die Übergangszellen verarbeitet werden, ist nicht wichtig. </font><font style="vertical-align: inherit;">Daher müssen wir die Zelle nicht am aktuellen Index löschen, wodurch </font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle Zellen gezwungen </font><font style="vertical-align: inherit;">würden, </font><font style="vertical-align: inherit;">sich danach </font><font style="vertical-align: inherit;">zu </font><font style="vertical-align: inherit;">bewegen. </font><font style="vertical-align: inherit;">Stattdessen verschieben wir die letzte Zelle in den aktuellen Index und löschen dann die letzte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells[i--] = transitioningCells[transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; transitioningCells.RemoveAt(transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir eine Methode erstellen </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um seine Arbeit zu erledigen, benötigt er einen Index und Zellendaten. Beginnen wir also damit, diese abzurufen. </font><font style="vertical-align: inherit;">Es sollte auch festgelegt werden, ob die Aktualisierung der Zelle fortgesetzt werden soll. </font><font style="vertical-align: inherit;">Standardmäßig gehen wir davon aus, dass dies nicht erforderlich ist. </font><font style="vertical-align: inherit;">Nach Abschluss der Arbeiten müssen die geänderten Daten übernommen und der Status "Das Update wird fortgesetzt" zurückgegeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; Color32 data = cellTextureData[index]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellendaten aktualisieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir eine Zelle, die sich im Übergang befindet oder diese bereits fertiggestellt hat. </font><font style="vertical-align: inherit;">Lassen Sie uns zunächst den Status der Zellsonde überprüfen. </font><font style="vertical-align: inherit;">Wenn die Zelle untersucht wird, ihr G-Wert jedoch noch nicht 255 beträgt, befindet sie sich im Übergangsprozess, sodass wir dies überwachen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } cellTextureData[index] = data;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Übergang durchzuführen, fügen wir dem G-Wert der Zelle ein Delta hinzu. </font><font style="vertical-align: inherit;">Arithmetische Operationen funktionieren nicht mit Bytes, sondern werden zuerst in Ganzzahlen konvertiert. </font><font style="vertical-align: inherit;">Daher hat die Summe das Ganzzahlformat, das in Byte konvertiert werden muss.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vor der Konvertierung müssen Sie jedoch sicherstellen, dass der Wert 255 nicht überschreitet. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als nächstes müssen wir dasselbe für die Sichtbarkeit tun, die den Wert von R verwendet. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible &amp;&amp; data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da die Zelle wieder unsichtbar werden kann, müssen wir prüfen, ob der Wert von R verringert werden muss. Dies geschieht, wenn die Zelle unsichtbar ist, R jedoch größer als Null ist. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r - delta; data.r = t &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist es </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fertig und die Sichtbarkeitsübergänge werden korrekt ausgeführt.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sichtbarkeitsübergänge.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schutz vor doppelten Übergangselementen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übergänge funktionieren, aber möglicherweise werden doppelte Elemente in der Liste angezeigt. </font><font style="vertical-align: inherit;">Dies geschieht, wenn sich der Sichtbarkeitsstatus der Zelle ändert, während sie sich noch im Übergang befindet. </font><font style="vertical-align: inherit;">Zum Beispiel, wenn die Zelle während der Bewegung des Trupps nur für kurze Zeit sichtbar ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund des Auftretens doppelter Elemente wird der Zellenübergang mehrmals pro Frame aktualisiert, was zu schnelleren Übergängen und zusätzlicher Arbeit führt. </font><font style="vertical-align: inherit;">Wir können dies verhindern, indem wir vor dem Hinzufügen einer Zelle prüfen, ob sie bereits in der Liste enthalten ist. </font><font style="vertical-align: inherit;">Eine Listensuche bei jedem Anruf</font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kostspielig, insbesondere wenn mehrere Zellübergänge durchgeführt werden. </font><font style="vertical-align: inherit;">Verwenden wir stattdessen einen anderen Kanal, der noch nicht verwendet wurde, um anzugeben, ob sich die Zelle im Übergangsprozess befindet, z. B. Wert B. Wenn wir der Liste eine Zelle hinzufügen, weisen wir ihr den Wert 255 zu und fügen nur die Zellen hinzu, deren Wert nicht 255 entspricht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData[index].b != <span class="hljs-number"><span class="hljs-number">255</span></span>) { cellTextureData[index].b = <span class="hljs-number"><span class="hljs-number">255</span></span>; transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Damit dies funktioniert, müssen wir den Wert von B nach Abschluss des Zellübergangs zurücksetzen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stillUpdating) { data.b = <span class="hljs-number"><span class="hljs-number">0</span></span>; } cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übergänge ohne Duplikate.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit sofort laden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderungen der Sichtbarkeit sind jetzt immer schrittweise, auch beim Laden einer Karte. </font><font style="vertical-align: inherit;">Dies ist unlogisch, da die Karte den Zustand beschreibt, in dem die Zellen bereits sichtbar sind, sodass der Übergang hier unangemessen ist. </font><font style="vertical-align: inherit;">Darüber hinaus kann das Durchführen von Übergängen für die vielen sichtbaren Zellen einer großen Karte das Spiel nach dem Laden verlangsamen. </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wechseln </font><font style="vertical-align: inherit;">wir daher vor dem Laden von Zellen und Trupps </font><font style="vertical-align: inherit;">in den Sofortübergangsmodus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher definieren wir die anfängliche Einstellung des Sofortübergangsmodus neu, unabhängig davon, wie er aussieht. </font><font style="vertical-align: inherit;">Möglicherweise ist es bereits ausgeschaltet oder es wurde eine Konfigurationsoption vorgenommen, sodass wir uns an den Anfangsmodus erinnern und nach Abschluss der Arbeiten darauf umschalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> originalImmediateMode = cellShaderData.ImmediateMode; cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; … cellShaderData.ImmediateMode = originalImmediateMode; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Höhenabhängiger Bereich </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir für alle Einheiten einen konstanten Umfang von drei verwendet, aber in Wirklichkeit ist dies komplizierter. Im allgemeinen Fall können wir das Objekt aus zwei Gründen nicht sehen: Entweder hindert uns ein Hindernis daran, es zu sehen, oder das Objekt ist zu klein oder zu weit. In unserem Spiel implementieren wir nur die Bereichsbeschränkung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können nicht sehen, was sich auf der gegenüberliegenden Seite der Erde befindet, weil der Planet uns verdeckt. Wir können nur bis zum Horizont sehen. Da der Planet ungefähr als Kugel betrachtet werden kann, gilt: Je höher der Blickwinkel, desto mehr Oberfläche können wir sehen, dh der Horizont hängt von der Höhe ab.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/788/208/0717882082a42e92b14e158876c6e28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Horizont hängt von der Höhe des Aussichtspunkts ab. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die eingeschränkte Sichtbarkeit unserer Einheiten ahmt den Horizonteffekt nach, der durch die Krümmung der Erde erzeugt wird. </font><font style="vertical-align: inherit;">Die Reichweite ihrer Überprüfung hängt von der Größe des Planeten und dem Maßstab der Karte ab. </font><font style="vertical-align: inherit;">Zumindest ist das die logische Erklärung. </font><font style="vertical-align: inherit;">Der Hauptgrund für die Reduzierung des Umfangs ist jedoch das Gameplay. Dies ist eine Einschränkung, die als Nebel des Krieges bezeichnet wird. </font><font style="vertical-align: inherit;">Wenn wir jedoch die dem Sichtfeld zugrunde liegende Physik verstehen, können wir daraus schließen, dass ein hoher Standpunkt einen strategischen Wert haben sollte, da er sich vom Horizont entfernt und es Ihnen ermöglicht, niedrigere Hindernisse zu betrachten. </font><font style="vertical-align: inherit;">Aber bisher haben wir es nicht umgesetzt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Höhe zur Überprüfung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Höhe bei der Bestimmung des Umfangs zu berücksichtigen, müssen wir die Höhe kennen. </font><font style="vertical-align: inherit;">Dies ist die übliche Höhe oder der übliche Wasserstand, je nachdem, ob es sich um eine Landzelle oder um Wasser handelt. </font><font style="vertical-align: inherit;">Fügen wir dies der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ViewElevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation &gt;= waterLevel ? elevation : waterLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich die Höhe jedoch auf den Bereich auswirkt, kann sich bei einer Änderung der Betrachtungshöhe der Zelle auch die Sichtbarkeitssituation ändern. </font><font style="vertical-align: inherit;">Da die Zelle den Umfang mehrerer Einheiten blockiert hat oder jetzt blockiert, ist es nicht so einfach zu bestimmen, was geändert werden muss. </font><font style="vertical-align: inherit;">Die Zelle selbst kann dieses Problem nicht lösen. Lassen Sie sie daher eine Änderung der Situation melden </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Angenommen, Sie </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben eine Methode dafür </font></font><code>ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden es bei </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bedarf </font><font style="vertical-align: inherit;">bei Abtretung anrufen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das gilt auch für </font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } ValidateRivers(); Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit zurücksetzen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir eine Methode erstellen </font></font><code>HexCellShaderData.ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Ermitteln, wie sich eine allgemeine Sichtbarkeitssituation ändert, ist eine komplexe Aufgabe, insbesondere wenn mehrere Zellen gleichzeitig geändert werden. </font><font style="vertical-align: inherit;">Daher werden wir keine Tricks finden, sondern einfach planen, die Sichtbarkeit aller Zellen zurückzusetzen. </font><font style="vertical-align: inherit;">Fügen Sie ein boolesches Feld hinzu, um zu verfolgen, ob dies geschehen soll. </font><font style="vertical-align: inherit;">Innerhalb der Methode setzen wir sie einfach auf true und schließen die Komponente ein. </font><font style="vertical-align: inherit;">Unabhängig von der Anzahl der Zellen, die sich gleichzeitig geändert haben, führt dies zu einem einzelnen Reset.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> needsVisibilityReset; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewElevationChanged</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Sichtbarkeitswerte aller Zellen zurückzusetzen, müssen Sie Zugriff auf diese haben, über die Sie </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht verfügen. </font><font style="vertical-align: inherit;">Lassen Sie uns diese Verantwortung delegieren </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dazu müssen Sie der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft etwas </font><font style="vertical-align: inherit;">hinzufügen, </font><font style="vertical-align: inherit;">damit Sie auf das Raster verweisen können. </font><font style="vertical-align: inherit;">Dann können wir es verwenden </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um einen Reset anzufordern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needsVisibilityReset) { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Grid.ResetVisibility(); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahren wir fort mit </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Setzen Sie den Link zum Raster, </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nachdem Sie die Shader-Daten erstellt haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); cellShaderData.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; CreateMap(cellCountX, cellCountZ); }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte auch eine Methode erhalten </font></font><code>ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um alle Zellen zu verwerfen. </font><font style="vertical-align: inherit;">Lassen Sie es einfach alle Zellen in der Schleife umgehen und delegieren Sie das Zurücksetzen an sich selbst.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir die </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">ergänzen </font></font><code>ResetVisibilty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Sichtbarkeit wird einfach auf Null gesetzt und die Sichtbarkeitsaktualisierung ausgelöst. </font><font style="vertical-align: inherit;">Dies muss erfolgen, wenn die Sichtbarkeit der Zelle größer als Null ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { visibility = <span class="hljs-number"><span class="hljs-number">0</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem er alle Sichtbarkeitsdaten zurückgesetzt hat, </font></font><code>HexGrid.ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss er erneut Sichtbarkeit auf alle Trupps anwenden, für die er den Umfang jedes Trupps kennen muss. </font><font style="vertical-align: inherit;">Angenommen, es kann mit der Eigenschaft abgerufen werden </font></font><code>VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { HexUnit unit = units[i]; IncreaseVisibility(unit.Location, unit.VisionRange); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit dies funktioniert, werden wir die Umbenennung </font></font><code>HexUnit.visionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font><font style="vertical-align: inherit;">umgestalten </font></font><code>HexUnit.VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und in eine Eigenschaft umwandeln. </font><font style="vertical-align: inherit;">Es wird zwar einen konstanten Wert von 3 erhalten, aber in Zukunft wird es sich ändern.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VisionRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesem Grund werden die Sichtbarkeitsdaten zurückgesetzt und bleiben nach dem Ändern der Zellenbetrachtungshöhe korrekt. </font><font style="vertical-align: inherit;">Es ist jedoch wahrscheinlich, dass wir die Regeln für die Bestimmung des Bereichs ändern und die Neukompilierung im Wiedergabemodus ausführen. </font><font style="vertical-align: inherit;">Damit sich der Bereich unabhängig ändert, führen wir einen Reset durch, </font></font><code>HexGrid.OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn eine Neukompilierung erkannt wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { … ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können Sie den Scope-Code ändern und die Ergebnisse anzeigen, während Sie im Wiedergabemodus bleiben. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Den Horizont erweitern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Berechnung des Umfangs wird festgelegt </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Damit sich die Höhe auf den Bereich auswirkt, können wir einfach die Betrachtungshöhe verwenden, indem wir </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den übertragenen Bereich vorübergehend neu definieren. </font><font style="vertical-align: inherit;">So können wir leicht überprüfen, ob dies funktioniert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { … range = fromCell.ViewElevation; fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/032/6d3/7270326d379796f2b4f2f3c3ca65512c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die Höhe als Zielfernrohr.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindernisse für die Sichtbarkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Anwenden einer Betrachtungshöhe als Bereich funktioniert nur dann ordnungsgemäß, wenn sich alle anderen Zellen auf der Höhe Null befinden. </font><font style="vertical-align: inherit;">Wenn jedoch alle Zellen dieselbe Höhe wie der Blickwinkel haben, sollte das Sichtfeld Null sein. </font><font style="vertical-align: inherit;">Außerdem sollten Zellen mit hohen Höhen die Sichtbarkeit der niedrigen Zellen dahinter blockieren. </font><font style="vertical-align: inherit;">Bisher wurde nichts davon implementiert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/7be/a6f/de87bea6f4b88cd61765450a63f738f9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Umfang stört nicht. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der korrekteste Weg, um den Umfang zu bestimmen, wäre die Überprüfung durch die Emission von Strahlen, aber es würde schnell teuer werden und immer noch seltsame Ergebnisse liefern. </font><font style="vertical-align: inherit;">Wir brauchen eine schnelle Lösung, die gut genug Ergebnisse liefert, die nicht perfekt sein müssen. </font><font style="vertical-align: inherit;">Darüber hinaus ist es wichtig, dass die Regeln zur Bestimmung des Umfangs für die Spieler einfach, intuitiv und vorhersehbar sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Lösung lautet wie folgt: Wenn Sie die Sichtbarkeit einer Zelle bestimmen, addieren wir die Betrachtungshöhe der benachbarten Zelle zur zurückgelegten Entfernung. </font><font style="vertical-align: inherit;">Tatsächlich verringert dies den Umfang, wenn wir diese Zellen betrachten, und wenn sie übersprungen werden, können wir die Zellen hinter ihnen nicht erreichen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/44c/efe/77444cefe82d428ee32e094213e82a1a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hohe Zellen blockieren die Ansicht.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollten wir in der Ferne keine hohen Zellen sehen?</font></font></b> <div class="spoiler_text">      ,     ,   ,   .       ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauen Sie nicht um die Ecken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt scheint es, dass hohe Zellen die Sicht auf niedrig blockieren, aber manchmal durchdringt der Bereich sie, obwohl es so scheint, dass dies nicht sein sollte. </font><font style="vertical-align: inherit;">Dies geschieht, weil der Suchalgorithmus immer noch einen Pfad zu diesen Zellen findet und die blockierenden Zellen umgeht. </font><font style="vertical-align: inherit;">Infolgedessen sieht es so aus, als ob unser Sichtbereich Hindernisse umgehen kann. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, müssen wir sicherstellen, dass bei der Bestimmung der Zellsichtbarkeit nur die kürzesten Pfade berücksichtigt werden. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem Pfade gelöscht werden, die länger als nötig werden.</font></font><br><br><pre> <code class="cs hljs"> HexCoordinates fromCoordinates = fromCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range || distance &gt; fromCoordinates.DistanceTo(neighbor.coordinates) ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/bfa/1c2/30dbfa1c2df2fb6119249f00cdc3d8d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir benutzen nur die kürzesten Wege.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also haben wir die meisten offensichtlich fehlerhaften Fälle behoben. Für nahe gelegene Zellen funktioniert dies gut, da es nur kürzeste Wege zu ihnen gibt. Weiter entfernte Zellen haben mehr Optionen für Pfade, daher kann über große Entfernungen immer noch eine Sichtbarkeitshülle auftreten. Dies ist kein Problem, wenn die Sichtbereiche klein bleiben und die Unterschiede in benachbarten Höhen nicht zu groß sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schließlich fügen wir, anstatt das übertragene Sichtfeld zu ersetzen, die Höhe der Sicht hinzu. Das eigene Sichtfeld des Trupps zeigt seine Höhe, Flughöhe oder Aufklärungsfähigkeiten an.</font></font><br><br><pre> <code class="cs hljs"> range += fromCell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ff/1ce/a2b/3ff1cea2b833bda69990576fa8323aec.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansicht mit vollem Sichtfeld bei niedriger Sicht. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das heißt, die endgültigen Sichtbarkeitsregeln gelten für das Sehen, wenn Sie sich auf dem kürzesten Weg zum Sichtfeld bewegen, wobei der Unterschied in der Zellenhöhe relativ zum Blickwinkel berücksichtigt wird. </font><font style="vertical-align: inherit;">Wenn eine Zelle außerhalb des Gültigkeitsbereichs liegt, blockiert sie alle Pfade durch sie. </font><font style="vertical-align: inherit;">Infolgedessen werden hohe Beobachtungspunkte, von denen aus nichts die Sicht behindert, strategisch wertvoll.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit der Behinderung der Sichtbarkeit von Objekten?</font></font></b> <div class="spoiler_text">  ,        ,  . ,  ,        .          . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen, die nicht erforscht werden können </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das letzte Problem mit der Sichtbarkeit betrifft die Kanten der Karte. </font><font style="vertical-align: inherit;">Das Relief endet abrupt und ohne Übergänge, weil die Zellen am Rand keine Nachbarn haben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/217/fbb/587217fbb248ae8a13759a33e22e25ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Markierter Rand der Karte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Idealfall sollte die visuelle Anzeige von unerforschten Bereichen und Kanten der Karte identisch sein. Wir können dies erreichen, indem wir Sonderfälle hinzufügen, wenn Kanten trianguliert werden, wenn sie keine Nachbarn haben. Dies erfordert jedoch zusätzliche Logik und wir müssen mit fehlenden Zellen arbeiten. Daher ist eine solche Lösung nicht trivial. Ein alternativer Ansatz besteht darin, zu erzwingen, dass die Grenzzellen der Karte nicht erforscht werden, selbst wenn sie sich im Bereich des Trupps befinden. Dieser Ansatz ist viel einfacher, also verwenden wir ihn. Außerdem können Sie diese als unerforschte und andere Zellen markieren, wodurch die Erstellung ungleichmäßiger Kanten der Karte erleichtert wird. Darüber hinaus können Sie mit versteckten Zellen an den Rändern Straßen und Flüsse erstellen, die in die Karte des Flusses und der Straße eintreten und diese verlassen, da ihre Endpunkte außerhalb des Bereichs liegen.Mithilfe dieser Lösung können Sie auch Einheiten hinzufügen, die die Karte betreten und verlassen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir markieren Zellen als untersucht </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft </font><font style="vertical-align: inherit;">hinzu, dass eine Zelle untersucht werden kann </font></font><code>Explorable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Explorable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt kann eine Zelle sichtbar sein, wenn es sich um eine untersuchte handelt. </font></font><code>IsVisible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher </font><font style="vertical-align: inherit;">ändern </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">die Eigenschaft </font><font style="vertical-align: inherit;">, um dies zu berücksichtigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Explorable; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleiches gilt für </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hierzu haben wir jedoch die Standardeigenschaft untersucht. </font><font style="vertical-align: inherit;">Wir müssen es in eine explizite Eigenschaft konvertieren, um die Logik seines Getters ändern zu können.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> explored &amp;&amp; Explorable; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { explored = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> explored;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verstecke den Rand der Karte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können den Rand einer rechteckigen Karte in der Methode ausblenden </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zellen, die sich nicht am Rand befinden, werden untersucht, der Rest ist unerforscht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sind die Karten an den Rändern abgedunkelt und verstecken sich hinter ihnen riesige unerforschte Räume. </font><font style="vertical-align: inherit;">Infolgedessen nimmt die Größe des untersuchten Kartenbereichs in jeder Dimension um zwei ab.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/594/19f/353/59419f35345fa4eac3380c4e16461baf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unerforschter Rand der Karte.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es möglich, den Forschungszustand bearbeitbar zu machen?</font></font></b> <div class="spoiler_text"> ,  ,     .          . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unerforschte Zellen beeinträchtigen die Sichtbarkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Zelle nicht untersucht werden kann, sollte sie die Sichtbarkeit beeinträchtigen. </font><font style="vertical-align: inherit;">Ändern Sie dies </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um dies zu berücksichtigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase || !neighbor.Explorable ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 23: Land erzeugen </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Füllen Sie neue Karten mit generierten Landschaften. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir erheben Land über Wasser, wir überfluten einige. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir kontrollieren die Menge des geschaffenen Landes, seine Höhe und Unebenheiten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bieten Unterstützung für verschiedene Konfigurationsoptionen zum Erstellen von Variablenzuordnungen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir machen es so, dass dieselbe Karte erneut generiert werden kann. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Teil des Tutorials ist der Beginn einer Reihe zur prozeduralen Kartengenerierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Teil wurde in Unity 2017.1.0 erstellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/798/7bb/99e7987bbcb46f1f961b72ba76a78aa0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine der vielen generierten Karten.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartengenerierung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir jede Karte erstellen können, dauert es sehr lange. Es wäre praktisch, wenn die Anwendung dem Designer helfen könnte, indem er Karten für ihn generiert, die er dann nach seinem Geschmack ändern kann. Sie können einen weiteren Schritt unternehmen und das manuelle Erstellen des Entwurfs vollständig vermeiden, indem Sie die Verantwortung für das Generieren der fertigen Karte vollständig auf die Anwendung übertragen. Aus diesem Grund kann das Spiel jedes Mal mit einer neuen Karte gespielt werden und jede Spielsitzung ist anders. Damit dies alles möglich ist, müssen wir einen Algorithmus zur Kartengenerierung erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Art von Generierungsalgorithmus Sie benötigen, hängt von der Art der Karte ab, die Sie benötigen. Es gibt keinen richtigen Ansatz, man muss immer nach einem Kompromiss zwischen Glaubwürdigkeit und Spielbarkeit suchen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit eine Karte glaubwürdig ist, muss sie dem Spieler durchaus möglich und real erscheinen. Dies bedeutet nicht, dass die Karte wie ein Teil unseres Planeten aussehen sollte. Es kann ein anderer Planet oder eine völlig andere Realität sein. Aber wenn es das Relief der Erde anzeigen soll, dann muss es ihm zumindest teilweise ähneln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Spielbarkeit hängt davon ab, wie die Karten dem Gameplay entsprechen. Manchmal widerspricht es der Glaubwürdigkeit. Zum Beispiel können Bergketten, obwohl sie schön aussehen können, gleichzeitig die Bewegung und Sicht von Einheiten stark einschränken. Wenn dies unerwünscht ist, müssen Sie auf Berge verzichten, was die Glaubwürdigkeit verringert und die Ausdruckskraft des Spiels einschränkt. Oder wir können die Berge retten, aber ihre Auswirkungen auf das Gameplay verringern, was auch die Glaubwürdigkeit verringern kann.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darüber hinaus muss die Machbarkeit berücksichtigt werden. Sie können beispielsweise einen sehr realistischen erdähnlichen Planeten erstellen, indem Sie tektonische Platten, Erosion, Regen, Vulkanausbrüche, die Auswirkungen von Meteoriten und Mond usw. simulieren. Die Entwicklung eines solchen Systems wird jedoch viel Zeit in Anspruch nehmen. Darüber hinaus kann es lange dauern, einen solchen Planeten zu generieren, und die Spieler werden nicht einige Minuten warten wollen, bevor sie ein neues Spiel starten. Das heißt, Simulation ist ein mächtiges Werkzeug, aber es hat einen Preis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spiele verwenden häufig Kompromisse zwischen Glaubwürdigkeit, Spielbarkeit und Durchführbarkeit. Manchmal sind solche Kompromisse unsichtbar und scheinen völlig normal zu sein, und manchmal sehen sie zufällig, inkonsistent oder chaotisch aus, abhängig von den Entscheidungen, die während des Entwicklungsprozesses getroffen werden. Dies gilt nicht nur für die Kartengenerierung, sondern Sie müssen bei der Entwicklung eines prozeduralen Kartengenerators besonders darauf achten. Sie können viel Zeit damit verbringen, einen Algorithmus zu erstellen, der wunderschöne Karten generiert, die sich für das von Ihnen erstellte Spiel als nutzlos herausstellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Tutorialserie werden wir ein landähnliches Relief erstellen. </font><font style="vertical-align: inherit;">Es sollte interessant aussehen, mit großer Variabilität und dem Fehlen großer homogener Bereiche. </font><font style="vertical-align: inherit;">Der Reliefmaßstab wird groß sein, Karten werden einen oder mehrere Kontinente, Regionen der Ozeane oder sogar einen ganzen Planeten abdecken. </font><font style="vertical-align: inherit;">Wir brauchen Kontrolle über die Geographie, einschließlich Landmassen, Klima, Anzahl der Regionen und Geländeunebenheiten. </font><font style="vertical-align: inherit;">In diesem Teil legen wir den Grundstein für die Herstellung von Sushi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erste Schritte im Bearbeitungsmodus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden uns auf die Karte konzentrieren, nicht auf das Gameplay, daher ist es bequemer, die Anwendung im Bearbeitungsmodus zu starten. </font><font style="vertical-align: inherit;">Dank dessen können wir die Karten sofort sehen. </font><font style="vertical-align: inherit;">Daher ändern wir </font></font><code>HexMapEditor.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Bearbeitungsmodus auf true und aktivieren das Shader-Schlüsselwort dieses Modus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartengenerator </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da zum Generieren von prozeduralen Maps ziemlich viel Code benötigt wird, werden wir ihn nicht direkt hinzufügen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen erstellen wir eine neue Komponente </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wissen nichts darüber. </font><font style="vertical-align: inherit;">Dies vereinfacht den Übergang zu einem anderen Algorithmus, wenn wir ihn benötigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Generator benötigt eine Verknüpfung zum Raster, daher fügen wir ihm ein allgemeines Feld hinzu. </font><font style="vertical-align: inherit;">Zusätzlich fügen wir eine allgemeine Methode hinzu </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die sich mit der Arbeit des Algorithmus befasst. </font><font style="vertical-align: inherit;">Wir geben ihm die Abmessungen der Karte als Parameter und erzwingen dann, dass sie zum Erstellen einer neuen leeren Karte verwendet wird.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der Szene ein Objekt mit einer Komponente hinzu </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verbinden Sie es mit dem Raster.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/b6e/fd2/932b6efd2dd1809893af27ec7a91c620.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kartengeneratorobjekt.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ändern Sie das Menü einer neuen Karte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden es </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so </font><font style="vertical-align: inherit;">ändern </font><font style="vertical-align: inherit;">, dass es Karten erzeugen kann, nicht nur leere. </font><font style="vertical-align: inherit;">Wir werden seine Funktionalität über ein Boolesches Feld steuern </font></font><code>generateMaps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das standardmäßig einen Wert hat </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lassen Sie uns eine allgemeine Methode zum Festlegen dieses Felds erstellen, wie wir es getan haben, um Optionen zu wechseln </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fügen Sie dem Menü den entsprechenden Schalter hinzu und verbinden Sie ihn mit der Methode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> generateMaps = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleMapGeneration</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { generateMaps = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc9/9c7/0c9/fc99c70c99095b3565104ef42254859d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menü einer neuen Karte mit einem Schalter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geben Sie dem Menü einen Link zum Kartengenerator. </font><font style="vertical-align: inherit;">Dann werden wir ihn zwingen, bei Bedarf die </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatormethode </font><font style="vertical-align: inherit;">aufzurufen </font><font style="vertical-align: inherit;">und nicht nur das </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raster </font><font style="vertical-align: inherit;">auszuführen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMapGenerator mapGenerator; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d1/e98/3d9/7d1e983d927d912b75d9b245219659f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschluss an den Generator.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellenzugriff </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit der Generator funktioniert, muss er auf die Zellen zugreifen können. </font><font style="vertical-align: inherit;">Wir </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben bereits gängige Methoden , </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die oder Positionsvektor erfordern, oder Sechseck - </font><font style="vertical-align: inherit;">Koordinaten. </font><font style="vertical-align: inherit;">Der Generator muss weder mit dem einen noch mit dem anderen arbeiten, daher fügen wir zwei praktische Methoden hinzu </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die mit den Koordinaten des Versatzes oder des Index der Zelle arbeiten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zOffset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[xOffset + zOffset * cellCountX]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[cellIndex]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann es Zellen direkt empfangen. </font><font style="vertical-align: inherit;">Nach dem Erstellen einer neuen Karte kann er beispielsweise Graskoordinaten verwenden, um Gras als Relief der mittleren Zellenspalte festzulegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; z; i++) { grid.GetCell(x / <span class="hljs-number"><span class="hljs-number">2</span></span>, i).TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/aee/119/860aee119f0e000ef290f6c87e61ad05.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grassäule auf einer kleinen Karte. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sushi machen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Erstellung einer Karte beginnen wir komplett ohne Land. </font><font style="vertical-align: inherit;">Man kann sich vorstellen, dass die ganze Welt von einem riesigen Ozean überflutet ist. </font><font style="vertical-align: inherit;">Ein Land entsteht, wenn ein Teil des Meeresbodens so weit nach oben gedrückt wird, dass er sich über das Wasser erhebt. </font><font style="vertical-align: inherit;">Wir müssen entscheiden, wie viel Land auf diese Weise geschaffen werden soll, wo es erscheinen wird und welche Form es haben wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erhöhen Sie die Erleichterung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fangen wir klein an - heben Sie ein Stück Land über das Wasser. </font><font style="vertical-align: inherit;">Dazu erstellen wir eine Methode </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Parameter zur Steuerung der Größe des Plots. </font><font style="vertical-align: inherit;">Rufen Sie diese Methode auf </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ersetzen Sie den vorherigen Testcode. </font><font style="vertical-align: inherit;">Beginnen wir mit einem kleinen Stück Land, das aus sieben Zellen besteht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; z; i++) { // grid.GetCell(x / 2, i).TerrainTypeIndex = 1; // } RaiseTerrain(7); } void RaiseTerrain (int chunkSize) {}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher verwenden wir das Relief „Gras“, um das erhöhte Land zu bezeichnen, und das ursprüngliche Relief „Sand“ bezieht sich auf den Ozean. </font><font style="vertical-align: inherit;">Lassen Sie uns </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine zufällige Zelle nehmen und die Art ihres Reliefs ändern, bis wir die richtige Menge Land erhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine zufällige Zelle zu erhalten, fügen wir eine Methode hinzu </font></font><code>GetRandomCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die einen zufälligen Zellenindex bestimmt und die entsprechende Zelle aus dem Raster erhält.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunkSize; i++) { GetRandomCell().TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, grid.cellCountX * grid.cellCountZ)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/fb8/ce6/396fb8ce67de74961b31562e275bd81a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sieben zufällige Sushi-Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir am Ende möglicherweise viele zufällige Zellen benötigen oder alle Zellen mehrmals durchlaufen müssen, verfolgen wir die Anzahl der Zellen in der Zelle selbst </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; … } … <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, cellCount)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellung einer Site </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher verwandeln wir sieben zufällige Zellen in Land, und sie können überall sein. </font><font style="vertical-align: inherit;">Höchstwahrscheinlich bilden sie keine einzige Landfläche. </font><font style="vertical-align: inherit;">Außerdem können wir dieselben Zellen mehrmals auswählen, sodass wir weniger Land erhalten. </font><font style="vertical-align: inherit;">Um beide Probleme ohne Einschränkungen zu lösen, wählen wir nur die erste Zelle aus. </font><font style="vertical-align: inherit;">Danach sollten wir nur die Zellen auswählen, die sich neben den zuvor ausgewählten befinden. </font><font style="vertical-align: inherit;">Diese Einschränkungen ähneln den Einschränkungen der Pfadsuche, daher verwenden wir hier denselben Ansatz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir fügen </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unser eigenes Eigentum und den Zähler der Phase der Suchgrenze hinzu, wie es war </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Überprüfen Sie, ob die Prioritätswarteschlange vorhanden ist, bevor wir sie benötigen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Erstellen einer neuen Karte ist die Suchgrenze für alle Zellen Null. Wenn wir jedoch bei der Kartengenerierung nach Zellen suchen, werden wir deren Suchgrenze in diesem Prozess erhöhen. Wenn wir viele Suchvorgänge ausführen, liegen diese möglicherweise vor der Phase der aufgezeichneten Suchgrenze </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies kann die Suche nach Einheitenpfaden beeinträchtigen. Um dies zu vermeiden, setzen wir am Ende des Kartengenerierungsprozesses die Suchphase aller Zellen auf Null zurück.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt muss ich </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach den entsprechenden Zellen suchen und sie nicht zufällig auswählen. Dieser Vorgang ist der Suchmethode in sehr ähnlich </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir werden Zellen jedoch nicht mehr als einmal besuchen, sodass es ausreicht, die Phase des Suchrahmens um 1 statt um 2 zu erhöhen. Dann initialisieren wir den Rand mit der ersten Zelle, die zufällig ausgewählt wird. Zusätzlich zum Festlegen der Suchphase weisen wir wie üblich den Abstand und die Heuristik auf Null zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; chunkSize; i++) { // GetRandomCell().TerrainTypeIndex = 1; // } searchFrontierPhase += 1; HexCell firstCell = GetRandomCell(); firstCell.SearchPhase = searchFrontierPhase; firstCell.Distance = 0; firstCell.SearchHeuristic = 0; searchFrontier.Enqueue(firstCell); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach ist uns die Suchschleife größtenteils vertraut. </font><font style="vertical-align: inherit;">Um die Suche fortzusetzen, bis der Rand leer ist, müssen wir außerdem anhalten, wenn das Fragment die gewünschte Größe erreicht hat, damit wir es verfolgen können. </font><font style="vertical-align: inherit;">Bei jeder Iteration extrahieren wir die nächste Zelle aus der Warteschlange, legen den Typ des Reliefs fest, erhöhen die Größe und umgehen dann die Nachbarn dieser Zelle. </font><font style="vertical-align: inherit;">Alle Nachbarn werden einfach zur Grenze hinzugefügt, wenn sie dort noch nicht hinzugefügt wurden. </font><font style="vertical-align: inherit;">Wir müssen keine Änderungen oder Vergleiche vornehmen. </font><font style="vertical-align: inherit;">Nach Abschluss müssen Sie die Grenze löschen.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } } searchFrontier.Clear();</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97a/f44/023/97af440236cb6909130d6a8bfaab3f5a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Reihe von Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben ein einzelnes Grundstück der richtigen Größe. </font><font style="vertical-align: inherit;">Es wird nur kleiner, wenn nicht genügend Zellen vorhanden sind. </font><font style="vertical-align: inherit;">Aufgrund der Art und Weise, wie die Grenze gefüllt ist, besteht das Grundstück immer aus einer Linie, die nach Nordwesten verläuft. </font><font style="vertical-align: inherit;">Es ändert die Richtung nur, wenn es den Rand der Karte erreicht.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verbinden Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Landflächen ähneln selten Linien, und wenn doch, sind sie nicht immer gleich ausgerichtet. </font><font style="vertical-align: inherit;">Um die Form der Site zu ändern, müssen wir die Prioritäten der Zellen ändern. </font><font style="vertical-align: inherit;">Die erste Zufallszelle kann als Mittelpunkt des Diagramms verwendet werden. </font><font style="vertical-align: inherit;">Dann ist der Abstand zu allen anderen Zellen relativ zu diesem Punkt. </font><font style="vertical-align: inherit;">Daher werden wir Zellen, die näher am Zentrum liegen, eine höhere Priorität einräumen, damit die Site nicht als Linie, sondern um das Zentrum herum wächst.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); HexCoordinates center = firstCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/117/149/84111714960a293415b1d24edf92f56b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ansammlung von Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich sind unsere sieben Zellen jetzt wunderschön in einem kompakten sechseckigen Bereich verpackt, wenn die zentrale Zelle nicht am Rand der Karte angezeigt wird. </font><font style="vertical-align: inherit;">Versuchen wir jetzt, eine Plotgröße von 30 zu verwenden.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/893/c36/13e/893c3613edfe02b457cc4ee6d191072c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sushi-Masse in 30 Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben wieder die gleiche Form, obwohl es nicht genügend Zellen gab, um das richtige Sechseck zu erhalten. </font><font style="vertical-align: inherit;">Da der Radius des Diagramms größer ist, ist es wahrscheinlicher, dass es sich nahe am Rand der Karte befindet, wodurch eine andere Form angenommen wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sushi Randomisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir möchten nicht, dass alle Bereiche gleich aussehen, daher ändern wir die Zellenprioritäten geringfügig. </font><font style="vertical-align: inherit;">Jedes Mal, wenn wir eine benachbarte Zelle zum Rand hinzufügen </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird die Heuristik dieser Zelle nicht 0, sondern 1 </font><font style="vertical-align: inherit;">, wenn die nächste Zahl </font><font style="vertical-align: inherit;">kleiner als ein bestimmter Schwellenwert ist. Verwenden wir den Wert 0,5 als Schwellenwert, dh es wirkt sich höchstwahrscheinlich auf die Hälfte der Zellen aus.</font></font><br><br><pre> <code class="cs hljs"> neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/aec/793/43eaec79315f68e0618fe71c0f93c3f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzerrter Bereich.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch Erhöhen der Suchheuristik der Zelle haben wir sie später als erwartet besucht. Gleichzeitig werden andere Zellen, die sich einen Schritt weiter vom Zentrum entfernt befinden, früher besucht, sofern sie nicht auch die Heuristik erhöhen. Dies bedeutet, dass wenn wir die Heuristik aller Zellen um einen Wert erhöhen, dies keine Auswirkungen auf die Karte hat. Das heißt, Schwelle 1 hat keine Auswirkung wie Schwelle 0. Und Schwelle 0,8 entspricht 0,2. Das heißt, die Wahrscheinlichkeit von 0,5 macht den Suchvorgang zum "zitterndsten". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das geeignete Maß an Schwingung hängt vom gewünschten Geländetyp ab. Machen wir es also anpassbar. Fügen Sie dem Generator ein generisches Float-Feld </font></font><code>jitterProbability</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Attribut hinzu</font></font><code>Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">begrenzt im Bereich von 0 bis 0,5. </font><font style="vertical-align: inherit;">Geben wir einen Standardwert an, der dem Durchschnitt dieses Intervalls entspricht, d. H. 0,25. </font><font style="vertical-align: inherit;">Auf diese Weise können wir den Generator im Unity-Inspektorfenster konfigurieren.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitterProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/b50/381/795b50381d8c9cda219ff092cf64cee5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wahrscheinlichkeit von Schwankungen. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kannst du es in der Benutzeroberfläche des Spiels anpassbar machen?</font></font></b> <div class="spoiler_text">  ,       .           UI,       .          ,      UI.  ,     .         ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um nun zu entscheiden, wann die Heuristik gleich 1 sein soll, verwenden wir die Wahrscheinlichkeit anstelle eines konstanten Werts. </font></font><br><br><pre> <code class="cs hljs"> neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; jitterProbability ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verwenden die heuristischen Werte 0 und 1. Obwohl größere Werte verwendet werden können, verschlechtert dies die Verformung der Abschnitte erheblich und verwandelt sie höchstwahrscheinlich in ein Bündel von Streifen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erhebe etwas Land </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden uns nicht auf die Erzeugung eines Stücks Land beschränken. </font><font style="vertical-align: inherit;">Zum Beispiel platzieren wir einen Aufruf </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">innerhalb einer Schleife, um fünf Abschnitte zu erhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d42/83f/acd/d4283facd88705107d705290c3d8e78b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fünf Grundstücke. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir jetzt fünf Parzellen mit jeweils 30 Zellen erzeugen, erhalten wir nicht unbedingt genau 150 Zellen Land. </font><font style="vertical-align: inherit;">Da jede Site separat erstellt wird, kennen sie sich nicht, sodass sie sich überschneiden können. </font><font style="vertical-align: inherit;">Dies ist normal, da dadurch interessantere Landschaften als nur einzelne Abschnitte erstellt werden können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Variabilität des Landes zu erhöhen, können wir auch die Größe jedes Grundstücks ändern. </font><font style="vertical-align: inherit;">Fügen Sie zwei ganzzahlige Felder hinzu, um die minimale und maximale Größe der Diagramme zu steuern. </font><font style="vertical-align: inherit;">Weisen Sie ihnen ein ausreichend großes Intervall zu, z. B. 20-200. </font><font style="vertical-align: inherit;">Ich werde das Standardminimum auf 30 und das Standardmaximum auf 100 setzen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(20, 200)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMin = <span class="hljs-number"><span class="hljs-number">30</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMax = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/026/e43/9ea026e43e949f571be0358332447de5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größenintervall. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese Felder, um die Größe des Bereichs beim Aufruf zufällig zu bestimmen </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/124/dab/0df124dab1f706825f75304d2862aea3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fünf zufällig große Abschnitte auf der mittleren Karte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstelle genug Sushi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwar können wir die Menge des erzeugten Landes nicht besonders kontrollieren. </font><font style="vertical-align: inherit;">Obwohl wir die Konfigurationsoption für die Anzahl der Diagramme hinzufügen können, sind die Diagramme selbst zufällig groß und können sich geringfügig oder stark überlappen. </font><font style="vertical-align: inherit;">Daher garantiert die Anzahl der Standorte nicht den Erhalt der erforderlichen Landmenge auf der Karte. </font><font style="vertical-align: inherit;">Fügen wir eine Option hinzu, um den Prozentsatz des Landes, der als Ganzzahl ausgedrückt wird, direkt zu steuern. </font><font style="vertical-align: inherit;">Da 100% Land oder Wasser nicht sehr interessant sind, beschränken wir es auf das Intervall 5–95 mit einem Standardwert von 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(5, 95)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/281/912/21e281912ad5a4a5378c5e55514c639c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozentsatz von Sushi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Schaffung der richtigen Menge Land zu gewährleisten, müssen wir nur weiterhin Gebiete des Geländes anheben, bis wir eine ausreichende Menge erhalten. </font><font style="vertical-align: inherit;">Dazu müssen wir den Prozess kontrollieren, der die Erzeugung von Land erschwert. </font><font style="vertical-align: inherit;">Ersetzen wir daher den vorhandenen Zyklus zum Erhöhen von Websites durch Aufrufen einer neuen Methode </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das erste, was diese Methode macht, ist die Anzahl der Zellen zu berechnen, die Land werden sollen. </font><font style="vertical-align: inherit;">Diese Menge ist unsere Gesamtsumme der Sushi-Zellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; 5; i++) { // RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + 1)); // } CreateLand(); for (int i = 0; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = 0; } } void CreateLand () { int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f); }</span></span></code> </pre> <br> <code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird verursachen, </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis wir die gesamte Menge an Zellen ausgegeben haben. </font><font style="vertical-align: inherit;">Um den Betrag nicht zu überschreiten, ändern wir ihn </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass er den Betrag als zusätzlichen Parameter erhält. </font><font style="vertical-align: inherit;">Nach Beendigung der Arbeit muss er den Restbetrag zurückgeben.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void RaiseTerrain (int chunkSize) { int RaiseTerrain (int chunkSize, int budget) { … return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Menge sollte jedes Mal abnehmen, wenn die Zelle von der Grenze entfernt und in Land umgewandelt wird. </font><font style="vertical-align: inherit;">Wenn danach der gesamte Betrag ausgegeben wird, müssen wir die Suche beenden und die Site vervollständigen. </font><font style="vertical-align: inherit;">Außerdem sollte dies nur erfolgen, wenn die aktuelle Zelle noch nicht gelandet ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann es Land anheben, bis es die gesamte Menge an Zellen verbraucht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { landBudget = RaiseTerrain( Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>), landBudget ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d15/34e/7f4/d1534e7f47ba4cf87f3dbeed60aa7d00.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genau die Hälfte der Karte wurde Land. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berücksichtigen Sie die Höhe </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Land ist nicht nur eine flache Platte, die durch die Küste begrenzt ist. </font><font style="vertical-align: inherit;">Sie hat eine wechselnde Höhe mit Hügeln, Bergen, Tälern, Seen und so weiter. </font><font style="vertical-align: inherit;">Aufgrund des Zusammenspiels sich langsam bewegender tektonischer Platten bestehen große Höhenunterschiede. </font><font style="vertical-align: inherit;">Obwohl wir es nicht simulieren werden, sollten unsere Landflächen in gewisser Weise solchen Platten ähneln. </font><font style="vertical-align: inherit;">Websites bewegen sich nicht, können sich jedoch überschneiden. </font><font style="vertical-align: inherit;">Und das können wir nutzen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schieben Sie das Land nach oben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Grundstück repräsentiert einen Teil des Landes, der aus dem Meeresboden herausgedrückt wurde. </font><font style="vertical-align: inherit;">Erhöhen wir daher ständig die Höhe der aktuellen Zelle </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sehen, was passiert.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f6e/d3e/b3cf6ed3e71eb737ea7246c92bdd5624.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lande mit Höhen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Höhen, aber es ist schwer zu sehen. </font><font style="vertical-align: inherit;">Sie können sie besser lesbar machen, wenn Sie für jede Höhenstufe einen eigenen Geländetyp verwenden, z. B. eine geografische Schichtung. </font><font style="vertical-align: inherit;">Wir werden dies nur tun, damit die Höhen besser erkennbar sind, sodass Sie die Höhenebene einfach als Höhenindex verwenden können.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was passiert, wenn die Höhe die Anzahl der Geländetypen überschreitet?</font></font></b> <div class="spoiler_text">        .        ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt den Geländetyp der Zelle bei jeder Höhenänderung zu aktualisieren, erstellen wir eine separate Methode </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um alle Geländetypen nur einmal festzulegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); cell.TerrainTypeIndex = cell.Elevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden diese Methode nach dem Erstellen von Sushi aufrufen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateLand(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann </font><font style="vertical-align: inherit;">er </font><font style="vertical-align: inherit;">sich nicht mehr mit der Art der Erleichterung befassen und sich auf Höhen konzentrieren. </font><font style="vertical-align: inherit;">Dazu müssen Sie die Logik ändern. </font><font style="vertical-align: inherit;">Wenn die neue Höhe der aktuellen Zelle 1 ist, ist sie gerade zu Land geworden, sodass die Summe der Zellen abgenommen hat, was zum Abschluss des Wachstums des Standorts führen kann.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (current.TerrainTypeIndex == 0) { // current.TerrainTypeIndex = 1; // if (--budget == 0) { // break; // } // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/eec/b9e/ee0eecb9e59f527bd27f0275e230de0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schichtung der Schichten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wasser hinzufügen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns explizit angeben, welche Zellen Wasser oder Land sind, und den Wasserstand für alle Zellen auf 1 einstellen. Führen Sie dies aus, </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bevor Sie Land erstellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = <span class="hljs-number"><span class="hljs-number">1</span></span>; } CreateLand(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für die Bezeichnung von Landschichten können wir nun alle Geländearten verwenden. </font><font style="vertical-align: inherit;">Alle U-Boot-Zellen bleiben Sand, ebenso wie die niedrigsten Landzellen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem der Wasserstand von der Höhe abgezogen und der Wert als Index für den Relieftyp verwendet wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { cell.TerrainTypeIndex = cell.Elevation - cell.WaterLevel; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b5/449/bc3/1b5449bc37b1c677d908484c7bcd0286.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Land und Wasser.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erhöhen Sie den Wasserstand </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind nicht auf einen Wasserstand beschränkt. </font><font style="vertical-align: inherit;">Machen wir es anpassbar, indem wir ein gemeinsames Feld mit einem Intervall von 1 bis 5 und einem Standardwert von 3 verwenden. </font><font style="vertical-align: inherit;">Verwenden Sie diese Ebene beim Initialisieren der Zellen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 5)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel = <span class="hljs-number"><span class="hljs-number">3</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/9cf/82f/c329cf82f9a847ac01f2754cc3252500.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/c9d/fe4/850c9dfe4694834486bf4be64ac1783a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasserstand 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Wasserstand 3 ist, bekommen wir weniger Land als erwartet. </font><font style="vertical-align: inherit;">Dies liegt daran </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dass </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">immer noch glaubt, dass der Wasserstand 1 ist. Lassen Sie es uns beheben.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung höherer Wasserstände führt dazu. </font><font style="vertical-align: inherit;">dass die Zellen nicht sofort landen. </font><font style="vertical-align: inherit;">Wenn der Wasserstand 2 ist, bleibt der erste Abschnitt immer noch unter Wasser. </font><font style="vertical-align: inherit;">Der Meeresboden ist gestiegen, bleibt aber immer noch unter Wasser. </font><font style="vertical-align: inherit;">Ein Land wird nur am Schnittpunkt von mindestens zwei Abschnitten gebildet. </font><font style="vertical-align: inherit;">Je höher der Wasserstand, desto mehr Standorte müssen überquert werden, um Land zu schaffen. </font><font style="vertical-align: inherit;">Mit steigendem Wasserstand wird das Land daher chaotischer. </font><font style="vertical-align: inherit;">Wenn mehr Grundstücke benötigt werden, ist es außerdem wahrscheinlicher, dass sie sich auf bereits vorhandenem Land kreuzen, wodurch Berge häufiger vorkommen, und flaches Land weniger wahrscheinlich, wie im Fall der Verwendung kleinerer Grundstücke.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c39/f02/abf/c39f02abf2bfa93f01395208da92ae9a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/01f/4e2/5a901f4e2785456e0784f33508be4ede.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/816/cc1/863816cc19c0fd7cbf172905962970d9.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/412/190/fd041219043df072443b00d6799f3946.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wasserstand beträgt 2–5, Sushi immer 50%. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertikale Bewegung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bisher haben wir die Grundstücke jeweils um eine Ebene angehoben, müssen uns aber nicht darauf beschränken. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hohe Standorte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl jeder Abschnitt die Höhe seiner Zellen um eine Ebene erhöht, können Ausschnitte auftreten. </font><font style="vertical-align: inherit;">Dies geschieht, wenn sich die Kanten zweier Abschnitte berühren. </font><font style="vertical-align: inherit;">Dies kann zu isolierten Klippen führen, aber lange Klippenlinien sind selten. </font><font style="vertical-align: inherit;">Wir können die Häufigkeit ihres Auftretens erhöhen, indem wir die Höhe des Diagramms um mehr als einen Schritt erhöhen. </font><font style="vertical-align: inherit;">Dies muss jedoch nur für einen bestimmten Anteil der Websites erfolgen. </font><font style="vertical-align: inherit;">Wenn alle Bereiche hoch ansteigen, ist es sehr schwierig, sich im Gelände zu bewegen. </font><font style="vertical-align: inherit;">Lassen Sie uns diesen Parameter mithilfe eines Wahrscheinlichkeitsfelds mit einem Standardwert von 0,25 anpassbar machen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highRiseProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/485/8d7/cb64858d7531bb31842aebdd49b68304.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahrscheinlichkeit eines starken Anstiegs der Zellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir jede Höhenerhöhung für hohe Bereiche verwenden können, gerät dies schnell außer Kontrolle. </font><font style="vertical-align: inherit;">Der Höhenunterschied 2 erzeugt bereits Klippen, das ist also genug. </font><font style="vertical-align: inherit;">Da Sie eine Höhe überspringen können, die dem Wasserstand entspricht, müssen wir die Art und Weise ändern, in der wir feststellen, ob eine Zelle zu Land geworden ist. </font><font style="vertical-align: inherit;">Wenn es unter dem Wasserspiegel lag und jetzt auf dem gleichen oder einem höheren Niveau liegt, haben wir eine neue Landzelle erstellt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rise = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; current.Elevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b31/8c1/ea5/b318c1ea557ced17d2cb0d9a951bcfc3.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ba/353/78b/4ba35378bc60e74b624e136b90a4a7eb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/8ac/b0a/ea38acb0a5cf12835c2ba177e41d6178.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/018/0df/bd9/0180dfbd9869a0d0e0d5a1712af34fb3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahrscheinlichkeiten eines starken Höhenanstiegs betragen 0,25, 0,50, 0,75 und 1.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Senke das Land </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Land steigt nicht immer, manchmal fällt es. </font><font style="vertical-align: inherit;">Wenn das Land tief genug fällt, füllt es Wasser und es geht verloren. </font><font style="vertical-align: inherit;">Bisher machen wir das nicht. </font><font style="vertical-align: inherit;">Da wir nur die Gebiete nach oben schieben, sieht das Land normalerweise aus wie eine Reihe ziemlich runder Gebiete, die miteinander vermischt sind. </font><font style="vertical-align: inherit;">Wenn wir den Bereich manchmal absenken, erhalten wir unterschiedlichere Formen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/95e/d81/9e495ed818dfffc39e5a238f273c8c5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Große Karte ohne versunkenes Sushi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die Häufigkeit der Landabsenkung mithilfe eines anderen Wahrscheinlichkeitsfelds steuern. </font><font style="vertical-align: inherit;">Da das Absenken Land zerstören kann, sollte die Wahrscheinlichkeit des Absenkens immer geringer sein als die Wahrscheinlichkeit des Anhebens. </font><font style="vertical-align: inherit;">Andernfalls kann es sehr lange dauern, bis der richtige Prozentsatz an Land erreicht ist. </font><font style="vertical-align: inherit;">Verwenden wir daher eine maximale Absenkungswahrscheinlichkeit von 0,4 mit einem Standardwert von 0,2.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.4f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sinkProbability = <span class="hljs-number"><span class="hljs-number">0.2f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/997/e82/a11997e824700a045e9faaedaafeb121.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wahrscheinlichkeit des Absenkens. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Absenken der Site ähnelt dem Anheben mit einigen Unterschieden. </font><font style="vertical-align: inherit;">Daher duplizieren wir die Methode </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ändern ihren Namen in </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anstatt die Größe des Anstiegs zu bestimmen, benötigen wir einen Absenkungswert, der dieselbe Logik verwenden kann. </font><font style="vertical-align: inherit;">Gleichzeitig müssen Vergleiche durchgeführt werden, um zu überprüfen, ob wir die Wasseroberfläche passiert haben. </font><font style="vertical-align: inherit;">Außerdem sind wir beim Absenken des Reliefs nicht auf die Summe der Zellen beschränkt. </font><font style="vertical-align: inherit;">Stattdessen gibt jede verlorene Sushi-Zelle den dafür ausgegebenen Betrag zurück, sodass wir ihn erhöhen und weiterarbeiten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; current.Elevation &lt; waterLevel <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; --budget == 0 ) { // break; budget += 1; } size += 1; … } searchFrontier.Clear(); return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen wir </font><font style="vertical-align: inherit;">bei jeder Iteration im Inneren </font><font style="vertical-align: inherit;">das Land entweder senken oder erhöhen, abhängig von der Wahrscheinlichkeit des Absenkens.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/c5e/762/d6bc5e76274e4aa9c8a692f90fde3646.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/8ae/3e3/c2f8ae3e3a4b814b6ae954d40225149e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/f5d/461/1e3f5d461421feddbb145d4e1d56c000.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33b/39d/462/33b39d462682688fc2a8094556e4fc91.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahrscheinlichkeit eines Abfalls beträgt 0,1, 0,2, 0,3 und 0,4.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Höhe begrenzen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegenwärtig können wir möglicherweise viele Abschnitte überlappen, manchmal mit mehreren Höhenerhöhungen, von denen einige nach unten und dann wieder nach oben gehen können. </font><font style="vertical-align: inherit;">Gleichzeitig können wir sehr hohe und manchmal sehr niedrige Höhen schaffen, insbesondere wenn ein hoher Prozentsatz an Land benötigt wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/c2e/359/f3fc2e359db04b4411f2bcd06b81888b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Riesige Höhen bei 90% Land. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Höhe zu begrenzen, fügen wir ein benutzerdefiniertes Minimum und Maximum hinzu. </font><font style="vertical-align: inherit;">Ein vernünftiges Minimum liegt irgendwo zwischen -4 und 0, und ein akzeptables Maximum kann im Bereich von 6 bis 10 liegen. </font><font style="vertical-align: inherit;">Die Standardwerte sind -2 und 8. Wenn Sie die Karte manuell bearbeiten, liegen sie außerhalb des zulässigen Grenzwerts, sodass Sie den Schieberegler der Benutzeroberfläche des Editors ändern oder unverändert lassen können.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(-4, 0)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMinimum = <span class="hljs-number"><span class="hljs-number">-2</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMaximum = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/20b/efc/bcb20befc496cd2c5bffbc94b0a9d267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimale und maximale Höhe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen wir sicherstellen, dass die Höhe das zulässige Maximum nicht überschreitet. </font><font style="vertical-align: inherit;">Dies kann durch Überprüfen erfolgen, ob die aktuellen Zellen zu hoch sind. </font><font style="vertical-align: inherit;">Wenn ja, überspringen wir sie, ohne die Höhe zu ändern und ihre Nachbarn hinzuzufügen. </font><font style="vertical-align: inherit;">Dies führt dazu, dass Landflächen Gebiete meiden, die eine maximale Höhe erreicht haben, und um sie herum wachsen.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &gt; elevationMaximum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; newElevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen Sie dasselbe in </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber für eine minimale Höhe.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = current.Elevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &lt; elevationMinimum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; newElevation &lt; waterLevel ) { budget += <span class="hljs-number"><span class="hljs-number">1</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/cbe/339/4afcbe339d0d697779ff0649f6c2c125.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begrenzte Höhe mit 90% Land.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erhalt der negativen Höhe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt kann der Speicher- und Ladecode keine negativen Höhen verarbeiten, da die Höhe als Byte gespeichert wird. </font><font style="vertical-align: inherit;">Eine negative Zahl wird beim Speichern in eine große positive Zahl umgewandelt. </font><font style="vertical-align: inherit;">Daher können beim Speichern und Laden der generierten Karte sehr hohe Karten anstelle der ursprünglichen Unterwasserzellen angezeigt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können negative Höhen unterstützen, indem wir sie als Ganzzahl und nicht als Byte speichern. </font><font style="vertical-align: inherit;">Wir müssen jedoch immer noch nicht mehrere Höhenstufen unterstützen. </font><font style="vertical-align: inherit;">Zusätzlich können wir den gespeicherten Wert durch Hinzufügen von 127 versetzen. Dadurch können wir Höhen im Bereich von –127–128 innerhalb eines Bytes korrekt speichern. </font><font style="vertical-align: inherit;">Ändern Sie </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entsprechend.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(elevation + <span class="hljs-number"><span class="hljs-number">127</span></span>)); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir die Art und Weise, wie wir Kartendaten speichern, geändert haben, erhöhen wir sie </font></font><code>SaveLoadMenu.mapFileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">schließlich </font><font style="vertical-align: inherit;">so, dass 127 von den aus Dateien der Version 4 geladenen Höhen abgezogen werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { elevation -= <span class="hljs-number"><span class="hljs-number">127</span></span>; } … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die gleiche Karte neu erstellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir eine Vielzahl von Karten erstellen. </font><font style="vertical-align: inherit;">Bei der Generierung wird jedes neue Ergebnis zufällig sein. </font><font style="vertical-align: inherit;">Mit den Konfigurationsoptionen können wir nur die Eigenschaften der Karte steuern, nicht jedoch die genaueste Form. </font><font style="vertical-align: inherit;">Aber manchmal müssen wir genau dieselbe Karte erneut erstellen. </font><font style="vertical-align: inherit;">Zum Beispiel, um eine schöne Karte mit einem Freund zu teilen oder nach der manuellen Bearbeitung erneut zu beginnen. </font><font style="vertical-align: inherit;">Es ist auch nützlich für den Spieleentwicklungsprozess. Fügen wir diese Funktion hinzu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden von Seed </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Kartengenerierungsprozess unvorhersehbar zu machen, verwenden wir </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um wieder dieselbe pseudozufällige Folge von Zahlen zu erhalten, müssen Sie denselben Startwert verwenden. </font><font style="vertical-align: inherit;">Wir haben bereits zuvor einen ähnlichen Ansatz gewählt </font></font><code>HexMetrics.InitializeHashGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zunächst wird der aktuelle Status des mit einem bestimmten Startwert initialisierten Zahlengenerators gespeichert und anschließend der ursprüngliche Status wiederhergestellt. </font><font style="vertical-align: inherit;">Wir können den gleichen Ansatz für verwenden </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir können uns wieder an den alten Zustand erinnern und ihn nach Abschluss wiederherstellen, um nichts anderes zu stören, was verwendet wird </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; … Random.state = originalRandomState; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes müssen wir den Startwert zur Verfügung stellen, mit dem die letzte Karte generiert wurde. </font><font style="vertical-align: inherit;">Dies erfolgt mithilfe eines gemeinsamen Ganzzahlfelds.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/3b5/538/41d3b553898698698636b6bada081aa6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startwert anzeigen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt brauchen wir den Startwert zum Initialisieren </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um zufällige Karten zu erstellen, müssen Sie einen zufälligen Startwert verwenden. </font><font style="vertical-align: inherit;">Der einfachste Ansatz besteht darin, einen beliebigen Startwert zum Generieren zu verwenden </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Damit der anfängliche Zufallszustand nicht beeinflusst wird, müssen wir dies nach dem Speichern tun.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); Random.InitState(seed); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir nach Abschluss einen zufälligen Zustand wiederherstellen, erhalten wir, wenn wir sofort eine andere Karte generieren, den gleichen Startwert. </font><font style="vertical-align: inherit;">Außerdem wissen wir nicht, wie der anfängliche Zufallszustand initialisiert wurde. </font><font style="vertical-align: inherit;">Obwohl es als willkürlicher Ausgangspunkt dienen kann, benötigen wir daher etwas mehr, um es bei jedem Aufruf zufällig zu ordnen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt verschiedene Möglichkeiten, Zufallszahlengeneratoren zu initialisieren. </font><font style="vertical-align: inherit;">In diesem Fall können Sie einfach mehrere beliebige Werte kombinieren, die über einen weiten Bereich variieren. Das heißt, die Wahrscheinlichkeit, dieselbe Karte erneut zu generieren, ist gering. </font><font style="vertical-align: inherit;">Zum Beispiel verwenden wir die unteren 32 Bits der Systemzeit, ausgedrückt in Zyklen, plus die aktuelle Laufzeit der Anwendung. </font><font style="vertical-align: inherit;">Kombinieren Sie diese Werte mit der bitweisen exklusiven ODER-Verknüpfung, damit das Ergebnis nicht sehr groß ist.</font></font><br><br><pre> <code class="cs hljs"> seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die resultierende Zahl kann negativ sein, was für einen Startwert mit öffentlichem Wert nicht sehr gut aussieht. </font><font style="vertical-align: inherit;">Wir können es streng positiv machen, indem wir eine bitweise Maskierung mit einem maximalen ganzzahligen Wert verwenden, der das Vorzeichenbit zurücksetzt.</font></font><br><br><pre> <code class="cs hljs"> seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; Random.InitState(seed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wiederverwendbarer Samen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir generieren immer noch zufällige Karten, aber jetzt können wir sehen, welcher Startwert für jede von ihnen verwendet wurde. </font><font style="vertical-align: inherit;">Um dieselbe Karte erneut zu erstellen, müssen wir den Generator anweisen, denselben Startwert erneut zu verwenden, anstatt einen neuen zu erstellen. </font><font style="vertical-align: inherit;">Wir werden dies tun, indem wir einen Schalter unter Verwendung eines Booleschen Feldes hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useFixedSeed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/200/4c6/eed/2004c6eed8c2244bdfe660bf477d2fa3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option zur Verwendung eines konstanten Samens. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein konstanter Startwert ausgewählt ist, überspringen wir einfach die Generierung des neuen Startwerts in </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir das Startfeld nicht manuell ändern, ist das Ergebnis wieder dieselbe Karte.</font></font><br><br><pre> <code class="cs hljs"> Random.State originalRandomState = Random.state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!useFixedSeed) { seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.time; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir den Startwert der gewünschten Karte kopieren und irgendwo speichern, um ihn in Zukunft erneut zu generieren. </font><font style="vertical-align: inherit;">Vergessen Sie nicht, dass wir nur dann dieselbe Karte erhalten, wenn wir genau dieselben Generatorparameter verwenden, dh dieselbe Kartengröße sowie alle anderen Konfigurationsoptionen. </font><font style="vertical-align: inherit;">Selbst eine kleine Änderung dieser Wahrscheinlichkeiten kann eine völlig andere Karte erzeugen. </font><font style="vertical-align: inherit;">Daher müssen wir uns zusätzlich zum Startwert alle Einstellungen merken.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/cd2/279/7ffcd2279b4dd882db924d8e1fc61d0e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/486/6db/156/4866db15628d75936b7e19fa4841f2f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Große Karten mit Startwerten 0 und 929396788, Standardparameter. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427003/">https://habr.com/ru/post/de427003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426991/index.html">Startup Digest: 10 bevorstehende IT-Events in Moskau</a></li>
<li><a href="../de426993/index.html">Muss ich C lernen, um zu verstehen, wie ein Computer funktioniert?</a></li>
<li><a href="../de426995/index.html">Recycling schadet sowohl Produkten als auch Mitarbeitern</a></li>
<li><a href="../de426997/index.html">So erstellen Sie benutzerdefinierte Formen mit MaterialShapeDrawable</a></li>
<li><a href="../de426999/index.html">Den Trends folgen oder sich in Richtung RxJava und LiveData bewegen</a></li>
<li><a href="../de427005/index.html">KI-Entwickler - der Beruf der Millionäre?</a></li>
<li><a href="../de427009/index.html">"Gehen" eines Elektrons: Manipulationen mit einer Ladung innerhalb der Struktur ungesättigter Bindungen</a></li>
<li><a href="../de427011/index.html">Meine "Hallo Welt!" auf FPGA oder der nächsten Version von UART</a></li>
<li><a href="../de427013/index.html">Von Angesicht zu Angesicht NeoQUEST-2018: Denken Sie daran, wie es war</a></li>
<li><a href="../de427015/index.html">Warum benötigen kommerzielle intelligente Rechenzentren intelligente PDUs?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>