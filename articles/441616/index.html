<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèôÔ∏è üññüèΩ ‚úäüèø Likbez lanzar√° Istio ü§∞ üéÖüèº üÜñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Isstio service mesh 


 En Namely hemos estado usando Istio durante un a√±o. Luego se fue. Tuvimos una gran ca√≠da en el rendimiento en el cl√∫ster de Ku...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Likbez lanzar√° Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441616/"><p> <a href=""><img src="https://habrastorage.org/webt/sh/m2/ja/shm2jainigjyhqewoqvi4cxdlg0.jpeg"></a> <br>  <em>Isstio service mesh</em> </p><br><p>  En Namely hemos estado usando Istio durante un a√±o.  Luego se fue.  Tuvimos una gran ca√≠da en el rendimiento en el cl√∫ster de Kubernetes, quer√≠amos un rastreo distribuido y tomamos a Istio para ejecutar Jaeger y resolverlo.  La malla de servicio encaja tan bien en nuestra infraestructura que decidimos invertir en esta herramienta. </p><br><p>  Tuve que sufrir, pero lo estudiamos por todas partes.  Esta es la primera publicaci√≥n de una serie donde describir√© c√≥mo Istio se integra con Kubernetes y lo que aprendimos sobre su trabajo.  A veces nos adentramos en la naturaleza t√©cnica, pero no muy lejos.  Adem√°s habr√° m√°s publicaciones. </p><a name="habracut"></a><br><h3 id="chto-takoe-istio">  ¬øQu√© es istio? </h3><br><p>  Istio es una herramienta de configuraci√≥n de malla de servicio.  Lee el estado del cl√∫ster de Kubernetes y actualiza los proxies L7 (HTTP y gRPC), que se implementan como sidecar en los pods de Kubernetes.  Estos sidecar son contenedores de Envoy que leen la configuraci√≥n de la API Istio Pilot (y el servicio gRPC) y enrutan el tr√°fico a trav√©s de ella.  Con el poderoso proxy L7 bajo el cap√≥, podemos usar m√©tricas, trazas, l√≥gica de reintento, disyuntor, equilibrio de carga y despliegues canarios. </p><br><h3 id="nachnem-s-nachala-kubernetes">  Comencemos desde el principio: Kubernetes </h3><br><p> En Kubernetes, creamos con un despliegue o StatefulSet.  O simplemente puede ser "vainilla" debajo sin un controlador de alto nivel.  Entonces Kubernetes hace todo lo posible para mantener el estado deseado: crea pods en el cl√∫ster en el nodo, se asegura de que se inicien y reinicien.  Cuando se crea un under, Kubernetes pasa por el ciclo de vida de la API, se asegura de que cada paso sea exitoso y solo entonces finalmente crea el under en el cl√∫ster. </p><br><p>  Etapas del ciclo de vida de la API: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/dl/dc/t5/dldct5fzrxubc5c1z3zt2m7lchu.png"></a> <br>  <em>Gracias a Banzai Cloud por la imagen genial.</em> </p><br><p>  Uno de los pasos es modificar los webhooks de admisi√≥n.  Esta es una parte separada del ciclo de vida en Kubernetes, donde los recursos se personalizan antes de comprometerse con el repositorio de etcd, la fuente de verdad para la configuraci√≥n de Kubernetes.  Y aqu√≠ Istio hace su magia. </p><br><h3 id="modificiruyuschie-vebhuki-dopuska">  Modificaci√≥n de webhooks de admisi√≥n </h3><br><p> Cuando se crea un sub (a trav√©s de <code>kubectl</code> o <code>Deployment</code> ), pasa por este ciclo de vida, y el acceso modificando webhooks lo cambia antes de lanzarlo al gran mundo. </p><br><p>  Durante la instalaci√≥n de Istio, el inyector istio-sidecar se agrega como un recurso de configuraci√≥n para modificar webhooks: </p><br><pre> <code class="plaintext hljs">$ kubectl get mutatingwebhookconfiguration NAME AGE istio-sidecar-injector 87d</code> </pre> <br><p>  Y la configuraci√≥n: </p><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: labels: app: istio-sidecar-injector chart: sidecarInjectorWebhook-1.0.4 heritage: Tiller name: istio-sidecar-injector webhooks: - clientConfig: caBundle: redacted service: name: istio-sidecar-injector namespace: istio-system path: /inject failurePolicy: Fail name: sidecar-injector.istio.io namespaceSelector: matchLabels: istio-injection: enabled rules: - apiGroups: - "" apiVersions: - v1 operations: - CREATE resources: - pods</code> </pre> <br><p>  Aqu√≠ dice que Kubernetes deber√≠a enviar todos los eventos de creaci√≥n de <code>istio-sidecar-injector</code> al servicio <code>istio-sidecar-injector</code> en el <code>istio-system</code> nombres <code>istio-system</code> si el espacio de nombres tiene <code>istio-injection=enabled</code> .  El inyector incluye dos contenedores m√°s en PodSpec: uno temporal para establecer reglas de proxy y otro para proxy.  El inyector del sidecar inserta estos contenedores de acuerdo con la plantilla del mapa de configuraci√≥n del <code>istio-sidecar-injector</code> del <code>istio-sidecar-injector</code> .  Este proceso tambi√©n se llama sidecaring. </p><br><h3 id="sidecar-pody">  Vainas Sidecar </h3><br><p>  Los sidecar son los trucos de nuestro mago Istio.  Istio hace todo tan ingeniosamente que desde el exterior es simplemente m√°gico, si no conoces los detalles.  Y es √∫til conocerlos si de repente necesita depurar solicitudes de red. </p><br><h3 id="init--i-proksi-konteynery">  Contenedores init y proxy </h3><br><p>  Kubernetes tiene contenedores de inicio temporales √∫nicos que se pueden ejecutar antes que los principales.  Agrupan recursos, migran bases de datos o, como es el caso con Istio, configuran reglas de red. </p><br><p>  Istio usa Envoy para representar todas las solicitudes de env√≠os a lo largo de las rutas deseadas.  Para hacer esto, Istio crea reglas de <code>iptables</code> , y env√≠an el tr√°fico entrante y saliente directamente a Envoy, y el servidor se env√≠a de forma ordenada al destino.  El tr√°fico hace un peque√±o desv√≠o, pero ha distribuido el rastreo, las m√©tricas de consulta y la aplicaci√≥n de pol√≠ticas.  Este archivo <a href="">muestra</a> desde el repositorio de Istio c√≥mo Istio crea las reglas de iptables. </p><br><p>  <a href="">@jimmysongio</a> dibuj√≥ un excelente diagrama de conexi√≥n entre las reglas de iptables y el proxy Envoy: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yl/3m/yc/yl3myca7qv4esodpj8a7iwsp6bc.jpeg"></a> <br>  <em>Enviado - Envoy Traffic</em> </p><br><p>  Envoy recibe todo el tr√°fico entrante y saliente, por lo que todo el tr√°fico generalmente se mueve dentro de Envoy, como en el diagrama.  El proxy de Istio es otro contenedor que se agrega a todos los m√≥dulos modificados por el inyector de sidecar Istio.  En este contenedor, comienza el proceso Envoy, que recibe todo el tr√°fico del hogar (con algunas excepciones, como el tr√°fico de su cl√∫ster de Kubernetes). </p><br><p>  El proceso de Envoy descubre todas las rutas a trav√©s de la API Envoy v2, que implementa Istio. </p><br><h3 id="envoy-i-pilot">  Enviado y piloto </h3><br><p>  El enviado en s√≠ no tiene l√≥gica para detectar pods y servicios en un cl√∫ster.  Es un plano de datos y necesita un plano de control para guiar.  El par√°metro de configuraci√≥n Envoy solicita al host o puerto de servicio que reciba esta configuraci√≥n a trav√©s de la API gRPC.  Istio, a trav√©s de su servicio Piloto, cumple los requisitos para la API gRPC.  Envoy se conecta a esta API en funci√≥n de una configuraci√≥n de sidecar implementada a trav√©s de un webhook modificador.  La API tiene todas las reglas de tr√°fico que Envoy necesita descubrir y enrutar para el cl√∫ster.  Esta es la malla de servicio. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/lr/kn/bz/lrknbzkkjqescnkyh6k1voy_nyk.png"></a> <br>  <em>Intercambio de datos "bajo el piloto &lt;-&gt;"</em> </p><br><p>  Pilot se conecta al cl√∫ster de Kubernetes, lee el estado del cl√∫ster y espera actualizaciones.  Supervisa los hogares, los servicios y los puntos finales en el cl√∫ster de Kubernetes, para luego dar la configuraci√≥n correcta a todos los sidecar de Envoy conectados al Pilot.  Este es el puente entre Kubernetes y Envoy. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fg/no/hj/fgnohjdngxbyn8kj5u_udcvl6x0.png"></a> <br>  <em>De piloto a kubernetes</em> </p><br><p>  Cuando se crean o actualizan pods, servicios o puntos finales en Kubernetes, Pilot se entera de ello y env√≠a la configuraci√≥n necesaria a todas las instancias de Envoy conectadas. </p><br><h3 id="kakaya-konfiguraciya-otpravlyaetsya">  ¬øQu√© configuraci√≥n se est√° enviando? </h3><br><p>  ¬øQu√© configuraci√≥n obtiene el Envoy del Istio Pilot? </p><br><p>  De manera predeterminada, Kubernetes resuelve sus problemas de red con un <code>sevice</code> (servicio) que administra los <code>endpoint</code> .  La lista de puntos finales se puede abrir con el comando: </p><br><pre> <code class="plaintext hljs">kubectl get endpoints</code> </pre> <br><p>  Esta es una lista de todas las direcciones IP y puertos en el cl√∫ster y sus direcciones (generalmente son pods creados a partir de una implementaci√≥n).  Es importante saber Istio para configurar y enviar datos de ruta a Envoy. </p><br><h3 id="servisy-proslushivateli-i-marshruty">  Servicios, oyentes y rutas. </h3><br><p>  Cuando crea un servicio en un cl√∫ster de Kubernetes, incluye accesos directos mediante los cuales se seleccionar√°n todos los pods adecuados.  Cuando env√≠a tr√°fico a la direcci√≥n IP del servicio, Kubernetes selecciona el tr√°fico para este tr√°fico.  Por ejemplo, el comando </p><br><pre> <code class="plaintext hljs">curl my-service.default.svc.cluster.local:3000</code> </pre> <br><p>  primero encontrar√° la IP virtual asignada al <code>my-service</code> en el espacio de nombres <code>default</code> , y esta IP reenviar√° el tr√°fico a un sub que coincida con la etiqueta del servicio. </p><br><p>  Istio y Envoy cambian ligeramente esta l√≥gica.  Istio configura Envoy en funci√≥n de los servicios y puntos finales en el cl√∫ster de Kubernetes y utiliza las funciones de enrutamiento inteligente y equilibrio de carga de Envoy para omitir el servicio de Kubernetes.  En lugar de enviar una IP a la vez, Envoy se conecta directamente al hogar de IP.  <strong>Para hacer esto, Istio asigna la configuraci√≥n de Kubernetes a la configuraci√≥n de Envoy</strong> . </p><br><p>  Los t√©rminos Kubernetes, Istio y Envoy son ligeramente diferentes, y no est√° claro de inmediato qu√© comen. </p><br><h3 id="servisy">  Servicios </h3><br><p>  Un servicio en Kubernetes se asigna a un <strong>cl√∫ster</strong> en Envoy.  El cl√∫ster Envoy contiene una lista de <strong>puntos finales</strong> , es decir, la IP (o nombres de host) de las instancias para procesar solicitudes.  Para ver la lista de cl√∫steres configurados en el sidecar-pod de <code>istioctl proxy-config cluster &lt; &gt;</code> , ejecute <code>istioctl proxy-config cluster &lt; &gt;</code> .  Este comando muestra el estado actual de las cosas en t√©rminos del hogar.  Aqu√≠ hay un ejemplo de uno de nuestros entornos: </p><br><pre> <code class="plaintext hljs">$ istioctl proxy-config cluster taxparams-6777cf899c-wwhr7 -n applications SERVICE FQDN PORT SUBSET DIRECTION TYPE BlackHoleCluster - - - STATIC accounts-grpc-gw.applications.svc.cluster.local 80 - outbound EDS accounts-grpc-public.applications.svc.cluster.local 50051 - outbound EDS addressvalidator.applications.svc.cluster.local 50051 - outbound EDS</code> </pre> <br><p>  Todos los mismos servicios est√°n en este espacio de nombres: </p><br><pre> <code class="plaintext hljs">$ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) accounts-grpc-gw ClusterIP 10.3.0.91 &lt;none&gt; 80/TCP accounts-grpc-public ClusterIP 10.3.0.202 &lt;none&gt; 50051/TCP addressvalidator ClusterIP 10.3.0.56 &lt;none&gt; 50051/TCP</code> </pre> <br><p>  ¬øC√≥mo sabe Istio qu√© protocolo usa el servicio?  Configura protocolos para manifiestos de servicio por el campo de <code>name</code> en la entrada del puerto. </p><br><pre> <code class="plaintext hljs">$ kubectl get service accounts-grpc-public -o yaml apiVersion: v1 kind: Service metadata: name: accounts-grpc-public spec: ports: - name: grpc port: 50051 protocol: TCP targetPort: 50051</code> </pre> <br><p>  Si hay <code>grpc</code> o el prefijo <code>grpc-</code> , Istio configurar√° el protocolo HTTP2 para el servicio.  A trav√©s de la amarga experiencia, aprendimos c√≥mo Istio usa el nombre del puerto cuando las configuraciones de proxy est√°n da√±adas porque no especifican los prefijos http o grpc ... </p><br><p>  Si usa kubectl y la p√°gina de reenv√≠o del puerto de administraci√≥n en Envoy, puede ver que Pilot implementa los puntos finales de cuenta-grpc-public como un cl√∫ster en Envoy con el protocolo HTTP2.  Esto confirma nuestras suposiciones: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward otherpod-dc56885ff-dqc6t 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... - cluster: circuit_breakers: thresholds: - {} connect_timeout: 1s eds_cluster_config: eds_config: ads: {} service_name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local http2_protocol_options: max_concurrent_streams: 1073741824 name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local type: EDS ...</code> </pre> <br><p>  El puerto 15000 es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina de administraci√≥n de Envoy</a> , disponible en todos los sidecar. </p><br><h3 id="proslushivateli">  Oyentes </h3><br><p>  Los oyentes reconocen los puntos finales de Kubernetes para pasar el tr√°fico a los hogares.  El servicio de verificaci√≥n de direcci√≥n tiene un punto final aqu√≠: </p><br><pre> <code class="plaintext hljs">$ kubectl get ep addressvalidator -o yaml apiVersion: v1 kind: Endpoints metadata: name: addressvalidator subsets: - addresses: - ip: 10.2.26.243 nodeName: ip-10-205-35-230.ec2.internal targetRef: kind: Pod name: addressvalidator-64885ccb76-87l4d namespace: applications ports: - name: grpc port: 50051 protocol: TCP</code> </pre> <br><p>  Por lo tanto, el hogar de verificaci√≥n de direcci√≥n tiene un oyente en el puerto 50051: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward addressvalidator-64885ccb76-87l4d 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... dynamic_active_listeners: - version_info: 2019-01-13T18:39:43Z/651 listener: name: 10.2.26.243_50051 address: socket_address: address: 10.2.26.243 port_value: 50051 filter_chains: - filter_chain_match: transport_protocol: raw_buffer ...</code> </pre> <br><h3 id="marshruty">  Rutas </h3><br><p>  En Istio, en lugar del objeto est√°ndar de Kubernetes Ingress, se <code>VirtualService</code> un recurso personalizado m√°s abstracto y eficiente: <code>VirtualService</code> .  VirtualService asigna rutas a cl√∫steres aguas arriba al vincularlas a la puerta de enlace.  As√≠ es como se usa Kubernetes Ingress con un controlador Ingress. </p><br><p>  En Namely, usamos Istio Ingress-Gateway para todo el tr√°fico interno de GRPC: </p><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: grpc-gateway spec: selector: istio: ingressgateway servers: - hosts: - '*' port: name: http2 number: 80 protocol: HTTP2 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: grpc-gateway spec: gateways: - grpc-gateway hosts: - '*' http: - match: - uri: prefix: /namely.address_validator.AddressValidator retries: attempts: 3 perTryTimeout: 2s route: - destination: host: addressvalidator port: number: 50051</code> </pre> <br><p>  A primera vista, no entender√° nada en el ejemplo.  Esto no es visible, pero el despliegue Istio-IngressGateway registra qu√© puntos finales son necesarios en <code>istio: ingressgateway</code> .  En este ejemplo, IngressGateway enruta el tr√°fico para todos los dominios a trav√©s del puerto 80 a trav√©s de HTTP2.  VirtualService implementa rutas para esta puerta de enlace, coincide con el <code>/namely.address_validator.AddressValidator</code> prefijo y pasa el <code>addressvalidator</code> trav√©s del puerto 50051 al servicio ascendente <code>addressvalidator</code> una regla de reintento en dos segundos. </p><br><p>  Si redirigimos el puerto de pod de Istio-IngressGateway y vemos la configuraci√≥n de Envoy, veremos qu√© hace VirtualService: </p><br><pre> <code class="plaintext hljs">$ kubectl -n istio-system port-forward istio-ingressgateway-7477597868-rldb5 15000 ... - match: prefix: /namely.address_validator.AddressValidator route: cluster: outbound|50051||addressvalidator.applications.svc.cluster.local timeout: 0s retry_policy: retry_on: 5xx,connect-failure,refused-stream num_retries: 3 per_try_timeout: 2s max_grpc_timeout: 0s decorator: operation: addressvalidator.applications.svc.cluster.local:50051/namely.address_validator.AddressValidator* ...</code> </pre> <br><h3 id="chto-my-guglili-kopayas-v-istio">  Lo que buscamos en Google mientras cavamos en Istio </h3><br><p>  <strong>Se produce el error 503 o 404</strong> </p><br><p>  Las razones son diferentes, pero generalmente son: </p><br><ul><li>  Las aplicaciones de sidecar no pueden contactar a Pilot (verifique que Pilot est√© funcionando). </li><li>  El manifiesto de servicio de Kubernetes tiene un protocolo no v√°lido. </li><li>  La configuraci√≥n VirtualService / Envoy escribe la ruta al cl√∫ster ascendente incorrecto.  Comience con el servicio perimetral, donde espera tr√°fico entrante, y examine los registros de Envoy.  O use algo como Jaeger para encontrar errores. </li></ul><br><p>  <strong>¬øQu√© significa NR / UH / UF en los registros proxy de Istio?</strong> </p><br><ul><li>  NR - Sin ruta. </li><li>  UH - Upstream Insalubre (inoperable upstream). </li><li>  UF - Falla aguas arriba (falla aguas arriba). </li></ul><br><p>  Lea m√°s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web de Envoy</a> . </p><br><p>  <strong>Sobre alta disponibilidad con Istio</strong> </p><br><ul><li>  Agregue NodeAffinity a los componentes de Istio para distribuir uniformemente los hogares en diferentes zonas de disponibilidad y aumentar el n√∫mero m√≠nimo de r√©plicas. </li><li>  Inicie la nueva versi√≥n de Kubernetes con la funci√≥n Horizontal Pod Autoscaling.  Los hogares m√°s importantes se escalar√°n seg√∫n la carga. </li></ul><br><p>  <strong>¬øPor qu√© no termina el cronjob?</strong> </p><br><p>  Cuando se completa la carga de trabajo principal, el contenedor del sidecar contin√∫a funcionando.  Para evitar el problema, desactive el sidecar en cronjobs agregando la anotaci√≥n <code>sidecar.istio.io/inject: ‚Äúfalse‚Äù</code> a PodSpec. </p><br><p>  <strong>¬øC√≥mo instalar Istio?</strong> </p><br><p>  Usamos Spinnaker para implementaciones, pero usualmente tomamos los √∫ltimos gr√°ficos de Helm, los conjuramos, usamos la <code>helm template -f values.yml</code> y comprometemos archivos en Github para ver los cambios antes de aplicarlos a trav√©s de <code>kubectl apply -f -</code> .  Esto es para no cambiar accidentalmente el CRD o la API en diferentes versiones. </p><br><p>  Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bobby Tables</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Michael Hamrah</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ayudarme</a> a escribir esta publicaci√≥n. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441616/">https://habr.com/ru/post/441616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441600/index.html">IU d√©bil, programador d√©bil</a></li>
<li><a href="../441602/index.html">¬øPor qu√© un autom√≥vil autom√°tico cl√°sico es imposible y no tiene perspectivas comerciales?</a></li>
<li><a href="../441604/index.html">Los sistemas nacionales de vigilancia de China: una fuente no solo de datos, sino tambi√©n de ingresos estables</a></li>
<li><a href="../441606/index.html">Soluciones casi confiables</a></li>
<li><a href="../441608/index.html">Dualidad: un motor f√°cil y r√°pido para igrostroy en Windows (Ext.)</a></li>
<li><a href="../441618/index.html">Creaci√≥n de la barra de navegaci√≥n inferior en Kotlin usando Anko</a></li>
<li><a href="../441626/index.html">Taller sobre impresi√≥n 3D industrial: 1 de marzo en Caliber Technopark</a></li>
<li><a href="../441628/index.html">Calificaci√≥n de empleadores de TI de San Petersburgo y Mosc√∫ 2018: resultados de una encuesta de desarrolladores</a></li>
<li><a href="../441632/index.html">1 de marzo - Teamlead Meetup: evaluaci√≥n y motivaci√≥n de los empleados</a></li>
<li><a href="../441634/index.html">¬øHay vida bajo Windows 98, segunda parte? Acerca del software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>