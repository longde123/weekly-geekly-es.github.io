<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€âš•ï¸ ğŸ˜ ğŸ‘¨ğŸ½â€ğŸŒ¾ Mengapa kita membutuhkan rentang dari C ++ 20 dalam penghancur sederhana? ğŸ• ğŸ‘¼ğŸ¼ ğŸ‘ˆğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, rentang yang harus dimasukkan dalam standar C ++ 20 telah dibahas cukup banyak, termasuk pada HabrÃ© ( contoh di mana ada banyak contoh ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa kita membutuhkan rentang dari C ++ 20 dalam penghancur sederhana?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473844/"><p>  Baru-baru ini, rentang yang harus dimasukkan dalam standar C ++ 20 telah dibahas cukup banyak, termasuk pada HabrÃ© ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh di mana ada banyak contoh</a> ).  Ada cukup banyak kritik tentang interval, kata mereka </p><br><ul><li>  mereka terlalu abstrak dan hanya diperlukan untuk kode yang sangat abstrak </li><li>  keterbacaan kode dengan mereka hanya memburuk </li><li>  interval memperlambat kode </li></ul><br><p>  Mari kita lihat sepenuhnya <del>  buruh-tani </del>  tugas praktis, untuk memahami apakah kritik ini valid <del>  dan apakah benar bahwa Eric Nibler digigit oleh Bartosz Milewski dan menulis range-v3 hanya dengan bulan purnama </del>  . </p><br><p><img src="https://habrastorage.org/webt/pb/dt/ih/pbdtihbl4gn8qiqwr5uk_j8qi0a.png" alt="kdpv"></p><br><p>  Kami akan mengintegrasikan fungsi berikut menggunakan metode trapesium: <math> </math> $ inline $ f (t) = 3 t ^ 2 \ sin t ^ 3 $ inline $   mulai dari nol hingga <math> </math> $ inline $ \ tau $ inline $   .  Jika <math> </math> $ inline $ \ tau ^ 3 / \ pi $ inline $   sama dengan angka ganjil, maka integralnya adalah 2. </p><a name="habracut"></a><br><p> Jadi, masalahnya: kita menulis prototipe fungsi yang menghitung integral <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan metode trapesium</a> .  Sekilas, tampaknya abstraksi tidak diperlukan di sini, tetapi kecepatan itu penting.  Sebenarnya, ini tidak sepenuhnya benar.  Untuk pekerjaan, saya sering harus menulis "penghancur angka", pengguna utamanya adalah saya sendiri.  Jadi saya juga harus mendukung dan menangani bug mereka (sayangnya kolega saya - tidak selalu hanya saya).  Dan itu juga terjadi bahwa beberapa kode tidak digunakan, katakanlah, setahun, dan kemudian ... Secara umum, dokumentasi dan tes juga perlu ditulis. </p><br><p>  Argumen apa yang harus dimiliki fungsi integrator?  Fungsi dan kisi yang terintegrasi (set point <math> </math> $ sebaris $ t_1, t_2, t_3 ... $ sebaris $  digunakan untuk menghitung integral).  Dan jika semuanya jelas dengan fungsi terintegrasi ( <code>std::function</code> akan ada di sini), lalu dalam bentuk apa seharusnya grid ditransmisikan?  Ayo lihat. </p><br><h2 id="varianty">  Opsi </h2><br><p>  Untuk mulai dengan - untuk memiliki sesuatu untuk membandingkan kinerja - kita akan menulis sederhana <code>for</code> loop dengan langkah waktu yang konstan: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// trapezoidal rule of integration with fixed time step; // dt_fixed is the timestep; n_fixed is the number of steps double integrate() { double acc = 0; for(long long i = 1; i &lt; n_fixed - 1; ++i) { double t = dt_fixed * static_cast&lt;double&gt;(i); acc += dt_fixed * f(t); } acc += 0.5 * dt_fixed * f(0); acc += 0.5 * dt_fixed * f(tau); return acc; }</span></span></code> </pre> <br><p>  Saat menggunakan siklus ini, Anda bisa meneruskan argumen ke fungsi awal dan akhir interval integrasi, serta jumlah titik untuk integrasi ini sendiri.  Stop - metode trapesium juga terjadi dengan langkah variabel, dan fungsi integrable kami hanya meminta untuk menggunakan langkah variabel!  Jadi, mari kita punya satu parameter lagi ( <math> </math> $ inline $ b $ inline $   ) untuk mengontrol "nonlinier" dan biarkan langkah-langkah kami, misalnya, sebagai berikut: <math> </math> $ inline $ \ Delta t (t) = \ Delta t_0 + bt $ inline $   .  Pendekatan ini (memperkenalkan satu parameter numerik tambahan) mungkin digunakan di sejuta tempat, meskipun, tampaknya, cacatnya harus jelas bagi semua orang.  Dan apakah kita memiliki fungsi yang berbeda?  Dan jika kita membutuhkan langkah kecil di suatu tempat di tengah interval numerik kita?  Tetapi bagaimana jika fungsi yang dapat diintegrasikan memiliki beberapa fitur?  Secara umum, kita harus dapat menyampaikan grid <em>apa pun</em> .  (Namun demikian, dalam contoh, hingga akhir, kami akan "lupa" tentang metode trapesium yang sebenarnya dan untuk kesederhanaan kami akan mempertimbangkan versinya dengan langkah konstan, dengan mengingat bahwa grid dapat berubah-ubah). </p><br><p>  Karena kisi dapat berupa apa saja, mari berikan nilainya <math> </math> $ inline $ t_1, t_2, ... $ inline $   terbungkus <code>std::vector</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// trapezoidal rule of integration with fixed time step double integrate(vector&lt;double&gt; t_nodes) { double acc = 0; for(auto t: t_nodes) { acc += dt_fixed * f(t); } acc -= 0.5 * dt_fixed * f(0); acc -= 0.5 * dt_fixed * f(tau); return acc; }</span></span></code> </pre> <br><p>  Ada lebih dari cukup komunitas dalam pendekatan ini, tetapi bagaimana dengan kinerja?  Dengan konsumsi memori?  Jika sebelumnya semuanya disimpulkan pada prosesor, sekarang kita harus terlebih dahulu mengisi area memori, dan kemudian membacanya.  Dan komunikasi dengan memori adalah hal yang agak lambat.  Dan memori masih belum karet ( <del>  dan silikon </del>  ) </p><br><p>  Mari kita lihat akar masalahnya.  Apa yang dibutuhkan seseorang untuk bahagia?  Lebih tepatnya, apa yang dibutuhkan siklus kami (berbasis rentang untuk loop)?  Kontainer apa pun dengan iterator <code>begin()</code> dan <code>end()</code> , dan <code>++</code> , <code>*</code> dan <code>!=</code> Operator untuk iterator.  Jadi kita akan menulis. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    ,      template &lt;typename T&gt; double integrate(T t_nodes) { double acc = 0; for(auto t: t_nodes) { acc += dt_fixed * f(t); } acc -= 0.5 * dt_fixed * f(0); acc -= 0.5 * dt_fixed * f(tau); return acc; } // ... //      class lazy_container { public: long long int n_nodes; lazy_container() { n_nodes = n_fixed; } ~lazy_container() {} class iterator { public: long long int i; // index of the current node iterator() { i = 0; } ~iterator() {} iterator&amp; operator++() { i+= 1; return *this; } // ! bool operator!=(const iterator&amp; rhs) const { return i != rhs.i; } double operator* () const { return dt_fixed * static_cast&lt;double&gt;(i); } }; iterator begin() { return iterator(); } iterator end() { iterator it; it.i = n_nodes; return it; } }; // ... //      lazy_container t_nodes; double res = integrate(t_nodes);</span></span></code> </pre> <br><p>  Kami sedang menghitung nilai baru di sini. <math> </math> $ inline $ t_i $ inline $   sesuai permintaan, seperti yang kami lakukan secara sederhana <code>for</code> loop.  Tidak ada akses memori, dan diharapkan kompiler modern akan menyederhanakan kode dengan sangat efisien.  Pada saat yang sama, kode fungsi integrasi tidak banyak berubah, dan masih dapat mencerna <code>std::vector</code> . </p><br><p>  Di mana fleksibilitasnya?  Bahkan, kita sekarang dapat menulis fungsi apa saja di operator <code>++</code> .  Artinya, pendekatan ini memungkinkan, pada kenyataannya, untuk mentransfer fungsi alih-alih parameter numerik tunggal.  Kotak yang dihasilkan dengan cepat dapat berupa apa saja, dan kami juga (mungkin) tidak kehilangan kinerja.  Namun, untuk menulis <code>lazy_container</code> baru setiap saat hanya untuk entah bagaimana mendistorsi grid dengan cara baru tidak terasa seperti itu sama sekali (ini adalah 27 baris yang sama!).  Tentu saja, Anda dapat membuat fungsi yang bertanggung jawab untuk menghasilkan grid sebagai parameter dari fungsi integrasi kami, dan <code>lazy_container</code> juga, yaitu, permisi, enkapsulasi. </p><br><p>  Anda bertanya - lalu ada sesuatu yang salah lagi?  Ya!  Pertama, akan diperlukan untuk secara terpisah mengirimkan jumlah poin untuk integrasi, yang dapat menyebabkan kesalahan.  Kedua, sepeda non-standar yang dibuat harus didukung dan mungkin dikembangkan oleh seseorang.  Sebagai contoh, dapatkah Anda segera membayangkan bagaimana, dengan pendekatan ini, untuk menyusun kombinator untuk fungsi-fungsi di operator <code>++</code> ? </p><br><p>  C ++ selama lebih dari 30 tahun.  Banyak di usia ini sudah memiliki anak, dan C ++ bahkan tidak memiliki wadah / iterator malas standar.  Mimpi buruk!  Tetapi semuanya (dalam arti iterator, bukan anak-anak) akan berubah pada awal tahun depan - standar (mungkin sebagian) akan mencakup perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">range-v3</a> , yang telah dikembangkan oleh Eric Nibler selama beberapa tahun.  Kami akan menggunakan karya buahnya.  Kode mengatakan semuanya untuk dirinya sendiri: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;range/v3/view/iota.hpp&gt; #include &lt;range/v3/view/transform.hpp&gt; //... auto t_nodes = ranges::v3::iota_view(0, n_fixed) | ranges::v3::views::transform( [](long long i){ return dt_fixed * static_cast&lt;double&gt;(i); } ); double res = integrate(t_nodes);</span></span></span></span></code> </pre> <br><p>  Fungsi pengintegrasian tetap sama.  Artinya, hanya 3 baris untuk menyelesaikan masalah kita!  Di sini <code>iota_view(0, n)</code> menghasilkan <em>interval</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">malas</a> (rentang, objek yang merangkum awal dan akhir yang digeneralisasi; rentang lazy adalah tampilan), yang, ketika mengulangi pada setiap langkah, menghitung angka berikutnya dalam rentang [0, n).  Lucu bahwa nama Î¹ (huruf Yunani iota) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">merujuk</a> 50 tahun yang lalu ke bahasa APL.  Tongkat <code>|</code>  memungkinkan Anda untuk menulis pipa pengubah interval, dan <code>transform</code> , pada kenyataannya, adalah pengubah sedemikian rupa sehingga, menggunakan fungsi lambda sederhana, mengubah urutan bilangan bulat menjadi satu rangkaian <math> </math> $ inline $ t_1, t_2, ... $ inline $   .  Semuanya sederhana, seperti pada <del>  dongeng </del>  Haskell. </p><br><p>  Tapi bagaimana cara membuat langkah variabel?  Semuanya sesederhana: </p><br><div class="spoiler">  <b class="spoiler_title">Sedikit matematika</b> <div class="spoiler_text"><p>  Sebagai langkah tetap, kami mengambil sepersepuluh dari periode fungsi kami di dekat batas atas integrasi <math> </math> $ sebaris $ \ Delta t_ {tetap} = 0,1 \ kali 2 \ pi / 3 \ tau ^ 2 $ sebaris $   .  Sekarang langkah akan menjadi variabel: Anda akan melihat bahwa jika Anda melakukannya <math> </math> $ inline $ t_i = \ tau (i / n) ^ {1/3} $ inline $   , (dimana <math> </math> $ inline $ n $ inline $   Apakah jumlah total poin), maka langkahnya adalah <math> </math> $ inline $ \ Delta t (t) \ approx dt_i / di = \ tau ^ 3 / (3 nt ^ 2) $ inline $   , yang merupakan sepersepuluh periode dari fungsi yang dapat diintegrasikan untuk suatu yang diberikan <math> </math> $ inline $ t $ inline $   jika <math> </math> $ inline $ n = \ tau ^ 3 / (0,1 \ kali 2 \ pi) $ inline $   .  Masih untuk "hem" ini ke beberapa partisi yang masuk akal untuk nilai-nilai kecil <math> </math> $ inline $ i $ inline $   . </p></div></div><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;range/v3/view/drop.hpp&gt; #include &lt;range/v3/view/iota.hpp&gt; #include &lt;range/v3/view/transform.hpp&gt; //... // trapezoidal rule of integration; step size is not fixed template &lt;typename T&gt; double integrate(T t_nodes) { double acc = 0; double t_prev = *(t_nodes.begin()); double f_prev = f(t_prev); for (auto t: t_nodes | ranges::v3::views::drop(1)) { double f_curr = f(t); acc += 0.5 * (t - t_prev) * (f_curr + f_prev); t_prev = t; f_prev = f_curr; } return acc; } //... auto step_f = [](long long i) { if (static_cast&lt;double&gt;(i) &lt;= 1 / a) { return pow(2 * M_PI, 1/3.0) * a * static_cast&lt;double&gt;(i); } else { return tau * pow(static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(n), 1/3.0); } }; auto t_nodes = ranges::v3::iota_view(0, n) | ranges::v3::views::transform(step_f); double res = integrate(t_nodes);</span></span></span></span></code> </pre> <br><p>  Pembaca yang penuh perhatian mencatat bahwa dalam contoh kami, langkah variabel memungkinkan kami untuk mengurangi jumlah titik kisi dengan faktor tiga, sementara di samping itu, ada biaya nyata untuk komputasi <math> </math> $ inline $ t_i $ inline $   .  Tetapi jika kita mengambil yang lain <math> </math> $ inline $ f (t) $ inline $   , jumlah poin bisa berubah lebih banyak ... (tapi di sini penulis sudah menjadi malas). </p><br><h2 id="itak-taymingi">  Jadi timing </h2><br><p>  Kami memiliki opsi berikut: </p><br><ul><li>  v1 - loop sederhana </li><li>  v2 - <math> </math> $ inline $ t_i $ inline $   berbaring di <code>std::vector</code> </li><li>  v3 - <code>lazy_container</code> darurat dengan iterator darurat </li><li>  v4 - interval dari C ++ 20 (rentang) </li><li>  v5 - berkisar lagi, tetapi hanya di sini metode trapesium ditulis menggunakan pitch variabel </li></ul><br><p>  Inilah hasilnya (dalam detik) untuk <math> </math> $ inline $ \ tau = (10 \, 000 \, 001 \ kali \ pi) ^ {1/3} $ inline $   , untuk g ++ 8.3.0 dan clang ++ 8.0.0 pada IntelÂ® XeonÂ® CPUÂ® X5550 (jumlah langkah sekitar <math> </math> $ inline $ 1.5 \ kali 10 ^ 8 $ inline $   , kecuali untuk v5, di mana langkah-langkahnya tiga kali lebih sedikit (hasil perhitungan oleh semua metode berbeda dari keduanya dengan tidak lebih dari 0,07): </p><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  v1 </td><td>  v2 </td><td>  v3 </td><td>  v4 </td><td>  v5 </td></tr><tr><td>  g ++ </td><td>  4.7 </td><td>  6.7 </td><td>  4.6 </td><td>  3.7 </td><td>  4.3 </td></tr><tr><td>  dentang ++ </td><td>  5.0 </td><td>  7.2 </td><td>  4.6 </td><td>  4.8 </td><td>  4.1 </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">Bendera ~~ dari kertas berwarna ~~</b> <div class="spoiler_text"><p>  g ++ -O3 -fast-math -std = c ++ 2a -Wall -Wpedantic -I range-v3 / include <br>  dentang ++ -Ofast -std = c ++ 2a -Wall -Wpedantic -I range-v3 / include </p></div></div><br><p>  Secara umum, lalat pergi melintasi lapangan, lalat menemukan koin! </p><br><div class="spoiler">  <b class="spoiler_title">g ++ dalam mode debug</b> <div class="spoiler_text"><p>  Mungkin penting bagi seseorang </p><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  v1 </td><td>  v2 </td><td>  v3 </td><td>  v4 </td><td>  v5 </td></tr><tr><td>  g ++ </td><td>  5.9 </td><td>  17.8 </td><td>  7.2 </td><td>  33.6 </td><td>  14.3 </td></tr></tbody></table></div></div></div><br><h2 id="itog">  Ringkasan </h2><br><p>  Bahkan dalam tugas yang sangat sederhana, rentang ternyata sangat berguna: alih-alih kode dengan iterator buatan sendiri pada 20+ baris, kami menulis 3 baris, sementara tidak memiliki masalah dengan keterbacaan kode atau kinerjanya. </p><br><p>  Tentu saja, jika kami membutuhkan (untuk) kinerja terbaik dalam tes ini, kami harus mendapatkan hasil maksimal dari prosesor dan dari memori dengan menulis kode paralel (atau menulis versi di bawah OpenCL) ... Juga, saya tidak tahu apa yang akan terjadi jika saya menulis rantai pengubah yang sangat panjang.  Apakah mudah untuk men-debug dan membaca pesan kompiler saat menggunakan rentang dalam proyek yang kompleks.  Akan mengumpulkan waktu meningkat.  Saya harap seseorang pernah menulis tentang artikel ini. </p><br><p>  Ketika saya menulis tes ini, saya sendiri tidak tahu apa yang akan terjadi.  Sekarang saya tahu - rentang pasti layak untuk diuji dalam proyek nyata, dalam kondisi di mana Anda bermaksud menggunakannya. </p><br><p><del>  Saya pergi ke pasar untuk membeli samovar. </del></p><br><h3 id="poleznye-ssylki">  Tautan yang bermanfaat </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">range-v3 rumah</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi dan Studi Kasus v3</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode dari artikel ini di github</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar di haskell, untuk perbandingan</a> </p><br><h3 id="blagodarnosti">  Ucapan Terima Kasih </h3><br><p>  Terima kasih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">fadey</a> untuk membantu menulis ini semua! </p><br><h3 id="ps">  PS </h3><br><p>  Saya harap seseorang mengomentari keanehan tersebut: i) Jika Anda mengambil interval integrasi 10 kali lebih kecil, maka pada Xeon saya contoh v2 adalah 10% lebih cepat dari v1, dan v4 tiga kali lebih cepat dari v1.  ii) Kompiler Intel (icc 2019) kadang-kadang dalam contoh ini membuat kode yang dua kali lebih cepat dari kompilasi g ++.  Apakah vektorisasi harus disalahkan?  Bisakah g ++ dipaksa melakukan hal yang sama? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473844/">https://habr.com/ru/post/id473844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473832/index.html">ShIoTiny: Pembaruan dan Pemberitahuan</a></li>
<li><a href="../id473834/index.html">Pemantauan blackbox di jaringan Clos. Laporan Yandex</a></li>
<li><a href="../id473838/index.html">DJI Mavic Mini: quadrocopter lipat paling ringan</a></li>
<li><a href="../id473840/index.html">Streaming video dari perangkat Android melalui aplikasi UDP ke JAVA</a></li>
<li><a href="../id473842/index.html">Oktober Machine Learning dan Intelijen Berita Buatan Intisari</a></li>
<li><a href="../id473846/index.html">Bagaimana mengukur kinerja jaringan blockchain. Metrik kunci</a></li>
<li><a href="../id473848/index.html">c.tech pada HighLoad ++ 2019</a></li>
<li><a href="../id473852/index.html">Pro dan kontra bekerja di malam hari</a></li>
<li><a href="../id473854/index.html">Bagaimana kita mengingat JokerConf terakhir</a></li>
<li><a href="../id473856/index.html">Kemudahan berbahaya yang dengannya Anda bisa menipu kecerdasan buatan militer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>