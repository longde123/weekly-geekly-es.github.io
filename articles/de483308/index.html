<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌱 👼🏿 🚴🏽 VonmoTrade-Experiment. Teil 4: Trading Charts 🐂 📍 🌤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In früheren Artikeln haben wir herausgefunden, wie Handelsaufträge erstellt und verarbeitet werden. Das Thema dieses Artikels wird die Verarbeitung un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VonmoTrade-Experiment. Teil 4: Trading Charts</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483308/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zr/8-/lo/zr8-log_36g9esbbfylm3dffoxm.jpeg"></div><br><p>  In früheren Artikeln haben wir herausgefunden, wie Handelsaufträge erstellt und verarbeitet werden.  Das Thema dieses Artikels wird die Verarbeitung und Speicherung von Informationen sein, die für grafische Werkzeuge der Marktanalyse - Aktiencharts - erforderlich sind. </p><a name="habracut"></a><br><p> Bevor ich anfange, möchte ich einen kleinen Exkurs machen.  Für interne Vonmo-Projekte wird das übliche V + -Wort-Benennungsschema verwendet, das die Funktionen des Projekts am besten beschreibt.  Heute habe ich festgestellt, dass VTrade ein bestehendes Unternehmen ist.  Um Verwirrung zu vermeiden, habe ich das Experiment in VonmoTrade umbenannt. </p><br><p>  Zur Beurteilung der Marktlage reicht ein Auftragsbuch und eine Transaktionshistorie nicht aus.  Wir brauchen ein Tool, mit dem wir die Entwicklung des Marktpreises klar und schnell erkennen können.  Trading-Charts können in zwei Arten unterteilt werden: </p><br><ol><li>  Linear; </li><li>  Intervall </li></ol><br><h2 id="lineynye-grafiki">  Liniendiagramme </h2><br><p>  Der einfachste und verständlichste Zeitplan ohne Vorbereitung.  Zeigt die Abhängigkeit des Preises eines Finanzinstruments von der Zeit an. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/pv/9e/ccpv9ehhldl7a9kgstwuqlr3i-k.png"></div><br><p>  Der Hauptvorteil dieser Art von Graph ist die Einfachheit.  Der Hauptnachteil ergibt sich daraus - geringer Informationsgehalt. </p><br><p>  Wenn das Diagramm auf Rohdaten basiert, wird der Preis des letzten Abschlusses genommen.  In der Regel werden Diagramme jedoch auf der Grundlage aggregierter Daten erstellt.  In diesem Fall wird der Schlusskurs jedes Intervalls genommen.  Da wir alles verwerfen, was in dem Intervall passiert ist, und nur den Schlusskurs des Intervalls nehmen, geht der Informationsgehalt verloren. </p><br><h2 id="razreshenie-grafika">  Grafikauflösung </h2><br><p>  Wenn wir damit beginnen, ein Diagramm auf der Grundlage aller Preisänderungen zu erstellen, das heißt, jede abgeschlossene Transaktion fällt in das Diagramm, ist es für eine Person schwierig, es wahrzunehmen.  Und die für die Bearbeitung und Zustellung eines solchen Zeitplans aufgewendete Energie wird ineffizient eingesetzt. </p><br><p>  Aus diesem Grund werden Daten ausgedünnt, indem die Zeitachse in Intervalle unterteilt und die Preise in diesen Intervallen aggregiert werden. <br>  Auflösung - Die Größe des Elementarintervalls für die Teilung der Zeitachse: Sekunde, Minute, Stunde, Tag usw. </p><br><h2 id="bary">  Bars </h2><br><p>  Beziehen Sie sich auf Intervalldiagramme.  Um den Informationsgehalt zu erhöhen, müssen für jedes Zeitintervall am Anfang und Ende des Intervalls Preisinformationen sowie der Maximal- und Minimalpreis angezeigt werden.  Die grafische Darstellung dieses Sets wird als Balken bezeichnet.  Betrachten Sie das Schema eines Balkens: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i2/23/e5/i223e5nfiik9-cuymwg188cy13e.png"></div><br><p>  Die Reihenfolge der Balken bildet ein Diagramm: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mg/ty/4c/mgty4c0sppe_vpnnf30jqmwul-y.png"></div><br><h2 id="yaponskie-svechi">  Japanische Kerzen </h2><br><p>  Beziehen Sie sich wie Balken auf Intervalldiagramme.  Sie sind der beliebteste Diagrammtyp in der technischen Analyse.  Eine Kerze besteht aus einem schwarzen oder weißen Körper und Schatten: oben und unten.  Manchmal wird ein Schatten Docht genannt.  Der obere und untere Rand des Schattens zeigt die Höchst- und Mindestpreise für den entsprechenden Zeitraum an.  Die Grenzen des Körpers zeigen die Eröffnungs- und Schlusskurse.  Lassen Sie uns eine Kerze zeichnen: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w3/-v/oi/w3-voimkk4ycn2var4jm0c_dubc.png"></div><br><p>  Die Reihenfolge der Kerzen bildet eine Grafik: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/py/d0/5q/pyd05qk3g41ztnw5bsqhumumhxu.png"></div><br><h2 id="ohlcv-notaciya">  OHLCV-Notation </h2><br><p>  Im letzten Artikel haben wir das Datenspeicherschema für das Diagramm in postgresql herausgefunden und eine Tabelle für die Datenquelle erstellt, in der die aggregierten Daten gespeichert werden: </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> df ( t <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, r df_resolution <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-string"><span class="hljs-string">'1m'</span></span>::df_resolution, o <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), h <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), l <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), c <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), v <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> df_pk PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (t, r) )</code> </pre> <br><p>  Felder müssen nicht erklärt werden, außer das Feld r ist die Auflösung der Reihe.  Es gibt Aufzählungen in postgresql. Es ist praktisch, sie zu verwenden, wenn eine Reihe von Werten für ein Feld im Voraus bekannt ist.  Durch die Aufzählungen definieren wir einen neuen Typ für die zulässigen Grafikauflösungen.  Lassen Sie es eine Reihe von einer Minute bis zu einem Monat sein: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> df_resolution <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ENUM (<span class="hljs-string"><span class="hljs-string">'1m'</span></span>, <span class="hljs-string"><span class="hljs-string">'3m'</span></span>, <span class="hljs-string"><span class="hljs-string">'5m'</span></span>, <span class="hljs-string"><span class="hljs-string">'15m'</span></span>, <span class="hljs-string"><span class="hljs-string">'30m'</span></span>, <span class="hljs-string"><span class="hljs-string">'45m'</span></span>, <span class="hljs-string"><span class="hljs-string">'1h'</span></span>, <span class="hljs-string"><span class="hljs-string">'2h'</span></span>, <span class="hljs-string"><span class="hljs-string">'4h'</span></span>, <span class="hljs-string"><span class="hljs-string">'6h'</span></span>, <span class="hljs-string"><span class="hljs-string">'8h'</span></span>, <span class="hljs-string"><span class="hljs-string">'12h'</span></span>, <span class="hljs-string"><span class="hljs-string">'1d'</span></span>, <span class="hljs-string"><span class="hljs-string">'3d'</span></span>, <span class="hljs-string"><span class="hljs-string">'1w'</span></span>, <span class="hljs-string"><span class="hljs-string">'1M'</span></span>);</code> </pre> <br><p>  Es ist wichtig, ein Gleichgewicht zwischen der Leistung des Plattensystems, des Prozessors und den Gesamtbetriebskosten zu finden.  Das System definiert derzeit 16 Auflösungen.  Zwei Lösungen liegen auf der Hand: </p><br><ul><li>  Wir können alle Auflösungen zählen und in der Datenbank speichern.  Diese Option bietet den Vorteil, dass beim Abtasten keine Zeit für die Aggregation von Intervallen aufgewendet wird und alle Daten sofort für die Ausgabe bereit sind.  In einem Monat werden für ein Instrument etwas mehr als 72.000 Datensätze erstellt.  Es sieht einfach und bequem aus, aber eine solche Tabelle ändert sich zu oft, da für jede Preisaktualisierung 16 Einträge in der Tabelle erstellt oder aktualisiert und der Index neu erstellt werden muss.  In postgresql kann zusätzlich ein Problem mit der Garbage Collection auftreten. </li><li>  Eine weitere Option ist das Speichern einer einzelnen Grundauflösung.  Bei der Auswahl einer Basisauflösung müssen die erforderlichen Auflösungen erstellt werden.  Wenn Sie beispielsweise die Minutenauflösung als Basis pro Monat speichern, werden für jedes Instrument 43.000 Datensätze erstellt.  Gegenüber der Vorgängerversion reduziert sich somit das Aufnahme- und Overheadvolumen um 40%.  Die Prozessorlast nimmt jedoch zu. </li></ul><br><p>  Wie oben erwähnt, ist es wichtig, ein Gleichgewicht zu finden.  Daher besteht eine Kompromissoption darin, nicht eine Grundauflösung zu speichern, sondern mehrere: 1 Minute, 1 Stunde, 1 Tag.  Mit diesem System werden monatlich 44,6 Tausend Datensätze für jedes Instrument erstellt.  Die Optimierung der Aufnahmelautstärke beträgt 36%, die Prozessorauslastung ist jedoch akzeptabel.  Um beispielsweise wöchentliche Intervalle zu erstellen, anstatt 10.080 Datensätze bei einer Grundauflösung von einer Minute zu lesen und zu aggregieren, müssen wir von der Festplatte lesen und die Daten von nur 7-Tage-Auflösungen aggregieren. </p><br><h2 id="hranenie-ohlcv">  OHLCV-Lagerung </h2><br><p>  OHLCV ist von Natur aus eine Zeitreihe.  Wie Sie wissen, eignet sich eine relationale Datenbank nicht sehr gut zum Speichern und Verarbeiten solcher Daten.  Um diese Probleme zu lösen, verwendet das Projekt die <a href="https://timescale.com/">Timescale-</a> Erweiterung. </p><br><p>  Timescale verbessert die Leistung von Einfüge- und Aktualisierungsvorgängen, ermöglicht die Konfiguration der Partitionierung und bietet Analysefunktionen, die speziell für die Arbeit mit Zeitreihen optimiert wurden. </p><br><p>  Zum Erstellen und Aktualisieren von Balken benötigen wir nur Standardfunktionen: </p><br><ul><li>  <code>date_trunc('minute' | 'hour' | 'day', transaction_ts)</code> - um den Beginn des Intervalls der Auflösung von Minute, Stunde und Tag zu ermitteln. </li><li>  <code>greatest</code> und <code>least</code> , um die Höchst- und Mindestpreise zu bestimmen. </li></ul><br><p>  Dank der Upsert-API wird nur eine Aktualisierungsanforderung pro Transaktion ausgeführt. <br>  Ich habe diese Art von SQL zum Korrigieren von Marktänderungen in grundlegenden Auflösungen: </p><br><pre> <code class="sql hljs">FOR i IN 1 .. array_upper(storage_resolutions, 1) LOOP resolution = storage_resolutions[i]; IF resolution = '1m' THEN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> DATE_TRUNC(<span class="hljs-string"><span class="hljs-string">'minute'</span></span>, ts) <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bar_start; ELSIF resolution = '1h' THEN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> DATE_TRUNC(<span class="hljs-string"><span class="hljs-string">'hour'</span></span>, ts) <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bar_start; ELSIF resolution = '1d' THEN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> DATE_TRUNC(<span class="hljs-string"><span class="hljs-string">'day'</span></span>, ts) <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bar_start; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">'INSERT INTO %I (t,r,o,h,l,c,v) VALUES (%L,%L,%L::numeric,%L::numeric,%L::numeric,%L::numeric,%L::numeric) ON CONFLICT (t,r) DO UPDATE SET h = GREATEST(%Ih, %L::numeric), l = LEAST(%Il, %L::numeric), c = %L::numeric, v = %Iv + %L::numeric;'</span></span>, df_table, bar_start, resolution, price, price, price, price, volume, df_table, price, df_table, price, price, df_table, volume ); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>;</code> </pre> <br><p>  Für die Abtastung zur Aggregation von Intervallen benötigen wir folgende Funktionen: </p><br><ul><li>  <code>time_bucket</code> - um in Intervalle zu brechen </li><li>  <code>first</code> - um den Eröffnungspreis zu finden - <code>O</code> </li><li>  <code>max</code> - der höchste Preis für das Intervall - <code>H</code> </li><li>  <code>min</code> - der niedrigste Preis pro Intervall - <code>L</code> </li><li>  <code>last</code> - um den Schlusskurs zu finden - <code>C</code> </li><li>  <code>sum</code> - um das Handelsvolumen zu finden - <code>V</code> </li></ul><br><p>  Das einzige Problem, das bei der Verwendung von Timescale <code>time_bucket</code> sind die Einschränkungen der <code>time_bucket</code> Funktion.  Sie können nur in Intervallen von weniger als einem Monat arbeiten.  Um eine monatliche Auflösung zu erstellen, müssen Sie die Standardfunktion <code>date_trunc</code> verwenden. </p><br><h2 id="api">  API </h2><br><p>  Um Charts auf dem Client anzuzeigen, verwenden wir <a href="https://github.com/tradingview/lightweight-charts">Lightweight-Charts</a> von Tradingview.  Die Bibliothek ermöglicht es Ihnen, das Erscheinungsbild der Diagramme vollständig anzupassen und ist bequem zu verwenden.  Ich habe die folgenden Grafiken: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/z1/iq/n2z1iqib3maz5hfa-zvxq6z-smu.png"></div><br><p>  Da der Hauptteil der Interaktion zwischen dem Browser und der Plattform über den Websocket erfolgt, gibt es keine Probleme mit der Interaktivität. </p><br><h2 id="istochnik-dannyh">  Datenquelle </h2><br><p>  Die Datenquelle für die Diagramme (Datenfeed) sollte den erforderlichen Teil der Zeitreihe in der erforderlichen Auflösung zurückgeben.  Gleichzeitig muss der Server die Punkte packen, um Datenverkehr zu sparen und die Verarbeitungszeit auf dem Client zu verkürzen. </p><br><p>  Die Datenfeed-API muss zunächst so gestaltet werden, dass Sie mehrere Diagramme in einer Anforderung anfordern und deren Aktualisierungen abonnieren können.  Dadurch wird die Anzahl der Befehle und Antworten im Kanal verringert. </p><br><p>  Betrachten Sie ein Beispiel für die Anfrage der letzten 50 Minuten nach USDGBP mit einem automatischen Abonnement für Kartenaktualisierungen: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"m"</span></span>:<span class="hljs-string"><span class="hljs-string">"market"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"c"</span></span>:<span class="hljs-string"><span class="hljs-string">"get_chart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"v"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"charts"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"ticker"</span></span>:<span class="hljs-string"><span class="hljs-string">"USDGBP"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resolution"</span></span>:<span class="hljs-string"><span class="hljs-string">"1h"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cnt"</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">"send_updates"</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span> } ] } }</code> </pre> <br><p>  Sie können natürlich eine Reihe von Daten (von, bis) anfordern, aber da das Intervall der einzelnen Balken bekannt ist, erscheint mir die deklarative API, die den Zeitpunkt und die Anzahl der Balken angibt, praktischer. <br>  Der Daten-Feed für diese Anfrage antwortet auf ähnliche Weise: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"m"</span></span>:<span class="hljs-string"><span class="hljs-string">"market"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"c"</span></span>:<span class="hljs-string"><span class="hljs-string">"chart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"v"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"bar_fields"</span></span>:[ <span class="hljs-string"><span class="hljs-string">"t"</span></span>,<span class="hljs-string"><span class="hljs-string">"uts"</span></span>,<span class="hljs-string"><span class="hljs-string">"o"</span></span>,<span class="hljs-string"><span class="hljs-string">"h"</span></span>,<span class="hljs-string"><span class="hljs-string">"l"</span></span>,<span class="hljs-string"><span class="hljs-string">"c"</span></span>,<span class="hljs-string"><span class="hljs-string">"v"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"ticker"</span></span>:<span class="hljs-string"><span class="hljs-string">"USDGBP"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resolution"</span></span>:<span class="hljs-string"><span class="hljs-string">"1h"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bars"</span></span>:[ [ <span class="hljs-string"><span class="hljs-string">"2019-12-13 13:00:00"</span></span>,<span class="hljs-number"><span class="hljs-number">1576242000</span></span>,<span class="hljs-string"><span class="hljs-string">"0.75236800"</span></span>, <span class="hljs-string"><span class="hljs-string">"0.76926400"</span></span>,<span class="hljs-string"><span class="hljs-string">"0.75236800"</span></span>,<span class="hljs-string"><span class="hljs-string">"0.76926400"</span></span>,<span class="hljs-string"><span class="hljs-string">"138.10000000"</span></span> ], .... ] } ] } }</code> </pre> <br><p>  Das Feld bar_fields enthält Informationen zu den Positionen der Elemente.  Weitere Optimierung besteht darin, dieses Feld in der Client-Konfiguration zu platzieren, die es beim Booten vom Server erhält. </p><br><p>  Auf diese Weise erhält der Client den erforderlichen Teil der Verlaufsdaten und erstellt den Anfangszustand des Diagramms.  Wenn sich der Status ändert, erhält er eine Aktualisierung, die nur den letzten Balken betrifft. </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"m"</span></span>:<span class="hljs-string"><span class="hljs-string">"market"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"c"</span></span>:<span class="hljs-string"><span class="hljs-string">"chart_tick"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"v"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"ticker"</span></span>:<span class="hljs-string"><span class="hljs-string">"USDGBP"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resolution"</span></span>:<span class="hljs-string"><span class="hljs-string">"1h"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"v"</span></span>:<span class="hljs-string"><span class="hljs-string">"140.600"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ut"</span></span>:<span class="hljs-number"><span class="hljs-number">1576242000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"t"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-12-13T13:00:00"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"o"</span></span>:<span class="hljs-string"><span class="hljs-string">"0.752368"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"l"</span></span>:<span class="hljs-string"><span class="hljs-string">"0.752368"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"h"</span></span>:<span class="hljs-string"><span class="hljs-string">"0.770531"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"c"</span></span>:<span class="hljs-string"><span class="hljs-string">"0.770531"</span></span> } } }</code> </pre> <br><h2 id="predvaritelnyy-itog">  Vorläufiges Ergebnis </h2><br><p>  Während der gesamten Artikelserie haben wir die Theorie und Praxis des Aufbaus eines Austauschs analysiert.  Es ist Zeit, das System zusammenzustellen. </p><br><p>  Im nächsten Artikel befassen wir uns mit der Entwicklung grafischer Benutzeroberflächen: Service-UI für die Plattformverwaltung und UI für Endbenutzer.  Eine Demoversion von Vonmo Trade wird ebenfalls vorgestellt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483308/">https://habr.com/ru/post/de483308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483284/index.html">Wie ich den Zeitplan analysiert habe</a></li>
<li><a href="../de483290/index.html">Design Thinking im Projektmanagement oder warum braucht ein Projektmanager kreative Techniken?</a></li>
<li><a href="../de483294/index.html">Wir schreiben einen "Taschenrechner". Teil II Gleichungen lösen, in LaTeX rendern, Funktionen auf Superlight beschleunigen</a></li>
<li><a href="../de483298/index.html">Wie man richtig aufhört, damit später ...</a></li>
<li><a href="../de483302/index.html">Erste Schritte mit Google Sheets in Python. Von der Registrierung bis zum Lesen von Daten</a></li>
<li><a href="../de483310/index.html">Erstellen Sie mit pix2pix Linsen für Snapchat</a></li>
<li><a href="../de483312/index.html">Die große Schneeflockentheorie</a></li>
<li><a href="../de483314/index.html">So führen Sie asynchrone Redux-Aktionen mit Redux-Thunk durch</a></li>
<li><a href="../de483316/index.html">Schnelle Einführung in SwiftUI</a></li>
<li><a href="../de483318/index.html">Bot für die Überwachung von Webdiensten in einer halben Stunde: Telegramm + Bash + Cron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>