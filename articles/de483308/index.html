<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå± üëºüèø üö¥üèΩ VonmoTrade-Experiment. Teil 4: Trading Charts üêÇ üìç üå§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In fr√ºheren Artikeln haben wir herausgefunden, wie Handelsauftr√§ge erstellt und verarbeitet werden. Das Thema dieses Artikels wird die Verarbeitung un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VonmoTrade-Experiment. Teil 4: Trading Charts</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483308/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zr/8-/lo/zr8-log_36g9esbbfylm3dffoxm.jpeg"></div><br><p>  In fr√ºheren Artikeln haben wir herausgefunden, wie Handelsauftr√§ge erstellt und verarbeitet werden.  Das Thema dieses Artikels wird die Verarbeitung und Speicherung von Informationen sein, die f√ºr grafische Werkzeuge der Marktanalyse - Aktiencharts - erforderlich sind. </p><a name="habracut"></a><br><p> Bevor ich anfange, m√∂chte ich einen kleinen Exkurs machen.  F√ºr interne Vonmo-Projekte wird das √ºbliche V + -Wort-Benennungsschema verwendet, das die Funktionen des Projekts am besten beschreibt.  Heute habe ich festgestellt, dass VTrade ein bestehendes Unternehmen ist.  Um Verwirrung zu vermeiden, habe ich das Experiment in VonmoTrade umbenannt. </p><br><p>  Zur Beurteilung der Marktlage reicht ein Auftragsbuch und eine Transaktionshistorie nicht aus.  Wir brauchen ein Tool, mit dem wir die Entwicklung des Marktpreises klar und schnell erkennen k√∂nnen.  Trading-Charts k√∂nnen in zwei Arten unterteilt werden: </p><br><ol><li>  Linear; </li><li>  Intervall </li></ol><br><h2 id="lineynye-grafiki">  Liniendiagramme </h2><br><p>  Der einfachste und verst√§ndlichste Zeitplan ohne Vorbereitung.  Zeigt die Abh√§ngigkeit des Preises eines Finanzinstruments von der Zeit an. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/pv/9e/ccpv9ehhldl7a9kgstwuqlr3i-k.png"></div><br><p>  Der Hauptvorteil dieser Art von Graph ist die Einfachheit.  Der Hauptnachteil ergibt sich daraus - geringer Informationsgehalt. </p><br><p>  Wenn das Diagramm auf Rohdaten basiert, wird der Preis des letzten Abschlusses genommen.  In der Regel werden Diagramme jedoch auf der Grundlage aggregierter Daten erstellt.  In diesem Fall wird der Schlusskurs jedes Intervalls genommen.  Da wir alles verwerfen, was in dem Intervall passiert ist, und nur den Schlusskurs des Intervalls nehmen, geht der Informationsgehalt verloren. </p><br><h2 id="razreshenie-grafika">  Grafikaufl√∂sung </h2><br><p>  Wenn wir damit beginnen, ein Diagramm auf der Grundlage aller Preis√§nderungen zu erstellen, das hei√üt, jede abgeschlossene Transaktion f√§llt in das Diagramm, ist es f√ºr eine Person schwierig, es wahrzunehmen.  Und die f√ºr die Bearbeitung und Zustellung eines solchen Zeitplans aufgewendete Energie wird ineffizient eingesetzt. </p><br><p>  Aus diesem Grund werden Daten ausged√ºnnt, indem die Zeitachse in Intervalle unterteilt und die Preise in diesen Intervallen aggregiert werden. <br>  Aufl√∂sung - Die Gr√∂√üe des Elementarintervalls f√ºr die Teilung der Zeitachse: Sekunde, Minute, Stunde, Tag usw. </p><br><h2 id="bary">  Bars </h2><br><p>  Beziehen Sie sich auf Intervalldiagramme.  Um den Informationsgehalt zu erh√∂hen, m√ºssen f√ºr jedes Zeitintervall am Anfang und Ende des Intervalls Preisinformationen sowie der Maximal- und Minimalpreis angezeigt werden.  Die grafische Darstellung dieses Sets wird als Balken bezeichnet.  Betrachten Sie das Schema eines Balkens: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i2/23/e5/i223e5nfiik9-cuymwg188cy13e.png"></div><br><p>  Die Reihenfolge der Balken bildet ein Diagramm: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mg/ty/4c/mgty4c0sppe_vpnnf30jqmwul-y.png"></div><br><h2 id="yaponskie-svechi">  Japanische Kerzen </h2><br><p>  Beziehen Sie sich wie Balken auf Intervalldiagramme.  Sie sind der beliebteste Diagrammtyp in der technischen Analyse.  Eine Kerze besteht aus einem schwarzen oder wei√üen K√∂rper und Schatten: oben und unten.  Manchmal wird ein Schatten Docht genannt.  Der obere und untere Rand des Schattens zeigt die H√∂chst- und Mindestpreise f√ºr den entsprechenden Zeitraum an.  Die Grenzen des K√∂rpers zeigen die Er√∂ffnungs- und Schlusskurse.  Lassen Sie uns eine Kerze zeichnen: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w3/-v/oi/w3-voimkk4ycn2var4jm0c_dubc.png"></div><br><p>  Die Reihenfolge der Kerzen bildet eine Grafik: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/py/d0/5q/pyd05qk3g41ztnw5bsqhumumhxu.png"></div><br><h2 id="ohlcv-notaciya">  OHLCV-Notation </h2><br><p>  Im letzten Artikel haben wir das Datenspeicherschema f√ºr das Diagramm in postgresql herausgefunden und eine Tabelle f√ºr die Datenquelle erstellt, in der die aggregierten Daten gespeichert werden: </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> df ( t <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, r df_resolution <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-string"><span class="hljs-string">'1m'</span></span>::df_resolution, o <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), h <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), l <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), c <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), v <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> df_pk PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (t, r) )</code> </pre> <br><p>  Felder m√ºssen nicht erkl√§rt werden, au√üer das Feld r ist die Aufl√∂sung der Reihe.  Es gibt Aufz√§hlungen in postgresql. Es ist praktisch, sie zu verwenden, wenn eine Reihe von Werten f√ºr ein Feld im Voraus bekannt ist.  Durch die Aufz√§hlungen definieren wir einen neuen Typ f√ºr die zul√§ssigen Grafikaufl√∂sungen.  Lassen Sie es eine Reihe von einer Minute bis zu einem Monat sein: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> df_resolution <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ENUM (<span class="hljs-string"><span class="hljs-string">'1m'</span></span>, <span class="hljs-string"><span class="hljs-string">'3m'</span></span>, <span class="hljs-string"><span class="hljs-string">'5m'</span></span>, <span class="hljs-string"><span class="hljs-string">'15m'</span></span>, <span class="hljs-string"><span class="hljs-string">'30m'</span></span>, <span class="hljs-string"><span class="hljs-string">'45m'</span></span>, <span class="hljs-string"><span class="hljs-string">'1h'</span></span>, <span class="hljs-string"><span class="hljs-string">'2h'</span></span>, <span class="hljs-string"><span class="hljs-string">'4h'</span></span>, <span class="hljs-string"><span class="hljs-string">'6h'</span></span>, <span class="hljs-string"><span class="hljs-string">'8h'</span></span>, <span class="hljs-string"><span class="hljs-string">'12h'</span></span>, <span class="hljs-string"><span class="hljs-string">'1d'</span></span>, <span class="hljs-string"><span class="hljs-string">'3d'</span></span>, <span class="hljs-string"><span class="hljs-string">'1w'</span></span>, <span class="hljs-string"><span class="hljs-string">'1M'</span></span>);</code> </pre> <br><p>  Es ist wichtig, ein Gleichgewicht zwischen der Leistung des Plattensystems, des Prozessors und den Gesamtbetriebskosten zu finden.  Das System definiert derzeit 16 Aufl√∂sungen.  Zwei L√∂sungen liegen auf der Hand: </p><br><ul><li>  Wir k√∂nnen alle Aufl√∂sungen z√§hlen und in der Datenbank speichern.  Diese Option bietet den Vorteil, dass beim Abtasten keine Zeit f√ºr die Aggregation von Intervallen aufgewendet wird und alle Daten sofort f√ºr die Ausgabe bereit sind.  In einem Monat werden f√ºr ein Instrument etwas mehr als 72.000 Datens√§tze erstellt.  Es sieht einfach und bequem aus, aber eine solche Tabelle √§ndert sich zu oft, da f√ºr jede Preisaktualisierung 16 Eintr√§ge in der Tabelle erstellt oder aktualisiert und der Index neu erstellt werden muss.  In postgresql kann zus√§tzlich ein Problem mit der Garbage Collection auftreten. </li><li>  Eine weitere Option ist das Speichern einer einzelnen Grundaufl√∂sung.  Bei der Auswahl einer Basisaufl√∂sung m√ºssen die erforderlichen Aufl√∂sungen erstellt werden.  Wenn Sie beispielsweise die Minutenaufl√∂sung als Basis pro Monat speichern, werden f√ºr jedes Instrument 43.000 Datens√§tze erstellt.  Gegen√ºber der Vorg√§ngerversion reduziert sich somit das Aufnahme- und Overheadvolumen um 40%.  Die Prozessorlast nimmt jedoch zu. </li></ul><br><p>  Wie oben erw√§hnt, ist es wichtig, ein Gleichgewicht zu finden.  Daher besteht eine Kompromissoption darin, nicht eine Grundaufl√∂sung zu speichern, sondern mehrere: 1 Minute, 1 Stunde, 1 Tag.  Mit diesem System werden monatlich 44,6 Tausend Datens√§tze f√ºr jedes Instrument erstellt.  Die Optimierung der Aufnahmelautst√§rke betr√§gt 36%, die Prozessorauslastung ist jedoch akzeptabel.  Um beispielsweise w√∂chentliche Intervalle zu erstellen, anstatt 10.080 Datens√§tze bei einer Grundaufl√∂sung von einer Minute zu lesen und zu aggregieren, m√ºssen wir von der Festplatte lesen und die Daten von nur 7-Tage-Aufl√∂sungen aggregieren. </p><br><h2 id="hranenie-ohlcv">  OHLCV-Lagerung </h2><br><p>  OHLCV ist von Natur aus eine Zeitreihe.  Wie Sie wissen, eignet sich eine relationale Datenbank nicht sehr gut zum Speichern und Verarbeiten solcher Daten.  Um diese Probleme zu l√∂sen, verwendet das Projekt die <a href="https://timescale.com/">Timescale-</a> Erweiterung. </p><br><p>  Timescale verbessert die Leistung von Einf√ºge- und Aktualisierungsvorg√§ngen, erm√∂glicht die Konfiguration der Partitionierung und bietet Analysefunktionen, die speziell f√ºr die Arbeit mit Zeitreihen optimiert wurden. </p><br><p>  Zum Erstellen und Aktualisieren von Balken ben√∂tigen wir nur Standardfunktionen: </p><br><ul><li>  <code>date_trunc('minute' | 'hour' | 'day', transaction_ts)</code> - um den Beginn des Intervalls der Aufl√∂sung von Minute, Stunde und Tag zu ermitteln. </li><li>  <code>greatest</code> und <code>least</code> , um die H√∂chst- und Mindestpreise zu bestimmen. </li></ul><br><p>  Dank der Upsert-API wird nur eine Aktualisierungsanforderung pro Transaktion ausgef√ºhrt. <br>  Ich habe diese Art von SQL zum Korrigieren von Markt√§nderungen in grundlegenden Aufl√∂sungen: </p><br><pre> <code class="sql hljs">FOR i IN 1 .. array_upper(storage_resolutions, 1) LOOP resolution = storage_resolutions[i]; IF resolution = '1m' THEN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> DATE_TRUNC(<span class="hljs-string"><span class="hljs-string">'minute'</span></span>, ts) <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bar_start; ELSIF resolution = '1h' THEN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> DATE_TRUNC(<span class="hljs-string"><span class="hljs-string">'hour'</span></span>, ts) <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bar_start; ELSIF resolution = '1d' THEN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> DATE_TRUNC(<span class="hljs-string"><span class="hljs-string">'day'</span></span>, ts) <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bar_start; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">'INSERT INTO %I (t,r,o,h,l,c,v) VALUES (%L,%L,%L::numeric,%L::numeric,%L::numeric,%L::numeric,%L::numeric) ON CONFLICT (t,r) DO UPDATE SET h = GREATEST(%Ih, %L::numeric), l = LEAST(%Il, %L::numeric), c = %L::numeric, v = %Iv + %L::numeric;'</span></span>, df_table, bar_start, resolution, price, price, price, price, volume, df_table, price, df_table, price, price, df_table, volume ); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>;</code> </pre> <br><p>  F√ºr die Abtastung zur Aggregation von Intervallen ben√∂tigen wir folgende Funktionen: </p><br><ul><li>  <code>time_bucket</code> - um in Intervalle zu brechen </li><li>  <code>first</code> - um den Er√∂ffnungspreis zu finden - <code>O</code> </li><li>  <code>max</code> - der h√∂chste Preis f√ºr das Intervall - <code>H</code> </li><li>  <code>min</code> - der niedrigste Preis pro Intervall - <code>L</code> </li><li>  <code>last</code> - um den Schlusskurs zu finden - <code>C</code> </li><li>  <code>sum</code> - um das Handelsvolumen zu finden - <code>V</code> </li></ul><br><p>  Das einzige Problem, das bei der Verwendung von Timescale <code>time_bucket</code> sind die Einschr√§nkungen der <code>time_bucket</code> Funktion.  Sie k√∂nnen nur in Intervallen von weniger als einem Monat arbeiten.  Um eine monatliche Aufl√∂sung zu erstellen, m√ºssen Sie die Standardfunktion <code>date_trunc</code> verwenden. </p><br><h2 id="api">  API </h2><br><p>  Um Charts auf dem Client anzuzeigen, verwenden wir <a href="https://github.com/tradingview/lightweight-charts">Lightweight-Charts</a> von Tradingview.  Die Bibliothek erm√∂glicht es Ihnen, das Erscheinungsbild der Diagramme vollst√§ndig anzupassen und ist bequem zu verwenden.  Ich habe die folgenden Grafiken: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/z1/iq/n2z1iqib3maz5hfa-zvxq6z-smu.png"></div><br><p>  Da der Hauptteil der Interaktion zwischen dem Browser und der Plattform √ºber den Websocket erfolgt, gibt es keine Probleme mit der Interaktivit√§t. </p><br><h2 id="istochnik-dannyh">  Datenquelle </h2><br><p>  Die Datenquelle f√ºr die Diagramme (Datenfeed) sollte den erforderlichen Teil der Zeitreihe in der erforderlichen Aufl√∂sung zur√ºckgeben.  Gleichzeitig muss der Server die Punkte packen, um Datenverkehr zu sparen und die Verarbeitungszeit auf dem Client zu verk√ºrzen. </p><br><p>  Die Datenfeed-API muss zun√§chst so gestaltet werden, dass Sie mehrere Diagramme in einer Anforderung anfordern und deren Aktualisierungen abonnieren k√∂nnen.  Dadurch wird die Anzahl der Befehle und Antworten im Kanal verringert. </p><br><p>  Betrachten Sie ein Beispiel f√ºr die Anfrage der letzten 50 Minuten nach USDGBP mit einem automatischen Abonnement f√ºr Kartenaktualisierungen: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"m"</span></span>:<span class="hljs-string"><span class="hljs-string">"market"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"c"</span></span>:<span class="hljs-string"><span class="hljs-string">"get_chart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"v"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"charts"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"ticker"</span></span>:<span class="hljs-string"><span class="hljs-string">"USDGBP"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resolution"</span></span>:<span class="hljs-string"><span class="hljs-string">"1h"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cnt"</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">"send_updates"</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span> } ] } }</code> </pre> <br><p>  Sie k√∂nnen nat√ºrlich eine Reihe von Daten (von, bis) anfordern, aber da das Intervall der einzelnen Balken bekannt ist, erscheint mir die deklarative API, die den Zeitpunkt und die Anzahl der Balken angibt, praktischer. <br>  Der Daten-Feed f√ºr diese Anfrage antwortet auf √§hnliche Weise: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"m"</span></span>:<span class="hljs-string"><span class="hljs-string">"market"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"c"</span></span>:<span class="hljs-string"><span class="hljs-string">"chart"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"v"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"bar_fields"</span></span>:[ <span class="hljs-string"><span class="hljs-string">"t"</span></span>,<span class="hljs-string"><span class="hljs-string">"uts"</span></span>,<span class="hljs-string"><span class="hljs-string">"o"</span></span>,<span class="hljs-string"><span class="hljs-string">"h"</span></span>,<span class="hljs-string"><span class="hljs-string">"l"</span></span>,<span class="hljs-string"><span class="hljs-string">"c"</span></span>,<span class="hljs-string"><span class="hljs-string">"v"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"ticker"</span></span>:<span class="hljs-string"><span class="hljs-string">"USDGBP"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resolution"</span></span>:<span class="hljs-string"><span class="hljs-string">"1h"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bars"</span></span>:[ [ <span class="hljs-string"><span class="hljs-string">"2019-12-13 13:00:00"</span></span>,<span class="hljs-number"><span class="hljs-number">1576242000</span></span>,<span class="hljs-string"><span class="hljs-string">"0.75236800"</span></span>, <span class="hljs-string"><span class="hljs-string">"0.76926400"</span></span>,<span class="hljs-string"><span class="hljs-string">"0.75236800"</span></span>,<span class="hljs-string"><span class="hljs-string">"0.76926400"</span></span>,<span class="hljs-string"><span class="hljs-string">"138.10000000"</span></span> ], .... ] } ] } }</code> </pre> <br><p>  Das Feld bar_fields enth√§lt Informationen zu den Positionen der Elemente.  Weitere Optimierung besteht darin, dieses Feld in der Client-Konfiguration zu platzieren, die es beim Booten vom Server erh√§lt. </p><br><p>  Auf diese Weise erh√§lt der Client den erforderlichen Teil der Verlaufsdaten und erstellt den Anfangszustand des Diagramms.  Wenn sich der Status √§ndert, erh√§lt er eine Aktualisierung, die nur den letzten Balken betrifft. </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"m"</span></span>:<span class="hljs-string"><span class="hljs-string">"market"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"c"</span></span>:<span class="hljs-string"><span class="hljs-string">"chart_tick"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"v"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"ticker"</span></span>:<span class="hljs-string"><span class="hljs-string">"USDGBP"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resolution"</span></span>:<span class="hljs-string"><span class="hljs-string">"1h"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"v"</span></span>:<span class="hljs-string"><span class="hljs-string">"140.600"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ut"</span></span>:<span class="hljs-number"><span class="hljs-number">1576242000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"t"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-12-13T13:00:00"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"o"</span></span>:<span class="hljs-string"><span class="hljs-string">"0.752368"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"l"</span></span>:<span class="hljs-string"><span class="hljs-string">"0.752368"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"h"</span></span>:<span class="hljs-string"><span class="hljs-string">"0.770531"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"c"</span></span>:<span class="hljs-string"><span class="hljs-string">"0.770531"</span></span> } } }</code> </pre> <br><h2 id="predvaritelnyy-itog">  Vorl√§ufiges Ergebnis </h2><br><p>  W√§hrend der gesamten Artikelserie haben wir die Theorie und Praxis des Aufbaus eines Austauschs analysiert.  Es ist Zeit, das System zusammenzustellen. </p><br><p>  Im n√§chsten Artikel befassen wir uns mit der Entwicklung grafischer Benutzeroberfl√§chen: Service-UI f√ºr die Plattformverwaltung und UI f√ºr Endbenutzer.  Eine Demoversion von Vonmo Trade wird ebenfalls vorgestellt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483308/">https://habr.com/ru/post/de483308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483284/index.html">Wie ich den Zeitplan analysiert habe</a></li>
<li><a href="../de483290/index.html">Design Thinking im Projektmanagement oder warum braucht ein Projektmanager kreative Techniken?</a></li>
<li><a href="../de483294/index.html">Wir schreiben einen "Taschenrechner". Teil II Gleichungen l√∂sen, in LaTeX rendern, Funktionen auf Superlight beschleunigen</a></li>
<li><a href="../de483298/index.html">Wie man richtig aufh√∂rt, damit sp√§ter ...</a></li>
<li><a href="../de483302/index.html">Erste Schritte mit Google Sheets in Python. Von der Registrierung bis zum Lesen von Daten</a></li>
<li><a href="../de483310/index.html">Erstellen Sie mit pix2pix Linsen f√ºr Snapchat</a></li>
<li><a href="../de483312/index.html">Die gro√üe Schneeflockentheorie</a></li>
<li><a href="../de483314/index.html">So f√ºhren Sie asynchrone Redux-Aktionen mit Redux-Thunk durch</a></li>
<li><a href="../de483316/index.html">Schnelle Einf√ºhrung in SwiftUI</a></li>
<li><a href="../de483318/index.html">Bot f√ºr die √úberwachung von Webdiensten in einer halben Stunde: Telegramm + Bash + Cron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>