<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😋 🔷 🏂🏻 Nous préparons un jeu dev. Partie 1 👨‍🍳 👩🏻‍🤝‍👨🏼 🔟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 
 L'histoire a commencé avec un hackathon basé sur la blockchain. Au début de l'événement, j'ai rencontré un homme qui crée des jeux de s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous préparons un jeu dev. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451458/"><img src="https://habrastorage.org/webt/kj/iq/cp/kjiqcpn8xsrxhus_hsclhpi9w_w.jpeg" align="left"><h2>  <font color="#292e5b">Présentation</font> </h2><br>  L'histoire a commencé avec un hackathon basé sur la blockchain.  Au début de l'événement, j'ai rencontré un homme qui crée des jeux de société comme passe-temps (j'étais sur le test d'un de ces jeux), nous nous sommes associés et avons trouvé une équipe avec laquelle ils ont «aveuglé» un simple jeu stratégique au cours du week-end.  Le hackathon est passé, mais l'enthousiasme est resté.  Et nous avons eu l'idée d'un jeu de cartes multijoueur sur le bonheur, la communauté mondiale et les élections. <br><br>  Dans la série d'articles, nous refléterons notre chemin vers la création d'un jeu, avec une description du rake sur lequel nous avons déjà marché et nous avancerons à mesure que nous progressons. <br clear="all">  Sous la coupe sera: <br><br><ul><li>  Résumé du jeu </li><li>  Comment la décision a été prise sur quoi faire backend.  Où va-t-il «vivre» pour ne pas payer pour cela au stade de développement </li><li>  Premières étapes du développement - authentification des joueurs et organisation du matchmaking </li><li>  Plans supplémentaires </li></ul><a name="habracut"></a><br><h2>  <font color="#292e5b">Quel est le jeu</font> </h2><br>  L'humanité est fatiguée des guerres mondiales, de l'épuisement des ressources et de la concurrence constante.  Les factions clés ont convenu d'utiliser la technologie moderne pour sélectionner une seule direction.  À l'heure fixée, l'électorat mondial doit décider du choix d'une fraction qui gouvernera la planète pour le prochain millénaire.  Les factions clés s'engagent dans une lutte de pouvoir «honnête».  Dans une session de jeu, chaque joueur représente une fraction. <br><br>  Ce jeu de cartes concerne les élections.  Chaque faction a un budget pour mener la course aux élections, des sources de revenus augmentant le budget et commençant les votes.  Au début du jeu, le jeu de cartes d'action est mélangé et 4 cartes sont délivrées à chaque participant.  Chaque tour, les joueurs peuvent effectuer jusqu'à deux actions de jeu.  Pour utiliser la carte, le joueur la met sur la table et, si nécessaire, désigne l'objectif et déduit du budget le coût d'utilisation de la carte.  Après la fin du tour, le joueur ne peut conserver qu'une seule des cartes inutilisées.  Au début de chaque tour, les joueurs reçoivent des cartes du jeu, de sorte qu'au début de chaque tour, chaque joueur a 4 cartes action en main. <br><br>  À la fin des tours 3, 6 et 9, le joueur avec le moins de votes est retiré du jeu.  Si plusieurs joueurs ont le même nombre minimum de votes, alors tous les joueurs avec ce résultat sont éliminés du jeu.  Les voix de ces joueurs vont au pool général de l'électorat. <br><br>  À la fin du tour 12, le vainqueur est celui qui a le plus de votes. <br><br><h2>  <font color="#292e5b">Choisir un outil pour le backend</font> </h2><br>  De la description du jeu suit: <br><br><ol><li>  C'est multijoueur </li><li>  Il faut en quelque sorte identifier les joueurs et gérer les comptes </li><li>  La présence d'une composante sociale bénéficierait au jeu - amis, communautés (clans), chats, réalisations (réalisations) </li><li>  Des classements et des fonctionnalités de matchmaking seront nécessaires. </li><li>  La fonctionnalité de gestion des tournois sera utile à l'avenir </li><li>  Étant donné que le jeu est un jeu de cartes, vous devez gérer le catalogue de cartes, vous devrez peut-être stocker les cartes disponibles pour le joueur et les decks compilés </li><li>  À l'avenir, une économie dans le jeu pourrait être nécessaire, y compris de la monnaie dans le jeu, l'échange de biens virtuels (cartes) </li></ol><br>  En regardant la liste des besoins, je suis immédiatement arrivé à la conclusion que créer mon propre backend au stade initial n'a pas de sens et je suis allé sur google quelles sont les autres options.  J'ai donc découvert qu'il existe des backends de jeux cloud spécialisés, parmi lesquels PlayFab (acheté par Microsoft) et GameSparks (acheté par Amazon) se démarquent. <br><br>  En général, ils sont fonctionnellement similaires et couvrent les besoins de base.  De plus, leur architecture interne est très différente, les mêmes tâches sont résolues un peu différemment et les correspondances explicites dans les fonctionnalités sont difficiles à tracer.  Vous trouverez ci-dessous les caractéristiques positives et négatives de chaque plate-forme et des considérations sur le sujet de choix. <br><br><h3>  <font color="#9cc2ce">Playfab</font> </h3><br>  Caractéristiques positives: <br><br><ul><li>  Les comptes de différents jeux sont combinés en un compte principal </li><li>  L'économie du jeu est décrite sans une seule ligne de code, y compris les prix vers un magasin virtuel séparé </li><li>  Interface utilisateur conviviale </li><li>  Microsoft acquiert un produit après son acquisition </li><li>  Le coût de possession en production par abonnement Indie Studio est de 99 $ (jusqu'à 100k MAU), lors du passage à Professional, un abonnement de 1k MAU coûtera 8 $ (compte minimum 300 $) </li></ul><br>  Caractéristiques négatives: <br><br><ul><li>  Le stockage des données de jeu est strictement limité, par exemple, dans un abonnement gratuit pour stocker des données pour une session de jeu spécifique (si je comprends bien, des groupes d'entités sont utilisés pour cela) 3 emplacements de 500 octets chacun sont disponibles </li><li>  Pour organiser le multijoueur, vous devez connecter des serveurs tiers qui traiteront les événements des clients et calculeront la logique du jeu.  Il s'agit de Photon sur votre matériel ou d'Azure Thunderhead, et vous devez non seulement organiser le serveur, mais également mettre à niveau votre abonnement vers au moins Indie Studio </li><li>  Il est nécessaire de supporter le fait que le code cloud sans saisie semi-automatique et il n'y a aucun moyen de se diviser en modules (ou ne pas trouver?) </li><li>  Il n'y a pas de débogueur normal, vous pouvez uniquement écrire des journaux dans CloudScript et afficher </li></ul><br><h3>  <font color="#9cc2ce">Gamesparks</font> </h3><br>  Caractéristiques positives: <br><br><ul><li>  Stockage des données du jeu.  Non seulement il existe de nombreux endroits où vous pouvez enregistrer des données (métadonnées générales de jeu, biens virtuels, profil de joueur, sessions multijoueurs, etc.), la plate-forme fournit également une base de données à part entière en tant que service qui n'est attachée à rien, de plus, MongoDB et Redis sont disponibles immédiatement pour différents types de données.  Dans l'environnement de développement, vous pouvez stocker 10 Mo, dans la bataille 10 Go </li><li>  Le multijoueur est disponible dans un abonnement gratuit (développement) avec une limite de 10 connexions simultanées et 10 requêtes par seconde </li><li>  Travail pratique avec CloudCode, y compris un outil intégré pour tester et déboguer (Test Harness) </li></ul><br>  Caractéristiques négatives: <br><br><ul><li>  Le sentiment que depuis l'achat par Amazon (hiver 2018) l'outil stagne, il n'y a pas d'innovations </li><li>  Encore une fois, après l'acquisition d'Amazon, les tarifs ont empiré; auparavant, il était possible d'utiliser jusqu'à 10000 MAU en production gratuitement </li><li>  Le coût de possession de production commence à 300 $ (abonnement standard) </li></ul><br><h3>  <font color="#9cc2ce">Réflexions</font> </h3><br>  Vous devez d'abord vérifier le concept du jeu.  Pour ce faire, je veux construire un prototype de bâtons et de scotch sans investissements monétaires et commencer à tester les mécanismes de jeu.  Par conséquent, en premier lieu lors du choix, je profite de l'occasion pour développer et tester un mécanicien sur un abonnement gratuit. <br>  GameSparks satisfait à ce critère, mais PlayFab ne le fait pas, car vous aurez besoin d'un serveur qui gérera les événements des clients de jeu et d'un abonnement Indie studio (99 $). <br><br>  Dans le même temps, j'accepte le risque qu'Amazon ne développe pas de GameSparks, ce qui signifie qu'il peut «mourir».  Compte tenu de cela et toujours du coût de possession en production, j'ai à l'esprit la nécessité potentielle de passer soit à une autre plateforme soit à mon propre backend. <br><br><h2>  <font color="#292e5b">Premières étapes de développement</font> </h2><br><h3>  <font color="#9cc2ce">Connexion et authentification</font> </h3><br>  Ainsi, le choix s'est porté sur GameSparks en tant que backend au stade du prototypage.  La première étape consiste à apprendre à se connecter à la plateforme et à authentifier le joueur.  Un point important est que l'utilisateur doit pouvoir jouer sans inscription ni SMS immédiatement après l'installation du jeu.  Pour ce faire, GameSparks offre la possibilité de créer un profil anonyme en appelant la méthode DeviceAuthenticationRequest, plus tard sur la base d'un profil anonyme, vous pouvez en créer un à part entière en vous connectant, par exemple, avec votre compte Google. <br><br>  Étant donné que j'ai un cerveau TDD, j'ai commencé par créer un test pour connecter le client au jeu.  Puisqu'à l'avenir, CloudCode devra être écrit en JS, je ferai des tests d'intégration en JS en utilisant mocha.js et chai.js.  Le premier test s'est avéré comme ceci: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"chai"</span></span>).expect; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameClientModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../src/gameClient"</span></span>); describe(<span class="hljs-string"><span class="hljs-string">"Integration test"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timeout(<span class="hljs-number"><span class="hljs-number">0</span></span>); it(<span class="hljs-string"><span class="hljs-string">"should connect client to server"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient.connected()).is.false; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient.connect(); expect(gameClient.connected()).is.true; }); })</code> </pre> <br>  Par défaut, le délai d'attente dans mocha.js est de 2 secondes, je le fais immédiatement sans fin, car les tests sont l'intégration.  Dans le test, je crée un client de jeu qui n'a pas encore été implémenté, vérifie qu'il n'y a pas de connexion au serveur, appelle la commande pour se connecter au backend et vérifie que le client s'est correctement connecté. <br><br>  Pour que le test devienne vert, vous devez télécharger et ajouter le SDK GameSparks JS au projet, ainsi que connecter ses dépendances (crypto-js et ws), et, bien sûr, implémenter GameClientModule: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameSparks = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../gamesparks-javascript-sdk-2018-04-18/gamesparks-functions"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./config.json"</span></span>); exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gamesparks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameSparks(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (gamesparks.connected === <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.initPreview({ <span class="hljs-attr"><span class="hljs-attr">key</span></span>: config.gameApiKey, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: config.credentialSecret, <span class="hljs-attr"><span class="hljs-attr">credential</span></span>: config.credential, <span class="hljs-attr"><span class="hljs-attr">onInit</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(), <span class="hljs-attr"><span class="hljs-attr">onMessage</span></span>: onMessage, <span class="hljs-attr"><span class="hljs-attr">onError</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(error), <span class="hljs-attr"><span class="hljs-attr">logger</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } }</code> </pre><br>  Au démarrage de l'implémentation du client de jeu, les clés nécessaires à l'autorisation technique pour créer une connexion à partir de l'application client sont lues dans la configuration.  La méthode connectée enveloppe le même champ à partir du SDK.  La chose la plus importante se produit dans la méthode connect, elle renvoie une promesse avec des rappels pour une connexion réussie ou une erreur, lie également le gestionnaire onMessage au même rappel.  onMessage agira en tant que gestionnaire de traitement des messages depuis le backend, pour l'instant laissez-le enregistrer les messages sur la console. <br><br>  Il semblerait que le travail soit terminé, mais le test reste rouge.  Il s'avère que le SDK GameSparks JS ne fonctionne pas avec node.js; pour lui, vous voyez, il manque le contexte du navigateur.  Faisons-lui penser que le nœud est Chrome sur le coquelicot.  Nous allons sur gamesparks.js et au tout début nous ajoutons: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports) { <span class="hljs-comment"><span class="hljs-comment">// node.js var navigator = { userAgent: "Chrome/73.0.3683.103", vendor: "Google Inc.", platform: "Mac" }; var window = {}; window.setInterval = setInterval; // &lt;&lt;&lt;   KeepAlive  }</span></span></code> </pre><br>  Le test est devenu vert, passant à autre chose. <br><br>  Comme je l'ai écrit plus tôt, un joueur devrait pouvoir commencer à jouer immédiatement dès qu'il entre dans le jeu, alors que je veux commencer à accumuler des analyses en activité.  Pour ce faire, nous nous lions soit à l'identifiant de l'appareil, soit à un identifiant généré aléatoirement.  Vérifiez que ce sera un tel test: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should auth two anonymous players"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient1.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient2.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"111"</span></span>); expect(gameClient1.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f5614031f5bc44d59b6a9"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"222"</span></span>); expect(gameClient2.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f6ddb031f5bc44d59b741"</span></span>); });</code> </pre><br>  J'ai décidé de vérifier immédiatement 2 clients afin de m'assurer que chaque client crée son propre profil sur le backend.  Pour ce faire, le client du jeu aura besoin d'une méthode dans laquelle vous pouvez transférer un certain identifiant externe à GameSparks, puis vérifier que le client a contacté le profil de joueur souhaité.  Profils préparés à l'avance sur le portail GameSparks. <br><br>  Pour l'implémentation dans GameClient, ajoutez: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authWithCustomId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">customId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestData = { <span class="hljs-string"><span class="hljs-string">"deviceId"</span></span>: customId , <span class="hljs-string"><span class="hljs-string">"deviceOS"</span></span>: <span class="hljs-string"><span class="hljs-string">"NodeJS"</span></span> } sendRequest(<span class="hljs-string"><span class="hljs-string">"DeviceAuthenticationRequest"</span></span>, requestData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.userId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = response.userId; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">requestType, requestData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.sendWithData(requestType, requestData, (response) =&gt; resolve(response)); }); }</code> </pre><br>  La mise en œuvre revient à envoyer une demande DeviceAuthenticationRequest, à recevoir l'identifiant du joueur de la réponse et à le placer dans la propriété du client.  Immédiatement, dans une méthode distincte, l'aide a envoyé des demandes à GameSparks avec un wrapper dans une promis. <br><br>  Les deux tests sont verts, il reste à ajouter la fermeture de la connexion et le refactor. <br>  Dans GameClient, j'ai ajouté une méthode qui ferme la connexion au serveur (déconnecter) et connectAsAnonymous combinant connect et authWithCustomId.  D'une part, connectAsAnonymous viole le principe de la responsabilité unique, mais ne semble pas violer ... En même temps, il ajoute la convivialité, car dans les tests, il sera souvent nécessaire d'authentifier les clients.  Qu'en pensez-vous? <br><br>  Dans les tests, il a ajouté un assistant de méthode d'usine qui crée une nouvelle instance du client de jeu et ajoute au tableau des clients créés.  Dans le gestionnaire mocha spécial, après chaque test en cours d'exécution pour les clients du tableau, j'appelle la méthode de déconnexion et efface ce tableau.  Je n'aime pas encore les "chaînes magiques" dans le code, j'ai donc ajouté un dictionnaire avec des identifiants personnalisés utilisés dans les tests. <br><br>  Le code final peut être consulté dans le référentiel, un lien auquel je donnerai à la fin de l'article. <br><br><h3>  <font color="#9cc2ce">Organisation de recherche de jeux (matchmaking)</font> </h3><br>  Je vais lancer la fonction de matchmaking, qui est très importante pour le multijoueur.  Ce système commence à fonctionner lorsque nous appuyons sur le bouton «Rechercher un jeu» dans le jeu.  Elle prend des rivaux, des coéquipiers, ou les deux (selon le jeu).  En règle générale, dans de tels systèmes, chaque joueur a un indicateur numérique MMR (Match Making Ratio) - une évaluation personnelle du joueur, qui est utilisée pour sélectionner d'autres joueurs avec le même niveau de compétence. <br><br>  Pour tester cette fonctionnalité, j'ai proposé le test suivant: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should find match"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient3 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connectAsAnonymous(playerCustomIds.id1); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connectAsAnonymous(playerCustomIds.id2); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.connectAsAnonymous(playerCustomIds.id3); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.findStandardMatch(); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.findStandardMatch(); expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.findStandardMatch(); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sleep(<span class="hljs-number"><span class="hljs-number">3000</span></span>); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient1.challenge, <span class="hljs-string"><span class="hljs-string">"challenge"</span></span>).is.not.undefined; expect(gameClient1.challenge.challengeId).is.not.undefined; expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient2.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient3.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); });</code> </pre><br>  Trois clients sont connectés au jeu (à l'avenir, c'est un minimum nécessaire pour vérifier certains scénarios) et sont enregistrés pour rechercher le jeu.  Après avoir enregistré le 3ème joueur sur le serveur, une session de jeu est formée et les joueurs doivent s'y connecter.  En même temps, l'état des clients change et le contexte de la session de jeu avec le même identifiant apparaît. <br><br>  Tout d'abord, préparez le backend.  Dans GameSparks, il existe un outil prêt à l'emploi pour personnaliser la recherche de jeux, disponible sur le chemin «Configurateur-&gt; Matchs».  J'en crée un nouveau et je continue la configuration.  En plus des paramètres standard tels que le code, le nom et la description du match, le nombre minimum et maximum de joueurs requis pour un mode de jeu personnalisé est indiqué.  Je vais attribuer le code «StandardMatch» au match créé et indiquer le nombre de joueurs de 2 à 3. <br><br>  Vous devez maintenant configurer les règles de sélection des joueurs dans la section «Seuils».  Pour chaque seuil, le temps de son action, le type (absolu, relatif et en pourcentage) et les limites sont indiqués. <br><br><img src="https://habrastorage.org/webt/tn/xb/i0/tnxbi0kpa9lb3gwhb3hlbpgs9og.png"><br><br>  Supposons qu'un joueur avec un MMR de 19 commence la recherche. Dans l'exemple ci-dessus, les 10 premières secondes seront la sélection d'autres joueurs avec un MMR de 19 à 21. Si les joueurs ne peuvent pas être sélectionnés, la deuxième bordure de recherche est activée, ce qui étend la plage de recherche de 16 pour les 20 secondes suivantes ( 19-3) à 22 (19 + 3).  Ensuite, le troisième seuil est inclus, dans lequel une recherche sera effectuée pendant 30 secondes dans la plage de 14 (19-25%) à 29 (19 + 50%), tandis que le match est considéré comme terminé si le nombre minimum requis de joueurs a été accumulé (Accepter la marque Min . Joueurs). <br><br>  En fait, le mécanisme est plus compliqué, car il prend en compte le MMR de tous les joueurs qui ont réussi à rejoindre un match particulier.  J'analyserai ces détails lorsque le moment sera venu de faire le mode de notation du jeu (pas dans cet article).  Pour le mode de jeu standard, où je ne prévois pas encore utiliser MMR, je n'ai besoin que d'un seul seuil. <br><br>  Lorsque tous les joueurs ont été sélectionnés, vous devez créer une session de jeu et y connecter les joueurs.  Dans GameSparks, la fonction de session de jeu est le «défi».  Dans le cadre de cette entité, les données de session de jeu sont stockées et des messages sont échangés entre les clients de jeu.  Pour créer un nouveau type de Challenge, vous devez suivre le chemin "Configurateur-&gt; Challenges".  Là, j'ajoute un nouveau type avec le code "StandardChallenge" et indique que ce type de session de jeu est au tour par tour, c'est-à-dire  les joueurs se relaient, pas simultanément.  GameSparks prend en même temps le contrôle de la séquence des mouvements. <br><br>  Pour qu'un client puisse s'inscrire pour rechercher un jeu, vous pouvez utiliser une demande du type MatchmakingRequest, mais je ne le recommanderais pas, car la valeur MMR du joueur est requise comme l'un des paramètres.  Cela peut conduire à une fraude de la part du client du jeu, et le client ne doit connaître aucun MMR, il s'agit d'une activité de backend.  Pour m'inscrire correctement à la recherche de jeu, je crée un événement arbitraire à partir du client.  Cela se fait dans la section «Configurateur-&gt; Événements».  J'appelle l'événement FindStandardMatch sans attributs.  Maintenant, vous devez configurer la réaction à cet événement, pour cela, je vais dans la section "Configurateur-&gt; Code Cloud" du code cloud, j'écris le gestionnaire suivant pour FindStandardMatch dans la section "Événements": <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.MatchmakingRequest(); matchRequest.matchShortCode = <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>; matchRequest.skill = <span class="hljs-number"><span class="hljs-number">0</span></span>; matchRequest.Execute();</code> </pre><br>  Ce code enregistre un joueur dans StandardMatch avec un MMR de 0, donc tous les joueurs enregistrés pour rechercher un jeu standard conviendront pour créer une session de jeu.  Dans la sélection d'un match de classement, il pourrait y avoir un appel aux données privées du profil du joueur pour obtenir le MMR de ce type de match. <br><br>  Lorsqu'il y a suffisamment de joueurs pour démarrer une session de jeu, GameSparks enverra un message MatchFoundMessage à tous les joueurs sélectionnés.  Ici, vous pouvez générer automatiquement une session de jeu et y ajouter des joueurs.  Pour ce faire, dans le "Messages utilisateur-&gt; MatchFoundMessage" ajoutez le code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Spark.getPlayer().getPlayerId() != matchData.participants[<span class="hljs-number"><span class="hljs-number">0</span></span>].id) { Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challengeCode = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accessType = <span class="hljs-string"><span class="hljs-string">"PRIVATE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (matchData.matchShortCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>: challengeCode = <span class="hljs-string"><span class="hljs-string">"StandardChallenge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.CreateChallengeRequest(); createChallengeRequest.challengeShortCode = challengeCode; createChallengeRequest.accessType = accessType; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomorrow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); tomorrow.setDate(tomorrow.getDate() + <span class="hljs-number"><span class="hljs-number">1</span></span>); createChallengeRequest.endTime = tomorrow.toISOString(); createChallengeRequest.usersToChallenge = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> participants = matchData.participants; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfPlayers = participants.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; numberOfPlayers; i++) { createChallengeRequest.usersToChallenge.push(participants[i].id) } createChallengeRequest.Send();</code> </pre><br>  Le code vérifie d'abord qu'il s'agit du premier joueur sur la liste des participants.  Ensuite, au nom du premier joueur, une instance de StandardChallenge est créée et les joueurs restants sont invités.  Les joueurs invités reçoivent un message ChallengeIssuedMessage.  Ici, vous pouvez imaginer le comportement lorsqu'une invitation à rejoindre le jeu s'affiche sur le client et nécessite une confirmation en envoyant AcceptChallengeRequest, ou vous pouvez accepter l'invitation en mode silencieux.  Je vais donc le faire, pour cela dans "Messages utilisateur-&gt; ChallengeIssuedMessage" j'ajouterai le code suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challangeData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acceptChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.AcceptChallengeRequest(); acceptChallengeRequest.challengeInstanceId = challangeData.challenge.challengeId; acceptChallengeRequest.message = <span class="hljs-string"><span class="hljs-string">"Joining"</span></span>; acceptChallengeRequest.SendAs(Spark.getPlayer().getPlayerId());</code> </pre><br>  L'étape suivante, GameSparks distribue l'événement ChallengeStartedMessage.  Le gestionnaire global de cet événement ("Messages globaux-&gt; ChallengeStartedMessage") est un endroit idéal pour initialiser une session de jeu, je m'en occupe lors de l'implémentation de la logique du jeu. <br><br>  Le moment est venu pour l'application cliente.  Changements dans le module client: <br><br><pre> <code class="javascript hljs">exports.GameClientStates = { <span class="hljs-attr"><span class="hljs-attr">IDLE</span></span>: <span class="hljs-string"><span class="hljs-string">"Idle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">MATCHMAKING</span></span>: <span class="hljs-string"><span class="hljs-string">"Matchmaking"</span></span>, <span class="hljs-attr"><span class="hljs-attr">CHALLENGE</span></span>: <span class="hljs-string"><span class="hljs-string">"Challenge"</span></span> } exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message[<span class="hljs-string"><span class="hljs-string">"@class"</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".MatchNotFoundMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".ChallengeStartedMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.CHALLENGE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = message.challenge; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } } onMessage = onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findStandardMatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventData = { <span class="hljs-attr"><span class="hljs-attr">eventKey</span></span>: <span class="hljs-string"><span class="hljs-string">"FindStandardMatch"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { sendRequest(<span class="hljs-string"><span class="hljs-string">"LogEventRequest"</span></span>, eventData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!response.error) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.MATCHMAKING; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(response.error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(error)); }); }); } }</code> </pre><br>  Conformément au test, deux champs sont apparus sur le client - état et défi.  La méthode onMessage a acquis un aspect significatif et répond désormais aux messages concernant le début d'une session de jeu et à un message indiquant qu'il n'était pas possible de prendre un jeu.  La méthode findStandardMatch a également été ajoutée, qui envoie la requête correspondante au backend.  Le test est vert, mais je suis satisfait, la sélection de jeux maîtrisée. <br><br><h2>  <font color="#292e5b">Et ensuite?</font> </h2><br>  Dans les articles suivants, je décrirai le processus de développement de la logique de jeu, de l'initialisation d'une session de jeu au traitement des mouvements.  J'analyserai les caractéristiques du stockage de différents types de données - une description des métadonnées du jeu, des caractéristiques du monde du jeu, des données des sessions de jeu et des données sur les joueurs.  La logique du jeu sera développée à travers deux types de tests - unitaire et d'intégration. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Je téléchargerai les sources sur github dans des</a> parties liées aux articles. <br><br>  Il est entendu que pour progresser efficacement dans la création d'un jeu, vous devez élargir notre équipe de passionnés.  L'artiste / designer se joindra bientôt.  Et le gourou, par exemple, Unity3D, qui fera la tête des plates-formes mobiles, reste à trouver. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451458/">https://habr.com/ru/post/fr451458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451446/index.html">Développement produit Visual Aid: Design</a></li>
<li><a href="../fr451448/index.html">Pourquoi Do-Not-Track peut être requis</a></li>
<li><a href="../fr451452/index.html">Build2019, comprendre ce que nous avons vu</a></li>
<li><a href="../fr451454/index.html">Nous modifions le contenu de l'application de notification iOS</a></li>
<li><a href="../fr451456/index.html">Stockage AERODISK russe: test de charge. Compression des IOPS</a></li>
<li><a href="../fr451460/index.html">Julia dans le labyrinthe</a></li>
<li><a href="../fr451462/index.html">Écrivez moins de code en double à l'aide de classeurs dans Laravel</a></li>
<li><a href="../fr451464/index.html">Frontend Weekly Digest (6 - 12 mai 2019)</a></li>
<li><a href="../fr451466/index.html">graphql - pièges</a></li>
<li><a href="../fr451468/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 364 (6-12 mai 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>