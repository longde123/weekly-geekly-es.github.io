<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòã üî∑ üèÇüèª Nous pr√©parons un jeu dev. Partie 1 üë®‚Äçüç≥ üë©üèª‚Äçü§ù‚Äçüë®üèº üîü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 L'histoire a commenc√© avec un hackathon bas√© sur la blockchain. Au d√©but de l'√©v√©nement, j'ai rencontr√© un homme qui cr√©e des jeux de s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous pr√©parons un jeu dev. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451458/"><img src="https://habrastorage.org/webt/kj/iq/cp/kjiqcpn8xsrxhus_hsclhpi9w_w.jpeg" align="left"><h2>  <font color="#292e5b">Pr√©sentation</font> </h2><br>  L'histoire a commenc√© avec un hackathon bas√© sur la blockchain.  Au d√©but de l'√©v√©nement, j'ai rencontr√© un homme qui cr√©e des jeux de soci√©t√© comme passe-temps (j'√©tais sur le test d'un de ces jeux), nous nous sommes associ√©s et avons trouv√© une √©quipe avec laquelle ils ont ¬´aveugl√©¬ª un simple jeu strat√©gique au cours du week-end.  Le hackathon est pass√©, mais l'enthousiasme est rest√©.  Et nous avons eu l'id√©e d'un jeu de cartes multijoueur sur le bonheur, la communaut√© mondiale et les √©lections. <br><br>  Dans la s√©rie d'articles, nous refl√©terons notre chemin vers la cr√©ation d'un jeu, avec une description du rake sur lequel nous avons d√©j√† march√© et nous avancerons √† mesure que nous progressons. <br clear="all">  Sous la coupe sera: <br><br><ul><li>  R√©sum√© du jeu </li><li>  Comment la d√©cision a √©t√© prise sur quoi faire backend.  O√π va-t-il ¬´vivre¬ª pour ne pas payer pour cela au stade de d√©veloppement </li><li>  Premi√®res √©tapes du d√©veloppement - authentification des joueurs et organisation du matchmaking </li><li>  Plans suppl√©mentaires </li></ul><a name="habracut"></a><br><h2>  <font color="#292e5b">Quel est le jeu</font> </h2><br>  L'humanit√© est fatigu√©e des guerres mondiales, de l'√©puisement des ressources et de la concurrence constante.  Les factions cl√©s ont convenu d'utiliser la technologie moderne pour s√©lectionner une seule direction.  √Ä l'heure fix√©e, l'√©lectorat mondial doit d√©cider du choix d'une fraction qui gouvernera la plan√®te pour le prochain mill√©naire.  Les factions cl√©s s'engagent dans une lutte de pouvoir ¬´honn√™te¬ª.  Dans une session de jeu, chaque joueur repr√©sente une fraction. <br><br>  Ce jeu de cartes concerne les √©lections.  Chaque faction a un budget pour mener la course aux √©lections, des sources de revenus augmentant le budget et commen√ßant les votes.  Au d√©but du jeu, le jeu de cartes d'action est m√©lang√© et 4 cartes sont d√©livr√©es √† chaque participant.  Chaque tour, les joueurs peuvent effectuer jusqu'√† deux actions de jeu.  Pour utiliser la carte, le joueur la met sur la table et, si n√©cessaire, d√©signe l'objectif et d√©duit du budget le co√ªt d'utilisation de la carte.  Apr√®s la fin du tour, le joueur ne peut conserver qu'une seule des cartes inutilis√©es.  Au d√©but de chaque tour, les joueurs re√ßoivent des cartes du jeu, de sorte qu'au d√©but de chaque tour, chaque joueur a 4 cartes action en main. <br><br>  √Ä la fin des tours 3, 6 et 9, le joueur avec le moins de votes est retir√© du jeu.  Si plusieurs joueurs ont le m√™me nombre minimum de votes, alors tous les joueurs avec ce r√©sultat sont √©limin√©s du jeu.  Les voix de ces joueurs vont au pool g√©n√©ral de l'√©lectorat. <br><br>  √Ä la fin du tour 12, le vainqueur est celui qui a le plus de votes. <br><br><h2>  <font color="#292e5b">Choisir un outil pour le backend</font> </h2><br>  De la description du jeu suit: <br><br><ol><li>  C'est multijoueur </li><li>  Il faut en quelque sorte identifier les joueurs et g√©rer les comptes </li><li>  La pr√©sence d'une composante sociale b√©n√©ficierait au jeu - amis, communaut√©s (clans), chats, r√©alisations (r√©alisations) </li><li>  Des classements et des fonctionnalit√©s de matchmaking seront n√©cessaires. </li><li>  La fonctionnalit√© de gestion des tournois sera utile √† l'avenir </li><li>  √âtant donn√© que le jeu est un jeu de cartes, vous devez g√©rer le catalogue de cartes, vous devrez peut-√™tre stocker les cartes disponibles pour le joueur et les decks compil√©s </li><li>  √Ä l'avenir, une √©conomie dans le jeu pourrait √™tre n√©cessaire, y compris de la monnaie dans le jeu, l'√©change de biens virtuels (cartes) </li></ol><br>  En regardant la liste des besoins, je suis imm√©diatement arriv√© √† la conclusion que cr√©er mon propre backend au stade initial n'a pas de sens et je suis all√© sur google quelles sont les autres options.  J'ai donc d√©couvert qu'il existe des backends de jeux cloud sp√©cialis√©s, parmi lesquels PlayFab (achet√© par Microsoft) et GameSparks (achet√© par Amazon) se d√©marquent. <br><br>  En g√©n√©ral, ils sont fonctionnellement similaires et couvrent les besoins de base.  De plus, leur architecture interne est tr√®s diff√©rente, les m√™mes t√¢ches sont r√©solues un peu diff√©remment et les correspondances explicites dans les fonctionnalit√©s sont difficiles √† tracer.  Vous trouverez ci-dessous les caract√©ristiques positives et n√©gatives de chaque plate-forme et des consid√©rations sur le sujet de choix. <br><br><h3>  <font color="#9cc2ce">Playfab</font> </h3><br>  Caract√©ristiques positives: <br><br><ul><li>  Les comptes de diff√©rents jeux sont combin√©s en un compte principal </li><li>  L'√©conomie du jeu est d√©crite sans une seule ligne de code, y compris les prix vers un magasin virtuel s√©par√© </li><li>  Interface utilisateur conviviale </li><li>  Microsoft acquiert un produit apr√®s son acquisition </li><li>  Le co√ªt de possession en production par abonnement Indie Studio est de 99 $ (jusqu'√† 100k MAU), lors du passage √† Professional, un abonnement de 1k MAU co√ªtera 8 $ (compte minimum 300 $) </li></ul><br>  Caract√©ristiques n√©gatives: <br><br><ul><li>  Le stockage des donn√©es de jeu est strictement limit√©, par exemple, dans un abonnement gratuit pour stocker des donn√©es pour une session de jeu sp√©cifique (si je comprends bien, des groupes d'entit√©s sont utilis√©s pour cela) 3 emplacements de 500 octets chacun sont disponibles </li><li>  Pour organiser le multijoueur, vous devez connecter des serveurs tiers qui traiteront les √©v√©nements des clients et calculeront la logique du jeu.  Il s'agit de Photon sur votre mat√©riel ou d'Azure Thunderhead, et vous devez non seulement organiser le serveur, mais √©galement mettre √† niveau votre abonnement vers au moins Indie Studio </li><li>  Il est n√©cessaire de supporter le fait que le code cloud sans saisie semi-automatique et il n'y a aucun moyen de se diviser en modules (ou ne pas trouver?) </li><li>  Il n'y a pas de d√©bogueur normal, vous pouvez uniquement √©crire des journaux dans CloudScript et afficher </li></ul><br><h3>  <font color="#9cc2ce">Gamesparks</font> </h3><br>  Caract√©ristiques positives: <br><br><ul><li>  Stockage des donn√©es du jeu.  Non seulement il existe de nombreux endroits o√π vous pouvez enregistrer des donn√©es (m√©tadonn√©es g√©n√©rales de jeu, biens virtuels, profil de joueur, sessions multijoueurs, etc.), la plate-forme fournit √©galement une base de donn√©es √† part enti√®re en tant que service qui n'est attach√©e √† rien, de plus, MongoDB et Redis sont disponibles imm√©diatement pour diff√©rents types de donn√©es.  Dans l'environnement de d√©veloppement, vous pouvez stocker 10 Mo, dans la bataille 10 Go </li><li>  Le multijoueur est disponible dans un abonnement gratuit (d√©veloppement) avec une limite de 10 connexions simultan√©es et 10 requ√™tes par seconde </li><li>  Travail pratique avec CloudCode, y compris un outil int√©gr√© pour tester et d√©boguer (Test Harness) </li></ul><br>  Caract√©ristiques n√©gatives: <br><br><ul><li>  Le sentiment que depuis l'achat par Amazon (hiver 2018) l'outil stagne, il n'y a pas d'innovations </li><li>  Encore une fois, apr√®s l'acquisition d'Amazon, les tarifs ont empir√©; auparavant, il √©tait possible d'utiliser jusqu'√† 10000 MAU en production gratuitement </li><li>  Le co√ªt de possession de production commence √† 300 $ (abonnement standard) </li></ul><br><h3>  <font color="#9cc2ce">R√©flexions</font> </h3><br>  Vous devez d'abord v√©rifier le concept du jeu.  Pour ce faire, je veux construire un prototype de b√¢tons et de scotch sans investissements mon√©taires et commencer √† tester les m√©canismes de jeu.  Par cons√©quent, en premier lieu lors du choix, je profite de l'occasion pour d√©velopper et tester un m√©canicien sur un abonnement gratuit. <br>  GameSparks satisfait √† ce crit√®re, mais PlayFab ne le fait pas, car vous aurez besoin d'un serveur qui g√©rera les √©v√©nements des clients de jeu et d'un abonnement Indie studio (99 $). <br><br>  Dans le m√™me temps, j'accepte le risque qu'Amazon ne d√©veloppe pas de GameSparks, ce qui signifie qu'il peut ¬´mourir¬ª.  Compte tenu de cela et toujours du co√ªt de possession en production, j'ai √† l'esprit la n√©cessit√© potentielle de passer soit √† une autre plateforme soit √† mon propre backend. <br><br><h2>  <font color="#292e5b">Premi√®res √©tapes de d√©veloppement</font> </h2><br><h3>  <font color="#9cc2ce">Connexion et authentification</font> </h3><br>  Ainsi, le choix s'est port√© sur GameSparks en tant que backend au stade du prototypage.  La premi√®re √©tape consiste √† apprendre √† se connecter √† la plateforme et √† authentifier le joueur.  Un point important est que l'utilisateur doit pouvoir jouer sans inscription ni SMS imm√©diatement apr√®s l'installation du jeu.  Pour ce faire, GameSparks offre la possibilit√© de cr√©er un profil anonyme en appelant la m√©thode DeviceAuthenticationRequest, plus tard sur la base d'un profil anonyme, vous pouvez en cr√©er un √† part enti√®re en vous connectant, par exemple, avec votre compte Google. <br><br>  √âtant donn√© que j'ai un cerveau TDD, j'ai commenc√© par cr√©er un test pour connecter le client au jeu.  Puisqu'√† l'avenir, CloudCode devra √™tre √©crit en JS, je ferai des tests d'int√©gration en JS en utilisant mocha.js et chai.js.  Le premier test s'est av√©r√© comme ceci: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"chai"</span></span>).expect; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameClientModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../src/gameClient"</span></span>); describe(<span class="hljs-string"><span class="hljs-string">"Integration test"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timeout(<span class="hljs-number"><span class="hljs-number">0</span></span>); it(<span class="hljs-string"><span class="hljs-string">"should connect client to server"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient.connected()).is.false; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient.connect(); expect(gameClient.connected()).is.true; }); })</code> </pre> <br>  Par d√©faut, le d√©lai d'attente dans mocha.js est de 2 secondes, je le fais imm√©diatement sans fin, car les tests sont l'int√©gration.  Dans le test, je cr√©e un client de jeu qui n'a pas encore √©t√© impl√©ment√©, v√©rifie qu'il n'y a pas de connexion au serveur, appelle la commande pour se connecter au backend et v√©rifie que le client s'est correctement connect√©. <br><br>  Pour que le test devienne vert, vous devez t√©l√©charger et ajouter le SDK GameSparks JS au projet, ainsi que connecter ses d√©pendances (crypto-js et ws), et, bien s√ªr, impl√©menter GameClientModule: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameSparks = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../gamesparks-javascript-sdk-2018-04-18/gamesparks-functions"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./config.json"</span></span>); exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gamesparks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameSparks(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (gamesparks.connected === <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.initPreview({ <span class="hljs-attr"><span class="hljs-attr">key</span></span>: config.gameApiKey, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: config.credentialSecret, <span class="hljs-attr"><span class="hljs-attr">credential</span></span>: config.credential, <span class="hljs-attr"><span class="hljs-attr">onInit</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(), <span class="hljs-attr"><span class="hljs-attr">onMessage</span></span>: onMessage, <span class="hljs-attr"><span class="hljs-attr">onError</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(error), <span class="hljs-attr"><span class="hljs-attr">logger</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } }</code> </pre><br>  Au d√©marrage de l'impl√©mentation du client de jeu, les cl√©s n√©cessaires √† l'autorisation technique pour cr√©er une connexion √† partir de l'application client sont lues dans la configuration.  La m√©thode connect√©e enveloppe le m√™me champ √† partir du SDK.  La chose la plus importante se produit dans la m√©thode connect, elle renvoie une promesse avec des rappels pour une connexion r√©ussie ou une erreur, lie √©galement le gestionnaire onMessage au m√™me rappel.  onMessage agira en tant que gestionnaire de traitement des messages depuis le backend, pour l'instant laissez-le enregistrer les messages sur la console. <br><br>  Il semblerait que le travail soit termin√©, mais le test reste rouge.  Il s'av√®re que le SDK GameSparks JS ne fonctionne pas avec node.js; pour lui, vous voyez, il manque le contexte du navigateur.  Faisons-lui penser que le n≈ìud est Chrome sur le coquelicot.  Nous allons sur gamesparks.js et au tout d√©but nous ajoutons: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports) { <span class="hljs-comment"><span class="hljs-comment">// node.js var navigator = { userAgent: "Chrome/73.0.3683.103", vendor: "Google Inc.", platform: "Mac" }; var window = {}; window.setInterval = setInterval; // &lt;&lt;&lt;   KeepAlive  }</span></span></code> </pre><br>  Le test est devenu vert, passant √† autre chose. <br><br>  Comme je l'ai √©crit plus t√¥t, un joueur devrait pouvoir commencer √† jouer imm√©diatement d√®s qu'il entre dans le jeu, alors que je veux commencer √† accumuler des analyses en activit√©.  Pour ce faire, nous nous lions soit √† l'identifiant de l'appareil, soit √† un identifiant g√©n√©r√© al√©atoirement.  V√©rifiez que ce sera un tel test: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should auth two anonymous players"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient1.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient2.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"111"</span></span>); expect(gameClient1.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f5614031f5bc44d59b6a9"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"222"</span></span>); expect(gameClient2.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f6ddb031f5bc44d59b741"</span></span>); });</code> </pre><br>  J'ai d√©cid√© de v√©rifier imm√©diatement 2 clients afin de m'assurer que chaque client cr√©e son propre profil sur le backend.  Pour ce faire, le client du jeu aura besoin d'une m√©thode dans laquelle vous pouvez transf√©rer un certain identifiant externe √† GameSparks, puis v√©rifier que le client a contact√© le profil de joueur souhait√©.  Profils pr√©par√©s √† l'avance sur le portail GameSparks. <br><br>  Pour l'impl√©mentation dans GameClient, ajoutez: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authWithCustomId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">customId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestData = { <span class="hljs-string"><span class="hljs-string">"deviceId"</span></span>: customId , <span class="hljs-string"><span class="hljs-string">"deviceOS"</span></span>: <span class="hljs-string"><span class="hljs-string">"NodeJS"</span></span> } sendRequest(<span class="hljs-string"><span class="hljs-string">"DeviceAuthenticationRequest"</span></span>, requestData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.userId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = response.userId; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">requestType, requestData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.sendWithData(requestType, requestData, (response) =&gt; resolve(response)); }); }</code> </pre><br>  La mise en ≈ìuvre revient √† envoyer une demande DeviceAuthenticationRequest, √† recevoir l'identifiant du joueur de la r√©ponse et √† le placer dans la propri√©t√© du client.  Imm√©diatement, dans une m√©thode distincte, l'aide a envoy√© des demandes √† GameSparks avec un wrapper dans une promis. <br><br>  Les deux tests sont verts, il reste √† ajouter la fermeture de la connexion et le refactor. <br>  Dans GameClient, j'ai ajout√© une m√©thode qui ferme la connexion au serveur (d√©connecter) et connectAsAnonymous combinant connect et authWithCustomId.  D'une part, connectAsAnonymous viole le principe de la responsabilit√© unique, mais ne semble pas violer ... En m√™me temps, il ajoute la convivialit√©, car dans les tests, il sera souvent n√©cessaire d'authentifier les clients.  Qu'en pensez-vous? <br><br>  Dans les tests, il a ajout√© un assistant de m√©thode d'usine qui cr√©e une nouvelle instance du client de jeu et ajoute au tableau des clients cr√©√©s.  Dans le gestionnaire mocha sp√©cial, apr√®s chaque test en cours d'ex√©cution pour les clients du tableau, j'appelle la m√©thode de d√©connexion et efface ce tableau.  Je n'aime pas encore les "cha√Ænes magiques" dans le code, j'ai donc ajout√© un dictionnaire avec des identifiants personnalis√©s utilis√©s dans les tests. <br><br>  Le code final peut √™tre consult√© dans le r√©f√©rentiel, un lien auquel je donnerai √† la fin de l'article. <br><br><h3>  <font color="#9cc2ce">Organisation de recherche de jeux (matchmaking)</font> </h3><br>  Je vais lancer la fonction de matchmaking, qui est tr√®s importante pour le multijoueur.  Ce syst√®me commence √† fonctionner lorsque nous appuyons sur le bouton ¬´Rechercher un jeu¬ª dans le jeu.  Elle prend des rivaux, des co√©quipiers, ou les deux (selon le jeu).  En r√®gle g√©n√©rale, dans de tels syst√®mes, chaque joueur a un indicateur num√©rique MMR (Match Making Ratio) - une √©valuation personnelle du joueur, qui est utilis√©e pour s√©lectionner d'autres joueurs avec le m√™me niveau de comp√©tence. <br><br>  Pour tester cette fonctionnalit√©, j'ai propos√© le test suivant: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should find match"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient3 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connectAsAnonymous(playerCustomIds.id1); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connectAsAnonymous(playerCustomIds.id2); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.connectAsAnonymous(playerCustomIds.id3); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.findStandardMatch(); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.findStandardMatch(); expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.findStandardMatch(); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sleep(<span class="hljs-number"><span class="hljs-number">3000</span></span>); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient1.challenge, <span class="hljs-string"><span class="hljs-string">"challenge"</span></span>).is.not.undefined; expect(gameClient1.challenge.challengeId).is.not.undefined; expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient2.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient3.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); });</code> </pre><br>  Trois clients sont connect√©s au jeu (√† l'avenir, c'est un minimum n√©cessaire pour v√©rifier certains sc√©narios) et sont enregistr√©s pour rechercher le jeu.  Apr√®s avoir enregistr√© le 3√®me joueur sur le serveur, une session de jeu est form√©e et les joueurs doivent s'y connecter.  En m√™me temps, l'√©tat des clients change et le contexte de la session de jeu avec le m√™me identifiant appara√Æt. <br><br>  Tout d'abord, pr√©parez le backend.  Dans GameSparks, il existe un outil pr√™t √† l'emploi pour personnaliser la recherche de jeux, disponible sur le chemin ¬´Configurateur-&gt; Matchs¬ª.  J'en cr√©e un nouveau et je continue la configuration.  En plus des param√®tres standard tels que le code, le nom et la description du match, le nombre minimum et maximum de joueurs requis pour un mode de jeu personnalis√© est indiqu√©.  Je vais attribuer le code ¬´StandardMatch¬ª au match cr√©√© et indiquer le nombre de joueurs de 2 √† 3. <br><br>  Vous devez maintenant configurer les r√®gles de s√©lection des joueurs dans la section ¬´Seuils¬ª.  Pour chaque seuil, le temps de son action, le type (absolu, relatif et en pourcentage) et les limites sont indiqu√©s. <br><br><img src="https://habrastorage.org/webt/tn/xb/i0/tnxbi0kpa9lb3gwhb3hlbpgs9og.png"><br><br>  Supposons qu'un joueur avec un MMR de 19 commence la recherche. Dans l'exemple ci-dessus, les 10 premi√®res secondes seront la s√©lection d'autres joueurs avec un MMR de 19 √† 21. Si les joueurs ne peuvent pas √™tre s√©lectionn√©s, la deuxi√®me bordure de recherche est activ√©e, ce qui √©tend la plage de recherche de 16 pour les 20 secondes suivantes ( 19-3) √† 22 (19 + 3).  Ensuite, le troisi√®me seuil est inclus, dans lequel une recherche sera effectu√©e pendant 30 secondes dans la plage de 14 (19-25%) √† 29 (19 + 50%), tandis que le match est consid√©r√© comme termin√© si le nombre minimum requis de joueurs a √©t√© accumul√© (Accepter la marque Min . Joueurs). <br><br>  En fait, le m√©canisme est plus compliqu√©, car il prend en compte le MMR de tous les joueurs qui ont r√©ussi √† rejoindre un match particulier.  J'analyserai ces d√©tails lorsque le moment sera venu de faire le mode de notation du jeu (pas dans cet article).  Pour le mode de jeu standard, o√π je ne pr√©vois pas encore utiliser MMR, je n'ai besoin que d'un seul seuil. <br><br>  Lorsque tous les joueurs ont √©t√© s√©lectionn√©s, vous devez cr√©er une session de jeu et y connecter les joueurs.  Dans GameSparks, la fonction de session de jeu est le ¬´d√©fi¬ª.  Dans le cadre de cette entit√©, les donn√©es de session de jeu sont stock√©es et des messages sont √©chang√©s entre les clients de jeu.  Pour cr√©er un nouveau type de Challenge, vous devez suivre le chemin "Configurateur-&gt; Challenges".  L√†, j'ajoute un nouveau type avec le code "StandardChallenge" et indique que ce type de session de jeu est au tour par tour, c'est-√†-dire  les joueurs se relaient, pas simultan√©ment.  GameSparks prend en m√™me temps le contr√¥le de la s√©quence des mouvements. <br><br>  Pour qu'un client puisse s'inscrire pour rechercher un jeu, vous pouvez utiliser une demande du type MatchmakingRequest, mais je ne le recommanderais pas, car la valeur MMR du joueur est requise comme l'un des param√®tres.  Cela peut conduire √† une fraude de la part du client du jeu, et le client ne doit conna√Ætre aucun MMR, il s'agit d'une activit√© de backend.  Pour m'inscrire correctement √† la recherche de jeu, je cr√©e un √©v√©nement arbitraire √† partir du client.  Cela se fait dans la section ¬´Configurateur-&gt; √âv√©nements¬ª.  J'appelle l'√©v√©nement FindStandardMatch sans attributs.  Maintenant, vous devez configurer la r√©action √† cet √©v√©nement, pour cela, je vais dans la section "Configurateur-&gt; Code Cloud" du code cloud, j'√©cris le gestionnaire suivant pour FindStandardMatch dans la section "√âv√©nements": <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.MatchmakingRequest(); matchRequest.matchShortCode = <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>; matchRequest.skill = <span class="hljs-number"><span class="hljs-number">0</span></span>; matchRequest.Execute();</code> </pre><br>  Ce code enregistre un joueur dans StandardMatch avec un MMR de 0, donc tous les joueurs enregistr√©s pour rechercher un jeu standard conviendront pour cr√©er une session de jeu.  Dans la s√©lection d'un match de classement, il pourrait y avoir un appel aux donn√©es priv√©es du profil du joueur pour obtenir le MMR de ce type de match. <br><br>  Lorsqu'il y a suffisamment de joueurs pour d√©marrer une session de jeu, GameSparks enverra un message MatchFoundMessage √† tous les joueurs s√©lectionn√©s.  Ici, vous pouvez g√©n√©rer automatiquement une session de jeu et y ajouter des joueurs.  Pour ce faire, dans le "Messages utilisateur-&gt; MatchFoundMessage" ajoutez le code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Spark.getPlayer().getPlayerId() != matchData.participants[<span class="hljs-number"><span class="hljs-number">0</span></span>].id) { Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challengeCode = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accessType = <span class="hljs-string"><span class="hljs-string">"PRIVATE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (matchData.matchShortCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>: challengeCode = <span class="hljs-string"><span class="hljs-string">"StandardChallenge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.CreateChallengeRequest(); createChallengeRequest.challengeShortCode = challengeCode; createChallengeRequest.accessType = accessType; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomorrow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); tomorrow.setDate(tomorrow.getDate() + <span class="hljs-number"><span class="hljs-number">1</span></span>); createChallengeRequest.endTime = tomorrow.toISOString(); createChallengeRequest.usersToChallenge = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> participants = matchData.participants; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfPlayers = participants.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; numberOfPlayers; i++) { createChallengeRequest.usersToChallenge.push(participants[i].id) } createChallengeRequest.Send();</code> </pre><br>  Le code v√©rifie d'abord qu'il s'agit du premier joueur sur la liste des participants.  Ensuite, au nom du premier joueur, une instance de StandardChallenge est cr√©√©e et les joueurs restants sont invit√©s.  Les joueurs invit√©s re√ßoivent un message ChallengeIssuedMessage.  Ici, vous pouvez imaginer le comportement lorsqu'une invitation √† rejoindre le jeu s'affiche sur le client et n√©cessite une confirmation en envoyant AcceptChallengeRequest, ou vous pouvez accepter l'invitation en mode silencieux.  Je vais donc le faire, pour cela dans "Messages utilisateur-&gt; ChallengeIssuedMessage" j'ajouterai le code suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challangeData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acceptChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.AcceptChallengeRequest(); acceptChallengeRequest.challengeInstanceId = challangeData.challenge.challengeId; acceptChallengeRequest.message = <span class="hljs-string"><span class="hljs-string">"Joining"</span></span>; acceptChallengeRequest.SendAs(Spark.getPlayer().getPlayerId());</code> </pre><br>  L'√©tape suivante, GameSparks distribue l'√©v√©nement ChallengeStartedMessage.  Le gestionnaire global de cet √©v√©nement ("Messages globaux-&gt; ChallengeStartedMessage") est un endroit id√©al pour initialiser une session de jeu, je m'en occupe lors de l'impl√©mentation de la logique du jeu. <br><br>  Le moment est venu pour l'application cliente.  Changements dans le module client: <br><br><pre> <code class="javascript hljs">exports.GameClientStates = { <span class="hljs-attr"><span class="hljs-attr">IDLE</span></span>: <span class="hljs-string"><span class="hljs-string">"Idle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">MATCHMAKING</span></span>: <span class="hljs-string"><span class="hljs-string">"Matchmaking"</span></span>, <span class="hljs-attr"><span class="hljs-attr">CHALLENGE</span></span>: <span class="hljs-string"><span class="hljs-string">"Challenge"</span></span> } exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message[<span class="hljs-string"><span class="hljs-string">"@class"</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".MatchNotFoundMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".ChallengeStartedMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.CHALLENGE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = message.challenge; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } } onMessage = onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findStandardMatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventData = { <span class="hljs-attr"><span class="hljs-attr">eventKey</span></span>: <span class="hljs-string"><span class="hljs-string">"FindStandardMatch"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { sendRequest(<span class="hljs-string"><span class="hljs-string">"LogEventRequest"</span></span>, eventData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!response.error) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.MATCHMAKING; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(response.error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(error)); }); }); } }</code> </pre><br>  Conform√©ment au test, deux champs sont apparus sur le client - √©tat et d√©fi.  La m√©thode onMessage a acquis un aspect significatif et r√©pond d√©sormais aux messages concernant le d√©but d'une session de jeu et √† un message indiquant qu'il n'√©tait pas possible de prendre un jeu.  La m√©thode findStandardMatch a √©galement √©t√© ajout√©e, qui envoie la requ√™te correspondante au backend.  Le test est vert, mais je suis satisfait, la s√©lection de jeux ma√Ætris√©e. <br><br><h2>  <font color="#292e5b">Et ensuite?</font> </h2><br>  Dans les articles suivants, je d√©crirai le processus de d√©veloppement de la logique de jeu, de l'initialisation d'une session de jeu au traitement des mouvements.  J'analyserai les caract√©ristiques du stockage de diff√©rents types de donn√©es - une description des m√©tadonn√©es du jeu, des caract√©ristiques du monde du jeu, des donn√©es des sessions de jeu et des donn√©es sur les joueurs.  La logique du jeu sera d√©velopp√©e √† travers deux types de tests - unitaire et d'int√©gration. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Je t√©l√©chargerai les sources sur github dans des</a> parties li√©es aux articles. <br><br>  Il est entendu que pour progresser efficacement dans la cr√©ation d'un jeu, vous devez √©largir notre √©quipe de passionn√©s.  L'artiste / designer se joindra bient√¥t.  Et le gourou, par exemple, Unity3D, qui fera la t√™te des plates-formes mobiles, reste √† trouver. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451458/">https://habr.com/ru/post/fr451458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451446/index.html">D√©veloppement produit Visual Aid: Design</a></li>
<li><a href="../fr451448/index.html">Pourquoi Do-Not-Track peut √™tre requis</a></li>
<li><a href="../fr451452/index.html">Build2019, comprendre ce que nous avons vu</a></li>
<li><a href="../fr451454/index.html">Nous modifions le contenu de l'application de notification iOS</a></li>
<li><a href="../fr451456/index.html">Stockage AERODISK russe: test de charge. Compression des IOPS</a></li>
<li><a href="../fr451460/index.html">Julia dans le labyrinthe</a></li>
<li><a href="../fr451462/index.html">√âcrivez moins de code en double √† l'aide de classeurs dans Laravel</a></li>
<li><a href="../fr451464/index.html">Frontend Weekly Digest (6 - 12 mai 2019)</a></li>
<li><a href="../fr451466/index.html">graphql - pi√®ges</a></li>
<li><a href="../fr451468/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 364 (6-12 mai 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>