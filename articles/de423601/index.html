<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻 🤞 🏇🏿 Jobsystem und Suchpfad 🌜 🐢 ☝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Karte 
 In einem früheren Artikel habe ich mir angesehen, was das neue Job-System ist , wie es funktioniert, wie Aufgaben erstellt, mit Daten gefüllt ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jobsystem und Suchpfad</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423601/"><h3>  Karte </h3><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel habe</a> ich mir angesehen, was das neue <b>Job-System ist</b> , wie es funktioniert, wie Aufgaben erstellt, mit Daten gefüllt und Multithread-Berechnungen durchgeführt werden, und nur kurz erklärt, wo Sie dieses System verwenden können.  In diesem Artikel werde ich versuchen, ein bestimmtes Beispiel zu analysieren, wo Sie dieses System verwenden können, um mehr Leistung zu erzielen. <br><a name="habracut"></a><br>  Da das System ursprünglich mit dem Ziel entwickelt wurde, mit Daten zu arbeiten, eignet es sich hervorragend zur Lösung von Pfadfindungsaufgaben. <br><br>  <b>Unity</b> verfügt bereits über einen guten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NavMesh-Pfadfinder</a> , funktioniert jedoch nicht in 2D-Projekten, obwohl es viele vorgefertigte Lösungen für dasselbe <i>Asset gibt</i> .  Nun, und wir werden versuchen, nicht nur ein System zu erstellen, das nach Wegen auf der erstellten Karte sucht, sondern diese Karte auch dynamisch macht, so dass das System jedes Mal, wenn sich etwas daran ändert, eine neue Karte erstellt, und all dies werden wir natürlich mit berechnen ein neues System von Aufgaben, um den Haupt-Thread nicht zu laden. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel für einen Systembetrieb</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/527/a69/ec1/527a69ec1543218ffe1df7c4b1deddb0.gif" alt="Bild"><br></div></div><br>  Im Beispiel wird ein Raster auf der Karte erstellt, es gibt einen Bot und ein Hindernis.  Das Raster wird jedes Mal neu erstellt, wenn wir Eigenschaften der Karte ändern, unabhängig von ihrer Größe oder Position. <br><br>  Für Flugzeuge habe ich einen einfachen <b>SpriteRenderer verwendet</b> . Diese Komponente verfügt über eine hervorragende <b>Grenzeigenschaft</b> , mit der Sie die Größe der Karte leicht ermitteln können. <br><br>  Das ist im Grunde alles für den Anfang, aber wir werden nicht aufhören und sofort zur Sache kommen. <br><br>  Beginnen wir mit den Skripten.  Und das erste ist das <b>Hindernishindernis-</b> Skript. <br><br><div class="spoiler">  <b class="spoiler_title">Hindernis</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  Innerhalb der <b>Hindernisklasse</b> erfassen wir alle Änderungen an den Hindernissen auf der Karte, z. B. das Ändern der Position oder Größe eines Objekts. <br>  Als Nächstes können Sie die <b>Map-</b> Map-Klasse erstellen, auf der das Raster erstellt wird, und es von der <b>Obstacle-</b> Klasse erben. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  Die <b>Map-</b> Klasse verfolgt auch alle Änderungen auf der Map, um das Raster bei Bedarf neu zu erstellen. <br><br>  Füllen Sie dazu die <b>Hindernis-</b> Basisklasse mit allen erforderlichen Variablen und Methoden, um <b>Objektänderungen</b> zu verfolgen. <br><br><div class="spoiler">  <b class="spoiler_title">Hindernis</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteRenderer renderer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempPos; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer = GetComponent&lt;SpriteRenderer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> virtual bool CheckChanges() { Vector2 newSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; float diff = (newSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = newSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } Vector2 newPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; diff = (newPos - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = newPos; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 size { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.bounds.size;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position;} } }</code> </pre> <br></div></div><br>  Hier hat die <b>Renderer-</b> Variable einen Verweis auf die <b>SpriteRenderer-</b> Komponente, und die <b>Variablen</b> <b>tempSize</b> und <b>tempPos</b> werden verwendet, um Änderungen in der Größe und Position des Objekts zu verfolgen. <br><br>  Die virtuelle <b>Awake-</b> Methode wird zum Initialisieren der Variablen verwendet, und die virtuelle <b>CheckChanges-</b> Methode verfolgt die aktuellen Änderungen der Größe und Position des Objekts und gibt ein <b>boolesches</b> Ergebnis zurück. <br><br>  Lassen Sie uns zunächst das <b>Hindernis-</b> Skript und fahren Sie mit dem <b>Map-</b> Map-Skript selbst fort, in dem wir es auch mit den für die Arbeit erforderlichen Parametern füllen. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); }</code> </pre> <br></div></div><br>  Die Variable <b>nodeSize</b> gibt die Größe der Zellen auf der Karte an. Hier habe ich ihre Größe von 0,1 auf 1 begrenzt, damit die Zellen im Raster nicht zu klein, sondern auch zu groß sind.  Die <b>Versatzvariable</b> wird verwendet, um die Karte beim Erstellen des Rasters einzurücken, sodass das Raster nicht entlang der Kanten der Karte erstellt wird. <br><br>  Da es jetzt zwei neue Variablen auf der Karte gibt, stellt sich heraus, dass ihre Änderungen ebenfalls verfolgt werden müssen.  <b>Fügen Sie dazu</b> einige Variablen hinzu und überladen Sie die <b>CheckChanges-</b> Methode in der <b>Map-</b> Klasse. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> float tempNodeSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempOffset; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { base.Awake(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } }</code> </pre> <br></div></div><br>  Fertig.  Jetzt können Sie ein Kartensprite auf der Bühne erstellen und ein Kartenskript darauf werfen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d75/60f/db8/d7560fdb8abeb5f00a7a5e1ec5e444df.png" alt="Bild"><br><br>  Wir machen dasselbe mit einem Hindernis - erstellen Sie ein einfaches Sprite auf der Bühne und werfen Sie das <b>Hindernis-</b> Skript darauf. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/ffa/e8d/347ffae8dd2b4cd3a3a50c881d5674df.png" alt="Bild"><br><br>  Jetzt haben wir Kartenobjekte und Hindernisse auf der Bühne. <br><br>  Das Kartenskript ist für die Verfolgung aller Änderungen auf der Karte verantwortlich. In der <b>Aktualisierungsmethode</b> überprüfen wir jeden Frame auf Änderungen. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool requireRebuild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { UpdateChanges(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Daher <b>verfolgt die</b> Karte in der <b>UpdateChanges-</b> Methode nur die <b>bisherigen</b> Änderungen.  Sie können das Spiel jetzt sogar starten und versuchen, die Größe der Karte oder den <b>Versatz</b> zu ändern, um sicherzustellen, dass alle Änderungen nachverfolgt werden. <br><br>  Jetzt müssen Sie die Änderungen der Hindernisse selbst auf der Karte irgendwie verfolgen.  Dazu setzen wir jedes Hindernis in eine Liste auf der Karte, die wiederum jeden Frame in der <b>Update-</b> Methode aktualisiert. <br><br>  Erstellen Sie in der <b>Map-</b> Klasse eine Liste aller möglichen Hindernisse auf der Map und einige statische Methoden, um sie zu registrieren. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map ObjInstance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Obstacle&gt; obstacles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Obstacle&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool RegisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle == Instance) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Contains(obstacle) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { Instance.obstacles.Add(obstacle); Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool UnregisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Remove(obstacle)) { Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjInstance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ObjInstance = FindObjectOfType&lt;Map&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjInstance; } } }</code> </pre> <br></div></div><br>  Bei der statischen <b>RegisterObstacle-</b> Methode registrieren wir ein neues Hindernishindernis auf der Karte und fügen es der Liste hinzu. Zunächst ist jedoch zu berücksichtigen, dass die Karte selbst auch von der <b>Hindernisklasse</b> geerbt wird. Daher sollten wir prüfen, ob wir versuchen, die Karte selbst als Hindernis zu registrieren. <br><br>  Die statische <b>UnregisterObstacle-</b> Methode beseitigt im Gegenteil das Hindernis aus der Karte und entfernt es aus der Liste, wenn wir zulassen, dass es zerstört wird. <br><br>  Gleichzeitig muss jedes Mal, wenn wir ein Hindernis zur Karte hinzufügen oder daraus entfernen, die Karte selbst neu erstellt werden. Setzen <b>Sie</b> daher nach Ausführung dieser statischen Methoden die Variable <b>requireRebuild</b> auf <b>true</b> . <br><br>  <b>Um</b> von jedem Skript aus problemlos auf das <b>Map-</b> Skript zugreifen zu können, habe ich eine statische <b>Instanzeigenschaft erstellt</b> , die mir genau diese Instanz der <b>Map zurückgibt</b> . <br><br>  <b>Kehren</b> wir nun zum <b>Hindernis-</b> Skript zurück, in dem wir ein Hindernis auf der Karte registrieren. <b>Fügen</b> Sie dazu einige <b>OnEnable-</b> und <b>OnDisable-</b> Methoden hinzu. <br><br><div class="spoiler">  <b class="spoiler_title">Hindernis</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { Map.RegisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { Map.UnregisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br></div></div><br>  Jedes Mal, wenn wir beim Spielen auf der Karte ein neues Hindernis erstellen, wird es automatisch in der <b>OnEnable-</b> Methode registriert, wobei es beim <b>Erstellen</b> eines neuen Rasters berücksichtigt wird und wir uns in der <b>OnDisable-</b> Methode von der Karte <b>entfernen</b> , wenn es zerstört oder deaktiviert wird. <br><br>  Es bleibt nur die Verfolgung der Änderungen der Hindernisse selbst im <b>Map-</b> Skript in der überladenen <b>CheckChanges-</b> Methode. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } foreach(Obstacle obstacle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle.CheckChanges()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Jetzt haben wir eine Karte, Hindernisse - im Allgemeinen alles, was Sie zum Aufbau eines Gitters benötigen, und jetzt können Sie zum Wichtigsten übergehen. <br><br><h4>  Vernetzung </h4><br>  Das Gitter ist in seiner einfachsten Form eine zweidimensionale Anordnung von Punkten.  Um es zu erstellen, müssen Sie die Größe der Karte und die Größe der Punkte darauf kennen. Nach einigen Berechnungen erhalten wir die Anzahl der Punkte horizontal und vertikal. Dies ist unser Raster. <br><br>  Es gibt viele Möglichkeiten, einen Pfad in einem Raster zu finden.  In diesem Artikel geht es jedoch hauptsächlich darum, zu verstehen, wie die Funktionen des Task-Systems korrekt verwendet werden. Daher werde ich hier nicht auf verschiedene Optionen zum Auffinden des Pfads sowie auf deren Vor- und Nachteile eingehen, sondern auf die einfachste Suchoption <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A *</a> . <br><br>  In diesem Fall sollten alle Punkte im Raster zusätzlich zur Position die Koordinaten- und Durchgängigkeitseigenschaft aufweisen. <br><br>  Mit der Durchgängigkeit denke ich, dass alles klar ist, warum es benötigt wird, aber die Koordinaten geben die Reihenfolge des Punktes auf dem Gitter an. Diese Koordinaten sind nicht spezifisch an die Position des Punktes im Raum gebunden.  Das Bild unten zeigt ein einfaches Raster, das die Unterschiede der Koordinaten von einer Position zeigt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/c12/466/7c1c124662f7c41ecb2a1c55939a1a64.png" alt="Bild"><br>  <i>Warum die Koordinaten?</i> <br>  Tatsache ist, dass in der Einheit ein einfaches <b>Float verwendet wird</b> , das sehr ungenau ist und eine gebrochene oder negative Zahl sein kann, um die Position eines Objekts im Raum anzuzeigen. <b>Daher ist</b> es schwierig, damit eine Pfadsuche auf der Karte zu implementieren.  Die Koordinaten werden in Form eines klaren <b>Int erstellt,</b> das immer positiv ist und mit dem bei der Suche nach benachbarten Punkten viel einfacher gearbeitet werden kann. <br><br>  Definieren wir zunächst ein <b>Punktobjekt</b> . Dies ist eine einfache <b>Knotenstruktur</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Knoten</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; }</code> </pre> <br></div></div><br>  Diese Struktur enthält die Positionsposition in Form von <b>Vector2</b> , wobei wir mit dieser Variablen einen Punkt im Raum zeichnen.  Die Koordinatenkoordinatenvariable in Form von <b>Vector2Int</b> gibt die Koordinaten eines Punkts auf der Karte an, und die <b>ID-</b> Variable, ihre numerische Kontonummer, vergleicht verschiedene Punkte im Raster und prüft, ob ein Punkt vorhanden ist. <br><br>  Die Durchgängigkeit des Punktes wird in Form seiner <b>booleschen</b> Eigenschaft angegeben. Da wir die <i>konvertierbaren</i> Datentypen im Task-System jedoch nicht verwenden können, geben wir seine Durchgängigkeit in Form einer <b>int-</b> Zahl an. Dazu habe ich eine einfache Aufzählung <b>NodeType verwendet</b> , wobei: 0 kein passierbarer Punkt ist. und 1 ist passabel. <br><br><div class="spoiler">  <b class="spoiler_title">NodeType und Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enum NodeType { NonWalkable = <span class="hljs-number"><span class="hljs-number">0</span></span>, Walkable = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int nodeType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool isWalkable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType == (int)NodeType.Walkable;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node(int id, Vector2 position, Vector2Int coords, NodeType type) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coords = coords; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType = (int)type; } }</code> </pre> <br></div></div><br>  Um die Arbeit mit einem Punkt zu vereinfachen, werde ich die <b>Equals-</b> Methode überladen, um den Vergleich von Punkten zu vereinfachen und die Überprüfungsmethode für die Existenz eines Punkts zu ergänzen. <br><br><div class="spoiler">  <b class="spoiler_title">Knoten</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool Equals(object obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Node) { Node other = (Node)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id == other.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.Equals(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> implicit operator bool(Node node) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br></div></div><br>  Da die <b>ID-</b> Nummer des Punkts im Raster mit 1 Einheit beginnt, überprüfe ich die Existenz des Punkts als Bedingung, dass seine <b>ID</b> größer als 0 ist. <br><br>  Gehen Sie zur <b>Map-</b> Klasse, wo wir alles für die Erstellung einer Map vorbereiten. <br>  Wir haben bereits eine Überprüfung für die Änderung der Parameter der Karte, jetzt müssen wir bestimmen, wie der Prozess des Aufbaus des Gitters ausgeführt wird.  Erstellen Sie dazu eine neue Variable und mehrere Methoden. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() {} <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Die <b>Neuerstellungseigenschaft</b> gibt an, ob der <b>Vernetzungsprozess ausgeführt</b> wird.  Die <b>Rebuild-</b> Methode sammelt Daten und Aufgaben zum <b>Erstellen</b> des Rasters, dann <b>startet</b> die <b>OnRebuildStart-</b> Methode den Grid- <b>Erstellungsprozess</b> und die <b>OnRebuildFinish-</b> Methode sammelt Daten aus den Aufgaben. <br><br>  Lassen Sie uns nun die <b>UpdateChanges-</b> Methode ein <b>wenig</b> ändern, damit die <b>Rasterbedingung</b> berücksichtigt wird. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(“  ...”); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(“ !”); OnRebuildStart(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Wie Sie jetzt in der <b>UpdateChanges-</b> Methode sehen können, <b>gibt</b> es eine Bedingung, dass beim <b>Erstellen</b> des alten Netzes nicht mit dem <b>Erstellen</b> eines neuen Netzes begonnen wird. Auch bei der <b>Rebuild-</b> Methode prüft die erste Aktion, ob der Vernetzungsprozess bereits ausgeführt wird. <br><br><h4>  Problemlösung </h4><br>  Nun ein wenig über den Prozess des Erstellens einer Karte. <br>  Da wir das Task-System verwenden und das Raster parallel erstellen, um die Map zu erstellen, habe ich den Typ der <b>IJobParallelFor-</b> Task verwendet, der eine bestimmte Anzahl von Malen ausgeführt wird.  Um den Konstruktionsprozess nicht mit einer separaten Aufgabe zu laden, verwenden wir den in einem <b>JobHandle</b> gepackten Aufgabenpool. <br><br>  Verwenden Sie zum Erstellen eines Rasters meistens zwei ineinander verschachtelte Zyklen, um beispielsweise horizontal und vertikal zu erstellen.  In diesem Beispiel wird das Raster auch zuerst horizontal und dann vertikal erstellt.  Dazu berechnen wir die Anzahl der horizontalen und vertikalen Punkte in der <b>Rebuild-</b> Methode. In der <b>Rebuild-</b> Methode durchlaufen wir den Zyklus entlang der vertikalen Punkte und erstellen in der Aufgabe parallel horizontale Punkte.  Schauen Sie sich die Animation unten an, um sich den Bauprozess besser vorzustellen. <br><br><div class="spoiler">  <b class="spoiler_title">Vernetzung</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/101/625/183/10162518305232afb889f9d8a45b70da.gif" alt="Bild"><br></div></div><br>  Die Anzahl der vertikalen Punkte gibt die Anzahl der Aufgaben an. Jede Aufgabe erstellt Punkte nur horizontal. Nach Abschluss aller Aufgaben werden die Punkte in einer Liste zusammengefasst.  Aus diesem Grund muss ich eine Aufgabe wie <b>IJobParallelFor verwenden</b> , um den Index des Punkts im Raster horizontal an die <b>Execute-</b> Methode zu übergeben. <br><br>  Und so haben wir die Punktstruktur. Jetzt können Sie die Struktur der <b>Jobaufgabe</b> erstellen und von der <b>IJobParallelFor-</b> Schnittstelle erben. <b>Hier</b> ist alles einfach. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Wir kehren zur <b>Rebuild-</b> Methode der <b>Map-</b> Klasse zurück, in der wir die erforderlichen Berechnungen für die Gittermessung durchführen. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(“ !”); Vector2 mapSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset * <span class="hljs-number"><span class="hljs-number">2</span></span>f; int horizontals = Mathf.RoundToInt(mapSize.x / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); int verticals = Mathf.RoundToInt(mapSize.y / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontals &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { OnRebuildFinish(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); OnRebuildStart(); } <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Bei der <b>Rebuild-</b> Methode berechnen wir die genaue Größe der <b>mapSize-</b> Karte unter Berücksichtigung der Einrückung. In <b>Vertikalen</b> schreiben wir dann die Anzahl der Punkte vertikal und in <b>Horizontalen die</b> Anzahl der Punkte horizontal.  Wenn die Anzahl der vertikalen Punkte 0 ist, beenden wir die <b>Erstellung</b> der Karte und rufen die <b>OnRebuildFinish-</b> Methode auf, um den Vorgang abzuschließen.  Die <b>Ursprungsvariable</b> gibt den Ort an, von dem aus wir mit dem Erstellen des Rasters beginnen. Im Beispiel ist dies der untere linke Punkt auf der Karte. <br><br>  Jetzt können Sie zu den Aufgaben selbst gehen und sie mit Daten füllen. <br>  Während des Aufbaus des Rasters benötigt die Aufgabe ein <b>NativeArray-</b> Array, in dem wir die Punkte platzieren. Da wir Hindernisse auf der Karte haben, müssen wir sie auch an die Aufgabe übergeben. Dazu verwenden wir ein anderes <b>NativeArray-</b> Array. Dann benötigen wir die Größe der Punkte im Problem , die Anfangsposition, von der aus wir die Punkte erstellen, sowie die Anfangskoordinaten der Reihe. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Node&gt; array; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 startPos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int startCoords; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Ich habe das Array von Punkten mit dem Attribut <b>WriteOnly markiert,</b> da in der Aufgabe nur die empfangenen Punkte in das Array " <i>geschrieben</i> " werden müssen. Im Gegensatz dazu wird das Array der Hindernisgrenzen mit dem Attribut <b>ReadOnly markiert,</b> da in der Aufgabe nur Daten aus diesem Array " <i>gelesen</i> " werden. <br><br>  Lassen Sie uns zunächst mit der Berechnung der Punkte selbst fortfahren. <br><br>  Nun zurück zur <b>Map-</b> Klasse, in der wir alle an den Aufgaben beteiligten Variablen bezeichnen. <br>  Hier benötigen wir zunächst ein globales <b>Handle von</b> Aufgaben, eine Reihe von Hindernissen in Form von <b>NativeArray</b> , eine Liste von Aufgaben, die alle im Raster und im <b>Wörterbuch</b> empfangenen Punkte mit allen Koordinaten und Punkten auf der Karte enthalten, damit es später bequemer ist, nach ihnen zu suchen. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt; jobs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2Int, Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2Int, Node&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Nun kehren wir wieder zur <b>Rebuild-</b> Methode zurück und bauen das Grid weiter auf. <br>  Initialisieren Sie zunächst das <b>Begrenzungsarray</b> von Hindernissen, um es an die Aufgabe weiterzuleiten. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Hier erstellen wir eine Instanz von <b>NativeArray</b> über einen neuen Konstruktor mit drei Parametern.  Ich habe die ersten beiden Parameter in einem früheren Artikel untersucht, aber der dritte Parameter hilft uns, ein wenig Zeit beim Erstellen eines Arrays zu sparen.  Tatsache ist, dass wir Daten unmittelbar nach ihrer Erstellung in das Array schreiben, was bedeutet, dass wir nicht sicherstellen müssen, dass es gelöscht wird.  Dieser Parameter ist nützlich für <b>NativeArray,</b> das in der Task nur im Lesemodus verwendet wird. <br><br>  Und so füllen wir das <b>Bounds-</b> Array mit Daten. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Jetzt können wir mit dem Erstellen von Aufgaben fortfahren. Dazu durchlaufen wir einen Zyklus durch alle vertikalen Zeilen des Rasters. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Zunächst <b>erhalten</b> wir in <b>xPos</b> und <b>yPos</b> die anfängliche horizontale Position der Serie. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Als Nächstes erstellen wir ein einfaches <b>NativeArray-</b> Array, in dem die Punkte in der Aufgabe platziert werden. Hier müssen Sie für das Array- <b>Array</b> angeben, wie viele Punkte horizontal erstellt werden und welche Art der Zuordnung <b>dauerhaft ist</b> , da die Aufgabe länger als ein Frame dauern kann. <br>  Erstellen Sie anschließend die <b>Job-</b> Task-Instanz selbst, setzen Sie die Anfangskoordinaten der <b>startCoords-</b> Reihe, die Anfangsposition der <b>startPos-</b> Reihe, die Größe der <b>nodeSize-</b> Punkte, das <b>Begrenzungsarray</b> von Hindernissen und das Array von Punkten selbst am Ende. <br>  Es bleibt nur die Aufgabe in <b>Handle</b> und die globale Aufgabenliste zu setzen. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(horizontals, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Add(array); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Fertig.  Wir haben eine Liste von Aufgaben und deren allgemeinem <b>Handle</b> . Jetzt können wir dieses <b>Handle</b> ausführen <b>, indem</b> wir die <b>Complete-</b> Methode in der <b>OnRebuildStart-</b> Methode <b>aufrufen</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Onrebuildstart</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  Da die <b>Wiederherstellungsvariable</b> anzeigt, dass der <b>Vernetzungsprozess ausgeführt</b> wird, muss die <b>UpdateChanges-</b> Methode <b>selbst</b> auch die Bedingung angeben, wann dieser Prozess unter Verwendung des <b>Handles</b> und seiner <b>IsCompleted-</b> Eigenschaft beendet wird. <br><br><div class="spoiler">  <b class="spoiler_title">Update-Änderungen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(“  ...”); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) OnRebuildFinish(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } }</code> </pre> <br></div></div><br>  Nach Abschluss der Aufgaben wird die <b>OnRebuildFinish-</b> Methode aufgerufen, bei der die empfangenen Punkte bereits in einer allgemeinen <b>Wörterbuchliste</b> gesammelt werden und vor allem die belegten Ressourcen <b>gelöscht</b> werden. <br><br><div class="spoiler">  <b class="spoiler_title">OnRebuildFinish</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Clear(); foreach (NativeArray&lt;Node&gt; array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs) { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Add(node.coords, node); array.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.IsCreated) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst löschen wir das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knotenwörterbuch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von den vorherigen Punkten, </font><font style="vertical-align: inherit;">sortieren </font><font style="vertical-align: inherit;">dann mithilfe der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foreach-Schleife</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alle Punkte, die wir von den Aufgaben erhalten haben, und fügen sie in das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knotenwörterbuch ein</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei der Schlüssel die Koordinaten ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NICHT die Position</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !) Des Punkts sind und der Wert der Punkt selbst ist. </font><font style="vertical-align: inherit;">Mit Hilfe dieses Wörterbuchs können wir leichter nach benachbarten Punkten auf der Karte suchen. </font><font style="vertical-align: inherit;">Nach dem Füllen löschen wir das Array- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispose-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">und am Ende löschen wir die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgabenliste selbst </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen auch die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grenzen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Hindernisse beseitigen, </font><font style="vertical-align: inherit;">wenn diese zuvor erstellt wurden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach all diesen Aktionen erhalten wir eine Liste aller Punkte auf der Karte und jetzt können Sie sie auf der Bühne zeichnen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungefähr so</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/65f/2d0/5a8/65f2d05a86a6a508900fcf321d546089.gif" alt="Bild"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen </font><font style="vertical-align: inherit;">Sie dazu in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">, in der </font><font style="vertical-align: inherit;">die Punkte </font><b><font style="vertical-align: inherit;">gezeichnet</font></b><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nun zeichnen wir durch die Schleife jeden Punkt. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); } } #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach all diesen Aktionen sieht unsere Karte irgendwie langweilig aus. Um wirklich ein Raster zu erhalten, müssen die Punkte miteinander verbunden sein. </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Mesh</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/460/01d/f10/46001df105fcb2bd9fb90ef382888f26.gif" alt="Bild"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für die Suche nach benachbarten Punkten müssen wir nur noch </font><font style="vertical-align: inherit;">den gewünschten Punkt durch seine Koordinaten in 8 Richtungen finden, so dass die Klasse </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine einfache statische Array Richtungen eingeleitet </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wegbeschreibung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Zellsuchverfahren für seine Koordinaten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly Vector2Int[] Directions = { Vector2Int.up, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), Vector2Int.right, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.down, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.left, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), }; <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node GetNode(Vector2Int coords) { Node result = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(Node); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes[coords]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verfahren </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kehrt Punkt zu den Koordinaten der Liste der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knoten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber es sollte , </font><font style="vertical-align: inherit;">weil sorgfältig durchgeführt werden , </font><font style="vertical-align: inherit;">wenn die Koordinaten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector2Int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falscher Fehler auftritt, werden also hier verwenden wir die Gruppenfrei Bypass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try catch - </font><font style="vertical-align: inherit;">Anweisung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die Bypass - </font><font style="vertical-align: inherit;">Ausnahme wird und nicht „ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hängen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ die gesamte Anwendung zum Scheitern verurteilt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes durchlaufen wir einen Zyklus in alle Richtungen und versuchen, benachbarte Punkte in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode zu finden. </font><font style="vertical-align: inherit;">Vergessen Sie vor allem nicht, die Durchgängigkeit des Punkts zu berücksichtigen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ondrawgizmos</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { Color c = Gizmos.color; foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Color newColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) newColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">153</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> newColor = Color.red; Gizmos.color = newColor; Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); newColor = Color.green; Gizmos.color = newColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Directions.Length; i++) { Vector2Int coords = node.coords + Directions[i]; Node connection = GetNode(coords); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.isWalkable) Gizmos.DrawLine(node.position, connection.position); } } } } Gizmos.color = c; } #endif</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können Sie das Spiel sicher starten und sehen, was passiert ist. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamische Karte</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/302/3ae/4e3/3023ae4e31ba9b2f888c27c4a9144ab7.gif" alt="Bild"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Beispiel haben wir nur das Diagramm selbst mithilfe von Aufgaben erstellt. Dies ist jedoch geschehen, nachdem ich den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Algorithmus selbst auf das System geschraubt habe </font><font style="vertical-align: inherit;">, der auch das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job-System verwendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um den Pfad und die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle am Ende des Artikels zu finden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karten- und Pfadsuche</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/769/46c/b2a76946c68d7af5dc30d3226e27b5a1.gif" alt="Bild"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So können Sie das neue Aufgabensystem für Ihre Ziele verwenden und ohne großen Aufwand interessante Systeme erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie im vorherigen Artikel wird das Task-System ohne </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS verwendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn Sie dieses System jedoch in Verbindung mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS verwenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , können Sie einfach erstaunliche Ergebnisse bei der Leistungssteigerung erzielen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel Glück</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pfadfinder-Projektquelle</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423601/">https://habr.com/ru/post/de423601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423589/index.html">Wie wir TTS zum Beispiel ausgewählt haben, klingt im Wörterbuch</a></li>
<li><a href="../de423591/index.html">Alte Lieder über die Hauptsache. Java und ausgehende Anfragen</a></li>
<li><a href="../de423593/index.html">Google kündigt einen Wettbewerb für Angriffe auf Bildverarbeitungsalgorithmen an</a></li>
<li><a href="../de423595/index.html">Frango Anomalie, Austausch</a></li>
<li><a href="../de423597/index.html">Wie und welche Cluster können im Kundenstamm zugeordnet werden?</a></li>
<li><a href="../de423603/index.html">RxSwift Teil 1</a></li>
<li><a href="../de423607/index.html">Linus Torvalds gibt seinen harten Stil auf und nimmt sich eine Auszeit</a></li>
<li><a href="../de423609/index.html">Wohin gehen Websites nach dem Tod? Persönliche Erfahrung</a></li>
<li><a href="../de423611/index.html">Ein-Klick-Zahlung - gut oder böse?</a></li>
<li><a href="../de423615/index.html">Von UX-Spezialisten geforderte Fachkenntnisse (Slice 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>