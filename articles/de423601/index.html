<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª ü§û üèáüèø Jobsystem und Suchpfad üåú üê¢ ‚òùÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Karte 
 In einem fr√ºheren Artikel habe ich mir angesehen, was das neue Job-System ist , wie es funktioniert, wie Aufgaben erstellt, mit Daten gef√ºllt ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jobsystem und Suchpfad</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423601/"><h3>  Karte </h3><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel habe</a> ich mir angesehen, was das neue <b>Job-System ist</b> , wie es funktioniert, wie Aufgaben erstellt, mit Daten gef√ºllt und Multithread-Berechnungen durchgef√ºhrt werden, und nur kurz erkl√§rt, wo Sie dieses System verwenden k√∂nnen.  In diesem Artikel werde ich versuchen, ein bestimmtes Beispiel zu analysieren, wo Sie dieses System verwenden k√∂nnen, um mehr Leistung zu erzielen. <br><a name="habracut"></a><br>  Da das System urspr√ºnglich mit dem Ziel entwickelt wurde, mit Daten zu arbeiten, eignet es sich hervorragend zur L√∂sung von Pfadfindungsaufgaben. <br><br>  <b>Unity</b> verf√ºgt bereits √ºber einen guten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NavMesh-Pfadfinder</a> , funktioniert jedoch nicht in 2D-Projekten, obwohl es viele vorgefertigte L√∂sungen f√ºr dasselbe <i>Asset gibt</i> .  Nun, und wir werden versuchen, nicht nur ein System zu erstellen, das nach Wegen auf der erstellten Karte sucht, sondern diese Karte auch dynamisch macht, so dass das System jedes Mal, wenn sich etwas daran √§ndert, eine neue Karte erstellt, und all dies werden wir nat√ºrlich mit berechnen ein neues System von Aufgaben, um den Haupt-Thread nicht zu laden. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr einen Systembetrieb</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/527/a69/ec1/527a69ec1543218ffe1df7c4b1deddb0.gif" alt="Bild"><br></div></div><br>  Im Beispiel wird ein Raster auf der Karte erstellt, es gibt einen Bot und ein Hindernis.  Das Raster wird jedes Mal neu erstellt, wenn wir Eigenschaften der Karte √§ndern, unabh√§ngig von ihrer Gr√∂√üe oder Position. <br><br>  F√ºr Flugzeuge habe ich einen einfachen <b>SpriteRenderer verwendet</b> . Diese Komponente verf√ºgt √ºber eine hervorragende <b>Grenzeigenschaft</b> , mit der Sie die Gr√∂√üe der Karte leicht ermitteln k√∂nnen. <br><br>  Das ist im Grunde alles f√ºr den Anfang, aber wir werden nicht aufh√∂ren und sofort zur Sache kommen. <br><br>  Beginnen wir mit den Skripten.  Und das erste ist das <b>Hindernishindernis-</b> Skript. <br><br><div class="spoiler">  <b class="spoiler_title">Hindernis</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  Innerhalb der <b>Hindernisklasse</b> erfassen wir alle √Ñnderungen an den Hindernissen auf der Karte, z. B. das √Ñndern der Position oder Gr√∂√üe eines Objekts. <br>  Als N√§chstes k√∂nnen Sie die <b>Map-</b> Map-Klasse erstellen, auf der das Raster erstellt wird, und es von der <b>Obstacle-</b> Klasse erben. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  Die <b>Map-</b> Klasse verfolgt auch alle √Ñnderungen auf der Map, um das Raster bei Bedarf neu zu erstellen. <br><br>  F√ºllen Sie dazu die <b>Hindernis-</b> Basisklasse mit allen erforderlichen Variablen und Methoden, um <b>Objekt√§nderungen</b> zu verfolgen. <br><br><div class="spoiler">  <b class="spoiler_title">Hindernis</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteRenderer renderer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempPos; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer = GetComponent&lt;SpriteRenderer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> virtual bool CheckChanges() { Vector2 newSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; float diff = (newSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = newSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } Vector2 newPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; diff = (newPos - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = newPos; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 size { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.bounds.size;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position;} } }</code> </pre> <br></div></div><br>  Hier hat die <b>Renderer-</b> Variable einen Verweis auf die <b>SpriteRenderer-</b> Komponente, und die <b>Variablen</b> <b>tempSize</b> und <b>tempPos</b> werden verwendet, um √Ñnderungen in der Gr√∂√üe und Position des Objekts zu verfolgen. <br><br>  Die virtuelle <b>Awake-</b> Methode wird zum Initialisieren der Variablen verwendet, und die virtuelle <b>CheckChanges-</b> Methode verfolgt die aktuellen √Ñnderungen der Gr√∂√üe und Position des Objekts und gibt ein <b>boolesches</b> Ergebnis zur√ºck. <br><br>  Lassen Sie uns zun√§chst das <b>Hindernis-</b> Skript und fahren Sie mit dem <b>Map-</b> Map-Skript selbst fort, in dem wir es auch mit den f√ºr die Arbeit erforderlichen Parametern f√ºllen. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); }</code> </pre> <br></div></div><br>  Die Variable <b>nodeSize</b> gibt die Gr√∂√üe der Zellen auf der Karte an. Hier habe ich ihre Gr√∂√üe von 0,1 auf 1 begrenzt, damit die Zellen im Raster nicht zu klein, sondern auch zu gro√ü sind.  Die <b>Versatzvariable</b> wird verwendet, um die Karte beim Erstellen des Rasters einzur√ºcken, sodass das Raster nicht entlang der Kanten der Karte erstellt wird. <br><br>  Da es jetzt zwei neue Variablen auf der Karte gibt, stellt sich heraus, dass ihre √Ñnderungen ebenfalls verfolgt werden m√ºssen.  <b>F√ºgen Sie dazu</b> einige Variablen hinzu und √ºberladen Sie die <b>CheckChanges-</b> Methode in der <b>Map-</b> Klasse. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> float tempNodeSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempOffset; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { base.Awake(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } }</code> </pre> <br></div></div><br>  Fertig.  Jetzt k√∂nnen Sie ein Kartensprite auf der B√ºhne erstellen und ein Kartenskript darauf werfen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d75/60f/db8/d7560fdb8abeb5f00a7a5e1ec5e444df.png" alt="Bild"><br><br>  Wir machen dasselbe mit einem Hindernis - erstellen Sie ein einfaches Sprite auf der B√ºhne und werfen Sie das <b>Hindernis-</b> Skript darauf. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/ffa/e8d/347ffae8dd2b4cd3a3a50c881d5674df.png" alt="Bild"><br><br>  Jetzt haben wir Kartenobjekte und Hindernisse auf der B√ºhne. <br><br>  Das Kartenskript ist f√ºr die Verfolgung aller √Ñnderungen auf der Karte verantwortlich. In der <b>Aktualisierungsmethode</b> √ºberpr√ºfen wir jeden Frame auf √Ñnderungen. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool requireRebuild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { UpdateChanges(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Daher <b>verfolgt die</b> Karte in der <b>UpdateChanges-</b> Methode nur die <b>bisherigen</b> √Ñnderungen.  Sie k√∂nnen das Spiel jetzt sogar starten und versuchen, die Gr√∂√üe der Karte oder den <b>Versatz</b> zu √§ndern, um sicherzustellen, dass alle √Ñnderungen nachverfolgt werden. <br><br>  Jetzt m√ºssen Sie die √Ñnderungen der Hindernisse selbst auf der Karte irgendwie verfolgen.  Dazu setzen wir jedes Hindernis in eine Liste auf der Karte, die wiederum jeden Frame in der <b>Update-</b> Methode aktualisiert. <br><br>  Erstellen Sie in der <b>Map-</b> Klasse eine Liste aller m√∂glichen Hindernisse auf der Map und einige statische Methoden, um sie zu registrieren. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map ObjInstance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Obstacle&gt; obstacles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Obstacle&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool RegisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle == Instance) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Contains(obstacle) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { Instance.obstacles.Add(obstacle); Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool UnregisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Remove(obstacle)) { Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjInstance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ObjInstance = FindObjectOfType&lt;Map&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjInstance; } } }</code> </pre> <br></div></div><br>  Bei der statischen <b>RegisterObstacle-</b> Methode registrieren wir ein neues Hindernishindernis auf der Karte und f√ºgen es der Liste hinzu. Zun√§chst ist jedoch zu ber√ºcksichtigen, dass die Karte selbst auch von der <b>Hindernisklasse</b> geerbt wird. Daher sollten wir pr√ºfen, ob wir versuchen, die Karte selbst als Hindernis zu registrieren. <br><br>  Die statische <b>UnregisterObstacle-</b> Methode beseitigt im Gegenteil das Hindernis aus der Karte und entfernt es aus der Liste, wenn wir zulassen, dass es zerst√∂rt wird. <br><br>  Gleichzeitig muss jedes Mal, wenn wir ein Hindernis zur Karte hinzuf√ºgen oder daraus entfernen, die Karte selbst neu erstellt werden. Setzen <b>Sie</b> daher nach Ausf√ºhrung dieser statischen Methoden die Variable <b>requireRebuild</b> auf <b>true</b> . <br><br>  <b>Um</b> von jedem Skript aus problemlos auf das <b>Map-</b> Skript zugreifen zu k√∂nnen, habe ich eine statische <b>Instanzeigenschaft erstellt</b> , die mir genau diese Instanz der <b>Map zur√ºckgibt</b> . <br><br>  <b>Kehren</b> wir nun zum <b>Hindernis-</b> Skript zur√ºck, in dem wir ein Hindernis auf der Karte registrieren. <b>F√ºgen</b> Sie dazu einige <b>OnEnable-</b> und <b>OnDisable-</b> Methoden hinzu. <br><br><div class="spoiler">  <b class="spoiler_title">Hindernis</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { Map.RegisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { Map.UnregisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br></div></div><br>  Jedes Mal, wenn wir beim Spielen auf der Karte ein neues Hindernis erstellen, wird es automatisch in der <b>OnEnable-</b> Methode registriert, wobei es beim <b>Erstellen</b> eines neuen Rasters ber√ºcksichtigt wird und wir uns in der <b>OnDisable-</b> Methode von der Karte <b>entfernen</b> , wenn es zerst√∂rt oder deaktiviert wird. <br><br>  Es bleibt nur die Verfolgung der √Ñnderungen der Hindernisse selbst im <b>Map-</b> Skript in der √ºberladenen <b>CheckChanges-</b> Methode. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } foreach(Obstacle obstacle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle.CheckChanges()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Jetzt haben wir eine Karte, Hindernisse - im Allgemeinen alles, was Sie zum Aufbau eines Gitters ben√∂tigen, und jetzt k√∂nnen Sie zum Wichtigsten √ºbergehen. <br><br><h4>  Vernetzung </h4><br>  Das Gitter ist in seiner einfachsten Form eine zweidimensionale Anordnung von Punkten.  Um es zu erstellen, m√ºssen Sie die Gr√∂√üe der Karte und die Gr√∂√üe der Punkte darauf kennen. Nach einigen Berechnungen erhalten wir die Anzahl der Punkte horizontal und vertikal. Dies ist unser Raster. <br><br>  Es gibt viele M√∂glichkeiten, einen Pfad in einem Raster zu finden.  In diesem Artikel geht es jedoch haupts√§chlich darum, zu verstehen, wie die Funktionen des Task-Systems korrekt verwendet werden. Daher werde ich hier nicht auf verschiedene Optionen zum Auffinden des Pfads sowie auf deren Vor- und Nachteile eingehen, sondern auf die einfachste Suchoption <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A *</a> . <br><br>  In diesem Fall sollten alle Punkte im Raster zus√§tzlich zur Position die Koordinaten- und Durchg√§ngigkeitseigenschaft aufweisen. <br><br>  Mit der Durchg√§ngigkeit denke ich, dass alles klar ist, warum es ben√∂tigt wird, aber die Koordinaten geben die Reihenfolge des Punktes auf dem Gitter an. Diese Koordinaten sind nicht spezifisch an die Position des Punktes im Raum gebunden.  Das Bild unten zeigt ein einfaches Raster, das die Unterschiede der Koordinaten von einer Position zeigt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/c12/466/7c1c124662f7c41ecb2a1c55939a1a64.png" alt="Bild"><br>  <i>Warum die Koordinaten?</i> <br>  Tatsache ist, dass in der Einheit ein einfaches <b>Float verwendet wird</b> , das sehr ungenau ist und eine gebrochene oder negative Zahl sein kann, um die Position eines Objekts im Raum anzuzeigen. <b>Daher ist</b> es schwierig, damit eine Pfadsuche auf der Karte zu implementieren.  Die Koordinaten werden in Form eines klaren <b>Int erstellt,</b> das immer positiv ist und mit dem bei der Suche nach benachbarten Punkten viel einfacher gearbeitet werden kann. <br><br>  Definieren wir zun√§chst ein <b>Punktobjekt</b> . Dies ist eine einfache <b>Knotenstruktur</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Knoten</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; }</code> </pre> <br></div></div><br>  Diese Struktur enth√§lt die Positionsposition in Form von <b>Vector2</b> , wobei wir mit dieser Variablen einen Punkt im Raum zeichnen.  Die Koordinatenkoordinatenvariable in Form von <b>Vector2Int</b> gibt die Koordinaten eines Punkts auf der Karte an, und die <b>ID-</b> Variable, ihre numerische Kontonummer, vergleicht verschiedene Punkte im Raster und pr√ºft, ob ein Punkt vorhanden ist. <br><br>  Die Durchg√§ngigkeit des Punktes wird in Form seiner <b>booleschen</b> Eigenschaft angegeben. Da wir die <i>konvertierbaren</i> Datentypen im Task-System jedoch nicht verwenden k√∂nnen, geben wir seine Durchg√§ngigkeit in Form einer <b>int-</b> Zahl an. Dazu habe ich eine einfache Aufz√§hlung <b>NodeType verwendet</b> , wobei: 0 kein passierbarer Punkt ist. und 1 ist passabel. <br><br><div class="spoiler">  <b class="spoiler_title">NodeType und Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enum NodeType { NonWalkable = <span class="hljs-number"><span class="hljs-number">0</span></span>, Walkable = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int nodeType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool isWalkable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType == (int)NodeType.Walkable;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node(int id, Vector2 position, Vector2Int coords, NodeType type) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coords = coords; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType = (int)type; } }</code> </pre> <br></div></div><br>  Um die Arbeit mit einem Punkt zu vereinfachen, werde ich die <b>Equals-</b> Methode √ºberladen, um den Vergleich von Punkten zu vereinfachen und die √úberpr√ºfungsmethode f√ºr die Existenz eines Punkts zu erg√§nzen. <br><br><div class="spoiler">  <b class="spoiler_title">Knoten</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool Equals(object obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Node) { Node other = (Node)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id == other.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.Equals(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> implicit operator bool(Node node) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br></div></div><br>  Da die <b>ID-</b> Nummer des Punkts im Raster mit 1 Einheit beginnt, √ºberpr√ºfe ich die Existenz des Punkts als Bedingung, dass seine <b>ID</b> gr√∂√üer als 0 ist. <br><br>  Gehen Sie zur <b>Map-</b> Klasse, wo wir alles f√ºr die Erstellung einer Map vorbereiten. <br>  Wir haben bereits eine √úberpr√ºfung f√ºr die √Ñnderung der Parameter der Karte, jetzt m√ºssen wir bestimmen, wie der Prozess des Aufbaus des Gitters ausgef√ºhrt wird.  Erstellen Sie dazu eine neue Variable und mehrere Methoden. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() {} <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Die <b>Neuerstellungseigenschaft</b> gibt an, ob der <b>Vernetzungsprozess ausgef√ºhrt</b> wird.  Die <b>Rebuild-</b> Methode sammelt Daten und Aufgaben zum <b>Erstellen</b> des Rasters, dann <b>startet</b> die <b>OnRebuildStart-</b> Methode den Grid- <b>Erstellungsprozess</b> und die <b>OnRebuildFinish-</b> Methode sammelt Daten aus den Aufgaben. <br><br>  Lassen Sie uns nun die <b>UpdateChanges-</b> Methode ein <b>wenig</b> √§ndern, damit die <b>Rasterbedingung</b> ber√ºcksichtigt wird. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(‚Äú  ...‚Äù); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(‚Äú !‚Äù); OnRebuildStart(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Wie Sie jetzt in der <b>UpdateChanges-</b> Methode sehen k√∂nnen, <b>gibt</b> es eine Bedingung, dass beim <b>Erstellen</b> des alten Netzes nicht mit dem <b>Erstellen</b> eines neuen Netzes begonnen wird. Auch bei der <b>Rebuild-</b> Methode pr√ºft die erste Aktion, ob der Vernetzungsprozess bereits ausgef√ºhrt wird. <br><br><h4>  Probleml√∂sung </h4><br>  Nun ein wenig √ºber den Prozess des Erstellens einer Karte. <br>  Da wir das Task-System verwenden und das Raster parallel erstellen, um die Map zu erstellen, habe ich den Typ der <b>IJobParallelFor-</b> Task verwendet, der eine bestimmte Anzahl von Malen ausgef√ºhrt wird.  Um den Konstruktionsprozess nicht mit einer separaten Aufgabe zu laden, verwenden wir den in einem <b>JobHandle</b> gepackten Aufgabenpool. <br><br>  Verwenden Sie zum Erstellen eines Rasters meistens zwei ineinander verschachtelte Zyklen, um beispielsweise horizontal und vertikal zu erstellen.  In diesem Beispiel wird das Raster auch zuerst horizontal und dann vertikal erstellt.  Dazu berechnen wir die Anzahl der horizontalen und vertikalen Punkte in der <b>Rebuild-</b> Methode. In der <b>Rebuild-</b> Methode durchlaufen wir den Zyklus entlang der vertikalen Punkte und erstellen in der Aufgabe parallel horizontale Punkte.  Schauen Sie sich die Animation unten an, um sich den Bauprozess besser vorzustellen. <br><br><div class="spoiler">  <b class="spoiler_title">Vernetzung</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/101/625/183/10162518305232afb889f9d8a45b70da.gif" alt="Bild"><br></div></div><br>  Die Anzahl der vertikalen Punkte gibt die Anzahl der Aufgaben an. Jede Aufgabe erstellt Punkte nur horizontal. Nach Abschluss aller Aufgaben werden die Punkte in einer Liste zusammengefasst.  Aus diesem Grund muss ich eine Aufgabe wie <b>IJobParallelFor verwenden</b> , um den Index des Punkts im Raster horizontal an die <b>Execute-</b> Methode zu √ºbergeben. <br><br>  Und so haben wir die Punktstruktur. Jetzt k√∂nnen Sie die Struktur der <b>Jobaufgabe</b> erstellen und von der <b>IJobParallelFor-</b> Schnittstelle erben. <b>Hier</b> ist alles einfach. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Wir kehren zur <b>Rebuild-</b> Methode der <b>Map-</b> Klasse zur√ºck, in der wir die erforderlichen Berechnungen f√ºr die Gittermessung durchf√ºhren. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(‚Äú !‚Äù); Vector2 mapSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset * <span class="hljs-number"><span class="hljs-number">2</span></span>f; int horizontals = Mathf.RoundToInt(mapSize.x / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); int verticals = Mathf.RoundToInt(mapSize.y / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontals &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { OnRebuildFinish(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); OnRebuildStart(); } <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Bei der <b>Rebuild-</b> Methode berechnen wir die genaue Gr√∂√üe der <b>mapSize-</b> Karte unter Ber√ºcksichtigung der Einr√ºckung. In <b>Vertikalen</b> schreiben wir dann die Anzahl der Punkte vertikal und in <b>Horizontalen die</b> Anzahl der Punkte horizontal.  Wenn die Anzahl der vertikalen Punkte 0 ist, beenden wir die <b>Erstellung</b> der Karte und rufen die <b>OnRebuildFinish-</b> Methode auf, um den Vorgang abzuschlie√üen.  Die <b>Ursprungsvariable</b> gibt den Ort an, von dem aus wir mit dem Erstellen des Rasters beginnen. Im Beispiel ist dies der untere linke Punkt auf der Karte. <br><br>  Jetzt k√∂nnen Sie zu den Aufgaben selbst gehen und sie mit Daten f√ºllen. <br>  W√§hrend des Aufbaus des Rasters ben√∂tigt die Aufgabe ein <b>NativeArray-</b> Array, in dem wir die Punkte platzieren. Da wir Hindernisse auf der Karte haben, m√ºssen wir sie auch an die Aufgabe √ºbergeben. Dazu verwenden wir ein anderes <b>NativeArray-</b> Array. Dann ben√∂tigen wir die Gr√∂√üe der Punkte im Problem , die Anfangsposition, von der aus wir die Punkte erstellen, sowie die Anfangskoordinaten der Reihe. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Node&gt; array; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 startPos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int startCoords; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Ich habe das Array von Punkten mit dem Attribut <b>WriteOnly markiert,</b> da in der Aufgabe nur die empfangenen Punkte in das Array " <i>geschrieben</i> " werden m√ºssen. Im Gegensatz dazu wird das Array der Hindernisgrenzen mit dem Attribut <b>ReadOnly markiert,</b> da in der Aufgabe nur Daten aus diesem Array " <i>gelesen</i> " werden. <br><br>  Lassen Sie uns zun√§chst mit der Berechnung der Punkte selbst fortfahren. <br><br>  Nun zur√ºck zur <b>Map-</b> Klasse, in der wir alle an den Aufgaben beteiligten Variablen bezeichnen. <br>  Hier ben√∂tigen wir zun√§chst ein globales <b>Handle von</b> Aufgaben, eine Reihe von Hindernissen in Form von <b>NativeArray</b> , eine Liste von Aufgaben, die alle im Raster und im <b>W√∂rterbuch</b> empfangenen Punkte mit allen Koordinaten und Punkten auf der Karte enthalten, damit es sp√§ter bequemer ist, nach ihnen zu suchen. <br><br><div class="spoiler">  <b class="spoiler_title">Karte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt; jobs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2Int, Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2Int, Node&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Nun kehren wir wieder zur <b>Rebuild-</b> Methode zur√ºck und bauen das Grid weiter auf. <br>  Initialisieren Sie zun√§chst das <b>Begrenzungsarray</b> von Hindernissen, um es an die Aufgabe weiterzuleiten. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Hier erstellen wir eine Instanz von <b>NativeArray</b> √ºber einen neuen Konstruktor mit drei Parametern.  Ich habe die ersten beiden Parameter in einem fr√ºheren Artikel untersucht, aber der dritte Parameter hilft uns, ein wenig Zeit beim Erstellen eines Arrays zu sparen.  Tatsache ist, dass wir Daten unmittelbar nach ihrer Erstellung in das Array schreiben, was bedeutet, dass wir nicht sicherstellen m√ºssen, dass es gel√∂scht wird.  Dieser Parameter ist n√ºtzlich f√ºr <b>NativeArray,</b> das in der Task nur im Lesemodus verwendet wird. <br><br>  Und so f√ºllen wir das <b>Bounds-</b> Array mit Daten. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Jetzt k√∂nnen wir mit dem Erstellen von Aufgaben fortfahren. Dazu durchlaufen wir einen Zyklus durch alle vertikalen Zeilen des Rasters. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Zun√§chst <b>erhalten</b> wir in <b>xPos</b> und <b>yPos</b> die anf√§ngliche horizontale Position der Serie. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Als N√§chstes erstellen wir ein einfaches <b>NativeArray-</b> Array, in dem die Punkte in der Aufgabe platziert werden. Hier m√ºssen Sie f√ºr das Array- <b>Array</b> angeben, wie viele Punkte horizontal erstellt werden und welche Art der Zuordnung <b>dauerhaft ist</b> , da die Aufgabe l√§nger als ein Frame dauern kann. <br>  Erstellen Sie anschlie√üend die <b>Job-</b> Task-Instanz selbst, setzen Sie die Anfangskoordinaten der <b>startCoords-</b> Reihe, die Anfangsposition der <b>startPos-</b> Reihe, die Gr√∂√üe der <b>nodeSize-</b> Punkte, das <b>Begrenzungsarray</b> von Hindernissen und das Array von Punkten selbst am Ende. <br>  Es bleibt nur die Aufgabe in <b>Handle</b> und die globale Aufgabenliste zu setzen. <br><br><div class="spoiler">  <b class="spoiler_title">Wiederaufbauen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(horizontals, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Add(array); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Fertig.  Wir haben eine Liste von Aufgaben und deren allgemeinem <b>Handle</b> . Jetzt k√∂nnen wir dieses <b>Handle</b> ausf√ºhren <b>, indem</b> wir die <b>Complete-</b> Methode in der <b>OnRebuildStart-</b> Methode <b>aufrufen</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Onrebuildstart</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  Da die <b>Wiederherstellungsvariable</b> anzeigt, dass der <b>Vernetzungsprozess ausgef√ºhrt</b> wird, muss die <b>UpdateChanges-</b> Methode <b>selbst</b> auch die Bedingung angeben, wann dieser Prozess unter Verwendung des <b>Handles</b> und seiner <b>IsCompleted-</b> Eigenschaft beendet wird. <br><br><div class="spoiler">  <b class="spoiler_title">Update-√Ñnderungen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(‚Äú  ...‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) OnRebuildFinish(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } }</code> </pre> <br></div></div><br>  Nach Abschluss der Aufgaben wird die <b>OnRebuildFinish-</b> Methode aufgerufen, bei der die empfangenen Punkte bereits in einer allgemeinen <b>W√∂rterbuchliste</b> gesammelt werden und vor allem die belegten Ressourcen <b>gel√∂scht</b> werden. <br><br><div class="spoiler">  <b class="spoiler_title">OnRebuildFinish</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Clear(); foreach (NativeArray&lt;Node&gt; array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs) { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Add(node.coords, node); array.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.IsCreated) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst l√∂schen wir das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knotenw√∂rterbuch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von den vorherigen Punkten, </font><font style="vertical-align: inherit;">sortieren </font><font style="vertical-align: inherit;">dann mithilfe der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foreach-Schleife</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alle Punkte, die wir von den Aufgaben erhalten haben, und f√ºgen sie in das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knotenw√∂rterbuch ein</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei der Schl√ºssel die Koordinaten ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NICHT die Position</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !) Des Punkts sind und der Wert der Punkt selbst ist. </font><font style="vertical-align: inherit;">Mit Hilfe dieses W√∂rterbuchs k√∂nnen wir leichter nach benachbarten Punkten auf der Karte suchen. </font><font style="vertical-align: inherit;">Nach dem F√ºllen l√∂schen wir das Array- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispose-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">und am Ende l√∂schen wir die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgabenliste selbst </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen auch die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grenzen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Hindernisse beseitigen, </font><font style="vertical-align: inherit;">wenn diese zuvor erstellt wurden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach all diesen Aktionen erhalten wir eine Liste aller Punkte auf der Karte und jetzt k√∂nnen Sie sie auf der B√ºhne zeichnen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungef√§hr so</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/65f/2d0/5a8/65f2d05a86a6a508900fcf321d546089.gif" alt="Bild"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen </font><font style="vertical-align: inherit;">Sie dazu in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><font style="vertical-align: inherit;">, in der </font><font style="vertical-align: inherit;">die Punkte </font><b><font style="vertical-align: inherit;">gezeichnet</font></b><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nun zeichnen wir durch die Schleife jeden Punkt. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); } } #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach all diesen Aktionen sieht unsere Karte irgendwie langweilig aus. Um wirklich ein Raster zu erhalten, m√ºssen die Punkte miteinander verbunden sein. </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Mesh</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/460/01d/f10/46001df105fcb2bd9fb90ef382888f26.gif" alt="Bild"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr die Suche nach benachbarten Punkten m√ºssen wir nur noch </font><font style="vertical-align: inherit;">den gew√ºnschten Punkt durch seine Koordinaten in 8 Richtungen finden, so dass die Klasse </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine einfache statische Array Richtungen eingeleitet </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wegbeschreibung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Zellsuchverfahren f√ºr seine Koordinaten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly Vector2Int[] Directions = { Vector2Int.up, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), Vector2Int.right, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.down, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.left, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), }; <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node GetNode(Vector2Int coords) { Node result = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(Node); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes[coords]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verfahren </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kehrt Punkt zu den Koordinaten der Liste der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knoten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber es sollte , </font><font style="vertical-align: inherit;">weil sorgf√§ltig durchgef√ºhrt werden , </font><font style="vertical-align: inherit;">wenn die Koordinaten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector2Int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falscher Fehler auftritt, werden also hier verwenden wir die Gruppenfrei Bypass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try catch - </font><font style="vertical-align: inherit;">Anweisung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die Bypass - </font><font style="vertical-align: inherit;">Ausnahme wird und nicht ‚Äû </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√§ngen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äú die gesamte Anwendung zum Scheitern verurteilt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes durchlaufen wir einen Zyklus in alle Richtungen und versuchen, benachbarte Punkte in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode zu finden. </font><font style="vertical-align: inherit;">Vergessen Sie vor allem nicht, die Durchg√§ngigkeit des Punkts zu ber√ºcksichtigen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ondrawgizmos</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { Color c = Gizmos.color; foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Color newColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) newColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">153</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> newColor = Color.red; Gizmos.color = newColor; Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); newColor = Color.green; Gizmos.color = newColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Directions.Length; i++) { Vector2Int coords = node.coords + Directions[i]; Node connection = GetNode(coords); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.isWalkable) Gizmos.DrawLine(node.position, connection.position); } } } } Gizmos.color = c; } #endif</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen Sie das Spiel sicher starten und sehen, was passiert ist. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamische Karte</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/302/3ae/4e3/3023ae4e31ba9b2f888c27c4a9144ab7.gif" alt="Bild"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Beispiel haben wir nur das Diagramm selbst mithilfe von Aufgaben erstellt. Dies ist jedoch geschehen, nachdem ich den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Algorithmus selbst auf das System geschraubt habe </font><font style="vertical-align: inherit;">, der auch das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job-System verwendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um den Pfad und die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle am Ende des Artikels zu finden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karten- und Pfadsuche</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/769/46c/b2a76946c68d7af5dc30d3226e27b5a1.gif" alt="Bild"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So k√∂nnen Sie das neue Aufgabensystem f√ºr Ihre Ziele verwenden und ohne gro√üen Aufwand interessante Systeme erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie im vorherigen Artikel wird das Task-System ohne </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS verwendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn Sie dieses System jedoch in Verbindung mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS verwenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , k√∂nnen Sie einfach erstaunliche Ergebnisse bei der Leistungssteigerung erzielen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel Gl√ºck</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pfadfinder-Projektquelle</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423601/">https://habr.com/ru/post/de423601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423589/index.html">Wie wir TTS zum Beispiel ausgew√§hlt haben, klingt im W√∂rterbuch</a></li>
<li><a href="../de423591/index.html">Alte Lieder √ºber die Hauptsache. Java und ausgehende Anfragen</a></li>
<li><a href="../de423593/index.html">Google k√ºndigt einen Wettbewerb f√ºr Angriffe auf Bildverarbeitungsalgorithmen an</a></li>
<li><a href="../de423595/index.html">Frango Anomalie, Austausch</a></li>
<li><a href="../de423597/index.html">Wie und welche Cluster k√∂nnen im Kundenstamm zugeordnet werden?</a></li>
<li><a href="../de423603/index.html">RxSwift Teil 1</a></li>
<li><a href="../de423607/index.html">Linus Torvalds gibt seinen harten Stil auf und nimmt sich eine Auszeit</a></li>
<li><a href="../de423609/index.html">Wohin gehen Websites nach dem Tod? Pers√∂nliche Erfahrung</a></li>
<li><a href="../de423611/index.html">Ein-Klick-Zahlung - gut oder b√∂se?</a></li>
<li><a href="../de423615/index.html">Von UX-Spezialisten geforderte Fachkenntnisse (Slice 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>