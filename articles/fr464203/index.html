<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëºüèø üë©üèΩ‚Äçü§ù‚Äçüë®üèª üóûÔ∏è Cr√©ation d'une n√©buleuse de pixels √† l'aide du bruit et de la coupe m√©diane ‚ôüÔ∏è ü¶á ü§≤üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je voulais une n√©buleuse dans mon jeu The Last Boundary . Ils ont l'air incroyables et l'espace sans eux n'est pas de l'espace, mais simplement des pi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'une n√©buleuse de pixels √† l'aide du bruit et de la coupe m√©diane</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464203/">  Je voulais une n√©buleuse dans mon jeu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Last Boundary</a> .  Ils ont l'air incroyables et l'espace sans eux n'est pas de l'espace, mais simplement des pixels blancs dispers√©s autour de l'arri√®re-plan.  Mais comme je cr√©e le jeu dans le style du "pixel art", je devais en quelque sorte faire en sorte que ma biblioth√®que de bruit g√©n√®re des images pixelis√©es. <br><br>  Voici quelques exemples: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/65f/7fd/f2e65f7fd23c0fe2fcfafcc0fcf62a3e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/358/ef9/665358ef9f488bb63d7ced8ea7dfd45d.png"></div><br><div class="spoiler">  <b class="spoiler_title">Plus d'exemples</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/d6e/4ab/b88d6e4ab783d2d67f0f0f6e7e38536f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/705/d13/40b/705d1340be1c918a6a6e9b22d3ae416f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/daa/1c7/1ba/daa1c71bade101b11ec6025a87ca30a4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/d8c/5f9/00bd8c5f9fa01ef5a90282a2d2897de3.png"></div><br></div></div><br>  Dans les exemples monochromes, 8 couleurs sont utilis√©es et dans d'autres, 16 couleurs.  Dans cet article, je vais vous expliquer comment j'ai cr√©√© une n√©buleuse pix√©lis√©e pour The Last Boundary. <br><a name="habracut"></a><br>  Lorsque nous travaillons avec une biblioth√®que de bruit, telle que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LibNoise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">que soit le</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur que</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous</a> utilisez (ou √©crivez le v√¥tre), les valeurs sont g√©n√©ralement r√©parties dans la plage de <code>-1</code> √† <code>1</code> .  Il est th√©oriquement plus probable que le bruit 2D soit compris entre <code>-0.7</code> et <code>0.7</code> , mais certaines impl√©mentations mettent le r√©sultat √† l'√©chelle, le traduisant dans l'intervalle de <code>-1</code> √† <code>1</code> .  Pour travailler avec des textures 2D, il est g√©n√©ralement converti en un intervalle de <code>0</code> √† <code>1</code> , puis il se <code>RGB(255,255,255)</code> dans la plage de <code>RGB(0,0,0)</code> √† <code>RGB(255,255,255)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Bruit Perlin g√©n√©r√© √† partir des coordonn√©es <code>x,y</code> de chaque pixel mis √† l'√©chelle √† <code>0.3f</code></i> <br><br>  Ensuite, vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le mouvement brownien fractionnaire</a> pour donner √† l'image une sensation de splendeur des nuages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/910/a74/aed910a745d77af8d1cfa816990276a5.png"></div><br>  <i>Le bruit de Perlin a √©t√© soumis √† un mouvement brownien fractionnaire avec <code>8</code> octaves, fr√©quence <code>0.01</code> , r√©gularit√© <code>0.5</code> et lacunarit√© <code>2.0</code> .</i> <br><br><blockquote>  J'ai remarqu√© qu'il existe de nombreuses impl√©mentations incorrectes du bruit Perlin, du bruit simplex et du mouvement brownien fractionnaire (fBm) sur Internet.  Il semble y avoir beaucoup de confusion sur ce qui est quoi.  Assurez-vous que vous utilisez l'impl√©mentation correcte, car si vous souhaitez cr√©er la cha√Æne d√©crite ci-dessus, en cas d'impl√©mentation incorrecte, vous risquez de ne pas obtenir les r√©sultats requis. </blockquote><br>  Imaginons que nous voulons cr√©er un effet de fum√©e, c'est-√†-dire qu'une telle solution nous convienne.  Mais notre jeu de pixel art aurait l'air √©trange si tout un tas de nouvelles couleurs y apparaissaient de <code>RGB(0,0,0)</code> √† <code>RGB(255,255,255)</code> .  Soudain, 255 nouveaux grades de gris appara√Ætront dans le jeu. <br><br>  Nous devons les convertir en un nombre limit√© de couleurs.  C'est ce que nous ferons plus tard.  En attendant ... <br><br><h2>  G√©n√©rer une n√©buleuse al√©atoire </h2><br>  J'ai r√©p√©t√© pour des didacticiels pr√™ts √† l'emploi sur la g√©n√©ration de n√©buleuses al√©atoires, mais j'ai ajout√© certaines de mes √©tapes et appliqu√© ma propre biblioth√®que de bruit.  Je l‚Äôai √©crit il y a quelques ann√©es parce que je voulais bien comprendre le bruit de Perlin et comment l‚Äôutiliser avec d‚Äôautres concepts pour cr√©er des textures, etc. <br><br>  Peut-√™tre pouvez-vous r√©p√©ter √©tape par √©tape apr√®s moi ou vous devrez faire des ajouts au code qui affecteront votre bruit.  Je vais tout expliquer sauf la g√©n√©ration de bruit initiale et fBm pour que vous puissiez √©crire le code vous-m√™me;  Je pense que l'on peut supposer que vous avez d√©j√† la capacit√© de g√©n√©rer du bruit et du fBm. <br><br>  Pour commencer, je vais montrer le r√©sultat de la g√©n√©ration de la n√©buleuse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>R√©sultat fini</i> <br><br>  Il est important de noter qu'il n'est pas encore pixellis√©.  Il a une gamme compl√®te de couleurs avec un ciel √©toil√© pix√©lis√©.  La n√©buleuse nous pixelliserons plus tard. <br><br>  La premi√®re chose √† faire est de g√©n√©rer cinq textures diff√©rentes: rouge, verte, bleue, alpha et masque.  Les textures rouge, verte et bleue sont n√©cessaires pour les canaux de couleur finale correspondants.  En fait, je ne g√©n√®re qu'un ou deux canaux de couleur, car il s'est av√©r√© que l'utilisation des trois produit une n√©buleuse incroyablement color√©e qui a l'air moche.  Toute couleur unique ou une combinaison de deux couleurs fera bien l'affaire. <br><br>  Le canal Alpha est important car cela d√©pend si les √©toiles inf√©rieures brillent √† travers la n√©buleuse.  Je vais illustrer cela en affichant le canal alpha de l'exemple ci-dessus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Canal alpha pr√™t de notre exemple</i> <br><br>  Plus la zone est blanche, plus la valeur est proche de <code>1.0</code> , ce qui nous donne une valeur alpha de <code>255</code> .  Plus la zone est noire, plus elle est transparente.  Si vous regardez un exemple, vous pouvez voir que les zones noires correspondent aux zones dans lesquelles le ciel √©toil√© est visible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/7d2/7ad/de97d27adeaaebdbfc8a5b5857bab02f.png"></div><br>  <i>Exemple de ciel √©toil√©</i> <br><br>  Ce ne sont pas les m√™mes √©toiles que dans l'exemple, car elles sont g√©n√©r√©es al√©atoirement dans chaque capture d'√©cran.  J'esp√®re que cela ne vous emp√™che pas de comprendre comment la n√©buleuse est g√©n√©r√©e. <br><br>  Ma biblioth√®que de bruit se compose de modules, suivant l'exemple de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lib Noise</a> .  Tout dans cette biblioth√®que est constitu√© de ¬´modules¬ª qui peuvent √™tre encha√Æn√©s ensemble.  Certains modules g√©n√®rent de nouvelles valeurs (module Perlin, valeur constante), d'autres les connectent (multiplication, ajout) et certains effectuent simplement des op√©rations sur la valeur (Lerp, Clamp). <br><br><h3>  Canaux de couleur </h3><br>  Peu importe que nous travaillions avec une, deux ou trois couleurs - les canaux rouge, vert et bleu sont g√©n√©r√©s de la m√™me mani√®re;  J'utilise juste une valeur de graine diff√©rente pour eux.  Mes valeurs de d√©part d√©pendent de l'heure actuelle du syst√®me. <br><br>  Ci-dessous, ils sont tous pr√©sent√©s en niveaux de gris, mais th√©oriquement, ce sont simplement des valeurs pour l'un des trois canaux.  Niveaux de gris est juste l√† pour illustrer les r√©sultats. <br><br><h4>  1. Le bruit de Perlin </h4><br>  Comme ci-dessus, le bruit de Perlin sera le point de d√©part.  Si vous voulez, vous pouvez utiliser du bruit simplex, il semble que son impl√©mentation 2D n'appartienne pas √† Ken Perlin, mais je peux me tromper.  D'un point de vue math√©matique, le bruit simplex utilise moins d'instructions, donc la g√©n√©ration d'une n√©buleuse similaire sera plus rapide.  Puisqu'il utilise des simplexes au lieu d'une grille, il cr√©e un bruit l√©g√®rement plus beau, mais nous ne travaillerons pas beaucoup avec, donc ce n'est pas particuli√®rement important. <br><br>  Le code r√©el n'est pas illustr√© ci-dessous, car dans les sources r√©elles <code>x,y</code> valeurs <code>x,y</code> ont √©t√© modifi√©es par fBm √† l'√©tape 3. Il s'agit simplement de la coordonn√©e <code>x,y</code> de l'image, multipli√©e par le facteur d'√©chelle statique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Bruit Perlin g√©n√©r√© √† partir des coordonn√©es <code>x,y</code> de chaque pixel mis √† l'√©chelle √† <code>0.3f</code> .</i>  <i>C'est-√†-dire</i> <i><code>PixelValue = PerlinNoise(x * 0.3f, y * 0.3f)</code></i> <br><br>  Les valeurs cr√©√©es par le bruit Perlin se situent approximativement dans la plage de <code>-1</code> √† <code>1</code> , donc pour cr√©er l'image en niveaux de gris habituelle illustr√©e ci-dessus, nous les convertissons √† l'intervalle de <code>0</code> √† <code>1</code> .  J'ai test√© la port√©e des valeurs afin que la conversion produise le plus grand contraste (la valeur la plus basse correspond √† <code>0</code> , la plus grande - <code>1</code> ). <br><br><h4>  2. Multiplication </h4><br>  Le module suivant utilis√© multiplie le bruit g√©n√©r√© par <code>5</code> .  Cela peut √™tre consid√©r√© comme un ajustement du contraste.  Les valeurs n√©gatives sont plus sombres, les valeurs positives sont plus claires. <br><br>  Je n'ai rien √† montrer ici, car dans le processus de conversion des valeurs de l'intervalle de <code>-5</code> √† <code>5</code> √† l'intervalle de <code>0</code> √† <code>1</code> r√©sultat ne change pas. <br><br><h4>  3. Mouvement brownien fractionnaire (fBM) </h4><br>  Cette √©tape transforme le bruit en ce que beaucoup de gens consid√®rent comme un v√©ritable ¬´effet de bruit¬ª.  Ici, nous ex√©cutons des octaves d'√©chantillons de plus en plus petits √† partir de la fonction de bruit (dans notre cas, la fonction est <code>perlin(x,y)</code> ) pour ajouter du fluffiness. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/388/634/15b/38863415ba86694f3acc86618e7173d2.png"></div><br>  <i>Mouvement brownien fractionnaire du bruit Perlin illustr√© ci-dessus.</i>  <i><code>8</code> octaves, fr√©quence <code>.01f</code> , r√©gularit√© <code>.5f</code> et <code>2.5f</code></i> <br><br>  Vous pouvez d√©j√† voir l'origine de quelque chose d'int√©ressant.  L'image ci-dessus n'est pas g√©n√©r√©e en mettant √† l'√©chelle les coordonn√©es <code>x,y</code> des pixels, fBM le fait.  Encore une fois, ces valeurs sont inversement converties en un intervalle de <code>0</code> √† <code>1</code> en un intervalle possible de <code>-5</code> √† <code>5</code> . <br><br><h4>  4. Restriction (pince) </h4><br>  Je vais maintenant limiter les valeurs √† une plage de <code>-1</code> √† <code>1</code> .  Tout ce qui se trouve en dehors de cet intervalle sera compl√®tement rejet√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/f7a/b80/623f7ab80bc886e62d416726bcb63a09.png"></div><br>  <i>Le m√™me fBm, limit√© √† <code>-1</code> √† <code>1</code></i> <br><br>  La t√¢che de cette op√©ration est de convertir les valeurs en un intervalle plus court tout en cr√©ant des d√©grad√©s plus nets et en augmentant la zone en blanc ou en noir.  Ces zones mortes ou vides sont importantes pour l'effet de n√©buleuse, que nous aborderons plus tard.  Si nous n'avions pas multipli√© par <code>5</code> au d√©but, alors la pince n'aurait rien chang√©. <br><br><h4>  5. Ajoutez 1 </h4><br>  Maintenant, nous prenons les valeurs de clamp et nous y ajoutons 1. Ainsi, nous transf√©rons les valeurs dans l'intervalle de <code>0</code> √† <code>2</code> .  Apr√®s la conversion, les r√©sultats seront les m√™mes qu'avant. <br><br><h4>  6. Divisez par 2 </h4><br>  Vous savez probablement ce qui se passera lorsque je divise le r√©sultat par <code>2</code> (multipliez par <code>.5</code> ).  Dans l'image, rien ne changera √† nouveau. <br><br>  Les √©tapes 5 et 6 convertissent les valeurs dans une plage de <code>0</code> √† <code>1</code> . <br><br><h4>  7. Cr√©ez une texture de distorsion </h4><br>  L'√©tape suivante consiste √† cr√©er une texture de distorsion.  Je vais le faire avec du bruit Perlin (avec la nouvelle valeur de d√©part)&gt; multiplier par 4&gt; ex√©cuter fBm.  Dans ce cas, fBm utilise <code>5</code> octaves, une fr√©quence de <code>0.025</code> , une r√©gularit√© de <code>0.5</code> et une lacunarit√© de <code>1.5</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/937/748/b34937748b4e87736c9f09f464bc99dd.png"></div><br>  <i>Texture de distorsion</i> <br><br>  Cette texture est n√©cessaire pour cr√©er plus de d√©tails que dans la texture existante de la n√©buleuse.  La n√©buleuse est un nuage ondul√© assez grand, et cette texture y apportera de petits changements.  √Ä travers elle, la nature de grille du bruit de Perlin commencera √† √©merger. <br><br><h4>  8. D√©calez la texture de couleur en utilisant la texture de d√©calage </h4><br>  Ensuite, je vais prendre ces deux textures et utiliser l'une pour compenser les coordonn√©es de l'autre par un facteur.  Dans notre cas, la combinaison ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>R√©sultat de biais</i> <br><br>  La texture de distorsion est utilis√©e pour modifier les coordonn√©es <code>x,y</code> nous recherchons dans les donn√©es de bruit source. <br><br>  N'oubliez pas que les images ci-dessus sont uniquement √† titre d'illustration.  √Ä chaque √©tape, nous n'avons en fait qu'une fonction de bruit.  Nous lui passons la valeur <code>x,y</code> et il renvoie un nombre.  √Ä certaines √©tapes, l'intervalle de ce nombre peut √™tre diff√©rent, mais ci-dessus, nous l'avons reconverti en niveaux de gris pour cr√©er une image.  L'image est cr√©√©e en utilisant chaque coordonn√©e <code>x,y</code> de l'image comme <code>x,y</code> , transmise par la fonction de bruit. <br><br>  Autrement dit, lorsque nous disons: <br><br><blockquote>  Donnez-moi la valeur du pixel du coin sup√©rieur gauche avec X = 0 et Y = 0 </blockquote><br>  La fonction nous renvoie un nombre.  Si nous demandons cela √† Perlin, nous savons que ce sera entre <code>-1</code> et <code>1</code> , si, comme ci-dessus, nous appliquons la pince, l'addition et la multiplication, nous obtenons une valeur entre <code>0</code> et <code>1</code> . <br><br>  Apr√®s avoir compris cela, nous apprenons que la fonction de bruit de distorsion cr√©e des valeurs dans la plage de <code>-1</code> √† <code>1</code> .  Par cons√©quent, pour effectuer le biais lorsque nous disons: <br><br><blockquote>  Donnez-moi la valeur du pixel dans le coin sup√©rieur gauche avec le pixel X = 0 et Y = 0 </blockquote><br>  le module de d√©calage demande d'abord √† la fonction de d√©calage les coordonn√©es <code>x,y</code> .  Le r√©sultat est compris entre <code>-1</code> et <code>1</code> (comme c'√©tait le cas ci-dessus).  Il est ensuite multipli√© par <code>40</code> (c'est le <em>coefficient que</em> j'ai s√©lectionn√©).  Le r√©sultat sera une valeur comprise entre <code>-40</code> et <code>40</code> . <br><br>  Ensuite, nous prenons cette valeur et l'ajoutons aux coordonn√©es des <code>x,y</code> que nous recherchions, et utilisons ce r√©sultat pour rechercher la texture de la couleur.  Nous avons coup√© les valeurs n√©gatives avec une pince √† 0, car il est impossible de rechercher des coordonn√©es <code>x,y</code> n√©gatives dans les fonctions de bruit (au moins dans ma biblioth√®que de bruit). <br><br>  Autrement dit, cela ressemble √† ceci: <br><br><pre> <code class="cpp hljs">ColourFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DisplaceFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">-1</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DoDisplace(x,y) = { v = DisplaceFunction(x,y) * factor clamp(v,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>) x = x + v; y = y + v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ColourFunction(x,y) }</code> </pre> <br>  J'esp√®re que vous comprenez cela.  En fait, nous ne regardons pas le <code>x,y</code> lequel nous √©tions, mais le d√©calage.  Et puisque la <em>magnitude</em> est √©galement un gradient lisse, elle se d√©place en douceur. <br><br>  Il existe d'autres fa√ßons d'effectuer le d√©calage.  Ma biblioth√®que de bruit a un module qui cr√©e un d√©placement en spirale.  Il peut √™tre utilis√© pour dessiner une texture, diminuant progressivement jusqu'√† un certain nombre de points.  <a href="">Voici un exemple</a> . <br><br>  C‚Äôest tout.  Nous r√©p√©tons les op√©rations ci-dessus trois fois, en utilisant de nouvelles valeurs de d√©part pour chaque canal de couleur.  Vous pouvez cr√©er un ou deux canaux.  Je ne pense pas que √ßa vaille la peine d'en cr√©er un troisi√®me. <br><br><h3>  Canal alpha </h3><br>  Un canal alpha est cr√©√© de la m√™me mani√®re que les canaux de couleur: <br><br><ol><li>  On commence par le bruit de Perlin </li><li>  Multipliez par <code>5</code> </li><li>  fBM avec <code>8</code> octaves, fr√©quence <code>0.005</code> , r√©gularit√© <code>0.5</code> et lacunarit√© <code>2.5</code> </li><li>  Nous limitons les r√©sultats en utilisant Clamp √† l'intervalle de <code>-1</code> √† <code>1</code> , ajoutons <code>1</code> , divisons par <code>2</code> (c'est-√†-dire que nous d√©calons l'intervalle de <code>-1</code> √† <code>1</code> √† l'intervalle de <code>0</code> √† <code>1</code> . </li><li>  Nous d√©calons l√©g√®rement le r√©sultat dans le sens n√©gatif.  J'ai compens√© de <code>0.4</code> .  Gr√¢ce √† cela, tout devient un peu plus sombre. </li><li>  Nous limitons les r√©sultats √† un intervalle de <code>0</code> √† <code>1</code> .  Puisque nous avons tout d√©plac√©, le rendant un peu plus sombre, en fait, nous avons cr√©√© plus de zones avec <code>0</code> , et certaines zones sont entr√©es dans des valeurs n√©gatives. </li></ol><br>  Le r√©sultat est une texture de canal alpha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Texture alpha</i> <br><br>  Comme je l'ai dit, les zones noires seront transparentes et les zones blanches seront opaques. <br><br><h3>  Masques de canal </h3><br>  Il s'agit de la derni√®re texture utilis√©e pour cr√©er des ombres superpos√©es sur tout le reste.  Cela commence comme toutes les autres textures: <br><br><ol><li>  Perlin de bruit </li><li>  Multipliez par <code>5</code> </li><li>  Nous effectuons fBm, <code>5</code> octaves, fr√©quence <code>0.01</code> , r√©gularit√© <code>0.1</code> , lacunarit√© <code>0.1</code> .  La r√©gularit√© est faible, donc le nuage est moins dense </li><li>  Effectuer un d√©calage d'intervalle de <code>-1</code> √† <code>1</code> √† un intervalle de <code>0</code> √† <code>1</code> </li></ol><br>  Mais nous cr√©ons deux de ces textures: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/11f/862/63011f8620c86a9bbf2f80d038a7c157.png"></div><br>  <i>Masquer un</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/ae6/62e/271ae662e2038e09afba52bb2725d8cb.png"></div><br>  <i>Masque B</i> <br><br>  Nous exposons ces deux textures √† ce que j'appelle le module <em>Select</em> .  En fait, nous utilisons la valeur du module A ou du module B. Le choix d√©pend de la valeur du module C. Il n√©cessite deux autres valeurs - <em>Select Point</em> et <em>Falloff</em> . <br><br>  Si la valeur au point <code>x,y</code> module C est sup√©rieure ou √©gale √† <code>SelectPoint</code> , alors nous utilisons la valeur au point <code>x,y</code> module B. Si la valeur est inf√©rieure ou √©gale √† <code>SelectPoint - Falloff</code> , alors nous utilisons la valeur √† <code>x,y</code> module A. <br><br>  S'il se situe entre <code>SelectPoint - Falloff</code> et <code>SelectPoint</code> , alors nous effectuons une interpolation lin√©aire entre les valeurs <code>x,y</code> du module A et du module B. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, moduleA, moduleB, moduleC, selectPoint, falloff)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = moduleC(x,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &gt;= selectPoint) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &lt;= selectPoint - falloff) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(a, b, (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / ((selectPoint - (selectPoint-falloff)) / (selectPoint - s))); } }</code> </pre> <br>  Dans notre cas, le module A est un module <em>constant</em> avec une valeur de <code>0</code> .  Le module B est la premi√®re texture du masque A et le <em>s√©lecteur</em> (module C) est le deuxi√®me masque de B. <code>SelectPoint</code> sera de <code>0.4</code> et <code>Falloff</code> sera de <code>0.1</code> .  En cons√©quence, nous obtenons: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/46a/265/93a46a265f690650dec24eb5c56bcf32.png"></div><br>  <i>Masque ultime</i> <br><br>  En augmentant ou en diminuant <code>SelectPoint</code> , nous <code>SelectPoint</code> ou <code>SelectPoint</code> la quantit√© de noir dans le masque.  En augmentant ou en diminuant l' <code>falloff</code> , nous <code>falloff</code> ou diminuons les bords mous des masques.  Au lieu d'un des masques, je pouvais utiliser le module <em>Constant</em> avec une valeur de <code>1</code> , mais je voulais ajouter un peu d'al√©atoire aux zones ¬´non masqu√©es¬ª. <br><br><h3>  M√©langez le canal de couleur et le masque </h3><br>  Maintenant, nous devons appliquer un masque √† chacun des canaux de couleur.  Cela se fait √† l'aide du module <em>Blending</em> .  Il combine les pourcentages de valeurs de deux modules afin que la somme des valeurs soit de 100%. <br><br>  Autrement dit, nous pouvons prendre 50% de la valeur en <code>x,y</code> module A et 50% de la valeur en <code>x,y</code> module B. Ou 75% et 25%, etc.  Le pourcentage que nous prenons de chaque module d√©pend d'un autre module - module C. Si la valeur en <code>x,y</code> module C est <code>0</code> , alors nous prendrons 100% du module A et 0% du module B. Si c'est <code>1</code> , alors nous prenons valeurs inverses. <br><br>  Combinez pour chaque texture de couleur. <br><br><ul><li>  Module A - Valeur constante 0 </li><li>  Le module B est le canal de couleur que nous avons d√©j√† vu </li><li>  Module C - r√©sultat du masque </li></ul><br>  Cela signifie que le bruit du canal de couleur sera affich√© uniquement lorsque le masque a des valeurs sup√©rieures √† <code>0</code> (zones plus proches du blanc), et l'amplitude de leur visibilit√© d√©pend de la valeur du masque. <br><br>  Voici le r√©sultat de notre exemple: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>R√©sultat final</i> <br><br>  Comparez cela √† l'original avant d'appliquer le m√©lange avec un masque. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Avant de m√©langer avec un masque</i> <br><br>  Peut-√™tre que cet exemple n'est pas tr√®s √©vident, mais en raison du hasard, il est difficile de s√©lectionner sp√©cifiquement un bon exemple.  L'effet du masque est de cr√©er des zones plus sombres.  Bien s√ªr, vous pouvez personnaliser le masque pour qu'il soit plus prononc√©. <br><br>  Il est important ici que le m√™me masque soit appliqu√© √† l'ensemble du canal de couleur, c'est-√†-dire que les m√™mes zones apparaissent dans l'ombre. <br><br><h3>  Nous combinons tout ensemble </h3><br>  Notre exemple fini initial: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Exemple pr√™t</i> <br><br>  Il utilise les canaux rouge, vert et alpha: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Canal rouge</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/001/8fb/c26/0018fbc263e0ae9983386f78428a0088.png"></div><br>  <i>Canal vert</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Canal alpha</i> <br><br>  Et puis nous les d√©posons sur notre ciel √©toil√©. <br><br>  Tout semble maintenant assez bon, mais pas tr√®s adapt√© √† un jeu de pixel art.  Nous devons r√©duire le nombre de couleurs ... <br><br><h2>  Coupe m√©diane </h2><br>  Cette partie de l'article peut s'appliquer √† tout.  Disons que vous g√©n√©rez une texture de marbre et que vous souhaitez r√©duire le nombre de couleurs.  C'est l√† que l'algorithme de coupe m√©diane est utile.  Nous l'utiliserons pour r√©duire le nombre de couleurs dans la n√©buleuse ci-dessus. <br><br>  Cela se produit <em>avant</em> qu'il ne se superpose au ciel √©toil√©.  Le nombre de couleurs est compl√®tement arbitraire. <br><br>  L'algorithme de coupe m√©diane tel que d√©crit dans Wikipedia: <br><br><blockquote>  Supposons que nous ayons une image avec un nombre arbitraire de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pixels</a> et que nous voulons g√©n√©rer une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">palette</a> de 16 couleurs.  Mettez tous les pixels de l'image (c'est-√†-dire leurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valeurs RVB</a> ) dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">corbeille</a> .  D√©couvrez quel canal de couleur (rouge, vert ou bleu) parmi tous les pixels du panier a la plus grande plage de valeurs, puis triez les pixels en fonction des valeurs de ce canal.  Par exemple, si le canal bleu a la plus grande plage de valeurs, le pixel avec la valeur RVB (32, 8, 16) est plus petit que le pixel avec la valeur RVB (1, 2, 24), car 16 &lt;24. Apr√®s le tri du panier, placez la moiti√© sup√©rieure des pixels dans un nouveau panier.  (Cette √©tape a donn√© le nom √† l'algorithme de coupe m√©diane; les paniers sont divis√©s par deux par la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©diane de la</a> liste des pixels.) R√©p√©tez le processus pour les deux paniers, ce qui nous donnera 4 paniers, puis r√©p√©tez pour les 4 paniers, obtenez 8 paniers, puis r√©p√©tez pour 8 paniers, nous obtenons 16 paniers.  Nous faisons la moyenne des pixels dans chacun des paniers et obtenons une palette de 16 couleurs.  Comme le nombre de paniers double √† chaque it√©ration, l'algorithme ne peut g√©n√©rer que de telles palettes, dont le nombre de couleurs est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une puissance de deux</a> .  Par exemple, pour g√©n√©rer une palette de 12 couleurs, vous devez d'abord g√©n√©rer une palette de 16 couleurs, puis combiner d'une mani√®re ou d'une autre certaines couleurs. <br><br>  Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://en.wikipedia.org/wiki/Median_cut</a> </blockquote><br>  Cette explication me semblait plut√¥t mauvaise et pas particuli√®rement utile.  Lors de la mise en ≈ìuvre de l'algorithme, des images plut√¥t laides sont obtenues de cette mani√®re.  Je l'ai impl√©ment√© avec quelques changements: <br><br><ol><li>  Nous stockons le conteneur de <code>boxes</code> avec la valeur indiquant l'intervalle (plus de d√©tails ci-dessous).  La <code>box</code> stocke simplement un certain nombre dynamique de pixels de l'image d'origine. </li><li>  Ajoutez tous les pixels de l'image d'origine comme premi√®re <code></code> et utilisez l'intervalle <code>0</code> </li><li>  Bien que le nombre total de <code></code> inf√©rieur au nombre de couleurs requis, nous continuons les √©tapes suivantes. </li><li>  Si la valeur de l'intervalle est <code>0</code> , alors pour chaque case actuelle, nous d√©terminons le canal de couleur principal de cette <code>box</code> , puis trions les pixels de cette <code>box</code> par cette couleur.   ‚Äî    Red, Green, Blue  Alpha,     . , <code>redRange = Max(Red) - Min(Red)</code> .           ,      . </li><li>           <code>box</code>   <code>boxes</code> .   ,        <code>box</code> . </li><li>  ,     4  5   <code>box</code> ,   <code>boxes</code>   .      ,         ,    ,     .     ,           ,      . </li><li>    <code>box</code> ( ==   )      <code>boxes</code> .               <code>0</code> (    ).  ,         ,       ,    ‚Äî .            . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous atteignons le nombre de cases √©gal au nombre de couleurs souhait√©, nous faisons simplement la moyenne de tous les pixels de chaque case pour d√©terminer l'√©l√©ment de palette qui convient le mieux √† ces couleurs. </font><font style="vertical-align: inherit;">Je viens d'utiliser la distance euclidienne, mais il existe des solutions perceptuelles qui peuvent faire mieux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici une image qui expliquera tout plus clairement. </font><font style="vertical-align: inherit;">Pour la d√©monstration, j'utilise uniquement RGB, car alpha est difficile √† montrer.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3e/bb8/3fa/f3ebb83fa6aa4d15c0422ef3d66fd9ed.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appliquons cette m√©thode √† notre exemple d'image. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>L'original</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coupe m√©diane jusqu'√† 16 couleurs</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'ai d√©couvert qu'en utilisant deux canaux de couleur, un bon effet est obtenu avec 16 couleurs. Mais gardez √† l'esprit que nous utilisons ici le canal alpha, qui est √©galement impliqu√© dans le calcul de la distance entre les couleurs. Donc, si vous ne vous souciez pas de la transparence, vous pouvez utiliser moins de couleurs. √âtant donn√© que ma coupe m√©diane, contrairement √† l'exemple de Wikipedia, peut utiliser un nombre arbitraire de couleurs (et pas seulement des puissances de deux), vous pouvez la personnaliser en fonction de vos besoins.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70c/32e/828/70c32e82884077298e54db439472c866.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De 16 √† 2 couleurs,</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons s√©lectionn√© une couleur dans chacune </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en faisant simplement la moyenne de toutes les valeurs. </font><font style="vertical-align: inherit;">Cependant, ce n'est pas le seul moyen. </font><font style="vertical-align: inherit;">Vous avez peut-√™tre remarqu√© que notre r√©sultat par rapport √† l'original n'est pas si brillant. </font><font style="vertical-align: inherit;">Si vous en avez besoin, vous pouvez donner la pr√©f√©rence dans les intervalles sup√©rieurs, en ajoutant du poids √† la d√©finition des intervalles. </font><font style="vertical-align: inherit;">Ou vous pouvez facilement s√©lectionner 1, 2 ou 3 des couleurs les plus lumineuses de l'image et les ajouter √† la palette. </font><font style="vertical-align: inherit;">Par cons√©quent, si vous avez besoin de 16 couleurs, g√©n√©rez une palette de 13 couleurs et ajoutez manuellement vos couleurs vives.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/48f/382/ce648f382b0be2409b25d24d682a528b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une palette avec les trois couleurs les plus brillantes</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, tout semble plut√¥t bien, mais l'image est trop in√©gale. </font><font style="vertical-align: inherit;">Il a de grandes zones de la m√™me couleur. </font><font style="vertical-align: inherit;">Maintenant, nous devons les lisser.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dithering </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'ai pas besoin de vous dire ce qu'est le tramage, car vous travaillez d√©j√† avec le pixel art. </font><font style="vertical-align: inherit;">Donc, pour obtenir une image plus fluide, nous utiliserons l'un des algorithmes de tramage, dont il existe beaucoup. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai impl√©ment√© un algorithme de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tramage Floyd-Steinberg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simple </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il n'y a pas eu de mauvaises surprises. </font><font style="vertical-align: inherit;">Cependant, l'effet a √©t√© assez fort. </font><font style="vertical-align: inherit;">Voici √† nouveau notre exemple:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>L'original</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, nous avons coup√© la palette √† 16 couleurs: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les valeurs sont mapp√©es sur une palette de 16 couleurs.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant le tramage suivi d'une conversion en palette:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84f/fa0/d82/84ffa0d82eb90de9f0e59c7ef718f753.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultat fini avec tramage</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464203/">https://habr.com/ru/post/fr464203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464189/index.html">Comment cr√©er un projet open source</a></li>
<li><a href="../fr464191/index.html">Comment r√©soudre les probl√®mes de site d'agr√©gateur √† l'aide de proxys r√©sidents</a></li>
<li><a href="../fr464193/index.html">Un microphone ouvert de DevOps Deflope, des histoires sur l'infrastructure de Skyeng et Nvidia et pas seulement</a></li>
<li><a href="../fr464195/index.html">L'histoire √† succ√®s du jeu Last Day on Earth du studio Volgograd Kefir</a></li>
<li><a href="../fr464197/index.html">Que se passera-t-il sur TechTrain et pourquoi devrais-je y aller?</a></li>
<li><a href="../fr464205/index.html">Comment l'IA et les neurosciences vont de l'avant</a></li>
<li><a href="../fr464207/index.html">De l'Homo sapiens sapiens √† l'Homo vuln√©rable √† l'Homo science ou √† la sensibilisation √† la s√©curit√© des adultes</a></li>
<li><a href="../fr464209/index.html">Gutenberg Editor, comment rendre les √©diteurs et les typographes pratiques</a></li>
<li><a href="../fr464217/index.html">Comment visualiser le son sur le web: une s√©lection de supports th√©matiques et de conf√©rences vid√©o avec th√©orie et pratique</a></li>
<li><a href="../fr464219/index.html">Bo√Æte √† outils Timlid de l'e-mail aux tableaux Kanban</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>