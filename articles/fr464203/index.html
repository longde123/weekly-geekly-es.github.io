<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏿 👩🏽‍🤝‍👨🏻 🗞️ Création d'une nébuleuse de pixels à l'aide du bruit et de la coupe médiane ♟️ 🦇 🤲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je voulais une nébuleuse dans mon jeu The Last Boundary . Ils ont l'air incroyables et l'espace sans eux n'est pas de l'espace, mais simplement des pi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création d'une nébuleuse de pixels à l'aide du bruit et de la coupe médiane</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464203/">  Je voulais une nébuleuse dans mon jeu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Last Boundary</a> .  Ils ont l'air incroyables et l'espace sans eux n'est pas de l'espace, mais simplement des pixels blancs dispersés autour de l'arrière-plan.  Mais comme je crée le jeu dans le style du "pixel art", je devais en quelque sorte faire en sorte que ma bibliothèque de bruit génère des images pixelisées. <br><br>  Voici quelques exemples: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/65f/7fd/f2e65f7fd23c0fe2fcfafcc0fcf62a3e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/358/ef9/665358ef9f488bb63d7ced8ea7dfd45d.png"></div><br><div class="spoiler">  <b class="spoiler_title">Plus d'exemples</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/d6e/4ab/b88d6e4ab783d2d67f0f0f6e7e38536f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/705/d13/40b/705d1340be1c918a6a6e9b22d3ae416f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/daa/1c7/1ba/daa1c71bade101b11ec6025a87ca30a4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/d8c/5f9/00bd8c5f9fa01ef5a90282a2d2897de3.png"></div><br></div></div><br>  Dans les exemples monochromes, 8 couleurs sont utilisées et dans d'autres, 16 couleurs.  Dans cet article, je vais vous expliquer comment j'ai créé une nébuleuse pixélisée pour The Last Boundary. <br><a name="habracut"></a><br>  Lorsque nous travaillons avec une bibliothèque de bruit, telle que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LibNoise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">que soit le</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur que</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous</a> utilisez (ou écrivez le vôtre), les valeurs sont généralement réparties dans la plage de <code>-1</code> à <code>1</code> .  Il est théoriquement plus probable que le bruit 2D soit compris entre <code>-0.7</code> et <code>0.7</code> , mais certaines implémentations mettent le résultat à l'échelle, le traduisant dans l'intervalle de <code>-1</code> à <code>1</code> .  Pour travailler avec des textures 2D, il est généralement converti en un intervalle de <code>0</code> à <code>1</code> , puis il se <code>RGB(255,255,255)</code> dans la plage de <code>RGB(0,0,0)</code> à <code>RGB(255,255,255)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Bruit Perlin généré à partir des coordonnées <code>x,y</code> de chaque pixel mis à l'échelle à <code>0.3f</code></i> <br><br>  Ensuite, vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le mouvement brownien fractionnaire</a> pour donner à l'image une sensation de splendeur des nuages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/910/a74/aed910a745d77af8d1cfa816990276a5.png"></div><br>  <i>Le bruit de Perlin a été soumis à un mouvement brownien fractionnaire avec <code>8</code> octaves, fréquence <code>0.01</code> , régularité <code>0.5</code> et lacunarité <code>2.0</code> .</i> <br><br><blockquote>  J'ai remarqué qu'il existe de nombreuses implémentations incorrectes du bruit Perlin, du bruit simplex et du mouvement brownien fractionnaire (fBm) sur Internet.  Il semble y avoir beaucoup de confusion sur ce qui est quoi.  Assurez-vous que vous utilisez l'implémentation correcte, car si vous souhaitez créer la chaîne décrite ci-dessus, en cas d'implémentation incorrecte, vous risquez de ne pas obtenir les résultats requis. </blockquote><br>  Imaginons que nous voulons créer un effet de fumée, c'est-à-dire qu'une telle solution nous convienne.  Mais notre jeu de pixel art aurait l'air étrange si tout un tas de nouvelles couleurs y apparaissaient de <code>RGB(0,0,0)</code> à <code>RGB(255,255,255)</code> .  Soudain, 255 nouveaux grades de gris apparaîtront dans le jeu. <br><br>  Nous devons les convertir en un nombre limité de couleurs.  C'est ce que nous ferons plus tard.  En attendant ... <br><br><h2>  Générer une nébuleuse aléatoire </h2><br>  J'ai répété pour des didacticiels prêts à l'emploi sur la génération de nébuleuses aléatoires, mais j'ai ajouté certaines de mes étapes et appliqué ma propre bibliothèque de bruit.  Je l’ai écrit il y a quelques années parce que je voulais bien comprendre le bruit de Perlin et comment l’utiliser avec d’autres concepts pour créer des textures, etc. <br><br>  Peut-être pouvez-vous répéter étape par étape après moi ou vous devrez faire des ajouts au code qui affecteront votre bruit.  Je vais tout expliquer sauf la génération de bruit initiale et fBm pour que vous puissiez écrire le code vous-même;  Je pense que l'on peut supposer que vous avez déjà la capacité de générer du bruit et du fBm. <br><br>  Pour commencer, je vais montrer le résultat de la génération de la nébuleuse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Résultat fini</i> <br><br>  Il est important de noter qu'il n'est pas encore pixellisé.  Il a une gamme complète de couleurs avec un ciel étoilé pixélisé.  La nébuleuse nous pixelliserons plus tard. <br><br>  La première chose à faire est de générer cinq textures différentes: rouge, verte, bleue, alpha et masque.  Les textures rouge, verte et bleue sont nécessaires pour les canaux de couleur finale correspondants.  En fait, je ne génère qu'un ou deux canaux de couleur, car il s'est avéré que l'utilisation des trois produit une nébuleuse incroyablement colorée qui a l'air moche.  Toute couleur unique ou une combinaison de deux couleurs fera bien l'affaire. <br><br>  Le canal Alpha est important car cela dépend si les étoiles inférieures brillent à travers la nébuleuse.  Je vais illustrer cela en affichant le canal alpha de l'exemple ci-dessus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Canal alpha prêt de notre exemple</i> <br><br>  Plus la zone est blanche, plus la valeur est proche de <code>1.0</code> , ce qui nous donne une valeur alpha de <code>255</code> .  Plus la zone est noire, plus elle est transparente.  Si vous regardez un exemple, vous pouvez voir que les zones noires correspondent aux zones dans lesquelles le ciel étoilé est visible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/7d2/7ad/de97d27adeaaebdbfc8a5b5857bab02f.png"></div><br>  <i>Exemple de ciel étoilé</i> <br><br>  Ce ne sont pas les mêmes étoiles que dans l'exemple, car elles sont générées aléatoirement dans chaque capture d'écran.  J'espère que cela ne vous empêche pas de comprendre comment la nébuleuse est générée. <br><br>  Ma bibliothèque de bruit se compose de modules, suivant l'exemple de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lib Noise</a> .  Tout dans cette bibliothèque est constitué de «modules» qui peuvent être enchaînés ensemble.  Certains modules génèrent de nouvelles valeurs (module Perlin, valeur constante), d'autres les connectent (multiplication, ajout) et certains effectuent simplement des opérations sur la valeur (Lerp, Clamp). <br><br><h3>  Canaux de couleur </h3><br>  Peu importe que nous travaillions avec une, deux ou trois couleurs - les canaux rouge, vert et bleu sont générés de la même manière;  J'utilise juste une valeur de graine différente pour eux.  Mes valeurs de départ dépendent de l'heure actuelle du système. <br><br>  Ci-dessous, ils sont tous présentés en niveaux de gris, mais théoriquement, ce sont simplement des valeurs pour l'un des trois canaux.  Niveaux de gris est juste là pour illustrer les résultats. <br><br><h4>  1. Le bruit de Perlin </h4><br>  Comme ci-dessus, le bruit de Perlin sera le point de départ.  Si vous voulez, vous pouvez utiliser du bruit simplex, il semble que son implémentation 2D n'appartienne pas à Ken Perlin, mais je peux me tromper.  D'un point de vue mathématique, le bruit simplex utilise moins d'instructions, donc la génération d'une nébuleuse similaire sera plus rapide.  Puisqu'il utilise des simplexes au lieu d'une grille, il crée un bruit légèrement plus beau, mais nous ne travaillerons pas beaucoup avec, donc ce n'est pas particulièrement important. <br><br>  Le code réel n'est pas illustré ci-dessous, car dans les sources réelles <code>x,y</code> valeurs <code>x,y</code> ont été modifiées par fBm à l'étape 3. Il s'agit simplement de la coordonnée <code>x,y</code> de l'image, multipliée par le facteur d'échelle statique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>Bruit Perlin généré à partir des coordonnées <code>x,y</code> de chaque pixel mis à l'échelle à <code>0.3f</code> .</i>  <i>C'est-à-dire</i> <i><code>PixelValue = PerlinNoise(x * 0.3f, y * 0.3f)</code></i> <br><br>  Les valeurs créées par le bruit Perlin se situent approximativement dans la plage de <code>-1</code> à <code>1</code> , donc pour créer l'image en niveaux de gris habituelle illustrée ci-dessus, nous les convertissons à l'intervalle de <code>0</code> à <code>1</code> .  J'ai testé la portée des valeurs afin que la conversion produise le plus grand contraste (la valeur la plus basse correspond à <code>0</code> , la plus grande - <code>1</code> ). <br><br><h4>  2. Multiplication </h4><br>  Le module suivant utilisé multiplie le bruit généré par <code>5</code> .  Cela peut être considéré comme un ajustement du contraste.  Les valeurs négatives sont plus sombres, les valeurs positives sont plus claires. <br><br>  Je n'ai rien à montrer ici, car dans le processus de conversion des valeurs de l'intervalle de <code>-5</code> à <code>5</code> à l'intervalle de <code>0</code> à <code>1</code> résultat ne change pas. <br><br><h4>  3. Mouvement brownien fractionnaire (fBM) </h4><br>  Cette étape transforme le bruit en ce que beaucoup de gens considèrent comme un véritable «effet de bruit».  Ici, nous exécutons des octaves d'échantillons de plus en plus petits à partir de la fonction de bruit (dans notre cas, la fonction est <code>perlin(x,y)</code> ) pour ajouter du fluffiness. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/388/634/15b/38863415ba86694f3acc86618e7173d2.png"></div><br>  <i>Mouvement brownien fractionnaire du bruit Perlin illustré ci-dessus.</i>  <i><code>8</code> octaves, fréquence <code>.01f</code> , régularité <code>.5f</code> et <code>2.5f</code></i> <br><br>  Vous pouvez déjà voir l'origine de quelque chose d'intéressant.  L'image ci-dessus n'est pas générée en mettant à l'échelle les coordonnées <code>x,y</code> des pixels, fBM le fait.  Encore une fois, ces valeurs sont inversement converties en un intervalle de <code>0</code> à <code>1</code> en un intervalle possible de <code>-5</code> à <code>5</code> . <br><br><h4>  4. Restriction (pince) </h4><br>  Je vais maintenant limiter les valeurs à une plage de <code>-1</code> à <code>1</code> .  Tout ce qui se trouve en dehors de cet intervalle sera complètement rejeté. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/f7a/b80/623f7ab80bc886e62d416726bcb63a09.png"></div><br>  <i>Le même fBm, limité à <code>-1</code> à <code>1</code></i> <br><br>  La tâche de cette opération est de convertir les valeurs en un intervalle plus court tout en créant des dégradés plus nets et en augmentant la zone en blanc ou en noir.  Ces zones mortes ou vides sont importantes pour l'effet de nébuleuse, que nous aborderons plus tard.  Si nous n'avions pas multiplié par <code>5</code> au début, alors la pince n'aurait rien changé. <br><br><h4>  5. Ajoutez 1 </h4><br>  Maintenant, nous prenons les valeurs de clamp et nous y ajoutons 1. Ainsi, nous transférons les valeurs dans l'intervalle de <code>0</code> à <code>2</code> .  Après la conversion, les résultats seront les mêmes qu'avant. <br><br><h4>  6. Divisez par 2 </h4><br>  Vous savez probablement ce qui se passera lorsque je divise le résultat par <code>2</code> (multipliez par <code>.5</code> ).  Dans l'image, rien ne changera à nouveau. <br><br>  Les étapes 5 et 6 convertissent les valeurs dans une plage de <code>0</code> à <code>1</code> . <br><br><h4>  7. Créez une texture de distorsion </h4><br>  L'étape suivante consiste à créer une texture de distorsion.  Je vais le faire avec du bruit Perlin (avec la nouvelle valeur de départ)&gt; multiplier par 4&gt; exécuter fBm.  Dans ce cas, fBm utilise <code>5</code> octaves, une fréquence de <code>0.025</code> , une régularité de <code>0.5</code> et une lacunarité de <code>1.5</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/937/748/b34937748b4e87736c9f09f464bc99dd.png"></div><br>  <i>Texture de distorsion</i> <br><br>  Cette texture est nécessaire pour créer plus de détails que dans la texture existante de la nébuleuse.  La nébuleuse est un nuage ondulé assez grand, et cette texture y apportera de petits changements.  À travers elle, la nature de grille du bruit de Perlin commencera à émerger. <br><br><h4>  8. Décalez la texture de couleur en utilisant la texture de décalage </h4><br>  Ensuite, je vais prendre ces deux textures et utiliser l'une pour compenser les coordonnées de l'autre par un facteur.  Dans notre cas, la combinaison ressemble à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Résultat de biais</i> <br><br>  La texture de distorsion est utilisée pour modifier les coordonnées <code>x,y</code> nous recherchons dans les données de bruit source. <br><br>  N'oubliez pas que les images ci-dessus sont uniquement à titre d'illustration.  À chaque étape, nous n'avons en fait qu'une fonction de bruit.  Nous lui passons la valeur <code>x,y</code> et il renvoie un nombre.  À certaines étapes, l'intervalle de ce nombre peut être différent, mais ci-dessus, nous l'avons reconverti en niveaux de gris pour créer une image.  L'image est créée en utilisant chaque coordonnée <code>x,y</code> de l'image comme <code>x,y</code> , transmise par la fonction de bruit. <br><br>  Autrement dit, lorsque nous disons: <br><br><blockquote>  Donnez-moi la valeur du pixel du coin supérieur gauche avec X = 0 et Y = 0 </blockquote><br>  La fonction nous renvoie un nombre.  Si nous demandons cela à Perlin, nous savons que ce sera entre <code>-1</code> et <code>1</code> , si, comme ci-dessus, nous appliquons la pince, l'addition et la multiplication, nous obtenons une valeur entre <code>0</code> et <code>1</code> . <br><br>  Après avoir compris cela, nous apprenons que la fonction de bruit de distorsion crée des valeurs dans la plage de <code>-1</code> à <code>1</code> .  Par conséquent, pour effectuer le biais lorsque nous disons: <br><br><blockquote>  Donnez-moi la valeur du pixel dans le coin supérieur gauche avec le pixel X = 0 et Y = 0 </blockquote><br>  le module de décalage demande d'abord à la fonction de décalage les coordonnées <code>x,y</code> .  Le résultat est compris entre <code>-1</code> et <code>1</code> (comme c'était le cas ci-dessus).  Il est ensuite multiplié par <code>40</code> (c'est le <em>coefficient que</em> j'ai sélectionné).  Le résultat sera une valeur comprise entre <code>-40</code> et <code>40</code> . <br><br>  Ensuite, nous prenons cette valeur et l'ajoutons aux coordonnées des <code>x,y</code> que nous recherchions, et utilisons ce résultat pour rechercher la texture de la couleur.  Nous avons coupé les valeurs négatives avec une pince à 0, car il est impossible de rechercher des coordonnées <code>x,y</code> négatives dans les fonctions de bruit (au moins dans ma bibliothèque de bruit). <br><br>  Autrement dit, cela ressemble à ceci: <br><br><pre> <code class="cpp hljs">ColourFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DisplaceFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">-1</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DoDisplace(x,y) = { v = DisplaceFunction(x,y) * factor clamp(v,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>) x = x + v; y = y + v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ColourFunction(x,y) }</code> </pre> <br>  J'espère que vous comprenez cela.  En fait, nous ne regardons pas le <code>x,y</code> lequel nous étions, mais le décalage.  Et puisque la <em>magnitude</em> est également un gradient lisse, elle se déplace en douceur. <br><br>  Il existe d'autres façons d'effectuer le décalage.  Ma bibliothèque de bruit a un module qui crée un déplacement en spirale.  Il peut être utilisé pour dessiner une texture, diminuant progressivement jusqu'à un certain nombre de points.  <a href="">Voici un exemple</a> . <br><br>  C’est tout.  Nous répétons les opérations ci-dessus trois fois, en utilisant de nouvelles valeurs de départ pour chaque canal de couleur.  Vous pouvez créer un ou deux canaux.  Je ne pense pas que ça vaille la peine d'en créer un troisième. <br><br><h3>  Canal alpha </h3><br>  Un canal alpha est créé de la même manière que les canaux de couleur: <br><br><ol><li>  On commence par le bruit de Perlin </li><li>  Multipliez par <code>5</code> </li><li>  fBM avec <code>8</code> octaves, fréquence <code>0.005</code> , régularité <code>0.5</code> et lacunarité <code>2.5</code> </li><li>  Nous limitons les résultats en utilisant Clamp à l'intervalle de <code>-1</code> à <code>1</code> , ajoutons <code>1</code> , divisons par <code>2</code> (c'est-à-dire que nous décalons l'intervalle de <code>-1</code> à <code>1</code> à l'intervalle de <code>0</code> à <code>1</code> . </li><li>  Nous décalons légèrement le résultat dans le sens négatif.  J'ai compensé de <code>0.4</code> .  Grâce à cela, tout devient un peu plus sombre. </li><li>  Nous limitons les résultats à un intervalle de <code>0</code> à <code>1</code> .  Puisque nous avons tout déplacé, le rendant un peu plus sombre, en fait, nous avons créé plus de zones avec <code>0</code> , et certaines zones sont entrées dans des valeurs négatives. </li></ol><br>  Le résultat est une texture de canal alpha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Texture alpha</i> <br><br>  Comme je l'ai dit, les zones noires seront transparentes et les zones blanches seront opaques. <br><br><h3>  Masques de canal </h3><br>  Il s'agit de la dernière texture utilisée pour créer des ombres superposées sur tout le reste.  Cela commence comme toutes les autres textures: <br><br><ol><li>  Perlin de bruit </li><li>  Multipliez par <code>5</code> </li><li>  Nous effectuons fBm, <code>5</code> octaves, fréquence <code>0.01</code> , régularité <code>0.1</code> , lacunarité <code>0.1</code> .  La régularité est faible, donc le nuage est moins dense </li><li>  Effectuer un décalage d'intervalle de <code>-1</code> à <code>1</code> à un intervalle de <code>0</code> à <code>1</code> </li></ol><br>  Mais nous créons deux de ces textures: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/11f/862/63011f8620c86a9bbf2f80d038a7c157.png"></div><br>  <i>Masquer un</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/ae6/62e/271ae662e2038e09afba52bb2725d8cb.png"></div><br>  <i>Masque B</i> <br><br>  Nous exposons ces deux textures à ce que j'appelle le module <em>Select</em> .  En fait, nous utilisons la valeur du module A ou du module B. Le choix dépend de la valeur du module C. Il nécessite deux autres valeurs - <em>Select Point</em> et <em>Falloff</em> . <br><br>  Si la valeur au point <code>x,y</code> module C est supérieure ou égale à <code>SelectPoint</code> , alors nous utilisons la valeur au point <code>x,y</code> module B. Si la valeur est inférieure ou égale à <code>SelectPoint - Falloff</code> , alors nous utilisons la valeur à <code>x,y</code> module A. <br><br>  S'il se situe entre <code>SelectPoint - Falloff</code> et <code>SelectPoint</code> , alors nous effectuons une interpolation linéaire entre les valeurs <code>x,y</code> du module A et du module B. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, moduleA, moduleB, moduleC, selectPoint, falloff)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = moduleC(x,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &gt;= selectPoint) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &lt;= selectPoint - falloff) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(a, b, (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / ((selectPoint - (selectPoint-falloff)) / (selectPoint - s))); } }</code> </pre> <br>  Dans notre cas, le module A est un module <em>constant</em> avec une valeur de <code>0</code> .  Le module B est la première texture du masque A et le <em>sélecteur</em> (module C) est le deuxième masque de B. <code>SelectPoint</code> sera de <code>0.4</code> et <code>Falloff</code> sera de <code>0.1</code> .  En conséquence, nous obtenons: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/46a/265/93a46a265f690650dec24eb5c56bcf32.png"></div><br>  <i>Masque ultime</i> <br><br>  En augmentant ou en diminuant <code>SelectPoint</code> , nous <code>SelectPoint</code> ou <code>SelectPoint</code> la quantité de noir dans le masque.  En augmentant ou en diminuant l' <code>falloff</code> , nous <code>falloff</code> ou diminuons les bords mous des masques.  Au lieu d'un des masques, je pouvais utiliser le module <em>Constant</em> avec une valeur de <code>1</code> , mais je voulais ajouter un peu d'aléatoire aux zones «non masquées». <br><br><h3>  Mélangez le canal de couleur et le masque </h3><br>  Maintenant, nous devons appliquer un masque à chacun des canaux de couleur.  Cela se fait à l'aide du module <em>Blending</em> .  Il combine les pourcentages de valeurs de deux modules afin que la somme des valeurs soit de 100%. <br><br>  Autrement dit, nous pouvons prendre 50% de la valeur en <code>x,y</code> module A et 50% de la valeur en <code>x,y</code> module B. Ou 75% et 25%, etc.  Le pourcentage que nous prenons de chaque module dépend d'un autre module - module C. Si la valeur en <code>x,y</code> module C est <code>0</code> , alors nous prendrons 100% du module A et 0% du module B. Si c'est <code>1</code> , alors nous prenons valeurs inverses. <br><br>  Combinez pour chaque texture de couleur. <br><br><ul><li>  Module A - Valeur constante 0 </li><li>  Le module B est le canal de couleur que nous avons déjà vu </li><li>  Module C - résultat du masque </li></ul><br>  Cela signifie que le bruit du canal de couleur sera affiché uniquement lorsque le masque a des valeurs supérieures à <code>0</code> (zones plus proches du blanc), et l'amplitude de leur visibilité dépend de la valeur du masque. <br><br>  Voici le résultat de notre exemple: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Résultat final</i> <br><br>  Comparez cela à l'original avant d'appliquer le mélange avec un masque. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>Avant de mélanger avec un masque</i> <br><br>  Peut-être que cet exemple n'est pas très évident, mais en raison du hasard, il est difficile de sélectionner spécifiquement un bon exemple.  L'effet du masque est de créer des zones plus sombres.  Bien sûr, vous pouvez personnaliser le masque pour qu'il soit plus prononcé. <br><br>  Il est important ici que le même masque soit appliqué à l'ensemble du canal de couleur, c'est-à-dire que les mêmes zones apparaissent dans l'ombre. <br><br><h3>  Nous combinons tout ensemble </h3><br>  Notre exemple fini initial: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>Exemple prêt</i> <br><br>  Il utilise les canaux rouge, vert et alpha: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>Canal rouge</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/001/8fb/c26/0018fbc263e0ae9983386f78428a0088.png"></div><br>  <i>Canal vert</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>Canal alpha</i> <br><br>  Et puis nous les déposons sur notre ciel étoilé. <br><br>  Tout semble maintenant assez bon, mais pas très adapté à un jeu de pixel art.  Nous devons réduire le nombre de couleurs ... <br><br><h2>  Coupe médiane </h2><br>  Cette partie de l'article peut s'appliquer à tout.  Disons que vous générez une texture de marbre et que vous souhaitez réduire le nombre de couleurs.  C'est là que l'algorithme de coupe médiane est utile.  Nous l'utiliserons pour réduire le nombre de couleurs dans la nébuleuse ci-dessus. <br><br>  Cela se produit <em>avant</em> qu'il ne se superpose au ciel étoilé.  Le nombre de couleurs est complètement arbitraire. <br><br>  L'algorithme de coupe médiane tel que décrit dans Wikipedia: <br><br><blockquote>  Supposons que nous ayons une image avec un nombre arbitraire de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pixels</a> et que nous voulons générer une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">palette</a> de 16 couleurs.  Mettez tous les pixels de l'image (c'est-à-dire leurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valeurs RVB</a> ) dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">corbeille</a> .  Découvrez quel canal de couleur (rouge, vert ou bleu) parmi tous les pixels du panier a la plus grande plage de valeurs, puis triez les pixels en fonction des valeurs de ce canal.  Par exemple, si le canal bleu a la plus grande plage de valeurs, le pixel avec la valeur RVB (32, 8, 16) est plus petit que le pixel avec la valeur RVB (1, 2, 24), car 16 &lt;24. Après le tri du panier, placez la moitié supérieure des pixels dans un nouveau panier.  (Cette étape a donné le nom à l'algorithme de coupe médiane; les paniers sont divisés par deux par la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">médiane de la</a> liste des pixels.) Répétez le processus pour les deux paniers, ce qui nous donnera 4 paniers, puis répétez pour les 4 paniers, obtenez 8 paniers, puis répétez pour 8 paniers, nous obtenons 16 paniers.  Nous faisons la moyenne des pixels dans chacun des paniers et obtenons une palette de 16 couleurs.  Comme le nombre de paniers double à chaque itération, l'algorithme ne peut générer que de telles palettes, dont le nombre de couleurs est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une puissance de deux</a> .  Par exemple, pour générer une palette de 12 couleurs, vous devez d'abord générer une palette de 16 couleurs, puis combiner d'une manière ou d'une autre certaines couleurs. <br><br>  Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://en.wikipedia.org/wiki/Median_cut</a> </blockquote><br>  Cette explication me semblait plutôt mauvaise et pas particulièrement utile.  Lors de la mise en œuvre de l'algorithme, des images plutôt laides sont obtenues de cette manière.  Je l'ai implémenté avec quelques changements: <br><br><ol><li>  Nous stockons le conteneur de <code>boxes</code> avec la valeur indiquant l'intervalle (plus de détails ci-dessous).  La <code>box</code> stocke simplement un certain nombre dynamique de pixels de l'image d'origine. </li><li>  Ajoutez tous les pixels de l'image d'origine comme première <code></code> et utilisez l'intervalle <code>0</code> </li><li>  Bien que le nombre total de <code></code> inférieur au nombre de couleurs requis, nous continuons les étapes suivantes. </li><li>  Si la valeur de l'intervalle est <code>0</code> , alors pour chaque case actuelle, nous déterminons le canal de couleur principal de cette <code>box</code> , puis trions les pixels de cette <code>box</code> par cette couleur.   —    Red, Green, Blue  Alpha,     . , <code>redRange = Max(Red) - Min(Red)</code> .           ,      . </li><li>           <code>box</code>   <code>boxes</code> .   ,        <code>box</code> . </li><li>  ,     4  5   <code>box</code> ,   <code>boxes</code>   .      ,         ,    ,     .     ,           ,      . </li><li>    <code>box</code> ( ==   )      <code>boxes</code> .               <code>0</code> (    ).  ,         ,       ,    — .            . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous atteignons le nombre de cases égal au nombre de couleurs souhaité, nous faisons simplement la moyenne de tous les pixels de chaque case pour déterminer l'élément de palette qui convient le mieux à ces couleurs. </font><font style="vertical-align: inherit;">Je viens d'utiliser la distance euclidienne, mais il existe des solutions perceptuelles qui peuvent faire mieux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici une image qui expliquera tout plus clairement. </font><font style="vertical-align: inherit;">Pour la démonstration, j'utilise uniquement RGB, car alpha est difficile à montrer.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3e/bb8/3fa/f3ebb83fa6aa4d15c0422ef3d66fd9ed.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appliquons cette méthode à notre exemple d'image. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>L'original</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coupe médiane jusqu'à 16 couleurs</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'ai découvert qu'en utilisant deux canaux de couleur, un bon effet est obtenu avec 16 couleurs. Mais gardez à l'esprit que nous utilisons ici le canal alpha, qui est également impliqué dans le calcul de la distance entre les couleurs. Donc, si vous ne vous souciez pas de la transparence, vous pouvez utiliser moins de couleurs. Étant donné que ma coupe médiane, contrairement à l'exemple de Wikipedia, peut utiliser un nombre arbitraire de couleurs (et pas seulement des puissances de deux), vous pouvez la personnaliser en fonction de vos besoins.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70c/32e/828/70c32e82884077298e54db439472c866.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De 16 à 2 couleurs,</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons sélectionné une couleur dans chacune </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en faisant simplement la moyenne de toutes les valeurs. </font><font style="vertical-align: inherit;">Cependant, ce n'est pas le seul moyen. </font><font style="vertical-align: inherit;">Vous avez peut-être remarqué que notre résultat par rapport à l'original n'est pas si brillant. </font><font style="vertical-align: inherit;">Si vous en avez besoin, vous pouvez donner la préférence dans les intervalles supérieurs, en ajoutant du poids à la définition des intervalles. </font><font style="vertical-align: inherit;">Ou vous pouvez facilement sélectionner 1, 2 ou 3 des couleurs les plus lumineuses de l'image et les ajouter à la palette. </font><font style="vertical-align: inherit;">Par conséquent, si vous avez besoin de 16 couleurs, générez une palette de 13 couleurs et ajoutez manuellement vos couleurs vives.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/48f/382/ce648f382b0be2409b25d24d682a528b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une palette avec les trois couleurs les plus brillantes</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, tout semble plutôt bien, mais l'image est trop inégale. </font><font style="vertical-align: inherit;">Il a de grandes zones de la même couleur. </font><font style="vertical-align: inherit;">Maintenant, nous devons les lisser.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dithering </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'ai pas besoin de vous dire ce qu'est le tramage, car vous travaillez déjà avec le pixel art. </font><font style="vertical-align: inherit;">Donc, pour obtenir une image plus fluide, nous utiliserons l'un des algorithmes de tramage, dont il existe beaucoup. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai implémenté un algorithme de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tramage Floyd-Steinberg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simple </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il n'y a pas eu de mauvaises surprises. </font><font style="vertical-align: inherit;">Cependant, l'effet a été assez fort. </font><font style="vertical-align: inherit;">Voici à nouveau notre exemple:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>L'original</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, nous avons coupé la palette à 16 couleurs: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les valeurs sont mappées sur une palette de 16 couleurs.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant le tramage suivi d'une conversion en palette:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84f/fa0/d82/84ffa0d82eb90de9f0e59c7ef718f753.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultat fini avec tramage</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464203/">https://habr.com/ru/post/fr464203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464189/index.html">Comment créer un projet open source</a></li>
<li><a href="../fr464191/index.html">Comment résoudre les problèmes de site d'agrégateur à l'aide de proxys résidents</a></li>
<li><a href="../fr464193/index.html">Un microphone ouvert de DevOps Deflope, des histoires sur l'infrastructure de Skyeng et Nvidia et pas seulement</a></li>
<li><a href="../fr464195/index.html">L'histoire à succès du jeu Last Day on Earth du studio Volgograd Kefir</a></li>
<li><a href="../fr464197/index.html">Que se passera-t-il sur TechTrain et pourquoi devrais-je y aller?</a></li>
<li><a href="../fr464205/index.html">Comment l'IA et les neurosciences vont de l'avant</a></li>
<li><a href="../fr464207/index.html">De l'Homo sapiens sapiens à l'Homo vulnérable à l'Homo science ou à la sensibilisation à la sécurité des adultes</a></li>
<li><a href="../fr464209/index.html">Gutenberg Editor, comment rendre les éditeurs et les typographes pratiques</a></li>
<li><a href="../fr464217/index.html">Comment visualiser le son sur le web: une sélection de supports thématiques et de conférences vidéo avec théorie et pratique</a></li>
<li><a href="../fr464219/index.html">Boîte à outils Timlid de l'e-mail aux tableaux Kanban</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>