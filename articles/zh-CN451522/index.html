<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏼 👨🏽‍✈️ 🚻 我们在几个小时内部署自动化：TypeScript，Protractor，Jasmine 🚳 👩🏾‍⚖️ 🏈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 我叫Vitaliy Kotov，我做过很多自动化测试，我喜欢它。 我最近参与了一个在TypeScript + Protractor + Jasmine堆栈上从头配置自动化的项目。 对我来说，这个堆栈是新的，我在Internet上搜索了必要的信息。 

 我设法只用英语找到了最有用，最...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们在几个小时内部署自动化：TypeScript，Protractor，Jasmine</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451522/"> 哈Ha！ <br><br> 我叫Vitaliy Kotov，我做过很多自动化测试，我喜欢它。 我最近参与了一个在TypeScript + Protractor + Jasmine堆栈上从头配置自动化的项目。 对我来说，这个堆栈是新的，我在Internet上搜索了必要的信息。 <br><br> 我设法只用英语找到了最有用，最明智的手册。 我认为俄语也需要这样做。 我只告诉您一些基础知识：为什么要这样的堆栈，需要配置什么以及最简单的测试是什么样的。 <br><br> 我必须马上说，我很少使用NodeJS，npm和一般的服务器端JavaScript（尤其是TypeScript）。 如果您发现某个地方的术语有误，或者我的某些决定可以改进，我将很高兴在经验丰富的专家的评论中了解到这一点。 <br><br> 顺便说一句，我已经有一篇类似的文章： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“我们在几个小时内部署自动化：PHPUnit，Selenium，Composer”</a> 。 <br><br><img src="https://habrastorage.org/webt/mn/rc/5t/mnrc5tzbyn3hmecryv5sj-1nuae.png"><br><a name="habracut"></a><br><h3> 挑战赛 </h3><br> 首先，让我们弄清楚我们正在解决什么问题。 我们有一个使用AngularJS编写的Web应用程序。 这是一个JavaScript框架，经常基于该框架编写Web项目。 <br><br> 在本文中，我们将不考虑AngularJS项目的利弊。 关于为此类项目编写端到端测试的几句话。 <br><br> 测试自动化的一个相当重要的方面是使用页面元素，这是在定位器的帮助下发生的。 定位器是根据某些规则组成并标识一个或多个UI元素的线。 <br><br> 对于Web，最常用的是CSS和Xpath。 有时，如果页面上有一个具有唯一ID的元素，则可以通过它进行搜索。 但是，在我看来，WebDriver最终仍将此ID转换为CSS定位器，并且已经在使用它。 <br><br> 如果我们看一些AngularJS项目的HTML代码，我们将看到很多经典HTML元素以外的属性： <br><br><img src="https://habrastorage.org/webt/zg/r3/et/zgr3etoo6q7qeycuobh1tl9g1f4.png"><br><br> 该代码来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">量角器演示</a>页面。 <br><br>  AngularJS使用所有以ng- *开头的属性来处理UI。 一个相当典型的情况是，除了这些控制属性以外的元素都没有其他元素，这使质量定位器的编译过程变得复杂。 <br><br> 那些做了很多自动化工作的人都知道可以轻松构建定位器的此类UI的价值。 毕竟，这对于大型项目而言很少见。  :) <br><br> 实际上，对于这样的项目，我们还需要配置测试自动化。 走吧 <br><br><h3> 什么是什么 </h3><br> 首先，让我们弄清楚为什么需要堆栈中的每个组件。 <br><br>  <b>量角器</b>是基于WebDriverJS的测试框架。 将由他启动我们的浏览器，使它们打开必要的页面并与必要的元素进行交互。 <br><br> 该框架是专门为AngularJS项目量身定制的。 它提供了其他方法来指定定位器： <br><br><pre><code class="javascript hljs">element(by.model(<span class="hljs-string"><span class="hljs-string">'first'</span></span>)); element(by.binding(<span class="hljs-string"><span class="hljs-string">'latest'</span></span>)); element(by.repeater(<span class="hljs-string"><span class="hljs-string">'some'</span></span>));</code> </pre> <br> 完整列表可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">手册</a>页上找到。 <br><br> 这些方法简化了项目中定位器的创建和支持。 但是，您必须了解，在任何情况下“全部”都将转换为css。 事实是，WebDriver中进行交互的W3C协议只能与一组有限的定位器一起使用。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">w3.org</a>上查看此列表。 <br><br>  <b>TypeScript</b>是Microsoft创建的一种编程语言。  TypeScript与JavaScript的不同之处在于其键入变量的能力，对使用完整类的支持以及连接模块的能力。 <br><br> 与V8引擎配合使用的TS代码编写的代码已转换为JS代码，该代码已经在执行。 在此转换过程中，将检查代码是否符合要求。 例如，如果将某个字符串而不是int显式传递给某个地方的函数，则它不会“编译”。 <br><br>  <b>Jasmine</b>是用于测试JavaScript代码的框架。 实际上，多亏了他，我们的JS代码才变成了我们所谓的测试。 他负责管理这些测试。 <br><br> 下面我们看一下它的功能。 <br><br><h3> 组装和项目设置 </h3><br> 好吧，我们决定了一套框架，现在让我们把整个事情放在一起。 <br><br> 为了使用该代码，我选择了Microsoft的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Visual Studio Code</a> 。 尽管许多人用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebStorm</a>甚至是JetBrains的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Intellij Idea</a>编写。 <br><br> 我已经安装了NodeJS（v11.6.0）和NPM（6.9.0）。 如果没有的话，这不是问题；安装它们并不困难。 一切在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方网站</a>上都有足够详细的描述。 <br><br> 可以使用纱线代替NPM，尽管这对于小型项目而言并不重要。 <br><br> 在我们的IDE中，我们正在创建一个新项目。 我们在项目的根目录中创建package.json-在其中将描述项目所需的所有软件包。 <br><br> 您可以使用<i>npm init</i>命令创建它。 或者，您可以简单地将内容复制到文件中。 <br><br> 最初， <b>package.json</b>如下所示： <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@types/node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^10.5.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@types/jasmine"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.3.12"</span></span>, <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>: <span class="hljs-string"><span class="hljs-string">"^5.4.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"typescript"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.4.1"</span></span> } }</code> </pre><br> 之后，我们执行<i>npm install</i>命令来安装所有必需的模块及其依赖项（好吧，您还记得有关比黑洞重的东西的图片……） <br><br> 结果，我们应该有一个node_modules目录。 如果她出现了，那么一切都按计划进行。 如果没有，那么值得研究一下命令执行的结果，通常所有内容都在此处进行了详细描述。 <br><br><h3>  TypeScript及其配置 </h3><br> 要安装TypeScript，我们需要npm： <br><br><pre> <code class="plaintext hljs">npm install -g typescript</code> </pre><br> 确保已安装： <br><br><pre> <code class="plaintext hljs">$ tsc -v Version 3.4.1</code> </pre><br> 一切似乎井井有条。 <br><br> 现在，我们需要创建一个用于使用TS的配置。 它也应该位于项目的根目录，并称为<b>tsconfig.json。</b> <br><br> 其内容将如下所示： <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [<span class="hljs-string"><span class="hljs-string">"es6"</span></span>], <span class="hljs-string"><span class="hljs-string">"strict"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"outDir"</span></span> : <span class="hljs-string"><span class="hljs-string">"output_js"</span></span>, <span class="hljs-string"><span class="hljs-string">"types"</span></span> : [<span class="hljs-string"><span class="hljs-string">"jasmine"</span></span>, <span class="hljs-string"><span class="hljs-string">"node"</span></span>] }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"node_modules/*"</span></span> ] }</code> </pre><br> 简而言之，我们在此配置中指定了以下内容： <br><br><ul><li> 将最终的JS代码放在哪个目录中（在本例中为output_js） </li><li> 启用严格模式 </li><li> 表明我们正在使用哪些框架 </li><li> 编译中排除的node_modules </li></ul><br>  TS具有多种设置。 这些足以满足我们的项目需求。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在typescriptlang.org上</a>了解更多信息。 <br><br> 现在让我们看一下<i>tsc</i>命令的<i>工作原理</i> ，它将把我们的TS代码变成JS代码。 为此，请创建一个包含以下内容的简单check_tsc.ts文件： <br><br><pre> <code class="javascript hljs">saySomething(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saySomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message); }</code> </pre><br> 然后执行<i>tsc</i>命令（为此，您需要在项目目录中）。 <br><br> 我们将看到我们具有output_js目录，并且其中包含以下内容的类似js文件已出现： <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; saySomething(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saySomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message); }</code> </pre><br> 该文件已经可以使用node命令启动： <br><br><pre> <code class="plaintext hljs">$ node output_js/check_tsc.js Hello, world!</code> </pre><br> 因此，我们编写了第一个TypeScipt程序，恭喜。 现在让我们编写测试。  :) <br><br><h3> 量角器配置 </h3><br> 对于量角器，我们还需要一个配置。 但它不再是json形式，而是ts文件形式。 让我们将其称为config.ts并在其中编写以下代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Config } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config: Config = { <span class="hljs-attr"><span class="hljs-attr">seleniumAddress</span></span>: <span class="hljs-string"><span class="hljs-string">"http://127.0.0.1:4444/wd/hub"</span></span>, <span class="hljs-attr"><span class="hljs-attr">SELENIUM_PROMISE_MANAGER</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">capabilities</span></span>: { <span class="hljs-attr"><span class="hljs-attr">browserName</span></span>: <span class="hljs-string"><span class="hljs-string">"chrome"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*chromeOptions: { args: [ "--headless", "--window-size=800,600" ] }*/</span></span> }, <span class="hljs-attr"><span class="hljs-attr">specs</span></span>: [ <span class="hljs-string"><span class="hljs-string">"Tests/*Test.js"</span></span>, ] };</code> </pre><br> 在此文件中，我们指定了以下内容： <br><br> 首先，是运行中的Selenium服务器的路径。 运行起来非常简单，您只需<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载Standalone Server jar文件</a>和必要的驱动程序（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Chrome浏览器</a>的chrome驱动程序）。 接下来，编写以下命令： <br><br><pre> <code class="plaintext hljs">java -jar -Dwebdriver.chrome.driver=/path/to/chromedriver /path/to/selenium-server-standalone.jar</code> </pre><br> 结果，我们应该看到以下结论： <br><br><pre> <code class="plaintext hljs">23:52:41.691 INFO [GridLauncherV3.launch] - Selenium build info: version: '3.11.0', revision: 'e59cfb3' 23:52:41.693 INFO [GridLauncherV3$1.launch] - Launching a standalone Selenium Server on port 4444 2019-05-02 23:52:41.860:INFO::main: Logging initialized @555ms to org.seleniumhq.jetty9.util.log.StdErrLog 23:52:42.149 INFO [SeleniumServer.boot] - Welcome to Selenium for Workgroups.... 23:52:42.149 INFO [SeleniumServer.boot] - Selenium Server is up and running on port 4444</code> </pre><br> 默认端口4444。 可以使用-port参数或通过配置参数“ seleniumArgs” =&gt;“ -port”进行设置。 <br><br> 如果您想要更轻松，更快捷：可以下载npm软件包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">webdriver-manager</a> 。 <br><br> 然后使用启动，关闭等命令管理服务器。 并没有太大的区别，只是我更习惯于使用jar文件。  :) <br><br>  <b>其次</b> ，我们表示我们不想使用Promise管理器。 稍后再详细介绍。 <br><br>  <b>第三</b> ，我们为浏览器指定了功能。 例如，我注释了一部分，我们很容易以无头模式启动浏览器。 这是一个很酷的功能，但是它不允许您直观地观察我们的测试。 同时，我们正在学习-我想。  :) <br><br>  <b>第四</b> ，我们为规格（测试）指定了一个掩码。 一切都位于Tests文件夹中，并以Test.js结尾。 为什么在js而不是ts上？ 这是因为最后，Node将专门用于JS文件，而不适用于TS文件。 重要的是不要混淆，尤其是在工作开始时。 <br><br> 现在创建Tests文件夹并编写第一个测试。 他将执行以下操作： <br><br><ul><li> 禁用检查这是一个Angular页面。 否则，我们会收到以下错误消息：运行testForAngular时出错。 当然，对于“角度页面”，不需要关闭此检查。 </li><li> 转到Google页面。 </li><li> 检查是否有文本输入字段。 </li><li> 输入文本“量角器”。 </li><li> 单击提交按钮（它有一个相当复杂的定位器，因为有两个按钮，第一个是不可见的）。 </li><li> 可以预期URL将包含“量角器”一词-这意味着我们做对了所有事情，然后开始搜索。 </li></ul><br> 这是我得到的代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { browser, by, element, protractor } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'Search'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'Open google and find a text'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-comment"><span class="hljs-comment">//       let EC = protractor.ExpectedConditions; //    AngularJS await browser.waitForAngularEnabled(false); //   Google await browser.get('https://www.google.com/'); //    css = input[role='combobox'] let input_button = element(by.css("input[role='combobox']")); //     ( presenceOf) await browser.wait(EC.presenceOf(input_button), 5000); //     “protractor” await input_button.sendKeys("protractor"); //      css let submit_button = element(by.css(".FPdoLc input[type='submit'][name='btnK']")); //      ( ,     input-,   ) await browser.wait(EC.presenceOf(submit_button), 5000); //     await submit_button.click(); // ,  URL    'protractor' await browser.wait(EC.urlContains('protractor'), 5000); }); });</span></span></code> </pre><br> 在代码中，我们看到一切都以describe（）函数开头。 她来自茉莉花框架。 这是我们脚本的包装。 在它内部，可能有功能beforeAll（）和beforeEach（）在所有测试之前和每个测试之前执行任何操作。 实际上，它所测试的功能与（）一样多。 最后，如果已定义，则将在每个测试和所有测试之后执行afterAll（）和afterEach（）进行操作。 <br><br> 我不会谈论Jasmine的所有功能，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">jasmine.github.io</a>网站上阅读有关它们的信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br> 要运行我们的测试，您首先需要将TS代码转换为JS代码，然后运行它： <br><br><pre> <code class="plaintext hljs">$ tsc $ protractor output_js/config.js</code> </pre><br> 我们的测试开始了-我们很棒。  :) <br><br><img src="https://habrastorage.org/webt/0f/vu/wc/0fvuwcmgrgf-pspd7vngaweq2dy.png"><br><br> 如果测试没有开始，则值得检查： <br><br><ul><li> 该代码编写正确。 通常，如果代码中存在严重错误，我们将在tsc命令期间捕获它们。 </li><li> 该Selenium服务器正在运行。 为此，您可以打开URL http： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//127.0.0.1-00-00444/wd/hub-</a>应该有一个Selenium会话接口。 </li><li> 该Chrome通常从下载的chrome-driver版本开始。 为此，请在wd /集线器/页面上，单击创建会话，然后选择Chrome。 如果无法启动，则您需要更新Chrome或下载其他版本的chrome驱动程序。 </li><li> 如果所有操作均失败，则可以验证npm install命令是否已成功完成。 </li><li> 如果所有内容均正确编写，但仍然没有任何内容-尝试搜索该错误。 它通常会有所帮助。  :) </li></ul><br><h3>  NPM脚本 </h3><br> 为了使生活更轻松，您可以使命令的一部分成为npm别名。 例如，我想删除具有先前JS文件的目录，并在每次测试运行之前使用新的JS文件重新创建该目录。 <br><br> 为此，请将脚本项添加到package.json中： <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"rm -rf output_js/; tsc; protractor output_js/config.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@types/node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^10.5.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@types/jasmine"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.3.12"</span></span>, <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>: <span class="hljs-string"><span class="hljs-string">"^5.4.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"typescript"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.4.1"</span></span> } }</code> </pre><br> 现在输入<i>npm test</i>命令将发生以下情况：带有旧代码的output_js目录将被删除，将重新创建该目录，并将新的JS代码写入其中。 之后，测试将立即开始。 <br><br> 除了这组命令，您还可以指定其他您个人需要使用的命令。 例如，您可以在两次测试运行之间启动和终止硒服务器。 尽管这当然更容易在测试代码内部进行控制。 <br><br><h3> 关于承诺 </h3><br> 最后，我将讨论Promise，异步/等待以及NodeJS中的测试编写与相同的Java或Python有何不同。 <br><br>  JavaScript是一种异步语言。 这意味着代码并不总是按照编写顺序执行。 这包括HTTP请求，我们记得该代码通过HTTP与Selenium Server通信。 <br><br> 承诺（通常称为“承诺”）提供了一种组织异步代码的便捷方法。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">learning.javascript.ru上</a>了解有关它们的更多信息。 <br><br> 实际上，这些对象使一个代码依赖于另一代码的执行，从而保证了一定的顺序。 量角器会非常积极地处理这些对象。 <br><br> 让我们来看一个例子。 假设我们执行以下代码： <br><br><pre> <code class="java hljs">driver.findElement().getText();</code> </pre><br> 在Java中，我们希望我们返回String类型的对象。 在量角器中，情况并非如此，我们将返回一个Promise对象。 就像那样，以调试为目标进行打印将不起作用。 <br><br> 通常我们不需要打印结果值。 我们需要将其传递给已经可以使用该值的其他方法。 例如，它将检查文本是否符合预期。 <br><br>  Protractor中类似的方法也接受Promise对象作为输入，因此没有问题。 但是，如果您仍然想查看该值，则（）将派上用场。 <br><br> 这是我们可以在Google页面上打印按钮文本的方式（请注意，由于这是一个按钮，因此文本位于value属性内）： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   let submit_button = element(by.css(".FPdoLc input[type='submit'][name='btnK']")); //    await browser.wait(EC.presenceOf(submit_button), 5000); //   then()   await submit_button.getAttribute("value").then((text) =&gt; { console.log(text); });</span></span></code> </pre><br> 至于async / await关键字，这是使用异步代码的一种较新的方法。 它使您可以避免由于大量嵌套而先前在代码中形成的promise hell。 不过，您将无法完全摆脱Promise，需要与他们合作。 这是可以理解和详细的，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在JavaScript中设计异步/等待：优势，陷阱和使用功能中找到</a> 。 <br><br><h3> 家庭作业 </h3><br> 作为一项家庭作业，我建议为用AngularJS编写的页面编写测试： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">protractor-demo</a> 。 <br><br> 不要忘记从代码中删除有关在AngularJS上关闭页面检查的行。 并确保使用专门为AngularJS设计的定位器。 这没有什么特别的魔术，但是很方便。 <br><br><h3> 总结 </h3><br> 让我们盘点一下。 我们设法编写了可以在TypeScript + Protractor + Jasmine上运行的测试。 我们学习了如何构建这样的项目，创建必要的配置，并编写了第一个测试。 <br><br> 在此过程中，我们讨论了有关使用JavaScript自动测试的一些知识。 几个小时似乎很好。  :) <br><br><h3> 阅读什么，在哪里看 </h3><br>  <b>量角器</b>具有相当不错的手册，其中包含JavaScript示例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//www.protractortest.org/#/tutorial</a> <br>  <b>茉莉花</b>有手册： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//jasmine.github.io/pages/docs_home.html</a> <br>  <b>TypeScipt</b>有一个很好的入门： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <b>//www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html</b> <br><br> 在媒介上，有一篇关于TypeScript + Protractor + Cucumber的英文很好的文章： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//medium.com/@igniteram/e2e-testing-with-protractor-cucumber-using-typescript-564575814e4a</a> <br><br> 在我的存储库中，我发布了本文讨论的最终代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/KotovVitaliy/HarbProtractorJasmineJasmine</a> 。 <br><br> 在Internet上，您可以找到此堆栈上更复杂和更大项目的示例。 <br><br> 感谢您的关注！  :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451522/">https://habr.com/ru/post/zh-CN451522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451512/index.html">如何解析移动MMORPG网络协议</a></li>
<li><a href="../zh-CN451514/index.html">CSS Subgrid新闻</a></li>
<li><a href="../zh-CN451516/index.html">Spring框架中使用的设计模式</a></li>
<li><a href="../zh-CN451518/index.html">我们精简的移动网站</a></li>
<li><a href="../zh-CN451520/index.html">VDI：便宜又开朗</a></li>
<li><a href="../zh-CN451524/index.html">Autoplay Media Studio 8.5.3.0水壶如何破裂的故事</a></li>
<li><a href="../zh-CN451528/index.html">“顺其自然”：云提供商不同意个人数据</a></li>
<li><a href="../zh-CN451532/index.html">OpenStreetMap第459号世界新闻（04/30/2019-06/05/2019）</a></li>
<li><a href="../zh-CN451534/index.html">电子游戏开发中的12条动画原则</a></li>
<li><a href="../zh-CN451538/index.html">Amazon Redshift并行扩展指南和测试结果</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>