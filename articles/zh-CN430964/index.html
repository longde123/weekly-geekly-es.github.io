<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏽 👩🏾‍🎨 👼🏼 陈述式思维 🏎️ 👃🏾 👨🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好流浪者。 我们作为思想中的旅行者和状况的分析者，应该了解它的优点，以及在其他方面的优点，确切的位置，我想提请读者注意这一点。 


 假设每个步骤都完成了，我们如何将思想链顺序地组合在一起，控制控制流和内存中单元的状态？ 或者简单地通过描述问题陈述，告诉程序您要解决的特定任务，这足以编译所有程序...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>陈述式思维</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430964/"><p>你好流浪者。 我们作为思想中的旅行者和状况的分析者，应该了解它的优点，以及在其他方面的优点，确切的位置，我想提请读者注意这一点。 </p><br><p> 假设每个步骤都完成了，我们如何将思想链顺序地组合在一起，控制控制流和内存中单元的状态？ 或者简单地通过描述问题陈述，告诉程序您要解决的特定任务，这足以编译所有程序。 并不是将编码转换为会改变系统内部状态的命令流，而是将原理表达为排序的概念，因为不必想象在那里隐藏了哪种算法，您只需要获取排序的数据即可。 美国总统可以无休止地提及泡泡，他表达了自己理解编程的思想。 他只是发现有一个排序算法，并且他自己桌面上表中的数据本身无法以某种神奇的方式按字母顺序排列。 </p><br><p> 我对声明式的表达方式感到满意，并通过一系列命令和过渡来表达一切的想法似乎过时且过时，因为我们的祖父这样做，祖父为配线架上的触点接线并使指示灯闪烁，而且我们有一个监视器和语音识别功能，在这种发展水平上，您仍然可以考虑遵循以下命令...在我看来，如果您以逻辑语言表示该程序，它将看起来更易于理解，并且可以做到这一点。 在技​​术上，早在80年代就下了赌注。 </p><br><p> 好吧，介绍拖了.... </p><a name="habracut"></a><br><p> 首先，我将尝试重述快速排序机制。  <em>要对列表进行排序，您需要将其分为两个子列表，然后将排序后的一个子列表与另一个排序后的子列表组合在一起</em> 。 </p><br><p> 拆分操作必须能够将列表转换为两个子列表，其中一个包含所有基本性较低的元素，第二个列表仅包含较大的元素。 表达这一点，在Erlang上只写了两行： </p><br><pre><code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([])</span></span></span><span class="hljs-function">-&gt;</span></span>[]; qsort([H|T])-&gt;qsort([X||X&lt;-T,X&lt;H])++[H|qsort([X||X&lt;-T,X&gt;=H])].</code> </pre> <br><p> 思考过程结果的这些表达令我感兴趣。 </p><br><p> 以命令形式提供对排序原理的描述更加困难。 这种编程方法怎么会有优势，然后即使存在s-place-place，至少是fortran，也不会调用它。 是因为javascript以及所有语言的新标准中的lambda函数的所有趋势，都证实了算法上的不便。 </p><br><p> 我将尝试进行实验，以验证一种方法和另一种方法的优势，然后对其进行测试。 我将尝试证明可以对分类定义的声明式记录及其算法记录进行性能比较，并得出如何更正确地制定程序的结论。 也许这将通过简单的过时的方法通过算法和命令流将编程推向货架，而这些方法根本不适合使用，因为在Haskell或横截面中表达自己同样时尚。 也许不仅神仙的精灵可以使程序看起来清晰紧凑？ </p><br><p> 我将使用Python进行演示，因为它有多个范例，而且它根本不是C ++，也不再是Lisp。 您可以使用其他范例编写清晰的程序： </p><br><h1 id="sortirovka-1"> 排序1 </h1><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> S==[]:<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] H,T=S[<span class="hljs-number"><span class="hljs-number">0</span></span>],S[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> qsort([X <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X&lt;T])+[H]+qsort([X <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X&gt;=T])</code> </pre> <br><p> 可以这样说单词： <em>排序以第一个元素为基础，然后对所有较小的元素进行排序并将其连接到所有较大的元素，然后再进行排序</em> 。 <br> 也许这样的表达式比以附近某些元素的排列的笨拙形式编写的排序更快地工作。 是否可以更简洁地表达这一点，并且为此不需要太多的文字。 尝试大声提出按气泡排序的原则，并告诉<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">美国总统</a> ，因为他得到了这些神圣的数据，因此他了解了算法并进行了如下处理：例如， <em>要对列表进行排序，您需要采用几个元素，将它们相互比较，然后如果第一个大于第二个，则必须进行交换，重新排列，然后您需要从列表的最开始重复搜索成对的此类元素，直到排列结束</em> 。 </p><br><p> 是的，排序气泡的原理听起来比快速排序版本更长，但是第二个优点不仅在于记录的简洁性，还在于它的速度，算法所表示的相同快速排序的表达是否会比声明性表达的版本更快？ 也许我们需要改变对教学程序设计的看法，这是日本人如何尝试在学校中介绍序言和相关思想教学的必要条件。 您可以系统地远离思想表达的算法语言。 </p><br><h1 id="sortirovka-2"> 排序2 </h1><br><p> 为了重现这一点，我不得不转向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文献</a> ，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hoar</a>的声明，我尝试将其转换为Python： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quicksort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, lo, hi)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lo &lt; hi: p = partition(A, lo, hi) quicksort(A, lo, p - <span class="hljs-number"><span class="hljs-number">1</span></span>) quicksort(A, p + <span class="hljs-number"><span class="hljs-number">1</span></span>, hi) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, lo, hi)</span></span></span><span class="hljs-function">:</span></span> pivot = A[lo] i = lo - <span class="hljs-number"><span class="hljs-number">1</span></span> j = hi + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> do: i= i + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> A[i] &lt; pivot do : j= j - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> A[j] &gt; pivot <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= j: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> j A[i],A[j]=A[j],A[i]</code> </pre> <br><p> 我很佩服这个想法，这里需要一个无休止的循环，他会在那插入一个go-that）），那里有一些笑话。 </p><br><h1 id="analiz"> 分析方法 </h1><br><p> 现在，让我们列出一长串并按两种方法对其进行排序，并了解如何更快，更高效地表达我们的想法。 哪种方法更容易采用？ <br> 创建一个随机数列表作为一个单独的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">问题</a> ，这是如何表示的： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> S==[]:<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] H,T=S[<span class="hljs-number"><span class="hljs-number">0</span></span>],S[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> qsort([X <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X&lt;H])+[H]+qsort([X <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X&gt;=H]) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len)</span></span></span><span class="hljs-function">:</span></span> list=[random.randint(<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>,len)] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> monotonic start = monotonic() slist=qsort(list) print(<span class="hljs-string"><span class="hljs-string">'qsort='</span></span>+str(monotonic() - start)) <span class="hljs-comment"><span class="hljs-comment">##print(slist)</span></span></code> </pre> <br><p> 这是获得的测量值： </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; test(10000) qsort=0.046999999998661224 &gt;&gt;&gt; test(10000) qsort=0.0629999999946449 &gt;&gt;&gt; test(10000) qsort=0.046999999998661224 &gt;&gt;&gt; test(100000) qsort=4.0789999999979045 &gt;&gt;&gt; test(100000) qsort=3.6560000000026776 &gt;&gt;&gt; test(100000) qsort=3.7340000000040163 &gt;&gt;&gt;</code> </pre> <br><p> 现在，我在算法公式中重复此步骤： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quicksort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, lo, hi)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lo &lt; hi: p = partition(A, lo, hi) quicksort(A, lo, p ) quicksort(A, p + <span class="hljs-number"><span class="hljs-number">1</span></span>, hi) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, lo, hi)</span></span></span><span class="hljs-function">:</span></span> pivot = A[lo] i = lo<span class="hljs-number"><span class="hljs-number">-1</span></span> j = hi+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: i=i+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[i]&gt;=pivot) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (i&gt;=hi): <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: j=j<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[j]&lt;=pivot) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (j&lt;=lo): <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= j: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(j,lo) A[i],A[j]=A[j],A[i] <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len)</span></span></span><span class="hljs-function">:</span></span> list=[random.randint(<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>,len)] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> monotonic start = monotonic() slist=quicksort(list,<span class="hljs-number"><span class="hljs-number">0</span></span>,len<span class="hljs-number"><span class="hljs-number">-1</span></span>) print(<span class="hljs-string"><span class="hljs-string">'quicksort='</span></span>+str(monotonic() - start))</code> </pre> <br><p> 我必须致力于将算法的原始示例从古代资源转换为维基百科。 因此： <em>您需要获取支持元素并在子数组中排列元素，以便所有内容在左侧越来越少，在右侧越来越多。</em>  <em>为此，将左侧与右侧元素交换。</em>  <em>我们对引用元素除以索引的每个子列表重复此操作，如果没有更改，请完成</em> 。 </p><br><h1 id="itogo"> 合计 </h1><br><p> 让我们看看同一列表的时差是多少，该列表又通过两种方法进行排序。 我们将进行100个实验，并绘制一个图表： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len)</span></span></span><span class="hljs-function">:</span></span> t1,t2=[],[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>): list=[random.randint(<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>,len)] list2=list[:] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> monotonic start = monotonic() slist=qsort(list) t1+=[monotonic() - start] <span class="hljs-comment"><span class="hljs-comment">#print('qsort='+str(monotonic() - start)) start = monotonic() slist=quicksort(list2,0,len-1) t2+=[monotonic() - start] #print('quicksort='+str(monotonic() - start)) import matplotlib.pyplot as plt fig = plt.figure() ax = fig.add_subplot(111) ax.plot(range(1,100),t1,label='qsort') ax.plot(range(1,100),t2,label='quicksort') ax.legend() ax.grid(True) plt.show() test(10000)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/k-/9c/gc/k-9cgcwk63v6bgvboi1xwwyrscu.png" alt="运行时间秒"></p><br><p> 在这里可以看到-quicksort（）函数的运行<strong>速度更快</strong> ，但是它的记录不是很明显，尽管该函数是递归的，但要理解其中执行的排列的工作并不容易。 </p><br><p> 那么，整理思想的哪种表达更<strong>自觉？</strong> </p><br><p> 在性能上的细微差别下，我们在代码的数量和复杂性上得到了这样的差别。 </p><br><p> 也许真理足以学习命令式语言，但是什么对您更有吸引力？ </p><br><h1 id="ps-a-vot-i-prolog">  PS。 这是序言： </h1><br><pre> <code class="plaintext hljs">qsort([],[]). qsort([H|T],Res):- findall(X,(member(X,T),X&lt;H),L1), findall(X,(member(X,T),X&gt;=H),L2), qsort(L1,S1), qsort(L2,S2), append(S1,[H|S2],Res).</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430964/">https://habr.com/ru/post/zh-CN430964/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430954/index.html">Qt无处不在：WebAssembly和WebGL流</a></li>
<li><a href="../zh-CN430956/index.html">我们教小猪们相信自己并飞翔</a></li>
<li><a href="../zh-CN430958/index.html">我们在Azure DevOps（VSTS）中使用单元测试启动容器</a></li>
<li><a href="../zh-CN430960/index.html">关于来自桌面展览的gamedev</a></li>
<li><a href="../zh-CN430962/index.html">Visual Studio Code中的Razor支持</a></li>
<li><a href="../zh-CN430966/index.html">Atlassian Jira Software的常规冲刺</a></li>
<li><a href="../zh-CN430968/index.html">“头脑在线。” 无人机无处不在</a></li>
<li><a href="../zh-CN430970/index.html">个人云</a></li>
<li><a href="../zh-CN430972/index.html">node.js服务器端-处理错误。 第一部分</a></li>
<li><a href="../zh-CN430974/index.html">莫斯科云1cloud很棒的照片之旅</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>