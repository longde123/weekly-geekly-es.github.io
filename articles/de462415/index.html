<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•¶ üö° üï¢ Bereitstellen von Symfony + React-Anwendungen auf AWS √ºber CI üñêüèª üì§ üí©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, in diesem Artikel werde ich zeigen, wie die Symfony 4-Anwendung unter AWS bereitgestellt wird. Es gibt ein Beispiel f√ºr einen solchen Proze...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereitstellen von Symfony + React-Anwendungen auf AWS √ºber CI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462415/"> Guten Tag, in diesem Artikel werde ich zeigen, wie die Symfony 4-Anwendung unter AWS bereitgestellt wird.  Es gibt ein Beispiel f√ºr einen solchen Prozess in der offiziellen Dokumentation, aber meine Version ist nicht so trivial wie das Herunterladen eines Zip-Archivs mit einer Anwendung.  Im Jahr 2019 werden im Docker-Modus die Microservice-Architektur und die CI / CD-Praktiken endlich in die Tools nicht nur von DevOps-Ingenieuren, sondern auch von gew√∂hnlichen <s>sterblichen</s> Entwicklern aufgenommen.  Um den Artikel interessanter zu gestalten, habe ich React.JS eine Front hinzugef√ºgt, um die Bed√ºrfnisse von mehr Personen abzudecken. Wenn Ihre Anwendung Encore nicht verwendet - es spielt keine Rolle, ich werde angeben, wie die Docker-Datei f√ºr Sie ge√§ndert werden soll. Die Unterst√ºtzung f√ºr React.JS wirkt sich nur darauf aus .  Wer wird an diesem Tutorial interessiert sein?  Zun√§chst richtet es sich an PHP-Entwickler, die ihre Bereitstellungspraxis √§ndern m√∂chten - sich von den √ºblichen Kanonen entfernen und Docker verwenden, um ihre Anwendung zu packen und das Image zu erstellen.  Sie k√∂nnen jedoch etwas tiefer gehen, und die weitere Beschreibung zielt darauf ab, die Anwendung automatisch von Git √ºber die CI / CD-Plattform bereitzustellen (CircleCI wird verwendet, aber wenn Sie an der Gitlab-Konfiguration interessiert sind, schreiben Sie in die Kommentare, ich werde sie anh√§ngen).  Tats√§chlich ist es f√ºr React / PHP absolut nicht wichtig, ob Sie eine Anwendung oder beispielsweise .NET Core haben. Dieser Teil ist f√ºr Entwickler interessant, um allgemein F√§higkeiten zur Bereitstellungsautomatisierung zu erwerben.  Der Quellcode ist im Github-Repository verf√ºgbar, Link am Ende des Artikels.  Nun, lass uns gehen! <br><a name="habracut"></a><br>  Ich gehe davon aus, dass Sie Ihre eigene Symfony-Anwendung haben, aber zu Demonstrationszwecken habe ich ‚ÄûHallo Welt!‚Äú Skizziert, die die folgenden Pakete enth√§lt: <br><br>  <code>`symfony/webpack-encore-bundle symfony/form symfony/orm-pack symfony/profiler-pack symfony/security-bundle symfony/twig-bundle symfony/validator symfony/phpunit-bridge`</code> ist ein minimaler Gentleman-Satz.  Im Moment sollte die Ordnerstruktur wie folgt aussehen: <br><br><img width="350" src="https://habrastorage.org/webt/6m/ck/xi/6mckxiczmqlde3nsjhdpzcbforq.png" alt="Bild"><br><br>  Jetzt m√ºssen Sie Ihre Cloud-Infrastruktur konfigurieren.  Ich werde mich nicht auf die Registrierung und Aktivierung des Testzeitraums von AWS konzentrieren. In dieser Phase m√ºssen wir zwei DB-Instanzen erstellen. Ich werde zwei Arten von Umgebungen verwenden: STG (Staging), um die Implementierung neuer ‚ÄûFunktionen‚Äú und PROD (Produktion) als direkten ‚ÄûKampf‚Äú zu testen. Server  Es wurden viele Artikel √ºber die Vorteile der Managed Service-Datenbank geschrieben. Dar√ºber hinaus verfolgen wir in diesem Handbuch haupts√§chlich die Bequemlichkeit f√ºr den Entwickler. Daher verwenden wir RDS, anstatt unseren eigenen separaten Datenbankserver zu erstellen.  Als DBMS f√ºr dieses Beispiel habe ich PostgreSQL verwendet. Sie k√∂nnen eine beliebige ausw√§hlen, zum RDS-Dienst gehen und zwei Instanzen der ben√∂tigten Kapazit√§t und des ben√∂tigten Volumens erstellen.  Da die <code>.env</code> Datei in Symfony "out of the box" f√ºr uns verf√ºgbar ist, verwenden wir sie beispielsweise f√ºr PROD. F√ºr STG erstellen wir eine Kopie von <code>.env.stg</code> und √§ndern <code>APP_ENV=dev</code> in <code>APP_ENV=stg</code> in <code>.env.stg</code> und <code>APP_ENV=dev</code> on <code>APP_ENV=prod</code> in <code>.env</code> und geben Sie auch die <code>.env</code> f√ºr jede der erstellten Instanzen ein. <br><br>  Gro√üartig, ein Anfang wurde gemacht!  Wie Sie wissen, werden Symfony-Abh√§ngigkeiten √ºber Composer installiert. Verwenden Sie zum Installieren die Datei composer.sh, die wir im Stammverzeichnis des Projekts ablegen: <br><br><div class="spoiler">  <b class="spoiler_title">composer.sh</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/bin/sh EXPECTED_SIGNATURE="$(wget -q -O - https://composer.github.io/installer.sig)" php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" ACTUAL_SIGNATURE="$(php -r "echo hash_file('sha384', 'composer-setup.php');")" if [ "$EXPECTED_SIGNATURE" != "$ACTUAL_SIGNATURE" ] then &gt;&amp;2 echo 'ERROR: Invalid installer signature' rm composer-setup.php exit 1 fi php composer-setup.php --quiet RESULT=$? rm composer-setup.php exit $RESULT</code> </pre> <br></div></div><br>  Dies <a href="">ist eine Softwareinstallationsanleitung von Composer</a> . <br><br>  Erstellen Sie nun f√ºr jede Umgebung Ihre eigene Docker-Datei im Stammverzeichnis des Projekts: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile.stg (Inszenierung)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ COPY ./.env.stg ./.env RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  und <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile (Produktion)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  Dateien k√∂nnen "wie sie sind" verwendet werden, es werden keine Makros f√ºr √Ñnderungen verwendet.  Lassen Sie uns durch den Inhalt der Docker-Datei gehen, um die ‚Äûmagische‚Äú Ber√ºhrung zu zerstreuen.  Als "Grundlage" verwenden wir das offizielle PHP 7.2.19-Image mit dem integrierten Apache-Webserver (Sie k√∂nnen jedes Ihrer Wahl verwenden, ein Bundle mit Nginx konfigurieren usw. In diesem Beispiel verwende ich meiner Meinung nach am h√§ufigsten das oben genannte. bequem).  Die Expose-Zeile ist f√ºr uns im Moment nicht wichtig, sie selbst macht nichts, wird aber in Zukunft von ElasticBeanstalk verwendet, das sie f√ºr die korrekte Bereitstellung ben√∂tigt.  Die folgenden Konstruktionen verwenden PHP-optimierte Produktionseinstellungen, die vom Hersteller empfohlen werden. Aktivieren Sie mod_rewrite f√ºr Apache und erh√∂hen Sie den maximalen Speicher f√ºr ein PHP-Skript von 128 auf 256 MB, damit Composer ordnungsgem√§√ü funktioniert.  Als n√§chstes installieren wir die erforderlichen Anwendungen, PHP-Abh√§ngigkeiten und Erweiterungen und konfigurieren sie sofort.  Wir weisen den Ordner / var / www dem Arbeitsverzeichnis unserer Anwendung zu - der Quellcode unserer Anwendung wird dort kopiert.  Da Apache standardm√§√üig / var / www als Einstiegspunkt f√ºr seinen Host verwendet und sich die Symfony-Indexdatei in / var / www / public befindet, √§ndern wir den Stamm des Apache-Dokuments mit der folgenden Konstruktion.  Dann installieren wir Composer, NodeJS und Garn nacheinander (wenn Sie encore / react.js in Ihrer Anwendung nicht verwenden, ben√∂tigen Sie die letzten beiden Punkte nicht).  Schlie√ülich kopieren wir unseren Quellcode und beginnen mit der Installation von Abh√§ngigkeiten √ºber Composer f√ºr Symfony und Garn f√ºr react.js.  Die Bedeutung einer separaten Docker-Datei f√ºr STG liegt in der vorletzten Anweisung f√ºr Docker - Kopieren von .env.stg nach .env, sodass die .env-Datei im STG-Image die f√ºr diese Umgebung relevanten Parameter enth√§lt.  Sie k√∂nnen das Image lokal (nat√ºrlich mit installiertem Docker) sammeln, ausf√ºhren und sicherstellen, dass die Anwendung funktioniert und f√ºr diese Arbeit nichts anderes ben√∂tigt: <br><br><pre> <code class="plaintext hljs">docker build -t tmp:stg -f Dockerfile.stg . docker run -p 80:80 tmp:stg</code> </pre> <br>  f√ºr STG und <br><br><pre> <code class="plaintext hljs">docker build -t tmp:prod . docker run -p 80:80 tmp:prod</code> </pre> <br>  f√ºr PROD. <br>  Wir k√∂nnen EC2 verwenden, ELB / ASG konfigurieren usw. oder ElasticBeanstalk verwenden, was aus praktischen Gr√ºnden nur ein Geschenk f√ºr uns ist.  Gehen Sie zum Abschnitt ElasticBeanstalk und erstellen Sie eine neue Anwendung mit Namen und Beschreibung.  Erstellen Sie dann zwei zuvor erw√§hnte Umgebungen: STG und PROD, erstellen Sie beide Umgebungen als Webserverumgebung, geben Sie "Docker" als Plattform an und belassen Sie die Beispielanwendung als Anwendungscode.  Die Bereitstellung in ElasticBeanstalk erfolgt durch Hochladen von Projektdateien oder Anweisungen, normalerweise in einem Zip-Archiv.  In unserem Fall sieht der Ablauf folgenderma√üen aus: Wir erfassen das Docker-Image unserer Anwendung, laden es in das Repository und laden die Anweisung anstelle des Quellarchivs oder des Docker-Images, wodurch ElasticBeanstalk angewiesen wird, das Image vom Remote-Server zu √ºbernehmen und bereitzustellen.  Und das alles automatisch. <br><br>  Beginnen wir mit der Erstellung eines Repositorys zum Speichern von Docker-Images.  Es gibt 2 M√∂glichkeiten: <br><br>  1 - Ihr Projekt ist privat, sein Code ist geschlossen und das Repository muss ebenfalls geschlossen sein.  In diesem Fall f√ºhren Sie entweder irgendwo Ihr eigenes Bildregister oder verwenden eine private Cloud.  AWS verf√ºgt √ºber ECR f√ºr diese Zwecke. Sie k√∂nnen dort ein Repository erstellen, aber niemand zwingt Sie dazu. <br><br>  2 - Sie haben ein Open Source-Projekt und k√∂nnen Dockerhub verwenden. <br><br>  In unserem Beispiel ist der Code offen, aber ich werde zeigen, wie geschlossene Repositorys verwendet werden. Nachdem Sie diesen Prozess verstanden haben, wird es nicht schwierig sein, ein Bild von Dockerhub aus zu verbinden.  Als erstes m√ºssen wir das Repository selbst erstellen. Danach erhalten Sie den eindeutigen URI.  Die weitere Beschreibung wird f√ºr Dritte gelten (nicht f√ºr AWS ECR-Repositories und deren Integration), f√ºr ECR werde ich danach schreiben. <br><br>  Nach dem Erstellen des Repositorys m√ºssen wir uns bei diesem Dienst anmelden, und es gibt einen kleinen Trick ... Gehen Sie zu den Einstellungen Ihres lokal installierten Dockers und √ºberpr√ºfen Sie, ob Sie die Option zum Speichern von Kennw√∂rtern im externen Speicher entfernt haben (f√ºr MacOS-Benutzer: ‚ÄûDocker-Anmeldungen sicher speichern in macOS Keychain ‚Äù), sonst ist die ben√∂tigte Konfigurationsdatei leer.  Und so autorisieren wir im ausgew√§hlten Dienst das Speichern der Register Ihrer Bilder: <br><br><pre> <code class="plaintext hljs">docker login -u LOGIN -p PASSWORD REGISTRY</code> </pre> <br>  Nach erfolgreicher Authentifizierung wird die folgende Konstruktion in der Konfigurationsdatei ~ / .docker / config.json angezeigt: <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> }</code> </pre><br>  Wenn es nicht angezeigt wird, √ºberpr√ºfen Sie die oben beschriebene Docker-Konfiguration erneut. <br><br>  Jetzt ist alles bereit, um die Anweisungsdatei f√ºr ElasticBeanstalk - Dockerrun.aws.json vorzubereiten. Der Code lautet wie folgt: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Im Allgemeinen sieht die Anweisung folgenderma√üen aus: Nachdem Sie sich mit dem Schl√ºssel von KEY_PATH im S3-Speicher BUCKET_ID angemeldet haben, laden Sie das Image, indem IMAGE_URL das gespeicherte √ºberschreibt, und leiten Sie es durch Portieren von Port 80 an denselben Port im Container.  Nun zu den verwendeten Konstanten: <br><br>  BUCKET_ID ist der ‚ÄûRucksack‚Äú, der im S3-Dienst automatisch f√ºr Sie erstellt wird. Er hat die Form von ElasticBeanstalk-REGION-HASH. Hier findet das System Servicedateien f√ºr Ihren ElasticBeanstalk, einschlie√ülich Anwendungsdateien, die Sie √ºber die Schaltfl√§che ‚ÄûHochladen und Bereitstellen‚Äú herunterladen. <br><br>  KEY_PATH - Pfad zur Autorisierungsdatei zum Image-Repository. Ich verwende das Format APP_NAME / cr.json, dh im Ordner in BUCKET_ID unter dem Namen meiner Anwendung (ich erstelle, falls noch nicht). Ich stelle die Datei cr.json mit dem nach der Autorisierung erhaltenen Code in das Register Bilder vor Ort: <br><br><div class="spoiler">  <b class="spoiler_title">BUCKET_ID / APP_NAME / cr.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> } }</code> </pre> </div></div><br>  IMAGE_URL ist die eindeutige URI Ihres Bildregisters + Tag des Bildes selbst, hier sollte alles klar sein. <br><br>  Jetzt k√∂nnen wir diese Datei als Version unserer Anwendung in ElasticBeanstalk herunterladen. Er ruft das angegebene Image auf und stellt es bereit. <br><br>  Dieser Prozess muss noch automatisiert werden.  Und um absolut interessant zu sein, werde ich die Abfolge der Schritte f√ºr den n√§chsten Ablauf implementieren: F√ºr alle Commits NICHT im Master-Zweig wird das Image gesammelt und in der STG-Umgebung bereitgestellt. Wenn wir in den Master pushen oder besser, schlie√üen Sie es und f√ºllen Sie es mit einer Zusammenf√ºhrungsanforderung Dann wird der Code auf PROD bereitgestellt.  So erhalten wir in PROD einen aktuellen Assistenten, in dem alles in Ordnung sein sollte, und Verzweigungen zum Entwickeln und Testen von neuem Code in STG.  F√ºr diese Implementierung ben√∂tigen wir Anweisungen zum Hochladen nicht aktueller Bilder, zum Kopieren von Dockerrun.aws.json in Dockerrun.aws.stg.json und zum Umbenennen von Dockerrun.aws.json in Dockerrun.aws.prod.json (nur zur Vereinfachung). <br><br>  Das einzige, was Dockerrun.aws.stg.json von Dockerrun.aws.prod.json unterscheidet, ist IMAGE_URL: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.stg.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL:dev"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Wie ich am Anfang des Artikels sagte, werde ich CircleCI als CI / CD verwenden, was nach meinen pers√∂nlichen Gef√ºhlen schneller ist als GitlabCI, wenn ich die kostenlose SaaS-Version verwende.  Free Travis w√ºrde dies tun, aber da es nicht mit privaten Git-Repositories funktioniert, habe ich keine spezielle Demo durchgef√ºhrt, damit es keine Entt√§uschung gibt, wenn eine solche Gelegenheit ben√∂tigt wird.  Ich √ºberlasse die Einstellungen f√ºr das Projekt in CircleCI den Lesern, um sie selbst zu studieren. Ich gebe die f√ºr die Bereitstellung erforderlichen Anweisungen selbst. Im Stammverzeichnis unseres Projekts erstellen wir den Ordner .circleci in der Datei config.yml mit den folgenden Inhalten: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br>  Ich habe den Flow selbst etwas fr√ºher gemalt. Hier wird er in yaml-Anweisungen f√ºr CircleCI √ºbersetzt. Lassen Sie uns die Implementierung bestimmter Schritte durchgehen.  Es ist wichtig zu beachten, dass f√ºr CI definierte Umgebungsvariablen vorhanden sind, die von ihm w√§hrend der Arbeit verwendet werden: <br><br>  CI_REGISTRY, CI_REGISTRY_USER, CI_REGISTRY_PASSWORD werden ben√∂tigt, um auf den Docker-Image-Speicher zuzugreifen - dasselbe, was wir in cr.json eingegeben haben, nur ohne base64 <br><br>  CI_REGISTRY / CI_REGISTRY_ID bilden eine eindeutige Bild-URL ohne Tag <br><br>  AWS_ACCESS_KEY_ID und AWS_SECRET_ACCESS_KEY - die Namen sprechen f√ºr sich. Dies sind AWS-Gutschriften f√ºr den Benutzer, in dessen Auftrag CircleCI bereitgestellt wird.  Gehen Sie zu AWS IAM und erstellen Sie einen Benutzer, f√ºgen Sie ihn der Gruppe der Administratoren hinzu und gew√§hren Sie nur programmgesteuerten Zugriff.  Denken Sie daran, dass AWS_SECRET_ACCESS_KEY nur einmal zum Anzeigen / Kopieren verf√ºgbar ist. Nachdem Sie auf den Show-Link geklickt haben, wird er nicht mehr angezeigt. <br><br>  Zur√ºck zu den CircleCI-Konfigurationsschritten.  Was ist die Magie?  Checkout l√§dt den Quellcode aus dem Git-Zweig in das aktuelle Arbeitsverzeichnis. Dieser Vorgang wird bei jedem Job wiederholt.  W√§hrend des Erstellungsprozesses melden wir uns nacheinander beim Repository an, sammeln den auf Dockerfile.stg basierenden Code unter dem Tag XXX: dev und senden ihn an das Repository.  Build-Master macht dasselbe, nur f√ºr den Build wird die "normale" Docker-Datei unter dem Tag XXX: latest verwendet. <br><br>  deploy-stg installiert die AWS EB-CLI und erstellt ein Berechtigungsprofil in der Datei ~ / .aws / config, das f√ºr die ordnungsgem√§√üe Funktion der CLI erforderlich ist. Anschlie√üend werden die Variablen f√ºr die CLI initialisiert. Sie m√ºssen die von Ihnen ausgew√§hlte Region, die Plattform und immer Docker und den Namen Ihrer Anwendung angeben.  Als N√§chstes kopieren wir den Inhalt von Dockerrun.aws.stg.json in die neue Datei Dockerrun.aws.json und geben unter Verwendung der spezifischen Umgebung und Region einen Befehl zum Bereitstellen unserer Anwendung unter Verwendung des erstellten Berechtigungsprofils.  Standardm√§√üig wird aufgrund dieses Befehls der gesamte Code des √ºberwachten Zweigs in einem Zip-Archiv gespeichert, das auf ElasticBeanstalk heruntergeladen und dort entpackt wird. Dieser Vorgang ist jedoch relativ teuer. Daher haben wir eine neue Datei Dockerrun.aws.json erstellt, die ausreicht, um die von uns erstellte Datei bereitzustellen Remote-Image, und wir m√ºssen es tats√§chlich nur hochladen.  Erstellen Sie dazu eine .ebignore-Datei im Projektstamm: <br><br><div class="spoiler">  <b class="spoiler_title">.ebignore</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">* !Dockerrun.aws.json</code> </pre></div></div><br>  Diese Datei verwendet die .gitignore-Syntax und ist .gitignore, jedoch nicht f√ºr die Git-CLI, sondern f√ºr die AWS EB-CLI.  In dieser Datei fordere ich die CLI auf, alle Dateien au√üer Dockerrun.aws.json zu √ºberspringen.  Wenn Sie jetzt den Job "deploy-stg" in ElasticBeanstalk ausf√ºhren, wird nur die von uns erstellte Datei gesendet.  deploy-prod macht dasselbe, kopiert nur den Inhalt der Datei Dockerrun.aws.prod.json nach Dockerrun.aws.json, und der letzte gibt die Arbeitssequenz im CircleCI-Format an (deploy-stg nach dem Build und deploy-prod nach dem Build -master) und auf welchen Zweigen die Daten suchen (ignorieren: - master und nur: - master). <br><br>  Eine etwas andere Sache ist bei AWS ECR, wie ich versprochen habe, wir werden darauf zur√ºckkommen.  Sie m√ºssen sich nicht remote bei der ECR anmelden und eine cr.json-Datei erstellen, da ElasticBeanstalk ‚Äûeinen Bruder pers√∂nlich kennt‚Äú.  Dementsprechend wird Dockerrun.aws.json anders aussehen - es wird einfach keinen Authentifizierungsblock geben: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json (AWS ECR)</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Aber wie erfolgt dann die Authentifizierung?  Tatsache ist, dass der Dienst, der auf die ECR zugreift, bestimmte Rechte hat, die wiederum auf bestimmten Sicherheitsrichtlinien basieren.  In unserem Fall wird beim Starten der Bereitstellung √ºber die AWS-CLI von einem Drittanbieter-Server (von CI) die Rolle "aws-elasticbeanstalk-ec2-role" verwendet. Suchen Sie sie im AWS IAM im Abschnitt "Rollen" und f√ºgen Sie die zus√§tzliche Richtlinie "AmazonEC2ContainerRegistryReadOnly" hinzu.  Das Herunterladen von einem privaten Repository auf seinen ‚ÄûNachbarn‚Äú ist nun fehlerfrei erfolgreich. <br><br>  Dies wird jedoch genau von derselben VPC geladen. √úber die CLI ist der Docker-Anmeldebefehl auch nicht "ohne Tricks": Sie m√ºssen Credits f√ºr die Docker-Anmeldung √ºber die AWS-CLI erhalten (nur erhalten), daf√ºr gibt es einen Befehl <br><br> <code>aws ecr get-login --region REGION --no-include-email</code> <br> <br>  Dieser Befehl gibt eine Zeile des Formular-Docker-Logins zur√ºck ... <br><br> <code>eval $(aws ecr get-login --region EB_REGION --no-include-email)</code> <br> <br>  Der Befehl erh√§lt zuerst eine Zeichenfolge zur Authentifizierung und startet dann den entsprechenden Prozess.  In Anbetracht dieser Regeln f√ºr AWS ECR sieht die Anweisungsdatei f√ºr CircleCI folgenderma√üen aus: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml (f√ºr AWS ECR)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br>   docker-in-docker   setup_remote_docker   ,          .   ,       : <br><br><img width="350" src="https://habrastorage.org/webt/7e/cw/sj/7ecwsjkjjmr8myxiuutwkujwnkg.png" alt="Bild"><br><br>   ,     ,     ()      .   ¬´¬ª   .  ( - )  ,      ,         ,                . <br><br>    GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tutorial-aws-symfony-ci</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462415/">https://habr.com/ru/post/de462415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462401/index.html">Entwickler Tods√ºnden</a></li>
<li><a href="../de462403/index.html">Auswahl der Monitorgr√∂√üe: Winkelgr√∂√üentheorie, Begr√ºndung und Vergleich</a></li>
<li><a href="../de462407/index.html">Food Design Digest Juli 2019</a></li>
<li><a href="../de462409/index.html">Assembler-Codegenerator-Bibliothek f√ºr AVR-Mikrocontroller. Teil 1</a></li>
<li><a href="../de462411/index.html">L√∂se Sudoku mit Algorithmus X.</a></li>
<li><a href="../de462417/index.html">Apples Petition</a></li>
<li><a href="../de462421/index.html">Apollo Guidance Computer - Architektur und Systemsoftware. Teil 2</a></li>
<li><a href="../de462423/index.html">Projektmanagement</a></li>
<li><a href="../de462429/index.html">VueJs + VueRouter + modal. Noch ein Fahrrad</a></li>
<li><a href="../de462431/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 309 (29. Juli - 4. August)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>