<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏻 🈂️ 📒 Menuju QUIC: Yang Mendasari HTTP / 3 👨🏽‍⚕️ ⬇️ ✝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tonggak sejarah baru dalam sejarah Internet dimulai di depan mata kita: kita dapat berasumsi bahwa HTTP / 3 telah diumumkan. Pada akhir Oktober, Mark ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menuju QUIC: Yang Mendasari HTTP / 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/430436/"> Tonggak sejarah baru dalam sejarah Internet dimulai di depan mata kita: kita dapat berasumsi bahwa HTTP / 3 telah diumumkan.  Pada akhir Oktober, Mark Nottingham dari IETF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyarankan sudah memutuskan nama</a> untuk protokol baru yang telah dibangun IETF sejak 2015.  Jadi, alih-alih nama seperti QUIC, HTTP / 3 keras muncul.  Publikasi Barat sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://daniel.haxx.se/blog/tag/">menulis tentang ini</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.zdnet.com/article/http-over-quic-to-be-renamed-">lebih dari sekali</a> .  Sejarah QUIC dimulai di perut Good Corporation pada 2012, sejak saat itu hanya server Google yang mendukung koneksi HTTP-over-QUIC, tetapi waktu terus berjalan dan Facebook sudah mulai menerapkan teknologi ini (7 November, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Facebook</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LiteSpeed</a> membuat interaksi pertama melalui HTTP / 3 );  Saat ini, pangsa situs yang mendukung QUIC adalah 1,2%.  Akhirnya, kelompok kerja WebRTC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga melihat ke arah QUIC</a> (plus lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API QUIC</a> ), sehingga dalam waktu dekat video / audio real-time akan melalui QUIC alih-alih RTP / RTCP.  Oleh karena itu, kami memutuskan bahwa akan sangat bagus untuk mengungkapkan rincian QUET IETF: khusus untuk Habr, kami menyiapkan terjemahan dari titik yang telah lama dibaca i.  Selamat menikmati! <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r4/ee/3s/r4ee3svcbqzrlxwfzuajri7go04.png"></div><a name="habracut"></a><br>  QUIC (Quick UDP Internet Connections) adalah protokol layer transport standar baru yang dienkripsi dan memiliki banyak peningkatan HTTP: keduanya untuk mempercepat lalu lintas dan meningkatkan keamanan.  QUIC juga memiliki tujuan jangka panjang - untuk akhirnya menggantikan TCP dan TLS.  Pada artikel ini, kita akan melihat chip QUIC kunci dan mengapa web akan mendapat manfaat dari mereka, serta masalah-masalah mendukung protokol yang sama sekali baru ini. <br><br>  Bahkan, ada dua protokol dengan nama yang sama: Google QUIC (gQUIC), protokol asli yang dikembangkan oleh para insinyur Google beberapa tahun yang lalu, yang, setelah serangkaian percobaan, diadopsi oleh Internet Engineering Task Force (IETF) untuk standardisasi. <br><br>  IETF QUIC (selanjutnya hanya QUIC) sudah memiliki perbedaan kuat dengan gQUIC sehingga dapat dianggap sebagai protokol terpisah.  Dari format paket hingga jabat tangan dan pemetaan HTTP, QUIC telah meningkatkan arsitektur gQUIC asli dengan berkolaborasi dengan banyak organisasi dan pengembang yang memiliki tujuan bersama: untuk membuat Internet lebih cepat dan lebih aman. <br><br>  Jadi, perbaikan apa yang ditawarkan QUIC? <br><br><h2>  Keamanan Terpadu (dan Kinerja) </h2><br>  Salah satu perbedaan yang paling mencolok antara QUIC dan TCP terhormat adalah tujuan awalnya yang dinyatakan sebagai protokol transport yang <b>aman secara default</b> .  QUIC mencapai ini dengan menggunakan otentikasi dan enkripsi, yang biasanya terjadi pada tingkat yang lebih tinggi (misalnya, dalam TLS), dan bukan dalam protokol transport itu sendiri. <br><br>  Jabat tangan QUIC asli menggabungkan komunikasi tiga arah biasa melalui TCP dengan jabat tangan TLS 1.3, yang menyediakan otentikasi peserta, serta koordinasi parameter kriptografi.  Bagi mereka yang terbiasa dengan TLS: QUIC menggantikan level perekaman TLS dengan format frame sendiri, tetapi pada saat yang sama menggunakan jabat tangan TLS. <br><br>  Ini tidak hanya memungkinkan koneksi untuk selalu dienkripsi dan dikonfirmasi, tetapi juga lebih cepat untuk membuat koneksi awal: jabat tangan QUIC biasa membuat pertukaran antara klien dan server dalam satu lintasan, sementara TCP + TLS 1.3 membuat dua lintasan. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h2/lq/o4/h2lqo4o2itthtb_h7qopgt7kbc4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/ne/vg/g6nevg964eqgvmzillfvnet3lus.png"></div><br>  Namun, QUIC melangkah lebih jauh dan juga mengenkripsi metadata koneksi yang dapat dengan mudah dikompromikan oleh pihak ketiga.  Sebagai contoh, penyerang dapat menggunakan nomor paket untuk mengarahkan pengguna di beberapa jalur jaringan ketika migrasi koneksi digunakan (lihat di bawah).  QUIC mengenkripsi nomor paket, sehingga tidak dapat dikoreksi oleh orang lain selain peserta sebenarnya dalam koneksi. <br><br>  Enkripsi juga dapat efektif terhadap "stagnasi" - sebuah fenomena yang tidak memungkinkan fleksibilitas protokol untuk digunakan dalam praktik karena asumsi yang salah dalam implementasi (pengerasan - inilah mengapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TLS 1.3 ditata</a> untuk waktu yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lama</a> . Kami mempostingnya hanya setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa perubahan</a> yang cegah blok yang tidak diinginkan untuk revisi TLS baru). <br><br><h2>  Memblokir awal antrian (Head-of-line blocking) </h2><br>  Salah satu peningkatan besar yang diberikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://blog.cloudflare.com/introducing-">HTTP / 2</a> adalah kemampuan untuk menggabungkan permintaan HTTP yang berbeda dalam satu koneksi TCP.  Ini memungkinkan aplikasi HTTP / 2 memproses permintaan secara paralel dan memanfaatkan saluran jaringan dengan lebih baik. <br><br>  Tentu saja, ini adalah langkah maju yang signifikan.  Karena aplikasi sebelumnya diperlukan untuk memulai banyak koneksi TCP + TLS jika mereka ingin memproses beberapa permintaan HTTP secara bersamaan (misalnya, ketika browser perlu menerima CSS dan JavaScript untuk membuat halaman).  Membuat koneksi baru memerlukan beberapa jabat tangan, serta menginisialisasi jendela kelebihan: ini berarti memperlambat rendering halaman.  Permintaan HTTP gabungan menghindari ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/rc/lb/ljrclbypotymwhoajopsze57jry.jpeg"></div><br><br>  Namun, ada kekurangannya: karena beberapa permintaan / respons dikirimkan melalui koneksi TCP yang sama, semuanya semuanya sama-sama tergantung pada kehilangan paket, bahkan jika data yang hilang hanya menyangkut salah satu permintaan.  Ini disebut "memblokir awal antrian." <br><br>  QUIC melangkah lebih dalam dan memberikan dukungan kelas satu untuk menggabungkan permintaan, misalnya, permintaan HTTP yang berbeda dapat dianggap sebagai permintaan QUIC transport yang berbeda, tetapi pada saat yang sama mereka semua akan menggunakan koneksi QUIC yang sama - yaitu, jabat tangan tambahan tidak diperlukan, ada satu jabat tangan status kemacetan, permintaan QUIC dikirimkan secara independen - sebagai hasilnya, dalam banyak kasus, kehilangan paket hanya mempengaruhi satu permintaan. <br><br>  Dengan demikian, dimungkinkan untuk secara signifikan mengurangi waktu, misalnya, perenderan penuh halaman web (CSS, JavaScript, gambar, dan sumber daya lainnya), terutama dalam kasus jaringan yang kelebihan beban dengan kehilangan paket yang tinggi. <br><br><h2>  Sangat sederhana, ya? </h2><br>  Untuk memenuhi janjinya, protokol QUIC harus mengatasi beberapa asumsi bahwa banyak aplikasi jaringan telah menerima begitu saja.  Ini dapat mempersulit implementasi dan implementasi QUIC. <br><br>  QUIC dirancang untuk dikirimkan melalui datagram UDP untuk memfasilitasi pengembangan dan menghindari masalah dengan perangkat jaringan yang menjatuhkan paket protokol yang tidak dikenal (karena sebagian besar perangkat mendukung UDP).  Ini juga memungkinkan QUIC untuk hidup di ruang pengguna, jadi, misalnya, browser akan dapat mengimplementasikan fitur protokol baru dan menyampaikannya kepada pengguna akhir, tanpa menunggu pembaruan OS. <br><br>  Namun, tujuan yang baik untuk mengurangi masalah jaringan membuatnya lebih sulit untuk melindungi paket dan merutekannya dengan benar. <br><br><h2>  Satu NAT untuk bersatu dan bersatu dengan satu kehendak hitam </h2><br>  Biasanya, router NAT bekerja dengan koneksi TCP menggunakan tuple 4 nilai (sumber IP dan port plus IP dan port tujuan), serta memonitor paket TCP SYN, ACK dan FIN yang dikirimkan melalui jaringan;  router dapat menentukan kapan koneksi baru dibuat dan kapan berakhir.  Oleh karena itu, manajemen yang tepat dari ikatan NAT (komunikasi antara IP dan port internal dan eksternal) dimungkinkan. <br><br>  Dalam kasus QUIC, ini belum memungkinkan, karena  Router NAT modern belum tahu tentang QUIC, sehingga biasanya downgrade ke pemrosesan UDP default dan kurang akurat, yang berarti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">timeout dari durasi sewenang-wenang (kadang-kadang pendek)</a> , yang dapat mempengaruhi koneksi jangka panjang. <br><br>  Ketika pengikatan kembali terjadi (misalnya, karena batas waktu), perangkat di luar perimeter NAT mulai menerima paket dari sumber lain, yang membuatnya tidak mungkin untuk mempertahankan koneksi hanya menggunakan tupel dari 4 nilai. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xg/ze/kz/xgzekzn8kq0nhe9--wkbotrxxmq.png"></div><br><br>  Dan itu bukan hanya NAT!  Satu fitur QUIC disebut migrasi koneksi dan memungkinkan perangkat untuk mentransfer koneksi ke alamat / jalur IP lain sesuai kebijakan mereka.  Misalnya, klien seluler dapat mentransfer koneksi QUIC dari jaringan seluler ke jaringan WiFi yang sudah dikenal (pengguna telah memasuki kedai kopi favorit, dll.). <br><br>  QUIC mencoba menyelesaikan masalah ini dengan konsep ID koneksi: sepotong informasi yang panjangnya berubah-ubah, dikirimkan dalam paket QUIC dan memungkinkan untuk mengidentifikasi koneksi.  Perangkat Endpoint dapat menggunakan ID ini untuk melacak koneksi mereka tanpa berdamai dengan tuple.  Dalam praktiknya, harus ada banyak ID yang menunjukkan koneksi yang sama, misalnya, untuk menghindari menghubungkan jalur yang berbeda ketika koneksi dimigrasi - karena seluruh proses dikendalikan hanya oleh perangkat akhir, bukan oleh middlebox. <br><br>  Namun, mungkin ada masalah bagi operator telekomunikasi yang menggunakan anycast dan routing ECMP, di mana satu IP berpotensi mengidentifikasi ratusan atau ribuan server.  Karena router perbatasan di jaringan ini belum tahu cara menangani lalu lintas QUIC, mungkin paket UDP dari koneksi QUIC yang sama, tetapi dengan tupel yang berbeda, akan dikirim ke server yang berbeda, yang berarti pemutusan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d4/vq/us/d4vqusefrkw1ideoglo-_heq8py.png"></div><br><br>  Untuk menghindari hal ini, operator mungkin perlu menerapkan penyeimbang tingkat yang lebih pintar.  Ini dapat dicapai secara terprogram tanpa memengaruhi router perbatasan itu sendiri (misalnya, lihat proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Katran</a> dari Facebook). <br><br><h2>  Qpack </h2><br>  Fitur lain yang berguna dari HTTP / 2 adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-">Header Compression (HPACK)</a> , yang memungkinkan perangkat akhir untuk mengurangi ukuran data yang dikirim dengan membuang permintaan dan tanggapan yang tidak perlu. <br><br>  Secara khusus, di antara teknik-teknik lain, HPACK menggunakan tabel dinamis dengan header yang telah dikirim / diterima dari permintaan / tanggapan HTTP sebelumnya, yang memungkinkan perangkat untuk merujuk permintaan / respons baru ke header yang sebelumnya ditemui (alih-alih mengirimnya lagi) . <br><br>  Tabel HPACK harus disinkronkan antara encoder (pihak yang mengirim permintaan / respons) dan decoder (sisi penerima), jika tidak, decoder tidak dapat men-decode apa yang diterimanya. <br><br>  Dalam hal HTTP / 2 melalui TCP, sinkronisasi ini transparan karena layer transport (TCP) mengirimkan permintaan / tanggapan dalam urutan yang sama dengan yang dikirim.  Artinya, Anda dapat mengirim instruksi ke decoder untuk memperbarui tabel dalam permintaan / respons sederhana.  Tetapi dengan QUIC, segalanya menjadi jauh lebih rumit. <br><br>  QUIC dapat mengirimkan beberapa permintaan / respons HTTP ke berbagai arah pada saat yang bersamaan, yang berarti QUIC menjamin pesanan pengiriman dalam satu arah, sementara tidak ada jaminan seperti itu dalam hal berbagai arah. <br><br>  Misalnya, jika klien mengirim permintaan HTTP A dalam aliran QUIC A, serta permintaan B dalam aliran B, maka karena permutasi paket atau kehilangan jaringan, server akan menerima permintaan B sebelum permintaan A. Dan jika permintaan B dikodekan sebagai ditunjukkan di header permintaan A, maka server tidak akan dapat men-decode permintaan B, karena permintaan belum terlihat A. <br><br>  Protokol gQUIC memecahkan masalah ini dengan hanya membuat semua header (tetapi bukan badan) dari permintaan HTTP / tanggapan <b>berurutan</b> dalam aliran gQUIC tunggal.  Ini memastikan bahwa semua header datang dalam urutan yang benar, apa pun yang terjadi.  Ini adalah skema yang sangat sederhana, dengan bantuannya, solusi yang ada dapat terus menggunakan kode yang dipertajam di bawah HTTP / 2;  di sisi lain, ini meningkatkan kemungkinan memblokir awal antrian, yang dirancang untuk mengurangi QUIC.  Oleh karena itu, kelompok kerja QUET IETF mengembangkan pemetaan baru antara HTTP dan QUIC (HTTP / QUIC), serta prinsip kompresi tajuk baru, QPACK. <br><br>  Dalam draf akhir spesifikasi HTTP / QUIC dan QPACK, setiap pertukaran permintaan / respons HTTP menggunakan aliran QUIC dua arahnya sendiri, sehingga memblokir awal antrian tidak terjadi.  Juga, untuk mendukung QPACK, setiap peserta membuat dua aliran QUIC searah tambahan, satu untuk mengirim pembaruan tabel, yang lain untuk mengonfirmasi penerimaan mereka.  Dengan demikian, encoder QPACK dapat menggunakan tautan ke tabel dinamis hanya setelah decoder mengonfirmasi penerimaannya. <br><br><h2>  Refleksi pembiasan </h2><br>  Masalah umum dengan protokol berbasis UDP adalah kerentanan mereka terhadap serangan refleksi, ketika penyerang memaksa server untuk mengirim sejumlah besar data kepada korban.  Penyerang memalsukan IP-nya sehingga server berpikir bahwa permintaan data berasal dari alamat korban. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/ee/ov/4eeeovjfl-9or5j0uq-9he0btrg.png"></div><br>  Jenis serangan ini bisa sangat efektif ketika respons server jauh lebih besar daripada permintaan.  Dalam hal ini, mereka berbicara tentang "keuntungan." <br><br>  TCP biasanya tidak digunakan untuk serangan seperti itu, karena paket-paket di jabat tangan asli (SYN, SYN + ACK, ...) memiliki panjang yang sama, sehingga mereka tidak memiliki potensi untuk "amplifikasi". <br><br>  Di sisi lain, jabat tangan QUIC sangat asimetris: seperti pada TLS, pertama server QUIC mengirim rantai sertifikatnya, yang bisa sangat besar, meskipun fakta bahwa klien harus mengirim hanya beberapa byte (pesan dari ClientHello klien TLS dibangun ke dalam paket QUIC )  Untuk alasan ini, paket QUIC asli harus ditingkatkan ke panjang minimum tertentu, bahkan jika isi paket jauh lebih kecil.  Meskipun demikian, ukuran ini masih tidak terlalu efektif, karena respons server tipikal berisi beberapa paket dan karenanya mungkin lebih dari paket klien yang diperbesar. <br><br>  Protokol QUIC juga mendefinisikan mekanisme verifikasi sumber eksplisit: server, alih-alih memberikan respons besar, hanya mengirim paket coba lagi dengan token unik, yang kemudian dikirim klien ke server dalam paket baru.  Jadi server lebih percaya diri bahwa klien tidak memiliki alamat IP pengganti dan Anda dapat mengakhiri jabat tangan.  Kurang dari keputusan - waktu jabat tangan meningkat, alih-alih satu pass, dua sudah diperlukan. <br><br>  Solusi alternatif adalah mengurangi respons server ke ukuran di mana serangan refleksi menjadi kurang efektif - misalnya, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sertifikat ECDSA</a> (biasanya mereka jauh lebih kecil dari RSA).  Kami juga bereksperimen dengan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompresi sertifikat TLS</a> menggunakan algoritma kompresi yang tersedia seperti zlib dan brotli;  ini adalah fitur yang pertama kali muncul di gQUIC tetapi saat ini tidak didukung di TLS. <br><br><h2>  Kinerja UDP </h2><br>  Salah satu masalah konstan QUIC adalah perangkat keras dan lunak yang ada yang tidak dapat bekerja dengan QUIC.  Kami telah memeriksa bagaimana QUIC mencoba menangani middlebox jaringan seperti router, tetapi area lain yang berpotensi bermasalah adalah kinerja pengiriman / penerimaan data antara perangkat QUIC melalui UDP.  Selama bertahun-tahun, upaya telah dilakukan untuk mengoptimalkan implementasi TCP sebanyak mungkin, termasuk kemampuan offload bawaan dalam perangkat lunak (misalnya, sistem operasi) dan dalam perangkat keras (antarmuka jaringan), tetapi tidak ada yang menyangkut UDP. <br><br>  Namun, hanya masalah waktu sebelum implementasi QUIC melampaui peningkatan dan manfaat ini.  Lihatlah upaya baru-baru ini untuk mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemuatan UDP di Linux</a> , yang akan memungkinkan aplikasi untuk menggabungkan dan mentransmisikan beberapa segmen UDP antara ruang pengguna dan tumpukan jaringan ruang kernel dengan biaya sekitar satu segmen;  contoh lain adalah dukungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">zerocopy untuk soket di Linux</a> , berkat aplikasi mana yang dapat menghindari biaya menyalin memori ruang pengguna ke ruang kernel. <br><br><h2>  Kesimpulan </h2><br>  Seperti HTTP / 2 dan TLS 1.3, protokol QUIC harus membawa banyak fitur baru yang akan meningkatkan kinerja dan keamanan situs web dan peserta lain dalam infrastruktur Internet.  Kelompok kerja IETF bermaksud untuk meluncurkan versi pertama dari spesifikasi QUIC pada akhir tahun ini, jadi inilah saatnya untuk memikirkan bagaimana kita dapat memanfaatkan manfaat QUIC secara maksimal. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430436/">https://habr.com/ru/post/id430436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430426/index.html">Rebranding Western Digital Products: Apa yang Telah Berubah?</a></li>
<li><a href="../id430428/index.html">Situs "Escher II" dalam nominasi "proyek Internet Rakyat" Hadiah Runet 2018</a></li>
<li><a href="../id430430/index.html">Fullstack - mengapa keren, atau bagaimana mendapatkan kesenangan dari pekerjaan</a></li>
<li><a href="../id430432/index.html">Jendela modal yang Anda tunggu-tunggu. Atau cara memanggil sembulan dari tombol yang berbeda di JS murni</a></li>
<li><a href="../id430434/index.html">Meluncurkan penampil gambar dari Windows XP pada Windows modern</a></li>
<li><a href="../id430438/index.html">Bayangan realistis untuk roguelike</a></li>
<li><a href="../id430446/index.html">Sekali lagi tentang pro "perbudakan seluler"</a></li>
<li><a href="../id430448/index.html">Apa yang memberi pembelajaran mesin ritel: contoh proyek</a></li>
<li><a href="../id430450/index.html">Model pengembangan menggunakan CPU berbasis Stack sebagai contoh</a></li>
<li><a href="../id430452/index.html">Api, air, dan semprotan halus. Bagaimana warga dan pengunjung Lakhta Centre akan terlindungi dari api</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>