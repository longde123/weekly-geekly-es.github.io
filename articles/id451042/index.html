<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº üöù üèÇüèº Dasar-Dasar Desain Basis Data - Perbandingan PostgreSQL, Cassandra, dan MongoDB üì° üçë üë©üèº‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo teman-teman. Sebelum berangkat untuk bagian kedua dari liburan Mei, kami berbagi dengan Anda materi yang kami terjemahkan pada malam peluncuran a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-Dasar Desain Basis Data - Perbandingan PostgreSQL, Cassandra, dan MongoDB</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/451042/">  Halo teman-teman.  Sebelum berangkat untuk bagian kedua dari liburan Mei, kami berbagi dengan Anda materi yang kami terjemahkan pada malam peluncuran aliran baru dengan laju <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"DBMS Relasional"</a> . <br><br><img src="https://habrastorage.org/webt/tg/jk/pk/tgjkpk23xr333l_ee0lddnylafa.png"><br><br>  Pengembang aplikasi menghabiskan banyak waktu membandingkan banyak database operasi untuk memilih salah satu yang paling sesuai dengan beban kerja yang dituju.  Kebutuhan dapat mencakup pemodelan data yang disederhanakan, jaminan transaksional, kinerja baca / tulis, penskalaan horizontal, dan toleransi kesalahan.  Secara tradisional, pilihan dimulai dengan kategori basis data, SQL atau NoSQL, karena masing-masing kategori menyediakan serangkaian pertukaran yang jelas.  Kinerja tinggi dalam hal latensi rendah dan throughput tinggi biasanya dipandang sebagai persyaratan trade-off, dan oleh karena itu diperlukan untuk setiap basis data dalam sampel. <a name="habracut"></a><br><br>  Tujuan artikel ini adalah untuk membantu pengembang aplikasi membuat pilihan yang tepat antara SQL dan NoSQL dalam konteks pemodelan data aplikasi.  Kita akan melihat satu database SQL, yaitu PostgreSQL dan dua database NoSQL - Cassandra dan MongoDB, untuk berbicara tentang dasar-dasar desain database, seperti membuat tabel, mengisi mereka, membaca data dari tabel dan menghapusnya.  Pada artikel selanjutnya, kita pasti akan melihat indeks, transaksi, GABUNG, arahan TTL, dan desain basis data berbasis JSON. <br><br>  <b>Apa perbedaan antara SQL dan NoSQL?</b> <br><br><blockquote>  Database SQL meningkatkan fleksibilitas aplikasi dengan jaminan transaksional ACID, serta kemampuannya untuk meminta data menggunakan GABUNGAN secara tak terduga di atas model database relasional yang dinormalisasi yang ada. </blockquote><br>  Mengingat arsitektur monolitik / single-node dan penggunaan model replikasi master-slave untuk redundansi, database SQL tradisional tidak memiliki dua fitur penting - skalabilitas linear catatan (mis., Pemisahan otomatis menjadi beberapa node) dan kehilangan data otomatis / nol.  Ini berarti bahwa jumlah data yang diterima tidak dapat melebihi throughput tulis maksimum dari satu node.  Selain itu, beberapa kehilangan data sementara harus diperhitungkan selama toleransi kesalahan (dalam arsitektur tanpa berbagi sumber daya).  Di sini Anda perlu diingat bahwa komit baru-baru ini belum tercermin dalam salinan budak.  Pembaruan tanpa downtime juga sulit dicapai dalam database SQL. <br><br>  Basis data NoSQL biasanya didistribusikan secara alami, mis.  di dalamnya, data dibagi menjadi beberapa bagian dan didistribusikan di beberapa node.  Mereka membutuhkan denasionalisasi.  Ini berarti bahwa data yang dimasukkan juga harus disalin beberapa kali untuk menanggapi permintaan spesifik yang Anda kirim.  Tujuan keseluruhan adalah untuk mendapatkan kinerja tinggi dengan mengurangi jumlah pecahan yang tersedia saat membaca.  Ini mengikuti pernyataan bahwa NoSQL mengharuskan Anda untuk memodelkan kueri Anda, sementara SQL mengharuskan Anda untuk memodelkan data Anda. <br><br><blockquote> NoSQL berfokus pada pencapaian kinerja tinggi dalam cluster terdistribusi, dan ini adalah alasan utama untuk banyak trade-off desain database yang meliputi ACID kerugian transaksi, GABUNG, dan indeks sekunder global yang konsisten. </blockquote><br>  Dipercaya bahwa meskipun database NoSQL memberikan skalabilitas penulisan linier dan toleransi kesalahan yang tinggi, hilangnya jaminan transaksional membuat mereka tidak cocok untuk data penting misi. <br><br>  Tabel berikut menunjukkan bagaimana pemodelan data dalam NoSQL berbeda dari SQL. <br><br><img src="https://habrastorage.org/webt/sv/6k/or/sv6kor2fwminli9ywljf1hf5h34.png"><br><br>  <b>SQL dan NoSQL: Mengapa keduanya dibutuhkan?</b> <br><br>  Aplikasi dunia nyata dengan sejumlah besar pengguna, seperti Amazon.com, Netflix, Uber, dan Airbnb, melakukan tugas yang kompleks dan beragam.  Misalnya, aplikasi e-commerce seperti Amazon.com perlu menyimpan data yang ringan dan sangat kritis, seperti informasi tentang pengguna, produk, pesanan, faktur, bersama dengan data yang berat tetapi kurang sensitif, seperti ulasan produk, pesan dukungan , aktivitas pengguna, ulasan pengguna, dan rekomendasi.  Secara alami, aplikasi ini mengandalkan setidaknya satu database SQL bersama dengan setidaknya satu database NoSQL.  Dalam sistem antar-regional dan global, basis data NoSQL berfungsi sebagai cache yang didistribusikan secara geografis untuk data yang disimpan dalam sumber tepercaya, basis data SQL, yang bekerja di satu wilayah. <br><br>  <b>Bagaimana YugaByte DB menggabungkan SQL dan NoSQL?</b> <br><br>  Dibangun di atas mesin penyimpanan campuran berorientasi log, sharding otomatis, replikasi konsensus terdistribusi sharding, dan transaksi yang didistribusikan ACID (terinspirasi oleh Google Spanner), YugaByte DB adalah database open source pertama di dunia yang secara bersamaan kompatibel dengan NoSQL (Cassandra &amp; Redis) ) dan SQL (PostgreSQL).  Seperti yang ditunjukkan pada tabel di bawah ini, YSQL, YugaByte DB API yang kompatibel dengan Cassandra, menambahkan konsep transaksi ACID tunggal dan multi-kunci dan indeks sekunder global ke API NoSQL, sehingga membuka era database NoSQL transaksional.  Selain itu, YSQL, yang merupakan YugaByte DB API yang mematuhi PostgreSQL, menambahkan gagasan tentang penskalaan penulisan linier dan toleransi kesalahan otomatis ke SQL API, yang memperkenalkan basis data SQL terdistribusi ke dunia.  Karena database DB YugaByte pada dasarnya bersifat transaksional, API NoSQL sekarang dapat digunakan dalam konteks data mission-critical. <br><br><img src="https://habrastorage.org/webt/ln/1a/_9/ln1a_9ouduu15ccxhvud1nssmme.png"><br><br>  Seperti yang dinyatakan sebelumnya dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">‚ÄúMemperkenalkan YSQL: API SQL Terdistribusi Kompatibel PostgreSQL untuk YugaByte DB‚Äù</a> , pilihan antara SQL atau NoSQL di YugaByte DB sepenuhnya bergantung pada karakteristik beban kerja utama: <br><br><ul><li>  Jika beban kerja utama adalah operasi multi-kunci dengan BERGABUNG, maka ketika memilih YSQL, pahami bahwa kunci Anda dapat didistribusikan di beberapa node, yang akan mengarah ke penundaan yang lebih tinggi dan / atau throughput yang lebih rendah daripada di NoSQL. </li><li>  Jika tidak, pilih salah satu dari kedua API NoSQL, dengan mengingat bahwa Anda akan mendapatkan kinerja yang lebih baik sebagai hasil dari permintaan yang dilayani dari satu simpul pada satu waktu.  YugaByte DB dapat berfungsi sebagai basis data operasional tunggal untuk aplikasi yang sangat kompleks di mana Anda perlu mengelola beberapa beban kerja secara bersamaan. </li></ul><br>  Lab pemodelan data di bagian selanjutnya didasarkan pada database DB YugaByte yang kompatibel dengan PostgreSQL dan Cassandra API, sebagai lawan dari database sumber.  Pendekatan ini menekankan kemudahan interaksi dengan dua API yang berbeda (pada dua port yang berbeda) dari kelompok basis data yang sama, yang bertentangan dengan penggunaan kelompok yang sepenuhnya independen dari dua basis data yang berbeda. <br><br>  Pada bagian berikut, kita akan bertemu dengan lab pemodelan data untuk menggambarkan perbedaan dan beberapa fitur umum dari database yang dimaksud. <br><br>  <b>Lab Pemodelan Data</b> <br><br>  <b>Instalasi Database</b> <br><br>  Mengingat penekanan pada mendesain model data (daripada arsitektur penyebaran yang kompleks), kami akan menginstal basis data dalam wadah Docker di komputer lokal, dan kemudian kami akan berinteraksi dengan mereka menggunakan cangkang baris perintah yang sesuai. <br><br>  <b>Kompatibel dengan PostgreSQL &amp; Cassandra, Basis data DB YugaByte</b> <br><br><pre><code class="sql hljs">mkdir ~/yugabyte &amp;&amp; cd ~/yugabyte wget https://downloads.yugabyte.com/yb-docker-ctl &amp;&amp; chmod +x yb-docker-ctl docker pull yugabytedb/yugabyte ./yb-docker-ctl <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-comment"><span class="hljs-comment">--enable_postgres</span></span></code> </pre> <br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs">docker run <span class="hljs-comment"><span class="hljs-comment">--name my-mongo -d mongo:latest</span></span></code> </pre> <br>  <b>Akses Baris Perintah</b> <br><br>  Mari kita sambungkan ke database menggunakan shell baris perintah untuk API yang sesuai. <br><br>  <b>PostgreSQL</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">psql</a> adalah shell baris perintah untuk berinteraksi dengan PostgreSQL.  Untuk kemudahan penggunaan, YugaByte DB hadir dengan psql langsung di folder bin. <br><br><pre> <code class="sql hljs">docker exec -it yb-postgres-n1 /home/yugabyte/postgres/bin/psql -p 5433 -U postgres</code> </pre> <br>  <b>Cassandra</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cqlsh</a> adalah shell command-line untuk berinteraksi dengan Cassandra dan databasenya yang kompatibel melalui CQL (bahasa permintaan Cassandra).  Untuk kemudahan penggunaan, YugaByte DB hadir dengan <code>cqlsh</code> di <code>bin</code> . <br><br>  Perhatikan bahwa CQL terinspirasi oleh SQL dan memiliki konsep yang mirip dengan tabel, baris, kolom, dan indeks.  Namun, sebagai bahasa NoSQL, ia menambahkan serangkaian batasan tertentu, yang sebagian besar akan kami bahas dalam artikel lain. <br><br><pre> <code class="sql hljs">docker exec -it yb-tserver-n1 /home/yugabyte/bin/cqlsh</code> </pre> <br>  <b>Mongodb</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mongo</a> adalah shell baris perintah untuk berinteraksi dengan MongoDB.  Itu dapat ditemukan di direktori bin dari instalasi MongoDB. <br><br><pre> <code class="sql hljs">docker exec -it my-mongo bash cd bin mongo</code> </pre> <br>  <b>Pembuatan tabel</b> <br><br>  Sekarang kita dapat berinteraksi dengan database untuk melakukan berbagai operasi menggunakan baris perintah.  Mari kita mulai dengan membuat tabel yang menyimpan informasi tentang lagu yang ditulis oleh artis yang berbeda.  Lagu-lagu ini dapat menjadi bagian dari album.  Atribut opsional untuk tahun - lagu rilis, harga, genre, dan peringkat.  Kami perlu mempertimbangkan atribut tambahan yang mungkin diperlukan di masa mendatang melalui bidang "tag".  Itu dapat menyimpan data semi-terstruktur sebagai pasangan kunci-nilai. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">25</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>), CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>Cassandra</b> <br><br>  Membuat tabel di Cassandra sangat mirip dengan PostgreSQL.  <b>Salah satu perbedaan utama adalah kurangnya kendala integritas (misalnya, BUKAN NULL), tetapi ini adalah tanggung jawab aplikasi, bukan database NoSQL</b> .  Kunci utama terdiri dari kunci bagian (kolom Artis pada contoh di bawah) dan satu set kolom pengelompokan (kolom SongTitle pada contoh di bawah).  Kunci partisi menentukan partisi / beling mana untuk menempatkan baris, dan kolom pengelompokan menunjukkan bagaimana data harus diatur di dalam beling saat ini. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> KEYSPACE myapp; <span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> myapp; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>Mongodb</b> <br><br>  MongoDB mengatur data ke dalam basis data (Database) (mirip dengan Keyspace di Cassandra), di mana ada koleksi (Koleksi) (mirip dengan tabel) yang berisi dokumen (Dokumen) (mirip dengan baris dalam tabel).  MongoDB pada dasarnya tidak memerlukan definisi dari skema asli.  Perintah <i>"gunakan database" yang</i> ditunjukkan di bawah ini membuat instance dari database pada panggilan pertama dan mengubah konteks untuk database yang baru dibuat.  Bahkan koleksi tidak perlu dibuat secara eksplisit, koleksi itu dibuat secara otomatis, hanya ketika Anda menambahkan dokumen pertama ke koleksi baru.  Harap dicatat bahwa MongoDB menggunakan database uji secara default, oleh karena itu setiap operasi tingkat pengumpulan tanpa menentukan database tertentu akan dilakukan di dalamnya secara default. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase;</code> </pre> <br>  <b>Mengambil informasi tabel PostgreSQL</b> <br><br><pre> <code class="sql hljs">\d Music Table "public.music" Column | Type | Collation | Nullable | Default <span class="hljs-comment"><span class="hljs-comment">--------------+-----------------------+-----------+----------+-------- artist | character varying(20) | | not null | songtitle | character varying(30) | | not null | albumtitle | character varying(25) | | | year | integer | | | price | double precision | | | genre | character varying(10) | | | criticrating | double precision | | | tags | text | | | Indexes: "music_pkey" PRIMARY KEY, btree (artist, songtitle)</span></span></code> </pre> <br>  <b>Cassandra</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DESCRIBE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> MUSIC; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> myapp.music ( artist <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, songtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, albumtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, price <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>, genre <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, tags <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (artist, songtitle) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLUSTERING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> (songtitle <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> default_time_to_live = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> transactions = {<span class="hljs-string"><span class="hljs-string">'enabled'</span></span>: <span class="hljs-string"><span class="hljs-string">'false'</span></span>};</code> </pre> <br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase; <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> collections;</code> </pre> <br>  <b>Posting data ke tabel PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span>, Price, Genre, CriticRating, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'Somewhat Famous'</span></span>, <span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">2.14</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">7.8</span></span>, <span class="hljs-string"><span class="hljs-string">'{"Composers": ["Smith", "Jones", "Davis"],"LengthInSeconds": 214}'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, CriticRating) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hey Now'</span></span>, <span class="hljs-number"><span class="hljs-number">1.98</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">8.4</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">0.99</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">2.47</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-string"><span class="hljs-string">'{"radioStationsPlaying": ["KHCR", "KBQX", "WTNR", "WJJH"], "tourDates": { "Seattle": "20150625", "Cleveland": "20150630"}, "rotation": Heavy}'</span></span> );</code> </pre> <br>  <b>Cassandra</b> <br><br>  Secara umum, ekspresi <code>INSERT</code> di Cassandra terlihat sangat mirip dengan yang ada di PostgreSQL.  Namun, ada satu perbedaan besar dalam semantik.  Dalam Cassandra, <code>INSERT</code> sebenarnya adalah operasi <code>UPSERT</code> mana nilai terakhir ditambahkan ke string jika string sudah ada. <br><blockquote>  Entri data mirip dengan PostgreSQL <code>INSERT</code> atas </blockquote><br>  <b>Mongodb</b> <br><br>  Meskipun MongoDB adalah database NoSQL, seperti Cassandra, operasi penyisipannya tidak ada hubungannya dengan perilaku semantik di Cassandra.  Dalam MongoDB, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masukkan ()</a> tidak memiliki kemampuan <code>UPSERT</code> , yang membuatnya terlihat seperti PostgreSQL.  Menambahkan data default tanpa <code>_idspecified</code> akan menambahkan dokumen baru ke koleksi. <br><br> <code>db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "Call Me Today", <br> albumTitle: "Somewhat Famous", <br> year: 2015, <br> price: 2.14, <br> genre: "Country", <br> tags: { <br> Composers: ["Smith", "Jones", "Davis"], <br> LengthInSeconds: 214 <br> } <br> } <br> ); <br> db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "My Dog Spot", <br> albumTitle: "Hey Now", <br> price: 1.98, <br> genre: "Country", <br> criticRating: 8.4 <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Look Out, World", <br> albumTitle:"The Buck Starts Here", <br> price: 0.99, <br> genre: "Rock" <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Still In Love", <br> albumTitle:"The Buck Starts Here", <br> price: 2.47, <br> genre: "Rock", <br> tags: { <br> radioStationsPlaying:["KHCR", "KBQX", "WTNR", "WJJH"], <br> tourDates: { <br> Seattle: "20150625", <br> Cleveland: "20150630" <br> }, <br> rotation: "Heavy" <br> } <br> } <br> );</code> <br> <br>  <b>Kueri tabel</b> <br><br>  Mungkin perbedaan paling signifikan antara SQL dan NoSQL dalam hal desain kueri adalah penggunaan pernyataan <code>FROM</code> dan <code>WHERE</code> .  SQL memungkinkan Anda untuk memilih beberapa tabel setelah <code>FROM</code> , dan <code>WHERE</code> dapat memiliki kompleksitas apa pun (termasuk operasi <code>JOIN</code> antara tabel).  Namun, NoSQL cenderung memaksakan pembatasan yang ketat pada <code>FROM</code> , dan bekerja dengan hanya satu tabel yang ditentukan, dan di <code>WHERE</code> , kunci utama harus selalu ditentukan.  Ini karena keinginan untuk meningkatkan kinerja NoSQL, yang telah kita bicarakan sebelumnya.  Keinginan ini mengarah pada setiap kemungkinan pengurangan interaksi lintas-tabular dan lintas-kunci.  Ini dapat menyebabkan keterlambatan besar dalam komunikasi antar-nodal ketika menanggapi permintaan dan, oleh karena itu, sebaiknya dihindari secara prinsip.  Sebagai contoh, Cassandra mensyaratkan bahwa permintaan dibatasi untuk operator tertentu (hanya <code>=, IN, &lt;, &gt;, =&gt;, &lt;=</code> diizinkan) pada kunci partisi, kecuali ketika meminta indeks sekunder (hanya = operator yang diizinkan di sini). <br><br>  <b>PostgreSQL</b> <br><br>  Tiga contoh pertanyaan yang dapat dengan mudah dieksekusi oleh database SQL akan diberikan di bawah ini. <br><br><ul><li>  Cetak semua lagu artis; </li><li>  Cetak semua lagu artis yang cocok dengan bagian pertama nama; </li><li>  Daftar semua lagu artis yang memiliki kata tertentu dalam judul dan harganya kurang dari 1,00. </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'Call%'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%Today%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Dari kueri PostgreSQL di atas, hanya yang pertama yang akan berfungsi di Cassandra tidak berubah, karena pernyataan <code>LIKE</code> tidak dapat diterapkan pada pengelompokan kolom seperti <code>SongTitle</code> .  Dalam hal ini, hanya operator <code>=</code> dan <code>IN</code> yang diizinkan. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>Mongodb</b> <br><br>  Seperti ditunjukkan dalam contoh sebelumnya, metode utama untuk membuat kueri di MongoDB adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">db.collection.find ()</a> .  Metode ini secara eksplisit berisi nama koleksi ( <code>music</code> dalam contoh di bawah), sehingga permintaan untuk beberapa koleksi dilarang. <br><br><pre> <code class="sql hljs">db.music.find( { artist: "No One You Know" } ); db.music.find( { artist: "No One You Know", songTitle: /<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>/ } );</code> </pre> <br>  <b>Baca semua baris tabel</b> <br><br>  Membaca semua baris hanyalah kasus khusus dari templat kueri yang telah kita periksa sebelumnya. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music;</code> </pre> <br><br>  <b>Cassandra</b> <br><br><blockquote>  Mirip dengan contoh di PostgreSQL di atas. </blockquote><br><br>  Mongodb <br><br><pre> <code class="sql hljs">db.music.find( {} );</code> </pre> <br>  <b>Mengedit data dalam sebuah tabel</b> <br><br>  <b>PostgreSQL</b> <br><br>  PostgreSQL menyediakan <code>UPDATE</code> untuk mengubah data.  Itu tidak memiliki kemampuan <code>UPSERT</code> , sehingga pelaksanaan instruksi ini akan gagal jika baris tidak lagi ada di database. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Genre = <span class="hljs-string"><span class="hljs-string">'Disco'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Cassandra memiliki <code>UPDATE</code> mirip dengan PostgreSQL.  <code>UPDATE</code> memiliki semantik <code>UPSERT</code> sama <code>UPSERT</code> <code>INSERT</code> . <br><br><blockquote>  Mirip dengan contoh di PostgreSQL di atas. </blockquote><br>  <b>Mongodb</b> <br>  Operasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembaruan ()</a> di MongoDB dapat sepenuhnya memperbarui dokumen yang ada atau hanya memperbarui bidang tertentu.  Secara default, ini memperbarui hanya satu dokumen dengan semantik <code>UPSERT</code> .  Memperbarui beberapa dokumen dan perilaku yang mirip dengan <code>UPSERT</code> dapat diterapkan dengan mengatur bendera tambahan untuk operasi.  Misalnya, dalam contoh di bawah ini, genre artis tertentu diperbarui oleh lagunya. <br><br><pre> <code class="sql hljs">db.music.update( {"artist": "The Acme Band"}, { $<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: { <span class="hljs-string"><span class="hljs-string">"genre"</span></span>: <span class="hljs-string"><span class="hljs-string">"Disco"</span></span> } }, {<span class="hljs-string"><span class="hljs-string">"multi"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"upsert"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} );</code> </pre> <br>  <b>Menghapus data dari tabel</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  Mirip dengan contoh di PostgreSQL di atas. </blockquote><br>  <b>Mongodb</b> <br><br>  MongoDB memiliki dua jenis operasi untuk menghapus dokumen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deleteOne ()</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">/ deleteMany ()</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hapus ()</a> .  Kedua jenis menghapus dokumen, tetapi mengembalikan hasil yang berbeda. <br><br><pre> <code class="sql hljs">db.music.deleteMany( { artist: "The Acme Band" } );</code> </pre><br>  <b>Hapus tabel</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  Mirip dengan contoh di PostgreSQL di atas. </blockquote><br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs">db.music.drop();</code> </pre> <br>  <b>Kesimpulan</b> <br><br>  Perdebatan tentang pilihan antara SQL dan NoSQL telah berlangsung selama lebih dari 10 tahun.  Ada dua aspek utama dari perdebatan ini: arsitektur mesin basis data (monolitik, transaksional SQL versus terdistribusi, NoSQL non-transaksional) dan pendekatan untuk desain basis data (pemodelan data dalam SQL versus pemodelan kueri Anda di NoSQL). <br><br>  Dengan database transaksional terdistribusi seperti YugaByte DB, perdebatan tentang arsitektur database dapat dengan mudah dihilangkan.  Ketika volume data menjadi lebih besar dari apa yang dapat ditulis ke satu node, arsitektur terdistribusi penuh yang mendukung skalabilitas linier dari rekaman dengan sharding / rebalancing otomatis menjadi perlu. <br><br>  Selain dikatakan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Cloud</a> , arsitektur transaksional, sangat konsisten sekarang lebih banyak digunakan untuk memberikan fleksibilitas pengembangan yang lebih baik daripada arsitektur non-transaksional, akhirnya konsisten. <br><br>  Kembali ke pembahasan desain database, wajar untuk mengatakan bahwa kedua pendekatan desain (SQL dan NoSQL) diperlukan untuk aplikasi nyata yang kompleks.  Pendekatan SQL "pemodelan data" memungkinkan pengembang untuk lebih mudah memenuhi persyaratan bisnis yang berubah, sedangkan pendekatan NoSQL "pemodelan data" memungkinkan pengembang yang sama untuk menangani sejumlah besar data dengan latensi rendah dan throughput tinggi.  Untuk alasan inilah YugaByte DB menyediakan SQL dan NoSQL API di kernel yang sama, daripada mempromosikan salah satu pendekatan.  Selain itu, dengan memastikan kompatibilitas dengan bahasa database populer, termasuk PostgreSQL dan Cassandra, YugaByte DB memastikan bahwa pengembang tidak harus belajar bahasa lain untuk bekerja dengan mesin database terdistribusi, sangat konsisten. <br><br>  Pada artikel ini, kami menemukan perbedaan dasar-dasar desain database di PostgreSQL, Cassandra, dan MongoDB.  Dalam artikel berikut, kami akan menyelami konsep desain canggih seperti indeks, transaksi, GABUNG, arahan TTL, dan dokumen JSON. <br><br>  Kami berharap Anda senang tinggal di sini selama akhir pekan dan mengundang Anda ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webinar gratis</a> , yang akan diadakan pada 14 Mei. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451042/">https://habr.com/ru/post/id451042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451026/index.html">Mengapa kita hanya memiliki sedikit sisa dari internet awal?</a></li>
<li><a href="../id451028/index.html">Panduan: jenis esai dalam bahasa Inggris dan tips untuk menulisnya</a></li>
<li><a href="../id451032/index.html">Penulisan HTTP / 1.1 & HTTP / 2 Client dan Server di Golang</a></li>
<li><a href="../id451034/index.html">Permintaan SQL Phantom</a></li>
<li><a href="../id451040/index.html">Runaway Fun in May, atau Standoff Approaching</a></li>
<li><a href="../id451044/index.html">IMaskjs - 3 tahun di Open Source</a></li>
<li><a href="../id451050/index.html">Ember.js: (lagi) saatnya mencoba</a></li>
<li><a href="../id451054/index.html">DO-RA: Mempersiapkan Produksi Industri</a></li>
<li><a href="../id451056/index.html">Pengantar MS Dynamics CRM</a></li>
<li><a href="../id451058/index.html">Workshop perusahaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>