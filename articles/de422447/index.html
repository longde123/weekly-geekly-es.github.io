<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòµ üç† üßòüèº bytes.Buffer in Go: Optimierungen, die nicht funktionieren ‚û°Ô∏è üêú üë®üèª‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Go- Programmierer sind mit Bytes vertraut. Einer der Vorteile besteht darin, dass Sie die Zuweisung von Speicher auf dem Heap auf die gleiche We...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bytes.Buffer in Go: Optimierungen, die nicht funktionieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/422447/"><p>  Viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-</a> Programmierer sind mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bytes</a> vertraut.  Einer der Vorteile besteht darin, dass Sie die Zuweisung von Speicher auf dem Heap auf die gleiche Weise wie bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierung kleiner Puffer / Gr√∂√üen</a> vermeiden k√∂nnen: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [<span class="hljs-number"><span class="hljs-number">64</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-comment"><span class="hljs-comment">//        // ...   }</span></span></code> </pre> <br><p>  Es gibt nur ein Problem.  Diese Optimierung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert nicht</a> . </p><br><p>  Am Ende dieses Artikels erfahren Sie, warum diese Optimierung nicht funktioniert und was wir dagegen tun k√∂nnen. </p><a name="habracut"></a><br><h1 id="kak-bylo-po-zadumke-small-buffer-optimization">  Wie beabsichtigt, "Small Buffer Optimization" </h1><br><p>  Lassen Sie uns eine leicht vereinfachte Definition von <code>bytes.Buffer</code> einf√ºhren. <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smallBufSize <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> buf []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> }</code> </pre> <br><p>  Wenn wir beispielsweise Aktionen f√ºr den <code>Buffer</code> ausf√ºhren, rufen Sie die <code>Buffer.Write</code> Methode auf. Der Datensatz wird immer in <code>buf</code> . Vor diesem Datensatz wird jedoch <code>Buffer.grow(n)</code> in jeder √§hnlichen Methode gestartet, um sicherzustellen, dass in diesem Slice gen√ºgend Speicherplatz f√ºr vorhanden ist n√§chste <code>n</code> Bytes. </p><br><p>  Wachsen kann ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//         bytes.Buffer. l := len(b.buf) //   Buffer need := n + l have := cap(b.buf) - l if have &gt;= need { b.buf = b.buf[:need] return } if need &lt;= smallBufSize { //     , //   . b.buf = b.bootstrap[:] } else { // growFactor -     . //     need  need*2. newBuf := make([]byte, need, growFactor(need)) copy(newBuf, b.buf) b.buf = newBuf } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Annahmen, die bei unserer Implementierung von Buffer.grow verwendet wurden</b> <div class="spoiler_text"><hr><br><p>  Wir gehen davon aus, dass <code>len(b.buf)</code> die tats√§chliche <code>len(b.buf)</code> in Buffer ist, f√ºr die <code>Write</code> Append-Methoden verwenden m√ºsste, um dem Slice neue Bytes hinzuzuf√ºgen.  Dies ist in <code>bytes.Buffer</code> nicht der Fall. <code>bytes.Buffer</code> aus der Standardbibliothek, aber als Beispiel ist dies ein irrelevantes Implementierungsdetail. </p><br><hr></div></div><br><p>  Wenn <code>b</code> auf dem Stapel zugewiesen <code>b</code> wird der darin enthaltene <code>bootstrap</code> auf dem Stapel zugewiesen, was bedeutet, dass das Slice <code>b.buf</code> den Speicher in <code>b</code> wiederverwendet, ohne dass eine zus√§tzliche Zuordnung erforderlich ist. </p><br><p>  Wenn das <code>grow</code> zeigt, dass das <code>bootstrap</code> Array bereits nicht ausreicht, wird ein neues, "echtes" Slice erstellt, in das Elemente aus dem vorherigen Speicher (aus dem "kleinen Puffer") kopiert werden.  Danach verliert <code>Buffer.bootstrap</code> seine Relevanz.  Wenn <code>Buffer.Reset</code> wird, bleibt <code>cap(b.buf)</code> gleich und es wird kein <code>bootstrap</code> Array mehr ben√∂tigt. </p><br><h1 id="pamyat-ubegayuschaya-v-heap">  Speicher l√§uft im Haufen weg </h1><br><p>  Es wird weiterhin erwartet, dass der Leser zumindest oberfl√§chlich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fluchtanalyse</a> in Go vertraut ist. </p><br><p>  Betrachten Sie die folgende Situation: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer <span class="hljs-comment"><span class="hljs-comment">// leak.go:11:6: moved to heap: b return &amp;b // leak.go:12:9: &amp;b escapes to heap }</span></span></code> </pre> <br><p>  Hier wird <code>b</code> auf dem Heap zugeordnet.  Der Grund daf√ºr ist der undichte Zeiger auf <code>b</code> : </p><br><pre> <code class="bash hljs">$ go tool compile -m leak.go leak.go:12:9: &amp;b escapes to heap leak.go:11:6: moved to heap: b</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Terminologie</b> <div class="spoiler_text"><hr><br><p>  In diesem Artikel werden "undicht" und "Flucht" fast synonym verwendet. </p><br><p>  Es gibt einige Unterschiede im Compiler selbst, zum Beispiel den Wert "Escape to Heap", aber die Funktionsparameter sind "Leaking Param x". </p><br><p>  Ein undichter Parameter bedeutet, dass das √ºbergebene Argument f√ºr diesen Parameter auf dem Heap zugewiesen wird.  Mit anderen Worten, der undichte Parameter bewirkt, dass die Argumente in einen Heap √ºbergehen. </p><br><hr></div></div><br><p>  Das Obige war ein offensichtlicher Fall, aber was ist damit: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() }</code> </pre> <br><p>  Hier brauchen wir nur 1 Byte, alles passt in den <code>bootstrap</code> , der Puffer selbst ist lokal und "entkommt" nicht der Funktion.  Sie werden √ºberrascht sein, aber das Ergebnis ist das gleiche, Zuordnung <code>b</code> auf dem Heap. </p><br><img src="https://habrastorage.org/webt/_d/3w/jr/_d3wjrildbyauunsvvv5oq7zqpo.jpeg"><br><p>  Um sicherzugehen, k√∂nnen Sie dies anhand des Benchmarks √ºberpr√ºfen: </p><br><pre> <code class="hljs powershell">BenchmarkLength<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">90.1</span></span> ns/op <span class="hljs-number"><span class="hljs-number">112</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Benchmark-Listung</b> <div class="spoiler_text"><hr><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = length() } }</code> </pre> <br><hr></div></div><br><div class="spoiler">  <b class="spoiler_title">Erl√§uterung 112 B / op</b> <div class="spoiler_text"><hr><br><p>  Wenn die Laufzeit den Allokator nach <code>N</code> Bytes fragt, m√ºssen nicht genau <code>N</code> Bytes zugewiesen werden. </p><br><blockquote>  Alle folgenden Ergebnisse beziehen sich auf die Kombination von <code>GOOS=linux</code> und <code>GOARCH=AMD64</code> . </blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:noinline func alloc9() []byte { return make([]byte, 9) } func BenchmarkAlloc9(b *testing.B) { for i := 0; i &lt; bN; i++ { _ = alloc9() } }</span></span></code> </pre> <br><p>  Wenn Sie ausf√ºhren <code>go test -bench=. -benchmem</code>  <code>go test -bench=. -benchmem</code> mit diesem Test: </p><br><pre> <code class="hljs powershell">BenchmarkAlloc9<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000000</span></span> <span class="hljs-number"><span class="hljs-number">33.5</span></span> ns/op <span class="hljs-number"><span class="hljs-number">16</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><p>  9 Bytes angefordert, 16 zugewiesen. Jetzt zur√ºck zu den Bytes. <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs">fmt.Println(unsafe.Sizeof(bytes.Buffer{})) =&gt; <span class="hljs-number"><span class="hljs-number">104</span></span></code> </pre> <br><p>  Schauen wir uns <a href="">$ GOROOT / src / runtime / sizeclasses.go an</a> : </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ class bytes/obj</span></span> bytes/span objects tail waste max waste /<span class="hljs-regexp"><span class="hljs-regexp">/ 1 8 8192 1024 0 87.50% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 16 8192 512 0 43.75% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3 32 8192 256 0 46.88% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 4 48 8192 170 32 31.52% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5 64 8192 128 0 23.44% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 6 80 8192 102 32 19.07% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 7 96 8192 85 32 15.95% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 8 112 8192 73 16 13.56% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... </span></span></code> </pre> <br><p>  Es passt nicht in 96 Bytes, 112 ist ausgew√§hlt. </p><br><hr></div></div><br><p>  Aber warum passiert das? </p><br><h1 id="chto-proishodit-i-pochemu">  Was passiert und warum? </h1><br><p>  Eine Analyse der Situation findet sich in dem eingangs erw√§hnten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thema</a> . <br>  Es gibt auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfachen Wiedergabeger√§t</a> . </p><br><p>  Der Problemort befindet sich nur in der Zuweisung <code>b.buf = b.bootstrap[:]</code> .  Bei diesem Code wird bei der Escape-Analyse davon ausgegangen, dass <code>b.bootstrap</code> "wegl√§uft". Da es sich um ein Array handelt, wird es im Objekt selbst gespeichert. Dies bedeutet, dass alle <code>b</code> auf dem Heap zugewiesen werden m√ºssen. </p><br><p>  Wenn Bootstrap ein Slice und kein Array w√§re, w√ºrde dies nicht passieren, da es eine Ad-hoc-Optimierung f√ºr die Zuweisung von Slices vom Objekt zum Objekt selbst gibt: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     , // object      . object.buf1 = object.buf2[a:b]</span></span></code> </pre> <br><p>  Die Antwort, warum diese Optimierung f√ºr Arrays nicht funktioniert, wurde bereits oben formuliert. Hier ist jedoch ein <a href="">Auszug</a> aus <a href="">esc.go # L835-L866 selbst</a> (der gesamte Optimierungscode wird durch Bezugnahme hervorgehoben): </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Note, this optimization does not apply to OSLICEARR, // because it does introduce a new pointer into b that was not already there // (pointer to b itself). After such assignment, if b contents escape, // b escapes as well. If we ignore such OSLICEARR, we will conclude // that b does not escape when b contents do.</span></span></code> </pre> <br><p>  Es ist erw√§hnenswert, dass es f√ºr den Zeigeranalysator mehrere Ebenen von "Lecks" gibt, die wichtigsten davon: </p><br><ol><li>  Das Objekt selbst entkommt (b entkommt).  In diesem Fall muss das Objekt selbst auf dem Heap zugewiesen werden. </li><li>  Die Elemente des Objekts (b Inhalt entkommen) entweichen.  In diesem Fall werden die Zeiger im Objekt als maskiert betrachtet. </li></ol><br><p>  Der Fall mit dem Array ist insofern besonders, als wenn das Array undicht ist, das Objekt, das es enth√§lt, ebenfalls undicht sein muss. </p><br><p>  Die Escape-Analyse entscheidet, ob es m√∂glich ist, ein Objekt auf dem Stapel zu platzieren oder nicht, und st√ºtzt sich dabei nur auf Informationen, die im Hauptteil der analysierten Funktion verf√ºgbar sind.  Die <code>Buffer.grow</code> Methode verwendet <code>b</code> Zeiger, daher muss eine geeignete Stelle zum Platzieren berechnet werden.  Da wir im Fall eines Arrays <code>"b escape"</code> von <code>"b contents escape"</code> , m√ºssen wir pessimistischer sein und zu dem Schluss kommen, dass <code>b</code> nicht sicher auf dem Stapel platziert werden kann. </p><br><p>  Angenommen, das <code>self-assignment</code> f√ºr Arrays genauso aufgel√∂st wie f√ºr Slices: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> bad <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { array [<span class="hljs-number"><span class="hljs-number">10</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> slice []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *bad)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b.slice = b.array[:] <span class="hljs-comment"><span class="hljs-comment">// ignoring self-assignment to b.slice sink = b.array // b.array escapes to heap // b does not escape }</span></span></code> </pre> <br><p>  Die Entscheidung, <code>b</code> in dieser Situation auf den Stapel zu legen, f√ºhrt zu einer Katastrophe: Nach dem Verlassen der Funktion, in der <code>b</code> erstellt wurde, ist der Speicher, auf den sich die <code>sink</code> bezieht, nichts anderes als M√ºll. </p><br><h1 id="ukazateli-na-massivy">  Array-Zeiger </h1><br><p>  Stellen Sie sich vor, unser <code>Buffer</code> wurde etwas anders deklariert: </p><br><pre> <code class="diff hljs">const smallBufSize int = 64 type Buffer struct { - bootstrap [smallBufSize]byte + bootstrap *[smallBufSize]byte buf []byte }</code> </pre> <br><p>  Im Gegensatz zu einem normalen Array speichert ein Zeiger auf ein Array nicht alle Elemente im <code>Buffer</code> selbst.  Dies bedeutet, dass, wenn die <code>bootstrap</code> Zuweisung auf dem Heap keine <code>Buffer</code> auf dem Heap beinhaltet.  Da die Escape-Analyse nach M√∂glichkeit Zeigerfelder auf dem Stapel zuordnen kann, k√∂nnen wir davon ausgehen, dass eine solche <code>Buffer</code> erfolgreicher ist. </p><br><p>  Das ist aber theoretisch.  In der Praxis hat ein Zeiger auf ein Array nicht viel Verarbeitung und f√§llt in dieselbe Kategorie wie ein Slice aus einem regul√§ren Array, was nicht ganz korrekt ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL133375: cmd / compile / internal / gc: Selbstzuweisung von Array-Slice-Handles in esc.go</a> soll diese Situation korrigieren. </p><br><p>  Angenommen, diese √Ñnderung wurde in den Go-Compiler √ºbernommen. </p><br><h1 id="zero-value-kotoryy-my-poteryali">  Nullwert haben wir verloren </h1><br><p>  Leider hat der √úbergang von <code>[64]byte</code> zu <code>*[64]byte</code> ein Problem: Jetzt k√∂nnen wir <code>bootstrap</code> nicht mehr verwenden, ohne es explizit zu initialisieren. Ein Nullwert von <code>Buffer</code> nicht mehr n√ºtzlich. Wir ben√∂tigen einen Konstruktor. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer{bootstrap: <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(*[smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)} }</code> </pre> <br><p>  Wir geben <code>Buffer</code> , nicht <code>*Buffer</code> , um Probleme bei der Analyse von Zeigern zu vermeiden (dies ist in Go sehr konservativ). Unter Ber√ºcksichtigung der Tatsache, dass <code>NewBuffer</code> immer an der Stelle eines Aufrufs <code>NewBuffer</code> , wird nicht unn√∂tig kopiert. </p><br><p>  Nach dem Einbetten des <code>NewBuffer</code> K√∂rpers an die Stelle des Escape-Aufrufs kann die Analyse versuchen zu beweisen, dass <code>new(*[smallBufSize]byte)</code> die Lebensdauer des Frames der Funktion, in der es aufgerufen wird, nicht √ºberschreitet.  Wenn ja, befindet sich die Zuordnung auf dem Stapel. </p><br><h1 id="intel-bytebuf">  Intel Bytebuf </h1><br><p>  Die oben beschriebene Optimierung wird im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paket intel-go / bytebuf angewendet</a> . </p><br><p>  Diese Bibliothek exportiert den Typ <code>bytebuf.Buffer</code> , der 99,9% <code>bytes.Buffer</code> .  Alle √Ñnderungen werden auf die Einf√ºhrung eines Konstruktors ( <code>bytebuf.New</code> ) und eines Zeigers auf ein Array anstelle eines regul√§ren Arrays reduziert: </p><br><pre> <code class="diff hljs">type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at &amp;buf[off], write at &amp;buf[len(buf)] - bootstrap [64]byte // helps small buffers avoid allocation. + bootstrap *[64]byte // helps small buffers avoid allocation. lastRead readOp // last read operation (for Unread*). }</code> </pre> <br><p>  Hier ist ein Leistungsvergleich mit <code>bytes.Buffer</code> : </p><br><pre> <code class="hljs powershell">name old time/op new time/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">138</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-number"><span class="hljs-number">24</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-82</span></span>.<span class="hljs-number"><span class="hljs-number">94</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">186</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">11</span></span>% <span class="hljs-number"><span class="hljs-number">60</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-67</span></span>.<span class="hljs-number"><span class="hljs-number">82</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">225</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">10</span></span>% <span class="hljs-number"><span class="hljs-number">108</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">6</span></span>% <span class="hljs-literal"><span class="hljs-literal">-52</span></span>.<span class="hljs-number"><span class="hljs-number">26</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">474</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">17</span></span>% <span class="hljs-number"><span class="hljs-number">338</span></span>ns ¬±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-literal"><span class="hljs-literal">-28</span></span>.<span class="hljs-number"><span class="hljs-number">57</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">889</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">740</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-16</span></span>.<span class="hljs-number"><span class="hljs-number">78</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old alloc/op new alloc/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">112</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0</span></span>B <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">117</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">5</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-95</span></span>.<span class="hljs-number"><span class="hljs-number">73</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">176</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">64</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-63</span></span>.<span class="hljs-number"><span class="hljs-number">64</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">368</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">256</span></span>B ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-30</span></span>.<span class="hljs-number"><span class="hljs-number">43</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.16</span></span>kB ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.05</span></span>kB ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-5</span></span>.<span class="hljs-number"><span class="hljs-number">19</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old allocs/op new allocs/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">1.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0.00</span></span> <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p>  Alle anderen Informationen finden Sie in <a href="">README</a> . </p><br><p>  Aufgrund der Unf√§higkeit, den Wert Null zu verwenden und an die Konstruktionsfunktion <code>New</code> zu <code>bytes.Buffer</code> , ist es nicht m√∂glich, diese Optimierung auf <code>bytes.Buffer</code> . </p><br><p>  Ist dies der einzige Weg, um schnellere <code>bytes.Buffer</code> zu <code>bytes.Buffer</code> .  Die Antwort ist nein.  Dies ist jedoch definitiv eine Methode, die nur minimale √Ñnderungen in der Implementierung erfordert. </p><br><h1 id="plany-na-escape-analysis">  Fluchtanalysepl√§ne </h1><br><p>  In der aktuellen Form ist die Escape-Analyse in Go ziemlich schwach.  Fast jede Operation mit Zeigerwerten f√ºhrt zu Zuweisungen auf dem Heap, auch wenn dies keine vern√ºnftige Entscheidung ist. </p><br><p>  Ich werde versuchen, die meiste Zeit, die ich dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Golang / Go-</a> Projekt widme, zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lenken</a> , um diese Probleme zu l√∂sen, sodass in der kommenden Version (1.12) einige Verbesserungen m√∂glich sind. </p><br><p>  √úber die Ergebnisse und Details der internen Struktur dieses Teils des Compilers k√∂nnen Sie in einem meiner n√§chsten Artikel lesen.  Ich werde versuchen, eine Reihe von Empfehlungen bereitzustellen, die in einigen F√§llen helfen, den Code so zu strukturieren, dass er weniger unerw√ºnschte Speicherzuordnungen aufweist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422447/">https://habr.com/ru/post/de422447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422437/index.html">User Experience-Spiele sowie Website- und Anwendungsgeschwindigkeit</a></li>
<li><a href="../de422439/index.html">Der Kampf mit Yandex: Wie ich mehr als ein Jahr damit verbracht habe, die Seite an die Spitze zu bringen</a></li>
<li><a href="../de422441/index.html">Es wurde eine Formel f√ºr einen schmerzlosen √úbergang zu .Net Core gefunden</a></li>
<li><a href="../de422443/index.html">Corona SDK Pr√§ziser Timer</a></li>
<li><a href="../de422445/index.html">BottomAppBar-Implementierung. Teil 3: Verhalten f√ºr Android</a></li>
<li><a href="../de422449/index.html">Senatoren gegen Amazon: Was ein Online-Shop getan hat</a></li>
<li><a href="../de422451/index.html">H√∂ren Sie sich das Spielemarketing und den Platz eines Drehbuchautors in der Spielebranche an.</a></li>
<li><a href="../de422453/index.html">SmartData 2018: Erste abgesagte JUG.ru-Gruppenkonferenz</a></li>
<li><a href="../de422455/index.html">EPAM + Universit√§ten: Wie wir mit ukrainischen Universit√§ten zusammenarbeiten</a></li>
<li><a href="../de422457/index.html">"Es macht f√ºr uns keinen Sinn, Retrofit zu verwenden": √ºber die Android-Entwicklung bei Sberbank Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>