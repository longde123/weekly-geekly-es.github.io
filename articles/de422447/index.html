<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😵 🍠 🧘🏼 bytes.Buffer in Go: Optimierungen, die nicht funktionieren ➡️ 🐜 👨🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Go- Programmierer sind mit Bytes vertraut. Einer der Vorteile besteht darin, dass Sie die Zuweisung von Speicher auf dem Heap auf die gleiche We...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bytes.Buffer in Go: Optimierungen, die nicht funktionieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/422447/"><p>  Viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-</a> Programmierer sind mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bytes</a> vertraut.  Einer der Vorteile besteht darin, dass Sie die Zuweisung von Speicher auf dem Heap auf die gleiche Weise wie bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierung kleiner Puffer / Größen</a> vermeiden können: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [<span class="hljs-number"><span class="hljs-number">64</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-comment"><span class="hljs-comment">//        // ...   }</span></span></code> </pre> <br><p>  Es gibt nur ein Problem.  Diese Optimierung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert nicht</a> . </p><br><p>  Am Ende dieses Artikels erfahren Sie, warum diese Optimierung nicht funktioniert und was wir dagegen tun können. </p><a name="habracut"></a><br><h1 id="kak-bylo-po-zadumke-small-buffer-optimization">  Wie beabsichtigt, "Small Buffer Optimization" </h1><br><p>  Lassen Sie uns eine leicht vereinfachte Definition von <code>bytes.Buffer</code> einführen. <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smallBufSize <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> buf []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> }</code> </pre> <br><p>  Wenn wir beispielsweise Aktionen für den <code>Buffer</code> ausführen, rufen Sie die <code>Buffer.Write</code> Methode auf. Der Datensatz wird immer in <code>buf</code> . Vor diesem Datensatz wird jedoch <code>Buffer.grow(n)</code> in jeder ähnlichen Methode gestartet, um sicherzustellen, dass in diesem Slice genügend Speicherplatz für vorhanden ist nächste <code>n</code> Bytes. </p><br><p>  Wachsen kann ungefähr so ​​aussehen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//         bytes.Buffer. l := len(b.buf) //   Buffer need := n + l have := cap(b.buf) - l if have &gt;= need { b.buf = b.buf[:need] return } if need &lt;= smallBufSize { //     , //   . b.buf = b.bootstrap[:] } else { // growFactor -     . //     need  need*2. newBuf := make([]byte, need, growFactor(need)) copy(newBuf, b.buf) b.buf = newBuf } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Annahmen, die bei unserer Implementierung von Buffer.grow verwendet wurden</b> <div class="spoiler_text"><hr><br><p>  Wir gehen davon aus, dass <code>len(b.buf)</code> die tatsächliche <code>len(b.buf)</code> in Buffer ist, für die <code>Write</code> Append-Methoden verwenden müsste, um dem Slice neue Bytes hinzuzufügen.  Dies ist in <code>bytes.Buffer</code> nicht der Fall. <code>bytes.Buffer</code> aus der Standardbibliothek, aber als Beispiel ist dies ein irrelevantes Implementierungsdetail. </p><br><hr></div></div><br><p>  Wenn <code>b</code> auf dem Stapel zugewiesen <code>b</code> wird der darin enthaltene <code>bootstrap</code> auf dem Stapel zugewiesen, was bedeutet, dass das Slice <code>b.buf</code> den Speicher in <code>b</code> wiederverwendet, ohne dass eine zusätzliche Zuordnung erforderlich ist. </p><br><p>  Wenn das <code>grow</code> zeigt, dass das <code>bootstrap</code> Array bereits nicht ausreicht, wird ein neues, "echtes" Slice erstellt, in das Elemente aus dem vorherigen Speicher (aus dem "kleinen Puffer") kopiert werden.  Danach verliert <code>Buffer.bootstrap</code> seine Relevanz.  Wenn <code>Buffer.Reset</code> wird, bleibt <code>cap(b.buf)</code> gleich und es wird kein <code>bootstrap</code> Array mehr benötigt. </p><br><h1 id="pamyat-ubegayuschaya-v-heap">  Speicher läuft im Haufen weg </h1><br><p>  Es wird weiterhin erwartet, dass der Leser zumindest oberflächlich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fluchtanalyse</a> in Go vertraut ist. </p><br><p>  Betrachten Sie die folgende Situation: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer <span class="hljs-comment"><span class="hljs-comment">// leak.go:11:6: moved to heap: b return &amp;b // leak.go:12:9: &amp;b escapes to heap }</span></span></code> </pre> <br><p>  Hier wird <code>b</code> auf dem Heap zugeordnet.  Der Grund dafür ist der undichte Zeiger auf <code>b</code> : </p><br><pre> <code class="bash hljs">$ go tool compile -m leak.go leak.go:12:9: &amp;b escapes to heap leak.go:11:6: moved to heap: b</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Terminologie</b> <div class="spoiler_text"><hr><br><p>  In diesem Artikel werden "undicht" und "Flucht" fast synonym verwendet. </p><br><p>  Es gibt einige Unterschiede im Compiler selbst, zum Beispiel den Wert "Escape to Heap", aber die Funktionsparameter sind "Leaking Param x". </p><br><p>  Ein undichter Parameter bedeutet, dass das übergebene Argument für diesen Parameter auf dem Heap zugewiesen wird.  Mit anderen Worten, der undichte Parameter bewirkt, dass die Argumente in einen Heap übergehen. </p><br><hr></div></div><br><p>  Das Obige war ein offensichtlicher Fall, aber was ist damit: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() }</code> </pre> <br><p>  Hier brauchen wir nur 1 Byte, alles passt in den <code>bootstrap</code> , der Puffer selbst ist lokal und "entkommt" nicht der Funktion.  Sie werden überrascht sein, aber das Ergebnis ist das gleiche, Zuordnung <code>b</code> auf dem Heap. </p><br><img src="https://habrastorage.org/webt/_d/3w/jr/_d3wjrildbyauunsvvv5oq7zqpo.jpeg"><br><p>  Um sicherzugehen, können Sie dies anhand des Benchmarks überprüfen: </p><br><pre> <code class="hljs powershell">BenchmarkLength<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">90.1</span></span> ns/op <span class="hljs-number"><span class="hljs-number">112</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Benchmark-Listung</b> <div class="spoiler_text"><hr><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = length() } }</code> </pre> <br><hr></div></div><br><div class="spoiler">  <b class="spoiler_title">Erläuterung 112 B / op</b> <div class="spoiler_text"><hr><br><p>  Wenn die Laufzeit den Allokator nach <code>N</code> Bytes fragt, müssen nicht genau <code>N</code> Bytes zugewiesen werden. </p><br><blockquote>  Alle folgenden Ergebnisse beziehen sich auf die Kombination von <code>GOOS=linux</code> und <code>GOARCH=AMD64</code> . </blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:noinline func alloc9() []byte { return make([]byte, 9) } func BenchmarkAlloc9(b *testing.B) { for i := 0; i &lt; bN; i++ { _ = alloc9() } }</span></span></code> </pre> <br><p>  Wenn Sie ausführen <code>go test -bench=. -benchmem</code>  <code>go test -bench=. -benchmem</code> mit diesem Test: </p><br><pre> <code class="hljs powershell">BenchmarkAlloc9<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000000</span></span> <span class="hljs-number"><span class="hljs-number">33.5</span></span> ns/op <span class="hljs-number"><span class="hljs-number">16</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><p>  9 Bytes angefordert, 16 zugewiesen. Jetzt zurück zu den Bytes. <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs">fmt.Println(unsafe.Sizeof(bytes.Buffer{})) =&gt; <span class="hljs-number"><span class="hljs-number">104</span></span></code> </pre> <br><p>  Schauen wir uns <a href="">$ GOROOT / src / runtime / sizeclasses.go an</a> : </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ class bytes/obj</span></span> bytes/span objects tail waste max waste /<span class="hljs-regexp"><span class="hljs-regexp">/ 1 8 8192 1024 0 87.50% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 16 8192 512 0 43.75% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3 32 8192 256 0 46.88% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 4 48 8192 170 32 31.52% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5 64 8192 128 0 23.44% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 6 80 8192 102 32 19.07% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 7 96 8192 85 32 15.95% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 8 112 8192 73 16 13.56% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... </span></span></code> </pre> <br><p>  Es passt nicht in 96 Bytes, 112 ist ausgewählt. </p><br><hr></div></div><br><p>  Aber warum passiert das? </p><br><h1 id="chto-proishodit-i-pochemu">  Was passiert und warum? </h1><br><p>  Eine Analyse der Situation findet sich in dem eingangs erwähnten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thema</a> . <br>  Es gibt auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfachen Wiedergabegerät</a> . </p><br><p>  Der Problemort befindet sich nur in der Zuweisung <code>b.buf = b.bootstrap[:]</code> .  Bei diesem Code wird bei der Escape-Analyse davon ausgegangen, dass <code>b.bootstrap</code> "wegläuft". Da es sich um ein Array handelt, wird es im Objekt selbst gespeichert. Dies bedeutet, dass alle <code>b</code> auf dem Heap zugewiesen werden müssen. </p><br><p>  Wenn Bootstrap ein Slice und kein Array wäre, würde dies nicht passieren, da es eine Ad-hoc-Optimierung für die Zuweisung von Slices vom Objekt zum Objekt selbst gibt: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     , // object      . object.buf1 = object.buf2[a:b]</span></span></code> </pre> <br><p>  Die Antwort, warum diese Optimierung für Arrays nicht funktioniert, wurde bereits oben formuliert. Hier ist jedoch ein <a href="">Auszug</a> aus <a href="">esc.go # L835-L866 selbst</a> (der gesamte Optimierungscode wird durch Bezugnahme hervorgehoben): </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Note, this optimization does not apply to OSLICEARR, // because it does introduce a new pointer into b that was not already there // (pointer to b itself). After such assignment, if b contents escape, // b escapes as well. If we ignore such OSLICEARR, we will conclude // that b does not escape when b contents do.</span></span></code> </pre> <br><p>  Es ist erwähnenswert, dass es für den Zeigeranalysator mehrere Ebenen von "Lecks" gibt, die wichtigsten davon: </p><br><ol><li>  Das Objekt selbst entkommt (b entkommt).  In diesem Fall muss das Objekt selbst auf dem Heap zugewiesen werden. </li><li>  Die Elemente des Objekts (b Inhalt entkommen) entweichen.  In diesem Fall werden die Zeiger im Objekt als maskiert betrachtet. </li></ol><br><p>  Der Fall mit dem Array ist insofern besonders, als wenn das Array undicht ist, das Objekt, das es enthält, ebenfalls undicht sein muss. </p><br><p>  Die Escape-Analyse entscheidet, ob es möglich ist, ein Objekt auf dem Stapel zu platzieren oder nicht, und stützt sich dabei nur auf Informationen, die im Hauptteil der analysierten Funktion verfügbar sind.  Die <code>Buffer.grow</code> Methode verwendet <code>b</code> Zeiger, daher muss eine geeignete Stelle zum Platzieren berechnet werden.  Da wir im Fall eines Arrays <code>"b escape"</code> von <code>"b contents escape"</code> , müssen wir pessimistischer sein und zu dem Schluss kommen, dass <code>b</code> nicht sicher auf dem Stapel platziert werden kann. </p><br><p>  Angenommen, das <code>self-assignment</code> für Arrays genauso aufgelöst wie für Slices: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> bad <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { array [<span class="hljs-number"><span class="hljs-number">10</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> slice []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *bad)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b.slice = b.array[:] <span class="hljs-comment"><span class="hljs-comment">// ignoring self-assignment to b.slice sink = b.array // b.array escapes to heap // b does not escape }</span></span></code> </pre> <br><p>  Die Entscheidung, <code>b</code> in dieser Situation auf den Stapel zu legen, führt zu einer Katastrophe: Nach dem Verlassen der Funktion, in der <code>b</code> erstellt wurde, ist der Speicher, auf den sich die <code>sink</code> bezieht, nichts anderes als Müll. </p><br><h1 id="ukazateli-na-massivy">  Array-Zeiger </h1><br><p>  Stellen Sie sich vor, unser <code>Buffer</code> wurde etwas anders deklariert: </p><br><pre> <code class="diff hljs">const smallBufSize int = 64 type Buffer struct { - bootstrap [smallBufSize]byte + bootstrap *[smallBufSize]byte buf []byte }</code> </pre> <br><p>  Im Gegensatz zu einem normalen Array speichert ein Zeiger auf ein Array nicht alle Elemente im <code>Buffer</code> selbst.  Dies bedeutet, dass, wenn die <code>bootstrap</code> Zuweisung auf dem Heap keine <code>Buffer</code> auf dem Heap beinhaltet.  Da die Escape-Analyse nach Möglichkeit Zeigerfelder auf dem Stapel zuordnen kann, können wir davon ausgehen, dass eine solche <code>Buffer</code> erfolgreicher ist. </p><br><p>  Das ist aber theoretisch.  In der Praxis hat ein Zeiger auf ein Array nicht viel Verarbeitung und fällt in dieselbe Kategorie wie ein Slice aus einem regulären Array, was nicht ganz korrekt ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL133375: cmd / compile / internal / gc: Selbstzuweisung von Array-Slice-Handles in esc.go</a> soll diese Situation korrigieren. </p><br><p>  Angenommen, diese Änderung wurde in den Go-Compiler übernommen. </p><br><h1 id="zero-value-kotoryy-my-poteryali">  Nullwert haben wir verloren </h1><br><p>  Leider hat der Übergang von <code>[64]byte</code> zu <code>*[64]byte</code> ein Problem: Jetzt können wir <code>bootstrap</code> nicht mehr verwenden, ohne es explizit zu initialisieren. Ein Nullwert von <code>Buffer</code> nicht mehr nützlich. Wir benötigen einen Konstruktor. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer{bootstrap: <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(*[smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)} }</code> </pre> <br><p>  Wir geben <code>Buffer</code> , nicht <code>*Buffer</code> , um Probleme bei der Analyse von Zeigern zu vermeiden (dies ist in Go sehr konservativ). Unter Berücksichtigung der Tatsache, dass <code>NewBuffer</code> immer an der Stelle eines Aufrufs <code>NewBuffer</code> , wird nicht unnötig kopiert. </p><br><p>  Nach dem Einbetten des <code>NewBuffer</code> Körpers an die Stelle des Escape-Aufrufs kann die Analyse versuchen zu beweisen, dass <code>new(*[smallBufSize]byte)</code> die Lebensdauer des Frames der Funktion, in der es aufgerufen wird, nicht überschreitet.  Wenn ja, befindet sich die Zuordnung auf dem Stapel. </p><br><h1 id="intel-bytebuf">  Intel Bytebuf </h1><br><p>  Die oben beschriebene Optimierung wird im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paket intel-go / bytebuf angewendet</a> . </p><br><p>  Diese Bibliothek exportiert den Typ <code>bytebuf.Buffer</code> , der 99,9% <code>bytes.Buffer</code> .  Alle Änderungen werden auf die Einführung eines Konstruktors ( <code>bytebuf.New</code> ) und eines Zeigers auf ein Array anstelle eines regulären Arrays reduziert: </p><br><pre> <code class="diff hljs">type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at &amp;buf[off], write at &amp;buf[len(buf)] - bootstrap [64]byte // helps small buffers avoid allocation. + bootstrap *[64]byte // helps small buffers avoid allocation. lastRead readOp // last read operation (for Unread*). }</code> </pre> <br><p>  Hier ist ein Leistungsvergleich mit <code>bytes.Buffer</code> : </p><br><pre> <code class="hljs powershell">name old time/op new time/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">138</span></span>ns ±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-number"><span class="hljs-number">24</span></span>ns ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-82</span></span>.<span class="hljs-number"><span class="hljs-number">94</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">186</span></span>ns ±<span class="hljs-number"><span class="hljs-number">11</span></span>% <span class="hljs-number"><span class="hljs-number">60</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-67</span></span>.<span class="hljs-number"><span class="hljs-number">82</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">225</span></span>ns ±<span class="hljs-number"><span class="hljs-number">10</span></span>% <span class="hljs-number"><span class="hljs-number">108</span></span>ns ± <span class="hljs-number"><span class="hljs-number">6</span></span>% <span class="hljs-literal"><span class="hljs-literal">-52</span></span>.<span class="hljs-number"><span class="hljs-number">26</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">474</span></span>ns ±<span class="hljs-number"><span class="hljs-number">17</span></span>% <span class="hljs-number"><span class="hljs-number">338</span></span>ns ±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-literal"><span class="hljs-literal">-28</span></span>.<span class="hljs-number"><span class="hljs-number">57</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">889</span></span>ns ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">740</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-16</span></span>.<span class="hljs-number"><span class="hljs-number">78</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old alloc/op new alloc/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">112</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0</span></span>B <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">117</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">5</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-95</span></span>.<span class="hljs-number"><span class="hljs-number">73</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">176</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">64</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-63</span></span>.<span class="hljs-number"><span class="hljs-number">64</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">368</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">256</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-30</span></span>.<span class="hljs-number"><span class="hljs-number">43</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.16</span></span>kB ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.05</span></span>kB ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-5</span></span>.<span class="hljs-number"><span class="hljs-number">19</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old allocs/op new allocs/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">1.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0.00</span></span> <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p>  Alle anderen Informationen finden Sie in <a href="">README</a> . </p><br><p>  Aufgrund der Unfähigkeit, den Wert Null zu verwenden und an die Konstruktionsfunktion <code>New</code> zu <code>bytes.Buffer</code> , ist es nicht möglich, diese Optimierung auf <code>bytes.Buffer</code> . </p><br><p>  Ist dies der einzige Weg, um schnellere <code>bytes.Buffer</code> zu <code>bytes.Buffer</code> .  Die Antwort ist nein.  Dies ist jedoch definitiv eine Methode, die nur minimale Änderungen in der Implementierung erfordert. </p><br><h1 id="plany-na-escape-analysis">  Fluchtanalysepläne </h1><br><p>  In der aktuellen Form ist die Escape-Analyse in Go ziemlich schwach.  Fast jede Operation mit Zeigerwerten führt zu Zuweisungen auf dem Heap, auch wenn dies keine vernünftige Entscheidung ist. </p><br><p>  Ich werde versuchen, die meiste Zeit, die ich dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Golang / Go-</a> Projekt widme, zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lenken</a> , um diese Probleme zu lösen, sodass in der kommenden Version (1.12) einige Verbesserungen möglich sind. </p><br><p>  Über die Ergebnisse und Details der internen Struktur dieses Teils des Compilers können Sie in einem meiner nächsten Artikel lesen.  Ich werde versuchen, eine Reihe von Empfehlungen bereitzustellen, die in einigen Fällen helfen, den Code so zu strukturieren, dass er weniger unerwünschte Speicherzuordnungen aufweist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422447/">https://habr.com/ru/post/de422447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422437/index.html">User Experience-Spiele sowie Website- und Anwendungsgeschwindigkeit</a></li>
<li><a href="../de422439/index.html">Der Kampf mit Yandex: Wie ich mehr als ein Jahr damit verbracht habe, die Seite an die Spitze zu bringen</a></li>
<li><a href="../de422441/index.html">Es wurde eine Formel für einen schmerzlosen Übergang zu .Net Core gefunden</a></li>
<li><a href="../de422443/index.html">Corona SDK Präziser Timer</a></li>
<li><a href="../de422445/index.html">BottomAppBar-Implementierung. Teil 3: Verhalten für Android</a></li>
<li><a href="../de422449/index.html">Senatoren gegen Amazon: Was ein Online-Shop getan hat</a></li>
<li><a href="../de422451/index.html">Hören Sie sich das Spielemarketing und den Platz eines Drehbuchautors in der Spielebranche an.</a></li>
<li><a href="../de422453/index.html">SmartData 2018: Erste abgesagte JUG.ru-Gruppenkonferenz</a></li>
<li><a href="../de422455/index.html">EPAM + Universitäten: Wie wir mit ukrainischen Universitäten zusammenarbeiten</a></li>
<li><a href="../de422457/index.html">"Es macht für uns keinen Sinn, Retrofit zu verwenden": über die Android-Entwicklung bei Sberbank Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>