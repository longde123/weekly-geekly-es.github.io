<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåí ü•å üï≥Ô∏è Abordagem gananciosa e m√°quinas ca√ßa-n√≠queis. An√°lise das tarefas da pista ML do campeonato de programa√ß√£o üíÉüèº ü•ò üôÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos a publicar an√°lises das tarefas propostas no campeonato recente. Em seguida, s√£o realizadas tarefas da rodada de qualifica√ß√£o para especia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abordagem gananciosa e m√°quinas ca√ßa-n√≠queis. An√°lise das tarefas da pista ML do campeonato de programa√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/461273/"><img src="https://habrastorage.org/webt/sd/i7/yd/sdi7ydyv5yabtpudjamnnmm2dge.jpeg"><br><br>  Continuamos a publicar an√°lises das tarefas propostas no campeonato recente.  Em seguida, s√£o realizadas tarefas da rodada de qualifica√ß√£o para especialistas em aprendizado de m√°quina.  Esta √© a terceira faixa de quatro (back-end, front-end, ML, an√°lises).  Os participantes precisavam criar um modelo para corrigir erros de digita√ß√£o nos textos, propor uma estrat√©gia para jogar em m√°quinas ca√ßa-n√≠queis, lembrar um sistema de recomenda√ß√µes de conte√∫do e compor v√°rios outros programas. <br><br><a name="habracut"></a><h2>  A. Erros de digita√ß√£o </h2><br><h4>  Condi√ß√£o </h4><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Todas as l√≠nguas</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  Prazo </td><td>  1 s </td><td>  5 s </td><td>  5 s </td></tr><tr><td>  Limite de mem√≥ria </td><td>  64 MB </td><td>  256 MB </td><td>  256 MB </td></tr><tr><td>  Entrar </td><td colspan="3">  entrada padr√£o ou input.txt </td></tr><tr><td>  Conclus√£o </td><td colspan="3">  sa√≠da padr√£o ou output.txt </td></tr></tbody></table></div>  (ep√≠grafe) (de um f√≥rum) <br>  - Quem comp√¥s esse absurdo? <br>  Astrof√≠sicos.  Eles tamb√©m s√£o pessoas. <br>  - Voc√™ cometeu 10 erros na palavra "jornalistas". <br><br>  Muitos usu√°rios cometem erros de digita√ß√£o, alguns por pressionar teclas e outros por causa de analfabetismo.  Queremos verificar se o usu√°rio realmente pode ter em mente alguma outra palavra al√©m da que ele digitou. <br><br>  Mais formalmente, suponha que ocorra o seguinte modelo de erro: o usu√°rio come√ßa com uma palavra que deseja escrever e, posteriormente, comete v√°rios erros.  Cada erro √© uma substitui√ß√£o de alguma substring da palavra por outra substring.  Um erro corresponde √† substitui√ß√£o apenas em uma posi√ß√£o (ou seja, se o usu√°rio deseja cometer um √∫nico erro pela regra ‚Äúabc‚Äù ‚Üí ‚Äúcba‚Äù, a partir da cadeia ‚Äúabcabc‚Äù ele pode obter ‚Äúcbaabc‚Äù ou ‚Äúabccba‚Äù).  Ap√≥s cada erro, o processo se repete.  A mesma regra pode ser usada v√°rias vezes em etapas diferentes (por exemplo, no exemplo acima, ‚Äúcbacba‚Äù pode ser obtido em duas etapas). <br><br>  √â necess√°rio determinar o n√∫mero m√≠nimo de erros que um usu√°rio poderia cometer se tivesse em mente uma determinada palavra e escrevesse outra. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos de E / S e exemplo</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  A primeira linha cont√©m a palavra que, de acordo com nossa suposi√ß√£o, o usu√°rio tinha em mente (consiste em letras do alfabeto latino em letras min√∫sculas, o comprimento n√£o excede 20). <br><br>  A segunda linha cont√©m a palavra que ele realmente escreveu (tamb√©m consiste em letras do alfabeto latino em letras min√∫sculas, o comprimento n√£o excede 20). <br><br>  A terceira linha cont√©m um √∫nico n√∫mero N (N &lt;50) - o n√∫mero de substitui√ß√µes que descrevem v√°rios erros. <br><br>  As pr√≥ximas N linhas cont√™m poss√≠veis substitui√ß√µes no formato &amp; lt "correta" seq√º√™ncia de letras &amp; gt &lt;espa√ßo&gt; &lt;"incorreta" sequ√™ncia de letras&gt;.  As sequ√™ncias n√£o t√™m mais que 6 caracteres. <br><br><h4>  Formato de sa√≠da </h4><br>  √â necess√°rio imprimir um n√∫mero - o n√∫mero m√≠nimo de erros que o usu√°rio pode cometer.  Se esse n√∫mero exceder 4 ou for imposs√≠vel obter outro de uma palavra, imprima -1. <br><br><h4>  Exemplo </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclus√£o</b> </td></tr><tr><td><code>mlax <br> drum <br> 50 <br> lr <br> mlax gtwt <br> md <br> mlax ujoc <br> ml pq <br> mf <br> ml bf <br> mlax aruq <br> mlax nqdd <br> mlax fglm <br> mlax bfit <br> mlax mziq <br> mla hlb <br> au <br> mlax vmpa <br> mw <br> aw <br> ax ok <br> mla kqf <br> me <br> xx <br> ml if <br> ml gk <br> le <br> mla xrh <br> mj <br> ac <br> ab <br> mq <br> ax fr <br> ml sb <br> mlax gxxx <br> xm <br> mlax hczx <br> lq <br> la sv <br> lg <br> ax eh <br> lax mjh <br> la ec <br> la pv <br> ml iq <br> aq <br> lax jrs <br> la qn <br> lax bjo <br> lo <br> az <br> ln <br> ac</code> </td> <td> <code>4</code> </td> </tr></tbody></table></div></div></div><br><h4>  Solu√ß√£o </h4><br>  Vamos tentar gerar a partir da ortografia correta todas as palavras poss√≠veis, com no m√°ximo 4 erros.  No pior dos casos, pode haver O ((LÔπíN) <sup>4</sup> ).  Nas limita√ß√µes do problema, esse √© um n√∫mero bastante grande, portanto, voc√™ precisa descobrir como reduzir a complexidade.  Em vez disso, voc√™ pode usar o algoritmo meet-in-the-middle: gere palavras com n√£o mais que 2 erros, bem como palavras com as quais voc√™ pode obter uma palavra escrita pelo usu√°rio com n√£o mais que 2 erros.  Observe que o tamanho de cada um desses conjuntos n√£o exceder√° 10 <sup>6</sup> .  Se o n√∫mero de erros cometidos pelo usu√°rio n√£o exceder 4, esses conjuntos se cruzar√£o.  Da mesma forma, podemos verificar se o n√∫mero de erros n√£o excede 3, 2 e 1. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FromTo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> to; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; applyRule(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; word, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FromTo &amp;fromTo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> from = word.find(fromTo.from, pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos, {}}; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to = from + fromTo.from.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cpy = word; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { cpy[i] = fromTo.to[i - from]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {from, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cpy)}; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inverseRules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt; &amp;rules)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; rule: rules) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(rule.from, rule.to); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordOrig, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordMissprinted, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt;&amp; replaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mapping; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; mappingInverse; mapping.emplace(wordOrig, <span class="hljs-number"><span class="hljs-number">0</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, wordOrig); mapping.emplace(wordMissprinted, <span class="hljs-number"><span class="hljs-number">1</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">1</span></span>, wordMissprinted); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; edges; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buildGraph = [&amp;edges, &amp;mapping, &amp;mappingInverse](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startId, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;FromTo&gt;&amp; replaces, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dir) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer0; mappingLayer0 = {startId}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer1; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: mappingLayer0) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; word = mappingInverse.at(v); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; fromTo: replaces) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> from = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [tmp, wordCpy] = applyRule(word, fromTo, from); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmp == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } from = tmp + <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = mapping.size(); mapping.emplace(wordCpy, w); w = mapping.at(wordCpy); mappingInverse.emplace(w, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(wordCpy)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dir) { edges[v].emplace(w); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { edges[w].emplace(v); } mappingLayer1.emplace(w); } } } } mappingLayer0 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mappingLayer1); } }; buildGraph(<span class="hljs-number"><span class="hljs-number">0</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); inverseRules(replaces); buildGraph(<span class="hljs-number"><span class="hljs-number">1</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; q; q.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; mask(mapping.size(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> level{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (q.size()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [w, level] = q.front(); q.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[w]) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } mask[w] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mappingInverse.at(w) == wordMissprinted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> level; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: edges[w]) { q.emplace(v, level + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><h2>  B. Bandido de muitas armas </h2><br><h4>  Condi√ß√£o </h4><div class="scrollable-table"><table><tbody><tr><td>  Prazo </td><td>  2 s </td></tr><tr><td>  Limite de mem√≥ria </td><td>  64 MB </td></tr><tr><td>  Entrar </td><td>  entrada padr√£o </td></tr><tr><td>  Conclus√£o </td><td>  sa√≠da padr√£o </td></tr></tbody></table></div>  Esta √© uma tarefa interativa. <br><br>  Voc√™ mesmo n√£o sabe como aconteceu, mas se viu em um sal√£o com m√°quinas ca√ßa-n√≠queis com um saco inteiro de fichas.  Infelizmente, nas bilheterias, eles se recusam a aceitar os tokens de volta e voc√™ decidiu tentar a sorte.  Existem muitas m√°quinas ca√ßa-n√≠queis no sal√£o que voc√™ pode jogar.  Para um jogo com uma slot machine, voc√™ usa um token.  Em caso de vit√≥ria, a m√°quina oferece um d√≥lar, em caso de perda - nada.  Cada m√°quina tem uma probabilidade fixa de ganhar (que voc√™ n√£o conhece), mas √© diferente para m√°quinas diferentes.  Tendo estudado o site do fabricante dessas m√°quinas, voc√™ descobriu que a probabilidade de ganhar para cada m√°quina √© selecionada aleatoriamente no est√°gio de fabrica√ß√£o a partir da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">distribui√ß√£o beta</a> com determinados par√¢metros. <br><br>  Voc√™ deseja maximizar seus ganhos esperados. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos de E / S e exemplo</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  Uma execu√ß√£o pode consistir em v√°rios testes. <br><br>  Cada teste come√ßa com o fato de seu programa conter dois n√∫meros inteiros em uma linha, separados por um espa√ßo: o n√∫mero N √© o n√∫mero de fichas na sua bolsa e M √© o n√∫mero de m√°quinas na sala (N ‚â§ 10 <sup>4</sup> , M ‚â§ min (N, 100) )  A pr√≥xima linha cont√©m dois n√∫meros reais Œ± e Œ≤ (1 ‚â§ Œ±, Œ≤ ‚â§ 10) - os par√¢metros da distribui√ß√£o beta da probabilidade de vit√≥ria. <br><br>  O protocolo de comunica√ß√£o com o sistema de verifica√ß√£o √© o seguinte: voc√™ faz exatamente N pedidos.  Para cada solicita√ß√£o, imprima em uma linha separada o n√∫mero da m√°quina que voc√™ reproduzir√° (de 1 a M inclusive).  Como resposta, em uma linha separada, haver√° "0" ou "1", significando, respectivamente, uma perda e uma vit√≥ria em um jogo com o ca√ßa-n√≠queis solicitado. <br><br>  Ap√≥s o √∫ltimo teste, em vez dos n√∫meros N e M, haver√° dois zeros. <br><br><h4>  Formato de sa√≠da </h4><br>  A tarefa ser√° considerada conclu√≠da se sua decis√£o n√£o for muito pior que a decis√£o do j√∫ri.  Se sua decis√£o for significativamente pior que a decis√£o do j√∫ri, voc√™ receber√° o veredicto "resposta errada". <br><br>  √â garantido que, se sua decis√£o n√£o for pior que a decis√£o do j√∫ri, a probabilidade de receber o veredicto "resposta errada" n√£o exceder√° <sup>10-6</sup> . <br><br><h4>  Anota√ß√µes </h4><br>  Exemplo de intera√ß√£o: <br><br><pre> <code class="cpp hljs">____________________  <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>     <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> ____________________ ____________________   <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </div></div><br><h4>  Solu√ß√£o </h4><br>  Este problema √© bem conhecido, poderia ser resolvido de diferentes maneiras.  A principal decis√£o do j√∫ri implementou a estrat√©gia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">amostragem Thompson</a> , mas como o n√∫mero de etapas era conhecido no in√≠cio do programa, existem estrat√©gias mais √≥timas (por exemplo, UCB1).  Al√©m disso, pode-se conviver com a estrat√©gia epsilon-gananciosa: com uma certa probabilidade Œµ toca uma m√°quina aleat√≥ria e com uma probabilidade (1 - Œµ) toca uma m√°quina com as melhores estat√≠sticas de vit√≥ria. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SolverFromStdIn</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.regrets = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.total_win = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.moves = [] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThompsonSampling</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SolverFromStdIn)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, bandits_total, init_a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, init_b=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" init_a (int): initial value of a in Beta(a, b). init_b (int): initial value of b in Beta(a, b). """</span></span> SolverFromStdIn.__init__(self) self.n = bandits_total self.alpha = init_a self.beta = init_b self._as = [init_a] * self.n <span class="hljs-comment"><span class="hljs-comment"># [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self._bs = [init_b] * self.n # [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self.last_move = -1 random.seed(int(time.time())) def move(self): samples = [random.betavariate(self._as[x], self._bs[x]) for x in range(self.n)] self.last_move = max(range(self.n), key=lambda x: samples[x]) self.moves.append(self.last_move) return self.last_move def set_reward(self, reward): i = self.last_move r = reward self._as[i] += r self._bs[i] += (1 - r) return i, r while True: n, m = map(int, sys.stdin.readline().split()) if n == 0 and m == 0: break alpha, beta = map(float, sys.stdin.readline().split()) solver = ThompsonSampling(m) for _ in range(n): print &gt;&gt; sys.stdout, solver.move() + 1 sys.stdout.flush() reward = int(sys.stdin.readline()) solver.set_reward(reward)</span></span></code> </pre> <br><h2>  C. Alinhamento das frases </h2><br><h4>  Condi√ß√£o </h4><div class="scrollable-table"><table><tbody><tr><td>  Prazo </td><td>  2 s </td></tr><tr><td>  Limite de mem√≥ria </td><td>  64 MB </td></tr><tr><td>  Entrar </td><td>  entrada padr√£o ou input.txt </td></tr><tr><td>  Conclus√£o </td><td>  sa√≠da padr√£o ou output.txt </td></tr></tbody></table></div>  Uma das tarefas mais importantes para o treinamento de um bom modelo de tradu√ß√£o autom√°tica √© um bom caso de frases paralelas.  Normalmente, a fonte de ofertas paralelas s√£o documentos paralelos.  Acontece que, muitas vezes, para construir um certo corpus de frases paralelas, voc√™ n√£o precisa saber nada al√©m de seus comprimentos.  Em particular, voc√™ pode notar que, quanto mais longa a frase no idioma de origem, mais provavelmente ser√° traduzida.  Alguma dificuldade reside no fato de que, durante a tradu√ß√£o, o n√∫mero de frases no texto pode mudar: algumas vezes duas frases adjacentes na tradu√ß√£o podem ser combinadas em uma ou vice-versa - uma frase pode ser dividida em duas.  Em alguns casos raros, as frases podem ser omitidas inteiramente em uma tradu√ß√£o ou uma tradu√ß√£o pode aparecer em uma tradu√ß√£o que n√£o estava no original. <br><br>  Mais formalmente, suponha que o seguinte modelo generativo para gabinetes paralelos seja verdadeiro.  Em cada etapa, fazemos um dos seguintes: <br><br>  <b>1. <i>Pare</i></b> <br><br>  Com probabilidade p <sub>h, a</sub> gera√ß√£o dos cascos termina. <br><br>  <b>2. [1-0] <i>Ignorando ofertas</i></b> <br><br>  Com probabilidade p <sub>d,</sub> atribu√≠mos uma frase ao texto original.  N√£o atribu√≠mos nada √† tradu√ß√£o.  O comprimento da frase no idioma original L ‚â• 1 √© selecionado a partir da distribui√ß√£o discreta: <br><br><img src="https://habrastorage.org/webt/bm/pe/t_/bmpet_y_ksvwgbohazpgctekbks.png" width="350">  . <br><br>  Aqui <i>Œº <sub>s</sub></i> , <i>œÉ <sub>s</sub></i> s√£o os par√¢metros de distribui√ß√£o e <i>Œ± <sub>s</sub></i> √© o coeficiente de normaliza√ß√£o escolhido para que <img src="https://habrastorage.org/webt/fm/ae/ns/fmaensnvy1nauvywiluibhryr6s.png" width="100">  . <br><br>  <b>3. [0-1] <i>Inserir proposta</i></b> <br><br>  Com probabilidade p <sub>i,</sub> atribu√≠mos uma frase √† tradu√ß√£o.  N√£o atribu√≠mos nada ao original.  O comprimento de uma frase em um idioma de tradu√ß√£o L ‚â• 1 √© selecionado a partir de uma distribui√ß√£o discreta: <br><br><img src="https://habrastorage.org/webt/yl/yn/kr/ylynkr3cs_t7dpedebtzqj3uryk.png" width="350">  . <br><br>  Aqui <i>Œº <sub>t</sub></i> , <i>œÉ <sub>t</sub></i> s√£o os par√¢metros de distribui√ß√£o e <i>Œ± <sub>t</sub></i> √© o coeficiente de normaliza√ß√£o escolhido para que <img src="https://habrastorage.org/webt/bq/-k/p3/bq-kp37k-c-k5fpq9jrz4r8rkvy.png" width="100">  . <br><br>  <b>4. <i>Tradu√ß√£o</i></b> <br><br>  Com probabilidade (1 - p <sub>d</sub> - p <sub>i</sub> - p <sub>h</sub> ), tomamos o comprimento da senten√ßa no idioma original L <sub>s</sub> ‚â• 1 da distribui√ß√£o p <sub>s</sub> (com arredondamento para cima).  Em seguida, geramos o comprimento da senten√ßa no idioma de tradu√ß√£o L <sub>t</sub> ‚â• 1 a partir da distribui√ß√£o discreta condicional: <br><br><img src="https://habrastorage.org/webt/ae/b6/mx/aeb6mx4cols1jplbs-di9emhxf8.png" width="500">  . <br><br>  Aqui, <i>Œ± <sub>st</sub></i> √© o coeficiente de normaliza√ß√£o, e os demais par√¢metros s√£o descritos nos par√°grafos anteriores. <br><br>  O pr√≥ximo passo √© outro: <br><br>  1. [2-1] Com probabilidade p <sub>dividida s, a</sub> senten√ßa gerada no idioma original se divide em duas n√£o vazias, de modo que o n√∫mero total de palavras <b><i>aumenta exatamente uma</i></b> .  A probabilidade de uma senten√ßa de comprimento L <sub>s</sub> se dividir em partes do comprimento L <sub>1</sub> e L <sub>2</sub> (isto √©, L <sub>1</sub> + L <sub>2</sub> = L <sub>s</sub> + 1) √© proporcional a P <sub>s</sub> (L <sub>1</sub> ) ‚ãÖ P <sub>s</sub> (L <sub>2</sub> ). <br><br>  2. [1-2] Com probabilidade p <sub>dividida t, a</sub> senten√ßa gerada no idioma de destino se divide em duas senten√ßas n√£o vazias, de modo que o n√∫mero total de palavras aumenta exatamente uma.  A probabilidade de uma senten√ßa de comprimento L <sub>t</sub> se dividir em partes do comprimento L1 e L2 (ou seja, L <sub>1</sub> + L <sub>2</sub> = L <sub>t</sub> + 1) √© proporcional a P <sub>t</sub> (L <sub>1</sub> ) ‚ãÖ P <sub>t</sub> (L <sub>2</sub> ). <br><br>  3. 3. [1-1] Com uma probabilidade de (1 - p <sub>dividir s</sub> - p <sub>dividir t</sub> ), nenhum dos pares de senten√ßas geradas decair√°. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos de E / S, exemplos e notas</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  A primeira linha do arquivo cont√©m os par√¢metros de distribui√ß√£o: p <sub>h</sub> , p <sub>d</sub> , p <sub>i</sub> , p <sub>split s</sub> , p <sub>split t</sub> , Œº <sub>s</sub> , œÉ <sub>s</sub> , Œºt, œÉt.  0,1 ‚â§ œÉ <sub>s</sub> &lt;œÉ <sub>t</sub> ‚â§ 3. 0 ‚â§ Œº <sub>s</sub> , Œº <sub>t</sub> ‚â§ 5. <br><br>  A pr√≥xima linha cont√©m os n√∫meros N <sub>s</sub> e N <sub>t</sub> - o n√∫mero de frases no caso no idioma original e no idioma de destino, respectivamente (1 ‚â§ N <sub>s</sub> , N <sub>t</sub> ‚â§ 1000). <br><br>  A pr√≥xima linha cont√©m N <sub>s</sub> inteiros - os comprimentos das frases no idioma original.  A pr√≥xima linha cont√©m N <sub>t</sub> inteiros - os comprimentos das senten√ßas no idioma de destino. <br><br>  A pr√≥xima linha cont√©m dois n√∫meros: j e k (1 ‚â§ j ‚â§ N <sub>s</sub> , 1 ‚â§ k ‚â§ N <sub>t</sub> ). <br><br><h4>  Formato de sa√≠da </h4><br>  √â necess√°rio derivar a probabilidade de que senten√ßas com √≠ndices j e k nos textos sejam respectivamente paralelas (ou seja, geradas em uma etapa do algoritmo e nenhuma delas seja resultado de decaimento). <br><br>  Sua resposta ser√° aceita se o erro absoluto n√£o exceder 10 <sup>‚Äì4</sup> . <br><br><h4>  Exemplo 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclus√£o</b> </td></tr><tr><td> <code>0.05 0.08 0.07 0.15 0.1 1 0.3 3 0.5 <br> 1 1 <br> 4 <br> 20 <br> 1 1</code> </td> <td> <code>0.975037457809</code> </td> </tr></tbody></table></div><h4>  Exemplo 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclus√£o</b> </td></tr><tr><td> <code>0.1 0.2 0.3 0.25 0.3 1 0.3 3 0.5 <br> 2 1 <br> 3 4 <br> 20 <br> 2 1</code> </td> <td> <code>0.247705779810</code> </td> </tr></tbody></table></div><h4>  Exemplo 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclus√£o</b> </td></tr><tr><td> <code>0.2 0.2 0.2 0.3 0.3 3 0.3 1 1 <br> 5 3 <br> 16 35 24 19 23 <br> 5 6 7 <br> 2 1</code> </td> <td> <code>0.200961101684</code> </td> </tr></tbody></table></div><h4>  Anota√ß√µes </h4><br>  No primeiro exemplo, a sequ√™ncia inicial de n√∫meros pode ser obtida de tr√™s maneiras: <br><br>  ‚Ä¢ Primeiro, com probabilidade p <sub>d</sub> adicione uma frase ao texto original, depois com probabilidade p <sub>i</sub> adicione uma frase √† tradu√ß√£o e, em seguida, com probabilidade p <sub>h</sub> termine a gera√ß√£o. <br><br>  A probabilidade deste evento √© P <sub>1</sub> = p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>h</sub> . <br><br>  ‚Ä¢ Primeiro, com probabilidade p <sub>d</sub> adicione uma frase ao texto original, depois com probabilidade p <sub>i</sub> adicione uma frase √† tradu√ß√£o e, em seguida, com probabilidade p <sub>h</sub> termine a gera√ß√£o. <br><br>  A probabilidade desse evento √© igual a P <sub>2</sub> = p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>h</sub> . <br><br>  ‚Ä¢ Com probabilidade (1 - p <sub>h</sub> - p <sub>d</sub> - p <sub>i</sub> ) gere duas frases, depois com probabilidade (1 - p <sub>split s</sub> - p <sub>split t</sub> ) deixe tudo como est√° (ou seja, n√£o divida o original ou a tradu√ß√£o em duas frases) ) e depois com probabilidade p <sub>h</sub> terminar a gera√ß√£o. <br><br>  A probabilidade deste evento √© <br><img src="https://habrastorage.org/webt/xw/ka/ys/xwkayskmtg4g3tkt9pb3n-ieyoa.png" width="550">  . <br><br>  Como resultado, a resposta √© calculada como <img src="https://habrastorage.org/webt/zm/tw/xk/zmtwxkdjhhctfrcbiqsc0tur6g0.png" width="100">  . </div></div><br><h4>  Solu√ß√£o </h4><br>  A tarefa √© um caso especial de alinhamento usando modelos de Markov ocultos (alinhamento HMM).  A id√©ia principal √© que voc√™ possa calcular a probabilidade de gerar um par espec√≠fico de documentos usando esse modelo e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o algoritmo forward</a> : nesse caso, o estado √© um par de prefixos de documentos.  Consequentemente, a probabilidade requerida de alinhamento de um par espec√≠fico de senten√ßas paralelas pode ser calculada pelo algoritmo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">avan√ßo para tr√°s</a> . <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cmath&gt; #include &lt;vector&gt; double p_h, p_d, p_i, p_tr, p_ss, p_st, mu_s, sigma_s, mu_t, sigma_t; double lognorm_cdf(double x, double mu, double sigma) { if (x &lt; 1e-9) return 0.0; double res = std::log(x) - mu; res /= std::sqrt(2.0) * sigma; res = 0.5 * (1 + std::erf(res)); return res; } double length_probability(int l, double mu, double sigma) { return lognorm_cdf(l, mu, sigma) - lognorm_cdf(l - 1, mu, sigma); } double translation_probability(int ls, int lt) { double res = length_probability(ls, mu_s, sigma_s); double mu = mu_t - mu_s + std::log(ls); double sigma = std::sqrt(sigma_t * sigma_t - sigma_s * sigma_s); res *= length_probability(lt, mu, sigma); return res; } double split_probability(int l1, int l2, double mu, double sigma) { int l_sum = l1 + l2; double total_prob = 0.0; for (int i = 1; i &lt; l_sum; ++i) { total_prob += length_probability(i, mu, sigma) * length_probability(l_sum - i, mu, sigma); } return length_probability(l1, mu, sigma) * length_probability(l2, mu, sigma) / total_prob; } double log_prob10(int ls) { return std::log(p_d * length_probability(ls, mu_s, sigma_s)); } double log_prob01(int lt) { return std::log(p_i * length_probability(lt, mu_t, sigma_t)); } double log_prob11(int ls, int lt) { return std::log(p_tr * (1 - p_ss - p_st) * translation_probability(ls, lt)); } double log_prob21(int ls1, int ls2, int lt) { return std::log(p_tr * p_ss * split_probability(ls1, ls2, mu_s, sigma_s) * translation_probability(ls1 + ls2 - 1, lt)); } double log_prob12(int ls, int lt1, int lt2) { return std::log(p_tr * p_st * split_probability(lt1, lt2, mu_t, sigma_t) * translation_probability(ls, lt1 + lt2 - 1)); } double logsum(double v1, double v2) { double res = std::max(v1, v2); v1 -= res; v2 -= res; v1 = std::min(v1, v2); if (v1 &lt; -30) { return res; } return res + std::log(std::exp(v1) + 1.0); } double loginc(double* to, double from) { *to = logsum(*to, from); } constexpr double INF = 1e25; int main(void) { using std::cin; using std::cout; cin &gt;&gt; p_h &gt;&gt; p_d &gt;&gt; p_i &gt;&gt; p_ss &gt;&gt; p_st &gt;&gt; mu_s &gt;&gt; sigma_s &gt;&gt; mu_t &gt;&gt; sigma_t; p_tr = 1.0 - p_h - p_d - p_i; int Ns, Nt; cin &gt;&gt; Ns &gt;&gt; Nt; using std::vector; vector&lt;int&gt; ls(Ns), lt(Nt); for (int i = 0; i &lt; Ns; ++i) cin &gt;&gt; ls[i]; for (int i = 0; i &lt; Nt; ++i) cin &gt;&gt; lt[i]; vector&lt; vector&lt; double&gt; &gt; fwd(Ns + 1, vector&lt;double&gt;(Nt + 1, -INF)), bwd = fwd; fwd[0][0] = 0; bwd[Ns][Nt] = 0; for (int i = 0; i &lt;= Ns; ++i) { for (int j = 0; j &lt;= Nt; ++j) { if (i &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j] + log_prob10(ls[i - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j] + log_prob10(ls[Ns - i])); } if (j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i][j - 1] + log_prob01(lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i][Nt - j + 1] + log_prob01(lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 1] + log_prob11(ls[i - 1], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 1] + log_prob11(ls[Ns - i], lt[Nt - j])); } if (i &gt;= 2 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 2][j - 1] + log_prob21(ls[i - 1], ls[i - 2], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 2][Nt - j + 1] + log_prob21(ls[Ns - i], ls[Ns - i + 1], lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 2) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 2] + log_prob12(ls[i - 1], lt[j - 1], lt[j - 2])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 2] + log_prob12(ls[Ns - i], lt[Nt - j], lt[Nt - j + 1])); } } } int j, k; cin &gt;&gt; j &gt;&gt; k; double rlog = fwd[j - 1][k - 1] + bwd[j][k] + log_prob11(ls[j - 1], lt[k - 1]) - bwd[0][0]; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12) &lt;&lt; std::exp(rlog) &lt;&lt; std::endl; }</span></span></span></span></code> </pre> </div></div><br><h2>  D. Fita de recomenda√ß√µes </h2><br><h4>  Condi√ß√£o </h4><div class="scrollable-table"><table><tbody><tr><td>  Prazo </td><td>  2 s </td></tr><tr><td>  Limite de mem√≥ria </td><td>  64 MB </td></tr><tr><td>  Entrar </td><td>  entrada padr√£o ou input.txt </td></tr><tr><td>  Conclus√£o </td><td>  sa√≠da padr√£o ou output.txt </td></tr></tbody></table></div>  Considere um feed de recomenda√ß√µes para conte√∫do heterog√™neo.  Ele mistura objetos de v√°rios tipos (fotos, v√≠deos, not√≠cias etc.).  Esses objetos geralmente s√£o ordenados por relev√¢ncia para o usu√°rio: quanto mais relevante (interessante) o objeto para o usu√°rio, mais pr√≥ximo ao topo da lista de recomenda√ß√µes.  No entanto, com essa ordem, surgem frequentemente situa√ß√µes em que v√°rios objetos do mesmo tipo aparecem na lista de recomenda√ß√µes.  Isso piora bastante a variedade externa de nossas recomenda√ß√µes e, portanto, os usu√°rios n√£o gostam.  √â necess√°rio implementar um algoritmo que, de acordo com a lista de recomenda√ß√µes, constitua uma nova lista que estar√° livre desse problema e ser√° mais relevante. <br><br>  Seja dada uma lista inicial de recomenda√ß√µes a = [a <sub>0</sub> , a <sub>1</sub> , ..., a <sub>n - 1</sub> ] de comprimento n&gt; 0. Um objeto com o n√∫mero i possui um tipo com o n√∫mero b <sub>i</sub> ‚àà {0, ..., m - 1}.  Al√©m disso, um objeto sob o n√∫mero i tem relev√¢ncia r (a <sub>i</sub> ) = 2 <sub>‚àíi</sub> .  Considere a lista que √© obtida a partir da inicial escolhendo um subconjunto de objetos e reorganizando-os: x = [a <sub>i <sub>0</sub></sub> , a <sub>i <sub>1</sub></sub> , ..., a <sub>i <sub>k - 1</sub></sub> ] de comprimento k (0 ‚â§ k ‚â§ n).  Uma lista √© chamada admiss√≠vel se n√£o houver dois objetos consecutivos coincidentes no tipo, ou seja, b <sub>i <sub>j</sub></sub> ‚â† b <sub>i <sub>j + 1</sub></sub> para todos os j = 0, ..., k - 2.  A relev√¢ncia da lista √© calculada pela f√≥rmula <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2212;</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.112ex" height="3.503ex" viewBox="0 -987.6 7367.6 1508.3" role="img" focusable="false" style="vertical-align: -1.209ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-75" x="719" y="0"></use><g transform="translate(1292,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-6D" x="0" y="0"></use><g transform="translate(878,403)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMAIN-2212" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMAIN-31" x="1300" y="0"></use></g><g transform="translate(878,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-6A" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMAIN-3D" x="412" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMAIN-30" x="1191" y="0"></use></g></g><g transform="translate(3543,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMAIN-2212" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-6A" x="778" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-72" x="4986" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMAIN-28" x="5437" y="0"></use><g transform="translate(5827,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-61" x="0" y="0"></use><g transform="translate(529,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.5)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMATHI-6A" x="488" y="-213"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhgy5T_NG9PWmZQ8AxtnrsprgA7UPw#MJMAIN-29" x="6978" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>‚àí</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mo>‚àí</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ sum_ {j = 0} ^ {k-1} 2 _ {- j} r (a_ {i_j}) </script>  .  Voc√™ precisa encontrar a lista de relev√¢ncia m√°xima entre todas as v√°lidas. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos e exemplos de E / S</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  Na primeira linha, os n√∫meros n e m s√£o escritos com um espa√ßo (1 ‚â§ n ‚â§ 100000, 1 ‚â§ m ‚â§ n).  As pr√≥ximas n linhas cont√™m os n√∫meros b <sub>i</sub> para i = 0, ..., n - 1 (0 ‚â§ b <sub>i</sub> ‚â§ m - 1). <br><br><h4>  Formato de sa√≠da </h4><br>  Anote, com um espa√ßo, os n√∫meros de objetos na lista final: i <sub>0</sub> , i <sub>1</sub> , ..., i <sub>k - 1</sub> . <br><br><h4>  Exemplo 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclus√£o</b> </td></tr><tr><td> <code>1 1 <br> 0</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Exemplo 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclus√£o</b> </td></tr><tr><td> <code>2 2 <br> 1 <br> 1</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Exemplo 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclus√£o</b> </td></tr><tr><td> <code>10 2 <br> 1 <br> 1 <br> 1 <br> 0 <br> 0 <br> 1 <br> 0 <br> 1 <br> 1 <br> 1</code> </td> <td> <code>0 3 1 4 2 6 5</code> </td> </tr></tbody></table></div></div></div><br><h4>  Solu√ß√£o </h4><br>  Usando c√°lculos matem√°ticos simples, pode ser demonstrado que o problema pode ser resolvido por uma abordagem ‚Äúgananciosa‚Äù, ou seja, na lista ideal de recomenda√ß√µes, cada item tem o objeto mais relevante de todos os que s√£o v√°lidos no mesmo in√≠cio da lista.  A implementa√ß√£o dessa abordagem √© simples: pegamos objetos em uma linha e os adicionamos √† resposta, se poss√≠vel.  Quando um objeto inv√°lido √© encontrado (cujo tipo coincide com o tipo do anterior), o colocamos de lado em uma fila separada, da qual o inserimos na resposta o mais r√°pido poss√≠vel.  Observe que, a todo momento, todos os objetos nessa fila ter√£o um tipo correspondente.  No final, v√°rios objetos podem permanecer na fila, eles n√£o ser√£o mais inclu√≠dos na resposta. <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; blend(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; types) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; repeated; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.empty() || types[result.back()] != types[i]) { result.push_back(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!repeated.empty() &amp;&amp; types[repeated.front()] != types[result.back()]) { result.push_back(repeated.front()); repeated.pop(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { repeated.push(i); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2>  D. Clusteriza√ß√£o de seq√º√™ncias de caracteres </h2><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Todas as l√≠nguas</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  Prazo </td><td>  1 s </td><td>  6 s </td><td>  6 s </td></tr><tr><td>  Limite de mem√≥ria </td><td>  64 MB </td><td>  64 MB </td><td>  64 MB </td></tr><tr><td>  Entrar </td><td colspan="3">  entrada padr√£o ou input.txt </td></tr><tr><td>  Conclus√£o </td><td colspan="3">  sa√≠da padr√£o ou output.txt </td></tr></tbody></table></div>  Existe um alfabeto finito A = {a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>K - 1</sub> , a <sub>K</sub> = S}, a <sub>i</sub> ‚àà {a, b, ..., z}, S √© o fim da linha. <br><br>  Considere o seguinte m√©todo para gerar seq√º√™ncias aleat√≥rias sobre o alfabeto A: <br><br>  1. O primeiro caractere x <sub>1</sub> √© uma vari√°vel aleat√≥ria com a distribui√ß√£o P (x <sub>1</sub> = a <sub>i</sub> ) = q <sub>i</sub> (sabe-se que q <sub>K</sub> = 0). <br>  2. Cada caractere seguinte √© gerado com base no anterior, de acordo com a distribui√ß√£o condicional P (x <sub>i</sub> = a <sub>j</sub> || x <sub>i - 1</sub> = a <sub>l</sub> ) = p <sub>jl</sub> . <br>  3. Se x <sub>i</sub> = S, a gera√ß√£o para e o resultado √© x <sub>1</sub> x <sub>2</sub> ... x <sub>i - 1</sub> . <br><br>  O conjunto de linhas geradas a partir de uma mistura de dois modelos descritos com diferentes par√¢metros √© dado.  √â necess√°rio que cada linha forne√ßa o √≠ndice da cadeia da qual foi gerada. <br><br><div class="spoiler">  <b class="spoiler_title">Formatos de E / S, exemplo e anota√ß√µes</b> <div class="spoiler_text"><h4>  Formato de entrada </h4><br>  A primeira linha cont√©m dois n√∫meros 1000 ‚â§ N ‚â§ 2000 e 3 ‚â§ K ‚â§ 27 - o n√∫mero de linhas e o tamanho do alfabeto, respectivamente. <br><br>  A segunda linha cont√©m uma linha que consiste em K - 1 letras min√∫sculas diferentes do alfabeto latino, indicando os primeiros elementos K - 1 do alfabeto. <br><br>  Cada uma das N linhas a seguir √© gerada de acordo com o algoritmo descrito na condi√ß√£o. <br><br><h4>  Formato de sa√≠da </h4><br>  N linhas, a i-√©sima linha cont√©m o n√∫mero do cluster (0/1) para a sequ√™ncia na i + 1-√©sima linha do arquivo de entrada.  A coincid√™ncia com a resposta verdadeira deve ser de pelo menos 80%. <br><br><h4>  Exemplo </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrar</b> </td><td>  <b>Conclus√£o</b> </td></tr><tr><td> <code>100 3 <br> a <br> a <br> aa <br> a <br> aaa <br> a <br> aaaaaa <br> aa <br> a <br> a <br> a <br> aaa <br> a <br> a <br> aaa <br> aa <br> aaaa <br> aaa <br> a <br> aaaaa <br> aa <br> a <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaaa <br> aaa <br> a <br> aa <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaa <br> aaa <br> a <br> a <br> bbb <br> bb <br> bb <br> bbbbbbb <br> bb <br> bbb <br> b <br> bbbbbbb <br> bbbb <br> bbb <br> bb <br> bbb <br> bb <br> bb <br> bbb <br> bbbbbb <br> bbb <br> b <br> bbbbbb <br> b <br> bbbbb <br> b <br> b <br> bb <br> b <br> bb <br> bb <br> b <br> b <br> b <br> b <br> bb <br> bb <br> bb <br> b <br> b <br> b <br> bb <br> b <br> bbb <br> bb <br> b <br> bbbbbb <br> b <br> bb <br> bb <br> bb <br> b <br> bb <br> bbb</code> </td> <td> <code>0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1</code> </td> </tr></tbody></table></div><h4>  Anota√ß√µes </h4><br>  Nota para o teste da condi√ß√£o: nele, as 50 primeiras linhas s√£o geradas a partir da distribui√ß√£o <br>  P (x <sub>i</sub> = a | x <sub>i - 1</sub> = a) = 0,5, P (x <sub>i</sub> = S | x <sub>i - 1</sub> = a) = 0,5, P (x <sub>1</sub> = a) = 1;  segundo 50 - da distribui√ß√£o <br>  P (x <sub>i</sub> = b | x <sub>i - 1</sub> = b) = 0,5, P (x <sub>i</sub> = S | x <sub>i - 1</sub> = b) = 0,5, P (x <sub>1</sub> = b) = 1. </div></div><br><h4>  Solu√ß√£o </h4><br>  O problema √© resolvido usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algoritmo EM</a> : sup√µe-se que a amostra apresentada seja gerada a partir de uma mistura de duas cadeias de Markov cujos par√¢metros s√£o restaurados durante as itera√ß√µes.  Uma restri√ß√£o de 80% das respostas corretas √© feita para que a corre√ß√£o da solu√ß√£o n√£o seja afetada por exemplos com alta probabilidade nas duas cadeias.  Esses exemplos, portanto, quando restaurados adequadamente, podem ser atribu√≠dos a uma cadeia incorreta em termos da resposta gerada. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math EPS = <span class="hljs-number"><span class="hljs-number">1e-9</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>] * size <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, cols)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [empty_row(cols) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(rows)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row)</span></span></span><span class="hljs-function">:</span></span> row_sum = sum(row) + EPS <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x / row_sum <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mtx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [normalized_row(r) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mtx] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alphabet, string_samples)</span></span></span><span class="hljs-function">:</span></span> n_tokens = len(alphabet) n_samples = len(string_samples) samples = [tuple([alphabet.index(token) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s] + [n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>, n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string_samples] probs = [random.random() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n_samples)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>): old_probs = [x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> probs] <span class="hljs-comment"><span class="hljs-comment"># probs fixed p0, A = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) q0, B = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) for prob, sample in zip(probs, samples): p0[sample[0]] += prob q0[sample[0]] += 1 - prob for t1, t2 in zip(sample[:-1], sample[1:]): A[t1][t2] += prob B[t1][t2] += 1 - prob A, p0 = normalized_matrix(A), normalized_row(p0) B, q0 = normalized_matrix(B), normalized_row(q0) trans_log_diff = [ [math.log(b + EPS) - math.log(a + EPS) for b, a in zip(B_r, A_r)] for B_r, A_r in zip(B, A) ] # A, p0, B, q0 fixed probs = empty_row(n_samples) for i, sample in enumerate(samples): value = math.log(q0[sample[0]] + EPS) - math.log(p0[sample[0]] + EPS) for t1, t2 in zip(sample[:-1], sample[1:]): value += trans_log_diff[t1][t2] probs[i] = 1.0 / (1.0 + math.exp(value)) if max(abs(x - y) for x, y in zip(probs, old_probs)) &lt; 1e-9: break return [int(x &gt; 0.5) for x in probs] def main(): N, K = list(map(int, input().split())) string_samples = [] alphabet = list(input().strip()) + [''] for _ in range(N): string_samples.append(input().rstrip()) result = restore_params(alphabet, string_samples) for r in result: print(r) if __name__ == '__main__': main()</span></span></code> </pre> <br><hr><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461273/">https://habr.com/ru/post/pt461273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461261/index.html">Lista de verifica√ß√£o de webinars √∫teis do RRC sobre produtos RRC</a></li>
<li><a href="../pt461265/index.html">Sobre o abuso do uso do sistema operacional em projetos para microcontroladores</a></li>
<li><a href="../pt461267/index.html">Novas tecnologias Intel para empacotamento de chips</a></li>
<li><a href="../pt461269/index.html">A solu√ß√£o de trabalho com pwnable.kr 08 √© perna e 10 √© shellshock. ARM assembler. Vulnerabilidade do Bash</a></li>
<li><a href="../pt461271/index.html">Como promover um aplicativo m√≥vel em 2019: 4 maneiras pr√°ticas + ferramentas √∫teis</a></li>
<li><a href="../pt461277/index.html">Vis√£o geral da ferramenta SQLIndexManager gratuita</a></li>
<li><a href="../pt461279/index.html">Como criar um microsservi√ßo simples no Golang e gRPC e cont√™-lo usando o Docker</a></li>
<li><a href="../pt461281/index.html">Passo a passo para configurar um servidor DNS BIND em um ambiente chroot para Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../pt461283/index.html">Arquitetura de software e design de sistemas: guia geral e recursos</a></li>
<li><a href="../pt461285/index.html">5 principais algoritmos de amostragem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>