<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚎 🤰🏼 👸🏾 Reagieren Sie auf dem HolyJs 2018 am HeadHunter-Stand auf das Quiz des Wettbewerbs 👨🏾‍💻 👁‍🗨 👨‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo. Am 24. und 25. September fand in Moskau eine Konferenz der Front-End-Entwickler von HolyJ https://holyjs-moscow.ru/ statt. Wir kamen mit unsere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reagieren Sie auf dem HolyJs 2018 am HeadHunter-Stand auf das Quiz des Wettbewerbs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/431492/"><p>  Hallo.  Am 24. und 25. September fand in Moskau eine Konferenz der Front-End-Entwickler von HolyJ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://holyjs-moscow.ru/</a> statt.  Wir kamen mit unserem Stand zur Konferenz, an dem wir ein Quiz abhielten.  Es gab ein Hauptquiz - 4 Qualifikationsrunden und 1 Endrunde, in denen die Apple Watch- und Lego-Konstrukteure gespielt wurden.  Und separat haben wir ein Quiz zum Reagieren von Wissen durchgeführt. </p><br><p>  Unter Cat - Parsing Quiz Aufgaben reagieren.  Die richtigen Optionen werden unter dem Spoiler versteckt, sodass Sie nicht nur die Analyse lesen, sondern auch sich selbst überprüfen können :) </p><br><p><img src="https://habrastorage.org/webt/ot/wn/yq/otwnyqyymtf5t_yedi3aj2-wuau.jpeg" alt="Bild"></p><br><p>  Lass uns gehen! </p><a name="habracut"></a><br><p>  Der Einfachheit halber haben wir die Fragen in Abschnitte unterteilt: </p><br><h3 id="sekciya-1-bazovoe-ponimanie-raboty-thissetstate-i-updating-lifecycle-komponenta">  Abschnitt 1. Grundlegendes Verständnis der Funktionsweise von this.setState und Aktualisieren des Komponentenlebenszyklus: </h3><br><p>  <strong>Frage 1.</strong> </p><br><pre><code class="plaintext hljs">      react-: 1) SetProps, SetState, ForceUpdate 2) ForceUpdate, SetState 3) ForceUpdate, SetState, Parent (re)render 4) ForceUpdate, SetState, directly call UpdateComponent</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  3) ForceUpdate, SetState, Parent (re) rendern </p></div></div><br><p>  <strong>Frage 2.</strong> </p><br><pre> <code class="plaintext hljs"> ,   this.setState({})  react 1)   ,  updating lifecycle 2)   ,    3) React    "Object cannot be empty" 4)    state  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  1) Die Komponente ist als verschmutzt markiert, der Aktualisierungslebenszyklus wird aufgerufen </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analyse der Fragen 1 und 2</b> <div class="spoiler_text"><p>  Um die Frage zu beantworten, werden wir 2 Teile analysieren: <br>  1) Eigene Komponentenanforderung zum Aktualisieren des Zyklus <br>  2) Anfrage außerhalb der Komponente </p><br><p>  Die Komponente selbst hat zwei Möglichkeiten, sich selbst zu aktualisieren: <br>  1) this.setState und this.forceUpdate.  In diesem Fall wird die Komponente als verschmutzt markiert und im Häkchen Reconcilliation wird ein Aktualisierungszyklus gestartet, wenn sie beim Rendern Priorität hat. </p><br><p>  Interessante Tatsache: <code>this.setState({})</code> und <code>this.forceUpdate</code> sind unterschiedlich.  Wenn <code>this.setState({})</code> aufgerufen wird, wird im Gegensatz zu <code>this.forceUpdate</code> die vollständige Aktualisierungsschleife <code>this.forceUpdate</code> , wenn die Aktualisierungsschleife ohne die Methode shouldComponentUpdate gestartet wird.  Ein Beispiel für die Arbeit von <code>this.setState({})</code> finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/m5jz2701l9</a> (wenn Sie im Beispiel setState durch forceUpdate ersetzen, können Sie sehen, wie sich das Verhalten der Komponenten ändert). </p><br><p>  2) Wenn das übergeordnete Element der Komponente erneut gerendert wird, gibt es den vDOM-Teil zurück, alle untergeordneten Elemente, die aktualisiert werden müssen, und sie werden auch als vollständiger Aktualisierungslebenszyklus bezeichnet.  Eine vollständige Nachzählung des Teilbaums kann vermieden werden, indem shouldComponentUpdate beschrieben oder die Komponente als PureComponent definiert wird. </p></div></div><br><p>  <strong>Frage 3</strong> </p><br><pre> <code class="plaintext hljs">  Component  PureComponent (PC) 1) Component   ,    Pure 2) PC  SCU,  shallowEqual props  state 3) PC    ,    store 4)  PC    shouldComponentUpdate</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  2) PC implementiert SCU, führt flache Gleiche Requisiten und Status durch </p><br><p>  Wie bereits erwähnt, wird beim (erneuten) Rendern des übergeordneten Elements der gesamte Teilbaum an den aktualisierenden Lebenszyklus gesendet.  Stellen Sie sich vor, Sie haben das Stammelement aktualisiert.  In diesem Fall müssen Sie entsprechend dem Ketteneffekt fast den gesamten Reaktionsbaum aktualisieren.  Um unnötige Aktualisierungen zu optimieren und nicht zu senden, gibt es in Reaktion eine Methode <code>shouldComponentUpdate</code> , mit der Sie true zurückgeben können, wenn die Komponente aktualisiert werden soll, andernfalls false.  Um Vergleiche in der Reaktion zu vereinfachen, können Sie von <code>PureComponent</code> erben, um sofort bereit zu sein, <code>shouldComponentUpdate</code> , das alle Requisiten und <code>shouldComponentUpdate</code> , die in die Komponente <code>shouldComponentUpdate</code> , <code>shouldComponentUpdate</code> von Referenzen (wenn es sich um Objekttypen handelt) oder nach Werten (wenn es sich um <code>shouldComponentUpdate</code> handelt) vergleicht. </p></div></div><br><p>  <strong>Frage 4.</strong> </p><br><pre> <code class="plaintext hljs">this.setState(() =&gt; {}, () =&gt; {}) —       setState? 1) set   .    updating 2)       state 3) setState   1 </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  2) Die zweite Funktion wird nach dem Aktualisieren des Status aufgerufen </p><br><p>  Im React-Lifecycle gibt es zwei Methoden: <code>componentDidMount</code> für die Mounting-Schleife und componentDidUpdate für die Aktualisierung, wobei Sie nach der Aktualisierung der Komponente eine Logik hinzufügen können.  Stellen Sie beispielsweise eine http-Anfrage, nehmen Sie einige Stiländerungen vor, rufen Sie die Metriken der HTML-Elemente ab und machen Sie (nach Bedingung) setState.  Wenn Sie nach dem Ändern bestimmter Felder im Status eine Aktion ausführen möchten, müssen Sie in der <code>componentDidUpdate</code> Methode entweder einen Vergleich schreiben: </p><br><pre> <code class="plaintext hljs">componentDidUpdate(prevProp, prevState) { if (prevState.foo !== this.state.foo) { // do awesome things here } }</code> </pre> <br><p>  Oder Sie können es mit setState tun: </p><br><pre> <code class="plaintext hljs">setState( // set new foo {foo: 'baz'}, () =&gt; { // do awesome things here } );</code> </pre> <br><p>  Jeder Ansatz hat Vor- und Nachteile (wenn Sie beispielsweise setState an mehreren Stellen ändern, ist es möglicherweise bequemer, eine Bedingung einmal zu schreiben). </p></div></div><br><p>  <strong>Frage 5.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { render() { console.log('render'); return &lt;div /&gt; } } function Test() { return &lt;A foo='bar' onClick={() =&gt; console.log('foo')} /&gt; } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;Test /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;Test /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  2) 2 </p></div></div><br><p>  <strong>Frage 6.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { render() { console.log('render'); return &lt;div /&gt; } } function Test() { return &lt;A foo='bar' /&gt; } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;Test /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;Test /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  1) 1 </p></div></div><br><p>  <strong>Frage 7.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { componentDidMount() { console.log('render'); } render() { return &lt;div /&gt; } } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;A /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;A /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  1) 1 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analyse der Fragen 5-7</b> <div class="spoiler_text"><p>  Fragen 5–7 sind für dasselbe erforderlich - um das Verständnis der Arbeit von <code>PureComponent</code> und die Aktualisierung der Komponenten bei der Übertragung von Requisiten zu überprüfen.  Wenn wir innerhalb der Render-Methode einen jsx-Rückruf übergeben, der dies direkt in der Render-Funktion beschreibt: </p><br><pre> <code class="plaintext hljs">render () { return &lt;Button onClick={() =&gt; {}} /&gt;; }</code> </pre> <br><p>  Dann aktualisiert jedes Rendering des übergeordneten Elements den angegebenen Klick-Handler.  Dies liegt daran, dass bei jedem Rendern eine neue Funktion mit einem eindeutigen Link erstellt wird. Im Vergleich zu PureComponent werden die neuen Requisiten nicht den alten entsprechen und Sie müssen die Komponente aktualisieren.  Wenn alle Prüfungen bestanden sind und shouldComponentUpdate false zurückgibt, erfolgt die Aktualisierung nicht. </p></div></div><br><h3 id="sekciya-2-keys-in-react">  Abschnitt 2. Schlüssel in Reaktion </h3><br><p>  Eine detaillierte Analyse der hier veröffentlichten Schlüssel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/company/hh/blog/352150/</a> </p><br><p>  <strong>Frage 1.</strong> </p><br><pre> <code class="plaintext hljs">    key,      ? 1)         key 2)    updating lifecycle 3)   key  4)    reconciliation</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  1) Löschen Sie die vorherige Instanz und mounten Sie die neue, wenn Sie den Schlüssel ändern </p><br><p>  Ohne Schlüssel wird durch Reagieren die Liste der Elemente paarweise von oben nach unten verglichen.  Wenn wir den Schlüssel verwenden, erfolgt der Vergleich mit dem entsprechenden Schlüssel.  Wenn ein neuer Schlüssel angezeigt wurde, wird eine solche Komponente mit niemandem verglichen und sofort von Grund auf neu erstellt. <br>  Sie können diese Methode auch dann verwenden, wenn wir 1 Element haben: Wir können <code>&lt;A key="1" /&gt;</code> , im nächsten Rendering geben wir <code>&lt;A key="2" /&gt;</code> und in diesem Fall wird durch Reagieren <code>&lt;A key="1" /&gt;</code> gelöscht. <code>&lt;A key="1" /&gt;</code> und erstellen Sie von Grund auf <code>&lt;A key="2" /&gt;</code> . </p></div></div><br><p>  <strong>Frage 2.</strong> </p><br><pre> <code class="plaintext hljs">      this.prop.key? 1)  2)  3)   static getKey</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  2) Nein </p><br><p>  Die Komponente kann den Schlüssel von ihren untergeordneten Elementen lernen, die ihr als Requisite übergeben wurden, kann jedoch nichts über ihren Schlüssel lernen. </p></div></div><br><p>  <strong>Frage 3.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { componentDidMount() { console.log('render'); } render() { return &lt;div /&gt; } } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;A key='1' /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;A /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  2) 2 </p><br><p>  Beim Ändern des Schlüssels wird die Komponente neu erstellt, sodass das Rendern zweimal angezeigt wird. </p></div></div><br><h3 id="sekciya-3-voprosy-po-jsx">  Abschnitt 3. Fragen zu jsx </h3><br><p>  <strong>Frage 1.</strong> </p><br><pre> <code class="plaintext hljs">  .           1)    prop / context 2)        3)  setParentProps 4)  static getParentRef</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  1) Rückruf in Form von Requisite / Kontext <br>  2) Entfernen Sie die Ebene des Modells und arbeiten Sie sie durch </p><br><p>  Es gibt zwei richtige Antworten.  Wenn Sie einen von ihnen in einem Quiz auswählen, erhalten Sie Punkte.  Diese Frage dient der Kenntnis des Datenflusses.  Daten von oben nach unten werden in Form von Requisiten oder Kontext verteilt. Sie können einen Rückruf enthalten, den die folgende Komponente aufrufen kann, um den Status des Systems zu beeinflussen. <br>  Eine andere Methode, die Modellentfernung, Kontext und Requisite kombiniert, ist beispielsweise die React-Redux-Bindung. <br>  Diese Bibliothek verwendet ein Modell aus React (Redux).  Legt redux.store in Provider fest, wodurch der Speicher tatsächlich im Kontext festgelegt wird.  Anschließend verwendet der Entwickler die HOC-Verbindung, die in den Kontext eingeht, Änderungen zum Speichern (store.subscribe) abonniert und bei Änderungen des Speichers die Funktion <code>mapStateToProps</code> .  Wenn sich die Daten geändert haben, werden sie in Requisiten für das umschlossene Objekt festgelegt. <br>  Gleichzeitig können Sie mit <code>mapDispatchToProps</code> angeben, wobei der Entwickler die actionCreators angibt, die an die Komponente übergeben werden müssen.  Wir wiederum empfangen sie von außen (ohne Kontext), binden die <code>actionCreators</code> an den Store (wir verpacken sie in store.dispatch) und übergeben sie als Requisiten an die verpackte Komponente. </p></div></div><br><p>  <strong>Frage 2.</strong> </p><br><pre> <code class="plaintext hljs">  props   jsx?     1)   2)   children</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  1) In jedem </p><br><p>  Sie können zu jedem übertragen.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">&lt;Button icon={&lt;Icon kind='warning'/&gt;}&gt;&lt;/Button&gt;</code> </pre> <br><p>  Zeichnet eine Schaltfläche mit einem Symbol.  Dieser Ansatz ist sehr praktisch, um der Komponente das Recht zu geben, die Position verschiedener Elemente relativ zueinander zu steuern, anstatt eine untergeordnete Requisite zu sortieren. </p></div></div><br><h3 id="sekciya-4-prodvinutoe-ponimanie-setstate">  Abschnitt 4. Erweitertes Verständnis von setState </h3><br><p>  Hier sind 3 stark verwandte Fragen: </p><br><p>  <strong>Frage 1.</strong> </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; ... this.setState({a: 'b'}); this.setState({a: this.state.a + 1}) this.state? 1) {a: 'a1'} 2) {a: 'b1'} 3)   4) {a: 'a'}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  3) Nicht genügend Daten </p></div></div><br><p>  <strong>Frage 2.</strong> </p><br><pre> <code class="plaintext hljs">this.state={a: 'a'} ... this.setState({a: 'b'}) this.setState(state =&gt; ({a: state.a + 1})) this.state? 1) {a: 'a1'} 2) {a: 'b1'} 3)   4) {a: 'ab1'}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  2) {a: 'b1'} </p></div></div><br><p>  <strong>Frage 3.</strong> </p><br><pre> <code class="plaintext hljs">   2 setState  componentDidUpdate  updating lifecycle   1) 1 2) 2 3) 3 4)  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  1) 1 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analyse der Fragen 1-3</b> <div class="spoiler_text"><p>  Die gesamte Arbeit von setState wird hier vollständig beschrieben: <br>  1) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://reactjs.org/docs/react-component.html#setstate</a> <br>  2) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973</a> </p><br><p>  Tatsache ist, dass setState nicht synchron erfolgt. <br>  Und wenn setState mehrere Aufrufe hintereinander hat, hängt die Ausführung von setState davon ab, ob wir uns innerhalb der React-Lifecycle-Methode, der Handlerfunktion des React-Ereignisses (onChange, onClick) befinden oder nicht. <br>  In React-Handlern arbeitet setState stapelweise (Änderungen werden erst dann ausgeführt, wenn die benutzerdefinierten Funktionen im Aufrufstapel beendet sind und wir auf die Funktionen zugreifen, die unsere Ereignishandler- und Lebenszyklusmethoden aufgerufen haben).  Sie rollen nacheinander. Wenn wir uns also im React-Handler befinden, erhalten wir: </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; // a: 'a' ... this.state.a // a: 'a' this.setState({a: 'b'}); // a: 'b' +   .       this.state.a // a: 'a' this.setState({a: this.state.a + 1}) // a: 'a1'</code> </pre> <br><p>  da die Änderungen aufgetreten sind batchevo. <br>  Aber gleichzeitig, wenn setState außerhalb von React-Handlern aufgerufen wurde: </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; // a: 'a' ... this.state.a // a: 'a' this.setState({a: 'b'}); // a: 'b' +     this.state.a // a: 'b' this.setState({a: this.state.a + 1}) // a: 'b1' +    </code> </pre> <br><p>  Da in diesem Fall die Änderungen separat gewürfelt werden. </p></div></div><br><h3 id="sekciya-5-redux">  Abschnitt 5. Redux </h3><br><p>  <strong>Frage 1.</strong> </p><br><pre> <code class="plaintext hljs">    action,  () =&gt; {} ? 1) .  action      type 2) ,   action      type 3) ,    middleware   action 4) ,       dispatch</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  3) Ja, Sie müssen für eine solche Aktion eine benutzerdefinierte Middleware definieren </p><br><p>  Nehmen Sie Redux-Thunk als einfachstes Beispiel.  Alle Middleware ist ein kleiner Codeblock: <br>  <a href="">https://github.com/reduxjs/redux-thunk/blob/master/src/index.js#L2-L9</a> </p><br><pre> <code class="plaintext hljs">return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; { if (typeof action === 'function') { return action(dispatch, getState, extraArgument); } return next(action); };</code> </pre> <br><p>  Wie funktioniert Middleware? <br>  Sie erhalten die Kontrolle, bevor die Aktion im Geschäft eintrifft.  Daher wird eine überschriebene Aktion zuerst die Middleware-Kette durchlaufen. <br>  Jede Middleware akzeptiert eine Speicherinstanz, die nächste Methode, mit der Sie die Aktion weiterleiten können, und die Aktion selbst. <br>  Wenn Middleware benutzerdefinierte Aktionen wie Redux-Thunk verarbeitet, leitet die Aktion, wenn sie eine Funktion ist, die Aktion nicht weiter, sondern "übertönt" sie, sondern ruft die Aktion mit den dort übergebenen Methoden dispatch und getState auf. <br>  Was würde passieren, wenn Redux-Thunk als nächstes eine Aktion ausführen würde, was eine Funktion ist? <br>  Speichern Sie vor dem Aufrufen von Reduzierern die Art der Aktion.  Es muss folgende Bedingungen erfüllen: <br>  1) Es muss ein Objekt sein <br>  2) Es sollte ein Typfeld haben <br>  3) Das Typfeld muss vom Typ string sein </p><br><p>  Wenn eine der Bedingungen nicht erfüllt ist, gibt redux einen Fehler aus. </p></div></div><br><h3 id="bonusnye-voprosy">  Bonusfragen: </h3><br><p>  <strong>Bonusfrage 1.</strong> </p><br><pre> <code class="plaintext hljs">  ? class Todos extends React.Component { getSnapshotBeforeUpdate(prevProps, prevState) { return this.props.list.length - prevProps.list.length; } componentDidUpdate(a, b, c) { console.log(c); } ... } ReactDOM.render(&lt;Todos list={['a','b']} /&gt;, app); setTimeout(() =&gt; ReactDOM.render(&lt;Todos list={['a','b','a','b']} /&gt;, app), 0); a) 0 b) 1 c) 2 d) undefined</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  c) 2 </p><br><p>  <code>getSnapshotBeforeUpdate</code> ist eine selten verwendete Funktion in react, mit der Sie einen Snapshot <code>getSnapshotBeforeUpdate</code> können, der dann an componentDidUpdate übergeben wird.  Diese Methode wird benötigt, um bestimmte Daten vorab zu berechnen, auf deren Grundlage Sie beispielsweise eine Abrufanforderung stellen können. </p></div></div><br><p>  <strong>Bonusfrage 2.</strong> </p><br><pre> <code class="plaintext hljs">       2,5 ? function Input() { const [text, setText] = useState("World!"); useEffect( () =&gt; { let id = setTimeout(() =&gt; { setText("Hello " + text); }, 1000); return () =&gt; { clearTimeout(id); }; }, [text] ); return ( &lt;input value={text} onChange={e =&gt; { setText(e.target.value); }} /&gt; ); } a) "World!" b) "Hello World!" c) "Hello Hello World!" d)   </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  c) "Hallo Hallo Welt!" </p></div></div><br><p>  Dies ist bereits eine Frage der Kenntnis neuer Funktionen in Reaktion, es war nicht in unserem Quiz.  Lassen Sie uns in den Kommentaren versuchen, die Funktionsweise des Codes aus der letzten Frage detailliert zu beschreiben :) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431492/">https://habr.com/ru/post/de431492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431480/index.html">Magento hat eine neue Hauptplattform veröffentlicht - 2.3.0 GA</a></li>
<li><a href="../de431482/index.html">Und du, Yota ...</a></li>
<li><a href="../de431486/index.html">Unsichtbare Fliegen: Eine neue Methode zur Untersuchung des Nervensystems durch Gewebedepigmentierung</a></li>
<li><a href="../de431488/index.html">Klangmodulation</a></li>
<li><a href="../de431490/index.html">Extern - GUI für Golang</a></li>
<li><a href="../de431496/index.html">Wie Technologie speziellen Klassenlehrern hilft</a></li>
<li><a href="../de431498/index.html">WebP wird das Web bald übernehmen, aber es wird nicht lange dauern</a></li>
<li><a href="../de431500/index.html">Datenbanken und Kubernetes (Rückblick und Videobericht)</a></li>
<li><a href="../de431502/index.html">Konferenz für iOS-Entwickler Kolesa Mobile 3.0. Videobericht</a></li>
<li><a href="../de431504/index.html">Phishing - funktioniert. Chronik des Diebstahls des iPhone XS, gefolgt von iCloud-Datendiebstahl</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>