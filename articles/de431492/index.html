<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöé ü§∞üèº üë∏üèæ Reagieren Sie auf dem HolyJs 2018 am HeadHunter-Stand auf das Quiz des Wettbewerbs üë®üèæ‚Äçüíª üëÅ‚Äçüó® üë®‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo. Am 24. und 25. September fand in Moskau eine Konferenz der Front-End-Entwickler von HolyJ https://holyjs-moscow.ru/ statt. Wir kamen mit unsere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reagieren Sie auf dem HolyJs 2018 am HeadHunter-Stand auf das Quiz des Wettbewerbs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/431492/"><p>  Hallo.  Am 24. und 25. September fand in Moskau eine Konferenz der Front-End-Entwickler von HolyJ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://holyjs-moscow.ru/</a> statt.  Wir kamen mit unserem Stand zur Konferenz, an dem wir ein Quiz abhielten.  Es gab ein Hauptquiz - 4 Qualifikationsrunden und 1 Endrunde, in denen die Apple Watch- und Lego-Konstrukteure gespielt wurden.  Und separat haben wir ein Quiz zum Reagieren von Wissen durchgef√ºhrt. </p><br><p>  Unter Cat - Parsing Quiz Aufgaben reagieren.  Die richtigen Optionen werden unter dem Spoiler versteckt, sodass Sie nicht nur die Analyse lesen, sondern auch sich selbst √ºberpr√ºfen k√∂nnen :) </p><br><p><img src="https://habrastorage.org/webt/ot/wn/yq/otwnyqyymtf5t_yedi3aj2-wuau.jpeg" alt="Bild"></p><br><p>  Lass uns gehen! </p><a name="habracut"></a><br><p>  Der Einfachheit halber haben wir die Fragen in Abschnitte unterteilt: </p><br><h3 id="sekciya-1-bazovoe-ponimanie-raboty-thissetstate-i-updating-lifecycle-komponenta">  Abschnitt 1. Grundlegendes Verst√§ndnis der Funktionsweise von this.setState und Aktualisieren des Komponentenlebenszyklus: </h3><br><p>  <strong>Frage 1.</strong> </p><br><pre><code class="plaintext hljs">      react-: 1) SetProps, SetState, ForceUpdate 2) ForceUpdate, SetState 3) ForceUpdate, SetState, Parent (re)render 4) ForceUpdate, SetState, directly call UpdateComponent</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  3) ForceUpdate, SetState, Parent (re) rendern </p></div></div><br><p>  <strong>Frage 2.</strong> </p><br><pre> <code class="plaintext hljs"> ,   this.setState({})  react 1)   ,  updating lifecycle 2)   ,    3) React    "Object cannot be empty" 4)    state  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  1) Die Komponente ist als verschmutzt markiert, der Aktualisierungslebenszyklus wird aufgerufen </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analyse der Fragen 1 und 2</b> <div class="spoiler_text"><p>  Um die Frage zu beantworten, werden wir 2 Teile analysieren: <br>  1) Eigene Komponentenanforderung zum Aktualisieren des Zyklus <br>  2) Anfrage au√üerhalb der Komponente </p><br><p>  Die Komponente selbst hat zwei M√∂glichkeiten, sich selbst zu aktualisieren: <br>  1) this.setState und this.forceUpdate.  In diesem Fall wird die Komponente als verschmutzt markiert und im H√§kchen Reconcilliation wird ein Aktualisierungszyklus gestartet, wenn sie beim Rendern Priorit√§t hat. </p><br><p>  Interessante Tatsache: <code>this.setState({})</code> und <code>this.forceUpdate</code> sind unterschiedlich.  Wenn <code>this.setState({})</code> aufgerufen wird, wird im Gegensatz zu <code>this.forceUpdate</code> die vollst√§ndige Aktualisierungsschleife <code>this.forceUpdate</code> , wenn die Aktualisierungsschleife ohne die Methode shouldComponentUpdate gestartet wird.  Ein Beispiel f√ºr die Arbeit von <code>this.setState({})</code> finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://codesandbox.io/s/m5jz2701l9</a> (wenn Sie im Beispiel setState durch forceUpdate ersetzen, k√∂nnen Sie sehen, wie sich das Verhalten der Komponenten √§ndert). </p><br><p>  2) Wenn das √ºbergeordnete Element der Komponente erneut gerendert wird, gibt es den vDOM-Teil zur√ºck, alle untergeordneten Elemente, die aktualisiert werden m√ºssen, und sie werden auch als vollst√§ndiger Aktualisierungslebenszyklus bezeichnet.  Eine vollst√§ndige Nachz√§hlung des Teilbaums kann vermieden werden, indem shouldComponentUpdate beschrieben oder die Komponente als PureComponent definiert wird. </p></div></div><br><p>  <strong>Frage 3</strong> </p><br><pre> <code class="plaintext hljs">  Component  PureComponent (PC) 1) Component   ,    Pure 2) PC  SCU,  shallowEqual props  state 3) PC    ,    store 4)  PC    shouldComponentUpdate</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  2) PC implementiert SCU, f√ºhrt flache Gleiche Requisiten und Status durch </p><br><p>  Wie bereits erw√§hnt, wird beim (erneuten) Rendern des √ºbergeordneten Elements der gesamte Teilbaum an den aktualisierenden Lebenszyklus gesendet.  Stellen Sie sich vor, Sie haben das Stammelement aktualisiert.  In diesem Fall m√ºssen Sie entsprechend dem Ketteneffekt fast den gesamten Reaktionsbaum aktualisieren.  Um unn√∂tige Aktualisierungen zu optimieren und nicht zu senden, gibt es in Reaktion eine Methode <code>shouldComponentUpdate</code> , mit der Sie true zur√ºckgeben k√∂nnen, wenn die Komponente aktualisiert werden soll, andernfalls false.  Um Vergleiche in der Reaktion zu vereinfachen, k√∂nnen Sie von <code>PureComponent</code> erben, um sofort bereit zu sein, <code>shouldComponentUpdate</code> , das alle Requisiten und <code>shouldComponentUpdate</code> , die in die Komponente <code>shouldComponentUpdate</code> , <code>shouldComponentUpdate</code> von Referenzen (wenn es sich um Objekttypen handelt) oder nach Werten (wenn es sich um <code>shouldComponentUpdate</code> handelt) vergleicht. </p></div></div><br><p>  <strong>Frage 4.</strong> </p><br><pre> <code class="plaintext hljs">this.setState(() =&gt; {}, () =&gt; {}) ‚Äî       setState? 1) set   .    updating 2)       state 3) setState   1 </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  2) Die zweite Funktion wird nach dem Aktualisieren des Status aufgerufen </p><br><p>  Im React-Lifecycle gibt es zwei Methoden: <code>componentDidMount</code> f√ºr die Mounting-Schleife und componentDidUpdate f√ºr die Aktualisierung, wobei Sie nach der Aktualisierung der Komponente eine Logik hinzuf√ºgen k√∂nnen.  Stellen Sie beispielsweise eine http-Anfrage, nehmen Sie einige Stil√§nderungen vor, rufen Sie die Metriken der HTML-Elemente ab und machen Sie (nach Bedingung) setState.  Wenn Sie nach dem √Ñndern bestimmter Felder im Status eine Aktion ausf√ºhren m√∂chten, m√ºssen Sie in der <code>componentDidUpdate</code> Methode entweder einen Vergleich schreiben: </p><br><pre> <code class="plaintext hljs">componentDidUpdate(prevProp, prevState) { if (prevState.foo !== this.state.foo) { // do awesome things here } }</code> </pre> <br><p>  Oder Sie k√∂nnen es mit setState tun: </p><br><pre> <code class="plaintext hljs">setState( // set new foo {foo: 'baz'}, () =&gt; { // do awesome things here } );</code> </pre> <br><p>  Jeder Ansatz hat Vor- und Nachteile (wenn Sie beispielsweise setState an mehreren Stellen √§ndern, ist es m√∂glicherweise bequemer, eine Bedingung einmal zu schreiben). </p></div></div><br><p>  <strong>Frage 5.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { render() { console.log('render'); return &lt;div /&gt; } } function Test() { return &lt;A foo='bar' onClick={() =&gt; console.log('foo')} /&gt; } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;Test /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;Test /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  2) 2 </p></div></div><br><p>  <strong>Frage 6.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { render() { console.log('render'); return &lt;div /&gt; } } function Test() { return &lt;A foo='bar' /&gt; } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;Test /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;Test /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  1) 1 </p></div></div><br><p>  <strong>Frage 7.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { componentDidMount() { console.log('render'); } render() { return &lt;div /&gt; } } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;A /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;A /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  1) 1 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analyse der Fragen 5-7</b> <div class="spoiler_text"><p>  Fragen 5‚Äì7 sind f√ºr dasselbe erforderlich - um das Verst√§ndnis der Arbeit von <code>PureComponent</code> und die Aktualisierung der Komponenten bei der √úbertragung von Requisiten zu √ºberpr√ºfen.  Wenn wir innerhalb der Render-Methode einen jsx-R√ºckruf √ºbergeben, der dies direkt in der Render-Funktion beschreibt: </p><br><pre> <code class="plaintext hljs">render () { return &lt;Button onClick={() =&gt; {}} /&gt;; }</code> </pre> <br><p>  Dann aktualisiert jedes Rendering des √ºbergeordneten Elements den angegebenen Klick-Handler.  Dies liegt daran, dass bei jedem Rendern eine neue Funktion mit einem eindeutigen Link erstellt wird. Im Vergleich zu PureComponent werden die neuen Requisiten nicht den alten entsprechen und Sie m√ºssen die Komponente aktualisieren.  Wenn alle Pr√ºfungen bestanden sind und shouldComponentUpdate false zur√ºckgibt, erfolgt die Aktualisierung nicht. </p></div></div><br><h3 id="sekciya-2-keys-in-react">  Abschnitt 2. Schl√ºssel in Reaktion </h3><br><p>  Eine detaillierte Analyse der hier ver√∂ffentlichten Schl√ºssel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/company/hh/blog/352150/</a> </p><br><p>  <strong>Frage 1.</strong> </p><br><pre> <code class="plaintext hljs">    key,      ? 1)         key 2)    updating lifecycle 3)   key  4)    reconciliation</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  1) L√∂schen Sie die vorherige Instanz und mounten Sie die neue, wenn Sie den Schl√ºssel √§ndern </p><br><p>  Ohne Schl√ºssel wird durch Reagieren die Liste der Elemente paarweise von oben nach unten verglichen.  Wenn wir den Schl√ºssel verwenden, erfolgt der Vergleich mit dem entsprechenden Schl√ºssel.  Wenn ein neuer Schl√ºssel angezeigt wurde, wird eine solche Komponente mit niemandem verglichen und sofort von Grund auf neu erstellt. <br>  Sie k√∂nnen diese Methode auch dann verwenden, wenn wir 1 Element haben: Wir k√∂nnen <code>&lt;A key="1" /&gt;</code> , im n√§chsten Rendering geben wir <code>&lt;A key="2" /&gt;</code> und in diesem Fall wird durch Reagieren <code>&lt;A key="1" /&gt;</code> gel√∂scht. <code>&lt;A key="1" /&gt;</code> und erstellen Sie von Grund auf <code>&lt;A key="2" /&gt;</code> . </p></div></div><br><p>  <strong>Frage 2.</strong> </p><br><pre> <code class="plaintext hljs">      this.prop.key? 1)  2)  3)   static getKey</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  2) Nein </p><br><p>  Die Komponente kann den Schl√ºssel von ihren untergeordneten Elementen lernen, die ihr als Requisite √ºbergeben wurden, kann jedoch nichts √ºber ihren Schl√ºssel lernen. </p></div></div><br><p>  <strong>Frage 3.</strong> </p><br><pre> <code class="plaintext hljs">      render: class A extends React.PureComponent { componentDidMount() { console.log('render'); } render() { return &lt;div /&gt; } } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;A key='1' /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;A /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  2) 2 </p><br><p>  Beim √Ñndern des Schl√ºssels wird die Komponente neu erstellt, sodass das Rendern zweimal angezeigt wird. </p></div></div><br><h3 id="sekciya-3-voprosy-po-jsx">  Abschnitt 3. Fragen zu jsx </h3><br><p>  <strong>Frage 1.</strong> </p><br><pre> <code class="plaintext hljs">  .           1)    prop / context 2)        3)  setParentProps 4)  static getParentRef</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  1) R√ºckruf in Form von Requisite / Kontext <br>  2) Entfernen Sie die Ebene des Modells und arbeiten Sie sie durch </p><br><p>  Es gibt zwei richtige Antworten.  Wenn Sie einen von ihnen in einem Quiz ausw√§hlen, erhalten Sie Punkte.  Diese Frage dient der Kenntnis des Datenflusses.  Daten von oben nach unten werden in Form von Requisiten oder Kontext verteilt. Sie k√∂nnen einen R√ºckruf enthalten, den die folgende Komponente aufrufen kann, um den Status des Systems zu beeinflussen. <br>  Eine andere Methode, die Modellentfernung, Kontext und Requisite kombiniert, ist beispielsweise die React-Redux-Bindung. <br>  Diese Bibliothek verwendet ein Modell aus React (Redux).  Legt redux.store in Provider fest, wodurch der Speicher tats√§chlich im Kontext festgelegt wird.  Anschlie√üend verwendet der Entwickler die HOC-Verbindung, die in den Kontext eingeht, √Ñnderungen zum Speichern (store.subscribe) abonniert und bei √Ñnderungen des Speichers die Funktion <code>mapStateToProps</code> .  Wenn sich die Daten ge√§ndert haben, werden sie in Requisiten f√ºr das umschlossene Objekt festgelegt. <br>  Gleichzeitig k√∂nnen Sie mit <code>mapDispatchToProps</code> angeben, wobei der Entwickler die actionCreators angibt, die an die Komponente √ºbergeben werden m√ºssen.  Wir wiederum empfangen sie von au√üen (ohne Kontext), binden die <code>actionCreators</code> an den Store (wir verpacken sie in store.dispatch) und √ºbergeben sie als Requisiten an die verpackte Komponente. </p></div></div><br><p>  <strong>Frage 2.</strong> </p><br><pre> <code class="plaintext hljs">  props   jsx?     1)   2)   children</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  1) In jedem </p><br><p>  Sie k√∂nnen zu jedem √ºbertragen.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">&lt;Button icon={&lt;Icon kind='warning'/&gt;}&gt;&lt;/Button&gt;</code> </pre> <br><p>  Zeichnet eine Schaltfl√§che mit einem Symbol.  Dieser Ansatz ist sehr praktisch, um der Komponente das Recht zu geben, die Position verschiedener Elemente relativ zueinander zu steuern, anstatt eine untergeordnete Requisite zu sortieren. </p></div></div><br><h3 id="sekciya-4-prodvinutoe-ponimanie-setstate">  Abschnitt 4. Erweitertes Verst√§ndnis von setState </h3><br><p>  Hier sind 3 stark verwandte Fragen: </p><br><p>  <strong>Frage 1.</strong> </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; ... this.setState({a: 'b'}); this.setState({a: this.state.a + 1}) this.state? 1) {a: 'a1'} 2) {a: 'b1'} 3)   4) {a: 'a'}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  3) Nicht gen√ºgend Daten </p></div></div><br><p>  <strong>Frage 2.</strong> </p><br><pre> <code class="plaintext hljs">this.state={a: 'a'} ... this.setState({a: 'b'}) this.setState(state =&gt; ({a: state.a + 1})) this.state? 1) {a: 'a1'} 2) {a: 'b1'} 3)   4) {a: 'ab1'}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  2) {a: 'b1'} </p></div></div><br><p>  <strong>Frage 3.</strong> </p><br><pre> <code class="plaintext hljs">   2 setState  componentDidUpdate  updating lifecycle   1) 1 2) 2 3) 3 4)  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  1) 1 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analyse der Fragen 1-3</b> <div class="spoiler_text"><p>  Die gesamte Arbeit von setState wird hier vollst√§ndig beschrieben: <br>  1) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://reactjs.org/docs/react-component.html#setstate</a> <br>  2) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973</a> </p><br><p>  Tatsache ist, dass setState nicht synchron erfolgt. <br>  Und wenn setState mehrere Aufrufe hintereinander hat, h√§ngt die Ausf√ºhrung von setState davon ab, ob wir uns innerhalb der React-Lifecycle-Methode, der Handlerfunktion des React-Ereignisses (onChange, onClick) befinden oder nicht. <br>  In React-Handlern arbeitet setState stapelweise (√Ñnderungen werden erst dann ausgef√ºhrt, wenn die benutzerdefinierten Funktionen im Aufrufstapel beendet sind und wir auf die Funktionen zugreifen, die unsere Ereignishandler- und Lebenszyklusmethoden aufgerufen haben).  Sie rollen nacheinander. Wenn wir uns also im React-Handler befinden, erhalten wir: </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; // a: 'a' ... this.state.a // a: 'a' this.setState({a: 'b'}); // a: 'b' +   .       this.state.a // a: 'a' this.setState({a: this.state.a + 1}) // a: 'a1'</code> </pre> <br><p>  da die √Ñnderungen aufgetreten sind batchevo. <br>  Aber gleichzeitig, wenn setState au√üerhalb von React-Handlern aufgerufen wurde: </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; // a: 'a' ... this.state.a // a: 'a' this.setState({a: 'b'}); // a: 'b' +     this.state.a // a: 'b' this.setState({a: this.state.a + 1}) // a: 'b1' +    </code> </pre> <br><p>  Da in diesem Fall die √Ñnderungen separat gew√ºrfelt werden. </p></div></div><br><h3 id="sekciya-5-redux">  Abschnitt 5. Redux </h3><br><p>  <strong>Frage 1.</strong> </p><br><pre> <code class="plaintext hljs">    action,  () =&gt; {} ? 1) .  action      type 2) ,   action      type 3) ,    middleware   action 4) ,       dispatch</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  3) Ja, Sie m√ºssen f√ºr eine solche Aktion eine benutzerdefinierte Middleware definieren </p><br><p>  Nehmen Sie Redux-Thunk als einfachstes Beispiel.  Alle Middleware ist ein kleiner Codeblock: <br>  <a href="">https://github.com/reduxjs/redux-thunk/blob/master/src/index.js#L2-L9</a> </p><br><pre> <code class="plaintext hljs">return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; { if (typeof action === 'function') { return action(dispatch, getState, extraArgument); } return next(action); };</code> </pre> <br><p>  Wie funktioniert Middleware? <br>  Sie erhalten die Kontrolle, bevor die Aktion im Gesch√§ft eintrifft.  Daher wird eine √ºberschriebene Aktion zuerst die Middleware-Kette durchlaufen. <br>  Jede Middleware akzeptiert eine Speicherinstanz, die n√§chste Methode, mit der Sie die Aktion weiterleiten k√∂nnen, und die Aktion selbst. <br>  Wenn Middleware benutzerdefinierte Aktionen wie Redux-Thunk verarbeitet, leitet die Aktion, wenn sie eine Funktion ist, die Aktion nicht weiter, sondern "√ºbert√∂nt" sie, sondern ruft die Aktion mit den dort √ºbergebenen Methoden dispatch und getState auf. <br>  Was w√ºrde passieren, wenn Redux-Thunk als n√§chstes eine Aktion ausf√ºhren w√ºrde, was eine Funktion ist? <br>  Speichern Sie vor dem Aufrufen von Reduzierern die Art der Aktion.  Es muss folgende Bedingungen erf√ºllen: <br>  1) Es muss ein Objekt sein <br>  2) Es sollte ein Typfeld haben <br>  3) Das Typfeld muss vom Typ string sein </p><br><p>  Wenn eine der Bedingungen nicht erf√ºllt ist, gibt redux einen Fehler aus. </p></div></div><br><h3 id="bonusnye-voprosy">  Bonusfragen: </h3><br><p>  <strong>Bonusfrage 1.</strong> </p><br><pre> <code class="plaintext hljs">  ? class Todos extends React.Component { getSnapshotBeforeUpdate(prevProps, prevState) { return this.props.list.length - prevProps.list.length; } componentDidUpdate(a, b, c) { console.log(c); } ... } ReactDOM.render(&lt;Todos list={['a','b']} /&gt;, app); setTimeout(() =&gt; ReactDOM.render(&lt;Todos list={['a','b','a','b']} /&gt;, app), 0); a) 0 b) 1 c) 2 d) undefined</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Antwort und Analyse</b> <div class="spoiler_text"><p>  c) 2 </p><br><p>  <code>getSnapshotBeforeUpdate</code> ist eine selten verwendete Funktion in react, mit der Sie einen Snapshot <code>getSnapshotBeforeUpdate</code> k√∂nnen, der dann an componentDidUpdate √ºbergeben wird.  Diese Methode wird ben√∂tigt, um bestimmte Daten vorab zu berechnen, auf deren Grundlage Sie beispielsweise eine Abrufanforderung stellen k√∂nnen. </p></div></div><br><p>  <strong>Bonusfrage 2.</strong> </p><br><pre> <code class="plaintext hljs">       2,5 ? function Input() { const [text, setText] = useState("World!"); useEffect( () =&gt; { let id = setTimeout(() =&gt; { setText("Hello " + text); }, 1000); return () =&gt; { clearTimeout(id); }; }, [text] ); return ( &lt;input value={text} onChange={e =&gt; { setText(e.target.value); }} /&gt; ); } a) "World!" b) "Hello World!" c) "Hello Hello World!" d)   </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text"><p>  c) "Hallo Hallo Welt!" </p></div></div><br><p>  Dies ist bereits eine Frage der Kenntnis neuer Funktionen in Reaktion, es war nicht in unserem Quiz.  Lassen Sie uns in den Kommentaren versuchen, die Funktionsweise des Codes aus der letzten Frage detailliert zu beschreiben :) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431492/">https://habr.com/ru/post/de431492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431480/index.html">Magento hat eine neue Hauptplattform ver√∂ffentlicht - 2.3.0 GA</a></li>
<li><a href="../de431482/index.html">Und du, Yota ...</a></li>
<li><a href="../de431486/index.html">Unsichtbare Fliegen: Eine neue Methode zur Untersuchung des Nervensystems durch Gewebedepigmentierung</a></li>
<li><a href="../de431488/index.html">Klangmodulation</a></li>
<li><a href="../de431490/index.html">Extern - GUI f√ºr Golang</a></li>
<li><a href="../de431496/index.html">Wie Technologie speziellen Klassenlehrern hilft</a></li>
<li><a href="../de431498/index.html">WebP wird das Web bald √ºbernehmen, aber es wird nicht lange dauern</a></li>
<li><a href="../de431500/index.html">Datenbanken und Kubernetes (R√ºckblick und Videobericht)</a></li>
<li><a href="../de431502/index.html">Konferenz f√ºr iOS-Entwickler Kolesa Mobile 3.0. Videobericht</a></li>
<li><a href="../de431504/index.html">Phishing - funktioniert. Chronik des Diebstahls des iPhone XS, gefolgt von iCloud-Datendiebstahl</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>