<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚 🏆 🍚 بناء أدوات في مشاريع التعلم الآلي ، لمحة عامة 🥠 👩‍🌾 🛌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="كنت أتساءل عن بنية / سير عمل مشروع التعلم / علم البيانات وكنت أقرأ آراء مختلفة حول هذا الموضوع. وعندما يبدأ الناس في الحديث عن سير العمل ، فإنهم يريدو...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>بناء أدوات في مشاريع التعلم الآلي ، لمحة عامة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451962/" style=";text-align:right;direction:rtl"> كنت أتساءل عن بنية / سير عمل مشروع التعلم / علم البيانات وكنت أقرأ آراء مختلفة حول هذا الموضوع.  وعندما يبدأ الناس في الحديث عن سير العمل ، فإنهم يريدون أن تكون سير عملهم قابلة للتكرار.  هناك الكثير من المشاركات التي تشير إلى استخدام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جعل</a> للحفاظ على سير العمل استنساخه.  على الرغم من <code>make</code> مستقرًا جدًا ويستخدم على نطاق واسع ، إلا أنني شخصياً أحب الحلول عبر الأنظمة الأساسية.  إنه عام 2019 ، وليس عام 1977. يمكن للمرء أن يجادل بأن تكوين نفسه عبارة عن منصة مشتركة ، ولكن في الواقع ستواجه بعض المشكلات وستقضي وقتًا في إصلاح الأداة بدلاً من القيام بالعمل الفعلي.  لذلك قررت إلقاء نظرة على المكان والتحقق من الأدوات الأخرى المتاحة.  نعم ، قررت قضاء بعض الوقت على الأدوات. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/aff/fbf/656/afffbf6566a6e67ea6427d28d76d7eea.png" alt="صورة"></div><br>  هذا المنشور هو دعوة للحوار أكثر من كونه تعليميًا.  ربما الحل الخاص بك هو الكمال.  إذا كان الأمر كذلك ، فسيكون من المثير للاهتمام معرفة ذلك. <br><br>  في هذا المنشور ، سأستخدم مشروع Python صغيرًا وسأقوم بمهام الأتمتة نفسها مع أنظمة مختلفة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">CMake</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PyBuilder</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">pynt</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجبان</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">DOIT</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لويجي</a> </li></ul><br>  سيكون هناك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جدول مقارنة</a> في نهاية المنشور. <br><a name="habracut"></a><br>  تُعرف معظم الأدوات التي سأنظر إليها باسم <em>برامج التشغيل الآلي</em> <em>للبناء</em> أو <em>أنظمة الإنشاء</em> .  هناك عدد لا يحصى من منهم في جميع النكهات والأحجام والتعقيدات المختلفة.  الفكرة هي نفسها: يحدد المطور قواعد لإنتاج بعض النتائج بطريقة آلية ومتسقة.  على سبيل المثال ، قد تكون النتيجة صورة ذات رسم بياني.  من أجل جعل هذه الصورة يحتاج المرء إلى تنزيل البيانات ، وتنظيف البيانات والقيام ببعض التلاعب في البيانات (مثال تقليدي ، حقًا).  يمكنك أن تبدأ مع اثنين من البرامج النصية قذيفة التي ستقوم بهذه المهمة.  بمجرد عودتك إلى المشروع بعد عام ، سيكون من الصعب تذكر جميع الخطوات وترتيبها الذي تحتاجه لاتخاذ هذه الصورة.  الحل الواضح هو توثيق جميع الخطوات.  خبر جيد!  تتيح لك أنظمة Build توثيق الخطوات في شكل برنامج كمبيوتر.  تشبه بعض أنظمة الإنشاء نصوص الصدفة ، ولكن مع أجراس وصفارات إضافية. <br><br>  أساس هذا المنشور هو سلسلة من المشاركات التي كتبها <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Mateusz Bednarski</a> على سير العمل الآلي لمشروع التعلم الآلي.  يشرح Mateusz وجهات نظره ويوفر وصفات لاستخدامها.  أنا أشجعك على الذهاب والتحقق من مشاركاته أولا.  سأستخدم رمزه في الغالب ، ولكن مع أنظمة بناء مختلفة. <br><br>  إذا كنت ترغب في معرفة المزيد حول "إنشاء" ، فاتباع ذلك هو إشارات لبضع منشورات.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بروك كينيدي</a> يعطي لمحة عامة رفيعة المستوى في 5 خطوات سهلة لجعل مشروع علوم البيانات الخاصة بك مستنسخة.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">يقدم Zachary Jones</a> مزيدًا من التفاصيل حول بناء الجملة والقدرات إلى جانب الروابط إلى المشاركات الأخرى.  يكتب <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">David Stevens</a> منشورًا شديد الضجيج عن السبب الذي يجعلك مضطرًا تمامًا إلى البدء في استخدام <code>make</code> مكالمات على الفور.  إنه يقدم أمثلة لطيفة تقارن بين <i>الطريقة القديمة والطريقة</i> <i>الجديدة</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">صموئيل لامبا</a> ، من ناحية أخرى ، يكتب عن سبب استخدام <code>make</code> فكرة سيئة. <br><br>  اختياري لأنظمة البناء غير شامل ولا متحيز.  إذا كنت تريد إنشاء قائمتك ، فقد تكون <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ويكيبيديا</a> نقطة انطلاق جيدة.  كما ذكر أعلاه ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">سأغطي</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">CMake</a> و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PyBuilder</a> و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">pynt</a> و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Paver</a> و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">doit</a> و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Luigi</a> .  معظم الأدوات في هذه القائمة تعتمد على الثعبان ومن المنطقي أن المشروع في بيثون.  لن يغطي هذا المنشور كيفية تثبيت الأدوات.  أفترض أنك ماهر في بيثون. <br><br>  أنا مهتم في الغالب باختبار هذه الوظيفة: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تحديد اثنين من الأهداف مع التبعيات.  أريد أن أرى كيف أفعل ذلك وكم هو سهل. </li><li style=";text-align:right;direction:rtl">  التحقق من إمكانية إنشاء تصاعدية.  هذا يعني أن نظام الإنشاء لن يعيد بناء ما لم يتم تغييره منذ التشغيل الأخير ، أي أنك لست بحاجة إلى إعادة تنزيل بياناتك الأولية.  شيء آخر سأبحث عنه هو إنشاءات تدريجية عندما تتغير التبعية.  تخيل أن لدينا رسم بياني للتبعيات <code>A -&gt; B -&gt; C</code>  هل سيتم إعادة بناء الهدف <code>C</code> إذا تغيرت <code>B</code> ؟  إذا؟ </li><li style=";text-align:right;direction:rtl">  التحقق من تشغيل إعادة الإنشاء إذا تم تغيير شفرة المصدر ، أي أننا نغير معلمة الرسم البياني الذي تم إنشاؤه ، في المرة القادمة التي يجب أن نبني فيها الصورة. </li><li style=";text-align:right;direction:rtl">  التحقق من طرق تنظيف القطع الأثرية للبناء ، أي إزالة الملفات التي تم إنشاؤها أثناء الإنشاء والعودة إلى الشفرة المصدرية النظيفة. </li></ol><br>  لن أستخدم جميع أهداف الإنشاء من موقع Mateusz ، فقط ثلاثة منها لتوضيح المبادئ. <br><br>  كل رمز متاح على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جيثب</a> . <br><br><h2 style=";text-align:right;direction:rtl"><a name="CMake"></a>  CMake </h2><br>  CMake عبارة عن مولد سيناريو بناء ، والذي يولد ملفات الإدخال لأنظمة البناء المختلفة.  واسم لتقف على جعل منصة عبر.  CMake هي أداة هندسة البرمجيات.  هو الشاغل الرئيسي هو بناء الملفات التنفيذية والمكتبات.  يعرف CMake كيفية إنشاء <i>أهداف</i> من التعليمات البرمجية المصدر باللغات المدعومة.  يتم تنفيذ CMake في خطوتين: التكوين والجيل.  أثناء التهيئة ، يمكن تكوين البنية المستقبلية وفقًا لاحتياجاتك.  على سبيل المثال ، يتم توفير المتغيرات التي يوفرها المستخدم أثناء هذه الخطوة.  عادة ما يكون التوليد مباشرًا وينتج ملفات (ملفات) يمكن أن تعمل عليها الأنظمة.  مع CMake ، لا يزال بإمكانك استخدام <code>make</code> ، ولكن بدلاً من كتابة makefile مباشرةً ، يمكنك كتابة ملف CMake ، مما يؤدي إلى إنشاء ملف التعريف لك. <br><br>  مفهوم آخر مهم هو أن CMake تشجع <i>يبني خارج المصدر</i> .  يبني خارج المصدر مصدر التعليمات البرمجية بعيدا عن أي القطع الأثرية التي تنتجها.  هذا له معنى كبير بالنسبة إلى الملفات التنفيذية حيث قد يتم تجميع قاعدة بيانات مصدر واحد تحت بنيات وحدة المعالجة المركزية وأنظمة التشغيل المختلفة.  ومع ذلك ، قد يتعارض هذا النهج مع الطريقة التي يعمل بها كثير من علماء البيانات.  يبدو لي أن مجتمع علم البيانات يميل إلى الحصول على اقتران عالي للبيانات والرمز والنتائج. <br><br>  دعونا نرى ما نحتاجه لتحقيق أهدافنا مع CMake.  هناك احتمالان لتحديد الأشياء المخصصة في CMake: الأهداف المخصصة والأوامر المخصصة.  لسوء الحظ ، سوف نحتاج إلى استخدام كليهما ، مما يؤدي إلى مزيد من الكتابة مقارنة بفانيلا makefile.  يعتبر الهدف المخصص قديمًا دائمًا ، أي إذا كان هناك هدف لتنزيل البيانات الخام ، فستعيد CMake تنزيله دائمًا.  يتيح الجمع بين الأمر المخصص والهدف المخصص الاحتفاظ بالأهداف محدثة. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لمشروعنا</a> سنقوم بإنشاء ملف يسمى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">CMakeLists.txt</a> ووضعه في جذر المشروع.  دعنا تحقق من المحتوى: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">cmake_minimum_required</span></span>(VERSION <span class="hljs-number"><span class="hljs-number">3.14</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> FATAL_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(Cmake_in_ml VERSION <span class="hljs-number"><span class="hljs-number">0.1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LANGUAGES NONE)</code> </pre><br>  هذا الجزء أساسي.  يحدد السطر الثاني اسم المشروع والإصدار الخاص بك ، ويحدد أننا لن نستخدم أي دعم لغوي مدمج (شرط أن نسمي بيثون البرامج النصية). <br><br>  سيكون هدفنا الأول تنزيل مجموعة بيانات IRIS: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(IRIS_URL <span class="hljs-string"><span class="hljs-string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span></span> CACHE <span class="hljs-keyword"><span class="hljs-keyword">STRING</span></span> <span class="hljs-string"><span class="hljs-string">"URL to the IRIS data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_DIR <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/raw) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_FILE <span class="hljs-variable"><span class="hljs-variable">${IRIS_DIR}</span></span>/iris.csv) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Downloading IRIS."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/download.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_URL}</span></span> <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Done. Checkout ${IRIS_FILE}."</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(rawdata ALL DEPENDS <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span>)</code> </pre><br>  يحدد السطر الأول المعلمة <code>IRIS_URL</code> ، والتي تتعرض للمستخدم أثناء خطوة التكوين.  إذا كنت تستخدم CMake GUI ، يمكنك تعيين هذا المتغير من خلال واجهة المستخدم الرسومية: <br><br><img src="https://habrastorage.org/webt/oo/za/pj/oozapjujvjg_q86ndg6r7c5u36a.png"><br><br>  بعد ذلك ، نحدد المتغيرات مع موقع تنزيل مجموعة بيانات IRIS.  ثم نضيف أمرًا مخصصًا ، والذي سينتج <code>IRIS_FILE</code> أثناء إخراجه.  في النهاية ، نقوم بتحديد قاعدة بيانات هدف مستهدفة مخصصة تعتمد على <code>IRIS_FILE</code> مما يعني أنه من أجل بناء <code>rawdata</code> <code>IRIS_FILE</code> يجب بناء <code>rawdata</code> .  يشير الخيار <code>ALL</code> للهدف المخصص إلى أن <code>rawdata</code> سيكون أحد الأهداف الافتراضية <code>rawdata</code> .  لاحظ أنني أستخدم <code>CMAKE_CURRENT_SOURCE_DIR</code> أجل الاحتفاظ بالبيانات التي تم تنزيلها في المجلد المصدر وليس في مجلد <code>CMAKE_CURRENT_SOURCE_DIR</code> .  هذا فقط لجعله نفس ماتيوس. <br><br>  حسنا ، دعنا نرى كيف يمكننا استخدامها.  أقوم حاليًا بتشغيله على Windows باستخدام برنامج التحويل البرمجي MinGW.  قد تحتاج إلى ضبط إعداد المولد حسب احتياجاتك (قم بتشغيل <code>cmake --help</code> للاطلاع على قائمة المولدات المتاحة).  أطلق النار على المحطة وانتقل إلى المجلد الأصل للكود المصدري ، ثم: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">mkdir overcome-the-chaos-build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> overcome-the-chaos-build cmake -G <span class="hljs-string"><span class="hljs-string">"MinGW Makefiles"</span></span> ../overcome-the-chaos</code> </pre><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">نتيجة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  - تكوين القيام به <br>  - توليد القيام به <br>  - تمت كتابة ملفات البناء إلى: C: / home / مساحة العمل / التغلب على الفوضى <br></div></div><br>  مع CMake الحديثة يمكننا بناء المشروع مباشرة من CMake.  سوف يستدعي هذا الأمر <code>build all</code> command: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">cmake --build .</code> </pre><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">نتيجة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  مسح تبعيات الهدف rawdata <br>  [100 ٪] بنيت الهدف البيانات الأولية <br></div></div><br>  يمكننا أيضًا عرض قائمة الأهداف المتاحة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">cmake --build . --target <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  ويمكننا إزالة الملف الذي تم تنزيله عن طريق: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">cmake --build . --target clean</code> </pre><br>  نرى أننا لسنا بحاجة إلى إنشاء الهدف النظيف يدويًا. <br><br>  الآن دعنا ننتقل إلى الهدف التالي - بيانات IRIS التي تم تجهيزها مسبقًا.  يقوم Mateusz بإنشاء ملفين من وظيفة واحدة: <code>processed.pickle</code> and <code>processed.xlsx</code> .  يمكنك أن ترى كيف يختفي بتنظيف ملف Excel هذا باستخدام <code>rm</code> مع wildcard.  أعتقد أن هذا ليس مقاربة جيدة للغاية.  في CMake ، لدينا خياران لكيفية التعامل معها.  الخيار الأول هو استخدام خاصية الدليل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ADDITIONAL_MAKE_CLEAN_FILES</a> .  الكود سيكون: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(PROCESSED_FILE <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/processed/processed.pickle) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Additional files to clean set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx )</span></span></code> </pre><br>  الخيار الثاني هو تحديد قائمة من الملفات كإخراج أمر مخصص: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(APPEND PROCESSED_FILE <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.pickle"</span></span> <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> data/processed/processed.pickle --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> src/data/preprocess.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>)</code> </pre><br>  لاحظ أنه في هذه الحالة قمت بإنشاء القائمة ، لكنني لم استخدمها داخل الأمر المخصص.  لا أعرف طريقة للإشارة إلى وسيطات الإخراج الخاصة بالأمر المخصص بداخلها. <br><br>  شيء آخر مثير للاهتمام أن نلاحظه هو استخدام <code>depends</code> في هذا الأمر المخصص.  لقد قمنا بتعيين التبعية ليس فقط من هدف مخصص ، بل إنه ناتج وكذلك سيناريو python.  إذا لم نقم بإضافة التبعية إلى <code>IRIS_FILE</code> ، فلن يؤدي تعديل <code>iris.csv</code> يدويًا إلى إعادة إنشاء هدف <code>preprocess</code> .  حسنًا ، يجب عدم تعديل الملفات في دليل الإنشاء يدويًا في المقام الأول.  فقط نعلمك.  مزيد من التفاصيل في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مشاركة سام الخميسفيلد</a> .  هناك حاجة إلى الاعتماد على البرنامج النصي بيثون لإعادة بناء الهدف إذا تغير البرنامج النصي بيثون. <br><br>  وأخيرا الهدف الثالث: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(EXPLORATORY_IMG <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/reports/figures/exploratory.png) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/visualization/exploratory.py <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> src/visualization/exploratory.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(exploratory DEPENDS <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span>)</code> </pre><br>  هذا الهدف هو في الأساس نفس الهدف الثاني. <br><br>  أن يختتم.  CMake يبدو فوضوي وأكثر صعوبة من جعل.  في الواقع ، ينتقد الكثير من الناس CMake لأنه بناء جملة.  في تجربتي ، سيأتي الفهم ومن الممكن تمامًا تفهم ملفات CMake المعقدة للغاية. <br><br>  ستظل تقوم بالكثير من الإلتصاق بنفسك حيث ستحتاج إلى تمرير المتغيرات الصحيحة.  لا أرى طريقة سهلة للإشارة إلى إخراج أمر مخصص واحد في أمر آخر.  يبدو أنه من الممكن القيام بذلك عبر أهداف مخصصة. <br><br><h2 style=";text-align:right;direction:rtl"><a name="PyBuilder"></a>  PyBuilder </h2><br>  جزء PyBuilder قصير جدًا.  لقد استخدمت Python 3.7 في مشروعي ولا يدعم الإصدار الحالي من PyBuilder 0.11.17.  الحل المقترح هو استخدام نسخة التطوير.  ومع ذلك ، يحد هذا الإصدار إلى النقطة v9.  النقطة هي v19.3 اعتبارا من وقت الكتابة.  المشكله.  بعد العبث بها قليلاً ، لم ينجح الأمر بالنسبة لي على الإطلاق.  كان تقييم PyBuilder قصير الأجل. <br><br><h2 style=";text-align:right;direction:rtl"><a name="pynt"></a>  pynt </h2><br>  Pynt يعتمد على python ، مما يعني أنه يمكننا استخدام وظائف python مباشرة.  ليس من الضروري لفهم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بنقرة</a> وتوفير واجهة سطر الأوامر.  ومع ذلك ، pynt قادر أيضًا على تنفيذ أوامر shell.  سأستخدم وظائف الثعبان. <br><br>  وترد أوامر البناء في ملف <code>build.py</code> .  يتم إنشاء الأهداف / المهام باستخدام أدوات تزيين الوظائف.  يتم توفير تبعيات المهام من خلال نفس الديكور. <br><br>  بما أنني أرغب في استخدام وظائف python أحتاج إلى استيرادها في البرنامج النصي للبناء.  Pynt لا يتضمن الدليل الحالي كنص بيثون ، لذلك اكتب smth مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  لن تعمل.  يتعين علينا القيام به: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys sys.path.append(os.path.join(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'.'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  كان ملف <code>build.py</code> الأولي الخاص بي مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import os import sys sys.path.append(os.path.join(os.path.dirname(__file__), '.')) from pynt import task from path import Path import glob from src.data.download import pydownload_file from src.data.preprocess import pypreprocess iris_file = 'data/raw/iris.csv' processed_file = 'data/processed/processed.pickle' @task() def rawdata(): '''Download IRIS dataset''' pydownload_file('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', iris_file) @task() def clean(): '''Clean all build artifacts''' patterns = ['data/raw/*.csv', 'data/processed/*.pickle', 'data/processed/*.xlsx', 'reports/figures/*.png'] for pat in patterns: for fl in glob.glob(pat): Path(fl).remove() @task(rawdata) def preprocess(): '''Preprocess IRIS dataset''' pypreprocess(iris_file, processed_file, 'data/processed/processed.xlsx')</span></span></code> </pre><br>  والهدف <code>preprocess</code> لم تنجح.  كان يشكو باستمرار من الحجج المدخلات من وظيفة <code>pypreprocess</code> .  يبدو أن Pynt لا يتعامل مع وسيطات الوظيفة الاختيارية جيدًا.  اضطررت لإزالة الحجة لجعل ملف اكسل.  ضع ذلك في الاعتبار إذا كان للمشروع وظائف مع وسائط اختيارية. <br><br>  يمكننا تشغيل pynt من مجلد المشروع وسرد جميع الأهداف المتاحة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">pynt -l</code> </pre><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">نتيجة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">Tasks <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> build file build.py: clean Clean all build artifacts exploratory Make an image with pairwise distribution preprocess Preprocess IRIS dataset rawdata Download IRIS dataset Powered by pynt 0.8.2 - A Lightweight Python Build Tool.</code> </pre><br></div></div><br>  لنجعل التوزيع الزوجي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">pynt exploratory</code> </pre><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">نتيجة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] Downloading from https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data to data/raw/iris.csv [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] Preprocessing data [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ] Plotting pairwise distribution... [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ]</code> </pre><br></div></div><br>  إذا قمنا الآن بتشغيل نفس الأمر مرة أخرى (أي <code>pynt exploratory</code> ) ، فستكون هناك عملية إعادة بناء كاملة.  لم يتعقب بينت أن لا شيء قد تغير. <br><br><h2 style=";text-align:right;direction:rtl"><a name="Paver"></a>  الجبان </h2><br>  رصف يبدو بالضبط تقريبا كما Pynt.  الأمر مختلف قليلاً في طريقة واحدة تحدد التبعيات بين الأهداف (ديكور آخر <code>@needs</code> ).  يقوم Paver بإعادة الإنشاء بالكامل في كل مرة ولا يلعب بشكل جيد مع الوظائف التي تحتوي على وسائط اختيارية.  تم العثور على تعليمات البناء في ملف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">pavement.py</a> . <br><br><h2 style=";text-align:right;direction:rtl"><a name="doit"></a>  DOIT </h2><br>  يبدو Doit وكأنه محاولة لإنشاء أداة أتمتة بناء حقيقية في بيثون.  يمكنه تنفيذ أوامر python code و shell.  يبدو واعدا جدا.  ما يبدو أنه مفقود (في سياق أهدافنا المحددة) هو القدرة على التعامل مع التبعيات بين الأهداف.  دعنا نقول أننا نريد إنشاء خط أنابيب صغير حيث يتم استخدام إخراج الهدف A كمدخل للهدف B. ودعونا نقول إننا نستخدم الملفات <code>outA</code> ، لذلك الهدف A إنشاء ملف يسمى <code>outA</code> . <br><br><img src="https://habrastorage.org/webt/xh/te/ol/xhteolpanywbjxanltb8uxdsoly.png"><br><br>  من أجل إنشاء خط أنابيب من هذا القبيل ، سنحتاج إلى تحديد <code>outA</code> file مرتين في الهدف A (كنتيجة للهدف ، ولكننا نرجع أيضًا أنه اسم كجزء من التنفيذ المستهدف).  بعد ذلك ، سوف نحتاج إلى تحديده كمدخل للهدف B. لذلك ، هناك 3 أماكن في المجموع نحتاج فيها إلى تقديم معلومات حول الملف <code>outA</code> .  وحتى بعد قيامنا بذلك ، لن يؤدي تعديل الملف <code>outA</code> إلى إعادة <code>outA</code> التلقائي للهدف B. وهذا يعني أنه إذا طلبنا من Doit إنشاء الهدف B ، فسوف يتحقق doit فقط إذا كان الهدف B محدثًا دون التحقق من أي من التبعيات.  للتغلب على هذا ، سنحتاج إلى تحديد <code>outA</code> 4 مرات - وأيضًا كتبعية ملف للهدف B. أرى ذلك بمثابة عيب.  يستطيع كل من Make و CMake التعامل مع مثل هذه المواقف بشكل صحيح. <br><br>  تعتمد التبعيات في doit على الملفات ويتم التعبير عنها كسلاسل.  هذا يعني أن التبعيات. / <code>myfile.txt</code> و <code>myfile.txt</code> يُنظر إليهما على أنهما مختلفان.  كما كتبت أعلاه ، أجد طريقة لتمرير المعلومات من الهدف إلى الهدف (عند استخدام أهداف الثعبان) غريبة بعض الشيء.  الهدف لديه قائمة من القطع الأثرية التي سينتجها ، لكن الهدف الآخر لا يمكنه استخدامها.  بدلاً من ذلك ، يجب أن تُرجع الدالة python ، التي تشكل الهدف ، قاموسًا ، يمكن الوصول إليه في هدف آخر.  دعونا نرى ذلك على سبيل المثال: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Preprocess IRIS dataset"""</span></span> pickle_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.pickle'</span></span> excel_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.xlsx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'file_dep'</span></span>: [<span class="hljs-string"><span class="hljs-string">'src/data/preprocess.py'</span></span>], <span class="hljs-string"><span class="hljs-string">'targets'</span></span>: [pickle_file, excel_file], <span class="hljs-string"><span class="hljs-string">'actions'</span></span>: [doit_pypreprocess], <span class="hljs-string"><span class="hljs-string">'getargs'</span></span>: {<span class="hljs-string"><span class="hljs-string">'input_file'</span></span>: (<span class="hljs-string"><span class="hljs-string">'rawdata'</span></span>, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)}, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }</code> </pre><br>  هنا تعتمد <code>preprocess</code> الهدف على البيانات <code>rawdata</code> .  يتم توفير التبعية عبر خاصية <code>getargs</code> .  تقول أن الوسيطة <code>input_file</code> للدالة <code>doit_pypreprocess</code> هي <code>filename</code> الإخراج <code>rawdata</code> الهدف.  ألقِ نظرة على المثال الكامل في ملف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">dodo.py.</a> <br><br>  قد يكون من المفيد قراءة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قصص نجاح</a> استخدام doit.  إنه يحتوي بالتأكيد على ميزات لطيفة مثل القدرة على توفير فحص مستهدف مخصص محدث. <br><br><h2 style=";text-align:right;direction:rtl"><a name="Luigi"></a>  لويجي </h2><br>  يبقى لويجي بعيدًا عن الأدوات الأخرى لأنه نظام لبناء خطوط أنابيب معقدة.  لقد ظهر على راداري بعد أن أخبرني أحد الزملاء أنه حاول صنع ، ولم يكن قادرًا على استخدامه عبر Windows / Linux وانتقل إلى لويجي. <br><br>  لويجي تهدف إلى أنظمة جاهزة للإنتاج.  لأنه يأتي مع خادم ، والذي يمكن استخدامه لتصور المهام الخاصة بك أو للحصول على تاريخ من تنفيذ المهام.  يسمى الخادم <em>جدولة المركزية</em> .  يتوفر جدولة محلية لأغراض التصحيح. <br><br>  تختلف لويجي أيضًا عن الأنظمة الأخرى بطريقة يتم بها إنشاء المهام.  لا تعمل <code>dodo.py</code> على بعض الملفات المحددة مسبقًا (مثل <code>dodo.py</code> أو <code>pavement.py</code> أو makefile).  بدلا من ذلك ، يتعين على المرء أن يمر اسم وحدة بيثون.  لذلك ، إذا حاولنا استخدامه بطريقة مشابهة للأدوات الأخرى (وضع ملف به مهام في جذر المشروع) ، فلن ينجح.  يتعين علينا إما تثبيت مشروعنا أو تعديل متغير البيئة <code>PYTHONPATH</code> عن طريق إضافة المسار إلى المشروع. <br><br>  ما هو عظيم حول لويجي هو طريقة تحديد التبعيات بين المهام.  كل مهمة هي فئة.  يخبر أسلوب <code>output</code> Luigi أين ستنتهي نتائج المهمة.  يمكن أن تكون النتائج عنصرًا واحدًا أو قائمة.  <code>requires</code> الأسلوب تحديد تبعيات المهام (مهام أخرى ؛ على الرغم من أنه من الممكن إنشاء تبعية من نفسه).  وهذا كل شيء.  كل ما تم تحديده <code>output</code> في المهمة A سيتم تمريره كمدخل إلى المهمة B إذا كانت المهمة B تعتمد على المهمة A. <br><img src="https://habrastorage.org/getpro/habr/post_images/ba2/95c/bb9/ba295cbb9b744767e709aa7b3a0e358f.png"><br><br>  لويجي لا يهتم التعديلات الملف.  يهتم بوجود ملف.  لذلك لا يمكن تشغيل عمليات إعادة الإنشاء عند تغيير التعليمات البرمجية المصدر.  لا تحتوي لويجي على وظيفة <i>نظيفة</i> مضمنة. <br><br>  تتوفر مهام Luigi لهذا المشروع في ملف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">luigitasks.py</a> .  أركضهم من المحطة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">luigi --local-scheduler --module luigitasks Exploratory</code> </pre><br><h2 style=";text-align:right;direction:rtl"><a name="Comparison"></a>  مقارنة </h2><br>  يلخص الجدول التالي كيفية عمل الأنظمة المختلفة فيما يتعلق بأهدافنا المحددة. <br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><tbody><tr><th></th><th>  تحديد الهدف مع التبعية </th><th>  يبني تدريجيا </th><th>  بناء تزايدي إذا تم تغيير التعليمات البرمجية المصدر </th><th>  القدرة على معرفة أي القطع الأثرية لإزالة أثناء القيادة <code>clean</code> </th></tr><tr><td>  <strong>CMake</strong> </td><td>  نعم </td><td>  نعم </td><td>  نعم </td><td>  نعم </td></tr><tr><td>  <strong>Pynt</strong> </td><td>  نعم </td><td>  لا </td><td>  لا </td><td>  لا </td></tr><tr><td>  <strong>الجبان</strong> </td><td>  نعم </td><td>  لا </td><td>  لا </td><td>  لا </td></tr><tr><td>  <strong>DOIT</strong> </td><td>  نعم نوعا ما </td><td>  نعم </td><td>  نعم </td><td>  نعم </td></tr><tr><td>  <strong>لويجي</strong> </td><td>  نعم </td><td>  لا </td><td>  لا </td><td>  لا </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar451962/">https://habr.com/ru/post/ar451962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar451950/index.html">محطات توليد الطاقة الافتراضية. هل من الممكن إدارة مصادر الطاقة "الخضراء"؟</a></li>
<li><a href="../ar451954/index.html">أكثر برقية سرية</a></li>
<li><a href="../ar451956/index.html">باستخدام AppDynamics مع ريد هات OpenShift v3</a></li>
<li><a href="../ar451958/index.html">نشاهد السيول على التلفزيون الذكي بدون رسائل نصية وتسجيل</a></li>
<li><a href="../ar451960/index.html">90 نقاط الضعف في تنفيذ التعليمات البرمجية عن بُعد في مايو قد يتم تحديثها يوم الثلاثاء</a></li>
<li><a href="../ar451966/index.html">أجهزة الإدخال / الإخراج الحديثة أسرع من المعالجات. نظرة عامة على المادة</a></li>
<li><a href="../ar451968/index.html">Top 3D Academy - التدريب على التقنيات المضافة في الشركات الروسية الرائدة</a></li>
<li><a href="../ar451970/index.html">Thrangrycat: تسمح الثغرات الحرجة في البرامج الثابتة لجهاز Cisco للمتسللين بتثبيت الخلفيات الخلفية عليهم</a></li>
<li><a href="../ar451972/index.html">كوادكاست - أصوات حقيقية</a></li>
<li><a href="../ar451974/index.html">تاريخ AMD: 50 عامًا من التطور السريع</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>