<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèº üåÄ üßë GPU Ray Tracing en Unity - Parte 3 üêö üèπ ‚õΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ La primera y segunda parte.] 


 Hoy daremos un gran salto. Nos alejaremos de las estructuras exclusivamente esf√©ricas y del plano infinito que traz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU Ray Tracing en Unity - Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450308/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La primera</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segunda</a> parte.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a8a/4f2/f9fa8a4f2a79b8c394636de6a128d0d5.png"></div><br>  Hoy daremos un gran salto.  Nos alejaremos de las estructuras exclusivamente esf√©ricas y del plano infinito que trazamos anteriormente, y agregaremos tri√°ngulos: toda la esencia de los gr√°ficos modernos por computadora, un elemento en el que consisten todos los mundos virtuales.  Si desea continuar con lo que terminamos la √∫ltima vez, use el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo de la parte 2</a> .  El c√≥digo final de lo que haremos hoy est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  ¬°Empecemos! <br><br><h2>  Tri√°ngulos </h2><br>  <em>Un tri√°ngulo</em> es solo una lista de tres <em>v√©rtices</em> conectados, cada uno de los cuales mantiene su posici√≥n, y algunas veces es normal.  El orden de recorrido de los v√©rtices desde su punto de vista determina lo que estamos viendo: la cara frontal o posterior del tri√°ngulo.  Tradicionalmente, el "frente" se considera el orden de derivaci√≥n en sentido antihorario. <br><br>  Primero, debemos ser capaces de determinar si el rayo se cruza con un tri√°ngulo, y si es as√≠, en qu√© punto.  En 1997, los se√±ores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Thomas Akenin-Meller</a> y Ben Trembor propusieron <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un</a> algoritmo muy popular (pero ciertamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no el √∫nico</a> ) para determinar la intersecci√≥n de un rayo con un tri√°ngulo.  Puede leer m√°s al respecto en su art√≠culo "Intersecci√≥n de tri√°ngulo-rayo de almacenamiento m√≠nimo y r√°pido" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><a name="habracut"></a><br>  El c√≥digo del art√≠culo se puede portar f√°cilmente al c√≥digo de sombreador HLSL: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> EPSILON = <span class="hljs-number"><span class="hljs-number">1e-8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectTriangle_MT97</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// find vectors for two edges sharing vert0 float3 edge1 = vert1 - vert0; float3 edge2 = vert2 - vert0; // begin calculating determinant - also used to calculate U parameter float3 pvec = cross(ray.direction, edge2); // if determinant is near zero, ray lies in plane of triangle float det = dot(edge1, pvec); // use backface culling if (det &lt; EPSILON) return false; float inv_det = 1.0f / det; // calculate distance from vert0 to ray origin float3 tvec = ray.origin - vert0; // calculate U parameter and test bounds u = dot(tvec, pvec) * inv_det; if (u &lt; 0.0 || u &gt; 1.0f) return false; // prepare to test V parameter float3 qvec = cross(tvec, edge1); // calculate V parameter and test bounds v = dot(ray.direction, qvec) * inv_det; if (v &lt; 0.0 || u + v &gt; 1.0f) return false; // calculate t, ray intersects triangle t = dot(edge2, qvec) * inv_det; return true; }</span></span></code> </pre> <br>  Para usar esta funci√≥n, necesitamos un rayo y tres v√©rtices de un tri√°ngulo.  El valor de retorno nos dice si el tri√°ngulo se cruz√≥.  En caso de intersecci√≥n, se calculan tres valores adicionales: <code>t</code> describe la distancia a lo largo de la viga hasta el punto de intersecci√≥n, y <code>u</code> / <code>v</code> son dos de las tres coordenadas barc√©ntricas que determinan la ubicaci√≥n del punto de intersecci√≥n en el tri√°ngulo (la √∫ltima coordenada se puede calcular como <code>w = 1 - u - v</code> ).  Si a√∫n no est√° familiarizado con las coordenadas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">barc√©ntricas</a> , lea su excelente explicaci√≥n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Scratchapixel</a> . <br><br>  Sin demasiado retraso, tracemos un tri√°ngulo con los v√©rtices indicados en el c√≥digo.  Busque la funci√≥n <code>Trace</code> en el sombreador y agregue el siguiente fragmento de c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Trace single triangle float3 v0 = float3(-150, 0, -150); float3 v1 = float3(150, 0, -150); float3 v2 = float3(0, 150 * sqrt(2), -150); float t, u, v; if (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { if (t &gt; 0 &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = 0.00f; bestHit.specular = 0.65f * float3(1, 0.4f, 0.2f); bestHit.smoothness = 0.9f; bestHit.emission = 0.0f; } }</span></span></code> </pre> <br>  Como dije, <code>t</code> almacena la distancia a lo largo de la viga, y podemos usar directamente este valor para calcular el punto de intersecci√≥n.  Lo normal, que es importante para calcular la reflexi√≥n correcta, se puede calcular utilizando el producto vectorial de cualquiera de los dos bordes del tri√°ngulo.  Inicie el modo de juego y admire su primer tri√°ngulo trazado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/65a/a84/b2965aa84ae9d882e6c26f7f44da2af7.png"></div><br>  <strong>Ejercicio:</strong> intente calcular la posici√≥n utilizando coordenadas barc√©ntricas en lugar de la distancia.  Si haces todo bien, el tri√°ngulo brillante se ver√° exactamente como antes. <br><br><h2>  Mallas triangulares </h2><br>  Superamos el primer obst√°culo, pero rastrear mallas enteras desde tri√°ngulos es una historia completamente diferente.  Primero necesitamos aprender informaci√≥n b√°sica sobre mallas.  Si los conoce, puede saltarse el siguiente p√°rrafo de forma segura. <br><br>  En gr√°ficos de computadora, la malla est√° definida por varios b√∫feres, los m√°s importantes son los b√∫feres de <em>v√©rtices</em> e <em>√≠ndices</em> .  <em>El b√∫fer de v√©rtices</em> es una lista de vectores 3D que describe la posici√≥n de cada v√©rtice en <em>el espacio del objeto</em> (esto significa que dichos valores no necesitan cambiarse al mover, rotar o escalar un objeto; se convierten del <em>espacio del objeto al espacio</em> <em>mundial</em> sobre la marcha utilizando la multiplicaci√≥n de matrices) .  <em>Un b√∫fer de √≠ndice</em> es una lista de valores enteros que son <em>√≠ndices</em> que apuntan al b√∫fer de v√©rtices.  Cada tres √≠ndices forman un tri√°ngulo.  Por ejemplo, si el b√∫fer de √≠ndice tiene la forma [0, 1, 2, 0, 2, 3], entonces tiene dos tri√°ngulos: el primer tri√°ngulo consiste en el primer, segundo y tercer v√©rtices en el b√∫fer de v√©rtices, y el segundo tri√°ngulo consiste en el primero, tercero y cuarto picos.  Por lo tanto, el b√∫fer de √≠ndice tambi√©n determina el orden transversal mencionado anteriormente.  Adem√°s de los b√∫feres e √≠ndices de v√©rtices, puede haber b√∫feres adicionales que agreguen otra informaci√≥n a cada v√©rtice.  Los buffers adicionales m√°s comunes almacenan <em>normales</em> , <em>coordenadas de textura</em> (llamadas <em>texcoords</em> o simplemente <em>UV</em> ), as√≠ como <em>colores de v√©rtice</em> . <br><br><h2>  Usando GameObjects </h2><br>  En primer lugar, necesitamos descubrir qu√© GameObjects deber√≠an formar parte del proceso de trazado de rayos.  Una soluci√≥n ingenua ser√≠a simplemente usar <code>FindObjectOfType&lt;MeshRenderer&gt;()</code> , pero hacer algo m√°s flexible y r√°pido.  <code>RayTracingObject</code> un nuevo componente <code>RayTracingObject</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RayTracingObject</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.RegisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.UnregisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br>  Este componente se agrega a cada objeto que queremos usar para el trazado de rayos y se involucra en su registro utilizando <code>RayTracingMaster</code> .  Agregue las siguientes funciones al asistente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;RayTracingObject&gt; _rayTracingObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;RayTracingObject&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Add(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnregisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Remove(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Todo va bien, ahora sabemos qu√© objetos deben rastrearse.  Pero luego viene la parte dif√≠cil: vamos a recopilar todos los datos de las mallas de Unity (matriz, b√∫feres de v√©rtices e √≠ndices, ¬ølos recuerda?), Los escribimos en nuestras propias estructuras de datos y los cargamos en la GPU para que el sombreador pueda usarlos.  Comencemos definiendo estructuras de datos y memorias intermedias en el lado de C #, en el asistente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MeshObject { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Matrix4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;MeshObject&gt; _meshObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MeshObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; _vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _meshObjectBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _vertexBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _indexBuffer;</code> </pre> <br>  ... y ahora hagamos lo mismo en el sombreador.  ¬øEst√°s acostumbrado? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MeshObject</span></span></span><span class="hljs-class"> {</span></span> float4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; }; StructuredBuffer&lt;MeshObject&gt; _MeshObjects; StructuredBuffer&lt;float3&gt; _Vertices; StructuredBuffer&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _Indices;</code> </pre> <br>  Las estructuras de datos est√°n listas y podemos llenarlas con datos reales.  Recopilamos todos los v√©rtices de todas las mallas en una gran <code>List&lt;Vector3&gt;</code> , y todos los √≠ndices en una gran <code>List&lt;int&gt;</code> .  No hay problemas con los v√©rtices, pero los √≠ndices deben cambiarse para que contin√∫en apuntando al v√©rtice correcto en nuestro b√∫fer grande.  Imagine que ya hemos agregado objetos de 1000 v√©rtices, y ahora agregamos un cubo de malla simple.  El primer tri√°ngulo puede consistir en √≠ndices [0, 1, 2], pero como ya ten√≠amos 1000 v√©rtices en el b√∫fer, necesitamos cambiar los √≠ndices antes de agregar v√©rtices al cubo.  Es decir, se convertir√°n en [1000, 1001, 1002].  As√≠ es como se ve en el c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RebuildMeshObjectBuffers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_meshObjectsNeedRebuilding) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _currentSample = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Clear all lists _meshObjects.Clear(); _vertices.Clear(); _indices.Clear(); // Loop over all objects and gather their data foreach (RayTracingObject obj in _rayTracingObjects) { Mesh mesh = obj.GetComponent&lt;MeshFilter&gt;().sharedMesh; // Add vertex data int firstVertex = _vertices.Count; _vertices.AddRange(mesh.vertices); // Add index data - if the vertex buffer wasn't empty before, the // indices need to be offset int firstIndex = _indices.Count; var indices = mesh.GetIndices(0); _indices.AddRange(indices.Select(index =&gt; index + firstVertex)); // Add the object itself _meshObjects.Add(new MeshObject() { localToWorldMatrix = obj.transform.localToWorldMatrix, indices_offset = firstIndex, indices_count = indices.Length }); } CreateComputeBuffer(ref _meshObjectBuffer, _meshObjects, 72); CreateComputeBuffer(ref _vertexBuffer, _vertices, 12); CreateComputeBuffer(ref _indexBuffer, _indices, 4); }</span></span></code> </pre> <br>  Llame a <code>RebuildMeshObjectBuffers</code> en la funci√≥n <code>OnRenderImage</code> y no olvide liberar nuevos buffers en <code>OnDisable</code> .  Aqu√≠ hay dos funciones auxiliares que utilic√© en el c√≥digo anterior para simplificar un poco el manejo del b√∫fer: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateComputeBuffer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ComputeBuffer buffer, List&lt;T&gt; data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do we already have a compute buffer? if (buffer != null) { // If no data or buffer doesn't match the given criteria, release it if (data.Count == 0 || buffer.count != data.Count || buffer.stride != stride) { buffer.Release(); buffer = null; } } if (data.Count != 0) { // If the buffer has been released or wasn't there to // begin with, create it if (buffer == null) { buffer = new ComputeBuffer(data.Count, stride); } // Set data on the buffer buffer.SetData(data); } } private void SetComputeBuffer(string name, ComputeBuffer buffer) { if (buffer != null) { RayTracingShader.SetBuffer(0, name, buffer); } }</span></span></code> </pre> <br>  ¬°Genial, creamos buffers y est√°n llenos de los datos necesarios!  Ahora solo tenemos que informar esto al sombreador.  Agregue el siguiente c√≥digo a <code>SetShaderParameters</code> (y gracias a las nuevas funciones auxiliares, podemos reducir el c√≥digo del b√∫fer de esfera): <br><br><pre> <code class="cs hljs">SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Spheres"</span></span>, _sphereBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_MeshObjects"</span></span>, _meshObjectBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Vertices"</span></span>, _vertexBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Indices"</span></span>, _indexBuffer);</code> </pre> <br>  Por lo tanto, el trabajo es aburrido, pero veamos lo que acabamos de hacer: recolectamos todos los datos internos de las mallas (matriz, v√©rtices e √≠ndices), los colocamos en una estructura conveniente y simple, y luego los enviamos a la GPU, que ahora esperamos cuando Pueden ser utilizados. <br><br><h2>  Trazado de malla </h2><br>  No lo hagamos esperar.  En el sombreador, ya tenemos el c√≥digo de traza de un tri√°ngulo individual, y la malla es, de hecho, solo muchos tri√°ngulos.  El √∫nico aspecto nuevo aqu√≠ es que usamos una matriz para transformar v√©rtices desde el espacio del objeto al espacio mundial usando la funci√≥n <code>mul</code> incorporada (abreviatura de multiplicar).  La matriz contiene la traslaci√≥n, rotaci√≥n y escala del objeto.  Tiene un tama√±o de 4 √ó 4, por lo que para la multiplicaci√≥n necesitamos un vector 4d.  Los primeros tres componentes (x, y, z) se toman del b√∫fer de v√©rtices.  Establecemos el cuarto componente (w) en 1 porque estamos tratando con un punto.  Si esta fuera la direcci√≥n, entonces escribir√≠amos 0 para ignorar todas las traducciones y la escala en la matriz.  ¬øEs esto confuso para ti?  Luego lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este tutorial</a> al menos ocho veces.  Aqu√≠ est√° el c√≥digo del sombreador: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectMeshObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, inout RayHit bestHit, MeshObject meshObject)</span></span></span><span class="hljs-function"> </span></span>{ uint offset = meshObject.indices_offset; uint count = offset + meshObject.indices_count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = offset; i &lt; count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { float3 v0 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v1 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v2 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t, u, v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; bestHit.specular = <span class="hljs-number"><span class="hljs-number">0.65f</span></span>; bestHit.smoothness = <span class="hljs-number"><span class="hljs-number">0.99f</span></span>; bestHit.emission = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } } } }</code> </pre> <br>  Estamos a solo un paso de verlo todo en acci√≥n.  Reestructuramos un poco la funci√≥n <code>Trace</code> y agreguemos un rastro de objetos de malla: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">RayHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray)</span></span></span><span class="hljs-function"> </span></span>{ RayHit bestHit = CreateRayHit(); uint count, stride, i; <span class="hljs-comment"><span class="hljs-comment">// Trace ground plane IntersectGroundPlane(ray, bestHit); // Trace spheres _Spheres.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectSphere(ray, bestHit, _Spheres[i]); } // Trace mesh objects _MeshObjects.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectMeshObject(ray, bestHit, _MeshObjects[i]); } return bestHit; }</span></span></code> </pre> <br><h2>  Resultados </h2><br>  Eso es todo!  <code>RayTracingObject</code> algunas mallas simples (las primitivas de Unity est√°n bien), dele el componente <code>RayTracingObject</code> y observe la magia.  <strong>¬°No use</strong> mallas detalladas todav√≠a (m√°s de unos pocos cientos de tri√°ngulos)!  Nuestro sombreador carece de optimizaci√≥n, y si se excede, puede tomar segundos o incluso minutos rastrear al menos una muestra por p√≠xel.  Como resultado, el sistema detendr√° el controlador de la GPU, el motor de Unity puede fallar y la computadora deber√° reiniciarse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/1d4/40e/c801d440e5a0a21f660b5a7e82e1b368.png"></div><br>  Tenga en cuenta que nuestras mallas no tienen un sombreado suave sino plano.  Como todav√≠a no hemos cargado las normales de los v√©rtices en el b√∫fer, para obtener la normal de los v√©rtices de cada tri√°ngulo, debemos realizar un producto vectorial.  Adem√°s, no podemos interpolar sobre el √°rea del tri√°ngulo.  Abordaremos este problema en la siguiente parte del tutorial. <br><br>  En aras del inter√©s, descargu√© el Stanford Bunny del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivo Morgan McGwire</a> y, utilizando el modificador de diezmado del paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blender</a> , reduje el n√∫mero de v√©rtices a 431. Puede experimentar con par√°metros de iluminaci√≥n y material codificado en la funci√≥n de sombreado <code>IntersectMeshObject</code> .  Aqu√≠ hay un conejo diel√©ctrico con hermosas sombras suaves y un poco de iluminaci√≥n global difusa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grafitti Shelter</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0da/860/bb4/0da860bb41d9465f2dc21d649a509a66.png"></div><br>  ... y aqu√≠ hay un conejo de metal bajo la fuerte luz direccional de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cape Hill</a> , arrojando un resplandor de disco en el plano del piso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a76/bb1/a64/a76bb1a642d620929ecd250f92e1ef1f.jpg"></div><br>  ... y aqu√≠ hay dos conejitos escondidos debajo de la gran piedra Suzanne bajo el cielo azul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kiara 9 Dusk</a> (prescrib√≠ material alternativo para el segundo objeto, verificando si el cambio de √≠ndice es cero): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ef/196/a4f/7ef196a4f818b366b4838f2b1e4148f5.png"></div><br><h2>  Que sigue </h2><br>  Es genial ver una malla real en tu propio marcador por primera vez, ¬øverdad?  Hoy procesamos algunos datos, descubrimos la intersecci√≥n utilizando el algoritmo Meller-Trambor y recopilamos todo para que pudi√©ramos usar de inmediato el motor GameObjects del motor Unity.  Adem√°s, vimos una de las ventajas del trazado de rayos: tan pronto como agrega una nueva intersecci√≥n al c√≥digo, todos los hermosos efectos (sombras suaves, iluminaci√≥n global reflejada y difusa, etc.) comienzan a funcionar de inmediato. <br><br>  Renderizar un conejo brillante tom√≥ mucho tiempo, y todav√≠a tuve que usar un poco de filtrado para deshacerme del ruido m√°s obvio.  Para resolver este problema, una escena generalmente se escribe en una estructura espacial, por ejemplo, en una cuadr√≠cula, un √°rbol K-dimensional o una jerarqu√≠a de vol√∫menes delimitadores, lo que aumenta significativamente la velocidad de representaci√≥n de escenas grandes. <br><br>  Pero tenemos que movernos en orden: adem√°s eliminaremos el problema con las normales para que nuestras mallas (incluso las de baja poli) se vean m√°s suaves que ahora.  Tambi√©n ser√≠a bueno actualizar autom√°ticamente las matrices al mover objetos y referirse directamente a los materiales de Unity, y no solo escribirlos en el c√≥digo.  Esto es lo que haremos en la pr√≥xima parte de la serie de tutoriales.  ¬°Gracias por leer y nos vemos en la parte 4! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450308/">https://habr.com/ru/post/450308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450294/index.html">Los venenos mas espantosos</a></li>
<li><a href="../450298/index.html">Futuro Cu√°ntico (continuaci√≥n)</a></li>
<li><a href="../450300/index.html">Deja de discutir sobre programaci√≥n funcional y POO</a></li>
<li><a href="../450302/index.html">Tecnolog√≠a de radioaficionados: prototipo de fabricaci√≥n de placas de circuito en una f√°brica china</a></li>
<li><a href="../450304/index.html">Carapuzik montando una hormiga: 100 millones de a√±os de mirmeofilia</a></li>
<li><a href="../450310/index.html">C√≥mo funciona Philips VideoWRITER. Primeras im√°genes de hierro, luego un poco de tedio.</a></li>
<li><a href="../450312/index.html">Docker Compose Starter Guide</a></li>
<li><a href="../450314/index.html">TensorFlow para principiantes. Parte 1: informaci√≥n general, instalaci√≥n de la biblioteca</a></li>
<li><a href="../450316/index.html">TDD: una metodolog√≠a de desarrollo que cambi√≥ mi vida</a></li>
<li><a href="../450318/index.html">Dise√±ar patrones en el desarrollo moderno de JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>