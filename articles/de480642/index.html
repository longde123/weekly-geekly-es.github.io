<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå± üêÜ ‚òùÔ∏è Einf√ºhrung in Linux ELFs: Verstehen und Analysieren üö≠ üëã ü§ì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt Dinge auf der Welt, die wir f√ºr selbstverst√§ndlich halten, obwohl sie wahre Meisterwerke sind. Eine solche Sache sind Linux-Dienstprogramme wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in Linux ELFs: Verstehen und Analysieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480642/"> Es gibt Dinge auf der Welt, die wir f√ºr selbstverst√§ndlich halten, obwohl sie wahre Meisterwerke sind.  Eine solche Sache sind Linux-Dienstprogramme wie ls und ps.  Obwohl sie normalerweise als einfach empfunden werden, ist dies weit davon entfernt, wenn wir nach innen schauen.  Und ELF, Executable und Linkable Format auch.  Ein Dateiformat, das universell verwendet wird, aber nur wenige verstehen es.  Diese Kurzanleitung hilft Ihnen beim Verst√§ndnis. <br><br><img src="https://habrastorage.org/webt/ka/0m/em/ka0memy9zppvjiut58hua0_cyt8.jpeg"><br><br>  Nachdem Sie diesen Leitfaden gelesen haben, lernen Sie Folgendes: <br><br><ul><li>  Warum wird das ELF-Format ben√∂tigt und f√ºr welche Dateitypen wird es verwendet? </li><li>  ELF-Dateistruktur und Formatdetails </li><li>  Lesen und Analysieren des bin√§ren Inhalts einer ELF-Datei </li><li>  Mit welchen Tools werden Bin√§rdateien analysiert? </li></ul><a name="habracut"></a><br><h2>  Was ist eine ELF-Datei? </h2><br>  ELF steht f√ºr Executable and Linkable Format und definiert die Struktur von Bin√§rdateien, Bibliotheken und Kerndateien.  Die Formatspezifikation erm√∂glicht es dem Betriebssystem, die in der Datei enthaltenen Maschinenanweisungen korrekt zu interpretieren.  Eine ELF-Datei ist normalerweise die Ausgabedatei eines Compilers oder Linkers und hat ein Bin√§rformat.  Mit geeigneten Werkzeugen kann es analysiert und untersucht werden. <br><br><h3>  Warum ELF im Detail studieren? </h3><br>  Bevor wir uns mit den technischen Details befassen, werden wir Ihnen unbedingt erkl√§ren, warum das Verst√§ndnis des ELF-Formats n√ºtzlich ist.  Erstens k√∂nnen Sie den internen Betrieb des Betriebssystems untersuchen.  Wenn etwas schief gelaufen ist, k√∂nnen Sie mit diesem Wissen besser nachvollziehen, was genau und aus welchem ‚Äã‚ÄãGrund passiert ist.  Die M√∂glichkeit, ELF-Dateien zu untersuchen, kann auch hilfreich sein, um Sicherheitsl√ºcken zu finden und verd√§chtige Dateien zu erkennen.  Und schlie√ülich zum besseren Verst√§ndnis des Entwicklungsprozesses.  Selbst wenn Sie in einer h√∂heren Sprache wie Go programmieren, wissen Sie immer noch besser, was sich hinter den Kulissen abspielt. <br><br>  Warum also ELF studieren? <br><br><ul><li>  F√ºr ein allgemeines Verst√§ndnis des Betriebssystems </li><li>  F√ºr die Softwareentwicklung </li><li>  Digitale Forensik und Incident Response (DFIR) </li><li>  Malware-Recherche (Bin√§ranalyse) </li></ul><br><h3>  Von der Quelle zum Prozess </h3><br>  Welches Betriebssystem wir auch verwenden, es ist notwendig, die Quellcodefunktionen in die CPU-Sprache zu √ºbersetzen - Maschinencode.  Die einfachsten Funktionen k√∂nnen beispielsweise das √ñffnen einer Datei auf der Festplatte oder das Anzeigen von Elementen auf dem Bildschirm sein.  Anstatt die CPU-Sprache direkt zu verwenden, verwenden wir eine Programmiersprache mit Standardfunktionen.  Der Compiler √ºbersetzt diese Funktionen dann in Objektcode.  Dieser Objektcode wird dann √ºber den Linker in das gesamte Programm eingebunden.  Das Ergebnis ist eine Bin√§rdatei, die auf einer bestimmten Plattform und einem bestimmten CPU-Typ ausgef√ºhrt werden kann. <br><br><h3>  Bevor du anf√§ngst </h3><br>  Dieser Beitrag enth√§lt viele Teams.  Es ist besser, sie auf einem Testcomputer auszuf√ºhren.  Kopieren Sie vorhandene Bin√§rdateien, bevor Sie diese Befehle ausf√ºhren.  Wir werden auch ein kleines C-Programm schreiben, das Sie kompilieren k√∂nnen.  Letztendlich ist √úbung der beste Weg, etwas zu lernen. <br><br><h2>  Anatomie einer ELF-Datei </h2><br>  Ein h√§ufiges Missverst√§ndnis ist, dass ELF-Dateien nur f√ºr bin√§re oder ausf√ºhrbare Dateien sind.  Wir haben bereits gesagt, dass sie f√ºr Teile von ausf√ºhrbaren Dateien (Objektcode) verwendet werden k√∂nnen.  Ein weiteres Beispiel sind Bibliotheksdateien und Core-Dumps (Core-Dateien und a.out-Dateien).  Die ELF-Spezifikation wird auch unter Linux f√ºr Kernel und Kernelmodule verwendet. <br><br><img src="https://habrastorage.org/webt/dt/5y/vq/dt5yvqm-oju3s6todxbbd6ivzw0.png"><br><br><h3>  Struktur </h3><br>  Aufgrund der Erweiterbarkeit von ELF-Dateien kann die Struktur f√ºr verschiedene Dateien variieren.  Die ELF-Datei besteht aus: <br><br><ol><li>  ELF-Header </li><li>  Daten </li></ol><br>  Mit dem Befehl readelf k√∂nnen wir uns die Dateistruktur ansehen und sie sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/vo/ng/w-/vongw-d8cy_mvkf9jgcizbdpq0c.png"><br><br><h3>  ELF-Header </h3><br>  Wie Sie auf dem Screenshot sehen k√∂nnen, beginnt der ELF-Header mit einer ‚Äûmagischen Zahl‚Äú.  Diese "magische Zahl" gibt Auskunft √ºber die Datei.  Die ersten 4 Bytes legen fest, dass es sich um eine ELF-Datei handelt (45 = E, 4c = L, 46 = F, vor 7f). <br><br>  Der ELF-Header ist erforderlich.  Dies ist erforderlich, damit die Daten w√§hrend der Verkn√ºpfung und Ausf√ºhrung korrekt interpretiert werden.  Zum besseren Verst√§ndnis des internen Betriebs einer ELF-Datei ist es hilfreich zu wissen, wof√ºr diese Informationen verwendet werden. <br><br><h3>  Klasse </h3><br>  Nach der Deklaration eines ELF-Typs folgt ein Klassenfeld.  Dieser Wert gibt die Architektur an, f√ºr die die Datei bestimmt ist.  Dies kann 01 (32-Bit-Architektur) oder 02 (64-Bit) sein.  Hier sehen wir 02, das vom Befehl readelf als ELF64-Datei √ºbersetzt wird, dh, diese Datei verwendet eine 64-Bit-Architektur.  Das ist nicht verwunderlich, denn in meinem Auto ist ein moderner Prozessor verbaut. <br><br><h3>  Daten </h3><br>  Als n√§chstes folgt das Datenfeld mit zwei Optionen: 01 - LSB (Least Significant Bit), auch bekannt als Little-Endian, oder 02 - MSB (Most Significant Bit, Big-Endian).  Diese Werte helfen bei der Interpretation der √ºbrigen Objekte in der Datei.  Dies ist wichtig, da unterschiedliche Prozessortypen unterschiedlich mit Datenstrukturen umgehen.  In unserem Fall wird LSB verwendet, da der Prozessor eine AMD64-Architektur hat. <br><br>  Der LSB-Effekt wird sichtbar, wenn das Hexdump-Dienstprogramm f√ºr eine Bin√§rdatei verwendet wird.  Sehen wir uns den ELF-Header f√ºr / bin / ps an. <br><br><pre><code class="bash hljs">$ hexdump -n 16 /bin/ps 0000000 457f 464c 0102 0001 0000 0000 0000 0000 0000010</code> </pre> <br>  Wir sehen, dass die Wertepaare aufgrund der Interpretation der Datenreihenfolge unterschiedlich sind. <br><br><h3>  Version </h3><br>  Dann folgt ein weiterer magischer Wert "01", der die Versionsnummer ist.  Derzeit ist nur die Version 01 verf√ºgbar, daher bedeutet diese Nummer nichts Interessantes. <br><br><h3>  OS / ABI </h3><br>  Jedes Betriebssystem hat seine eigene Art, Funktionen aufzurufen, sie haben viele Gemeinsamkeiten, aber dar√ºber hinaus weist jedes System kleine Unterschiede auf.  Die Reihenfolge des Funktionsaufrufs wird durch das Application Binary Interface (ABI) festgelegt.  Die OS / ABI-Felder beschreiben, welches ABI verwendet wird und in welcher Version.  In unserem Fall ist der Wert 00, was bedeutet, dass bestimmte Erweiterungen nicht verwendet werden.  In der Ausgabe wird dies als System V angezeigt. <br><br><h3>  ABI-Version </h3><br>  Bei Bedarf kann eine ABI-Version angegeben werden. <br><br><h3>  Auto </h3><br>  Der Titel gibt auch den erwarteten Maschinentyp (AMD64) an. <br><br><h3>  Typ </h3><br>  Das Feld Typ gibt an, wof√ºr die Datei bestimmt ist.  Hier sind einige gebr√§uchliche Dateitypen. <br><br>  KERN (Wert 4) <br>  DYN (Shared Object File), Bibliothek (Wert 3) <br>  EXEC (ausf√ºhrbare Datei), ausf√ºhrbare Datei (Wert 2) <br>  REL (Relocatable file), Datei vor dem Verkn√ºpfen (Wert 1) <br><br><h3>  Siehe den vollst√§ndigen Titel </h3><br>  Obwohl einige Felder √ºber readelf angezeigt werden k√∂nnen, gibt es tats√§chlich mehr.  Sie k√∂nnen beispielsweise herausfinden, f√ºr welchen Prozessor die Datei bestimmt ist.  Verwenden Sie hexdump, um den vollst√§ndigen ELF-Header und alle Werte anzuzeigen. <br><br><pre> <code class="bash hljs">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............| 02 00 3e 00 01 00 00 00 a8 2b 40 00 00 00 00 00 |..&gt;......+@.....| 40 00 00 00 00 00 00 00 30 65 01 00 00 00 00 00 |@.......0e......| 00 00 00 00 40 00 38 00 09 00 40 00 1c 00 1b 00 |....@.8...@.....|</code> </pre> <br>  (Ausgabe hexdump -C -n 64 / bin / ps) <br><br>  Das hervorgehobene Feld bestimmt den Maschinentyp.  Der Wert 3e ist dezimal 62, was AMD64 entspricht.  Informationen zu allen Dateitypen finden Sie in <a href="" rel="nofollow">dieser</a> Header-Datei. <br><br>  Obwohl Sie all dies in einem hexadezimalen Speicherauszug ausf√ºhren k√∂nnen, ist es sinnvoll, ein Tool zu verwenden, das die Arbeit f√ºr Sie erledigt.  Das Dienstprogramm dumpelf kann n√ºtzlich sein.  Es werden formatierte Ausgaben angezeigt, die mit dem ELF-Header √ºbereinstimmen.  Es ist gut zu untersuchen, welche Felder verwendet werden und welche typischen Werte sie haben. <br><br>  Jetzt, wo wir die Bedeutung dieser Felder erkl√§rt haben, ist es an der Zeit, zu schauen, was wahre Magie hinter ihnen steckt, und mit den n√§chsten √úberschriften fortzufahren! <br><br><h3>  Dateidaten </h3><br>  Neben dem Header bestehen ELF-Dateien aus drei Teilen. <br><br><ul><li>  Programm√ºberschriften oder -segmente </li><li>  Abschnitt oder Abschnitts√ºberschriften </li><li>  Daten </li></ul><br>  Bevor wir uns mit diesen √úberschriften befassen, ist es hilfreich zu wissen, dass die ELF-Datei zwei verschiedene ‚ÄûTypen‚Äú hat.  Eine davon ist f√ºr den Linker konzipiert und erm√∂glicht die Ausf√ºhrung von Code (Segmente).  Der andere ist f√ºr Befehle und Daten (Abschnitte).  Je nach Verwendungszweck wird der entsprechende Headertyp verwendet.  Beginnen wir mit dem Programmheader, der sich in den ausf√ºhrbaren ELF-Dateien befindet. <br><br><h3>  Programmtitel </h3><br>  Eine ELF-Datei besteht aus null oder mehr Segmenten und beschreibt, wie ein Prozess erstellt wird, ein Speicherabbild f√ºr die Laufzeitausf√ºhrung.  Wenn der Kernel diese Segmente sieht, platziert er sie mithilfe des Systemaufrufs mmap (2) im virtuellen Adressraum.  Mit anderen Worten, es konvertiert vorbereitete Anweisungen in ein Bild im Speicher.  Wenn es sich bei der ELF-Datei um eine regul√§re Bin√§rdatei handelt, werden diese Programmheader ben√∂tigt, da sie sonst einfach nicht funktionieren.  Diese Header bilden zusammen mit den entsprechenden Datenstrukturen den Prozess.  F√ºr gemeinsam genutzte Bibliotheken ist der Prozess √§hnlich. <br><br><img src="https://habrastorage.org/webt/p4/ja/c_/p4jac_lojwvn9movhy8w5rad1g0.png"><br>  Programmkopf in bin√§rer ELF-Datei <br><br>  In diesem Beispiel sehen wir 9 Programmtitel.  Zun√§chst ist es schwer zu verstehen, was sie bedeuten.  Lassen Sie uns in die Details eintauchen. <br><br><h3>  GNU_EH_FRAME </h3><br>  Dies ist die sortierte Warteschlange, die vom GCC-Compiler verwendet wird.  Es speichert Ausnahmebehandlungsroutinen.  Wenn etwas schief gelaufen ist, werden sie verwendet, um die Situation richtig zu handhaben. <br><br><h3>  GNU_STACK </h3><br>  Dieser Header wird zum Speichern von Stack-Informationen verwendet.  Interessant ist, dass der Stack nicht ausf√ºhrbar sein muss, da dies zu Sicherheitsl√ºcken f√ºhren kann. <br><br>  Wenn das GNU_STACK-Segment fehlt, wird der ausf√ºhrbare Stapel verwendet.  Die Dienstprogramme scanelf und execstack zeigen die Details des Stack-Ger√§ts an. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># scanelf -e /bin/ps TYPE STK/REL/PTL FILE ET_EXEC RW- R-- RW- /bin/ps # execstack -q /bin/ps - /bin/ps</span></span></code> </pre> <br>  Befehle zum Anzeigen des Programmheaders: <br><br><ul><li>  dumpelf (pax-utils) </li><li>  Elfen -S / bin / ps </li><li>  eu-readelf -program-headers / bin / ps </li></ul><br><h3>  ELF-Abschnitte </h3><br><h4>  Abschnitts√ºberschriften </h4><br>  Abschnitts√ºberschriften definieren alle Abschnitte einer Datei.  Wie bereits erw√§hnt, werden diese Informationen zur Verlinkung und zum Umzug verwendet. <br><br>  Abschnitte werden in einer ELF-Datei angezeigt, nachdem der GNU C-Compiler C-Code in Assembler konvertiert und der GNU Assembler Objekte erstellt. <br><br>  Wie in der obigen Abbildung gezeigt, kann ein Segment aus 0 oder mehr Abschnitten bestehen.  Es gibt vier Hauptabschnitte f√ºr ausf√ºhrbare Dateien: .text, .data, .rodata und .bss.  Jeder dieser Abschnitte startet mit unterschiedlichen Berechtigungen, die mit readelf -S angezeigt werden k√∂nnen. <br><br><h4>  .text </h4><br>  Enth√§lt ausf√ºhrbaren Code.  Es wird in ein Segment mit Lese- und Ausf√ºhrungsrechten gepackt.  Es wird einmal heruntergeladen und sein Inhalt √§ndert sich nicht.  Dies kann mit dem Dienstprogramm objdump festgestellt werden. <br><br><pre> <code class="bash hljs">12 .text 0000a3e9 0000000000402120 0000000000402120 00002120 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE</code> </pre> <br><h4>  .data </h4><br>  Initialisierte Daten mit Lese- und Schreibrechten. <br><br><h4>  .rodata </h4><br>  Initialisierte Daten mit schreibgesch√ºtzten Berechtigungen.  (= A). <br><br><h4>  .bss </h4><br>  Nicht initialisierte Daten mit Lese- / Schreibberechtigungen.  (= WA) <br><br><pre> <code class="bash hljs">[24] .data PROGBITS 00000000006172e0 000172e0 0000000000000100 0000000000000000 WA 0 0 8 [25] .bss NOBITS 00000000006173e0 000173e0 0000000000021110 0000000000000000 WA 0 0 32</code> </pre> <br><br>  Befehle zum Anzeigen von Abschnitten und Titeln. <br><br><ul><li>  dumpelf </li><li>  elfls -p / bin / ps </li><li>  eu-readelf ‚Äìsection-headers / bin / ps </li><li>  readelf -S / bin / ps </li><li>  objdump -h / bin / ps </li></ul><br><h4>  Abschnittsgruppen </h4><br>  Einige Abschnitte k√∂nnen so gruppiert werden, als ob sie ein einzelnes Ganzes bilden w√ºrden.  Neue Linker unterst√ºtzen diese Funktionalit√§t.  Dies ist jedoch nicht √ºblich. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># readelf -g /bin/ps There are no section groups in this file.</span></span></code> </pre> <br>  Obwohl dies nicht sehr interessant erscheint, bietet das Wissen √ºber die ELF-Dateianalyse-Tools gro√üe Vorteile.  Aus diesem Grund finden Sie am Ende des Artikels eine √úbersicht √ºber diese Tools und ihren Zweck. <br><br><h3>  Statische und dynamische Bin√§rdateien </h3><br>  Wenn Sie mit ELF-Bin√§rdateien arbeiten, ist es hilfreich zu wissen, wie diese beiden Dateitypen verkn√ºpft sind.  Sie k√∂nnen statisch und dynamisch sein, und dies gilt f√ºr die von ihnen verwendeten Bibliotheken.  Wenn die Bin√§rdatei "dynamisch" ist, werden externe Bibliotheken verwendet, die einige allgemeine Funktionen enthalten, z. B. das √ñffnen einer Datei oder das Erstellen eines Netzwerk-Sockets.  Statische Bin√§rdateien enthalten dagegen alle erforderlichen Bibliotheken. <br><br>  Wenn Sie pr√ºfen m√∂chten, ob die Datei statisch oder dynamisch ist, verwenden Sie den Befehl file.  Sie wird so etwas zeigen: <br><br><pre> <code class="bash hljs">$ file /bin/ps /bin/ps: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), &lt;b&gt;dynamically linked (uses shared libs)&lt;/b&gt;, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.24, BuildID[sha1]=2053194ca4ee8754c695f5a7a7cff2fb8fdd297e, stripped</code> </pre> <br>  Um festzustellen, welche externen Bibliotheken verwendet werden, verwenden Sie einfach ldd f√ºr dieselbe Bin√§rdatei: <br><br><pre> <code class="bash hljs">$ ldd /bin/ps linux-vdso.so.1 =&gt; (0x00007ffe5ef0d000) libprocps.so.3 =&gt; /lib/x86_64-linux-gnu/libprocps.so.3 (0x00007f8959711000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f895934c000) /lib64/ld-linux-x86-64.so.2 (0x00007f8959935000)</code> </pre> <br>  Tipp: Um weitere Abh√§ngigkeiten anzuzeigen, ist es besser, das Dienstprogramm lddtree zu verwenden. <br><br><h2>  Tools f√ºr die bin√§re Analyse </h2><br>  Wenn Sie ELF-Dateien analysieren m√∂chten, ist es auf jeden Fall hilfreich, sich zun√§chst die vorhandenen Tools anzusehen.  Es gibt Toolkits f√ºr die umgekehrte Entwicklung von Bin√§rdateien und ausf√ºhrbarem Code.  Wenn Sie mit der Analyse von ELF-Dateien noch nicht vertraut sind, beginnen Sie mit der statischen Analyse.  Statische Analyse impliziert, dass wir Dateien untersuchen, ohne sie zu starten.  Wenn Sie beginnen, ihre Arbeit besser zu verstehen, fahren Sie mit der dynamischen Analyse fort.  F√ºhren Sie die Beispiele aus und sehen Sie sich ihr tats√§chliches Verhalten an. <br><br><h3>  Beliebte Tools </h3><br><h4>  Radare2 </h4><br>  Das Radare2-Toolkit wurde von Sergi Alvarez erstellt.  Die Zahl 2 impliziert, dass der Code im Vergleich zur ersten Version vollst√§ndig umgeschrieben wurde.  Jetzt wird es von vielen Forschern verwendet, um die Funktionsweise des Codes zu untersuchen. <br><br><h4>  Software-Pakete </h4><br>  Auf den meisten Linux-Systemen sind Binutils installiert.  Mit anderen Paketen k√∂nnen Sie weitere Informationen anzeigen.  Das richtige Toolkit vereinfacht Ihre Arbeit, insbesondere wenn Sie ELF-Dateien analysieren.  Ich habe hier eine Liste von Paketen und Dienstprogrammen zum Analysieren von ELF-Dateien zusammengestellt. <br><br>  <b>elfutils</b> <br>  / usr / bin / eu-addr2line <br>  / usr / bin / eu-ar - eine Alternative zu ar zum Erstellen und Verarbeiten von Archivdateien <br>  / usr / bin / eu-elfcmp <br>  / usr / bin / eu-elflint - √úberpr√ºfen Sie, ob die gABI- und psABI-Spezifikationen eingehalten werden <br>  / usr / bin / eu-findtextrel - Suche nach Textverlagerungen <br>  / usr / bin / eu-ld - kombiniert Objekt- und Archivdateien <br>  / usr / bin / eu-make-debug-archive <br>  / usr / bin / eu-nm - Zeigt die Symbole des Objekts und der ausf√ºhrbaren Dateien an <br>  / usr / bin / eu-objdump - Zeigt Informationen aus der Objektdatei an <br>  / usr / bin / eu-ranlib - Erstellt einen Index der Archivdateien <br>  / usr / bin / eu-readelf - Zeigt die ELF-Datei in lesbarer Form an <br>  / usr / bin / eu-size - Zeigt die Gr√∂√üe der einzelnen Abschnitte an (Text, Daten, BSS usw.). <br>  / usr / bin / eu-stack - Zeigt den Stapel des aktuellen Prozesses oder Kernel-Dumps an <br>  / usr / bin / eu-strings - zeigt Textstrings an (wie das Strings-Dienstprogramm) <br>  / usr / bin / eu-strip - Entfernt die Zeichentabelle aus der ELF-Datei <br>  / usr / bin / eu-unstrip - f√ºgt der Bin√§rdatei Symbole und Debugging-Informationen hinzu <br>  Hinweis: Das elfutils-Paket ist ein guter Anfang, es enth√§lt die meisten Analyse-Tools <br><br>  <b>Elfkicker</b> <br>  / usr / bin / ebfc - Brainfuck-Sprachcompiler <br>  / usr / bin / elfls - Zeigt Programm- und Abschnitts√ºberschriften mit Flags an <br>  / usr / bin / elftoc - konvertiert ein Bin√§rprogramm in ein C-Programm <br>  / usr / bin / infect - Ein Dienstprogramm, das eine Pipette injiziert, erstellt eine Setuid-Datei in / tmp <br>  / usr / bin / objres - Erstellt ein Objekt aus regul√§ren oder bin√§ren Daten <br>  / usr / bin / rebind - √Ñndert die Bindung und Sichtbarkeit von Zeichen in ELF-Dateien <br>  / usr / bin / sstrip - Entfernt unn√∂tige Komponenten aus einer ELF-Datei <br>  Hinweis: Der Autor des ELFKickers-Pakets konzentriert sich auf die Bearbeitung von ELF-Dateien, sodass Sie mehr Informationen erhalten, wenn Sie mit den ‚Äûfalschen‚Äú ELF-Bin√§rdateien arbeiten <br><br>  <b>pax-utils</b> <br>  / usr / bin / dumpelf - Dump der internen ELF-Struktur <br>  / usr / bin / lddtree - wie bei ldd, wobei der Grad der angezeigten Abh√§ngigkeiten festgelegt wird <br>  / usr / bin / pspax - Zeigt ELF / PaX-Informationen zu laufenden Prozessen an <br>  / usr / bin / scanelf - eine breite Palette von Informationen, einschlie√ülich PaX-Details <br>  / usr / bin / scanmacho - zeigt Details der Mach-O-Bin√§rdateien (Mac OS X) <br>  / usr / bin / symtree - zeigt Baumzeichen an <br>  Hinweis: Einige Dienstprogramme in diesem Paket k√∂nnen Verzeichnisse rekursiv durchsuchen und eignen sich ideal zum Analysieren des gesamten Inhalts eines Verzeichnisses.  Der Schwerpunkt liegt auf PaX-Recherchetools.  Zus√§tzlich zur Unterst√ºtzung von ELF k√∂nnen Sie Informationen aus Mach-O-Bin√§rdateien extrahieren. <br><br>  Ausgabebeispiel <br><pre> <code class="bash hljs">scanelf -a /bin/ps TYPE PAX PERM ENDIAN STK/REL/PTL TEXTREL RPATH BIND FILE ET_EXEC PeMRxS 0755 LE RW- R-- RW- - - LAZY /bin/ps</code> </pre> <br><br>  <b>Prelink</b> <br>  / usr / bin / execstack - Sie k√∂nnen Informationen dar√ºber anzeigen oder √§ndern, ob der Stack ausf√ºhrbar ist <br>  / usr / bin / prelink - verschiebt Aufrufe in ELF-Dateien, um den Prozess zu beschleunigen <br><br><h2>  H√§ufig gestellte Fragen </h2><br><h3>  Was ist ein ABI? </h3><br>  ABI ist die Application Binary Interface und definiert eine Low-Level-Schnittstelle zwischen dem Betriebssystem und dem ausf√ºhrbaren Code. <br><br><h3>  Was ist ELF? </h3><br>  ELF ist ein ausf√ºhrbares und verkn√ºpfbares Format.  Dies ist eine Formatspezifikation, die definiert, wie Anweisungen in ausf√ºhrbaren Code geschrieben werden. <br><br><h3>  Wie kann ich den Dateityp sehen? </h3><br>  Verwenden Sie den Befehl file f√ºr die erste Stufe der Analyse.  Dieser Befehl kann die Details anzeigen, die aus den "magischen" Zahlen und √úberschriften extrahiert wurden. <br><br><h2>  Fazit </h2><br>  ELF-Dateien dienen zur Ausf√ºhrung und Verkn√ºpfung.  Sie enthalten je nach Verwendungszweck die erforderlichen Segmente und Abschnitte.  Der Kernel des Betriebssystems durchsucht die Segmente und ordnet sie dem Speicher zu (mit mmap).  Abschnitte werden von einem Linker angezeigt, der eine ausf√ºhrbare Datei oder ein freigegebenes Objekt erstellt. <br><br>  ELF-Dateien sind sehr flexibel und unterst√ºtzen verschiedene Arten von CPUs, Maschinenarchitekturen und Betriebssystemen.  Es ist auch erweiterbar, jede Datei ist unterschiedlich gestaltet, abh√§ngig von den ben√∂tigten Teilen.  Mit den richtigen Tools k√∂nnen Sie den Zweck der Datei herausfinden und den Inhalt der Bin√§rdateien untersuchen.  Sie k√∂nnen die in der Datei enthaltenen Funktionen und Zeilen anzeigen.  Ein guter Anfang f√ºr diejenigen, die nach Malware suchen oder verstehen, warum sich der Prozess auf eine bestimmte Weise verh√§lt (oder nicht). <br><br><h2>  Ressourcen f√ºr weitere Studien </h2><br>  Wenn Sie mehr √ºber ELF und Reverse Engineering erfahren m√∂chten, k√∂nnen Sie sich die Arbeit ansehen, die wir in Linux Security Expert leisten.  Im Rahmen des Lehrplans verf√ºgen wir √ºber <a href="https://linuxsecurity.expert/training/domains/reverse-engineering" rel="nofollow">ein Reverse Engineering-Modul</a> mit praktischer Laborarbeit. <br><br>  F√ºr diejenigen unter Ihnen, die es lieben zu lesen, ein gutes und tiefes Dokument: <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf" rel="nofollow">ELF Format</a> und ein <a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt" rel="nofollow">von</a> Brian Raiter <a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt" rel="nofollow">verfasster</a> Artikel, auch bekannt als ELFkickers.  Wer die Quelle verstehen m√∂chte, sollte sich den <a href="" rel="nofollow">dokumentierten ELF-Header von</a> Apple ansehen. <br><br>  Tipp: <br>  Wenn Sie das Analysieren von Dateien verbessern m√∂chten, k√∂nnen Sie die <a href="https://linuxsecurity.expert/security-tools/binary-analysis-tools" rel="nofollow">g√§ngigen Analysetools verwenden</a> , die derzeit verf√ºgbar sind. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480642/">https://habr.com/ru/post/de480642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480614/index.html">Schnelle ENUM</a></li>
<li><a href="../de480618/index.html">Elektronisches Spiel Tic Tac Toe. Zu was bin ich gekommen?</a></li>
<li><a href="../de480620/index.html">SD-WAN und DNA zur Unterst√ºtzung des Administrators: Merkmale von Architekturen und Verfahren</a></li>
<li><a href="../de480622/index.html">So nutzen Sie die verf√ºgbare Speicherkapazit√§t richtig</a></li>
<li><a href="../de480626/index.html">Vererbung von Altsystemen und -prozessen oder Die ersten 90 Tage als CTO</a></li>
<li><a href="../de480644/index.html">Das Manifest zur Abschaffung von 146 des Strafgesetzbuches und der Boykott von Sberbank und Urheberrechtsinhabern-Parasiten. F√ºr Open Source und Nginx</a></li>
<li><a href="../de480646/index.html">Habr - beste Artikel, Autoren und Statistiken 2019</a></li>
<li><a href="../de480650/index.html">Wessen Haar ist st√§rker: Haarmorphologie</a></li>
<li><a href="../de480652/index.html">250 Meter PoE-Kamera √ºber Kabel - das ist m√∂glich</a></li>
<li><a href="../de480654/index.html">Wird Julia Python genauso schlagen wie Python Java?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>