<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌱 🐆 ☝️ Einführung in Linux ELFs: Verstehen und Analysieren 🚭 👋 🤓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt Dinge auf der Welt, die wir für selbstverständlich halten, obwohl sie wahre Meisterwerke sind. Eine solche Sache sind Linux-Dienstprogramme wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in Linux ELFs: Verstehen und Analysieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480642/"> Es gibt Dinge auf der Welt, die wir für selbstverständlich halten, obwohl sie wahre Meisterwerke sind.  Eine solche Sache sind Linux-Dienstprogramme wie ls und ps.  Obwohl sie normalerweise als einfach empfunden werden, ist dies weit davon entfernt, wenn wir nach innen schauen.  Und ELF, Executable und Linkable Format auch.  Ein Dateiformat, das universell verwendet wird, aber nur wenige verstehen es.  Diese Kurzanleitung hilft Ihnen beim Verständnis. <br><br><img src="https://habrastorage.org/webt/ka/0m/em/ka0memy9zppvjiut58hua0_cyt8.jpeg"><br><br>  Nachdem Sie diesen Leitfaden gelesen haben, lernen Sie Folgendes: <br><br><ul><li>  Warum wird das ELF-Format benötigt und für welche Dateitypen wird es verwendet? </li><li>  ELF-Dateistruktur und Formatdetails </li><li>  Lesen und Analysieren des binären Inhalts einer ELF-Datei </li><li>  Mit welchen Tools werden Binärdateien analysiert? </li></ul><a name="habracut"></a><br><h2>  Was ist eine ELF-Datei? </h2><br>  ELF steht für Executable and Linkable Format und definiert die Struktur von Binärdateien, Bibliotheken und Kerndateien.  Die Formatspezifikation ermöglicht es dem Betriebssystem, die in der Datei enthaltenen Maschinenanweisungen korrekt zu interpretieren.  Eine ELF-Datei ist normalerweise die Ausgabedatei eines Compilers oder Linkers und hat ein Binärformat.  Mit geeigneten Werkzeugen kann es analysiert und untersucht werden. <br><br><h3>  Warum ELF im Detail studieren? </h3><br>  Bevor wir uns mit den technischen Details befassen, werden wir Ihnen unbedingt erklären, warum das Verständnis des ELF-Formats nützlich ist.  Erstens können Sie den internen Betrieb des Betriebssystems untersuchen.  Wenn etwas schief gelaufen ist, können Sie mit diesem Wissen besser nachvollziehen, was genau und aus welchem ​​Grund passiert ist.  Die Möglichkeit, ELF-Dateien zu untersuchen, kann auch hilfreich sein, um Sicherheitslücken zu finden und verdächtige Dateien zu erkennen.  Und schließlich zum besseren Verständnis des Entwicklungsprozesses.  Selbst wenn Sie in einer höheren Sprache wie Go programmieren, wissen Sie immer noch besser, was sich hinter den Kulissen abspielt. <br><br>  Warum also ELF studieren? <br><br><ul><li>  Für ein allgemeines Verständnis des Betriebssystems </li><li>  Für die Softwareentwicklung </li><li>  Digitale Forensik und Incident Response (DFIR) </li><li>  Malware-Recherche (Binäranalyse) </li></ul><br><h3>  Von der Quelle zum Prozess </h3><br>  Welches Betriebssystem wir auch verwenden, es ist notwendig, die Quellcodefunktionen in die CPU-Sprache zu übersetzen - Maschinencode.  Die einfachsten Funktionen können beispielsweise das Öffnen einer Datei auf der Festplatte oder das Anzeigen von Elementen auf dem Bildschirm sein.  Anstatt die CPU-Sprache direkt zu verwenden, verwenden wir eine Programmiersprache mit Standardfunktionen.  Der Compiler übersetzt diese Funktionen dann in Objektcode.  Dieser Objektcode wird dann über den Linker in das gesamte Programm eingebunden.  Das Ergebnis ist eine Binärdatei, die auf einer bestimmten Plattform und einem bestimmten CPU-Typ ausgeführt werden kann. <br><br><h3>  Bevor du anfängst </h3><br>  Dieser Beitrag enthält viele Teams.  Es ist besser, sie auf einem Testcomputer auszuführen.  Kopieren Sie vorhandene Binärdateien, bevor Sie diese Befehle ausführen.  Wir werden auch ein kleines C-Programm schreiben, das Sie kompilieren können.  Letztendlich ist Übung der beste Weg, etwas zu lernen. <br><br><h2>  Anatomie einer ELF-Datei </h2><br>  Ein häufiges Missverständnis ist, dass ELF-Dateien nur für binäre oder ausführbare Dateien sind.  Wir haben bereits gesagt, dass sie für Teile von ausführbaren Dateien (Objektcode) verwendet werden können.  Ein weiteres Beispiel sind Bibliotheksdateien und Core-Dumps (Core-Dateien und a.out-Dateien).  Die ELF-Spezifikation wird auch unter Linux für Kernel und Kernelmodule verwendet. <br><br><img src="https://habrastorage.org/webt/dt/5y/vq/dt5yvqm-oju3s6todxbbd6ivzw0.png"><br><br><h3>  Struktur </h3><br>  Aufgrund der Erweiterbarkeit von ELF-Dateien kann die Struktur für verschiedene Dateien variieren.  Die ELF-Datei besteht aus: <br><br><ol><li>  ELF-Header </li><li>  Daten </li></ol><br>  Mit dem Befehl readelf können wir uns die Dateistruktur ansehen und sie sieht ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/vo/ng/w-/vongw-d8cy_mvkf9jgcizbdpq0c.png"><br><br><h3>  ELF-Header </h3><br>  Wie Sie auf dem Screenshot sehen können, beginnt der ELF-Header mit einer „magischen Zahl“.  Diese "magische Zahl" gibt Auskunft über die Datei.  Die ersten 4 Bytes legen fest, dass es sich um eine ELF-Datei handelt (45 = E, 4c = L, 46 = F, vor 7f). <br><br>  Der ELF-Header ist erforderlich.  Dies ist erforderlich, damit die Daten während der Verknüpfung und Ausführung korrekt interpretiert werden.  Zum besseren Verständnis des internen Betriebs einer ELF-Datei ist es hilfreich zu wissen, wofür diese Informationen verwendet werden. <br><br><h3>  Klasse </h3><br>  Nach der Deklaration eines ELF-Typs folgt ein Klassenfeld.  Dieser Wert gibt die Architektur an, für die die Datei bestimmt ist.  Dies kann 01 (32-Bit-Architektur) oder 02 (64-Bit) sein.  Hier sehen wir 02, das vom Befehl readelf als ELF64-Datei übersetzt wird, dh, diese Datei verwendet eine 64-Bit-Architektur.  Das ist nicht verwunderlich, denn in meinem Auto ist ein moderner Prozessor verbaut. <br><br><h3>  Daten </h3><br>  Als nächstes folgt das Datenfeld mit zwei Optionen: 01 - LSB (Least Significant Bit), auch bekannt als Little-Endian, oder 02 - MSB (Most Significant Bit, Big-Endian).  Diese Werte helfen bei der Interpretation der übrigen Objekte in der Datei.  Dies ist wichtig, da unterschiedliche Prozessortypen unterschiedlich mit Datenstrukturen umgehen.  In unserem Fall wird LSB verwendet, da der Prozessor eine AMD64-Architektur hat. <br><br>  Der LSB-Effekt wird sichtbar, wenn das Hexdump-Dienstprogramm für eine Binärdatei verwendet wird.  Sehen wir uns den ELF-Header für / bin / ps an. <br><br><pre><code class="bash hljs">$ hexdump -n 16 /bin/ps 0000000 457f 464c 0102 0001 0000 0000 0000 0000 0000010</code> </pre> <br>  Wir sehen, dass die Wertepaare aufgrund der Interpretation der Datenreihenfolge unterschiedlich sind. <br><br><h3>  Version </h3><br>  Dann folgt ein weiterer magischer Wert "01", der die Versionsnummer ist.  Derzeit ist nur die Version 01 verfügbar, daher bedeutet diese Nummer nichts Interessantes. <br><br><h3>  OS / ABI </h3><br>  Jedes Betriebssystem hat seine eigene Art, Funktionen aufzurufen, sie haben viele Gemeinsamkeiten, aber darüber hinaus weist jedes System kleine Unterschiede auf.  Die Reihenfolge des Funktionsaufrufs wird durch das Application Binary Interface (ABI) festgelegt.  Die OS / ABI-Felder beschreiben, welches ABI verwendet wird und in welcher Version.  In unserem Fall ist der Wert 00, was bedeutet, dass bestimmte Erweiterungen nicht verwendet werden.  In der Ausgabe wird dies als System V angezeigt. <br><br><h3>  ABI-Version </h3><br>  Bei Bedarf kann eine ABI-Version angegeben werden. <br><br><h3>  Auto </h3><br>  Der Titel gibt auch den erwarteten Maschinentyp (AMD64) an. <br><br><h3>  Typ </h3><br>  Das Feld Typ gibt an, wofür die Datei bestimmt ist.  Hier sind einige gebräuchliche Dateitypen. <br><br>  KERN (Wert 4) <br>  DYN (Shared Object File), Bibliothek (Wert 3) <br>  EXEC (ausführbare Datei), ausführbare Datei (Wert 2) <br>  REL (Relocatable file), Datei vor dem Verknüpfen (Wert 1) <br><br><h3>  Siehe den vollständigen Titel </h3><br>  Obwohl einige Felder über readelf angezeigt werden können, gibt es tatsächlich mehr.  Sie können beispielsweise herausfinden, für welchen Prozessor die Datei bestimmt ist.  Verwenden Sie hexdump, um den vollständigen ELF-Header und alle Werte anzuzeigen. <br><br><pre> <code class="bash hljs">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............| 02 00 3e 00 01 00 00 00 a8 2b 40 00 00 00 00 00 |..&gt;......+@.....| 40 00 00 00 00 00 00 00 30 65 01 00 00 00 00 00 |@.......0e......| 00 00 00 00 40 00 38 00 09 00 40 00 1c 00 1b 00 |....@.8...@.....|</code> </pre> <br>  (Ausgabe hexdump -C -n 64 / bin / ps) <br><br>  Das hervorgehobene Feld bestimmt den Maschinentyp.  Der Wert 3e ist dezimal 62, was AMD64 entspricht.  Informationen zu allen Dateitypen finden Sie in <a href="" rel="nofollow">dieser</a> Header-Datei. <br><br>  Obwohl Sie all dies in einem hexadezimalen Speicherauszug ausführen können, ist es sinnvoll, ein Tool zu verwenden, das die Arbeit für Sie erledigt.  Das Dienstprogramm dumpelf kann nützlich sein.  Es werden formatierte Ausgaben angezeigt, die mit dem ELF-Header übereinstimmen.  Es ist gut zu untersuchen, welche Felder verwendet werden und welche typischen Werte sie haben. <br><br>  Jetzt, wo wir die Bedeutung dieser Felder erklärt haben, ist es an der Zeit, zu schauen, was wahre Magie hinter ihnen steckt, und mit den nächsten Überschriften fortzufahren! <br><br><h3>  Dateidaten </h3><br>  Neben dem Header bestehen ELF-Dateien aus drei Teilen. <br><br><ul><li>  Programmüberschriften oder -segmente </li><li>  Abschnitt oder Abschnittsüberschriften </li><li>  Daten </li></ul><br>  Bevor wir uns mit diesen Überschriften befassen, ist es hilfreich zu wissen, dass die ELF-Datei zwei verschiedene „Typen“ hat.  Eine davon ist für den Linker konzipiert und ermöglicht die Ausführung von Code (Segmente).  Der andere ist für Befehle und Daten (Abschnitte).  Je nach Verwendungszweck wird der entsprechende Headertyp verwendet.  Beginnen wir mit dem Programmheader, der sich in den ausführbaren ELF-Dateien befindet. <br><br><h3>  Programmtitel </h3><br>  Eine ELF-Datei besteht aus null oder mehr Segmenten und beschreibt, wie ein Prozess erstellt wird, ein Speicherabbild für die Laufzeitausführung.  Wenn der Kernel diese Segmente sieht, platziert er sie mithilfe des Systemaufrufs mmap (2) im virtuellen Adressraum.  Mit anderen Worten, es konvertiert vorbereitete Anweisungen in ein Bild im Speicher.  Wenn es sich bei der ELF-Datei um eine reguläre Binärdatei handelt, werden diese Programmheader benötigt, da sie sonst einfach nicht funktionieren.  Diese Header bilden zusammen mit den entsprechenden Datenstrukturen den Prozess.  Für gemeinsam genutzte Bibliotheken ist der Prozess ähnlich. <br><br><img src="https://habrastorage.org/webt/p4/ja/c_/p4jac_lojwvn9movhy8w5rad1g0.png"><br>  Programmkopf in binärer ELF-Datei <br><br>  In diesem Beispiel sehen wir 9 Programmtitel.  Zunächst ist es schwer zu verstehen, was sie bedeuten.  Lassen Sie uns in die Details eintauchen. <br><br><h3>  GNU_EH_FRAME </h3><br>  Dies ist die sortierte Warteschlange, die vom GCC-Compiler verwendet wird.  Es speichert Ausnahmebehandlungsroutinen.  Wenn etwas schief gelaufen ist, werden sie verwendet, um die Situation richtig zu handhaben. <br><br><h3>  GNU_STACK </h3><br>  Dieser Header wird zum Speichern von Stack-Informationen verwendet.  Interessant ist, dass der Stack nicht ausführbar sein muss, da dies zu Sicherheitslücken führen kann. <br><br>  Wenn das GNU_STACK-Segment fehlt, wird der ausführbare Stapel verwendet.  Die Dienstprogramme scanelf und execstack zeigen die Details des Stack-Geräts an. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># scanelf -e /bin/ps TYPE STK/REL/PTL FILE ET_EXEC RW- R-- RW- /bin/ps # execstack -q /bin/ps - /bin/ps</span></span></code> </pre> <br>  Befehle zum Anzeigen des Programmheaders: <br><br><ul><li>  dumpelf (pax-utils) </li><li>  Elfen -S / bin / ps </li><li>  eu-readelf -program-headers / bin / ps </li></ul><br><h3>  ELF-Abschnitte </h3><br><h4>  Abschnittsüberschriften </h4><br>  Abschnittsüberschriften definieren alle Abschnitte einer Datei.  Wie bereits erwähnt, werden diese Informationen zur Verlinkung und zum Umzug verwendet. <br><br>  Abschnitte werden in einer ELF-Datei angezeigt, nachdem der GNU C-Compiler C-Code in Assembler konvertiert und der GNU Assembler Objekte erstellt. <br><br>  Wie in der obigen Abbildung gezeigt, kann ein Segment aus 0 oder mehr Abschnitten bestehen.  Es gibt vier Hauptabschnitte für ausführbare Dateien: .text, .data, .rodata und .bss.  Jeder dieser Abschnitte startet mit unterschiedlichen Berechtigungen, die mit readelf -S angezeigt werden können. <br><br><h4>  .text </h4><br>  Enthält ausführbaren Code.  Es wird in ein Segment mit Lese- und Ausführungsrechten gepackt.  Es wird einmal heruntergeladen und sein Inhalt ändert sich nicht.  Dies kann mit dem Dienstprogramm objdump festgestellt werden. <br><br><pre> <code class="bash hljs">12 .text 0000a3e9 0000000000402120 0000000000402120 00002120 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE</code> </pre> <br><h4>  .data </h4><br>  Initialisierte Daten mit Lese- und Schreibrechten. <br><br><h4>  .rodata </h4><br>  Initialisierte Daten mit schreibgeschützten Berechtigungen.  (= A). <br><br><h4>  .bss </h4><br>  Nicht initialisierte Daten mit Lese- / Schreibberechtigungen.  (= WA) <br><br><pre> <code class="bash hljs">[24] .data PROGBITS 00000000006172e0 000172e0 0000000000000100 0000000000000000 WA 0 0 8 [25] .bss NOBITS 00000000006173e0 000173e0 0000000000021110 0000000000000000 WA 0 0 32</code> </pre> <br><br>  Befehle zum Anzeigen von Abschnitten und Titeln. <br><br><ul><li>  dumpelf </li><li>  elfls -p / bin / ps </li><li>  eu-readelf –section-headers / bin / ps </li><li>  readelf -S / bin / ps </li><li>  objdump -h / bin / ps </li></ul><br><h4>  Abschnittsgruppen </h4><br>  Einige Abschnitte können so gruppiert werden, als ob sie ein einzelnes Ganzes bilden würden.  Neue Linker unterstützen diese Funktionalität.  Dies ist jedoch nicht üblich. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># readelf -g /bin/ps There are no section groups in this file.</span></span></code> </pre> <br>  Obwohl dies nicht sehr interessant erscheint, bietet das Wissen über die ELF-Dateianalyse-Tools große Vorteile.  Aus diesem Grund finden Sie am Ende des Artikels eine Übersicht über diese Tools und ihren Zweck. <br><br><h3>  Statische und dynamische Binärdateien </h3><br>  Wenn Sie mit ELF-Binärdateien arbeiten, ist es hilfreich zu wissen, wie diese beiden Dateitypen verknüpft sind.  Sie können statisch und dynamisch sein, und dies gilt für die von ihnen verwendeten Bibliotheken.  Wenn die Binärdatei "dynamisch" ist, werden externe Bibliotheken verwendet, die einige allgemeine Funktionen enthalten, z. B. das Öffnen einer Datei oder das Erstellen eines Netzwerk-Sockets.  Statische Binärdateien enthalten dagegen alle erforderlichen Bibliotheken. <br><br>  Wenn Sie prüfen möchten, ob die Datei statisch oder dynamisch ist, verwenden Sie den Befehl file.  Sie wird so etwas zeigen: <br><br><pre> <code class="bash hljs">$ file /bin/ps /bin/ps: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), &lt;b&gt;dynamically linked (uses shared libs)&lt;/b&gt;, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.24, BuildID[sha1]=2053194ca4ee8754c695f5a7a7cff2fb8fdd297e, stripped</code> </pre> <br>  Um festzustellen, welche externen Bibliotheken verwendet werden, verwenden Sie einfach ldd für dieselbe Binärdatei: <br><br><pre> <code class="bash hljs">$ ldd /bin/ps linux-vdso.so.1 =&gt; (0x00007ffe5ef0d000) libprocps.so.3 =&gt; /lib/x86_64-linux-gnu/libprocps.so.3 (0x00007f8959711000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f895934c000) /lib64/ld-linux-x86-64.so.2 (0x00007f8959935000)</code> </pre> <br>  Tipp: Um weitere Abhängigkeiten anzuzeigen, ist es besser, das Dienstprogramm lddtree zu verwenden. <br><br><h2>  Tools für die binäre Analyse </h2><br>  Wenn Sie ELF-Dateien analysieren möchten, ist es auf jeden Fall hilfreich, sich zunächst die vorhandenen Tools anzusehen.  Es gibt Toolkits für die umgekehrte Entwicklung von Binärdateien und ausführbarem Code.  Wenn Sie mit der Analyse von ELF-Dateien noch nicht vertraut sind, beginnen Sie mit der statischen Analyse.  Statische Analyse impliziert, dass wir Dateien untersuchen, ohne sie zu starten.  Wenn Sie beginnen, ihre Arbeit besser zu verstehen, fahren Sie mit der dynamischen Analyse fort.  Führen Sie die Beispiele aus und sehen Sie sich ihr tatsächliches Verhalten an. <br><br><h3>  Beliebte Tools </h3><br><h4>  Radare2 </h4><br>  Das Radare2-Toolkit wurde von Sergi Alvarez erstellt.  Die Zahl 2 impliziert, dass der Code im Vergleich zur ersten Version vollständig umgeschrieben wurde.  Jetzt wird es von vielen Forschern verwendet, um die Funktionsweise des Codes zu untersuchen. <br><br><h4>  Software-Pakete </h4><br>  Auf den meisten Linux-Systemen sind Binutils installiert.  Mit anderen Paketen können Sie weitere Informationen anzeigen.  Das richtige Toolkit vereinfacht Ihre Arbeit, insbesondere wenn Sie ELF-Dateien analysieren.  Ich habe hier eine Liste von Paketen und Dienstprogrammen zum Analysieren von ELF-Dateien zusammengestellt. <br><br>  <b>elfutils</b> <br>  / usr / bin / eu-addr2line <br>  / usr / bin / eu-ar - eine Alternative zu ar zum Erstellen und Verarbeiten von Archivdateien <br>  / usr / bin / eu-elfcmp <br>  / usr / bin / eu-elflint - Überprüfen Sie, ob die gABI- und psABI-Spezifikationen eingehalten werden <br>  / usr / bin / eu-findtextrel - Suche nach Textverlagerungen <br>  / usr / bin / eu-ld - kombiniert Objekt- und Archivdateien <br>  / usr / bin / eu-make-debug-archive <br>  / usr / bin / eu-nm - Zeigt die Symbole des Objekts und der ausführbaren Dateien an <br>  / usr / bin / eu-objdump - Zeigt Informationen aus der Objektdatei an <br>  / usr / bin / eu-ranlib - Erstellt einen Index der Archivdateien <br>  / usr / bin / eu-readelf - Zeigt die ELF-Datei in lesbarer Form an <br>  / usr / bin / eu-size - Zeigt die Größe der einzelnen Abschnitte an (Text, Daten, BSS usw.). <br>  / usr / bin / eu-stack - Zeigt den Stapel des aktuellen Prozesses oder Kernel-Dumps an <br>  / usr / bin / eu-strings - zeigt Textstrings an (wie das Strings-Dienstprogramm) <br>  / usr / bin / eu-strip - Entfernt die Zeichentabelle aus der ELF-Datei <br>  / usr / bin / eu-unstrip - fügt der Binärdatei Symbole und Debugging-Informationen hinzu <br>  Hinweis: Das elfutils-Paket ist ein guter Anfang, es enthält die meisten Analyse-Tools <br><br>  <b>Elfkicker</b> <br>  / usr / bin / ebfc - Brainfuck-Sprachcompiler <br>  / usr / bin / elfls - Zeigt Programm- und Abschnittsüberschriften mit Flags an <br>  / usr / bin / elftoc - konvertiert ein Binärprogramm in ein C-Programm <br>  / usr / bin / infect - Ein Dienstprogramm, das eine Pipette injiziert, erstellt eine Setuid-Datei in / tmp <br>  / usr / bin / objres - Erstellt ein Objekt aus regulären oder binären Daten <br>  / usr / bin / rebind - Ändert die Bindung und Sichtbarkeit von Zeichen in ELF-Dateien <br>  / usr / bin / sstrip - Entfernt unnötige Komponenten aus einer ELF-Datei <br>  Hinweis: Der Autor des ELFKickers-Pakets konzentriert sich auf die Bearbeitung von ELF-Dateien, sodass Sie mehr Informationen erhalten, wenn Sie mit den „falschen“ ELF-Binärdateien arbeiten <br><br>  <b>pax-utils</b> <br>  / usr / bin / dumpelf - Dump der internen ELF-Struktur <br>  / usr / bin / lddtree - wie bei ldd, wobei der Grad der angezeigten Abhängigkeiten festgelegt wird <br>  / usr / bin / pspax - Zeigt ELF / PaX-Informationen zu laufenden Prozessen an <br>  / usr / bin / scanelf - eine breite Palette von Informationen, einschließlich PaX-Details <br>  / usr / bin / scanmacho - zeigt Details der Mach-O-Binärdateien (Mac OS X) <br>  / usr / bin / symtree - zeigt Baumzeichen an <br>  Hinweis: Einige Dienstprogramme in diesem Paket können Verzeichnisse rekursiv durchsuchen und eignen sich ideal zum Analysieren des gesamten Inhalts eines Verzeichnisses.  Der Schwerpunkt liegt auf PaX-Recherchetools.  Zusätzlich zur Unterstützung von ELF können Sie Informationen aus Mach-O-Binärdateien extrahieren. <br><br>  Ausgabebeispiel <br><pre> <code class="bash hljs">scanelf -a /bin/ps TYPE PAX PERM ENDIAN STK/REL/PTL TEXTREL RPATH BIND FILE ET_EXEC PeMRxS 0755 LE RW- R-- RW- - - LAZY /bin/ps</code> </pre> <br><br>  <b>Prelink</b> <br>  / usr / bin / execstack - Sie können Informationen darüber anzeigen oder ändern, ob der Stack ausführbar ist <br>  / usr / bin / prelink - verschiebt Aufrufe in ELF-Dateien, um den Prozess zu beschleunigen <br><br><h2>  Häufig gestellte Fragen </h2><br><h3>  Was ist ein ABI? </h3><br>  ABI ist die Application Binary Interface und definiert eine Low-Level-Schnittstelle zwischen dem Betriebssystem und dem ausführbaren Code. <br><br><h3>  Was ist ELF? </h3><br>  ELF ist ein ausführbares und verknüpfbares Format.  Dies ist eine Formatspezifikation, die definiert, wie Anweisungen in ausführbaren Code geschrieben werden. <br><br><h3>  Wie kann ich den Dateityp sehen? </h3><br>  Verwenden Sie den Befehl file für die erste Stufe der Analyse.  Dieser Befehl kann die Details anzeigen, die aus den "magischen" Zahlen und Überschriften extrahiert wurden. <br><br><h2>  Fazit </h2><br>  ELF-Dateien dienen zur Ausführung und Verknüpfung.  Sie enthalten je nach Verwendungszweck die erforderlichen Segmente und Abschnitte.  Der Kernel des Betriebssystems durchsucht die Segmente und ordnet sie dem Speicher zu (mit mmap).  Abschnitte werden von einem Linker angezeigt, der eine ausführbare Datei oder ein freigegebenes Objekt erstellt. <br><br>  ELF-Dateien sind sehr flexibel und unterstützen verschiedene Arten von CPUs, Maschinenarchitekturen und Betriebssystemen.  Es ist auch erweiterbar, jede Datei ist unterschiedlich gestaltet, abhängig von den benötigten Teilen.  Mit den richtigen Tools können Sie den Zweck der Datei herausfinden und den Inhalt der Binärdateien untersuchen.  Sie können die in der Datei enthaltenen Funktionen und Zeilen anzeigen.  Ein guter Anfang für diejenigen, die nach Malware suchen oder verstehen, warum sich der Prozess auf eine bestimmte Weise verhält (oder nicht). <br><br><h2>  Ressourcen für weitere Studien </h2><br>  Wenn Sie mehr über ELF und Reverse Engineering erfahren möchten, können Sie sich die Arbeit ansehen, die wir in Linux Security Expert leisten.  Im Rahmen des Lehrplans verfügen wir über <a href="https://linuxsecurity.expert/training/domains/reverse-engineering" rel="nofollow">ein Reverse Engineering-Modul</a> mit praktischer Laborarbeit. <br><br>  Für diejenigen unter Ihnen, die es lieben zu lesen, ein gutes und tiefes Dokument: <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf" rel="nofollow">ELF Format</a> und ein <a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt" rel="nofollow">von</a> Brian Raiter <a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt" rel="nofollow">verfasster</a> Artikel, auch bekannt als ELFkickers.  Wer die Quelle verstehen möchte, sollte sich den <a href="" rel="nofollow">dokumentierten ELF-Header von</a> Apple ansehen. <br><br>  Tipp: <br>  Wenn Sie das Analysieren von Dateien verbessern möchten, können Sie die <a href="https://linuxsecurity.expert/security-tools/binary-analysis-tools" rel="nofollow">gängigen Analysetools verwenden</a> , die derzeit verfügbar sind. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480642/">https://habr.com/ru/post/de480642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480614/index.html">Schnelle ENUM</a></li>
<li><a href="../de480618/index.html">Elektronisches Spiel Tic Tac Toe. Zu was bin ich gekommen?</a></li>
<li><a href="../de480620/index.html">SD-WAN und DNA zur Unterstützung des Administrators: Merkmale von Architekturen und Verfahren</a></li>
<li><a href="../de480622/index.html">So nutzen Sie die verfügbare Speicherkapazität richtig</a></li>
<li><a href="../de480626/index.html">Vererbung von Altsystemen und -prozessen oder Die ersten 90 Tage als CTO</a></li>
<li><a href="../de480644/index.html">Das Manifest zur Abschaffung von 146 des Strafgesetzbuches und der Boykott von Sberbank und Urheberrechtsinhabern-Parasiten. Für Open Source und Nginx</a></li>
<li><a href="../de480646/index.html">Habr - beste Artikel, Autoren und Statistiken 2019</a></li>
<li><a href="../de480650/index.html">Wessen Haar ist stärker: Haarmorphologie</a></li>
<li><a href="../de480652/index.html">250 Meter PoE-Kamera über Kabel - das ist möglich</a></li>
<li><a href="../de480654/index.html">Wird Julia Python genauso schlagen wie Python Java?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>