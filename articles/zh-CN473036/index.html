<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏼 ✈️ 🤔 茶壶提供的Android Camera2 API，第3部分。媒体编解码器和UDP流视频 🚸 🥅 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="因此，我们有点想出了如何使用Camera2 API拍照和录制视频。 剩下的只是学习如何将视频流从Android设备传输到外部受苦的接收者。 正如之前反复提到的，最终目标是机器人的智能化-我们在上面安装了智能手机，可以说，将猴子变成了人。 媒体编解码器将为此提供帮助。 当然还有新的Camera2 AP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>茶壶提供的Android Camera2 API，第3部分。媒体编解码器和UDP流视频</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473036/">因此，我们有点想出了如何使用Camera2 API拍照和录制视频。 剩下的只是学习如何将视频流从Android设备传输到外部受苦的接收者。 正如之前反复提到的，最终目标是机器人的智能化-我们在上面安装了智能手机，可以说，将猴子变成了人。 媒体编解码器将为此提供帮助。 当然还有新的Camera2 API。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/tl/mf/satlmfdhbe-ow-gywoc5-tuxupe.jpeg"></div><br> 谁在乎，请在猫下。 <br><a name="habracut"></a><br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到有关机器人项目的详细信息，但就<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目前而言</a> ，我们将直接将视频（或与其连接的Android智能手机）流式传输到个人电子计算机。 <br><br><h4> 为此我们需要什么？ </h4><br> 如您所知，为了将视频流从智能手机屏幕传输到其他地方，首先需要将其（流）转换为合适的压缩格式（它太厚，无法逐帧传输），设置时间戳（时间戳）并以二进制形式发送给接收者。 它将执行逆解码操作。 <br><br> 从2013年Android 4.3发行之日起，Media Codec类就一直在处理这些低级的黑手党。 <br><br><img src="https://habrastorage.org/webt/ci/oz/xq/ciozxqlqwq8hecadsrkn0-8me6m.png"><br><br> 另一件事是，与今天不同的是，较早采用视频编码并不是那么简单。 为了从相机上获取图片，有必要使用大量的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">神秘密码</a> ，其中唯一的错误可能导致应用程序彻底崩溃，就像Yakut萨满巫师的咒语一样。 再加上以前的Camera API，您必须自己编写不同的同步笔，而不是现成的回调，并且此活动不适合胆小的人。 <br><br> 最重要的是，您从远处看工作<a href="">代码，</a>从总体上看，一切似乎都很清楚。 您开始将零件转移到您的项目中-目前尚不清楚为什么要浇筑它。 但是，由于难以理解细节，因此无法纠正。 <br><br> 是的，并且从固体中以某种方式轻松<s>过时</s> 。 简而言之，一团糟 <br><br> 幸运的是，对于那些机智的人，Google建设者已经引入了<b>Surface</b>的神奇概念，通过它可以避免出现底层细节。 作为开发人员，我付出了什么代价，却输了什么钱，这对我来说是很难理解的，但是现在我们几乎可以直言不讳地说：“ Android，将这个Surface摄像头的视频显示在此Surface上，而无需更改其中的任何代码并继续发送。” 最令人惊奇的是，它有效。 有了新的Camera2 API，程序本身就知道何时发送数据，出现了新的回调！ <br><br> 所以现在要编码视频-随地吐痰。 我们现在要做什么。 <br> 我们从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一篇文章中</a>获取代码，并且像往常一样，将所有内容扔掉，除了按钮和相机初始化外。 <br><br><div class="spoiler">  <b class="spoiler_title">让我们从应用程序的布局开始。</b> <div class="spoiler_text"><pre><code class="java hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span> xmlns:app=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span> xmlns:tools=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/tools"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> tools:context=<span class="hljs-string"><span class="hljs-string">".MainActivity"</span></span>&gt; &lt;TextureView android:id=<span class="hljs-string"><span class="hljs-string">"@+id/textureView"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"356dp"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"410dp"</span></span> android:layout_marginTop=<span class="hljs-string"><span class="hljs-string">"32dp"</span></span> app:layout_constraintEnd_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintHorizontal_bias=<span class="hljs-string"><span class="hljs-string">"0.49"</span></span> app:layout_constraintStart_toStartOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintTop_toTopOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> /&gt; &lt;LinearLayout android:layout_width=<span class="hljs-string"><span class="hljs-string">"292dp"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"145dp"</span></span> android:layout_marginStart=<span class="hljs-string"><span class="hljs-string">"16dp"</span></span> android:orientation=<span class="hljs-string"><span class="hljs-string">"vertical"</span></span> app:layout_constraintBottom_toBottomOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintEnd_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintStart_toStartOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintTop_toBottomOf=<span class="hljs-string"><span class="hljs-string">"@+id/textureView"</span></span> app:layout_constraintVertical_bias=<span class="hljs-string"><span class="hljs-string">"0.537"</span></span>&gt; &lt;Button android:id=<span class="hljs-string"><span class="hljs-string">"@+id/button1"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:text=<span class="hljs-string"><span class="hljs-string">"   "</span></span> /&gt; &lt;Button android:id=<span class="hljs-string"><span class="hljs-string">"@+id/button2"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:text=<span class="hljs-string"><span class="hljs-string">" "</span></span> /&gt; &lt;Button android:id=<span class="hljs-string"><span class="hljs-string">"@+id/button3"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:text=<span class="hljs-string"><span class="hljs-string">" "</span></span> /&gt; &lt;/LinearLayout&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code> </pre> <br></div></div><br><h4> 并以Media Codec挂钩结束 </h4><br> 在上一篇文章中，我们在Surface上显示了来自摄像头的图像，并使用MediaRecorder编写了视频。 为此，我们只需在“曲面”列表中指定两个组件。 <br><br><pre> <code class="java hljs">(Arrays.asList(surface, mMediaRecorder.getSurface()).</code> </pre><br> 这是同一件事，我们只指定mMediaRecorder而不是： <br><br><pre> <code class="java hljs">(Arrays.asList(surface, mEncoderSurface),</code> </pre><br> 原来是这样的： <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startCameraPreviewSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SurfaceTexture texture = mImageView.getSurfaceTexture(); texture.setDefaultBufferSize(<span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>); surface = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Surface(texture); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewBuilder.addTarget(surface); mPreviewBuilder.addTarget(mEncoderSurface); mCameraDevice.createCaptureSession(Arrays.asList(surface, mEncoderSurface), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CameraCaptureSession.StateCallback() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ mSession = session; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mSession.setRepeatingRequest(mPreviewBuilder.build(), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, mBackgroundHandler); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CameraAccessException e) { e.printStackTrace(); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigureFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ } }, mBackgroundHandler); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CameraAccessException e) { e.printStackTrace(); } }</code> </pre><br> 什么是mEncoderSurface？ 这与Media Codec将使用的Surface相同。 仅对于初学者，您需要大约以这种方式来初始化它们。 <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpMediaCodec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mCodec = MediaCodec.createEncoderByType(<span class="hljs-string"><span class="hljs-string">"video/avc"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// H264  } catch (Exception e) { Log.i(LOG_TAG, "  "); } int width = 320; //   int height = 240; //   int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface; //    int videoBitrate = 500000; //    bps (  ) int videoFramePerSecond = 20; // FPS int iframeInterval = 2; // I-Frame    MediaFormat format = MediaFormat.createVideoFormat("video/avc", width, height); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat); format.setInteger(MediaFormat.KEY_BIT_RATE, videoBitrate); format.setInteger(MediaFormat.KEY_FRAME_RATE, videoFramePerSecond); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iframeInterval); mCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); //     mEncoderSurface = mCodec.createInputSurface(); //  Surface  mCodec.setCallback(new EncoderCallback()); mCodec.start(); //   Log.i(LOG_TAG, " "); }</span></span></code> </pre><br> 现在，只需注册一个回调。 当媒体编解码器突然感觉到可以进一步广播的下一个数据准备就绪时，他将通过以下方式通知我们： <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EncoderCallback</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaCodec</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callback</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInputBufferAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOutputBufferAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, MediaCodec.BufferInfo info)</span></span></span><span class="hljs-function"> </span></span>{ outPutByteBuffer = mCodec.getOutputBuffer(index); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] outDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[info.size]; outPutByteBuffer.get(outDate); Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">" outDate.length : "</span></span> + outDate.length); mCodec.releaseOutputBuffer(index, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, MediaCodec.CodecException e)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOutputFormatChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, MediaFormat format)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">"encoder output format changed: "</span></span> + format); } }</code> </pre><br>  outDate字节数组是真正的宝藏。 它包含现成的H264编码视频流片段，我们现在可以用它执行我们想做的任何事情。 <br><br> 他们在这里... <br><br><img src="https://habrastorage.org/webt/lh/pe/kz/lhpekzdgk-z95gpos8493tdgdqi.png"><br><br> 有些片段可能太大，无法通过网络传输，但是如果有必要，系统不会自行将它们切碎并发送给接收者。 <br> 但是，如果它非常可怕，那么您可以通过推碎这样的碎片来粉碎自己 <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count =<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temp =outDate.length ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {<span class="hljs-comment"><span class="hljs-comment">//    byte[] ds; temp = temp-1024; if(temp&gt;=0) { ds = new byte[1024];} else { ds = new byte[temp+1024];} for(int i =0;i&lt;ds.length;i++) { ds[i]=outDate[i+1024*count]; } count=count+1; try { // Log.i(LOG_TAG, " outDate.length : " + ds.length); DatagramPacket packet = new DatagramPacket(ds, ds.length, address, port); udpSocket.send(packet); } catch (IOException e) { Log.i(LOG_TAG, "   UDP "); } } while (temp&gt;=0);</span></span></code> </pre><br><br> 但就目前而言，我们需要亲眼看到缓冲区中的数据确实是H264视频流。 因此，让我们将它们发送到文件中： <br><br> 我们将在设置中编写： <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpMediaCodec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ File mFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), <span class="hljs-string"><span class="hljs-string">"test3.h264"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { outputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(mFile)); Log.i(<span class="hljs-string"><span class="hljs-string">"Encoder"</span></span>, <span class="hljs-string"><span class="hljs-string">"outputStream initialized"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { e.printStackTrace(); }</code> </pre><br> 在回调中，缓冲区在哪里： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { outputStream.write(outDate, <span class="hljs-number"><span class="hljs-number">0</span></span>, outDate.length);<span class="hljs-comment"><span class="hljs-comment">//     } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); }</span></span></code> </pre><br> 打开应用程序，按按钮：“打开相机和流”。 录制自动开始。 我们稍等一下，然后按停止按钮。 <br><br> 由于格式不是MP4，因此保存的文件通常不会丢失，但是如果您使用VLC播放器打开该文件或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用ONLINE CONVERT</a>在线转换它，我们将确保我们走在正确的轨道上。 的确，图像位于侧面，但是可以修复。 <br><br> 通常，对于录制，拍照或流媒体的每个事件，最好每次都打开一个新会话并关闭旧会话。 也就是说，首先我们打开相机并启动裸露的预览。 然后，如果需要拍照，请关闭预览并打开预览，但要固定图像阅读器。 如果我们切换到视频录制，请关闭当前会话并在连接了预览和Media Recorder的情况下开始会话。 我没有这样做，因此代码的可见性不会受到影响，您可以决定如何为自己提供更多便利。 <br><br> 这是整个代码。 <br><br><div class="spoiler">  <b class="spoiler_title">基本媒体编解码器</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.basicmediacodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.annotation.RequiresApi; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.appcompat.app.AppCompatActivity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.core.content.ContextCompat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.Manifest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.ActivityInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.PackageManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.graphics.SurfaceTexture; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraAccessException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraCaptureSession; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraDevice; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CaptureRequest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodecInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Build; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Environment; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Handler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.HandlerThread; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.StrictMode; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.util.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.Surface; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.TextureView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.View; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Button; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Toast; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String LOG_TAG = <span class="hljs-string"><span class="hljs-string">"myLogs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Surface surface = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; CameraService[] myCameras = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CameraManager mCameraManager = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CAMERA1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonOpenCamera1 = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonTStopStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TextureView mImageView = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HandlerThread mBackgroundThread; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Handler mBackgroundHandler = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MediaCodec mCodec = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Surface mEncoderSurface; // Surface      BufferedOutputStream outputStream; ByteBuffer outPutByteBuffer; private void startBackgroundThread() { mBackgroundThread = new HandlerThread("CameraBackground"); mBackgroundThread.start(); mBackgroundHandler = new Handler(mBackgroundThread.getLooper()); } private void stopBackgroundThread() { mBackgroundThread.quitSafely(); try { mBackgroundThread.join(); mBackgroundThread = null; mBackgroundHandler = null; } catch (InterruptedException e) { e.printStackTrace(); } } @RequiresApi(api = Build.VERSION_CODES.M) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setContentView(R.layout.activity_main); Log.d(LOG_TAG, " "); if (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED || (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ) { requestPermissions(new String[]{Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1); } mButtonOpenCamera1 = findViewById(R.id.button1); mButtonStreamVideo = findViewById(R.id.button2); mButtonTStopStreamVideo = findViewById(R.id.button3); mImageView = findViewById(R.id.textureView); mButtonOpenCamera1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { setUpMediaCodec();//    if (myCameras[CAMERA1] != null) {//   if (!myCameras[CAMERA1].isOpen()) myCameras[CAMERA1].openCamera(); } } }); mButtonStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { { //    } } }); mButtonTStopStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (mCodec != null) { Toast.makeText(MainActivity.this, "  ", Toast.LENGTH_SHORT).show(); myCameras[CAMERA1].stopStreamingVideo(); } } }); mCameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); try { //      myCameras = new CameraService[mCameraManager.getCameraIdList().length]; for (String cameraID : mCameraManager.getCameraIdList()) { Log.i(LOG_TAG, "cameraID: " + cameraID); int id = Integer.parseInt(cameraID); //     myCameras[id] = new CameraService(mCameraManager, cameraID); } } catch (CameraAccessException e) { Log.e(LOG_TAG, e.getMessage()); e.printStackTrace(); } } public class CameraService { private String mCameraID; private CameraDevice mCameraDevice = null; private CameraCaptureSession mSession; private CaptureRequest.Builder mPreviewBuilder; public CameraService(CameraManager cameraManager, String cameraID) { mCameraManager = cameraManager; mCameraID = cameraID; } private CameraDevice.StateCallback mCameraCallback = new CameraDevice.StateCallback() { @Override public void onOpened(CameraDevice camera) { mCameraDevice = camera; Log.i(LOG_TAG, "Open camera with id:" + mCameraDevice.getId()); startCameraPreviewSession(); } @Override public void onDisconnected(CameraDevice camera) { mCameraDevice.close(); Log.i(LOG_TAG, "disconnect camera with id:" + mCameraDevice.getId()); mCameraDevice = null; } @Override public void onError(CameraDevice camera, int error) { Log.i(LOG_TAG, "error! camera id:" + camera.getId() + " error:" + error); } }; private void startCameraPreviewSession() { SurfaceTexture texture = mImageView.getSurfaceTexture(); texture.setDefaultBufferSize(320, 240); surface = new Surface(texture); try { mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewBuilder.addTarget(surface); mPreviewBuilder.addTarget(mEncoderSurface); mCameraDevice.createCaptureSession(Arrays.asList(surface, mEncoderSurface), new CameraCaptureSession.StateCallback() { @Override public void onConfigured(CameraCaptureSession session) { mSession = session; try { mSession.setRepeatingRequest(mPreviewBuilder.build(), null, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } @Override public void onConfigureFailed(CameraCaptureSession session) { } }, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } public boolean isOpen() { if (mCameraDevice == null) { return false; } else { return true; } } public void openCamera() { try { if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { mCameraManager.openCamera(mCameraID, mCameraCallback, mBackgroundHandler); } } catch (CameraAccessException e) { Log.i(LOG_TAG, e.getMessage()); } } public void closeCamera() { if (mCameraDevice != null) { mCameraDevice.close(); mCameraDevice = null; } } public void stopStreamingVideo() { if (mCameraDevice != null &amp; mCodec != null) { try { mSession.stopRepeating(); mSession.abortCaptures(); } catch (CameraAccessException e) { e.printStackTrace(); } mCodec.stop(); mCodec.release(); mEncoderSurface.release(); closeCamera(); } } } private void setUpMediaCodec() { File mFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), "test3.h264"); try { outputStream = new BufferedOutputStream(new FileOutputStream(mFile)); Log.i("Encoder", "outputStream initialized"); } catch (Exception e) { e.printStackTrace(); } try { mCodec = MediaCodec.createEncoderByType("video/avc"); // H264  } catch (Exception e) { Log.i(LOG_TAG, "  "); } int width = 320; //   int height = 240; //   int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface; //    int videoBitrate = 500000; //    bps (  ) int videoFramePerSecond = 20; // FPS int iframeInterval = 3; // I-Frame    MediaFormat format = MediaFormat.createVideoFormat("video/avc", width, height); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat); format.setInteger(MediaFormat.KEY_BIT_RATE, videoBitrate); format.setInteger(MediaFormat.KEY_FRAME_RATE, videoFramePerSecond); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iframeInterval); mCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); //     mEncoderSurface = mCodec.createInputSurface(); //  Surface  mCodec.setCallback(new EncoderCallback()); mCodec.start(); //   Log.i(LOG_TAG, " "); } private class EncoderCallback extends MediaCodec.Callback { @Override public void onInputBufferAvailable(MediaCodec codec, int index) { } @Override public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) { outPutByteBuffer = mCodec.getOutputBuffer(index); byte[] outDate = new byte[info.size]; outPutByteBuffer.get(outDate); try { Log.i(LOG_TAG, " outDate.length : " + outDate.length); outputStream.write(outDate, 0, outDate.length);//     } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } mCodec.releaseOutputBuffer(index, false); } @Override public void onError(MediaCodec codec, MediaCodec.CodecException e) { Log.i(LOG_TAG, "Error: " + e); } @Override public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) { Log.i(LOG_TAG, "encoder output format changed: " + format); } } @Override public void onPause() { if (myCameras[CAMERA1].isOpen()) { myCameras[CAMERA1].closeCamera(); } stopBackgroundThread(); super.onPause(); } @Override public void onResume() { super.onResume(); startBackgroundThread(); } }</span></span></code> </pre><br></div></div><br> 并且不要忘记清单中的权限。 <br><br><pre> <code class="java hljs"> &lt;uses-permission android:name=<span class="hljs-string"><span class="hljs-string">"android.permission.CAMERA"</span></span> /&gt; &lt;uses-permission android:name=<span class="hljs-string"><span class="hljs-string">"android.permission.INTERNET"</span></span>/&gt;</code> </pre><br> 因此，我们确保媒体编解码器正在运行。 但是，用它将视频写入文件是不可行的。  Media Recorder可以更好地处理此任务，并且可以增加声音。 因此，我们将再次丢弃文件部分，并添加一个代码块，以使用udp协议将视频流式传输到网络。 这也很简单。 <br><br> 首先，我们实际上是初始化UDP服务器。 <br><br><pre> <code class="java hljs"> DatagramSocket udpSocket; String ip_address = <span class="hljs-string"><span class="hljs-string">"192.168.1.84"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      InetAddress address; int port = 40002; // ,      …….. try { udpSocket = new DatagramSocket(); Log.i(LOG_TAG, "  udp "); } catch ( SocketException e) { Log.i(LOG_TAG, "   udp "); } try { address = InetAddress.getByName(ip_address); Log.i(LOG_TAG, "  "); } catch (Exception e) {</span></span></code> </pre><br> 在同一个回调中，我们将准备数据发送到文件流中，现在，我们将以数据报的形式将它们发送到我们的家庭网络（我希望每个人都拥有吗？） <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DatagramPacket packet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DatagramPacket(outDate, outDate.length, address, port); udpSocket.send(packet); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">"   UDP "</span></span>); }</code> </pre><br><br> 这就是全部吗？ <br><br> 看来，但没有。 该应用程序将在启动时启动。 您会看到，该系统与主流不同，我们发送各种数据报包。 但是没有理由恐慌。 首先，尽管我们在主线程中，但是我们仍然异步工作，即触发回调。 其次，发送udp数据包是相同的异步过程。 我们仅告诉操作系统发送数据包会很好，但是在此问题上我们完全依靠它。 因此，为了使Android不会反叛，我们将在程序的开头添加两行： <br><br><pre> <code class="java hljs"> StrictMode.ThreadPolicy policy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StrictMode.ThreadPolicy.Builder().permitAll().build(); StrictMode.setThreadPolicy(policy);</code> </pre><br> 总的来说，下面的小型<s>优雅</s>演示程序将会出现： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.basicmediacodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.annotation.RequiresApi; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.appcompat.app.AppCompatActivity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.core.content.ContextCompat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.Manifest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.ActivityInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.PackageManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.graphics.SurfaceTexture; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraAccessException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraCaptureSession; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraDevice; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CaptureRequest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodecInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Build; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Handler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.HandlerThread; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.StrictMode; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.util.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.Surface; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.TextureView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.View; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Button; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Toast; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.DatagramPacket; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.DatagramSocket; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.InetAddress; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.SocketException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String LOG_TAG = <span class="hljs-string"><span class="hljs-string">"myLogs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Surface surface = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; CameraService[] myCameras = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CameraManager mCameraManager = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CAMERA1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonOpenCamera1 = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonTStopStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TextureView mImageView = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HandlerThread mBackgroundThread; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Handler mBackgroundHandler = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MediaCodec mCodec = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Surface mEncoderSurface; // Surface      BufferedOutputStream outputStream; ByteBuffer outPutByteBuffer; DatagramSocket udpSocket; String ip_address = "192.168.1.84"; InetAddress address; int port = 40002; private void startBackgroundThread() { mBackgroundThread = new HandlerThread("CameraBackground"); mBackgroundThread.start(); mBackgroundHandler = new Handler(mBackgroundThread.getLooper()); } private void stopBackgroundThread() { mBackgroundThread.quitSafely(); try { mBackgroundThread.join(); mBackgroundThread = null; mBackgroundHandler = null; } catch (InterruptedException e) { e.printStackTrace(); } } @RequiresApi(api = Build.VERSION_CODES.M) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build(); StrictMode.setThreadPolicy(policy); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setContentView(R.layout.activity_main); Log.d(LOG_TAG, " "); if (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED || (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ) { requestPermissions(new String[]{Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1); } mButtonOpenCamera1 = findViewById(R.id.button1); mButtonStreamVideo = findViewById(R.id.button2); mButtonTStopStreamVideo = findViewById(R.id.button3); mImageView = findViewById(R.id.textureView); mButtonOpenCamera1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { setUpMediaCodec();//    if (myCameras[CAMERA1] != null) {//   if (!myCameras[CAMERA1].isOpen()) myCameras[CAMERA1].openCamera(); } } }); mButtonStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { { //    } } }); mButtonTStopStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (mCodec != null) { Toast.makeText(MainActivity.this, "  ", Toast.LENGTH_SHORT).show(); myCameras[CAMERA1].stopStreamingVideo(); } } }); try { udpSocket = new DatagramSocket(); Log.i(LOG_TAG, "  udp "); } catch ( SocketException e) { Log.i(LOG_TAG, "   udp "); } try { address = InetAddress.getByName(ip_address); Log.i(LOG_TAG, "  "); } catch (Exception e) { } mCameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); try { //      myCameras = new CameraService[mCameraManager.getCameraIdList().length]; for (String cameraID : mCameraManager.getCameraIdList()) { Log.i(LOG_TAG, "cameraID: " + cameraID); int id = Integer.parseInt(cameraID); //     myCameras[id] = new CameraService(mCameraManager, cameraID); } } catch (CameraAccessException e) { Log.e(LOG_TAG, e.getMessage()); e.printStackTrace(); } } public class CameraService { private String mCameraID; private CameraDevice mCameraDevice = null; private CameraCaptureSession mSession; private CaptureRequest.Builder mPreviewBuilder; public CameraService(CameraManager cameraManager, String cameraID) { mCameraManager = cameraManager; mCameraID = cameraID; } private CameraDevice.StateCallback mCameraCallback = new CameraDevice.StateCallback() { @Override public void onOpened(CameraDevice camera) { mCameraDevice = camera; Log.i(LOG_TAG, "Open camera with id:" + mCameraDevice.getId()); startCameraPreviewSession(); } @Override public void onDisconnected(CameraDevice camera) { mCameraDevice.close(); Log.i(LOG_TAG, "disconnect camera with id:" + mCameraDevice.getId()); mCameraDevice = null; } @Override public void onError(CameraDevice camera, int error) { Log.i(LOG_TAG, "error! camera id:" + camera.getId() + " error:" + error); } }; private void startCameraPreviewSession() { SurfaceTexture texture = mImageView.getSurfaceTexture(); texture.setDefaultBufferSize(320, 240); surface = new Surface(texture); try { mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewBuilder.addTarget(surface); mPreviewBuilder.addTarget(mEncoderSurface); mCameraDevice.createCaptureSession(Arrays.asList(surface, mEncoderSurface), new CameraCaptureSession.StateCallback() { @Override public void onConfigured(CameraCaptureSession session) { mSession = session; try { mSession.setRepeatingRequest(mPreviewBuilder.build(), null, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } @Override public void onConfigureFailed(CameraCaptureSession session) { } }, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } public boolean isOpen() { if (mCameraDevice == null) { return false; } else { return true; } } public void openCamera() { try { if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { mCameraManager.openCamera(mCameraID, mCameraCallback, mBackgroundHandler); } } catch (CameraAccessException e) { Log.i(LOG_TAG, e.getMessage()); } } public void closeCamera() { if (mCameraDevice != null) { mCameraDevice.close(); mCameraDevice = null; } } public void stopStreamingVideo() { if (mCameraDevice != null &amp; mCodec != null) { try { mSession.stopRepeating(); mSession.abortCaptures(); } catch (CameraAccessException e) { e.printStackTrace(); } mCodec.stop(); mCodec.release(); mEncoderSurface.release(); closeCamera(); } } } private void setUpMediaCodec() { try { mCodec = MediaCodec.createEncoderByType("video/avc"); // H264  } catch (Exception e) { Log.i(LOG_TAG, "  "); } int width = 320; //   int height = 240; //   int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface; //    int videoBitrate = 500000; //    bps (  ) int videoFramePerSecond = 20; // FPS int iframeInterval = 3; // I-Frame    MediaFormat format = MediaFormat.createVideoFormat("video/avc", width, height); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat); format.setInteger(MediaFormat.KEY_BIT_RATE, videoBitrate); format.setInteger(MediaFormat.KEY_FRAME_RATE, videoFramePerSecond); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iframeInterval); mCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); //     mEncoderSurface = mCodec.createInputSurface(); //  Surface  mCodec.setCallback(new EncoderCallback()); mCodec.start(); //   Log.i(LOG_TAG, " "); } private class EncoderCallback extends MediaCodec.Callback { @Override public void onInputBufferAvailable(MediaCodec codec, int index) { } @Override public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) { outPutByteBuffer = mCodec.getOutputBuffer(index); byte[] outDate = new byte[info.size]; outPutByteBuffer.get(outDate); try { DatagramPacket packet = new DatagramPacket(outDate, outDate.length, address, port); udpSocket.send(packet); } catch (IOException e) { Log.i(LOG_TAG, "   UDP "); } mCodec.releaseOutputBuffer(index, false); } @Override public void onError(MediaCodec codec, MediaCodec.CodecException e) { Log.i(LOG_TAG, "Error: " + e); } @Override public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) { Log.i(LOG_TAG, "encoder output format changed: " + format); } } @Override public void onPause() { if (myCameras[CAMERA1].isOpen()) { myCameras[CAMERA1].closeCamera(); } stopBackgroundThread(); super.onPause(); } @Override public void onResume() { super.onResume(); startBackgroundThread(); } }</span></span></code> </pre><br> 我不知道其他人会怎么做，但是在我的Red Note 7上，您甚至可以看到如何在正确的地址下载千字节 <br><br><img src="https://habrastorage.org/webt/9x/3q/gz/9x3qgzrctdcevzw5ym5zi6imgq8.png"><br><br> 而且有很多这样的udp套接字，多少网络带宽就足够了。 最主要的是在哪里有地址。 您将进行广播。 <br><br><h4> 现在让我们在计算机上查找所需的地址 </h4><br> 我必须说，并不是每个计算机程序都能够通过单个udp通道吸收和消化H264视频流，而没有任何其他信息。 但是有些可能。 例如，这是非常著名的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VLC</a>媒体<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">播放器</a> 。 这是一件很酷的事情，如果您开始描述它的功能，那么从本文中您会得到一整本书。 当然可以。 如果没有，戴上它。 <br><br> 从命令描述来看，udp数据包可以消化该播放器。 <br><br><pre> <code class="java hljs">URL syntax: file:<span class="hljs-comment"><span class="hljs-comment">///path/file Plain media file http://host[:port]/file HTTP URL ftp://host[:port]/file FTP URL mms://host[:port]/file MMS URL screen:// Screen capture dvd://[device] DVD device vcd://[device] VCD device cdda://[device] Audio CD device udp://[[&lt;source address&gt;]@[&lt;bind address&gt;][:&lt;bind port&gt;]]</span></span></code> </pre><br> 从理论上讲，不需要所有这些源地址和绑定地址。 仅需要侦听端口。 <br><br><img src="https://habrastorage.org/webt/7-/kw/pi/7-kwpik08ayqmgvd2rta1sqjtae.png"><br><br>  , ,         ( ) <br><br><img src="https://habrastorage.org/webt/ix/9r/sj/ix9rsjovph-xzqgmosv_kgu-in4.jpeg"><br><br>   ,         ? <br><br>      ( ) <br><br> ,   ,  VLC        .  . <br><br><h4>   ? </h4><br>   .  , ,    VLC 3.08 Vetinari?   ,    udp  deprecated     . <br><br> -    .      udp     -: <br><br><ul><li>       .                 ,    .       . </li><li>     </li></ul><br>   , ,      RTP  .     —   ,        udp ( ),           .      ,    -   ,           .      .   ,  ,   . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>   .    -, ,    —          .   udp   . <br>  -   RTP    - . ,       ,      .    VLC ,  udp   . <br><br> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VLC 2.2.6 Umbrella</a> <br><br>       (   VLC),   . <br><br>      . <br><br>    ,        H264. - VLC     ,       (  ,      ).  -      ,  ,  VLC  .   ,  ? <br><br>    . <br><br><img src="https://habrastorage.org/webt/jq/f5/er/jqf5ercz20oa2hxzlbeqmokqgbs.png"><br><br>      «» . ,  -   ,        . <br><br>            : <br><br><pre> <code class="java hljs">C:\Program Files\VideoLAN\VLC\vlc udp:<span class="hljs-comment"><span class="hljs-comment">//@:40002 --demux h264 --video-filter=transform --transform-type=90</span></span></code> </pre><br>     . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/IbN9eh1uyv4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>   .       JAVA    .       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN473036/">https://habr.com/ru/post/zh-CN473036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN473024/index.html">您需要了解的有关物联网的知识：基础教育计划</a></li>
<li><a href="../zh-CN473026/index.html">百胜和数据验证</a></li>
<li><a href="../zh-CN473028/index.html">在俄罗斯开始从欧洲进口放射性废物？ 整理出来</a></li>
<li><a href="../zh-CN473032/index.html">“希望是一个坏策略。” 2月3-5日在莫斯科进行SRE密集</a></li>
<li><a href="../zh-CN473034/index.html">蒂姆利德怎么坐</a></li>
<li><a href="../zh-CN473038/index.html">8位莫尔斯电码</a></li>
<li><a href="../zh-CN473042/index.html">Django的优缺点</a></li>
<li><a href="../zh-CN473044/index.html">如何在App Store中为应用程序创建有效的屏幕截图</a></li>
<li><a href="../zh-CN473046/index.html">风浪，意志力：戴尔坚固耐用的平板电脑如何帮助俄罗斯人赢得国际帆船赛</a></li>
<li><a href="../zh-CN473050/index.html">AMD强迫Intel不仅降低新CPU的价格，而且降低旧CPU的价格。 这是另一场价格战的开始</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>