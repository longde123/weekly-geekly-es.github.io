<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéâ ü§ë üöê IDisposable - que sua m√£e n√£o falou em liberar recursos. Parte 1 üõåüèø üéê üë®‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© uma tradu√ß√£o da primeira parte do artigo. O artigo foi escrito em 2008. Ap√≥s 10 anos, quase perdeu sua relev√¢ncia. 
 Libera√ß√£o determin√≠stica d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IDisposable - que sua m√£e n√£o falou em liberar recursos. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414873/"><p>  Esta √© uma tradu√ß√£o da primeira parte do artigo.  O artigo foi escrito em 2008.  Ap√≥s 10 anos, quase perdeu sua relev√¢ncia. </p><br><h2 id="determinirovannoe-osvobozhdenie-resursov---neobhodimost">  Libera√ß√£o determin√≠stica de recursos - uma necessidade </h2><br><p>  Ao longo de mais de 20 anos de experi√™ncia em codifica√ß√£o, √†s vezes desenvolvi meus pr√≥prios idiomas para resolver problemas.  Eles variavam de linguagens simples e imperativas a express√µes regulares especializadas para √°rvores.  Ao criar idiomas, existem muitas recomenda√ß√µes e algumas regras simples n√£o devem ser violadas.  Um deles: </p><br><blockquote>  Nunca crie um idioma de exce√ß√£o no qual n√£o haja libera√ß√£o determin√≠stica de recursos. </blockquote><p>  Adivinha quais recomenda√ß√µes o tempo de execu√ß√£o do .NET n√£o segue e, como resultado, todos os idiomas baseados nele? </p><a name="habracut"></a><br><p> O motivo dessa regra existir √© que a <strong>libera√ß√£o determin√≠stica de recursos √© necess√°ria para criar programas suportados</strong> .  A libera√ß√£o determinada de recursos fornece um certo ponto no qual o programador tem certeza de que o recurso foi liberado.  Existem duas maneiras de escrever programas confi√°veis: a abordagem tradicional √© liberar recursos o mais cedo poss√≠vel e a abordagem moderna √© liberar recursos por tempo indeterminado.  A vantagem da abordagem moderna √© que o programador n√£o precisa liberar recursos explicitamente.  A desvantagem √© que √© muito mais dif√≠cil escrever um aplicativo confi√°vel, existem muitos erros sutis.  Infelizmente, o tempo de execu√ß√£o do .NET foi criado usando uma abordagem moderna. </p><br><p> O .NET suporta a libera√ß√£o n√£o determin√≠stica de recursos usando o m√©todo <code>Finalize</code> , que tem um significado especial.  Para libera√ß√£o determin√≠stica de recursos, a Microsoft tamb√©m adicionou a interface <code>IDisposable</code> (e outras classes, as quais discutiremos mais adiante).  No entanto, para o tempo de execu√ß√£o, <code>IDisposable</code> √© uma interface normal, como todos os outros.  Esse status de "segunda categoria" cria algumas dificuldades. </p><br><p>  No C #, a "vers√£o determin√≠stica para os pobres" pode ser implementada usando as <code>try</code> e <code>finally</code> ou <code>using</code> (que √© quase a mesma coisa).  A Microsoft vem discutindo h√° muito tempo se deve ou n√£o fazer contagem de links, e me parece que a decis√£o errada foi tomada.  Como resultado, para libera√ß√£o determin√≠stica de recursos, voc√™ precisa usar as constru√ß√µes desajeitadas <code>finally</code> \ <code>using</code> ou uma chamada direta para <code>IDisposable.Dispose</code> , que est√° repleta de erros.  Para um programador C ++ que est√° acostumado a usar o <code>shared_ptr&lt;T&gt;</code> duas op√ß√µes n√£o s√£o atraentes.  (A √∫ltima frase deixa claro onde o autor tem esse relacionamento - <em>aprox.</em> </p><br><h2 id="idisposable">  IDisposable </h2><br><p>  <code>IDisposable</code> √© uma solu√ß√£o para libera√ß√£o determin√≠stica de recursos oferecidos pela Misoftro.  Um √© para os seguintes casos: </p><br><ul><li>  Qualquer tipo que <em>possua recursos</em> gerenciados ( <code>IDisposable</code> ).  Um tipo deve necessariamente <strong>possuir</strong> , isto √©, gerenciar o tempo de vida, os recursos e n√£o apenas se referir a eles. </li><li>  Qualquer tipo que possua recursos n√£o gerenciados. </li><li>  Qualquer tipo que possua recursos gerenciados e n√£o gerenciados. </li><li>  Qualquer tipo herdado de uma classe que implementa <code>IDisposable</code> .  N√£o recomendo herdar de classes que possuem recursos n√£o gerenciados.  Melhor usar um anexo. </li></ul><br><p>  <code>IDisposable</code> ajuda a liberar recursos deterministicamente, mas tem seus pr√≥prios problemas. </p><br><h2 id="slozhnosti-idisposable---udobstvo-ispolzovaniya">  Dificuldades IDisposable - Usabilidade </h2><br><p>  Objetos <code>IDisposable</code> est√£o <code>IDisposable</code> usar bastante pesado.  O uso de um objeto deve ser envolvido em uma constru√ß√£o <code>using</code> .  A m√° not√≠cia √© que o C # n√£o permite o <code>using</code> com um tipo que n√£o implementa <code>IDisposable</code> .  Portanto, o programador deve consultar a documenta√ß√£o todas as vezes para entender se √© necess√°rio escrever <code>using</code> , ou apenas escrever <code>using</code> qualquer lugar, e depois apagar onde o compilador jura. </p><br><p>  C ++ gerenciado √© muito melhor nesse sentido.  Ele suporta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sem√¢ntica de pilha para tipos de refer√™ncia</a> , que funciona como somente para tipos quando necess√°rio.  O C # pode se beneficiar da capacidade de escrever <code>using</code> qualquer tipo. </p><br><p>  Este problema pode ser resolvido com.  ferramentas de an√°lise de c√≥digo.  Para piorar a situa√ß√£o, se voc√™ esquecer de usar, o programa pode passar nos testes, mas travar enquanto trabalha "nos campos". </p><br><p>  Em vez de contar os links, o <code>IDisposable</code> tem outro problema - determinar o propriet√°rio.  Quando em C ++ a √∫ltima c√≥pia do <code>shared_ptr&lt;T&gt;</code> sai do escopo, os recursos s√£o liberados imediatamente, sem a necessidade de pensar em quem deve liberar.  <code>IDisposable</code> pelo contr√°rio, for√ßa o programador a determinar quem "possui" o objeto e √© respons√°vel por liber√°-lo.  √Äs vezes, a propriedade √© √≥bvia: quando um objeto encapsula outro e ele implementa <code>IDisposable</code> , ele √© respons√°vel pela libera√ß√£o de objetos filhos.  √Äs vezes, a vida √∫til de um objeto √© determinada por um bloco de c√≥digo, e o programador simplesmente usa o <code>using</code> torno desse bloco.  No entanto, existem muitos casos em que um objeto pode ser usado em v√°rios lugares e √© dif√≠cil determinar sua vida √∫til (embora, neste caso, a contagem de refer√™ncia funcione perfeitamente). </p><br><h2 id="slozhnosti-idisposable---obratnaya-sovmestimost">  Dificuldades IDisposable - Compatibilidade com vers√µes anteriores </h2><br><p>  Adicionar <code>IDisposable</code> √† classe e remover <code>IDisposable</code> da lista de interfaces implementadas √© uma mudan√ßa de √∫ltima hora.  O c√≥digo do cliente que n√£o espera <code>IDisposable</code> n√£o <code>IDisposable</code> recursos se voc√™ adicionar <code>IDisposable</code> a uma de suas classes passadas por refer√™ncia a uma interface ou classe base. </p><br><p>  A pr√≥pria Microsoft encontrou esse problema.  <code>IEnumerator</code> n√£o <code>IEnumerator</code> herdado de <code>IDisposable</code> e <code>IEnumerator&lt;T&gt;</code> herdado.  Se voc√™ passar <code>IEnumerator&lt;T&gt;</code> c√≥digo que recebe <code>IEnumerator</code> , <code>Dispose</code> n√£o ser√° chamado. </p><br><p>  Este n√£o √© o fim do mundo, mas fornece alguma ess√™ncia secund√°ria do <code>IDisposable</code> . </p><br><h2 id="slozhnosti-idisposable---proektirovanie-ierarhii-klassov">  Dificuldades IDisposable - Criando uma hierarquia de classes </h2><br><p>  A maior desvantagem causada pelo <code>IDisposable</code> no campo do design da hierarquia √© que cada classe e interface deve prever se o <code>IDisposable</code> ser√° necess√°rio por seus descendentes. </p><br><p>  Se a interface n√£o herdar <code>IDisposable</code> , mas as classes que implementam a interface tamb√©m implementarem <code>IDisposable</code> , o c√≥digo final ignorar√° a libera√ß√£o determin√≠stica ou dever√° verificar se o objeto implementa a interface <code>IDisposable</code> .  Mas, para isso, n√£o ser√° poss√≠vel usar a constru√ß√£o using e voc√™ ter√° que escrever uma <code>try</code> feia e <code>finally</code> . </p><br><p>  Em resumo, o <code>IDisposable</code> complica o desenvolvimento de software reutiliz√°vel.  O principal motivo √© a viola√ß√£o de um dos princ√≠pios do design orientado a objetos - separa√ß√£o de interface e implementa√ß√£o.  A libera√ß√£o de recursos deve ser um detalhe de implementa√ß√£o.  A Microsoft decidiu tornar a libera√ß√£o determin√≠stica de recursos uma interface de segunda classe. </p><br><p>  Uma das solu√ß√µes n√£o t√£o bonitas √© fazer com que todas as classes implementem <code>IDisposable</code> , mas na grande maioria das classes, <code>IDisposable.Dispose</code> n√£o far√° nada.  Mas isso n√£o √© muito bonito. </p><br><p>  Outra dificuldade com o <code>IDisposable</code> √© cole√ß√µes.  Algumas cole√ß√µes ‚Äúpossuem‚Äù objetos neles, e outras n√£o.  No entanto, as pr√≥prias cole√ß√µes n√£o implementam <code>IDisposable</code> .  O programador deve se lembrar de chamar <code>IDisposable.Dispose</code> nos objetos da cole√ß√£o ou criar seus pr√≥prios descendentes de classes de cole√ß√£o que implementam <code>IDisposable</code> para significar propriedade. </p><br><h2 id="slozhnosti-idisposable---dopolnitelnoe-oshibochnoe-sostoyanie">  Dificuldades IDisposable - estado "err√¥neo" adicional </h2><br><p>  <code>IDisposable</code> pode ser chamado explicitamente a qualquer momento, independentemente da vida √∫til do objeto.  Ou seja, um estado "liberado" √© adicionado a cada objeto, no qual √© recomend√°vel lan√ßar uma <code>ObjectDisposedException</code> .  Verificar o status e lan√ßar exce√ß√µes √© uma despesa adicional. </p><br><p>  Em vez de verificar cada espirro, √© melhor considerar acessar o objeto no estado "liberado" como "comportamento indefinido" como uma chamada √† mem√≥ria liberada. </p><br><h2 id="slozhnosti-idisposable---net-garantiy">  Dificuldades IDisposable - sem garantias </h2><br><p>  <code>IDisposable</code> √© apenas uma interface.  Uma classe que implementa <code>IDisposable</code> <strong>oferece suporte √†</strong> libera√ß√£o determin√≠stica, mas n√£o a <strong>garante</strong> .  Para o c√≥digo do cliente, n√£o h√° problema em chamar <code>Dispose</code> .  Portanto, uma classe que implementa <code>IDisposable</code> deve oferecer suporte √† libera√ß√£o determin√≠stica e n√£o determin√≠stica. </p><br><h2 id="slozhnosti-idisposable---slozhnaya-realizaciya">  Complexidades IDisposable - Implementa√ß√£o Complexa </h2><br><p>  A Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">oferece um padr√£o</a> para implementar <code>IDisposable</code> .  (Anteriormente, havia um padr√£o geralmente terr√≠vel, mas, relativamente recentemente, ap√≥s o aparecimento do .NET 4, a documenta√ß√£o foi corrigida, inclusive sob a influ√™ncia deste artigo. Nas edi√ß√µes antigas dos livros do .NET, √© poss√≠vel encontrar a vers√£o antiga. - <em>aprox.</em> ) </p><br><ul><li>  <code>IDisposable.Dispose</code> n√£o pode ser chamado, portanto, a classe deve incluir um finalizador para liberar recursos. </li><li>  <code>IDisposable.Dispose</code> pode ser chamado v√°rias vezes e deve funcionar sem efeitos colaterais vis√≠veis.  Portanto, √© necess√°rio adicionar uma verifica√ß√£o se o m√©todo j√° foi chamado ou n√£o. </li><li>  Os finalizadores s√£o chamados em um thread separado e podem ser chamados antes da <code>IDisposable.Dispose</code> .  O uso do <code>GC.SuppressFinalize</code> para evitar essas "corridas". </li></ul><br><p>  Al√©m disso: </p><br><ul><li>  Os finalizadores s√£o chamados, inclusive para objetos que lan√ßam uma exce√ß√£o no construtor.  Portanto, o c√≥digo de libera√ß√£o deve funcionar com objetos parcialmente inicializados. </li><li>  A implementa√ß√£o de um <code>IDisposable</code> em uma classe herdada de <code>CriticalFinalizerObject</code> requer constru√ß√µes n√£o triviais.  <code>void Dispose(bool disposing)</code> √© um m√©todo viral e deve ser executado na regi√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">execu√ß√£o restrita</a> , que requer uma chamada para <code>RuntimeHelpers.PrepareMethod</code> . </li></ul><br><h2 id="slozhnosti-idisposable---ne-podhodit-dlya-logiki-zaversheniya">  Dificuldades IDisposable - N√£o √© adequado para l√≥gica de conclus√£o </h2><br><p>  Desligando um objeto - geralmente ocorre em programas em threads paralelos ou ass√≠ncronos.  Por exemplo, uma classe usa um thread separado e deseja conclu√≠-lo usando <code>ManualResetEvent</code> .  Isso pode ser feito em <code>IDisposable.Dispose</code> , mas pode levar a um erro se o c√≥digo for chamado no finalizador. </p><br><p>  Para entender as limita√ß√µes do finalizador, voc√™ precisa entender como o coletor de lixo funciona.  Abaixo est√° um diagrama simplificado no qual muitos detalhes relacionados a gera√ß√µes, links fracos, recupera√ß√£o de objetos, coleta de lixo em segundo plano etc. s√£o omitidos. </p><br><p>  O coletor de lixo .NET usa o algoritmo de marca√ß√£o e varredura.  Em geral, a l√≥gica √© assim: </p><br><ol><li>  Pause todos os threads. </li><li>  Pegue todos os objetos raiz: vari√°veis ‚Äã‚Äãna pilha, campos est√°ticos, objetos <code>GCHandle</code> , fila de finaliza√ß√£o.  No caso de descarregar o dom√≠nio do aplicativo (encerramento do programa), considera-se que as vari√°veis ‚Äã‚Äãna pilha e nos campos est√°ticos n√£o s√£o ra√≠zes. </li><li>  Recursivamente, percorra todos os links dos objetos e marque-os como "alcan√ß√°veis". </li><li>  Percorra todos os outros objetos que possuem destruidores (finalizadores), declare-os acess√≠veis e coloque-os na fila de finaliza√ß√£o ( <code>GC.SuppressFinalize</code> diz ao GC para n√£o fazer isso).  Os objetos s√£o enfileirados em uma ordem imprevis√≠vel. </li></ol><br><p>  Em segundo plano, um fluxo (ou v√°rios) de finaliza√ß√£o funciona: </p><br><ol><li>  Retira um objeto da fila e inicia seu finalizador.  √â poss√≠vel executar v√°rios finalizadores de objetos diferentes ao mesmo tempo. </li><li>  O objeto √© removido da fila e, se mais ningu√©m se referir a ele, ser√° limpo na pr√≥xima coleta de lixo. </li></ol><br><p>  Agora deve ficar claro por que √© imposs√≠vel acessar recursos gerenciados do finalizador - voc√™ n√£o sabe em que ordem os finalizadores s√£o chamados.  Mesmo chamando <code>IDisposable.Dispose</code> outro objeto do finalizador pode levar a um erro, pois o c√≥digo de libera√ß√£o do recurso pode funcionar em outro thread. </p><br><p>  Existem algumas exce√ß√µes quando voc√™ pode acessar recursos gerenciados de um finalizador: </p><br><ol><li>  A finaliza√ß√£o de objetos herdados de <code>CriticalFinalizerObject</code> √© executada <strong>ap√≥s a</strong> finaliza√ß√£o de objetos n√£o herdados dessa classe.  Isso significa que voc√™ pode chamar <code>ManualResetEvent</code> do finalizador at√© que a classe seja herdada de <code>CriticalFinalizerObject</code> </li><li>  Alguns objetos e m√©todos s√£o especiais, como o Console e alguns m√©todos de Thread.  Eles podem ser chamados dos finalizadores, mesmo que o programa termine. </li></ol><br><p>  No caso geral, √© melhor n√£o acessar recursos gerenciados dos finalizadores.  No entanto, a l√≥gica da conclus√£o √© necess√°ria para software n√£o trivial.  No <code>Windows.Forms</code> cont√©m a l√≥gica de conclus√£o no m√©todo <code>Application.Exit</code> .  Ao desenvolver sua biblioteca de componentes, a melhor coisa a fazer √© concluir a l√≥gica de conclus√£o com <code>IDisposable</code> .  Termina√ß√£o normal em caso de chamar <code>IDisposable.Dispose</code> e emerg√™ncia caso contr√°rio. </p><br><p>  A Microsoft tamb√©m encontrou esse problema.  A classe <code>StreamWriter</code> possui um objeto <code>Stream</code> (dependendo dos par√¢metros do construtor na vers√£o mais recente - <em>aprox. Por.</em> ).  <code>StreamWriter.Close</code> libera o buffer e chama <code>Stream.Close</code> (tamb√©m ocorre se envolvido com o <code>using</code> - <em>aprox. Por.</em> ).  Se o <code>StreamWriter</code> n√£o <code>StreamWriter</code> fechado, o buffer n√£o ser√° liberado e o bate-papo de dados ser√° perdido.  A Microsoft simplesmente n√£o redefiniu o finalizador, "resolvendo" o problema de conclus√£o.  Um √≥timo exemplo da necessidade de l√≥gica de conclus√£o. </p><br><h2 id="rekomenduyu-pochitat">  Eu recomendo a leitura </h2><br><p>  Muitas informa√ß√µes sobre o .NET internos neste artigo s√£o fornecidas pelo CLR de Jeffrey Richter via C #.  Se voc√™ ainda n√£o o tem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compre-o</a> .  S√©rio.  Esse √© o conhecimento necess√°rio para qualquer programador de C #. </p><br><h2 id="zaklyuchenie-ot-perevodchika">  Conclus√£o do tradutor </h2><br><p>  A maioria dos programadores .NET nunca encontrar√° os problemas descritos neste artigo.  O .NET evoluir√° para aumentar o n√≠vel de abstra√ß√£o e reduzir a necessidade de "malabarismo" de recursos n√£o gerenciados.  No entanto, este artigo √© √∫til, pois descreve os detalhes profundos de coisas simples e seu impacto no design do c√≥digo. </p><br><p>  A pr√≥xima parte ser√° uma discuss√£o detalhada de como trabalhar com recursos gerenciados e n√£o gerenciados no .NET com v√°rios exemplos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414873/">https://habr.com/ru/post/pt414873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414861/index.html">Modelagem de T√∫nel - Vers√£o 1.0</a></li>
<li><a href="../pt414865/index.html">iMaterialist Furniture Challenge ou 50 tons de cadeiras</a></li>
<li><a href="../pt414867/index.html">ThinkingHome.Migrator - migra√ß√£o com vers√£o do esquema do banco de dados na plataforma .NET Core</a></li>
<li><a href="../pt414869/index.html">Estruturas desaparecendo</a></li>
<li><a href="../pt414871/index.html">Tempestade de poeira em Marte atingiu escala planet√°ria, at√© a curiosidade afetada</a></li>
<li><a href="../pt414875/index.html">Integra√ß√£o de cont√™ineres Kubernetes substituindo o Docker pronto para produ√ß√£o</a></li>
<li><a href="../pt414877/index.html">Uma lente incomum para uma c√¢mera comum ou como parar de pensar em foco</a></li>
<li><a href="../pt414879/index.html">Por que 2 extrusoras em uma impressora 3D?</a></li>
<li><a href="../pt414881/index.html">Um pouco de VK nos bastidores</a></li>
<li><a href="../pt414883/index.html">As mem√≥rias soaram de uma nova maneira: a BBC atualizou o arquivo de som do projeto RemArc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>