<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÇ üöø üë∏üèº Das Buch "Vue.js in Aktion" üí™üèº üë± üà∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Der Zweck dieses Buches ist es, Ihnen das Wissen zu vermitteln, mit dem Sie ohne zu z√∂gern an einem Projekt teilnehmen k√∂nnen, das...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Vue.js in Aktion"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/448304/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/7u/pn/a0/7upna0knmll01vosthivrjtjhpi.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  Der Zweck dieses Buches ist es, Ihnen das Wissen zu vermitteln, mit dem Sie ohne zu z√∂gern an einem Projekt teilnehmen k√∂nnen, das diese Bibliothek verwendet.  Das Buch richtet sich an alle, die Vue.js lernen m√∂chten und Erfahrung mit JavaScript, HTML und CSS haben.  Sie m√ºssen nicht √ºber fundierte Kenntnisse in diesem Bereich verf√ºgen, aber das Verst√§ndnis der Grundlagen wie Arrays, Variablen, Schleifen und HTML-Elemente schadet nicht. <br><br>  Unter dem Schnitt befindet sich eine Passage in Form des Vuex-Kapitels, die beschreibt: Wie ist der Zustand?  die Verwendung von Gettern;  Implementierung von Mutationen;  Hinzuf√ºgen von Aktionen;  mit Vuex-Hilfsmethoden arbeiten;  Module und Projekteinrichtung. <br><a name="habracut"></a><br><h3>  10.1.  Warum brauchen wir Vuex? </h3><br>  Die Vuex-Bibliothek verwaltet den Status.  Es speichert es zentral, wodurch es einfach ist, auf alle Komponenten zuzugreifen.  Status sind Informationen oder Daten, die die Anwendung unterst√ºtzen.  Dies ist wichtig, da wir einen zuverl√§ssigen und verst√§ndlichen Mechanismus f√ºr die Arbeit mit diesen Informationen ben√∂tigen. <br><br>  Wenn Sie bereits Erfahrung mit anderen Frameworks zum Erstellen von Anwendungen mit nur einer Seite haben, sind einige dieser Konzepte m√∂glicherweise bekannt.  Beispielsweise verwendet React ein √§hnliches Statusverwaltungssystem namens Redux.  Vuex und Redux werden vom Flux-Projekt beeinflusst.  Dies ist die von Facebook vorgeschlagene Architektur, die die Erstellung von Client-Webanwendungen vereinfachen soll.  Es tr√§gt zur Bewegung von Daten in eine Richtung bei: von Aktionen zum Dispatcher, dann zum Speicher und am Ende zur Ansicht.  Mit diesem Ansatz k√∂nnen Sie den Status vom Rest der Anwendung trennen und synchrone Aktualisierungen f√∂rdern.  Weitere Informationen zu Flux finden Sie in der offiziellen Dokumentation unter facebook.github.io/flux/docs/overview.html. <br><br>  Vuex arbeitet nach dem gleichen Prinzip und hilft dabei, den Zustand vorhersehbar und synchron zu √§ndern.  Entwickler m√ºssen sich keine Gedanken √ºber die Folgen der Aktualisierung des Status mit synchronen und asynchronen Funktionen machen.  Stellen Sie sich vor, wir interagieren mit einer Server-API, die Daten im JSON-Format zur√ºckgibt.  Was passiert, wenn diese Daten gleichzeitig von einer Drittanbieter-Bibliothek ge√§ndert werden?  Wir wollen kein unvorhersehbares Ergebnis.  Vuex hilft, solche Situationen zu vermeiden, indem asynchrone √Ñnderungen eliminiert werden. <br>  Sie fragen sich wahrscheinlich, warum wir die Vuex-Bibliothek √ºberhaupt brauchen.  Am Ende k√∂nnen Sie mit Vue.js Informationen an Komponenten √ºbergeben.  Wie Sie aus fr√ºheren Kapiteln wissen, sind hierf√ºr Eingabeparameter und Benutzerereignisse vorgesehen.  Wir k√∂nnten sogar einen eigenen Ereignisbus f√ºr die Daten√ºbertragung und die Kommunikation zwischen Komponenten erstellen.  Ein Beispiel f√ºr einen solchen Mechanismus ist in Abb. 1 dargestellt.  10.1. <br><br>  Dies w√§re f√ºr kleine Anwendungen mit einer Handvoll Komponenten geeignet.  In diesem Fall m√ºssen Sie Informationen nur an wenige Empf√§nger √ºbertragen.  Was aber, wenn die Anwendung gr√∂√üer, komplexer und vielschichtiger ist?  Es ist klar, dass es in einem gro√üen Projekt nicht so einfach ist, alle R√ºckruffunktionen, Eingabeparameter und Ereignisse im Auge zu behalten. <br><br>  Nur f√ºr solche Situationen wurde die Vuex-Bibliothek erstellt.  Sie k√∂nnen die Arbeit mit dem Status in Form eines zentralen Repositorys organisieren.  Stellen Sie sich ein Szenario vor, √ºber das Sie nachdenken sollten.  Zum Beispiel arbeiten wir an einem Blog mit Artikeln und Kommentaren, die Sie erstellen, bearbeiten und l√∂schen k√∂nnen.  Gleichzeitig verf√ºgen wir √ºber ein Administrationsfenster, in dem Sie Benutzer blockieren und hinzuf√ºgen k√∂nnen. <br><br>  Mal sehen, wie dies mit Vuex implementiert wird.  In Abb.  Abbildung 10.2 zeigt, dass die EditBio-Komponente ein untergeordnetes Element des Admin-Panels ist.  Er ben√∂tigt Zugriff auf Benutzerinformationen, damit er diese aktualisieren kann.  In Zusammenarbeit mit Vuex k√∂nnen wir auf das zentrale Repository zugreifen, die Daten √§ndern und die √Ñnderungen direkt √ºber die EditBio-Komponente speichern.  Dies ist viel besser, als Informationen von der Stamminstanz von Vue.js an die Admin-Komponente und dann mithilfe der Eingabeparameter an EditBio zu √ºbergeben.  Es w√§re schwierig f√ºr uns, Daten an verschiedenen Orten im Auge zu behalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xr/0b/03/xr0b03q-1ielejscatrwuawsmfw.png" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/az/hj/6x/azhj6xybhs1mchcgfshl3ardskq.png" alt="Bild"></div><br>  Die Verwendung von Vuex hat jedoch einen Preis in Form von zus√§tzlichem Boilerplate-Code und Komplexit√§t der Anwendungsstruktur.  Wie bereits erw√§hnt, ist es besser, diese Bibliothek nicht in einfachen Projekten zu verwenden, die aus mehreren Komponenten bestehen.  Das wahre Potenzial zeigt sich in gro√üen Anwendungen mit einem komplexeren Zustand. <br><br><h3>  10.2.  Zustand und Mutation in Vuex </h3><br>  Vuex speichert den Status der gesamten Anwendung in einem einzelnen Objekt, das auch als einzelne Wahrheitsquelle bezeichnet wird.  Wie der Name schon sagt, werden alle Daten an einem Ort gesammelt und nicht in anderen Teilen des Codes dupliziert. <br><blockquote>  TIPP <br><br>  Es ist erw√§hnenswert, dass wir nicht alle unsere Daten in Vuex speichern m√ºssen.  Einzelne Komponenten k√∂nnen ihren eigenen lokalen Status haben.  In bestimmten Situationen ist dies vorzuziehen.  Ihre Komponente enth√§lt beispielsweise eine Variable, die nur in ihr verwendet wird.  Sie muss vor Ort bleiben. </blockquote>  Betrachten Sie ein einfaches Beispiel f√ºr die Arbeit mit state in Vuex.  Unser gesamter Code wird in einer Datei abgelegt.  Sp√§ter erfahren Sie, wie Sie mithilfe der Vue-CLI Vuex zu einem Projekt hinzuf√ºgen.  √ñffnen Sie einen Texteditor und erstellen Sie die Datei vuex-state.html.  Wir zeigen eine Nachricht im zentralen Repository und einen Z√§hler an.  Das Ergebnis ist in Abb. 2 dargestellt.  10.3. <br><br><img src="https://habrastorage.org/webt/iv/4v/tn/iv4vtnbwgbqcbfgp-gmmh1ujhsg.png" align="left" alt="Bild">  F√ºgen Sie zun√§chst Skript-Tags mit Links zu Vue und Vuex hinzu.  Erstellen Sie dann das HTML-Markup.  Wir werden die Tags H1, H2, H3 und Button verwenden.  Das Tag h1 zeigt den Header mit einer lokalen Variablen an, die in der Instanz Vue.js. deklariert ist.  Die Begr√º√üungs- und Z√§hlernachrichten werden als berechnete Eigenschaften basierend auf dem Vuex-Repository ausgef√ºhrt. <br><br>  Das Schaltfl√§chenelement l√∂st eine Inkrementierungsaktion aus.  Kopieren Sie den Code aus Listing 10.1 in die Datei vuex-state.html. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i8/0x/34/i80x34aujec0yim7ew-xuroqslu.png" alt="Bild"></div><br>  Wenn Sie mit dem HTML-Markup fertig sind, beginnen wir mit der Erstellung des Vuex-Repositorys.  Es enth√§lt alle Anwendungsdaten, einschlie√ülich der Eigenschaften msg und count. <br><br>  Um den Status zu aktualisieren, verwenden wir Mutationen.  Dies ist so etwas wie Setter aus anderen Programmiersprachen.  Der Setter setzt den Wert, die Mutation aktualisiert den Status des Programms.  In Vuex m√ºssen Mutationen synchron sein.  In unserem Beispiel wird der Z√§hler nur auf Knopfdruck erh√∂ht, sodass Sie sich keine Gedanken √ºber asynchronen Code machen m√ºssen (sp√§ter werden wir Ma√ünahmen in Betracht ziehen, die zur L√∂sung von Problemen mit der Asynchronit√§t beitragen). <br><br>  Erstellen Sie eine Inkrementierungsfunktion innerhalb des Mutationsobjekts, die den Status erh√∂ht.  Nehmen Sie den Code in Listing 10.2 und f√ºgen Sie ihn am Ende der Datei vuex-state.html ein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ev/35/cc/ev35cct8d2bymgoqwg47n6loghi.png" alt="Bild"></div><br>  Also haben wir HTML-Markup und Vuex-Repository vorbereitet.  Jetzt k√∂nnen Sie eine Logik hinzuf√ºgen, die sie verbindet.  Wir m√∂chten, dass die Vorlage die Nachrichten- und Z√§hlerwerte anzeigt, die Teil des Vuex-Status sind.  Au√üerdem muss der Z√§hler aktualisiert werden. <br><br>  Erstellen Sie eine Instanz von Vue.js mit einer neuen Datenfunktion, die eine lokale Header-Eigenschaft mit dem Text der Vuex-App zur√ºckgibt.  F√ºgen Sie im berechneten Abschnitt die berechneten Eigenschaften welcome und counter hinzu.  Der erste gibt store.state.msg zur√ºck und der zweite - store.state.count. <br><br>  Schlie√ülich m√ºssen Sie eine Methode namens Inkrement hinzuf√ºgen.  Im Vuex-Repository wurde eine Mutation deklariert, die wir jedoch nicht direkt zum Aktualisieren des Status verwenden k√∂nnen.  Hierf√ºr steht eine spezielle Commit-Funktion zur Verf√ºgung.  Es weist Vuex an, das Repository zu aktualisieren, und speichert dadurch die √Ñnderungen.  Der Ausdruck store.commit ('Inkrement') f√ºhrt die Mutation durch.  F√ºgen Sie das folgende Snippet (Listing 10.3) unmittelbar nach dem in Listing 10.2 erstellten Code ein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ou/fr/fx/oufrfxchrwxh0ilabltkow4vl6e.png" alt="Bild"></div><br>  Dies ist eine vollwertige Arbeitsanwendung, die auf Vuex basiert!  Versuchen Sie, die Taste zu dr√ºcken - jedes Mal, wenn Sie den Z√§hler dr√ºcken, sollte er um 1 erh√∂ht werden. <br><br>  Aktualisieren Sie den Code so, dass durch Dr√ºcken der Taste der Z√§hler um 10 erh√∂ht wird. Wenn Sie sich die Inkrementmutation genau ansehen, werden Sie feststellen, dass nur ein Argument erforderlich ist: state.  Lassen Sie uns einen anderen √ºbergeben - nennen wir ihn Nutzlast.  Es wird von der Inkrementmethode √ºbergeben, die in der Stamminstanz von Vue.js erstellt wird. <br><br>  Kopieren Sie den Inhalt von vuex-state.html in die neue Datei vuex-state-pass.html.  Am Beispiel dieser Anwendung zeigen wir, wie Argumente √ºbergeben werden. <br><br>  Wie Sie in Listing 10.4 sehen k√∂nnen, m√ºssen nur das Mutationsobjekt und die Inkrementierungsmethode aktualisiert werden.  F√ºgen Sie dem Mutationsinkrement ein weiteres Argument hinzu, das als Nutzlast bezeichnet wird.  Dies ist der Wert, um den sich state.count erh√∂ht.  Suchen Sie den Aufruf von store.commit in der Inkrementierungsmethode und geben Sie 10 als zweites Argument an.  Aktualisieren Sie die Datei vuex-state.html wie unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/ar/lp/lparlpajbodkpiupswhu-5sj814.png" alt="Bild"></div><br>  Speichern Sie die Datei vuex-state-pass.html und √∂ffnen Sie sie in einem Browser.  Wenn Sie nun die Taste dr√ºcken, sollte sich der Z√§hler um 10 und nicht um 1 erh√∂hen. Wenn ein Fehler aufgetreten ist, √ºberpr√ºfen Sie die Browserkonsole und stellen Sie sicher, dass keine Tippfehler vorliegen. <br><br><h3>  10.3.  Getter und Aktionen </h3><br>  Im vorherigen Beispiel haben wir direkt √ºber die berechneten Eigenschaften auf das Gesch√§ft zugegriffen.  Aber was w√§re, wenn wir mehrere Komponenten h√§tten, die denselben Zugriff ben√∂tigen?  Angenommen, wir m√∂chten eine Begr√º√üungsnachricht in Gro√übuchstaben anzeigen.  In diesem Fall helfen uns Getter. <br><br>  Getter sind Teil von Vuex.  Mit ihnen k√∂nnen Sie in allen Komponenten einen einheitlichen Statuszugriff implementieren.  Nehmen wir ein Beispiel aus Abschnitt 10.2 und anstatt √ºber berechnete Eigenschaften direkt auf das Repository zuzugreifen, verwenden wir Getter.  Au√üerdem lassen wir den Getter f√ºr die msg-Eigenschaft alle Buchstaben in Gro√übuchstaben √ºbersetzen. <br><br>  Kopieren Sie den Inhalt der Datei vuex-state-pass.html nach vuex-state-getter-action.html.  Lassen Sie den HTML-Code unver√§ndert, um die Aufgabe zu vereinfachen.  Am Ende sollten Sie etwas √Ñhnliches wie Abb.  10.4. <br><br><img src="https://habrastorage.org/webt/sw/po/np/swponphqaqcwiinwh-5b-gai7b0.png" align="left" alt="Bild">  Wie Sie sehen k√∂nnen, wird die Nachricht "Hallo Welt" jetzt in Worten angezeigt.  Durch Dr√ºcken der Taste Press Me wird der Z√§hler auf die gleiche Weise wie im vorherigen Beispiel erh√∂ht. <br><br>  Suchen Sie das Vuex.Store-Konstrukt in der neuen Datei vuex-state-getter-action.html direkt unter dem Tag <img src="https://habrastorage.org/webt/ux/wq/hg/uxwqhgjw_hle7zwwssn_a6kylcw.png" alt="Bild">  F√ºgen Sie nach Mutationen, die als Getter bezeichnet werden, ein neues Objekt hinzu.  Erstellen Sie die Methoden msg und count in diesem Objekt, wie in Listing 10.5 gezeigt.  Beide Methoden akzeptieren dasselbe Statusargument. <br><br>  Der msg getter gibt state.msg.toUppercase () zur√ºck.  Dank dessen wird die Nachricht immer in Gro√übuchstaben angezeigt.  Im get getter geben wir state.count zur√ºck.  Nach dem Hinzuf√ºgen von Gettern unterhalb der Mutationen sollte die Datei vuex-state-getter-action.html folgenderma√üen aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/17/hg/lh17hghhfqmvinzfxxyvd6kfw10.png" alt="Bild"></div><br>  Aktionen sind ein weiterer wesentlicher Bestandteil von Vuex.  Ich habe bereits erw√§hnt, dass Mutationen synchron sein m√ºssen.  Aber was ist, wenn wir mit asynchronem Code arbeiten?  Wie k√∂nnen asynchrone Anrufe den Status √§ndern?  Vuex-Aktionen helfen uns dabei. <br>  Stellen Sie sich vor, die Anwendung greift auf den Server zu und wartet auf eine Antwort.  Dies ist ein Beispiel f√ºr eine asynchrone Aktion.  Leider sind Mutationen asynchron, daher k√∂nnen wir sie hier nicht verwenden.  F√ºgen Sie stattdessen eine asynchrone Operation hinzu, die auf der Vuex-Aktion basiert. <br><br>  Verwenden Sie die Funktion setTimeout, um eine Verz√∂gerung zu erstellen.  √ñffnen Sie die Datei vuex-state-getter-action.html und f√ºgen Sie das Aktionsobjekt unmittelbar nach getters hinzu.  Platzieren Sie in diesem Objekt die Inkrementierungsaktion, die die Kontext- und Nutzlastargumente verwendet.  Im Kontext speichern wir die √Ñnderungen.  Platzieren Sie die Operation context.commit in setTimeout.  Auf diese Weise simulieren wir eine Verz√∂gerung auf dem Server.  Wir k√∂nnen das Payload-Argument auch an context.commit √ºbergeben, das dann in die Mutation gelangt.  Aktualisieren Sie den Code basierend auf Listing 10.6. <br><br>  Nach dem Aktualisieren von Vuex.Store k√∂nnen Sie mit der Stamminstanz von Vue.js fortfahren.  Die berechnete Eigenschaft greift nicht wie zuvor direkt auf den Speicher zu, sondern verwendet Getter.  Wir modifizieren auch die Inkrementierungsmethode.  Um auf die neue Vuex-Eigenschaft zuzugreifen, die wir zuvor erstellt haben, wird der Aufruf store.dispatch ('increment', 10) verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ow/na/tk/ownatktwrqjz5jnedkigjoqbqdg.png" alt="Bild"></div><br>  Das erste Argument f√ºr den Versandaufruf ist der Name der Aktion, und das zweite Argument enth√§lt immer zus√§tzliche Daten, die an diese Aktion √ºbergeben werden. <br><blockquote>  TIPP <br><br>  Zus√§tzliche Daten k√∂nnen eine regul√§re Variable oder sogar ein Objekt sein. <br>  Aktualisieren Sie die Instanz Vue.js in der Datei vuex-state-getter-action.html, wie in Listing 10.7 gezeigt. </blockquote><img src="https://habrastorage.org/webt/9r/m1/b1/9rm1b1-hossqa_axypdxhp47v7q.png" alt="Bild"><br><br>  Laden Sie die Anwendung herunter und dr√ºcken Sie die Taste mehrmals.  Sie sollten eine Verz√∂gerung bemerken, aber der Z√§hler erh√∂ht sich nach jedem Dr√ºcken um 10. <br><br><h3>  10.4.  Verwenden von Vuex in einem Zoohandlungsprojekt mithilfe von Vue-CLI </h3><br>  Kehren wir zu dem Tierhandlungsprojekt zur√ºck, an dem wir gearbeitet haben.  Wenn Sie es nicht vergessen haben, haben wir uns entschlossen, Animationen und √úberg√§nge hinzuzuf√ºgen.  Jetzt integrieren wir die Vuex-Bibliothek, die wir zuvor kennengelernt haben. <br><br>  Wir √ºbertragen die Daten der Ware ins Lager.  Wie Sie sich aus den vorherigen Kapiteln erinnern, wurden die Daten im erstellten Hook in der Hauptkomponente initialisiert.  Jetzt sollte dieser Hook ein neues Ereignis generieren, das das Vuex-Repository initialisiert.  Wir werden auch die berechneten Eigenschaftsprodukte hinzuf√ºgen, die Produkte mit dem Getter abrufen (wir werden sie sp√§ter erstellen).  Das Endergebnis sieht wie in Abb.  10.5. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-s/6q/nf/-s6qnfzox3qmsvozrfvla8liuqe.png" alt="Bild"></div><br><h3>  10.4.1.  Installieren Sie Vuex mit Vue-CLI </h3><br>  Installieren Sie zuerst Vuex!  Dies ist ein einfacher Vorgang.  Bereiten Sie die neueste Version der Zoohandlung vor, an der wir in Kapitel 8 gearbeitet haben. Sie k√∂nnen auch den gesamten Code f√ºr dieses Kapitel auf GitHub unter github.com/ErikCH/VuejsInActionCode herunterladen. <br><br>  √ñffnen Sie ein Terminalfenster und wechseln Sie in das Stammverzeichnis des Projekts.  F√ºhren Sie den folgenden Befehl aus, um die neueste Version von Vuex zu installieren: <br><br><pre><code class="plaintext hljs">$ npm install vuex</code> </pre> <br>  und speichern Sie den Datensatz dar√ºber in der Datei package.json der Zoohandlung. <br><br>  Jetzt m√ºssen Sie den Speicher zur Datei main.js hinzuf√ºgen, die sich im Ordner src befindet.  Das Repository selbst existiert noch nicht, aber wir importieren es trotzdem.  Normalerweise befindet es sich in der Datei src / store / store.js, aber Sie k√∂nnen einen anderen Pfad w√§hlen - alle Entwickler haben ihre eigenen Einstellungen.  Lassen Sie uns auf die allgemein akzeptierte Option eingehen.  Sp√§ter in diesem Kapitel werden wir eine alternative Verzeichnisstruktur unter Verwendung von Modulen diskutieren. <br><br>  Sie m√ºssen der Stamminstanz von Vue.js unterhalb des Routers Speicher hinzuf√ºgen, wie in Listing 10.8 gezeigt.  √úbrigens verwenden wir den ES6-Standard, daher kann store: store auf store gek√ºrzt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/du/gj/ns/dugjnsblenm_dydxirxudmpqbbk.png" alt="Bild"></div><br>  Nachdem Sie den Speicher mit der Root-Instanz verbunden haben, k√∂nnen Sie von jedem Teil der Anwendung aus darauf zugreifen.  Erstellen Sie die Datei src / store / store.js.  Darin platzieren wir das Vuex-Repository mit Informationen zu den von der Zoohandlung angebotenen Produkten.  F√ºgen Sie oben zwei Importanweisungen hinzu, eine f√ºr Vue und Vuex.  Geben Sie dann Vue.use (Vuex) an, um alles zusammenzusetzen. <br><br>  Wir haben das Repository in der Datei main.js aus ./store/store importiert.  Jetzt m√ºssen Sie das Speicherobjekt in store.js exportieren.  Wie Sie in Listing 10.9 sehen k√∂nnen, exportieren wir einen konstanten Speicherwert, der Vuex.Store entspricht. <br><br>  F√ºgen Sie zun√§chst Objekte mit Status und Mutationen hinzu.  Der Status enth√§lt ein leeres Objekt namens products.  Bald werden wir es mit der initStore-Methode f√ºllen.  Die Mutation hei√üt SET_STORE und ordnet die √ºbertragenen Waren der Eigenschaft state.products zu.  F√ºgen Sie den Code aus der folgenden Liste in die soeben erstellte Datei src / store / store.js ein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rq/2a/hi/rq2ahigjzyp0u3khuvvkrerrqxk.png" alt="Bild"></div><br>  Wir m√ºssen eine Aktion und einen Getter im Repository erstellen.  Ein Getter gibt ein Produktobjekt zur√ºck.  Die Aktion ist etwas komplizierter.  Sie sollten den erstellten Hook, der die Datei static / products.json mit Axios liest, auf das Aktionsobjekt in Vuex √ºbertragen. <br><br>  Ich habe bereits erw√§hnt, dass Mutationen synchron sein m√ºssen und dass nur Aktionen in Vuex asynchronen Code akzeptieren k√∂nnen.  Um diese Einschr√§nkung zu umgehen, f√ºgen Sie den Axios-Code in die Vuex-Aktion ein. <br><br>  Erstellen Sie ein Aktionsobjekt in der Datei store.js und f√ºgen Sie die initStore-Methode hinzu.  Kopieren Sie den Inhalt des erstellten Hooks aus der Datei components / Main.vue in diese Methode.  Anstatt dem Produktobjekt response.data.products zuzuweisen, rufen wir die Mutation mit der Commit-Funktion auf.  √úbergeben Sie response.data.products als Argument an SET_STORE.  Der resultierende Code sollte folgenderma√üen aussehen (Listing 10.10). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nj/cp/od/njcpodi_wkiwlkhc5o_0du-1udu.png" alt="Bild"></div><br>  Wir sind fast fertig, wir m√ºssen nur die Datei Main.vue aktualisieren und die Waren vom lokalen Produktobjekt in das Vuex-Repository √ºbertragen.  √ñffnen Sie die Datei src / components / Main.vue und suchen Sie die Datenfunktion.  Entfernen Sie die Linienprodukte: {}.  Wir werden von dem berechneten Eigentum, das das Gesch√§ft zur√ºckgibt, auf die Waren zugreifen. <br><br>  Suchen Sie die berechneten Eigenschaften cartItemCount und sortedProducts in Main.vue. Sie sollten direkt nach dem Methodenabschnitt stehen.  F√ºgen Sie die Eigenschaft products hinzu und lassen Sie sie den gleichnamigen Getter zur√ºckgeben. <br><br>  Wir haben das Repository mit der Stamminstanz von Vue.js in der Datei main.js verbunden, sodass wir es nicht mehr importieren m√ºssen.  Dar√ºber hinaus ist bei Verwendung von Vue-CLI der Speicher immer in Form dieses. $ Store verf√ºgbar.  Vergessen Sie nicht das $ -Zeichen, da sonst ein Fehler auftritt.  F√ºgen Sie die Eigenschaft f√ºr berechnete Produkte hinzu, wie in Listing 10.11 gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1f/nj/ry/1fnjry2y8uanpzheonuljtcbzvi.png" alt="Bild"></div><br>  Suchen Sie den erstellten Hook, in dem das Produktobjekt initialisiert wird, und l√∂schen Sie dessen Inhalt.  F√ºgen Sie stattdessen den zuvor erstellten initStore-Aktionsaufruf in das Vuex-Repository ein.  Verwenden Sie zum Aufrufen einer Aktion die Versandfunktion wie im vorherigen Beispiel.  Listing 10.12 zeigt, wie der erstellte Hook nach dem Aktualisieren der Datei Main.vue aussehen sollte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/1b/40/vn1b40pqnqauvsjz-jsh7amutty.png" alt="Bild"></div><br>  Das sollte reichen.  F√ºhren Sie den Befehl npm run dev im Terminal aus, und auf dem Bildschirm sollte ein Fenster mit der Pet Store-Anwendung angezeigt werden.  Versuchen Sie, die Waren in den Warenkorb zu legen und stellen Sie sicher, dass alles so funktioniert, wie es sollte.  Wenn etwas schief gelaufen ist, suchen Sie in der Konsole nach Fehlern.  In der Datei src / store / store.js k√∂nnen Sie anstelle von Vuex.store versehentlich Vuex.Store eingeben.  Denken Sie daran! <br><br><h3>  10.5.  Hilfsmethoden Vuex </h3><br>  Vuex bietet praktische Hilfsmethoden, die den Code pr√§ziser gestalten und das Hinzuf√ºgen derselben Getter, Setter, Mutationen und Aktionen √ºberfl√ºssig machen.  Eine vollst√§ndige Liste der Vuex-Hilfsmethoden finden Sie im offiziellen Handbuch unter vuex.vuejs.org/guide/core-concepts.html.  Mal sehen, wie sie funktionieren. <br><br>  Die wichtigste Hilfsmethode, die Sie kennen sollten, hei√üt mapGetters.  Es wird verwendet, um alle verf√ºgbaren Getter zum berechneten Abschnitt hinzuzuf√ºgen, und erfordert nicht, dass jeder von ihnen aufgelistet wird.  Bevor Sie es verwenden k√∂nnen, m√ºssen Sie es in die Komponente importieren.  Kehren Sie erneut zur Zoohandlung zur√ºck und f√ºgen Sie die mapGetters-Methode hinzu. <br><br>  √ñffnen Sie die Datei src / components / Main.vue und suchen Sie das Skript-Tag.  Irgendwo in diesem Tag sollte die Header-Komponente importiert werden.  Verbinden Sie mapGetters sofort nach diesem Import, wie in Listing 10.13 gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/df/1a/oy/df1aoyonrmhjh26zev5aehqhtec.png" alt="Bild"></div><br>  Jetzt m√ºssen Sie die berechnete Eigenschaft aktualisieren.  Suchen Sie die Produktfunktion im berechneten Abschnitt und f√ºgen Sie das mapGetters-Objekt an seiner Stelle ein. <br><br>  mapGetters ist ein eindeutiges Objekt. F√ºr den ordnungsgem√§√üen Betrieb muss der Spread-Operator von ES6 verwendet werden. Er erweitert den Ausdruck in einer Situation, in der Argumente erwartet werden (null oder mehr).  Weitere Informationen zu dieser Syntax finden Sie in der MDN-Dokumentation unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_syntax</a> . <br><br>  mapGetters stellt sicher, dass alle Getter als berechnete Eigenschaften hinzugef√ºgt werden.  Dies ist eine viel einfachere und elegantere Methode als das Schreiben einer separaten berechneten Eigenschaft f√ºr jeden Getter.  Alle Getter werden im mapGetters-Array aufgelistet.  F√ºgen Sie diese Hilfsmethode zur Datei Main.vue hinzu (Listing 10.14). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w8/uc/4r/w8uc4rzccr0ygnfvoooi_7j8mda.png" alt="Bild"></div><br>  Nach dem Ausf√ºhren des Befehls npm run dev sollte die Zoohandlung wie zuvor funktionieren.  Die MapGetters-Hilfsmethode sieht bisher nicht sehr n√ºtzlich aus, aber je mehr Getter wir hinzuf√ºgen, desto mehr Zeit wird gespart. <br><br>  Es gibt drei weitere Hilfsmethoden, die Sie kennen sollten: mapState, mapMutations und mapActions.  Sie funktionieren alle auf √§hnliche Weise und reduzieren die Menge an Boilerplate-Code, die Sie manuell schreiben m√ºssen. <br><br>  Stellen Sie sich vor, Ihr Repository enth√§lt mehrere Daten und der Zugriff auf den Status erfolgt direkt von der Komponente aus, ohne dass Getter verwendet werden.  In diesem Fall k√∂nnen Sie die mapState-Methode im berechneten Abschnitt verwenden (Listing 10.15). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/09/yf/2w/09yf2w3fnle9nujbxlsqsdku3g4.png" alt="Bild"></div><br>  Stellen Sie sich nun vor, Sie m√ºssen mehrere Mutationen in einer Komponente verwenden.  Verwenden Sie zur Vereinfachung dieses Vorgangs die Hilfsmethode mapMutations (Listing 10.16), wie dies bei mapState und mapGetters der Fall ist.  Next mut1 bindet this.mut1 () an this. $ Store.commit ('mut1'). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6h/7y/py/6h7ypy5x0dsc400qmndzolgzr-m.png" alt="Bild"></div><br>  Betrachten Sie abschlie√üend die Hilfsmethode mapActions.  Sie k√∂nnen der Anwendung Vuex-Aktionen hinzuf√ºgen, ohne dass Methoden mit jeweils Versandaufrufen erstellt werden m√ºssen.  Stellen Sie sich zum vorherigen Beispiel vor, die Anwendung enth√§lt einige asynchrone Operationen.  Da die Verwendung von Mutationen ausgeschlossen ist, m√ºssen wir Ma√ünahmen ergreifen.  Nachdem Sie sie in Vuex erstellt haben, m√ºssen Sie im Methodenobjekt der Komponente auf sie zugreifen.  Dieses Problem kann mit mapActions gel√∂st werden.  act1 bindet this.act1 () an this. $ store.dispatch ('act1'), wie in Listing 10.17 gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6b/lf/e2/6blfe2nzmh7iotgvmia9d8nksto.png" alt="Bild"></div><br>  Betrachten Sie abschlie√üend die Hilfsmethode mapActions.  Sie k√∂nnen der Anwendung Vuex-Aktionen hinzuf√ºgen, ohne dass Methoden mit jeweils Versandaufrufen erstellt werden m√ºssen.  Stellen Sie sich zum vorherigen Beispiel vor, die Anwendung enth√§lt einige asynchrone Operationen.  Da die Verwendung von Mutationen ausgeschlossen ist, m√ºssen wir Ma√ünahmen ergreifen.  Nachdem Sie sie in Vuex erstellt haben, m√ºssen Sie im Methodenobjekt der Komponente auf sie zugreifen.  Dieses Problem kann mit mapActions gel√∂st werden.  act1 bindet this.act1 () an this. $ store.dispatch ('act1'), wie in Listing 10.17 gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ov/5m/jm/ov5mjmyoyymzvr09mtyibqsrhmk.png" alt="Bild"></div><br>  Wenn die Anwendung w√§chst, werden diese Hilfsmethoden immer n√ºtzlicher und reduzieren die Menge an Code, die geschrieben werden muss.  Beachten Sie, dass Sie die Eigenschaftsnamen in Ihrem Repository durchdenken m√ºssen, da Sie mithilfe von Hilfsmethoden in Komponenten darauf zugreifen k√∂nnen. <br><br><h3>  10.6.  Kurze Einf√ºhrung in Module </h3><br>  Zu Beginn dieses Kapitels haben wir die Datei store.js im Verzeichnis src / store erstellt.  F√ºr ein kleines Projekt ist dieser Ansatz durchaus angemessen.  Aber was ist, wenn es sich um eine viel gr√∂√üere Anwendung handelt?  Die Datei store.js w√§chst schnell und es wird schwierig sein, alles zu verfolgen, was darin passiert. <br>  Um dieses Problem zu l√∂sen, bietet Vuex das Konzept von Modulen an.  Mit Modulen k√∂nnen Sie den Speicher in mehrere kleinere Teile aufteilen.  Jedes Modul hat seine eigenen Zust√§nde, Mutationen, Aktionen und Getter. Sie k√∂nnen sie sogar ineinander verschachteln. <br><br>  Wir schreiben die Zoohandlung mit Modulen neu.  Die Datei store.js bleibt erhalten, daneben sollten Sie jedoch den Modulordner erstellen und dort die Datei products.js ablegen.  Die Verzeichnisstruktur sollte wie in Abb. 1 aussehen.  10.6. <br><br><img src="https://habrastorage.org/webt/-a/xi/tt/-axittmozbvjtdxsblaraowkbdy.png" align="left" alt="Bild">  In products.js m√ºssen Sie vier Objekte erstellen: Status, Getter, Aktionen und Mutationen.  Der Inhalt von jedem von ihnen sollte aus der Datei store.js kopiert werden. <br><br>  √ñffnen Sie die Datei src / store / store.js und kopieren Sie den Code daraus.  Wenn Sie fertig sind, sollte die Datei products.js folgenderma√üen aussehen (Listing 10.18). <br><br>  Jetzt m√ºssen wir den gesamten Code exportieren, den wir der Datei product.js hinzugef√ºgt haben.  Dadurch wird es in store.js importiert.  F√ºgen Sie am Ende der Datei den Standardausdruck f√ºr den Ausdrucksexport hinzu.  Dies ist eine Exportanweisung im ES6-Format, mit der Sie diesen Code aus anderen Dateien importieren k√∂nnen (Listing 10.19). <br><br>  Die Datei store.js sollte aktualisiert werden.  F√ºgen Sie ein Modulobjekt hinzu, in dem Sie alle neuen Module auflisten k√∂nnen.  Denken Sie daran, die zuvor erstellte Modul- / Produktdatei zu importieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qn/t1/mo/qnt1moalahiofswpasrzsw7dsec.png" alt="Bild"></div><br>  Unser Beispiel enth√§lt nur ein Modul. F√ºgen Sie es daher sofort zum Modulobjekt hinzu.  Sie m√ºssen auch alles Unn√∂tige aus Vuex.Store entfernen, wie in Listing 10.20 gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wf/f0/0u/wff00uliblovkw3hhwsr4xfsxni.png" alt="Bild"></div><br>  Durch den Import der Module haben wir den Refactoring-Prozess abgeschlossen.  Nach dem Aktualisieren der Seite sollte die Anwendung genau wie zuvor funktionieren. <br><blockquote>  Namespaces in Vuex <br><br>  In einigen gro√üen Projekten kann die Modularisierung bestimmte Probleme verursachen.  Wenn neue Module hinzugef√ºgt werden, k√∂nnen Konflikte mit den Namen von Aktionen, Gettern, Mutationen und Statuseigenschaften auftreten.  Beispielsweise k√∂nnen Sie versehentlich zwei Gettern in verschiedenen Dateien denselben Namen zuweisen.  Und da sich in Vuex alles in einem globalen globalen Namespace befindet, tritt in der Konsole ein doppelter Schl√ºsselfehler auf. <br>  Um dieses Problem zu vermeiden, platzieren Sie jedes Modul in einem separaten Namespace.  Geben Sie dazu einfach "namespaced: true" oben in Vuex.store an.  Weitere Informationen zu dieser Funktion finden Sie in der offiziellen Vuex-Dokumentation unter vuex.vuejs.org/en/guide/modules.html. </blockquote>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% <b>Rabatt</b> auf Gutschein f√ºr <b>H√§ndler</b> - <b>Vue.js</b> <br><br>  Nach Zahlung der Papierversion des Buches wird eine elektronische Version des Buches per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448304/">https://habr.com/ru/post/de448304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448294/index.html">Das Gesetz zur Isolation der Runen wird von der Staatsduma in drei Lesungen verabschiedet</a></li>
<li><a href="../de448296/index.html">Freiberuflich und finanziell: 5 M√∂glichkeiten, sich zwischen einem Kunden und einem Freiberufler niederzulassen</a></li>
<li><a href="../de448298/index.html">GLTF- und GLB-Grundlagen, Teil 2</a></li>
<li><a href="../de448300/index.html">Konferenz mailto: CLOUD - √ºber Wolken und Umgebung</a></li>
<li><a href="../de448302/index.html">Durch die Sicherheitsanf√§lligkeit in AdBlock- und uBlock-Filtern kann beliebiger Code auf der Benutzerseite ausgef√ºhrt werden</a></li>
<li><a href="../de448308/index.html">Data Science Digest (April 2019)</a></li>
<li><a href="../de448310/index.html">Schreiben eines Telegrammbots in Python mit der Telebot-Bibliothek Teil 1</a></li>
<li><a href="../de448316/index.html">Bestimmung der Hunderasse: Ein vollst√§ndiger Entwicklungszyklus, von einem neuronalen Netzwerk in Python bis zu einer Anwendung bei Google Play</a></li>
<li><a href="../de448320/index.html">Warum Silizium und warum CMOS?</a></li>
<li><a href="../de448322/index.html">C ++ Russia 2019: kostenlose √úbertragung der ersten Halle und ein wenig dar√ºber, was auf der Konferenz sein wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>