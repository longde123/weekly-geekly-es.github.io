<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title> ざ 碉 Guardar datos en una EEPROM en un Arduino transaccionalmente 锔  </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La presencia de EEPROM brinda a los desarrolladores una herramienta conveniente para guardar los par谩metros de configuraci贸n o un estado que cambia le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guardar datos en una EEPROM en un Arduino transaccionalmente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482918/">  La presencia de EEPROM brinda a los desarrolladores una herramienta conveniente para guardar los par谩metros de configuraci贸n o un estado que cambia lentamente para que un apag贸n pueda sobrevivir.  En este art铆culo veremos c贸mo hacer esto de la manera m谩s segura y conveniente posible para no olvidar nada y no recordar lo que no estaba all铆. <br><a name="habracut"></a><br>  Supongamos que tenemos una variable y queremos almacenarla en una EEPROM.  Parece que todas las herramientas para esto est谩n en nuestras manos: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;EEPROM.h&gt; int my_var = DEFAULT_VALUE; EEPROM.get(MY_VAR_ADDR, my_var); my_var = NEW_VALUE; EEPROM.put(MY_VAR_ADDR, my_var);</span></span></span></span></code> </pre> <br>  Sin embargo, una mirada m谩s cercana revela que este enfoque crea m谩s problemas de los que resuelve.  Los discutiremos en orden. <br><br>  1. 驴C贸mo asegurarnos de que leemos exactamente lo que escribimos (para garantizar la <b>integridad</b> )?  Imagina la siguiente imagen.  Nos escribimos una carta a nosotros mismos en caso de nuestra muerte repentina por una p茅rdida de energ铆a o una se帽al de reinicio y la guardamos en un caj贸n del escritorio.  En la pr贸xima vida, abrimos el caj贸n del escritorio, sacamos un trozo de papel, leemos el mensaje y continuamos nuestra misi贸n.  El problema es que en el cuadro siempre hay hojas de papel garabateadas con texto aleatorio.  Por lo tanto, necesitamos una forma de distinguir el mensaje correcto del aleatorio.  Uno podr铆a asegurarle un notario p煤blico, pero en el caso m谩s simple, su firma ser铆a suficiente si tenemos una forma de verificar su exactitud.  Por ejemplo, podemos usar el resultado de una expresi贸n matem谩tica dependiendo del texto como firma, de modo que la probabilidad de coincidencia aleatoria sea suficientemente peque帽a.  En el caso m谩s simple, este es un CRC o suma de verificaci贸n.  Nos proteger谩 no solo de leer lo que no escribimos, sino tambi茅n de leer un mensaje da帽ado.  Despu茅s de todo, el texto se desvanece con el tiempo, y los electrones en el obturador aislado son a煤n menos duraderos: una part铆cula volar谩 desde el espacio con suficiente energ铆a y la broca cambiar谩.  Pero hay otra forma de obtener un mensaje da帽ado: esto no es agregarlo al final.  No es tan ex贸tico, porque en el momento de la grabaci贸n, el consumo actual aumenta bruscamente, lo que puede provocar una muerte prematura del escritor. <br><br>  2. Supongamos que estamos convencidos de la exactitud del mensaje, pero 驴c贸mo puedo asegurarme de que fui yo quien lo escribi贸 (para garantizar la <b>autenticidad</b> )?  Como dice el refr谩n, soy diferente.  De repente, alguien m谩s estaba sentado en esta mesa antes de mi reencarnaci贸n, y 茅l ten铆a una misi贸n diferente, y 驴por qu茅 raz贸n ahora me guiar茅 por sus mensajes?  Si proporcion谩ramos nuestras notas con una etiqueta determinada, ser铆a m谩s f谩cil para nosotros distinguir las nuestras de los extra帽os.  Por ejemplo, dicha etiqueta podr铆a ser el nombre de la variable que estamos guardando.  El 煤nico problema es que en EEPROM no hay mucho espacio para poner nombres de variables all铆, y es inconveniente hacerlo, porque son de diferentes longitudes.  Pero, afortunadamente, hay una forma m谩s simple: puede calcular la suma de verificaci贸n en nombre de la variable y usarla como un acceso directo.  Al mismo tiempo, es 煤til agregar el tama帽o de la variable en bytes a esta suma de verificaci贸n para no leer accidentalmente la cantidad incorrecta.  Bueno, en aras de la exhaustividad, agregamos otro identificador num茅rico all铆, para garantizar distinguir nuestra variable de otra persona, incluso si se les llama igual.  Llamamos a este n煤mero el identificador de instancia (inspirado por OOP si el nombre de la variable se considera como un campo de objeto).  Si alguna vez mejoramos nuestra misi贸n a una versi贸n radicalmente nueva, para que esta actualizaci贸n no tenga sentido todo lo que guard贸 la anterior, entonces solo tenemos que cambiar el identificador de instancia para invalidar todo lo guardado por la versi贸n anterior. <br><br>  3. 驴C贸mo puedo hacer que una operaci贸n de escritura incompleta deje el antiguo valor almacenado sin cambios?  Es decir, la operaci贸n de salvar deber铆a tener 茅xito o no deber铆a tener ning煤n efecto observable.  En otras palabras, deber铆a ser <b>at贸mico</b> o transaccional si estamos hablando de una transacci贸n que se reduce a una actualizaci贸n incondicional de un solo valor.  Obviamente, no podemos garantizar la atomicidad del registro reescribiendo el valor anterior, debemos escribir en un nuevo lugar para que el valor almacenado anterior permanezca intacto, al menos hasta que se complete la grabaci贸n del nuevo.  Esta t茅cnica a menudo se llama 'copiar en escritura' si solo se actualiza parte del valor guardado, pero la parte que permanece sin cambios todav铆a se copia y se escribe en una nueva ubicaci贸n.  Al desarrollar nuestra analog铆a, nos escribiremos cartas a nosotros mismos, dejando intactas las antiguas, pero suministrando a cada letra un n煤mero de serie cada vez mayor para que en nuestra pr贸xima vida tengamos la oportunidad de encontrar la 煤ltima carta que escribimos.  Al mismo tiempo, sin embargo, surge un nuevo problema: el lugar en el cuadro donde colocamos las letras terminar谩 tarde o temprano si no desechamos las letras viejas que se han vuelto irrelevantes.  Es f谩cil entender que es suficiente almacenar solo 2 letras, una antigua y una nueva, puede estar en proceso de escritura.  En consecuencia, el n煤mero de letra tampoco necesita muchos bits. <br><br>  Por extra帽o que parezca, el autor no pudo encontrar una implementaci贸n 煤nica que permitiera la organizaci贸n del almacenamiento de datos en EEPROM, al tiempo que garantizaba la integridad, la autenticidad y la atomicidad.  Tuve que escribir a <a href="https://github.com/olegv142/NvTx" rel="nofollow">github.com/olegv142/NvTx</a> yo mismo <br><br>  Para guardar cada variable en la EEPROM, se utilizan 2 谩reas consecutivas: celdas con la misma estructura.  El identificador de la variable calculado sobre la base de su tama帽o, etiqueta de texto e identificador de instancia se escribe en los primeros 2 bytes.  A continuaci贸n, se escriben los datos, seguidos de 2 bytes de la suma de verificaci贸n.  En el primer byte, dos bits tienen un prop贸sito especial.  El bit m谩s significativo es el indicador de correcci贸n; cuando se escribe, siempre se establece en uno.  El bit de orden inferior se usa como un n煤mero de un solo bit de la era; es necesario para encontrar el 煤ltimo mensaje.  La grabaci贸n se realiza en celdas 'en c铆rculo'.  El n煤mero de la era cambia cada vez que se realiza un registro en la primera celda.  De ah铆 el algoritmo para determinar la 煤ltima celda registrada: si las 茅pocas de las celdas son iguales, entonces el segundo se escribe 煤ltimo, si es diferente, entonces el primero. <br><br>  El bit de correcci贸n parece redundante, pero tiene una funci贸n importante.  En primer lugar, leemos los datos almacenados y verificamos la correcci贸n de ambas celdas.  Si la celda no pasa la verificaci贸n del identificador o suma de verificaci贸n correctos, restablecemos el bit de correcci贸n.  Las operaciones de escritura posteriores pueden no verificar la correcci贸n de las celdas, pero se basan en este indicador, que reduce la sobrecarga en aproximadamente 2 veces. <br><br>  Aquellos que quieran profundizar en los detalles de implementaci贸n pueden ver las im谩genes y el c贸digo en el <a href="https://github.com/olegv142/NvTx" rel="nofollow">repositorio</a> .  Yo, para no aburrir al lector, paso al uso.  Las funciones de escritura / lectura de datos reciben cada una 5 par谩metros, por lo que se sacrifica la conveniencia de su uso en favor de la flexibilidad.  Pero est谩 generosamente compensado por dos conjuntos de macros, que hacen que el uso de la biblioteca sea tan simple como en el caso de EEPROM.get / put.  El primer conjunto de macros se usa si solo desea guardar la variable en la direcci贸n dada: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; bool have_my_var = NvTxGetAt(my_var, MY_VAR_ADDR); my_var = NEW_VALUE; NvTxPutAt(my_var, MY_VAR_ADDR);</span></span></span></span></code> </pre><br>  Si hay varias variables para guardar, cada una tendr谩 que determinar la direcci贸n y, al mismo tiempo, considerar correctamente el tama帽o para que las 谩reas de memoria donde se almacenan las variables no se superpongan.  Para simplificar la tarea, el segundo conjunto de macros implementa la asignaci贸n autom谩tica de direcciones, y lo hace <b>en tiempo de compilaci贸n</b> .  Por ejemplo, la <a href="https://github.com/thijse/Arduino-EEPROMEx" rel="nofollow">biblioteca Arduino-EEPROMEx</a> puede asignar memoria en tiempo de ejecuci贸n, mientras almacena la direcci贸n en RAM para cada variable almacenada.  La biblioteca <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx</a> asigna espacio en la EEPROM sin agregar nada al c贸digo ejecutable o al contenido de la RAM. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; char my_string[16] = ""; NvPlace(my_var, MY_START_ADDR, MY_INST_ID); NvAfter(my_string, my_var); bool have_my_var = NvTxGet(my_var); my_var = NEW_VALUE; NvTxPut(my_var);</span></span></span></span></code> </pre><br>  La macro NvPlace establece la direcci贸n de inicio del 谩rea EEPROM, donde almacenaremos las variables y el identificador de instancia.  La macro NvAfter reserva una regi贸n de memoria para almacenar su primer argumento inmediatamente despu茅s de la regi贸n de memoria reservada para el segundo.  Al asignar memoria, tambi茅n se verifica que no excedimos el tama帽o de EEPROM disponible y que no reservamos 谩reas de memoria superpuestas (esto puede suceder si dos macros NvAfter tienen el mismo segundo argumento).  En caso de violaci贸n de cualquiera de las dos condiciones especificadas, el programa simplemente no compila.  Aquellos que quieran lidiar con el mecanismo de asignaci贸n de memoria lo encontrar谩n en el archivo de encabezado <a href="" rel="nofollow">NvTx.h.</a>  Todo lo que hacen las macros NvPlace y NvAfter es definir las enumeraciones, formando sus nombres basados en los nombres de las variables, y tambi茅n usar la construcci贸n idiom谩tica muy 煤til de la <a href="" rel="nofollow">afirmaci贸n de tiempo de compilaci贸n</a> . <br><br>  Esperemos que la biblioteca <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx</a> ayude a los lectores a escribir c贸digo confiable de grado industrial. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482918/">https://habr.com/ru/post/482918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482902/index.html">No, la inteligencia artificial no puede vencernos.</a></li>
<li><a href="../482904/index.html">Una breve historia de los microprocesadores espaciales, primera parte</a></li>
<li><a href="../482906/index.html">Sobre seguridad de red</a></li>
<li><a href="../482908/index.html">La segunda parte de la traducci贸n del libro de David Kouchner Masters of Doom. Cap铆tulos 6-12</a></li>
<li><a href="../482912/index.html">La idea de una red social descentralizada de pr贸xima generaci贸n</a></li>
<li><a href="../482920/index.html">C贸mo el piloto autom谩tico entr贸 en nuestras vidas, pero no nos dimos cuenta</a></li>
<li><a href="../482922/index.html">Drupal Digest - 2019 / diciembre</a></li>
<li><a href="../482926/index.html">Arc es un sistema de control de versiones para un monorepository. Informe Yandex</a></li>
<li><a href="../482928/index.html">Predator Vision: efecto de visi贸n t茅rmica</a></li>
<li><a href="../482930/index.html">Investigaci贸n geneal贸gica: libros de m茅tricas, censos, archivos, bases de datos abiertas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>