<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêõ üôåüèª ü¶ó A la cuesti√≥n de los tampones (anillo) üëçüèø üåü üñïüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Si encuentra que los costos de desarrollo de la arquitectura son excesivos, considere cu√°nto puede costarle la arquitectura incorrecta" 
 - No puedo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A la cuesti√≥n de los tampones (anillo)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438476/"><h3>  "Si encuentra que los costos de desarrollo de la arquitectura son excesivos, considere cu√°nto puede costarle la arquitectura incorrecta" </h3><br>  - No puedo recordar exactamente la fuente <br><br>  Una vez, "hace mucho tiempo, en una galaxia distante", compr√© el maravilloso libro de Charles Weatherly "Etudes for Programmers", en la introducci√≥n a la cual el autor confirm√≥ la necesidad de estudiar ejemplos educativos y tareas antes de comenzar una programaci√≥n independiente.  Le recomiendo que encuentre este libro, lea el prefacio (y sin detenerse en √©l, lea el resto y resuelva los problemas que contiene), ya que no puedo justificar mejor la necesidad de tal pr√°ctica.  Incluso si sigue mi recomendaci√≥n y adquiere muchos conocimientos y habilidades pr√°cticas al leer el libro, puede regresar y leer esta publicaci√≥n, ya que est√° dedicada a varios otros temas.  Y si no sigues mis recomendaciones, tanto m√°s debes ir debajo del gato. <br><a name="habracut"></a><br>  No hace mucho tiempo, en una publicaci√≥n en la que lo rega√±√©, expres√© mi opini√≥n sobre un RTOS dom√©stico, mencion√© que la implementaci√≥n del b√∫fer de anillo en la conocida biblioteca mcucpp (y en ciertos aspectos, absolutamente maravillosa) no puede considerarse ideal.  Tratar√© de explicar mi punto de vista e imaginar la implementaci√≥n ideal (en la medida de lo posible en el mundo real).  Nota: el texto ofrecido a su atenci√≥n estuvo en "inacabado" durante bastante tiempo, y luego apareci√≥ un caso tan conveniente. <br><br>  Continuamos desarrollando una biblioteca para trabajar con un dispositivo perif√©rico, y somos los siguientes en la l√≠nea de gesti√≥n de memoria y almacenamiento en b√∫fer (s√≠, todav√≠a continuamos las operaciones preparatorias, pero sin ellas de ninguna manera).  ¬øDe d√≥nde viene la necesidad de organizar amortiguadores y qu√© tipo de animal es?  El hecho es que una parte importante de la periferia tiene una velocidad limitada y el proceso de transmisi√≥n, que se inicia de una forma u otra, lleva un tiempo determinado, y a veces muy significativo, en comparaci√≥n con la creaci√≥n de otra porci√≥n de informaci√≥n para la transmisi√≥n.  Por supuesto, antes de que este tiempo haya pasado, la siguiente transmisi√≥n no se puede realizar y, en consecuencia, no se puede iniciar. <br><br>  Tenemos un caso cl√°sico de un par escritor-lector con diferentes velocidades.  Es simplemente imposible resolver este problema de manera general, ya que "con un exceso arbitrariamente peque√±o, pero no cero, del flujo de solicitudes sobre el flujo de servicio, el tama√±o de la cola tiende al infinito", y el infinito es fundamentalmente imposible.  Pero un caso especial del problema, cuando tenemos r√°fagas locales de solicitudes, pero en promedio el flujo de servicio puede hacer frente a la carga, se puede resolver una memoria intermedia de capacidad suficiente.  Prestemos atenci√≥n a la frase "capacidad suficiente", luego aprenderemos c√≥mo calcularla, siempre y cuando el hecho de que esto sea fundamentalmente posible sea suficiente para nosotros. <br><br>  Por supuesto, si la memoria intermedia es un requisito absoluto, no lo es.  Para la informaci√≥n transmitida, puede usar un registro de bloqueo, pero con la informaci√≥n recibida es algo peor, tendr√° que agregarse en alg√∫n lugar antes del procesamiento, si no toma las medidas apropiadas en el protocolo de nivel superior (la expresi√≥n m√°gica xon / xoff no naci√≥ desde cero), lo que no siempre es posible y, en cualquier caso, generalmente conduce a una limitaci√≥n significativa de la velocidad de transmisi√≥n.  Tambi√©n hay una implementaci√≥n de hardware de memorias intermedias internas en dispositivos perif√©ricos (al menos para un elemento), pero esto no siempre se hace y el tama√±o de la memoria intermedia est√° estrictamente limitado desde arriba. <br><br>  Por lo tanto, a√∫n implementaremos el b√∫fer de programa, para lo cual ser√≠a natural usar el m√©todo FIFO (es decir, la cola) para organizar dicho b√∫fer, y la cola, a su vez, se implementa mejor en un b√∫fer en anillo con dos punteros.  Cuando escribo "mejor", esto no significa en absoluto que otras implementaciones (por ejemplo, una cola de referencia) sean imposibles o tengan fallas fatales que no sean fatales.  Esta expresi√≥n solo significa que la implementaci√≥n no ser√° demasiado complicada y bastante efectiva, aunque otros pueden tener ventajas innegables sobre ella, por lo que tendr√°n que pagar por algo, porque DarZaNeBy. <br><br>  Dado que es muy poco probable que su modelo MK tenga una implementaci√≥n de hardware de un dispositivo de uso tan general (los m√≥dulos perif√©ricos individuales pueden tener sus propios buffers de anillo, pero no tienen nada que ver con el tema de esta publicaci√≥n), tendremos que crear un buffer de anillo en la memoria lineal (implementar en vector, este es, de hecho, el √∫nico objeto natural en la memoria direccionable), y para esto, se requerir√° un √≠ndice de b√∫fer (o tal vez incluso dos √≠ndices, pero m√°s sobre eso m√°s adelante).  En mi opini√≥n, un b√∫fer circular con dos punteros (√≠ndices) es la √∫nica forma aceptable de implementar una cola en un vector, pero hay diferentes puntos de vista sobre este tema y vi con mis propios ojos una implementaci√≥n en el estilo de "x1 = x2;  x2 = x3; ... x8 = nuevo s√≠mbolo ", si quieres, no lo considerar√© tan ex√≥tico.  El hecho de que el fragmento dado pueda tener derecho a existir en una situaci√≥n espec√≠fica y muy limitada no lo hace aceptable en general. <br><br>  Consideraremos la implementaci√≥n correcta del m√≥dulo del programa para organizar el puntero y, para comenzar, prestaremos atenci√≥n a la primera palabra en la definici√≥n.  La diferencia entre un c√≥digo correcto y uno incorrecto no es solo porque el c√≥digo correcto no contiene errores, aunque este es un requisito absoluto.  Incluso el c√≥digo que realiza completamente sus funciones puede ser incorrecto si es incomprensible, o si hay una opci√≥n que no es menos clara, pero se ejecuta m√°s r√°pido o se ejecuta tan r√°pido, pero m√°s claramente escrito, por lo que el concepto de correcci√≥n es algo relativo.  Continuamos considerando nuestro ejemplo de implementaci√≥n de b√∫fer, que nos permitir√° demostrar la diferencia entre diferentes grados de correcci√≥n. <br><br>  Antes de pasar a la esencia, un punto importante sobre la discusi√≥n adicional.  Quiero decir que su compilador siempre est√° activado en un nivel de optimizaci√≥n diferente de cero (-O2), por lo que no tenemos que pensar en mejoras menores como 1) modificaci√≥n del prefijo versus postfix, o 2) usar los resultados de la operaci√≥n anterior, o 3) la diferencia entre el incremento y la suma unidades, etc., suponemos que el compilador har√° mucho por nosotros.  Por supuesto, esto no es una suposici√≥n estricta, pero de lo contrario tendremos que sumergirnos en las entra√±as del ensamblador, que en nuestro tiempo no es la corriente principal. <br><br>  Perm√≠tame recordarle que se nos indic√≥ que implementemos el √≠ndice (puntero) del b√∫fer en anillo, es decir, necesitamos crear el comportamiento de una variable que se <b>ejecuta secuencialmente a trav√©s de una serie de valores, desde algunos iniciales hasta otros finales</b> .  Suponga de inmediato que el valor inicial ser√° cero, de lo contrario tendremos que escribir un c√≥digo m√°s o menos correcto, y esto contradice los objetivos educativos y no tenemos prisa, y el √∫ltimo es Max. <br><br>  Este comportamiento de la variable se puede implementar utilizando la siguiente construcci√≥n: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (++Counter) % (Max+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  y es precisamente ese c√≥digo el que podemos ver en muchos (es decir, muy a menudo) casos.  Lo que est√° mal: bueno, en primer lugar, durante alg√∫n tiempo (desde la realizaci√≥n de la operaci√≥n de incremento hasta la asignaci√≥n del resultado) nuestra variable ser√° mayor que el valor m√°ximo permitido y, si en ese momento se produce una interrupci√≥n que debe tener en cuenta el valor de esta variable, entonces predigo personalmente No presumo los resultados.  Por lo tanto, reescribimos el programa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter=<span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) % (Max + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Hemos eliminado un error, y el c√≥digo (en adelante me referir√© al c√≥digo "c√≥digo" significa que el c√≥digo ejecutable generado por el compilador) no se ha alargado y ya no se ejecuta (de hecho, se ejecuta m√°s r√°pido, sino solo porque en la primera versi√≥n la palabra vol√°til se usa completamente redundante en este caso), y no se ha vuelto menos clara (m√°s bien, a√∫n m√°s clara, pero esto es cuesti√≥n de gustos). <br><br>  Nota necesaria sobre vol√°til: esta directiva es necesaria si queremos evitar la optimizaci√≥n del c√≥digo que conduce a una ejecuci√≥n incorrecta, y en este caso particular (cuando el valor de la variable no cambia fuera del alcance del m√≥dulo y no hay entradas secuenciales en √©l) (directiva ) completamente redundante.  Le recomiendo que mire el c√≥digo generado para ambas opciones en godbolt.org.  Por qu√© no debe abusar de la directiva vol√°til, a diferencia de la palabra clave est√°tica, que se recomienda utilizar siempre que sea posible.  Bueno, en primer lugar, prohibimos la optimizaci√≥n, es decir, el c√≥digo definitivamente no ser√° m√°s r√°pido (lo m√°s probable es que se haga m√°s grande y m√°s lento, pero preferimos formulaciones estrictas).  Y en segundo lugar, en este caso particular, esta palabra es enga√±osa, ya que en relaci√≥n con nuestro programa, el valor del contador no puede cambiar de ninguna manera fuera de nuestro control.  En un programa que lee su valor, es decir, en la implementaci√≥n del b√∫fer en anillo, puede considerar el contador como mutable fuera del m√≥dulo, y all√≠ es cuestionable, por lo tanto, este atributo simplemente no es aplicable al contador.  Si una variable se debe interpretar de manera diferente en diferentes m√≥dulos, nuestros servicios se deben combinar, si estamos hablando de organizar una secci√≥n cr√≠tica, por ejemplo, al implementar una transacci√≥n u operaciones at√≥micas, entonces esta directiva no da nada en absoluto. <br><br>  Volvemos al c√≥digo y vemos que el programa todav√≠a est√° mal, lo que pasa, y el hecho es que no es lo que necesitamos (ver la descripci√≥n de la tarea), sino algo m√°s (calcula el resto de la divisi√≥n), solo los resultados emparejar  Bueno, creemos que s√≠ (no lo creo, pero los autores del c√≥digo ciertamente), que los resultados coinciden, de hecho, en el caso general, no coinciden, solo tuvimos suerte con el rango de la variable (valores positivos).  Adem√°s, el proceso de ejecuci√≥n del c√≥digo es m√°s largo de lo que podr√≠a hacerse, ya que en el mejor de los casos tenemos la operaci√≥n de divisi√≥n de enteros (si es parte de los comandos de nuestra arquitectura), y no se realiza de ninguna manera en un ciclo de procesador (un valor caracter√≠stico de 10 ciclos para arquitectura de 8 bits), y en el peor de los casos, veremos la llamada al procedimiento de divisi√≥n desde la biblioteca est√°ndar (y bueno, si es una divisi√≥n corta), el tiempo de ejecuci√≥n ser√° de decenas de ciclos de reloj. <br><br>  Entonces, ¬øpor qu√© todav√≠a es posible encontrar un enfoque tan completamente equivocado tan a menudo?  Aqu√≠, desde la audiencia, me dicen que con el valor de Max + 1, que es una potencia de dos, el compilador adivinar√° en lugar de la operaci√≥n de divisi√≥n, colocar√° la operaci√≥n de multiplicaci√≥n bit a bit en la m√°scara correspondiente (igual a Max), que se realizar√° muy r√°pidamente y todo estar√° bien. <br><br>  Estoy de acuerdo con esta declaraci√≥n y adopto este enfoque, si no fuera por las siguientes circunstancias: <br><br><ul><li>  esto solo es posible para Mach est√°ticamente definido en la etapa de compilaci√≥n, </li><li>  esto solo sucede cuando la optimizaci√≥n est√° habilitada, </li><li>  esto solo sucede cuando Mach cumple esta condici√≥n, </li><li>  Esto no ocurre para todos los tipos cardinales. </li></ul><br>  Adem√°s, es en este caso particular (cuando la variable se define como un signo), adem√°s del comando de multiplicar (l√≥gico) por la m√°scara, se generar√° un comando de comparaci√≥n con cero y una rama para valores negativos, y aunque esta rama nunca ser√° para nuestro rango se ejecutar√°, ocupar√° espacio en la memoria (y en el caso de una funci√≥n sustituible, tomar√° varias veces) y llevar√° tiempo realizar la operaci√≥n de comparaci√≥n, si no lo cree, nuevamente vamos al sitio especificado y lo veremos por usted mismo.  Otro argumento a favor de los cardenales sin firmar, al que recientemente dediqu√© una publicaci√≥n completa. <br><br>  Por lo tanto, si queremos usar la multiplicaci√≥n l√≥gica con una m√°scara (obtenida al optimizar el c√°lculo del resto), entonces deber√≠amos reescribir el m√≥dulo en consecuencia: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Counter_t; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> sCounter_t; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> IS_POWER2(Max + 1) return (Counter + 1) &amp; Max #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return (Counter + 1) % (Max + 1); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>  En esta versi√≥n, todo es completamente claro y controlable y todo es cierto (aunque persisten algunas deficiencias, pero ahora son obvias y no est√°n enmascaradas), por lo tanto, es correcto, aunque es m√°s correcto y ahora las buscaremos.  El principal inconveniente, en mi opini√≥n, es una violaci√≥n del principio KISS, ya que el uso de la operaci√≥n restante por divisi√≥n descuida completamente este principio.  Por lo tanto, ahora destruiremos todas las deficiencias de un solo golpe (no te preocupes por su destino, renacer√°n 100,500 veces, porque no todos los programadores de Arduino leen mis publicaciones). <br><br>  Pero primero, una ligera desviaci√≥n hacia un lado.  ¬øC√≥mo podemos implementar una verificaci√≥n de la potencia de dos (un n√∫mero binario se puede representar como {0} 1 {0}) que acabamos de usar <br><br><div class="spoiler">  <b class="spoiler_title">no espiar</b> <div class="spoiler_text">  #define IS_POWER2 (N) ((((((N) - 1) &amp; (N)) == 0) <br></div></div><br>  ¬øY c√≥mo podemos implementar la verificaci√≥n de que un n√∫mero es una secuencia correcta de unidades {0} 1 {1} en notaci√≥n binaria? Una opci√≥n es obvia <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) IsPower2 ((N) + 1)</span></span></code> </pre> <br>  y el segundo es trivial <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) ( (((N) + 1) &amp; (N)) == 0)</span></span></code> </pre> <br>  Nota: no puedo evitar recordar el magn√≠fico teorema: "Un n√∫mero trascendental en un grado trascendental siempre es trascendental, a menos que lo contrario sea obvio o trivial". <br><br>  ¬øY c√≥mo podemos verificar que un n√∫mero sea una secuencia de unidades {0} 1 {1} {0} <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsSequence(N) IsPower2( (N) ^ ((N) &lt;&lt; 1))</span></span></code> </pre> <br>  Y finalmente, c√≥mo seleccionar el n√∫mero menos significativo de un n√∫mero (no s√© por qu√© esto podr√≠a ser necesario, pero ser√° √∫til) <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LowerBit(N) ((((N) - 1) ^ (N)) &amp; (N)).</span></span></code> </pre> <br><br>  Pero se le ocurri√≥ lo que puede ser √∫til <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) (IsSequence(N) &amp;&amp; (LowerBit(N) == 1))</span></span></code> </pre> <br>  Una observaci√≥n curiosa: estas macros no son del todo correctas, resulta que 0 es una potencia de dos y una secuencia correcta (por supuesto, una secuencia tambi√©n), lo cual es un poco extra√±o.  Pero 1 es todos estos objetos con bastante raz√≥n, por lo que parece que cero solo debe considerarse por separado.  Otra propiedad interesante de estas macros es que no hacemos suposiciones sobre la longitud del argumento, es decir, funcionan correctamente con cualquier tipo cardinal. <br><br>  Hay un libro maravilloso, Trucos para programadores, donde puede encontrar las macros mencionadas y muchas otras tareas igualmente divertidas e instructivas, le recomiendo leerlo, especialmente porque no contiene demasiadas letras. <br><br>  Pero volvamos a nuestro √≠ndice de b√∫fer en anillo.  Dimos la soluci√≥n correcta, pero prometimos a√∫n m√°s correctamente, lo que significa que nuestra √∫ltima soluci√≥n tiene fallas (qui√©n lo dudar√≠a).  Uno de ellos, la longitud del b√∫fer debe determinarse est√°ticamente en la etapa de compilaci√≥n, el segundo, en caso de una longitud fallida, el tiempo de ejecuci√≥n es muy largo y todav√≠a hay un cierto n√∫mero de errores en una parte relativamente peque√±a del programa, lo que nos hace recordar un chiste sobre 4 errores al escribir la palabra "m√°s".  Los eliminaremos a todos (algunos se dejar√°n para m√°s adelante) e inmediatamente, para lo cual, finalmente, escribiremos la soluci√≥n al problema original como es: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; Max) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; };</code> </pre> <br>  (Como ya entendi√≥, soy partidario de los corchetes egipcios y no hay nada que hacer al respecto). <br><br>  Prestemos atenci√≥n al hecho de que simplemente reescribimos la condici√≥n del problema desde un lenguaje natural en el lenguaje de programaci√≥n elegido, por lo que resulta extremadamente claro y comprensible.  ¬øEs posible mejorarlo? Sin duda, pero solo desde el punto de vista de la velocidad del c√≥digo, ya que simplemente no hay otras deficiencias para esta soluci√≥n (no hay deficiencias obvias, de hecho existen y las eliminaremos con √©xito). <br><br>  Evaluemos la complejidad computacional de esta soluci√≥n: suma con unidad (1) y comparaci√≥n (2) siempre, luego asignando cero (1) (raramente) o sumando (1) (casi siempre), lo que da 1 + 2 + 1 + Œî ~ 4 elemental operaciones y memoria cero.  Es posible que un buen compilador en el modo correcto haga ciertas optimizaciones y reduzca el tiempo de ejecuci√≥n del c√≥digo, pero es mejor que lo hagamos expl√≠citamente.  Aqu√≠ est√° la siguiente opci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> sCounter_t Tmp; Tmp = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &gt; Max) { Tmp = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  Evaluamos la complejidad - suma y comparaci√≥n siempre, asignando cero (raramente) - aproximadamente 3 operaciones y un elemento de memoria.  De hecho, la versi√≥n anterior tambi√©n ten√≠a un elemento de memoria (impl√≠cito), por lo que tenemos una ganancia neta en una operaci√≥n elemental.  Adem√°s, la versi√≥n anterior ten√≠a dos inconvenientes m√°s: 1) viol√≥ el principio DRY (calcul√≥ el aumento en uno dos veces) y 2) tuvo m√°s de un punto de salida, lo que no es bueno.  Tampoco perdimos la comprensi√≥n, es decir, logramos matar a un mont√≥n de conejos de un disparo, y tampoco gastamos ning√∫n cartucho, es solo una historia al estilo del Bar√≥n Munchausen. <br><br>  Tenga en cuenta que no <code>if ( (Tmp = Counter + 1) &gt; Max)</code> construcci√≥n <code>if ( (Tmp = Counter + 1) &gt; Max)</code> , aunque contiene una instrucci√≥n expl√≠cita para el compilador para tratar de no hacer transferencias redundantes.  Esto es aromatizante en la forma m√°s flagrante, simplemente no me gusta el valor devuelto por el operador de asignaci√≥n e intento evitar usarlo.  No puedo explicar la raz√≥n de este fuerte sentimiento, seg√∫n Freud, es muy probable que sea un trauma psicol√≥gico en la infancia.  Los compiladores modernos son bastante capaces de llevar a cabo una optimizaci√≥n simple por s√≠ mismos, y adem√°s, tambi√©n agregu√© un calificador de registro, por lo que el c√≥digo de mi versi√≥n y el correcto (desde el punto de vista del lenguaje C) coincidir√°n.  Sin embargo, no limito en absoluto su libertad para usar el m√©todo que le parezca preferible. <br><br>  Continuamos mejorando, porque no hay l√≠mite para la perfecci√≥n y todav√≠a no la hemos alcanzado.  Para lograrlo, reformulamos un poco el problema original y dejamos solo que el requisito de la variable est√© en el rango de valores, sin indicar la direcci√≥n del cambio.  Este enfoque le permite reescribir el programa de la siguiente manera <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> Counter_t Tmp; Tmp = (Counter - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Tmp = ; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  A primera vista, nada ha cambiado mucho, pero, sin embargo, obtenemos una ganancia en el tiempo.  Por supuesto, no debido al hecho de que la operaci√≥n de disminuir por uno funciona m√°s r√°pido que la operaci√≥n de aumentar por √©l (aunque escuch√© una versi√≥n similar), sino debido a las peculiaridades de la comparaci√≥n.  Si en las versiones anteriores consideraba la comparaci√≥n como 2 operaciones elementales (primero restamos y luego tomamos una decisi√≥n), entonces en este caso el resultado de la operaci√≥n anterior se usa para tomar una decisi√≥n directamente y la comparaci√≥n toma una operaci√≥n elemental, lo que lleva a dos operaciones siempre y una asignaci√≥n (raramente) y guardamos una operaci√≥n (sin perder nada), como dice el refr√°n, "un poco, pero agradable".  ¬øEs la soluci√≥n resultante ideal? Desafortunadamente, no.  Es ligeramente inferior a la soluci√≥n con una m√°scara (que requiere exactamente 2 operaciones elementales) en t√©rminos de velocidad y este es quiz√°s su √∫nico inconveniente. <br><br>  Existe una soluci√≥n a√∫n m√°s r√°pida: simplemente aumente (disminuya) el valor del contador y no haga nada m√°s, pero solo es posible en el caso en que el valor m√°ximo coincida con el valor m√°s representativo en el tipo aceptado.  Para un contador de 8 bits (es decir, como uint8_t), ser√° 255, luego escribimos Counter = Counter + 1 y conf√≠o en que escribir Counter + = 1 o ++ Counter es completamente opcional, aunque muchos son y escribir√°n y tendr√°n toda la raz√≥n.  Si no consideramos seriamente la versi√≥n sobre la necesidad de guardar caracteres (ya que la primera opci√≥n es la m√°s larga), entonces esto no tiene sentido, al menos si estamos escribiendo un programa para arquitectura ARM o AVR (para otros que simplemente no verifiqu√©, sospecho que el resultado ser√° lo mismo) bajo el compilador GCC (el autor entiende que est√° escribiendo el programa en el editor del entorno de programaci√≥n integrado, esto es solo una revoluci√≥n del habla del pasado cuando las computadoras eran grandes y la memoria peque√±a), y con la optimizaci√≥n activada en cualquier nivel, porque  El c√≥digo dado ser√° absolutamente id√©ntico. <br><br>  Los compiladores modernos son muy, muy avanzados en t√©rminos de optimizaci√≥n y generan un c√≥digo realmente muy bueno, por supuesto, si ha habilitado el modo correspondiente.  Aunque estoy dispuesto a aceptar que tales construcciones de lenguaje no hacen da√±o y pueden ser √∫tiles bajo ciertas condiciones, lo √∫nico que noto es que las expresiones de Counter ++ (en este caso particular, por supuesto) deben evitarse sin ambig√ºedad, ya que est√° destinado a situaciones completamente diferentes y puede dar lugar a c√≥digo m√°s lento, aunque opcional. <br><br>  Otra pregunta es que un b√∫fer de 256 elementos no siempre es aceptable, pero si tiene suficiente memoria, ¬øpor qu√© no?  Con esta implementaci√≥n, si puede alinear el b√∫fer con el borde de la p√°gina, entonces el acceso a los elementos se puede hacer muy r√°pido al eliminar la operaci√≥n de cambiar de √≠ndice a √≠ndice (la palabra clave de uni√≥n le indicar√° la implementaci√≥n de dicha funci√≥n, no la traer√© para no aprender malo), pero esta es una decisi√≥n muy, muy espec√≠fica con un fuerte apego a la arquitectura, que est√° peligrosamente cerca de trucos en el peor sentido de la palabra, y este no es nuestro estilo. <br><br>  Por supuesto, nadie nos proh√≠be escribir un contenedor que llame a este o aquel m√©todo dependiendo del valor de los valores de contador m√°ximos (y m√≠nimos, ya que muchos m√©todos simplemente no funcionan con un m√≠nimo distinto de cero), ya he propuesto los principios b√°sicos de tal soluci√≥n, por lo que Vamos a ofrecer esto como un ejercicio. <br><br>  En resumen, para resumir, reuniremos diferentes implementaciones de trabajo con un √≠ndice de anillo y evaluaremos sus propiedades. <br><div class="scrollable-table"><table><tbody><tr><th>  M√©todo </th><th>  Versatilidad </th><th>  Plazo de entrega </th></tr><tr><td>  ¬± </td><td>  0 (1) </td><td>  1 </td></tr><tr><td>  ¬±% </td><td>  1 (7) </td><td>  2 </td></tr><tr><td>  + si </td><td>  3 (cualquiera) </td><td>  3.x </td></tr><tr><td>  - si </td><td>  3 (cualquiera) </td><td>  2.x </td></tr></tbody></table></div><br>  La segunda l√≠nea entre par√©ntesis muestra el n√∫mero de valores de tama√±o del b√∫fer (no superior a 256) para los que esta implementaci√≥n est√° disponible, pero queremos decir que un b√∫fer de tama√±o 0 no nos interesa. <br><br>  Como puede ver en esta tabla, DarZaNeBy (mi expresi√≥n favorita, como puede haber notado), y las ventajas se compran a costa de desventajas, lo √∫nico que se puede afirmar inequ√≠vocamente es que el incremento con la verificaci√≥n tiene un competidor m√°s exitoso en forma de disminuci√≥n con verificaci√≥n y no pasa a la siguiente ronda bajo ninguna circunstancia <br><br>  Una nota necesaria: hay lenguajes de programaci√≥n en los que no tendr√≠amos que pensar en la implementaci√≥n del √≠ndice, sino que simplemente podr√≠amos usar el tipo de intervalo.  Desafortunadamente, no puedo considerar √≥ptima la implementaci√≥n de estas construcciones en el c√≥digo, ya que estas construcciones (y estos lenguajes) no est√°n destinados a la optimizaci√≥n en tiempo de ejecuci√≥n, pero es una pena. <br><br>  Entonces, hicimos el m√≥dulo correcto (qu√© nombre tan fuerte para la funci√≥n en l√≠nea) para trabajar con el √≠ndice, y ahora estamos listos para comenzar a implementar el b√∫fer en anillo. <br><br>  Y para empezar, debemos decidir qu√© queremos exactamente de este objeto de programa.  Es absolutamente necesario poder colocar un elemento de datos en un b√∫fer y extraerlo: dos m√©todos principales, una especie de captador y definidor.  Es te√≥ricamente posible imaginar un b√∫fer sin uno de estos m√©todos, o incluso sin ambos (se puede imaginar poco te√≥ricamente), pero el valor pr√°ctico de tal implementaci√≥n es una gran pregunta.  La siguiente funcionalidad necesaria, verificar la informaci√≥n, se puede implementar como un m√©todo separado o como un valor especial (o atributo) devuelto por la lectura.  Por lo general, prefieren el primer m√©todo, ya que resulta m√°s comprensible y no demasiado caro. <br>  Pero verificar que el b√∫fer est√© completo ya es una gran pregunta: esta operaci√≥n requerir√° tiempo adicional, que siempre se dedicar√° a la grabaci√≥n, aunque nadie nos obliga a usarlo, as√≠ que d√©jelo.  No necesitamos nada m√°s del b√∫fer, recordemos esta frase para el futuro. <br><br>  Volver a la implementaci√≥n.  Necesitamos un lugar para almacenar los elementos de la cola y dos √≠ndices: uno para escribir en el b√∫fer y otro para leerlo.  C√≥mo exactamente obtendremos este lugar (y estos indicadores) es un tema para una discusi√≥n por separado, por ahora dejamos este momento fuera de par√©ntesis y creemos que simplemente los tenemos.  Algunos (incluidos los autores del libro "Programaci√≥n para matem√°ticos", que respeto, recomiendo leerlo) tambi√©n usan el contador de lugares rellenos, pero no haremos esto e intentar√© mostrar por qu√© esto es malo. <br><br>  Primero, sobre los √≠ndices: notamos de inmediato que estos son √≠ndices, no indicadores, aunque a veces me permit√≠ llamarme as√≠.    (     ),    (       )-   ,  ,   ,      .       (  256    ),     ,       ,       (         ,     8     , ,     4-  ),  ,       ,     ( ,      ). <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"> ,       51 (   )    2 (    )   3  ( ),   ,             ,      . ,   ,  GCC     x51,       AVR  . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, muchos trucos que aumentan la velocidad para obtener el siguiente valor no estar√°n disponibles al usar el puntero. Y si tambi√©n tiene en cuenta la opini√≥n de que los punteros son m√°s dif√≠ciles de entender (no es que esta opini√≥n me pareciera correcta, pero existe), entonces la elecci√≥n es clara: √≠ndices.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, ¬øqu√© deben mostrar exactamente los √≠ndices? Aqu√≠, el alcance de la imaginaci√≥n es ilimitado dentro del tama√±o del b√∫fer Max (e incluso m√°s que eso), pero un conjunto muy peque√±o de opciones tiene un significado pr√°ctico. Para el √≠ndice de grabaci√≥n, hay dos posibilidades: 1) indicar el lugar donde se grab√≥ el √∫ltimo elemento y 2) indicar el lugar donde se grabar√° el siguiente elemento. Dado que inmediatamente despu√©s de crear la cola, la primera opci√≥n parece un poco extra√±a, luego elegimos la segunda, especialmente porque esto nos promete una ganancia tangible en el futuro. Para el √≠ndice de lectura, asumimos de inmediato que apunta al elemento que se leer√° la pr√≥xima vez que se lea. Inmediatamente hay un criterio simple (en el sentido de verificaci√≥n) de que la cola no est√° vac√≠a: los √≠ndices no son iguales. Pero surge el segundo problema: si ponemos en cola exactamente los elementos de Mach,entonces los √≠ndices coincidir√°n y no podremos distinguir esta situaci√≥n de una cola vac√≠a.</font></font><br><br>     (¬´,      ¬ª)             ,      .       ‚Äî  1)    , 2)       ( ,  ) 3)        ,     , 4)       256            , 5)     ( ),    .    ,     ,   ,   ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo necesitamos evitar una situaci√≥n en la que los √≠ndices puedan coincidir despu√©s del pr√≥ximo registro (el hecho de que puedan coincidir despu√©s de la lectura es obvio), y para esto necesitamos limitar el n√∫mero posible de elementos en el b√∫fer a 1 menos de lo posible. </font><font style="vertical-align: inherit;">Aqu√≠ est√° su implementaci√≥n:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NeedOverflowControl YES typedef uint8_t Data_t; static Data_t BufferData[Max]; static Counter_t BufferWriteCounter=0, BufferReadCounter=BufferWriteCounter; void BufferWrite(const data_t Data) { BufferData[BuffWriteCounter] = Data; register counter_t Tmp = NextCount(BufferWriteCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (NeedOverflowControl == YES) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Tmp == BufferReadCounter) {BufferOverflow();} </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> { BufferWriteCounter = Tmp; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hay una ligera incorrecci√≥n en la funci√≥n anterior, propongo encontrarla y arreglarla por mi cuenta, aunque ... todav√≠a la hay, pero continuaremos: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == BufferWriteCounter ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsFull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == NextCounter(BufferWriteCounter) ); }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DataSizeIsSmaller (sizeof(data_t) &lt; sizeof(counter_t)) data_t BufferRead(void) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller register data_t Tmp = BufferData[BufferReadCounter]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> register counter_t Tmp = BufferReadCounter; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> BufferReadCounter = NextCount(BufferReadCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller return Tmp; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return BufferData[Tmp]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>    ,        (     ) ‚Äî        ,        , ,      ‚Äî    ,         .  ,        ,        ,         . <br><br> ,     ,     ‚Äî  ,         ,         ,       . <br><br>  , (  )   <br><br> 1)            (    ‚Äî     ,        ,      ‚Äî      ,  ,        ). <br>   (,  ,    )  <br><br> 2)            ‚Äî    ,     . <br><br>         : <br><br> 3)  4)      ,    (¬´  ¬ª).    ‚Äî      ,   ,      (  N   N+1 )       ,    ?    <br><br> 3)     ,   <br><br> 4)       . <br><br>      ‚Äî ¬´ ¬ª,     -      ,     ‚Äî    .      3,     (      ),       ,    . <br><br>      ‚Äî    , (      ,      ),    <br><br> 5)      ‚Äî       ,    ,       ,      ,       ‚Äî   ,     . <br><br>   ‚Äî             ,      ,     . <br><br>    ,  ,     ,    , ,   , ,    , ,   ,      ,     .        ,      4       ,    ,  .        MRSW (Multi-Reader Single-Writer)   ¬´The Art of Mulpiprocessor Programming¬ª (   ,   )        (  )      .      ‚Äî           ,               ,   . <br><br>       MRMW        ,   ¬´¬ª (, ,      ¬´ ¬ª ).     ,         , ,       ,      .  , ,     ,           (,   ,      ‚Äî    ,     ,   ,  ),     . <br><br>  ,    (   )      ,       .     ,     ,         ,     ,  ,         ,      ,        . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferData[Max]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> BufferWriteCounter=<span class="hljs-number"><span class="hljs-number">0</span></span>, BufferReadCounter=WriteCounter; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> BufferHaveData = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((BufferWriteCounter == BufferReadCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">1</span></span>)) {BufferOverflow();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { BufferData[BufferWriteCounter] = Data; BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; BufferWriteCounter = NextCounter(BufferWriteCounter); }; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((BufferReadCounter==BufferWriteCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">0</span></span>));}; <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferRead(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> Tmp; Tmp = BufferReadCounter; BufferReadCounter = NextCount(BufferReadCounter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BufferReadCount == BufferWriteCounter) { BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BufferData[Tmp]; };</code> </pre> <br>   ,        ,    ,       ,    ,                   . <br><br>  ,         (    0  1,   ,     ,   ),      ,    ,      ,  ,  ,         (  ),  ,      , <br><br><div class="spoiler"> <b class="spoiler_title"> - </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> (NoBufferHaveData= <span class="hljs-number"><span class="hljs-number">0</span></span>, BufferHaveData =<span class="hljs-number"><span class="hljs-number">1</span></span>) BufferHave DataFlag_t; BufferHaveData_t BufferYaveDataFlag; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = NoBufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagClr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = BufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagIsSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(BufferHaveDataFlag == BufferHaveData);};</code> </pre> <br></div></div><br>  ,        ,      0  1,             . ,     ,        ,        0  1.   , ,    ,      ,    BufferFullFlag      ,          BufferIsNotEmptyFlag         .   ,  KISS      ,   ,   ,        ,    , ¬´   ¬ª. <br><br>   ,       ,                    . <br><br>          ,         ,      . <br><br> PS    ,        ,                 : <br><br><ol><li>     ‚Äî      (,  ,     ),  ‚Äî   ,     , ,   ,  . </li><li>               . </li><li>      . </li><li>    2    . </li><li>       </li><li>     ,     (  )   ,       ,       . </li><li>    ,   <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_writeCount - Atomic::Fetch(&amp;_readCount)) &amp; (size_type)~(_mask)) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>     ‚Äî    ,    ,     ,         <br><br><pre> <code class="cpp hljs">size_type(~(_mask))</code> </pre> <br>     . </li></ol><br> PPS ,           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438476/">https://habr.com/ru/post/438476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438466/index.html">Muleta para un l√°ser chino</a></li>
<li><a href="../438468/index.html">Colonia Cap√≠tulo 23: Prueba de manejo</a></li>
<li><a href="../438470/index.html">Ventas mundiales en diciembre y 2018: 2 millones de veh√≠culos el√©ctricos enchufables vendidos</a></li>
<li><a href="../438472/index.html">Sofisticado entorno arquitect√≥nico modular en UE4</a></li>
<li><a href="../438474/index.html">Courier: migraci√≥n de Dropbox a gRPC</a></li>
<li><a href="../438478/index.html">GitLab 11.7 lanzado con versiones, √©picas anidadas de varios niveles y el registro de paquetes NPM</a></li>
<li><a href="../438480/index.html">Col√≥quelo bien: 7 lugares ideales para colocar contenido de video</a></li>
<li><a href="../438482/index.html">Reputaci√≥n, trabajo y emigraci√≥n: c√≥mo utilizar las herramientas de promoci√≥n de la empresa para resolver problemas personales.</a></li>
<li><a href="../438486/index.html">Tarjeta de memoria impenetrable: ahogar, congelar y prender fuego a Kingston microSD High Endurance</a></li>
<li><a href="../438490/index.html">Lanzamiento beta de Unity 2019.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>