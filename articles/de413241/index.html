<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôåÔ∏è üé∑ üåû Abfangen von Funktionen im Linux-Kernel mit ftrace üé¨ ü•Ä üë®‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem Projekt zur Sicherheit von Linux-Systemen mussten Aufrufe wichtiger Funktionen im Kernel abgefangen werden (z. B. √ñffnen von Dateien und Ausf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abfangen von Funktionen im Linux-Kernel mit ftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413241/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/xy/k-/zy/xyk-zye1hkr1vaw41hvsxup3brc.png" alt="Ninja Pinguin, En3l" align="right" width="40%"></a>  In einem Projekt zur Sicherheit von Linux-Systemen mussten Aufrufe wichtiger Funktionen im Kernel abgefangen werden (z. B. √ñffnen von Dateien und Ausf√ºhren von Prozessen), um die Aktivit√§t im System √ºberwachen und die Aktivit√§t verd√§chtiger Prozesse vorbeugend blockieren zu k√∂nnen. <br><br>  W√§hrend des Entwicklungsprozesses ist es uns gelungen, einen ziemlich guten Ansatz zu erfinden, mit dem wir jede Funktion im Kernel bequem nach Namen abfangen und unseren Code um seine Aufrufe herum ausf√ºhren k√∂nnen.  Der Interceptor kann von einem ladbaren GPL-Modul installiert werden, ohne den Kernel neu zu erstellen.  Der Ansatz unterst√ºtzt Kernel Version 3.19+ f√ºr die x86_64-Architektur. <br><a name="habracut"></a><br>  <font color="gray">( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pinguinbild</a> oben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬© En3l with DeviantArt</a> .)</font> <br><br><h2>  Bekannte Ans√§tze </h2><br><h3>  Linux-Sicherheits-API </h3><br>  Am richtigsten w√§re es, die <em>Linux-Sicherheits-API zu verwenden</em> - eine spezielle Schnittstelle, die speziell f√ºr diese Zwecke erstellt wurde.  An kritischen Stellen des Kernel-Codes befinden sich Aufrufe von Sicherheitsfunktionen, die wiederum die vom Sicherheitsmodul festgelegten R√ºckrufe aufrufen.  Das Sicherheitsmodul kann den Kontext einer Operation untersuchen und entscheiden, ob sie zul√§ssig oder abgelehnt ist. <br><br>  Leider weist die Linux-Sicherheits-API einige wichtige Einschr√§nkungen auf: <br><br><ul><li>  Sicherheitsmodule k√∂nnen nicht dynamisch geladen werden, sind Teil des Kernels und m√ºssen neu erstellt werden </li><li>  Es kann nur ein Sicherheitsmodul im System geben (mit wenigen Ausnahmen). </li></ul><br>  Wenn die Position der Kernelentwickler in Bezug auf die Vielzahl der Module nicht eindeutig ist, ist das Verbot des dynamischen Ladens von grundlegender Bedeutung: Das Sicherheitsmodul muss Teil des Kernels sein, um die Sicherheit ab dem Zeitpunkt des Ladens konstant zu gew√§hrleisten. <br><br>  Um die Sicherheits-API verwenden zu k√∂nnen, m√ºssen Sie daher Ihre eigene Kernel-Assembly bereitstellen und das Add-On-Modul in SELinux oder AppArmor integrieren, die von g√§ngigen Distributionen verwendet werden.  Der Kunde wollte solche Verpflichtungen nicht abonnieren, daher wurde diese Route gesperrt. <br><br>  Aus diesen Gr√ºnden passte die Sicherheits-API nicht zu uns, da sie sonst eine ideale Option w√§re. <br><br><h3>  √Ñnderung der Systemaufruftabelle </h3><br>  Die √úberwachung war haupts√§chlich f√ºr Aktionen erforderlich, die von Benutzeranwendungen ausgef√ºhrt wurden, damit sie im Prinzip auf der Ebene von Systemaufrufen implementiert werden konnte.  Wie Sie wissen, speichert Linux alle Systemaufruf-Handler in der Tabelle <code>sys_call_table</code> .  Das Ersetzen von Werten in dieser Tabelle f√ºhrt zu einer √Ñnderung des Verhaltens des gesamten Systems.  Wenn wir also die alten Werte des Handlers beibehalten und unseren eigenen Handler in der Tabelle ersetzen, k√∂nnen wir jeden Systemaufruf abfangen. <br><br>  Dieser Ansatz hat bestimmte Vorteile: <br><br><ul><li>  <strong>Volle Kontrolle √ºber alle Systemaufrufe</strong> - die einzige Schnittstelle zum Kernel f√ºr Benutzeranwendungen.  Mit dieser Funktion k√∂nnen wir sicher sein, dass wir keine wichtigen Aktionen des Benutzerprozesses verpassen. <br></li><li>  <strong>Minimaler Overhead.</strong>  Bei der Aktualisierung der Systemaufruftabelle ist eine einmalige Kapitalinvestition erforderlich.  Neben der unvermeidlichen √úberwachungsnutzlast ist der einzige Aufwand ein zus√§tzlicher Funktionsaufruf (zum Aufrufen des urspr√ºnglichen Systemaufruf-Handlers). <br></li><li>  <strong>Mindestanforderungen an den Kernel.</strong>  Falls gew√ºnscht, erfordert dieser Ansatz keine zus√§tzlichen Konfigurationsoptionen im Kernel, sodass theoretisch ein m√∂glichst breites Systemspektrum unterst√ºtzt wird. <br></li></ul><br>  Er leidet jedoch auch an einigen M√§ngeln: <br><br><ul><li>  <strong>Die technische Komplexit√§t der Implementierung.</strong>  Das Ersetzen von Zeigern in einer Tabelle ist an sich nicht schwierig.  Verwandte Aufgaben erfordern jedoch nicht offensichtliche L√∂sungen und eine bestimmte Qualifikation: <br><ul><li>  Aufruftabelle des Suchsystems </li><li>  Bypass zum Schutz vor Tabellen√§nderungen </li><li>  atomarer und sicherer Ersatz </li></ul><br>  Dies sind alles interessante Dinge, aber sie erfordern wertvolle Entwicklungszeit, zuerst f√ºr die Implementierung und dann f√ºr die Unterst√ºtzung und das Verst√§ndnis. <br></li><li>  <strong>Unf√§higkeit, einige Handler abzufangen.</strong>  In Kerneln vor Version 4.16 enthielt die Systemaufrufbehandlung f√ºr die x86_64-Architektur eine Reihe von Optimierungen.  Einige von ihnen forderten, dass der Systemaufruf-Handler ein spezieller Adapter ist, der in Assembler implementiert ist.  Dementsprechend sind solche Handler manchmal schwierig und manchmal sogar unm√∂glich durch Ihre eigenen zu ersetzen, geschrieben in C.  Dar√ºber hinaus werden in verschiedenen Versionen des Kernels unterschiedliche Optimierungen verwendet, was die technischen Schwierigkeiten des Sparschweins erh√∂ht. <br></li><li>  <strong>Es werden nur Systemaufrufe abgefangen.</strong>  Mit diesem Ansatz k√∂nnen Sie Systemaufruf-Handler ersetzen, wodurch die Einstiegspunkte auf nur diese beschr√§nkt werden.  Alle zus√§tzlichen √úberpr√ºfungen werden entweder am Anfang oder am Ende durchgef√ºhrt, und wir haben nur die Argumente des Systemaufrufs und seinen R√ºckgabewert.  Manchmal f√ºhrt dies dazu, dass doppelte √úberpr√ºfungen der Angemessenheit von Argumenten und Zugriffspr√ºfungen erforderlich sind.  Manchmal verursacht es unn√∂tigen Overhead, wenn Sie den Speicher des Benutzerprozesses zweimal kopieren m√ºssen: Wenn das Argument √ºber einen Zeiger √ºbergeben wird, m√ºssen wir es zuerst selbst kopieren, dann kopiert der urspr√ºngliche Handler das Argument erneut f√ºr sich.  Dar√ºber hinaus bieten Systemaufrufe in einigen F√§llen eine zu geringe Granularit√§t von Ereignissen, die zus√§tzlich nach Rauschen gefiltert werden m√ºssen. <br></li></ul><br>  Zun√§chst haben wir diesen Ansatz gew√§hlt und erfolgreich umgesetzt, um die Vorteile der Unterst√ºtzung der meisten Systeme zu nutzen.  Zu diesem Zeitpunkt wussten wir jedoch noch nichts √ºber die Funktionen von x86_64 und die Einschr√§nkungen f√ºr abgefangene Anrufe.  Sp√§ter stellte sich heraus, dass es f√ºr uns von entscheidender Bedeutung ist, Systemaufrufe im Zusammenhang mit dem Starten neuer Prozesse - clone () und execve () - zu unterst√ºtzen, die nur etwas Besonderes sind.  Dies f√ºhrte uns zur Suche nach neuen Optionen. <br><br><h3>  Verwenden von kprobes </h3><br>  Eine der in Betracht <em>gezogenen</em> Optionen war die Verwendung von <em>kprobes</em> : eine spezialisierte API, die haupts√§chlich zum Debuggen und Verfolgen des Kernels entwickelt wurde.  √úber diese Schnittstelle k√∂nnen Sie Vor- und Nachhandler f√ºr <em>alle Anweisungen</em> im Kernel sowie Handler f√ºr die Eingabe und R√ºckgabe einer Funktion festlegen.  Handler erhalten Zugriff auf Register und k√∂nnen diese √§ndern.  Auf diese Weise k√∂nnten wir sowohl die √úberwachung als auch die F√§higkeit erhalten, den weiteren Arbeitsablauf zu beeinflussen. <br><br>  Vorteile der Verwendung von kprobes zum Abfangen: <br><br><ul><li>  <strong>Reife API.</strong>  Kprobes existieren und verbessern sich seit jeher (2002).  Sie haben eine gut dokumentierte Oberfl√§che, die meisten Fallstricke wurden bereits gefunden, ihre Arbeit wurde so weit wie m√∂glich optimiert und so weiter.  Im Allgemeinen ein ganzer Berg von Vorteilen gegen√ºber experimentellen selbstgebauten Fahrr√§dern. <br></li><li>  <strong>Abfangen eines beliebigen Ortes im Kern.</strong>  Kprobes werden mithilfe von Haltepunkten (int3-Anweisungen) implementiert, die in den ausf√ºhrbaren Code des Kernels eingebettet sind.  Auf diese Weise k√∂nnen Sie kprobes buchst√§blich √ºberall in jeder Funktion installieren, sofern bekannt.  In √§hnlicher Weise werden kretprobes durch Spoofing der R√ºcksprungadresse auf dem Stapel implementiert und erm√∂glichen es Ihnen, die R√ºckgabe von jeder Funktion abzufangen (mit Ausnahme derjenigen, die im Prinzip keine Kontrolle zur√ºckgeben). <br></li></ul><br>  Nachteile von kprobes: <br><br><ul><li>  <strong>Technische Schwierigkeit.</strong>  Kprobes ist nur eine M√∂glichkeit, einen Haltepunkt irgendwo im Kernel festzulegen.  Um die Argumente einer Funktion oder die Werte lokaler Variablen zu erhalten, m√ºssen Sie wissen, in welchen Registern oder wo auf dem Stapel sie sich befinden, und sie unabh√§ngig voneinander von dort extrahieren.  Um einen Funktionsaufruf zu blockieren, m√ºssen Sie den Status des Prozesses manuell √§ndern, sodass der Prozessor denkt, dass er bereits die Kontrolle √ºber die Funktion zur√ºckgegeben hat. <br></li><li>  <strong>Jprobes sind veraltet.</strong>  Jprobes ist ein Add-On f√ºr kprobes, mit dem Sie Funktionsaufrufe bequem abfangen k√∂nnen.  Es extrahiert unabh√§ngig die Argumente der Funktion aus den Registern oder dem Stapel und ruft Ihren Handler auf, der dieselbe Signatur wie die Hook-Funktion haben sollte.  Der Haken ist, dass J-Sonden veraltet sind und aus modernen Kerneln herausgeschnitten werden. <br></li><li>  <strong>Nicht trivialer Overhead.</strong>  Haltepunkte sind teuer, aber einmalig.  Haltepunkte wirken sich nicht auf andere Funktionen aus, ihre Verarbeitung ist jedoch relativ teuer.  Gl√ºcklicherweise ist f√ºr die x86_64-Architektur eine Sprungoptimierung implementiert, die die Kosten f√ºr kprobes erheblich senkt, aber immer noch mehr bleibt als beispielsweise beim √Ñndern der Systemaufruftabelle. <br></li><li>  <strong>Einschr√§nkungen von Kretsonden.</strong>  Kretprobes werden implementiert, indem die R√ºcksprungadresse auf dem Stapel gef√§lscht wird.  Dementsprechend m√ºssen sie die urspr√ºngliche Adresse irgendwo speichern, um nach der Verarbeitung von kretprobe dorthin zur√ºckzukehren.  Adressen werden in einem Puffer fester Gr√∂√üe gespeichert.  Im Falle eines √úberlaufs √ºberspringen kretprobes Operationen, wenn zu viele gleichzeitige Aufrufe der abgefangenen Funktion im System ausgef√ºhrt werden. <br></li><li>  <strong>Extrusion deaktiviert.</strong>  Da kprobes auf Interrupts basiert und Prozessorregister jongliert, werden zur Synchronisation alle Handler mit deaktivierter Vorbelegung ausgef√ºhrt.  Dies f√ºhrt zu gewissen Einschr√§nkungen f√ºr die Handler: Sie k√∂nnen nicht in ihnen warten - reservieren Sie viel Speicher, f√ºhren Sie E / A durch, schlafen Sie in Timern und Semaphoren und anderen bekannten Dingen. <br></li></ul><br>  Bei der Erforschung des Themas fielen unsere Augen auf das <strong>ftrace-</strong> Framework, das jprobes ersetzen kann.  Wie sich herausstellte, funktioniert es besser f√ºr unsere Anforderungen zum Abfangen von Funktionsaufrufen.  Wenn Sie jedoch bestimmte Anweisungen innerhalb von Funktionen verfolgen m√ºssen, sollten kprobes nicht rabattiert werden. <br><br><h3>  Splei√üen </h3><br>  Der Vollst√§ndigkeit halber lohnt es sich auch, die klassische Methode zum Abfangen von Funktionen zu beschreiben, bei der die Anweisungen zu Beginn der Funktion durch einen bedingungslosen √úbergang ersetzt werden, der zu unserem Handler f√ºhrt.  Die urspr√ºnglichen Anweisungen werden an einen anderen Ort √ºbertragen und ausgef√ºhrt, bevor zur abgefangenen Funktion zur√ºckgekehrt wird.  Mit Hilfe von zwei √úberg√§ngen binden wir unseren zus√§tzlichen Code in die Funktion ein ( <em>splei√üen ihn ein)</em> , daher wird dieser Ansatz als <em>Splei√üen bezeichnet</em> . <br><br>  So wird die Sprungoptimierung f√ºr kprobes implementiert.  Mit dem Splei√üen k√∂nnen Sie die gleichen Ergebnisse erzielen, jedoch ohne zus√§tzliche Kosten f√ºr k-Sonden und mit vollst√§ndiger Kontrolle √ºber die Situation. <br><br>  Die Vorteile des Splei√üens liegen auf der Hand: <br><br><ul><li>  <strong>Mindestanforderungen an den Kernel.</strong>  Das Splei√üen erfordert keine speziellen Optionen im Kernel und funktioniert zu Beginn einer Funktion.  Sie m√ºssen nur ihre Adresse kennen. <br></li><li>  <strong>Minimaler Overhead.</strong>  Zwei bedingungslose √úberg√§nge - das sind alle Aktionen, die der abgefangene Code ausf√ºhren muss, um die Kontrolle an den Handler zu √ºbertragen und umgekehrt.  Solche √úberg√§nge werden vom Prozessor perfekt vorhergesagt und sind sehr billig. <br></li></ul><br>  Der Hauptnachteil dieses Ansatzes tr√ºbt jedoch das Bild ernsthaft: <br><br><ul><li>  <strong>Technische Schwierigkeit.</strong>  Sie dreht sich um.  Sie k√∂nnen den Maschinencode nicht einfach √ºbernehmen und neu schreiben.  Hier ist eine kurze und unvollst√§ndige Liste der zu l√∂senden Aufgaben: <br><ul><li>  Synchronisation der Installation und Entfernung des Abfangens (was ist, wenn die Funktion direkt beim Ersetzen ihrer Anweisungen aufgerufen wird?) </li><li>  Bypass des Schutzes bei √Ñnderung von Speicherbereichen mit einem Code </li><li>  Ung√ºltigmachung des CPU-Cache nach Ersetzen der Anweisungen </li><li>  Zerlegen austauschbarer Anweisungen, um sie vollst√§ndig zu kopieren </li><li>  √úberpr√ºfen Sie, ob im ersetzten Teil keine √úberg√§nge vorhanden sind </li><li>  √úberpr√ºfen Sie, ob das ersetzte Teil an einen anderen Ort gebracht werden kann </li></ul><br>  Ja, Sie k√∂nnen kprobes ausspionieren und das intranukle√§re Livepatch-Framework verwenden, aber die endg√ºltige L√∂sung ist immer noch recht kompliziert.  Es ist be√§ngstigend, sich vorzustellen, wie viele Schlafprobleme in jeder neuen Implementierung auftreten werden. <br></li></ul><br>  Wenn Sie diesen D√§mon aufrufen k√∂nnen, der nur den Eingeweihten untergeordnet ist und bereit ist, ihn in Ihrem Code zu ertragen, ist das Splei√üen im Allgemeinen ein vollst√§ndig funktionierender Ansatz zum Abfangen von Funktionsaufrufen.  Ich hatte eine negative Einstellung zum Schreiben von Fahrr√§dern, daher blieb diese Option ein Backup f√ºr uns, falls es bei vorgefertigten L√∂sungen √ºberhaupt keine Fortschritte geben sollte. <br><br><h2>  Neuer Ansatz mit ftrace </h2><br>  <strong>Ftrace</strong> ist ein Kernel-Tracing-Framework auf Funktionsebene.  Es wurde seit 2008 entwickelt und verf√ºgt √ºber eine fantastische Oberfl√§che f√ºr Benutzerprogramme.  Mit Ftrace k√∂nnen Sie die H√§ufigkeit und Dauer von Funktionsaufrufen verfolgen, Anrufdiagramme anzeigen, interessierende Funktionen nach Vorlage filtern usw.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aus</a> √ºber ftrace-Funktionen lesen und dann den Links und der offiziellen Dokumentation folgen. <br><br>  Es implementiert ftrace basierend auf den Compiler-Schl√ºsseln <code>-pg</code> und <code>-mfentry</code> , die den Aufruf der speziellen Trace-Funktion mcount () oder __fentry __ () am Anfang jeder Funktion einf√ºgen.  In Benutzerprogrammen wird diese Compilerfunktion normalerweise von Profilern verwendet, um Aufrufe aller Funktionen zu verfolgen.  Der Kernel verwendet diese Funktionen, um das ftrace-Framework zu implementieren. <br><br>  Das Aufrufen von ftrace von <em>jeder</em> Funktion ist nat√ºrlich nicht billig, daher ist eine Optimierung f√ºr g√§ngige Architekturen verf√ºgbar: <em>dynamisches ftrace</em> .  Das Fazit ist, dass der Kernel den Speicherort aller Aufrufe von mcount () oder __fentry __ () kennt und in den fr√ºhen Phasen des Ladens den Maschinencode durch <strong>nop ersetzt</strong> - eine spezielle Anweisung, die nichts bewirkt.  Wenn die Ablaufverfolgung in den erforderlichen Funktionen enthalten ist, werden ftrace-Aufrufe wieder hinzugef√ºgt.  Wenn also ftrace nicht verwendet wird, ist seine Auswirkung auf das System minimal. <br><br><h3>  Beschreibung der ben√∂tigten Funktionen </h3><br>  Jede abgefangene Funktion kann durch die folgende Struktur beschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * struct ftrace_hook -    * * @name:    * * @function:  -,     *   * * @original:   ,     *  ,    * * @address:   ,    * * @ops:   ftrace,  , *      */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *function; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *original; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  Der Benutzer muss nur die ersten drei Felder ausf√ºllen: Name, Funktion, Original.  Die verbleibenden Felder werden als Implementierungsdetail betrachtet.  Die Beschreibung aller abgefangenen Funktionen kann in einem Array gesammelt werden, und Makros k√∂nnen verwendet werden, um die Kompaktheit des Codes zu erh√∂hen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOOK(_name, _function, _original) \ { \ .name = (_name), \ .function = (_function), \ .original = (_original), \ } static struct ftrace_hook hooked_functions[] = { HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_clone"</span></span></span><span class="hljs-meta">, fh_sys_clone, &amp;real_sys_clone), HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_execve"</span></span></span><span class="hljs-meta">, fh_sys_execve, &amp;real_sys_execve), };</span></span></code> </pre><br>  Wrapper √ºber abgefangene Funktionen sind wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *        execve(). *     .      *  :       , *    ABI (  "asmlinkage"). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">long</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*real_sys_execve)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *      .   ‚Äî  *   .      *  .      ,  *    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Wie Sie sehen k√∂nnen, abgefangene Funktionen mit einem Minimum an zus√§tzlichem Code.  Das einzige, was besondere Aufmerksamkeit erfordert, sind die Funktionssignaturen.  Sie m√ºssen eins zu eins passen.  Ohne dies werden die Argumente nat√ºrlich falsch weitergegeben und alles wird bergab gehen.  Um Systemaufrufe abzufangen, ist dies weniger wichtig, da ihre Handler sehr stabil sind und aus Effizienzgr√ºnden Argumente in derselben Reihenfolge annehmen, in der das System selbst aufruft.  Wenn Sie jedoch andere Funktionen abfangen m√∂chten, sollten Sie ber√ºcksichtigen, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Kernel keine stabilen Schnittstellen vorhanden sind</a> . <br><br><h3>  Ftrace-Initialisierung </h3><br>  Zuerst m√ºssen wir die Adresse der Funktion finden und speichern, die wir abfangen werden.  Mit Ftrace k√∂nnen Sie Funktionen nach Namen verfolgen, aber wir m√ºssen noch die Adresse der urspr√ºnglichen Funktion kennen, um sie aufrufen zu k√∂nnen. <br><br>  Sie k√∂nnen die Adresse mit <em>kallsyms abrufen</em> - einer Liste aller Zeichen im Kernel.  Diese Liste enth√§lt <em>alle</em> Zeichen, die nicht nur f√ºr Module exportiert wurden.  Das Abrufen der Adresse der Hook-Funktion sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_hook_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ hook-&gt;address = kallsyms_lookup_name(hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hook-&gt;address) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unresolved symbol: %s\n"</span></span>, hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOENT; } *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) hook-&gt;original) = hook-&gt;address; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Als n√§chstes m√ºssen Sie die Struktur <code>ftrace_ops</code> initialisieren.  Es ist verbindlich <br>  Das Feld ist nur <em>func</em> und zeigt einen R√ºckruf an, aber wir brauchen es auch <br>  Setzen Sie einige wichtige Flags: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = resolve_hook_address(hook); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; hook-&gt;ops.func = fh_ftrace_thunk; hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_IPMODIFY; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  <em>fh_ftrace_thunk</em> () ist unser R√ºckruf, den ftrace beim Verfolgen einer Funktion aufruft.  √úber ihn sp√§ter.  Die von uns gesetzten Flags sind erforderlich, um das Abfangen abzuschlie√üen.  Sie weisen ftrace an, Prozessorregister zu speichern und wiederherzustellen, deren Inhalt wir im R√ºckruf √§ndern k√∂nnen. <br><br>  Jetzt sind wir bereit, das Abfangen zu erm√∂glichen.  Dazu m√ºssen Sie zuerst ftrace f√ºr die f√ºr uns interessante Funktion mit ftrace_set_filter_ip () aktivieren und dann ftrace erlauben, unseren R√ºckruf mit register_ftrace_function () aufzurufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } err = register_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"register_ftrace_function() failed: %d\n"</span></span>, err); <span class="hljs-comment"><span class="hljs-comment">/*    ftrace   . */</span></span> ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Das Abfangen wird auf √§hnliche Weise nur in umgekehrter Reihenfolge deaktiviert: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_remove_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = unregister_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unregister_ftrace_function() failed: %d\n"</span></span>, err); } err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); } }</code> </pre><br>  Nachdem der Aufruf von unregister_ftrace_function () abgeschlossen ist, ist das Fehlen von Aktivierungen des im System installierten R√ºckrufs (und damit unserer Wrapper) garantiert.  Daher k√∂nnen wir beispielsweise das Abfangmodul ruhig entladen, ohne bef√ºrchten zu m√ºssen, dass irgendwo im System unsere Funktionen noch ausgef√ºhrt werden (denn wenn sie verschwinden, wird der Prozessor gest√∂rt). <br><br><h3>  Funktionshaken ausf√ºhren </h3><br>  Wie wird das Abfangen tats√§chlich durchgef√ºhrt?  Sehr einfach.  Mit Ftrace k√∂nnen Sie den Status von Registern nach dem Beenden eines R√ºckrufs √§ndern.  Durch √Ñndern des% rip-Registers - eines Zeigers auf die n√§chste ausf√ºhrbare Anweisung - √§ndern wir die Anweisungen, die der Prozessor ausf√ºhrt - das hei√üt, wir k√∂nnen ihn zwingen, einen bedingungslosen √úbergang von der aktuellen Funktion zu unserer auszuf√ºhren.  So √ºbernehmen wir die Kontrolle. <br><br>  Der R√ºckruf f√ºr ftrace lautet wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br>  Mit dem Makro container_of () erhalten wir die Adresse unserer <code>struct ftrace_hook</code> an die Adresse der <code>struct ftrace_hook</code> eingebetteten <code>struct ftrace_hook</code> und ersetzen dann den% rip-Registerwert in der <code>struct pt_regs</code> durch die Adresse unseres <code>struct pt_regs</code> .  Das ist alles.  F√ºr andere Architekturen als x86_64 kann dieses Register anders aufgerufen werden (wie IP oder PC), aber die Idee ist im Prinzip auf sie anwendbar. <br><br>  Beachten Sie das f√ºr den R√ºckruf hinzugef√ºgte <strong>Notrace-Qualifikationsmerkmal</strong> .  Sie k√∂nnen Features kennzeichnen, die mit ftrace nicht verfolgt werden d√ºrfen.  Auf diese Weise werden beispielsweise die Funktionen von ftrace selbst markiert, die am Traceprozess beteiligt sind.  Dies verhindert, dass das System in einer Endlosschleife einfriert, wenn alle Funktionen im Kernel verfolgt werden (ftrace kann dies tun). <br><br>  Der ftback-R√ºckruf ruft normalerweise mit deaktivierter Extrusion auf (wie kprobes).  Es kann Ausnahmen geben, aber Sie sollten sich nicht auf sie verlassen.  In unserem Fall ist diese Einschr√§nkung jedoch nicht wichtig, sodass wir nur acht Bytes in der Struktur ersetzen. <br><br>  Die Wrapper-Funktion, die sp√§ter aufgerufen wird, wird im selben Kontext wie die urspr√ºngliche Funktion ausgef√ºhrt.  Daher k√∂nnen Sie dort tun, was in der abgefangenen Funktion zul√§ssig ist.  Wenn Sie beispielsweise einen Interrupt-Handler abfangen, k√∂nnen Sie immer noch nicht in einem Wrapper schlafen. <br><br><h3>  Rekursiver Anrufschutz </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der obige Code enth√§lt einen Haken: Wenn unser Wrapper die urspr√ºngliche Funktion aufruft, f√§llt er erneut in ftrace, wodurch unser R√ºckruf erneut aufgerufen wird, wodurch die Kontrolle wieder auf den Wrapper √ºbertragen wird. Diese unendliche Rekursion muss irgendwie abgebrochen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der eleganteste Weg, der uns gekommen ist, ist die Verwendung </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eines der Argumente des ftrace-R√ºckrufs, der die R√ºcksprungadresse zu der Funktion enth√§lt, die die verfolgte Funktion aufgerufen hat. Normalerweise wird dieses Argument verwendet, um ein Diagramm von Funktionsaufrufen zu erstellen. Wir k√∂nnen es verwenden, um den ersten Aufruf der abgefangenen Funktion von dem wiederholten zu unterscheiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat, wenn Sie erneut anrufen</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte in unseren Wrapper zeigen, w√§hrend am ersten - irgendwo an einer anderen Stelle im Kernel. </font><font style="vertical-align: inherit;">Die Steuerung sollte nur beim ersten Aufruf der Funktion √ºbertragen werden, alle anderen sollten die urspr√ºngliche Funktion ausf√ºhren d√ºrfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingabepr√ºfung kann sehr effizient durchgef√ºhrt werden, indem die Adresse mit den R√§ndern des aktuellen Moduls (das alle unsere Funktionen enth√§lt) verglichen wird. </font><font style="vertical-align: inherit;">Dies funktioniert hervorragend, wenn im Modul nur der Wrapper die abgefangene Funktion aufruft. </font><font style="vertical-align: inherit;">Andernfalls m√ºssen Sie selektiver vorgehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insgesamt lautet der korrekte ftrace-R√ºckruf wie folgt:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!within_module(parent_ip, THIS_MODULE)) regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Besonderheiten / Vorteile dieses Ansatzes: </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geringer Overhead. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur ein paar Subtraktionen und Vergleiche. </font><font style="vertical-align: inherit;">Keine Spinlocks, Listenp√§sse und so weiter.</font></font><br></li><li> <strong>   .</strong>         .       ,         . <br></li><li> <strong>   .</strong>     <em>kretprobes</em>         ,     (      ).           ,       . <br></li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich ein Beispiel vor: Sie haben den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Befehl ls</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in das Terminal eingegeben </font><font style="vertical-align: inherit;">, um eine Liste der Dateien im aktuellen Verzeichnis anzuzeigen. Die Shell (z. B. Bash) verwendet ein traditionelles Paar von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fork</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () + </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">-Funktionen </font><font style="vertical-align: inherit;">aus der C-Standardbibliothek </font><font style="vertical-align: inherit;">, um einen neuen Prozess zu starten </font><font style="vertical-align: inherit;">. Intern werden diese Funktionen √ºber die Systemaufrufe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone ()</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bzw. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve ()</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert </font><font style="vertical-align: inherit;">. Angenommen, wir fangen den Systemaufruf execve () ab, um den Start neuer Prozesse zu steuern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In grafischer Form sieht das Abfangen der Handlerfunktion folgenderma√üen aus: </font></font><br><br><img alt="Abfangsequenzdiagramm" src="https://habrastorage.org/webt/ok/mm/4x/okmm4xnova8g2nfmx7y60oocuju.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sehen wir, wie der Benutzerprozess ( </font></font><font color="#66B2FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blau</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) einen Systemaufruf an den Kernel ausf√ºhrt ( </font></font><font color="#EA6B66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rot)</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), wobei das ftrace-Framework ( </font></font><font color="#A680B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lila</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Funktionen von unserem Modul ( </font></font><font color="#97D077"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gr√ºn</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">aufruft </font><font style="vertical-align: inherit;">.</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Benutzerprozess f√ºhrt SYSCALL aus. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser Anweisung wird der Kernelmodus √ºbertragen und die Steuerung an den Systemaufruf-Handler auf niedriger Ebene √ºbertragen - </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry_SYSCALL_64</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font><font style="vertical-align: inherit;">Er ist verantwortlich f√ºr alle Systemaufrufe von 64-Bit-Programmen auf 64-Bit-Kerneln.</font></font><br></li><li> <strong>    .</strong>     , <a href="">  </a> ,      <em>do_syscall_64</em> (), <a href="">  </a> .            <code>sys_call_table</code>          ‚Äî       <em>sys_execve</em> (). <br></li><li> <strong> ftrace.</strong>         <em>__fentry__</em> (),    ftrace.  ,    ,       <em>nop</em> ,      sys_execve()   . <br></li><li> <strong>Ftrace   .</strong>    ftrace     ,   .         ,    %rip,       . <br></li><li> <strong>  .</strong>     <code>parent_ip</code> ,   do_syscall_64() ‚Äî        sys_execve() ‚Äî     ,   <em> %rip</em>   <code>pt_regs</code> . <br></li><li> <strong>Ftrace  .</strong>   FTRACE_SAVE_REGS, ftrace      <code>pt_regs</code>   .    ftrace     .     %rip ‚Äî      ‚Äî          . <br></li><li> <strong>  -.</strong> -     sys_execve()   .       <em>fh_sys_execve</em> ().           ,                do_syscall_64(). <br></li><li> <strong>   .</strong>          .  fh_sys_execve()        (  )       .        .        ‚Äî sys_execve()  ,   <em>real_sys_execve</em> ,      . <br></li><li> <strong>  .</strong>      sys_execve(),     ftrace     . ,       -‚Ä¶ <br></li><li> <strong>   .</strong>       sys_execve()    fh_sys_execve(),     do_syscall_64().         sys_execve()   .     : ftrace    sys_execve() . <br></li><li> <strong>  .</strong>       sys_execve()      fh_sys_execve().        .   ,    execve()  ,   ,     ,  . . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Management kehrt zum Kern zur√ºck. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich wird fh_sys_execve () abgeschlossen und die Steuerung an do_syscall_64 () √ºbergeben, wodurch ber√ºcksichtigt wird, dass der Systemaufruf wie gewohnt abgeschlossen wurde. </font><font style="vertical-align: inherit;">Der Kern setzt sein Nukleargesch√§ft fort.</font></font><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Management kehrt zum Benutzerprozess zur√ºck. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich f√ºhrt der Kernel den IRET-Befehl (oder SYSRET, aber f√ºr execve () ist es immer IRET) aus, setzt Register f√ºr den neuen Benutzerprozess und versetzt den Zentralprozessor in den Benutzercode-Ausf√ºhrungsmodus. </font><font style="vertical-align: inherit;">Der Systemaufruf (und das Starten eines neuen Prozesses) ist abgeschlossen.</font></font><br></li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vor- und Nachteile </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als Ergebnis erhalten wir eine sehr bequeme M√∂glichkeit, alle Funktionen im Kernel abzufangen, was die folgenden Vorteile bietet: </font></font><br><br><ul><li> <strong> API   .</strong>        .       ,     ,      .   ‚Äî   -,    . <br></li><li> <strong>    .</strong>            .   -     ,     ,  ,  - .      (    ),    . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Abfangen ist mit der Ablaufverfolgung kompatibel. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offensichtlich widerspricht diese Methode nicht ftrace, sodass Sie dem Kernel immer noch sehr n√ºtzliche Leistungsindikatoren entnehmen k√∂nnen. </font><font style="vertical-align: inherit;">Die Verwendung von Sonden oder Splei√üen kann die Verfolgungsmechanismen beeintr√§chtigen.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was sind die Nachteile dieser L√∂sung? </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anforderungen an die Kernelkonfiguration. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Funktions-Hooks mit ftrace erfolgreich ausf√ºhren zu k√∂nnen, muss der Kernel eine Reihe von Funktionen bereitstellen:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Liste der Kallsyms-Zeichen, um nach Funktionen nach Namen zu suchen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ftrace Framework im Allgemeinen f√ºr die R√ºckverfolgung </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfolgen Sie kritische Abfangoptionen </font></font></li></ul><br>                . ,  ,   ,        ,           . ,     -  ,       . <br></li><li> <strong>   ftrace</strong> ,   kprobes (  ftrace    ),   ,   ,  . , <em> ftrace</em> ‚Äî      ,    ¬´¬ª  ftrace   . <br></li><li> <strong>  .</strong>    ,      . ,         ,  ftrace    . ,         ,       . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doppelter Anruf ftrace. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der oben beschriebene Ansatz der </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigeranalyse f√ºhrt erneut zu einem ftrace-Aufruf f√ºr Hook-Funktionen. </font><font style="vertical-align: inherit;">Dies erh√∂ht den Overhead und kann andere Spuren zerst√∂ren, die doppelt so viele Anrufe sehen. </font><font style="vertical-align: inherit;">Dieser Nachteil kann vermieden werden, indem ein wenig schwarze Magie angewendet wird: Der ftrace-Aufruf befindet sich am Anfang der Funktion. Wenn also die Adresse der urspr√ºnglichen Funktion um 5 Byte (die L√§nge der Aufrufanweisung) vorw√§rts verschoben wird, k√∂nnen Sie durch ftrace springen.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrachten Sie einige der Nachteile genauer. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anforderungen an die Kernelkonfiguration </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr den Anfang muss der Kernel ftrace und kallsyms unterst√ºtzen. </font><font style="vertical-align: inherit;">Dazu m√ºssen folgende Optionen aktiviert sein:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_FTRACE </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_KALLSYMS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann sollte ftrace die dynamische Registermodifikation unterst√ºtzen. </font><font style="vertical-align: inherit;">Die Option ist daf√ºr verantwortlich.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_DYNAMIC_FTRACE_WITH_REGS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem muss der verwendete Kernel auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version 3.19 oder h√∂her</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basieren </font><font style="vertical-align: inherit;">, um auf das Flag FTRACE_OPS_FL_IPMODIFY zugreifen zu k√∂nnen. </font><font style="vertical-align: inherit;">Fr√ºhere Versionen des Kernels k√∂nnen auch das% rip-Register ersetzen. Ab 3.19 sollte dies jedoch erst nach dem Setzen dieses Flags erfolgen. </font><font style="vertical-align: inherit;">Das Vorhandensein eines Flags f√ºr alte Kernel f√ºhrt zu einem Kompilierungsfehler, und das Fehlen f√ºr neue Kernel f√ºhrt zu einem Leerlaufabfangen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Abfangen durchzuf√ºhren, ist schlie√ülich die Position des ftrace-Aufrufs innerhalb der Funktion kritisch: Der Aufruf muss ganz am Anfang vor dem Prolog der Funktion liegen (wobei Platz f√ºr lokale Variablen zugewiesen wird und ein Stapelrahmen gebildet wird). </font><font style="vertical-align: inherit;">Diese Architekturfunktion wird von der Option ber√ºcksichtigt</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_HAVE_FENTRY </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die x86_64-Architektur unterst√ºtzt diese Option, der i386 jedoch nicht. </font><font style="vertical-align: inherit;">Aufgrund von Einschr√§nkungen der i386-Architektur kann der Compiler vor dem Funktionsprolog keinen ftrace-Aufruf einf√ºgen. Daher ist der Funktionsstapel zum Zeitpunkt des Aufrufs von ftrace bereits ge√§ndert. </font><font style="vertical-align: inherit;">In diesem Fall reicht es zum Abfangen nicht aus, nur den Wert des% eip-Registers zu √§ndern. Sie m√ºssen dennoch alle im Prolog ausgef√ºhrten Aktionen umkehren, die sich von Funktion zu Funktion unterscheiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesem Grund unterst√ºtzt ftrace Interception die x86 32-Bit-Architektur nicht. </font><font style="vertical-align: inherit;">Im Prinzip k√∂nnte es mit Hilfe bestimmter schwarzer Magie (Erzeugung und Durchf√ºhrung eines ‚ÄûAnti-Prologs‚Äú) implementiert werden, aber dann leidet die technische Einfachheit der L√∂sung, was einer der Vorteile der Verwendung von ftrace ist.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unverst√§ndliche √úberraschungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Testen stie√üen wir auf eine interessante </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Bei einigen Distributionen f√ºhrten Hooking-Funktionen dazu, dass das System fest abst√ºrzte. Dies geschah nat√ºrlich nur auf anderen Systemen als den von den Entwicklern verwendeten. Das Problem wurde auch nicht auf dem urspr√ºnglichen Interception-Prototyp mit Distributionen und Kernel-Versionen reproduziert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Debuggen zeigte, dass der Hang innerhalb der abgefangenen Funktion auftritt. Aus irgendeinem mystischen Grund wurde beim Aufrufen der urspr√ºnglichen Funktion innerhalb des ftrace-R√ºckrufs die Adresse </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weiterhin </font><font style="vertical-align: inherit;">im Kernelcode </font><font style="vertical-align: inherit;">anstelle des Wrapper-Funktionscodes angegeben. Aus diesem Grund entstand eine Endlosschleife, da ftrace unseren Wrapper immer wieder aufrief, ohne n√ºtzliche Aktionen auszuf√ºhren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gl√ºcklicherweise verf√ºgten wir sowohl √ºber funktionierenden als auch √ºber fehlerhaften Code, sodass es nur eine Frage der Zeit war, die Unterschiede zu finden. </font><font style="vertical-align: inherit;">Nachdem der Code vereinheitlicht und alles Unn√∂tige verworfen worden war, wurden die Unterschiede zwischen den Versionen in einer Wrapper-Funktion lokalisiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Option hat funktioniert:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aber dieser - hat das System aufgeh√§ngt: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie stellt sich heraus, dass die Protokollierungsstufe das Verhalten beeinflusst? Eine sorgf√§ltige Untersuchung des Maschinencodes der beiden Funktionen verdeutlichte schnell die Situation und verursachte genau das Gef√ºhl, als der Compiler schuld war. Normalerweise steht er irgendwo in der N√§he der kosmischen Strahlung auf der Verd√§chtigenliste, diesmal jedoch nicht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie sich herausstellte, werden Aufrufe von pr_devel () in die Leere erweitert. Diese Version des printk-Makros wird f√ºr die Protokollierung w√§hrend der Entwicklung verwendet. Solche Protokolleintr√§ge sind w√§hrend des Betriebs nicht interessant, daher werden sie automatisch aus dem Code herausgeschnitten, wenn das DEBUG-Makro nicht deklariert wird. Danach wird die Funktion f√ºr den Compiler folgenderma√üen:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> real_sys_execve(filename, argv, envp); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und hier kommt die Optimierung ins Spiel. </font><font style="vertical-align: inherit;">In diesem Fall ist es so genannte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierung Endrekursion</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Tail Call - </font><font style="vertical-align: inherit;">Optimierung). </font><font style="vertical-align: inherit;">Es erm√∂glicht dem Compiler, einen ehrlichen Funktionsaufruf durch einen direkten Sprung zu seinem K√∂rper zu ersetzen, wenn eine Funktion eine andere aufruft und sofort ihren Wert zur√ºckgibt. </font><font style="vertical-align: inherit;">Im Maschinencode sieht ein ehrlicher Anruf folgenderma√üen aus:</font></font><br><br><pre> <code class="hljs xml">0000000000000000 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve</span></span></span><span class="hljs-tag">&gt;</span></span>: 0: e8 00 00 00 00 callq 5 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve+0x5</span></span></span><span class="hljs-tag">&gt;</span></span> 5: ff 15 00 00 00 00 callq *0x0(%rip) b: f3 c3 repz retq</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und nicht arbeitend - so: </font></font><br><br><pre> <code class="hljs perl"><span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> &lt;fh_sys_execve&gt;: <span class="hljs-number"><span class="hljs-number">0</span></span>: e8 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> callq <span class="hljs-number"><span class="hljs-number">5</span></span> &lt;fh_sys_execve+<span class="hljs-number"><span class="hljs-number">0x5</span></span>&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>b <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> mov <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rip),%rax c: ff e<span class="hljs-number"><span class="hljs-number">0</span></span> jmpq *%rax</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste CALL-Anweisung ist derselbe __fentry __ () -Aufruf, den der Compiler am Anfang aller Funktionen eingef√ºgt hat. Im normalen Code k√∂nnen Sie jedoch den Aufruf von real_sys_execve (durch den Zeiger im Speicher) √ºber die Anweisung CALL sehen und mit der Anweisung RET von fh_sys_execve () zur√ºckkehren. Der fehlerhafte Code wird direkt √ºber JMP an die Funktion real_sys_execve () √ºbergeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch die Optimierung von Tail-Aufrufen k√∂nnen Sie ein wenig Zeit bei der Bildung eines ‚Äûbedeutungslosen‚Äú Stapelrahmens sparen, der die durch den CALL-Befehl im Stapel gespeicherte R√ºcksprungadresse enth√§lt. F√ºr uns spielt jedoch die Richtigkeit der Absenderadresse eine entscheidende Rolle - wir verwenden sie </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um eine Entscheidung √ºber das Abfangen zu treffen. Nach der Optimierung speichert die Funktion fh_sys_execve () nicht mehr die neue R√ºcksprungadresse auf dem Stapel, sondern die alte, die auf den Kernel zeigt. Deshalb</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt weiterhin in den Kern, was letztendlich zur Bildung einer Endlosschleife f√ºhrt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erkl√§rt auch, warum das Problem nur bei einigen Distributionen reproduziert wurde. Beim Kompilieren von Modulen verwenden verschiedene Distributionen unterschiedliche S√§tze von Kompilierungsflags. In notleidenden Distributionen war die Tail-Call-Optimierung standardm√§√üig aktiviert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die L√∂sung f√ºr das Problem bestand f√ºr uns darin, die Tail-Call-Optimierung f√ºr die gesamte Datei mit Wrapper-Funktionen zu deaktivieren:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> GCC optimize(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"-fno-optimize-sibling-calls"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was kann ich noch sagen ... Das Entwickeln von Low-Level-Code f√ºr den Linux-Kernel macht Spa√ü. </font><font style="vertical-align: inherit;">Ich hoffe, diese Ver√∂ffentlichung spart jemandem ein wenig Zeit bei der Auswahl, was er verwenden soll, um Ihr bestes Antivirenprogramm der Welt zu schreiben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie selbst mit dem Abfangen experimentieren m√∂chten, finden Sie den vollst√§ndigen Code des Kernelmoduls </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413241/">https://habr.com/ru/post/de413241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413231/index.html">Einf√ºhrung in Smart Contracts</a></li>
<li><a href="../de413233/index.html">Der uLogin-Dienst sendet Daten von Formularen (E-Mail, Telefon) an eine Website eines Drittanbieters und schweigt dar√ºber</a></li>
<li><a href="../de413235/index.html">Wetten auf bessere Vorhersagen: Neue Mathematik der Wettervorhersage</a></li>
<li><a href="../de413237/index.html">Facebook bestreitet, dass Ger√§tehersteller dieselben Daten wie Entwickler Alexander Kogan senden</a></li>
<li><a href="../de413239/index.html">Wie man ein Smartphone etwas d√ºmmer macht</a></li>
<li><a href="../de413243/index.html">School of Data: Wie man Mathematik und Wirtschaft kombiniert</a></li>
<li><a href="../de413245/index.html">Auf Dolby Atmos-Ger√§ten - nur "nativer" Sound. Dolby verbietet nicht native Upmixing</a></li>
<li><a href="../de413247/index.html">Warum Speichersysteme √ºberwachen?</a></li>
<li><a href="../de413249/index.html">Schreiben eines Linux-Kernelmoduls: I2C</a></li>
<li><a href="../de413251/index.html">Polymerasekettenreaktion und Wladiwostok</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>