<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏽 👌🏾 🤳🏼 C ++ Rússia: como foi 🐓 🦑 👩‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se, no início da peça, você diz que o código C ++ está pendurado na parede, então, no final, ele certamente deve lhe dar um tiro no pé. 

 Bjarne Stro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ Rússia: como foi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/481358/">  <i>Se, no início da peça, você diz que o código C ++ está pendurado na parede, então, no final, ele certamente deve lhe dar um tiro no pé.</i> <i><br><br></i>  <i>Bjarne Stroustrup</i> <i><br></i> <br>  De 31 de outubro a 1 de novembro, São Petersburgo sediou a C ++ Russia Piter Conference, uma das maiores conferências de programação na Rússia, organizada pelo JUG Ru Group.  Entre os palestrantes convidados estão membros do comitê de padronização do C ++, palestrantes do CppCon, autores de livros de O'Reilly, além de mantenedores de projetos como LLVM, libc ++ e Boost.  A conferência é destinada a desenvolvedores experientes em C ++ que desejam aprofundar seus conhecimentos e trocar experiências em comunicação ao vivo.  Estudantes, estudantes de graduação e professores universitários recebem descontos muito agradáveis. <br><br>  A edição de Moscou da conferência já pode ser visitada em abril do próximo ano, mas, por enquanto, nossos alunos contarão as coisas interessantes que aprenderam no último evento. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a73/7bf/78f/a737bf78fa7a626dc60d87aae2d2ce88.png"><br><a name="habracut"></a><br>  <i>Foto do <a href="https://vk.com/album-77278886_270140987">álbum da conferência</a></i> <br><br><h2>  Sobre nós </h2><br>  Dois alunos da Escola Superior de Economia - São Petersburgo, trabalharam neste post: <br><br><ul><li>  Lisa Vasilenko é uma aluna do 4º ano que estuda a direção de "Linguagens de Programação" como parte do programa "Matemática Aplicada e Ciência da Computação".  Familiarizado com a linguagem C ++ no primeiro ano da universidade, posteriormente adquiriu experiência trabalhando com ela em estágios na indústria.  A paixão pelas linguagens de programação em geral e pela programação funcional em particular deixou sua marca na escolha dos relatórios na conferência. <br></li><li>  Danya Smirnov é uma aluna do primeiro ano do programa de mestrado “Programação e Análise de Dados”.  Enquanto ainda estava na escola, ele escreveu problemas das Olimpíadas em C ++ e, de alguma forma, aconteceu que o idioma aparecia constantemente nas atividades educacionais e, como resultado, tornou-se o principal trabalho.  Decidi participar da conferência para aprimorar meu conhecimento e aprender sobre novas oportunidades. <br></li></ul><br>  No boletim, os líderes do corpo docente costumam compartilhar informações sobre eventos educacionais relacionados à nossa especialidade.  Em setembro, vimos informações sobre C ++ Rússia e decidimos nos registrar como ouvintes.  Esta é a nossa primeira experiência de participação em tais conferências. <br><br><h2>  Estrutura da Conferência </h2><br><ul><li><h3>  Relatórios </h3></li></ul><br>  Ao longo de dois dias, os especialistas leram 30 relatórios destacando muitos tópicos importantes: aplicativos espirituosos de recursos de linguagem para resolver problemas aplicados, atualizações futuras de idiomas devido ao novo padrão, comprometimentos no design e precauções em C ++ ao trabalhar com suas consequências, exemplos de arquitetura de projeto interessante, bem como algumas partes do mecanismo da infraestrutura de idiomas.  Ao mesmo tempo, ocorreram três apresentações, na maioria das vezes duas em russo e uma em inglês. <br><br><ul><li><h3>  Zonas de discussão </h3></li></ul><br>  Após o discurso, todas as perguntas não respondidas e discussões incompletas foram transferidas para áreas de comunicação especialmente designadas com alto-falantes equipados com placas de identificação.  Uma boa maneira de passar o intervalo entre as apresentações para uma conversa agradável. <br><br><ul><li><h3>  Lightning Talks e discussões informais </h3></li></ul><br>  Se você quiser fazer um breve relatório, poderá se inscrever para uma Lightning Talk à noite em um quadro de marcadores e ter cinco minutos para conversar sobre qualquer assunto sobre o tópico da conferência.  Por exemplo, uma rápida introdução aos desinfetantes para C ++ (que acabou sendo nova para alguns) ou uma história sobre um bug na geração de um sinusóide que você só pode ouvir, mas não vê. <br><br>  Outro formato é o painel de discussão “Com o Comitê da Alma”.  No palco, há alguns membros do comitê de padronização; no projetor, há uma lareira (oficialmente - para criar uma atmosfera de alma, mas a razão "porque TUDO EM FOGO" parece mais engraçado), as perguntas são sobre a visão geral e padrão do C ++, sem discussões técnicas e holivars acalorados.  Verificou-se que as pessoas vivas também fazem parte do comitê, que pode não estar completamente certo de algo ou pode não saber de nada. <br><br>  Para os entusiastas do holivar, o terceiro evento permaneceu - a sessão do BOF "Go against C ++".  Levamos um amante do Go, um amante do C ++, antes do início da sessão, eles preparam 100500 slides sobre o tópico juntos (como problemas com pacotes em C ++ ou falta de genéricos no Go) e depois discutem animadamente entre si e o público, e o público tenta entender dois pontos de vista ao mesmo tempo .  Se o holivar não iniciar os negócios, o moderador intervém e reconcilia as partes.  Esse formato é viciante: algumas horas após o início, apenas metade dos slides foi concluída.  O fim teve que ser muito acelerado. <br><br><ul><li><h3>  Stands de parceiros </h3></li></ul><br>  Os parceiros da conferência estavam representados nos corredores - eles conversaram sobre projetos atuais nas estandes, ofereceram estágios e empregos, realizaram quizzes e pequenas competições e também tiveram ótimos prêmios.  No entanto, algumas empresas até se ofereceram para passar pelas etapas iniciais das entrevistas, o que pode ser útil para aqueles que vieram não apenas ouvir os relatórios. <br><br><h2>  Detalhes técnicos dos relatórios </h2><br>  Ouvimos relatórios nos dois dias.  Às vezes, era difícil escolher um relatório entre os que estavam sendo executados em paralelo - concordamos em compartilhar e trocar o conhecimento adquirido durante os intervalos.  E mesmo assim, parece que muito se perdeu.  Aqui gostaríamos de falar sobre o conteúdo de alguns relatórios que nos pareceram os mais interessantes <br><br><h3>  Exceções em C ++ através do prisma das otimizações do compilador, Roman Rusyaev </h3><br><br><img src="https://habrastorage.org/webt/dc/0q/rl/dc0qrlgt1peqimzact93fvh8zb0.png"><br>  <i>Slide de <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">apresentação</a></i> <br><br>  Como o nome indica, Roman procurou trabalhar com exceções usando o LLVM como exemplo.  Ao mesmo tempo, para aqueles que não usam o Clang em seus trabalhos, o relatório ainda pode dar uma idéia de como o código pode ser otimizado.  Isso ocorre porque os desenvolvedores de compiladores e as bibliotecas padrão correspondentes se comunicam entre si e muitas soluções bem-sucedidas podem coincidir. <br><br>  Portanto, para lidar com a exceção, é necessário executar várias ações: chame o código de processamento (se houver) ou libere recursos no nível atual e relaxe a pilha mais alto.  Tudo isso leva ao fato de que o compilador adiciona instruções adicionais para lançar chamadas em potencial.  Portanto, se uma exceção de fato não for causada, o programa ainda começará a executar ações desnecessárias.  Para reduzir de alguma forma os custos indiretos, o LLVM possui várias heurísticas para determinar situações em que você não precisa adicionar um código de tratamento de exceção ou pode reduzir o número de instruções "desnecessárias". <br><br>  O palestrante considera cerca de uma dúzia deles e mostra as situações em que eles ajudam a acelerar a execução do programa e aquelas em que esses métodos não são aplicáveis. <br><br>  Assim, Roman Rusyaev leva o público à conclusão de que o código que contém o trabalho com exceções nem sempre pode ser executado com zero de sobrecarga e fornece as seguintes dicas: <br><br><ul><li>  ao desenvolver bibliotecas, você deve abandonar as exceções em princípio; </li><li>  se você ainda precisar de exceções, sempre que possível, vale a pena adicionar modificadores noexcept (e const) para que o compilador possa otimizar o máximo possível. </li></ul><br>  Em geral, o orador reiterou a visão de que as exceções são melhor usadas ao mínimo, ou mesmo as abandonam. <br><br>  Os slides do relatório estão disponíveis em: <a href="https://assets.ctfassets.net/oxjq45e8ilak/6Q09SPvX2Rsveiayc1VkcC/ce9e2b8eb22d6693eb4c3b06968bedc0/100693_477384438_Roman_Rusyayev_Isklyucheniya_C_cherez_prizmu_kompilyatornykh_optimizatsiy.pdf">["Exceções em C ++ através do prisma da otimização do compilador LLVM"]</a> <br><br><h3>  Geradores, corotinas e outras doçuras que desenrolam o cérebro, Adi Shavit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d20/0c4/4a6/d200c44a65058c3b50a29d0b551a9cc0.png"><br>  <i>Slide de <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">apresentação</a></i> <br><br>  Um dos muitos relatórios desta conferência dedicados às inovações do C ++ 20 foi lembrado não apenas por sua apresentação colorida, mas também por sua clara designação dos problemas com a lógica de processamento de coleções (para loop de retorno de chamada). <br><br>  Adi Shavit destaca o seguinte: os métodos atualmente disponíveis percorrem toda a coleção e não dão acesso a algum estado intermediário interno (ou no caso de retornos de chamada, mas com muitos efeitos colaterais desagradáveis, como o mesmo inferno de retorno de chamada).  Parece que existem iteradores, mas nem tudo é tão fácil com eles: não há pontos de entrada e saída comuns (começo → fim versus rbegin → rend e assim por diante), não está claro quanto vamos iterar.  Começando com C ++ 20, esses problemas foram resolvidos! <br><br>  A primeira opção: intervalos.  Devido ao wrapper na parte superior dos iteradores, obtemos uma interface comum para o início e o final da iteração, além da possibilidade de composição.  Tudo isso facilita a construção de pipelines completos de processamento de dados.  Mas nem tudo é tão tranquilo: parte da lógica dos cálculos está na implementação de um iterador específico, que pode complicar o código de percepção e depuração. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/a7d/09d/f41a7d09d24a823a3397aa27a552f254.png"><br>  <i>Slide de <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">apresentação</a></i> <br><br>  Bem, neste caso, foram adicionadas corotinas no C ++ 20 (funções cujo comportamento é semelhante aos geradores em Python): a execução pode ser adiada retornando algum valor atual, mantendo o estado intermediário.  Assim, conseguimos não apenas trabalhar com dados como eles aparecem, mas também encapsular toda a lógica dentro de uma determinada rotina. <br><br>  Mas há uma mosca na pomada: no momento, eles são apenas parcialmente suportados pelos compiladores existentes e também não são implementados com a precisão que gostaríamos: por exemplo, links e objetos temporários não devem ser usados ​​em corotinas.  Além disso, existem algumas restrições sobre o que podem ser corotinas, e as funções constexpr, construtores / destruidores e também as principais não estão incluídas nesta lista. <br><br>  Assim, as corotinas resolvem uma parte significativa dos problemas com a simplicidade da lógica de processamento de dados, mas suas implementações atuais exigem refinamento. <br><br>  Materiais: <br><br><ul><li>  Slides com C ++ Russia - <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">["Geradores, corotinas e outras doçuras que desenrolam o cérebro"]</a> </li><li>  <a href="https://youtu.be/qYHDERleSL8">Relatório de vídeo do CppCon 2019</a> </li></ul><br><h3>  Truques em C ++ de Yandex.Taxi, Anton Polukhin </h3><br>  Em sua atividade profissional, às vezes você precisa implementar coisas puramente auxiliares: um invólucro entre a interface interna e a API de alguma biblioteca, registrando ou analisando.  No entanto, geralmente não há necessidade de qualquer otimização adicional.  Mas e se esses componentes forem usados ​​em alguns dos serviços mais populares do Runet?  Em tal situação, você terá que processar apenas terabytes por hora de logs!  Cada milissegundo conta e, portanto, você precisa recorrer a vários truques - Anton Polukhin falou sobre eles. <br><br>  Talvez o exemplo mais interessante tenha sido a implementação do padrão ponteiro para implementação (pimpl). <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;third_party/json.hpp&gt; //PROBLEMS! struct Value { Value() = default; Value(Value&amp;&amp; other) = default; Value&amp; operator=(Value&amp;&amp; other) = default; ~Value() = default; std::size_t Size() const { return data_.size(); } private: third_party::Json data_; };</span></span></span></span></code> </pre> <br>  Neste exemplo, primeiro você deseja se livrar dos arquivos de cabeçalho das bibliotecas externas - eles serão compilados mais rapidamente e você pode se proteger de possíveis conflitos de nome e outros erros semelhantes. <br><br>  Ok, movemos #include para o arquivo .cpp: você precisa da declaração de encaminhamento da API agrupada, além de std :: unique_ptr.  Agora, temos alocações dinâmicas e outras coisas desagradáveis, como dados espalhados por uma pilha e garantias reduzidas.  Com tudo isso, std :: align_storage pode ajudar. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... private: using JsonNative = third_party::Json; const JsonNative* Ptr() const noexcept; JsonNative* Ptr() noexcept; constexpr std::size_t kImplSize = 32; constexpr std::size_t kImplAlign = 8; std::aligned_storage_t&lt;kImplSize, kImplAlign&gt; data_; };</span></span></code> </pre> <br>  O único problema: você precisa especificar o tamanho e o alinhamento de cada invólucro - criaremos nosso modelo pimpl com os parâmetros &lt;T, SizeT, AlignmentT&gt;, usaremos alguns valores arbitrários e adicionaremos ao destruidor uma verificação para adivinhar tudo: <br><br><pre> <code class="cpp hljs">~FastPimpl() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { validate&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt;(); Ptr()-&gt;~T(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualSize, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualAlignment&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Size == ActualSize, <span class="hljs-string"><span class="hljs-string">"Size and sizeof(T) mismatch"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Alignment == ActualAlignment, <span class="hljs-string"><span class="hljs-string">"Alignment and alignof(T) mismatch"</span></span> ); }</code> </pre> <br>  Como T já foi determinado durante o processamento do destruidor, esse código será desmontado corretamente e, no estágio de compilação na forma de erros, exibirá os valores de tamanho e alinhamento necessários que precisam ser inseridos.  Assim, ao custo de um início adicional de compilação, nos livramos da alocação dinâmica de classes agrupadas, ocultamos a API em um arquivo .cpp com a implementação e também obtemos um design mais adequado para armazenamento em cache pelo processador. <br><br>  O registro e a análise pareciam menos impressionantes e, portanto, não serão mencionados nesta revisão. <br><br>  Os slides do relatório estão disponíveis no link: <a href="https://assets.ctfassets.net/oxjq45e8ilak/4rkoaQV6ancsfvzYx1fOCF/087dda7d63101cc225d706d03d7c5075/100566_2093066332_Anton_Polukhin_C_tryuki_iz_Taksi.pdf">["C ++ Taxi Tricks"]</a> <br><br><h3>  Técnicas modernas para manter seu código SECO, Björn Fahller </h3><br>  Nesta palestra, Björn Fahller mostra várias maneiras diferentes de lidar com falhas estilísticas, como repetidas verificações condicionais: <br><br><pre> <code class="cpp hljs">assert(a == IDLE || a == CONNECTED || a == DISCONNECTED);</code> </pre> <br>  Isso é familiar?  Usando várias técnicas C ++ poderosas que apareceram nos padrões recentes, você pode implementar normalmente a mesma funcionalidade sem a menor perda de desempenho.  Compare: <br><br><pre> <code class="cpp hljs">assert(a == any_of(IDLE, CONNECTED, DISCONNECTED));</code> </pre> <br>  Para processar um número ilimitado de verificações, você é solicitado imediatamente a usar modelos variados e expressões de dobra.  Suponha que desejamos verificar a igualdade de várias variáveis ​​com o elemento enum'a state_type.  A primeira coisa que vem à mente é escrever a função auxiliar is_any_of: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> state_type { IDLE, CONNECTED, DISCONNECTED }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp; ... ts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((s == ts) || ...); }</code> </pre><br>  Um resultado tão intermediário é decepcionante.  Até agora, o código não está se tornando legível: <br><br><pre> <code class="cpp hljs">assert(is_any_of(state, IDLE, DISCONNECTING, DISCONNECTED));</code> </pre> <br>  Parâmetros de modelo não-tipo ajudarão a melhorar um pouco a situação.  Com a ajuda deles, transferimos os elementos enumerados para a lista de parâmetros do modelo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;state_type ... states&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == states) | ...); } assert(is_any_of&lt;IDLE, DISCONNECTING, DISCONNECTED&gt;(state));</code> </pre> <br>  Usando auto em um parâmetro de modelo não típico (C ++ 17), a abordagem é simplesmente generalizada para comparações não apenas com elementos state_type, mas também com tipos primitivos que podem ser usados ​​como parâmetros de modelo não-tipo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ... alternatives, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == alternatives) | ...); }</code> </pre> <br>  Por meio dessas melhorias incrementais, é alcançada a sintaxe superficial desejada para verificação: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any_of</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts ...&gt; { <span class="hljs-comment"><span class="hljs-comment">//      tuple        using std::tuple&lt;Ts ...&gt;::tuple;        template &lt;typename T&gt;        bool operator ==(const T&amp; t) const {                return std::apply(                        [&amp;t](const auto&amp; ... ts) {                                return ((ts == t) || ...);                        },                        static_cast&lt;const std::tuple&lt;Ts ...&gt;&amp;&gt;(*this));        } }; template &lt;class ... Ts&gt; any_of(Ts ...) -&gt; any_of&lt;Ts ... &gt;; assert(any_of(IDLE, DISCONNECTING, DISCONNECTED) == state);</span></span></code> </pre><br>  Neste exemplo, o guia de dedução serve para solicitar os parâmetros desejados da estrutura do modelo para um compilador que conhece os tipos de argumentos do construtor. <br><br>  Mais interessante.  Bjorn ensina a generalizar o código resultante para operadores de comparação, além de == e, em seguida, para operações arbitrárias.  Juntamente com o exemplo de uso, são explicados recursos como o atributo no_unique_address (C ++ 20) e parâmetros de modelo nas funções lambda (C ++ 20).  (Sim, agora a sintaxe lambda é ainda mais fácil de lembrar - são quatro pares consecutivos de colchetes de todos os tipos.) A solução final usando funções como partes construtoras realmente aquece minha alma, sem mencionar a expressão de tupla nas melhores tradições do cálculo lambda. <br><br>  No final, não esqueça de colocar um gloss: <br><br><ul><li>  Lembre-se de que as lambdas são gratuitas; </li><li>  Adicione encaminhamento perfeito e observe sua sintaxe feia aplicada ao pacote de parâmetros no fechamento lambda; </li><li>  Vamos dar ao compilador mais opções para otimizações com exceção condicional; </li><li>  Nós cuidaremos de uma saída de erro mais clara nos modelos devido aos valores de retorno explícitos das lambdas.  Isso forçará o compilador a fazer mais verificações antes de realmente chamar a função de modelo - no estágio de verificação de tipo. </li></ul><br>  Para detalhes, consulte os materiais da palestra: <br><br><ul><li>  Slides do relatório: <a href="https://assets.ctfassets.net/oxjq45e8ilak/7lP3ueTFEJnmdVjGGjrgHI/e30dfcbff0630fb63389f3f3e734a1a3/100644_2039674689_Bjrn_Fahller_Modern_techniques_for_keeping_your_code_dry.pdf">[Técnicas modernas para manter seu código seco]</a> </li><li>  <a href="https://github.com/rollbear/dry-comparisons">Código fonte do Github</a> </li><li>  <a href="https://playfulprogramming.blogspot.com/2018/07/dry-multicomparisons.html">Artigo do blog do autor</a> </li></ul><br><h2>  Nossas impressões </h2><br>  Nossa primeira participação no C ++ Russia foi lembrada por sua riqueza.  Havia uma impressão de C ++ Rússia como um evento emocional, onde a linha entre aprendizado e comunicação ao vivo quase não é perceptível.  Tudo, desde o humor dos palestrantes até as competições dos parceiros do evento, é propício para discussões acaloradas.  O conteúdo da conferência, que consiste em relatórios, abrange uma ampla gama de tópicos, incluindo inovações em C ++, exemplos da prática de grandes projetos e considerações ideológicas da arquitetura.  Mas seria injusto privar a atenção do componente social do evento, o que ajuda a superar barreiras linguísticas em relação não apenas ao C ++. <br><br>  Agradecemos aos organizadores da conferência pela oportunidade de participar de um evento como esse! <br>  Você pode ver a postagem dos organizadores sobre o passado, presente e futuro do C ++ Russia <a href="https://habr.com/ru/company/jugru/blog/480584/">no blog JUG Ru</a> . <br><br>  Obrigado pela leitura e esperamos que nossa recontagem dos eventos tenha sido útil! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481358/">https://habr.com/ru/post/pt481358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481348/index.html">Pentest Active Directory. Parte 1</a></li>
<li><a href="../pt481350/index.html">Quem trabalha no cosmódromo de Plesetsk</a></li>
<li><a href="../pt481352/index.html">DBA: limpando registros de clones de uma tabela sem PK</a></li>
<li><a href="../pt481354/index.html">TelegramBot. A funcionalidade básica. Voa separadamente, costeletas separadamente. (Parte 2)</a></li>
<li><a href="../pt481356/index.html">Obrigado, 2019</a></li>
<li><a href="../pt481360/index.html">Os resultados da semana: Rambler e Twitch concordaram, o trabalho eletrônico será introduzido na Federação Russa e o Facebook criará seu próprio sistema operacional</a></li>
<li><a href="../pt481362/index.html">Certificado SSL para aplicativo da web Docker</a></li>
<li><a href="../pt481364/index.html">Casa sensível está substituindo casas inteligentes</a></li>
<li><a href="../pt481366/index.html">RICE: Fácil Priorização para Gerentes de Produto</a></li>
<li><a href="../pt481368/index.html">Teste cego da câmera: iPhone, Pixel, Samsung e Huawei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>