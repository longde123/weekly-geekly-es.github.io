<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¼â€ğŸ« ğŸŒš ğŸ—ï¸ Pengantar ECMAScript 6 (ES-2015) ğŸ‚ğŸ¼ ğŸŒ“ ğŸ¥¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengantar ES6 

 Daftar isi 
 1. Templat literal 
 2. biarkan dan const 
 3. Ekspresi fungsi panah 
 4. Untuk ... dari 
 5. Nama properti yang dihitun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar ECMAScript 6 (ES-2015)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460741/"><h2>  Pengantar ES6 </h2><br><br>  <b>Daftar isi</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Templat literal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. biarkan dan const</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Ekspresi fungsi panah</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Untuk ... dari</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Nama properti yang dihitung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Object.assign ()</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Parameter istirahat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8. Parameter default</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9. Penugasan yang merusak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">10. Peta</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">11. Atur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">12. Kelas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">13. Janji</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">14. Iterator</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">15. Generator</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">16. Sumbol</a> <br><br><a name="section001"></a><h2>  Templat literal (Templat string) </h2><br>  Templat literal adalah string literal yang memungkinkan penggunaan ekspresi di dalam.  Dengan mereka Anda dapat menggunakan multiline literal dan interpolasi string. <br><br>  Literal template dilampirkan dalam backticks (``) bukan double atau single.  Mereka dapat berisi wildcard yang ditandai dengan tanda dolar dan kurung kurawal ($ {ekspresi}).  Ekspresi subtitusi dan teks di antara keduanya diteruskan ke fungsi.  Secara default, fungsi hanya menggabungkan semua bagian menjadi string.  Jika ada ekspresi sebelum baris (ini tag), maka baris templat disebut "templat tag".  Dalam kasus ini, ekspresi tag (biasanya fungsi) disebut dengan literal templat yang diproses, yang dapat Anda modifikasi sebelum hasilnya.  Untuk menghindari backquote dalam literal templat, tentukan backslash \. <br><a name="habracut"></a><br>  <b>Literal multiline</b> <br>  Karakter baris baru adalah bagian dari wildcard literals.  Menggunakan string biasa, penyisipan pembungkus akan membutuhkan sintaks berikut: <br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'string text line 1\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'string text line 2'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br>  Sama dengan menggunakan literal templat: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`string text line 1 string text line 2`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br><br>  <b>Interpolasi Ekspresi</b> <br>  Untuk menyisipkan ekspresi ke string reguler, Anda harus menggunakan sintaks berikut: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Fifteen is '</span></span> + (a + b) + <span class="hljs-string"><span class="hljs-string">' and not '</span></span> + (<span class="hljs-number"><span class="hljs-number">2</span></span> * a + b) + <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <br><br>  Sekarang, dengan bantuan literal templat, Anda dapat menggunakan `sintaksis gula`, yang membuat pergantian seperti itu lebih mudah dibaca: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fifteen is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a + b}</span></span></span><span class="hljs-string"> and not </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> * a + b}</span></span></span><span class="hljs-string">.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <cut></cut><br><br>  <b>Templat Bersarang</b> <br>  Terkadang, membuat pola adalah cara terpendek dan mungkin lebih mudah dibaca untuk membuat string.  Cukup masukkan satu lagi di dalam template backquoted, bungkus mereka di substitusi $ {}.  Misalnya, jika ekspresi itu benar, Anda bisa mengembalikan templat literal. <br>  Dalam ES5: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classes = <span class="hljs-string"><span class="hljs-string">'header'</span></span> classes += (isLargeScreen() ? <span class="hljs-string"><span class="hljs-string">''</span></span> : item.isCollapsed ? <span class="hljs-string"><span class="hljs-string">' icon-expander'</span></span> : <span class="hljs-string"><span class="hljs-string">' icon-collapser'</span></span>);</code> </pre> <br>  Di ES2015 dengan templat literal tanpa bersarang: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : (item.isCollapsed ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-expander'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-collapser'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br>  Dalam ES2015 dengan literal templat bersarang: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`icon-</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${item.isCollapsed ? </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'expander'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"> : </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'collapser'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br><cut></cut><br>  <b>Templat tag</b> <br>  Bentuk literal templat yang diperluas adalah templat yang ditandai.  Mereka memungkinkan Anda untuk mem-parsing templat literal menggunakan fungsi.  Argumen pertama dari fungsi tersebut berisi array nilai string, dan sisanya berisi ekspresi dari pergantian.  Akibatnya, fungsi tersebut harus mengembalikan string yang dirakit (atau sesuatu yang sama sekali berbeda, seperti yang akan ditampilkan nanti).  Nama fungsinya bisa apa saja. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings, personExp, ageExp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "That " var str1 = strings[1]; // " is a " // ,     // (  )    , //    (""),    . // var str2 = strings[2]; var ageStr; if (ageExp &gt; 99){ ageStr = 'centenarian'; } else { ageStr = 'youngster'; } //     ,     return `${str0}${personExp}${str1}${ageStr}`; } var output = myTag`That ${ person } is a ${ age }`; console.log(output);// That Mike is a youngster</span></span></code> </pre> <br>  Fungsi tag tidak diperlukan untuk mengembalikan string. <br><cut></cut><br>  <b>Garis mentah</b> <br>  Properti mentah khusus, tersedia untuk argumen pertama dari template tag, memungkinkan Anda untuk mendapatkan string dalam bentuk yang dimasukkan, tanpa interpretasi. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings.raw[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } tag<span class="hljs-string"><span class="hljs-string">`string text line 1 \\n string text line 2`</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "string text line 1 \\n string text line 2", //  'n'    '\'</span></span></code> </pre> <br>  Selain itu, ada metode String.raw () yang mengembalikan string sumber yang sama persis dengan fungsi templat default dan penggabungan string akan kembali bersamaan. <br><cut></cut><br>  Di ECMAScript 2016, templat yang diberi tag ikuti aturan untuk keluar dari karakter berikut: <br><ul><li>  Karakter Unicode dimulai dengan "\ u", misalnya, \ u00A9 </li><li>  Poin kode Unicode dimulai dengan "\ u {}", misalnya, \ u {2F804} </li><li>  Representasi karakter heksadesimal dimulai dengan "\ x", misalnya, \ xA9 </li><li>  representasi oktal karakter yang dimulai dengan "\", misalnya, \ 251 </li></ul><br><cut></cut><br><a name="section002"></a><h2>  biarkan dan const </h2><br>  Cakupan variabel yang dideklarasikan oleh kata kunci let dan const adalah blok di mana mereka dideklarasikan, dan semuanya berada di bawah blok.  Dalam hal ini, operasi direktif let mirip dengan direktif var.  Perbedaan utama adalah bahwa ruang lingkup variabel yang dideklarasikan oleh direktif var adalah seluruh fungsi yang dideklarasikan.  Selain variabel, nilai konstanta tidak dapat diubah oleh tugas baru, juga tidak dapat didefinisikan ulang.  Saat mendeklarasikan variabel dengan kata kunci const, Anda harus menggunakan operator penugasan untuk menetapkan nilai konstanta. <br><br>  Konstanta global tidak menjadi properti objek jendela, tidak seperti variabel var. <br>  Diperlukan inisialisasi konstanta. <br>  Anda harus menentukan nilai pada saat yang sama dengan deklarasi (intinya adalah bahwa nilai ini tidak lagi dapat diubah). <br>  Mendeklarasikan variabel dengan kata kunci const menciptakan konstanta (referensi bernama baru ke wilayah memori) yang hanya baca. <br>  Ini tidak berarti bahwa nilai yang ditunjukkan tidak berubah, tetapi itu berarti bahwa pengidentifikasi tidak dapat dipindahkan.  Misalnya, jika sebuah titik konstan ke suatu objek, maka objek itu sendiri dapat dimodifikasi. <br>  Nama konstanta tidak bisa bersamaan dengan nama fungsi atau variabel dengan cakupan yang sama. <cut></cut><br><br>  Contoh perbedaan antara ruang lingkup global dan blok: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">//SyntaxError   a     if if (true) var b = 5; console.log(b); //5   b     }</span></span></code> </pre> <br><br><a name="section003"></a><h2>  Ekspresi fungsi panah </h2><br>  Ekspresi fungsi panah memiliki sintaks yang lebih pendek daripada ekspresi fungsional dan secara leksikal terikat dengan nilai ini (tetapi tidak terikat dengan ini sendiri, argumen, super, atau new.target).  Ekspresi fungsi panah tidak memungkinkan Anda untuk menentukan nama, oleh karena itu fungsi panah bersifat anonim kecuali ditugaskan untuk apa pun. <br><cut></cut><br>  <b>Sintaks dasar</b> <br><pre> <code class="javascript hljs">(param1, param2, â€¦, paramN) =&gt; { statements } (param1, param2, â€¦, paramN) =&gt; expression <span class="hljs-comment"><span class="hljs-comment">// : (param1, param2, â€¦, paramN) =&gt; { return expression; } //       : (singleParam) =&gt; { statements } singleParam =&gt; { statements } //       : () =&gt; { statements } () =&gt; expression // : () =&gt; { return expression; }</span></span></code> </pre> <br><br>  <b>Sintaks yang diperluas</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,     params =&gt; ({foo: bar}) // Rest       (param1, param2, ...rest) =&gt; { statements } (param1 = defaultValue1, param2, â€¦, paramN = defaultValueN) =&gt; { statements } //    var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6</span></span></code> </pre> <br>  Informasi lebih lanjut tentang fungsi panah, dapat Anda temukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><a name="section004"></a><h2>  Untuk ... dari </h2><br>  Untuk ... pernyataan mengeksekusi loop melalui objek iterable (termasuk Array, Map, Set, objek argumen dan sejenisnya), meminta setiap langkah iterasi operator untuk setiap nilai dari berbagai properti objek. <br><cut></cut><br>  Mengapa TIDAK HARUS menggunakan for ... in loop untuk beralih?  Karena tergantung pada mesinnya, JavaScript dapat beralih secara acak, yang dapat menyebabkan hasil yang tidak dapat diprediksi.  Jika properti berubah dalam satu iterasi dan kemudian berubah lagi, nilainya dalam loop adalah nilai terakhirnya.  Properti yang dihapus sebelum siklus mencapai itu tidak akan berpartisipasi di dalamnya.  Properti yang ditambahkan ke objek dalam loop dapat dilewati.  Secara umum, yang terbaik adalah tidak menambahkan, memodifikasi, atau menghapus properti dari objek selama iterasi jika Anda belum melewatinya.  Tidak ada jaminan bahwa properti yang ditambahkan akan dikunjungi oleh siklus, diubah setelah perubahan dilakukan, dan dihapus setelah penghapusan.  Selain itu, variabel iteratif adalah string, bukan angka, yang berarti bahwa jika Anda akan membuat perhitungan dengan variabel, Anda harus menggabungkan string daripada menambahkannya.  Jadi untuk menghindari kesalahan logis, Anda sebaiknya tidak menggunakannya! <br><br>  Tidak seperti for ... dari loop, for ... in loop mengembalikan semua properti yang disebutkan, termasuk yang dengan nama non-integer dan yang diwarisi. <br><br>  <b>Untuk ... dari sintaks loop</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) <span class="hljs-comment"><span class="hljs-comment">//for ( of ) arr[i] = "something value"</span></span></code> </pre> <br>  Contoh: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.objCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.arrCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterable = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]; iterable.foo = <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">// 0, 1, 2, "foo", "arrCustom", "objCustom" for (let i in iterable) { if (iterable.hasOwnProperty(i)) console.log(i); //  0, 1, 2, "foo" } for (let i of iterable) console.log(i); // 3, 5, 7</span></span></code> </pre><cut></cut><br>  Setiap objek akan mewarisi metode objCustom dan setiap Array akan mewarisi metode arrCustom dengan membuat mereka di Object.prototype dan Array.prototype.  Objek iterable akan mewarisi metode objCustom dan arrCustom karena pewarisan prototipe. <br><br>  Loop hanya menampilkan properti enumerasi objek iterable, sesuai urutannya dibuat.  Itu tidak mencetak nilai 3, 5, 7 dan halo karena mereka tidak dapat dihitung.  Nama-nama properti dan metode ditampilkan, misalnya, arrCustom dan objCustom. <br><br>  Loop mirip dengan yang sebelumnya, tetapi menggunakan hasOwnProperty () untuk memeriksa apakah properti objek ini adalah miliknya sendiri atau diwarisi.  Hanya properti sendiri yang ditampilkan.  Nama 0, 1, 2 dan foo hanya milik turunan dari objek (tidak diwarisi).  Metode arrCustom dan objCustom bukan output karena mereka diwarisi. <br><br>  Loop ini mem-bypass iterable dan menampilkan nilai-nilai dari objek iterable yang didefinisikan dalam metode iterating over, mis.  bukan properti objek, tetapi nilai-nilai array 3, 5, 7. <br><br><a name="section005"></a><h2>  Nama properti yang dihitung </h2><br>  Sintaks untuk mendeklarasikan objek dan elemennya mendukung nama properti yang dihitung.  Ini memungkinkan Anda untuk menambahkan ekspresi ke tanda kurung [] yang akan dievaluasi sebagai nama properti.  Itu menyerupai templat literal. <br><br>  <b>Contoh nama yang dihitung:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = { [<span class="hljs-string"><span class="hljs-string">"a"</span></span> + (<span class="hljs-number"><span class="hljs-number">10</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span>)]: { [<span class="hljs-string"><span class="hljs-string">"some"</span></span> + <span class="hljs-string"><span class="hljs-string">"string"</span></span>]: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span>]: <span class="hljs-number"><span class="hljs-number">10</span></span>, [<span class="hljs-string"><span class="hljs-string">`hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a()}</span></span></span><span class="hljs-string">`</span></span>]: a() } }</code> </pre> <br><cut></cut><br><br><a name="section006"></a><h2>  Object.assign () </h2><br>  Metode Object.assign () digunakan untuk menyalin nilai dari semua properti enumerasinya sendiri dari satu atau lebih objek sumber ke objek target.  Setelah menyalin, ia mengembalikan objek target. <br><br>  Metode Object.assign () hanya menyalin properti enumerasi dan asli dari objek sumber ke objek target.  Ia menggunakan metode [[Get]] internal pada objek sumber dan metode [[Set]] internal pada objek target, sehingga ia juga memanggil getter dan setter.  Itulah sebabnya ia memberikan properti alih-alih hanya menyalin atau mendefinisikan properti baru.  Perilaku ini dapat membuat metode tidak cocok untuk menyuntikkan properti baru ke dalam prototipe jika objek sumber yang disuntikkan berisi getter.  Sebagai gantinya, untuk menyalin prototipe definisi properti, termasuk tanda enumerasi mereka, metode Object.getOwnPropertyDescriptor () dan Object.defineProperty () harus digunakan. <br><br>  Properti tipe String dan Simbol disalin. <br><br>  Dalam hal terjadi kesalahan, misalnya, ketika properti tidak dapat ditulisi, pengecualian TypeError dilemparkan, dan objek target tetap tidak berubah. <br><br>  Perhatikan bahwa metode Object.assign () tidak melempar pengecualian jika nilai awal adalah nol atau tidak terdefinisi. <br><br>  <b>Contoh: Mengkloning Objek</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> copy = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(copy); <span class="hljs-comment"><span class="hljs-comment">// { a: 1 }</span></span></code> </pre> <br>  <b>Contoh: Menggabungkan Objek</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o1 = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o2 = { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o3 = { <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(o1, o2, o3); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { a: 1, b: 2, c: 3 } console.log(o1); // { a: 1, b: 2, c: 3 },     .</span></span></code> </pre> <br><br><a name="section007"></a><h2>  Parameter istirahat </h2><br>  Sintaks dari parameter fungsi yang tersisa memungkinkan Anda untuk mewakili sekumpulan argumen tak terbatas dalam bentuk array. <br><br>  Jika argumen fungsi yang disebutkan terakhir memiliki awalan ..., maka secara otomatis menjadi array dengan elemen dari 0 hingga theArgs.length sesuai dengan jumlah argumen aktual yang diteruskan ke fungsi. <br><br>  <b>Sintaks</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...theArgs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><br>  <b>Contoh menggunakan sintaks dari parameter yang tersisa:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...c</span></span></span><span class="hljs-function">) </span></span>{} name (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,)</code> </pre> <br>  Dalam contoh ini, a = 0 b = 1 c [0] = 2 c [1] = 3 <br>  Jika parameter yang tersisa tidak lulus, maka itu akan menjadi array kosong (tidak seperti parameter biasa, itu tidak akan pernah terdefinisi). <br><br>  Sintaks ini dapat digunakan tidak hanya dalam argumen fungsi, tetapi juga di tempat lain, misalnya, untuk menyalin dan menggabungkan array: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = [ ...a, ...b ]; <span class="hljs-comment"><span class="hljs-comment">// [ 0, 1, 2, 3, 4, 5 ]</span></span></code> </pre> <br><br><a name="section008"></a><h2>  Parameter default </h2><br>  Parameter default memungkinkan Anda untuk mengatur parameter fungsi formal ke nilai default jika fungsi dipanggil tanpa argumen, atau jika parameter secara eksplisit diteruskan tidak terdefinisi. <br><br>  Dalam JavaScript, parameter fungsi yang tidak lulus nilai saat dipanggil mengambil nilai default yang tidak ditentukan.  Namun, dalam beberapa kasus mungkin berguna untuk menetapkan nilai default yang berbeda.  Untuk kasus seperti itu pengaturan default dimaksudkan. <br><br>  Nilai default ditetapkan untuk parameter formal hanya jika, selama panggilan fungsi, nilai untuk parameter ini tidak lulus atau tidak ditentukan secara eksplisit diteruskan. <br><br>  <b>Contoh menggunakan parameter default:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFun()); <span class="hljs-comment"><span class="hljs-comment">// 25</span></span></code> </pre> <cut></cut><br><br><a name="section009"></a><h2>  Penugasan restrukturisasi </h2><br>  Sintaks penugasan merusak dalam ekspresi JavaScript memungkinkan Anda untuk mengambil data dari array atau objek menggunakan sintaksis yang mirip dengan mendeklarasikan array atau literal dalam suatu objek. <br><br>  Pernyataan deklarasi objek atau array menyediakan cara mudah untuk membuat paket data yang homogen.  Saat membuat paket seperti itu, Anda mendapat kesempatan untuk menggunakannya dengan cara apa pun yang memungkinkan.  Anda juga dapat mengembalikannya dalam fungsi. <br><br>  Salah satu cara utama untuk menggunakan penetapan destruktif adalah membaca struktur data dengan satu operator, meskipun Anda dapat menemukan banyak kegunaan lain selain ini. <br><br>  <b>Contoh penugasan destruktif:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, rest; [a, b] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(b); // 2 [a, b, ...rest] = [1, 2, 3, 4, 5]; console.log(a); // 1 console.log(b); // 2 console.log(rest); // [3, 4, 5] ({a, b} = {a:1, b:2}); console.log(a); // 1 console.log(b); // 2</span></span></code> </pre> <br>  Anda dapat melihat lebih banyak contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><a name="section010"></a><h2>  Peta </h2><br>  Peta - Objek yang berisi pasangan nilai kunci dan mempertahankan urutan penyisipan.  Nilai apa pun (baik objek maupun primitif) dapat digunakan sebagai kunci. <br><br>  <b>Contoh:</b> <cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyObj = {}, keyFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, keyString = <span class="hljs-string"><span class="hljs-string">"a string"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   myMap.set(keyString, "value associated with 'a string'"); myMap.set(keyObj, "value associated with keyObj"); myMap.set(keyFunc, "value associated with keyFunc"); myMap.size; // 3 //   myMap.get(keyString); // "value associated with 'a string'" myMap.get(keyObj); // "value associated with keyObj" myMap.get(keyFunc); // "value associated with keyFunc" myMap.get("a string"); // "value associated with 'a string'" //   keyString === 'a string' myMap.get({}); // undefined,   keyObj !== {} myMap.get(function() {}) // undefined,   keyFunc !== function () {}</span></span></code> </pre> <br>  <b>Perbedaan Peta dari Objek:</b> <br><br><ul><li>  Kunci objek adalah Garis dan Simbol, sedangkan nilai apa pun bisa menjadi kunci Peta, termasuk fungsi, objek, dan primitif. </li><li>  Tidak seperti Objek, tombol di Peta diurutkan.  Jadi, selama iterasi Peta, kunci dikembalikan dalam urutan penyisipan. </li><li>  Anda dapat dengan mudah mendapatkan jumlah elemen dalam Peta menggunakan properti ukuran, sedangkan jumlah elemen dalam Objek hanya dapat ditentukan secara manual. </li><li>  Peta adalah objek yang dapat diulang dan dapat diulangi secara langsung, sedangkan Objek membutuhkan penerimaan manual dari daftar kunci dan iterasi mereka. </li><li>  Objek memiliki prototipe dan karenanya memiliki seperangkat kunci standar, yang, jika ceroboh, dapat bersinggungan dengan kunci Anda.  Sejak rilis ES5, ini dapat diubah menggunakan map = Object.create (null). </li><li>  Peta dapat memiliki kinerja yang lebih baik jika sering menambah atau menghapus kunci. </li></ul><cut></cut><br>  <b>Properti dan metode:</b> <br><br><ul><li>  Map.prototype.size - Mengembalikan jumlah pasangan kunci \ nilai pada Peta </li><li>  Map.prototype.set (kunci, nilai) - Menambahkan pasangan kunci lulus \ nilai ke Peta.  Jika kunci yang ditentukan sudah ada, maka akan ditimpa dengan nilai baru. </li><li>  Map.prototype.get (key) - Mengembalikan nilai dari kunci yang dikirimkan.  Jika tidak ada kunci, maka undefined akan kembali </li><li>  Map.prototype.has (kunci) - Mengembalikan nilai true jika kunci yang disahkan ada dan salah jika tidak </li><li>  Map.prototype.delete (key) - Menghapus pasangan kunci \ nilai yang ditentukan dan mengembalikan true.  Mengembalikan nilai false jika kunci tidak ada. </li><li>  Map.prototype.clear () - Menghapus semua pasangan kunci \ nilai dari Peta </li><li>  Map.prototype.keys () - Mengembalikan iterator kunci pada Peta untuk setiap elemen </li><li>  Map.prototype.values â€‹â€‹() - Mengembalikan iterator nilai pada Peta untuk setiap elemen </li><li>  Map.prototype.entries () - Mengembalikan iterator array [kunci, nilai] pada Peta untuk setiap elemen </li></ul><cut></cut><br><br><a name="section011"></a><h2>  Setel </h2><br>  Memungkinkan Anda menyimpan nilai unik dari jenis apa pun, baik primitif maupun jenis objek lainnya. <br><br>  Tetapkan objek mewakili koleksi nilai yang bisa Anda lintasi dalam urutan elemen yang dimasukkan.  Nilai elemen dalam Set dapat hadir hanya dalam satu contoh, yang memastikan keunikannya dalam koleksi Set. <br><br>  Properti dan Metode Instance Set <br><ul><li>  size - Mengembalikan jumlah elemen dalam objek Set. </li><li>  add (value) - Menambahkan elemen baru dengan nilai yang diberikan ke objek Set.  Mengembalikan objek Set. </li><li>  clear () - Menghapus semua elemen dari objek Set. </li><li>  delete (value) - Menghapus elemen yang terkait dengan nilai dan mengembalikan nilai yang memiliki (nilai) sebelumnya akan kembali.  memiliki (nilai) akan mengembalikan false nanti. </li><li>  entri () - Mengembalikan objek Iterator baru yang berisi larik [nilai, nilai] untuk setiap elemen di objek Tetapkan dalam urutan penyisipan.  Ini disimpan mirip dengan objek Peta, sehingga setiap entri memiliki nilai yang sama untuk kunci dan nilainya di sini. </li><li>  forEach (callbackFn [, thisArg]) - Memanggil callbackFn satu kali untuk setiap nilai yang ada di objek Set, dalam urutan penyisipan.  Jika thisArg ditentukan untuk masing-masing, ini akan digunakan sebagai nilai ini untuk setiap panggilan balik. </li><li>  has (value) - Mengembalikan nilai boolean yang mengonfirmasi apakah elemen dengan nilai yang diberikan ada di objek Set atau tidak. </li><li>  values â€‹â€‹() - Mengembalikan objek Iterator baru yang berisi nilai untuk setiap elemen di objek Set dalam urutan penyisipan. </li></ul><br>  <b>Menggunakan Set Object</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mySet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); mySet.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add("some text"); // Set { 1, 5, 'some text' } var o = {a: 1, b: 2}; mySet.add(o); mySet.add({a: 1, b: 2}); //  o    ,      mySet.has(1); // true mySet.has(3); // false, 3     set mySet.has(5); // true mySet.has(Math.sqrt(25)); // true mySet.has("Some Text".toLowerCase()); // true mySet.has(o); // true mySet.size; // 5 mySet.delete(5); //  5  set mySet.has(5); // false, 5   mySet.size; // 4,     console.log(mySet); // Set {1, 'some text', Object {a: 1, b: 2}, Object {a: 1, b: 2}}</span></span></code> </pre> <br>  <b>Set Bypass</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.keys()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.values()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} //(key  value    ) for (let [key, value] of mySet.entries()) console.log(key); //  Set  Array var myArr = Array.from(mySet); // [1, "some text", {"a": 1, "b": 2}] //       HTML  mySet.add(document.body); mySet.has(document.querySelector("body")); // true //   Array  Set   mySet2 = new Set([1,2,3,4]); mySet2.size; // 4 [...mySet2]; // [1,2,3,4] //      var intersection = new Set([...set1].filter(x =&gt; set2.has(x))); //      var difference = new Set([...set1].filter(x =&gt; !set2.has(x))); //   set   forEach mySet.forEach(function(value) { console.log(value); }); // 1 // 2 // 3 // 4</span></span></code> </pre> <br><cut></cut><br><br><a name="section012"></a><h2>  Kelas </h2><br>  Kelas-kelas dalam JavaScript diperkenalkan dalam ECMAScript 2015 dan merupakan sintaksis gula atas pewarisan prototipe dalam JavaScript.  Sintaks kelas tidak memperkenalkan model berorientasi objek baru, tetapi menyediakan cara yang lebih sederhana dan lebih intuitif untuk membuat objek dan mengatur warisan. <br><br>  Kelas sebenarnya "fungsi khusus", jadi sama seperti Anda mendefinisikan fungsi (ekspresi fungsi dan deklarasi fungsi), Anda dapat mendefinisikan kelas dengan: deklarasi kelas dan ekspresi kelas. <br><br>  Perbedaan antara deklarasi fungsi dan deklarasi kelas adalah bahwa deklarasi fungsi diangkat, sedangkan deklarasi kelas tidak.  Oleh karena itu, Anda harus mendeklarasikan kelas Anda dan baru kemudian bekerja dengannya, jika tidak pengecualian dari ReferenceError akan dibuang. <br><cut></cut><br><h4>  Deklarasi kelas </h4><br>  Cara pertama untuk mendefinisikan kelas adalah dengan deklarasi kelas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk melakukan ini, gunakan kata kunci kelas dan tentukan nama kelas (dalam contoh, "myClass"). </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myClass</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(height, width) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; } }</code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara kedua untuk mendefinisikan kelas adalah ekspresi kelas. </font><font style="vertical-align: inherit;">Anda dapat membuat ekspresi bernama dan tanpa nama. </font><font style="vertical-align: inherit;">Dalam kasus pertama, nama ekspresi kelas berada dalam cakupan lokal kelas dan dapat diperoleh melalui properti kelas itu sendiri, dan bukan turunannya.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  var myClass = class { constructor(height, width) { this.height = height; this.width = width; } }; //  var myClass = class myClass { constructor(height, width) { this.height = height; this.width = width; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ekspresi kelas tunduk pada masalah mengangkat yang sama dengan deklarasi kelas! </font></font><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Badan deklarasi kelas dan ekspresi kelas dieksekusi dalam mode ketat. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode ketat mengubah sintaks dan perilaku runtime. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar lebih tepat, mode ketat ditandai dengan yang berikut:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konversi kesalahan menjadi pengecualian </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perubahan yang menyederhanakan perhitungan variabel dalam kasus tertentu menggunakan namanya; </font></font></li><li> ,  eval  arguments; </li><li> ,   Â«Â» JavaScript; </li></ul><br> <b>   </b> <br><ol><li>        . </li><li>     . </li><li> ,      ,  . </li><li>        (           ). </li><li>  ,    ,     .       ,      . </li><li>         .             . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sintaksis sistem angka oktal dilarang. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyetel properti dengan nilai primitif dilarang. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyederhanaan pekerjaan dengan variabel</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mode ketat menyederhanakan perbandingan nama variabel dengan tempat definisi dalam kode.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dilarang menggunakan dengan. </font><font style="vertical-align: inherit;">Masalahnya dengan saat runtime, nama apa pun di dalam blok dapat merujuk ke properti objek yang sedang diproses atau variabel dalam konteks sekitarnya (atau bahkan global) - tidak mungkin untuk mengetahui hal ini sebelumnya. </font><font style="vertical-align: inherit;">Alternatif sederhana dengan yang sudah ada - menugaskan objek ke variabel dengan nama pendek dan kemudian mengakses properti yang diinginkan sebagai properti dari variabel ini.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eval () dalam mode ketat tidak menambahkan variabel baru ke konteks sekitarnya. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dilarang menghapus nama-nama sederhana. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyederhanaan eval dan argumen</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mode ketat mengurangi jumlah keanehan dalam perilaku argumen dan eval, yang keduanya mencampur sejumlah sihir ke dalam kode reguler. </font><font style="vertical-align: inherit;">Jadi eval menambah atau menghapus variabel dan mengubah nilainya, dan variabel argumen dapat mengejutkan Anda dengan properti yang diindeks, yang merupakan referensi (sinonim) untuk argumen fungsi bernama.</font></font><cut></cut><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Argumen dan argumen kata kunci tidak dapat diganti atau dimodifikasi. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bidang objek argumen tidak terkait dengan argumen fungsi yang disebutkan, tetapi merupakan duplikat nilai mereka. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti arguments.callee tidak didukung. </font><font style="vertical-align: inherit;">Dalam kode reguler, properti arguments.callee merujuk ke fungsi itu sendiri, untuk permohonan objek argumen yang dibuat.</font></font></li></ol><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript "Aman"</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa situs web memberi pengguna kemampuan untuk menulis JavaScript yang akan dieksekusi di situs atas nama pengguna lain. </font><font style="vertical-align: inherit;">Di browser, JavaScript mungkin memiliki akses ke informasi pribadi, yang merupakan lubang keamanan dalam JavaScript.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nilai diteruskan ke fungsi karena ini tidak dilemparkan ke objek dalam mode ketat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak mungkin untuk "menjalankan" tumpukan JavaScript melalui ekstensi ECMAScript dasar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam fungsi, properti argumen tidak lagi menyediakan akses ke variabel yang dibuat di dalam fungsi. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spesifikasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ECMAScript 5.1 untuk mempelajari lebih lanjut tentang mode Ketat. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan juga </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari Mozilla.</font></font><br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstruktor </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> konstruktor adalah metode khusus yang digunakan untuk membuat dan menginisialisasi objek yang dibuat menggunakan kelas. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">'Robert'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.name); <span class="hljs-comment"><span class="hljs-comment">// Outputs 'Robert'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat membuat objek baru dari kelas, konstruktor () akan diluncurkan, yang diperlukan untuk menginisialisasi objek. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya ada satu metode dalam kelas yang disebut konstruktor. </font><font style="vertical-align: inherit;">Jika kelas berisi lebih dari satu konstruktor, pengecualian SyntaxError akan dibuang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata kunci super dapat digunakan dalam konstruktor untuk memanggil konstruktor dari kelas induk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tidak mendefinisikan metode konstruktor, maka konstruktor default akan digunakan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk kelas dasar, konstruktor default adalah:</font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk kelas turunan, konstruktor default adalah: </font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(...args) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(...args); }</code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Metode </font></font></h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaks deklarasi metode:</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { property([parameters]) {}, get property() {}, set property(value) {}, * generator() {} };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singkatan dari Metode Generator</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { * g() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> index++; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = obj.g(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(it.next().value); // 1</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua definisi metode kecuali metode generator tidak dapat menjadi konstruktor dan akan menghasilkan TypeError jika Anda mencoba untuk instantiate. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nama Properti yang Dihitung</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { [<span class="hljs-string"><span class="hljs-string">"foo"</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>](){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.foo2()); <span class="hljs-comment"><span class="hljs-comment">// 2 };</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata kunci statis mendefinisikan metode statis untuk suatu kelas. </font><font style="vertical-align: inherit;">Metode statis dipanggil tanpa membuat instance kelas mereka, dan tidak dapat dipanggil pada instance kelas.</font></font><br><cut></cut><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaks getter dan setter</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } get Name() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } set Name(newName) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(newName) != <span class="hljs-string"><span class="hljs-string">"string"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Name is not a string!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; <span class="hljs-comment"><span class="hljs-comment">// Robert } } var robert = new Student('robert'); robert.Name = "Robert"; console.log(robert.Name);</span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setter - Diperlukan untuk validasi parameter tertulis (seperti pada contoh di atas) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter - Diperlukan untuk mendapatkan properti (meskipun mereka dapat diperoleh secara langsung). </font><font style="vertical-align: inherit;">Tidak dapat memiliki argumen</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak ada enkapsulasi bawaan di ES6, tetapi Anda dapat mengaturnya sendiri. </font></font> Misalnya, seperti ini: <br><cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Student = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> privateProps = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name, Age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-comment"><span class="hljs-comment">// public privateProps.set(this, {age: Age}); // private } get Age() { return privateProps.get(this).age; } set Age (newAge) { privateProps.set(this, {age: newAge}); } } return Person; })(); var robert = new Student('Robert', 19); robert.Age = 20; console.log(robert.Age); // 20</span></span></code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warisan </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kata kunci extends digunakan dalam deklarasi kelas dan ekspresi kelas untuk membuat kelas yang merupakan anak dari kelas lain. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } sayAge () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (name, age) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(age); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } sayFull () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello my name is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.sayAge()}</span></span></span><span class="hljs-string"> years old`</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">"Robert"</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.sayFull()); <span class="hljs-comment"><span class="hljs-comment">// Hello my name is Robert and I'm 19 years old</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di konstruktor, kata kunci super () digunakan sebagai fungsi yang memanggil konstruktor induk. </font><font style="vertical-align: inherit;">Itu harus dipanggil sebelum panggilan pertama ke kata kunci ini di badan konstruktor. </font><font style="vertical-align: inherit;">Kata kunci super juga dapat digunakan untuk memanggil fungsi objek induk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika Anda mengganti metode kelas induk di kelas anak, metode kelas anak akan dipanggil secara default, tetapi Anda dapat secara eksplisit memanggil metode kelas induk menggunakan fungsi super ().</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } displayName(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name.length; } } <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); } displayName() { <span class="hljs-comment"><span class="hljs-comment">//     return [this.name, super.displayName()]; } } var Obj = new obj_2("obj_2"); console.log(Obj.displayName()); // Array [ "obj_2", 5 ]</span></span></code> </pre><cut></cut><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memperluas objek inline dengan extends</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contoh ini memperluas objek Date inline.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myDate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } getFormattedDate() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'Jan'</span></span>, <span class="hljs-string"><span class="hljs-string">'Feb'</span></span>, <span class="hljs-string"><span class="hljs-string">'Mar'</span></span>, <span class="hljs-string"><span class="hljs-string">'Apr'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jun'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jul'</span></span>, <span class="hljs-string"><span class="hljs-string">'Aug'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sep'</span></span>, <span class="hljs-string"><span class="hljs-string">'Oct'</span></span>, <span class="hljs-string"><span class="hljs-string">'Nov'</span></span>, <span class="hljs-string"><span class="hljs-string">'Dec'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDate() + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + months[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMonth()] + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getFullYear(); } }</code> </pre> <br><br><a name="section013"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Janji </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek Janji digunakan untuk perhitungan yang ditangguhkan dan tidak sinkron. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Janji bisa di tiga negara:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tertunda: keadaan awal, tidak selesai dan tidak ditolak. </font></font></li><li>  (fulfilled):   . </li><li>  (rejected):    . </li></ul><br>       (pending),      (fulfilled),    (),   (rejected),   .       ,     then. (         ,     , ..           Â« Â», , ,      DOM.) <br><br>    Promise.prototype.then()  Promise.prototype.catch()   ,    ,  . <br><img src="https://habrastorage.org/getpro/habr/post_images/835/119/a5c/835119a5c72db92a1ae89730a7af1251.png" alt="gambar"><br><br> <b>  (promise)</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek Janji dibuat menggunakan kata kunci baru dan konstruktornya. </font><font style="vertical-align: inherit;">Konstruktor Janji mengambil argumen yang disebut fungsi pelaksana sebagai argumen. </font><font style="vertical-align: inherit;">Fungsi ini harus menerima dua fungsi panggilan balik sebagai parameter. </font><font style="vertical-align: inherit;">Yang pertama (tekad) dipanggil ketika operasi asinkron selesai dengan sukses dan mengembalikan hasil eksekusi sebagai nilai. </font><font style="vertical-align: inherit;">Callback kedua (tolak) dipanggil ketika operasi gagal, dan mengembalikan nilai yang menunjukkan alasan kegagalan, paling sering objek kesalahan.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    : resolve(someValue); //   //  reject("failure reason"); //  });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek fungsi dengan dua argumen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyelesaikan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menolak,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyebabkan janji untuk berhasil, yang kedua menolaknya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menyediakan fungsi dengan fungsionalitas janji, Anda hanya perlu mengembalikan objek Janji di dalamnya.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAsyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url); xhr.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(xhr.responseText); xhr.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> reject(xhr.statusText); xhr.send(); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan. </font><font style="vertical-align: inherit;">kemudian penangan eksekusi dan penolakan dilampirkan.</font></font><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.all (iterable) - Menunggu semua janji untuk dieksekusi atau ditolak untuk salah satu dari mereka. </font><font style="vertical-align: inherit;">Mengembalikan janji yang akan dieksekusi setelah semua janji dieksekusi di iterable. </font><font style="vertical-align: inherit;">Jika ada janji yang ditolak, Janji. Semua juga akan ditolak.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.allSettled (iterable) - Menunggu untuk menyelesaikan semua janji yang diterima (baik eksekusi dan penolakan). </font><font style="vertical-align: inherit;">Mengembalikan janji yang dieksekusi ketika semua janji yang diterima selesai (dieksekusi atau ditolak), yang berisi berbagai hasil eksekusi dari janji yang diterima.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.race (iterable) - Menunggu eksekusi atau penolakan terhadap janji yang diterima. </font><font style="vertical-align: inherit;">Mengembalikan janji yang akan dieksekusi atau ditolak dengan hasil pelaksanaan janji yang dieksekusi atau ditolak pertama dari .iterable.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.reject (reason) - Mengembalikan janji yang ditolak karena alasan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.resolve (value) - Mengembalikan janji yang dieksekusi dengan nilai hasil. </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prototipe janji</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> catch (onRejected) - Menambahkan fungsi callback untuk menangani penolakan janji, yang mengembalikan janji baru yang dibuat dengan nilai yang diteruskan jika dipanggil, atau nilai penyelesaian asli jika janji itu dibuat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then (onFulfilled, onRejected) - Menambahkan pemenuhan janji dan penangan penolakan, dan mengembalikan janji baru yang dieksekusi dengan nilai penangan yang disebut, atau nilai asli jika janji tidak diproses (mis. jika penangan onFulfilled atau onRejected yang bersangkutan bukan fungsi). </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat permintaan http asinkron: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> URL = <span class="hljs-string"><span class="hljs-string">"https://getfestivo.com/v1/holidays?api_key=f8f42551-eb66-49d2-bcba-b8e42727ddfb&amp;country=US&amp;year=2019"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  API      function asyncHttpRequest (url) { return new Promise((resolve, reject) =&gt; { //  promise if (url == undefined) //     url reject(new Error("Expected url and received nothing")); else { resolve(() =&gt; { fetch(url).then((response) =&gt; { //   return response.json(); //    JSON   }).then((myJson) =&gt; { return(console.log(myJson)); //      }); }); } } );} asyncHttpRequest(URL).then((result) =&gt; result(), (error) =&gt; console.log(error));</span></span></code> </pre> <br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda bisa mendapatkan lebih banyak contoh dan informasi tentang janji di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><font style="vertical-align: inherit;">, serta di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mozilla </font><font style="vertical-align: inherit;">.</font></font><br><br><a name="section014"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iterator </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memproses setiap item dalam koleksi adalah operasi yang sangat umum. JavaScript menyediakan beberapa cara untuk beralih pada koleksi, dari yang sederhana untuk loop ke map (), filter (), dan pemahaman array. Iterator dan generator mengimplementasikan konsep enumerasi langsung ke inti bahasa dan menyediakan mekanisme untuk mengatur perilaku untuk ... loop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek adalah iterator jika dapat mengakses elemen koleksi satu per satu, sambil melacak posisinya saat ini dalam urutan ini. Dalam JavaScript, iterator adalah objek yang menyediakan metode next () yang mengembalikan elemen berikutnya dari suatu urutan. Metode ini mengembalikan objek dengan dua properti: selesai dan nilai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah dibuat, objek iterator dapat digunakan secara eksplisit dengan memanggil metode next ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterable - Ini adalah objek yang isinya dapat dilingkarkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek iterable berbeda dari yang tidak iterable karena memiliki metode khusus yang mengembalikan objek untuk akses ke mana simbol khusus digunakan: Symbol.iterator</font></font><br><pre> <code class="javascript hljs">Iterable { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek yang mengembalikan metode ini secara resmi disebut iterator. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator hanya memiliki satu metode next ()</font></font><br><pre> <code class="javascript hljs">Iterator { next(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yang mengembalikan objek (sebut saja itreratorResult) dengan dua properti selesai dan nilai </font></font><br><pre> <code class="javascript hljs">IteratorResult { done, value }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selesai menunjukkan apakah masih ada nilai dalam urutan yang dicari, dan nilai berisi elemen berikutnya dari urutan. </font></font><br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah inisialisasi, metode next () dapat dipanggil untuk mengakses pasangan kunci-nilai pada objek satu per satu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek iterable jika mendefinisikan metode untuk menghitung nilai, yaitu, misalnya, bagaimana nilai dihitung dalam for..of konstruksi. </font><font style="vertical-align: inherit;">Beberapa tipe bawaan, seperti Array atau Map, dapat diubah secara default, sedangkan tipe lainnya, seperti Object, tidak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar dapat diulang, suatu objek harus mengimplementasikan metode iterator, yang berarti bahwa itu (atau salah satu objek dalam rantai prototipe) harus memiliki properti yang disebut Symbol.iterator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti inilah tampilan iterator standar:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nextIndex &lt; array.length ? { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: array[nextIndex++], <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } : { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; } } }</code> </pre> <br><br><a name="section015"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generator </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator adalah jenis fungsi khusus yang berfungsi seperti pabrik iterator. </font><font style="vertical-align: inherit;">Suatu fungsi menjadi generator jika mengandung satu atau lebih pernyataan hasil dan menggunakan sintaks fungsi *.</font></font><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator adalah jenis fungsi baru yang dapat menjeda eksekusi dan mengembalikan hasil antara dan melanjutkan eksekusi nanti. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat fungsi reguler yang menghitung dan mengembalikan hasilnya:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 9</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang lihat fungsi generator yang serupa: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = generator(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 10 console.log(it.next().value); // 9&lt;/i&gt;</span></span></code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang dinyatakan sebelumnya, generator dapat menjeda eksekusi dan mengembalikan hasil antara. Contoh ini menunjukkan bahwa pada saat panggilan pertama, fungsinya seolah-olah menunda eksekusi pada breakpoint pertama dan mengembalikan hasil dari ekspresi pertama. Dalam panggilan kedua, fungsi berlanjut dari breakpoint sebelumnya dan bergerak ke yang berikutnya, mengembalikan hasil dari ekspresi berikutnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Function generator menyediakan alat yang ampuh untuk menulis fungsi berurutan yang kompleks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator menghitung hasil dari ekspresi hasil sesuai permintaan, yang memungkinkan mereka untuk bekerja secara efisien dengan urutan dengan kompleksitas komputasi yang tinggi, atau bahkan urutan tanpa batas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode () selanjutnya juga mengambil nilai yang dapat digunakan untuk mengubah keadaan internal generator. Nilai yang diteruskan ke next () akan dianggap sebagai hasil dari ekspresi hasil terakhir yang menjeda generator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda bisa memaksa generator untuk melempar eksepsi dengan memanggil metode throw () dan meneruskan nilai eksepsi yang harus dilemparkan sebagai parameter. Pengecualian ini akan dilempar dari konteks jeda generator saat ini seolah-olah pernyataan hasil jeda saat ini adalah pernyataan melempar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika pernyataan hasil tidak terjadi selama pemrosesan pengecualian yang dilemparkan, maka pengecualian dilewatkan di atas melalui panggilan throw (), dan hasil dari panggilan berikutnya ke next () akan dilakukan properti yang sama dengan true.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generator memiliki metode pengembalian (nilai) yang mengembalikan nilai yang diberikan dan menghentikan generator. </font></font><br><br><a name="section016"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simbol </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simbol adalah tipe data primitif yang instansinya unik dan tidak dapat diubah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam runtime JavaScript, nilai "simbol" dibuat dengan memanggil fungsi Symbol (), yang secara dinamis menciptakan nilai anonim dan unik. </font><font style="vertical-align: inherit;">Satu-satunya penggunaan yang masuk akal adalah untuk menyimpan karakter, dan kemudian menggunakan nilai yang disimpan untuk membuat properti objek.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika karakter digunakan sebagai pengidentifikasi dalam tugas properti, properti (misalnya, karakter) adalah anonim; </font><font style="vertical-align: inherit;">dan juga tidak terhitung. </font><font style="vertical-align: inherit;">Karena properti tidak dapat dihitung, properti tidak akan ditampilkan dalam loop "for (... in ...)", dan karena properti tersebut anonim, properti tidak akan ditampilkan di larik hasil "Object.getOwnPropertyNames ()". </font><font style="vertical-align: inherit;">Akses ke properti ini dapat diperoleh dengan menggunakan nilai awal dari simbol yang membuatnya, atau dengan mengulangi melalui larik hasil "Object.getOwnPropertySymbols ()".</font></font><br><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jadi, Anda dapat membuat properti karakter: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"password"</span></span>)]: <span class="hljs-string"><span class="hljs-string">"12hsK3I"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan larik objek karakter, gunakan properti Object.getOwnPropertySymbols (obj); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengakses di mana saja dalam kode Anda, gunakan metode Symbol.for () dan Symbol.keyFor (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk informasi lebih lanjut tentang tipe data Sumbol, lihat di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><font style="vertical-align: inherit;">, dan juga di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mozilla.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460741/">https://habr.com/ru/post/id460741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460729/index.html">Menyenangkan dan bermanfaat dalam mengajar</a></li>
<li><a href="../id460731/index.html">Otoritas A.S. menyelesaikan penyelidikan tentang kecelakaan bus robot pada tahun 2017</a></li>
<li><a href="../id460735/index.html">CI \ CD untuk startup: alat apa yang ada di sana dan mengapa tidak hanya perusahaan besar dan terkenal yang menggunakannya</a></li>
<li><a href="../id460737/index.html">Dengarkan Latar Belakang: Podcast Manajemen Proyek</a></li>
<li><a href="../id460739/index.html">Kami datang dengan damai dari seluruh umat manusia</a></li>
<li><a href="../id460743/index.html">Panduan Pemula Bergetar</a></li>
<li><a href="../id460745/index.html">Pengalaman dalam menggunakan modul GSM di otomatisasi rumah</a></li>
<li><a href="../id460747/index.html">Mencari keuntungan atau mengencangkan kacang: Spotify telah berhenti bekerja dengan penulis secara langsung - apa artinya</a></li>
<li><a href="../id460751/index.html">Bagaimana kami meluncurkan robot dalam Chernobyl kecil. Bagian 1</a></li>
<li><a href="../id460755/index.html">ROS Trolley Robot - Bagian 1: Besi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>