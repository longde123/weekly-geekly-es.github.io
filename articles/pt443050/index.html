<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíç üë®üèæ‚Äç‚öïÔ∏è üï¥üèæ A explica√ß√£o mais simples de como os algoritmos de criptografia sim√©trica funcionam hoje ‚ú¥Ô∏è ü§πüèª üßöüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(Encontrei um t√≥pico no Twitter com uma explica√ß√£o muito legal das cifras sim√©tricas. Foi escrito por Colm MacC√°rthaigh, um dos principais colaborador...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A explica√ß√£o mais simples de como os algoritmos de criptografia sim√©trica funcionam hoje</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443050/"><p>  <em>(Encontrei um t√≥pico no Twitter com uma explica√ß√£o muito legal das cifras sim√©tricas. Foi escrito por Colm MacC√°rthaigh, um dos principais colaboradores do Apache. Pedi permiss√£o a Colm para traduzir, ele concordou gentilmente).</em> </p><br><p>  Vou explicar em linguagem simples o que acontece quando os dados s√£o criptografados.  Espero que sem o misticismo e as coisas complexas que foram inventadas pelos cript√≥grafos. </p><br><p>  Portanto, a criptografia sim√©trica √© exatamente o que usamos na maioria dos casos quando queremos criptografar um monte de dados.  Seu navegador envia e recebe dados usando criptografia sim√©trica.  Se voc√™ criptografar arquivos ou um disco, a criptografia sim√©trica tamb√©m funcionar√° nesse caso.  iMessage, Signal, WhatsApp - todos eles usam criptografia sim√©trica para a seguran√ßa da sua correspond√™ncia. </p><br><p> Se voc√™ acha que, ao criptografar os dados, eles s√£o misturados para que ningu√©m possa l√™-los sem uma chave, da maneira que realmente acontece. </p><br><p>  Aqui est√° um exemplo simples.  Suponha que eu tenha uma string Ovaltine e queira criptograf√°-la.  Eu poderia usar rot13 - a cifra muito simples da velha escola de C√©sar, que faz uma dan√ßa redonda das letras em que a e z d√£o as m√£os e substitui cada letra por outra letra do alfabeto, com 13 caracteres da letra substitu√≠da.  Assim, "O" se transforma em "B" e "v" se torna "i", como resultado, "Ovaltine" se transforma em "Binygvar".  Claro, isso n√£o √© muito seguro.  Este √© um exemplo ing√™nuo, f√°cil de quebrar, pois o invasor pode descobrir qual letra √© mais frequentemente encontrada (geralmente no texto original √© "e") e encontrar as letras restantes dessa maneira. </p><a name="habracut"></a><br><p>  Agora voc√™ pode imaginar que deve haver maneiras mais complicadas de "misturar" as letras.  Por exemplo, algum esquema complexo no qual "a" vai para "p", mas quando re-criptografado, para "f".  Talvez at√© algumas vezes esse esquema comece a criptografar "a" com duas letras, por exemplo, "jd" ou outra coisa.  Portanto, esse esquema complicado pode criptografar "Ovaltine" na string "FGyswDmweeRq" (observe que ele se tornou mais longo).  No passado, surgiram algoritmos de criptografia que funcionavam de maneira semelhante, mas n√£o √© assim que funciona a criptografia moderna. </p><br><p>  Em vez de "embaralhar" as letras, a criptografia moderna pega sua cadeia secreta e as combina artisticamente com dados aleat√≥rios.  Isso √© semelhante ao rot13 apenas em dois aspectos: criptografia e descriptografia s√£o essencialmente a mesma opera√ß√£o e tudo acontece "no lugar".  Na verdade, voc√™ notou que o rot13 √© um algoritmo de criptografia e descriptografia?  rot13 (Ovaltina) -&gt; Binygvar, rot13 (Binygvar) -&gt; Ovaltina.  Eu acredito que essa √© uma simetria muito bonita na criptografia sim√©trica.  Mas voltando ao nosso t√≥pico.  O truque √© que usamos a opera√ß√£o XOR bit a bit.  Em criptografia, l√≥gica formal e c√≥digo, os programas XOR podem ser definidos de maneira diferente, mas usarei uma nota√ß√£o que voc√™ provavelmente conhece.  Parece assim: ^. </p><br><p>  XOR significa "OR exclusivo".  Este √© um operador (ou fun√ß√£o, se voc√™ preferir), que recebe dois argumentos e retorna o resultado.  A ^ B = C. Este operador √© chamado "bit a bit" porque se aplica aos bits correspondentes um ao outro.  Se A e B s√£o bytes, podemos assumir que A ^ B = C s√£o essencialmente 8 opera√ß√µes diferentes que ocorrem simultaneamente.  ^ compara o primeiro bit A e o primeiro bit B e, em seguida, coloca o resultado no primeiro bit C. Ele repete as mesmas 7 vezes mais para os bits restantes.  As regras s√£o simples: se o bit de A for "1" OU o bit de B for "1", definiremos o bit C correspondente como "1", mas apenas se "A" e "B" n√£o forem "1" ao mesmo tempo.  Esta √© a parte exclusiva.  Aqui est√° uma tabela de verdade da velha escola: </p><br><pre><code class="plaintext hljs">A|B|C 0|0|0 1|0|1 0|1|1 1|1|0</code> </pre> <br><p>  O mais legal do XOR √© que ele se parece com rot13.  Podemos us√°-lo para criptografia e descriptografia.  Vou mostrar isso com um exemplo simples.  Vamos imaginar que queremos criptografar o n√∫mero usual "3" e que nossa chave de criptografia √© outro n√∫mero "7".  Assim, 3 ^ 7 = 4. Ou seja, o resultado da criptografia √© "4".  Vamos agora decifrar o n√∫mero.  Farei a mesma coisa novamente: 4 ^ 7 = 3. Pegue qualquer n√∫mero que desejar ou qualquer dado, e ele sempre funcionar√° - o XOR sempre poder√° se descriptografar. </p><br><p>  Pouco a pouco - √© assim que realmente criptografamos e descriptografamos dados, n√£o h√° mixagem, apenas XOR-ing.  A parte dif√≠cil √© encontrar dados aos quais podemos aplicar o XOR.  Uma abordagem √© pegar um grande peda√ßo de dados secretos em m√£os e us√°-los como o segundo argumento para o XOR.  Nesse caso, todos os participantes no processo de transmiss√£o de dados criptografados devem usar o mesmo conjunto de dados secretos para criptografia e descriptografia.  E vai funcionar.  √â verdade que existem v√°rios problemas. </p><br><p>  O primeiro problema  Dados secretos devem parecer aleat√≥rios.  Voc√™ n√£o pode receber texto de um livro ou algo assim.  Quaisquer padr√µes aparecer√£o nos dados criptografados.  Foi exatamente isso que tornou as for√ßas aliadas superiores na Segunda Guerra Mundial. </p><br><p>  O segundo problema.  Voc√™ n√£o pode reutilizar dados confidenciais, pois os padr√µes reaparecem.  Portanto, voc√™ precisa fornecer grandes quantidades de dados secretos para todos que precisam, como o One-time pad.  Isso √© muito dif√≠cil. </p><br><p>  Na criptografia moderna, "geramos" os dados secretos necess√°rios a partir de pequenas chaves.  Essas chaves s√£o muito mais f√°ceis de transportar e proteger.  Isto √© o que realmente s√£o os algoritmos de criptografia sim√©trica - esquemas para a gera√ß√£o determin√≠stica de dados aleat√≥rios a partir de uma chave.  A parte sobre ‚Äúdeterminismo‚Äù √© muito importante: duas pessoas com a mesma chave devem gerar absolutamente o mesmo conjunto de dados, caso contr√°rio, elas n√£o ser√£o capazes de se entender.  Voc√™ provavelmente j√° ouviu falar sobre esses algoritmos: AES, 3DES, DES, RC4, ChaCha20.  Todos fazem isso. </p><br><p>  Acontece que o problema matem√°tico de gerar um fluxo de dados aleat√≥rio (no qual n√£o h√° padr√µes de qualquer forma previs√≠vel) usando a chave √© muito dif√≠cil.  Nesta lista, apenas o AES e o ChaCha20 s√£o considerados seguros hoje.  Outros algoritmos foram invadidos: as pessoas foram capazes de prever.  Al√©m disso, a AES tem uma reputa√ß√£o um pouco manchada, porque os criptografadores dizem o seguinte: </p><br><blockquote>  O AES √© o principal e mais analisado algoritmo de criptografia.  Absolutamente Gold Standard!  : dark_sunglasses: </blockquote><p>  Mas, ao mesmo tempo, eles adicionam: </p><br><blockquote>  As implementa√ß√µes de AES no software (n√£o no hardware) s√£o inseguras ou lentas, e √†s vezes n√£o s√£o seguras e lentas.  Ele n√£o foi projetado levando em considera√ß√£o o fato de poder ser hackeado usando a an√°lise de cache.  : facepalm: </blockquote><p>  N√£o tenha muito medo se isso n√£o estiver claro para voc√™.  A id√©ia principal √© a seguinte: o AES √© maravilhoso do ponto de vista da matem√°tica, mas √© muito complicado na implementa√ß√£o de software.  Mas n√£o se preocupe - quase sempre temos suporte AES no n√≠vel do hardware (uma lista de todos os processadores com suporte ao hardware AES pode ser encontrada aqui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://en.wikipedia.org/wiki/AES_instruction_set</a> , - nota do tradutor). </p><br><p>  Seja como for, continuamos ... Como esses algoritmos realmente funcionam?  Como podemos pegar uma chave e gerar com seguran√ßa um fluxo de dados aleat√≥rio?  Vou simplificar um pouco as coisas aqui e come√ßar com blocos. </p><br><p>  Esses algoritmos recebem tr√™s par√¢metros na entrada e fornecem o texto cifrado na sa√≠da.  Par√¢metros de entrada - uma chave, texto criptografado e ... surpresa - algo estranho chamado "vetor de inicializa√ß√£o" (vetor de inicializa√ß√£o, IV). </p><br><pre> <code class="plaintext hljs">AES(key, IV, plaintext) -&gt; encrypted_data.</code> </pre> <br><p>  A chave e o IV s√£o combinados entre si para criar um conjunto de "condi√ß√µes iniciais" para o algoritmo;  isso √© semelhante √† troca ou embaralhamento inicial de pe√ßas em um jogo de Scrabble.  A mesma combina√ß√£o de chave e IV sempre criar√° o mesmo conjunto de condi√ß√µes iniciais.  Voc√™ pergunta, por que precisamos de IV ent√£o?  Precisamos de um IV para que possamos criptografar v√°rias mensagens usando a mesma chave.  Sem IV, cada fluxo de dados gerado seria o mesmo, e isso √© ruim.  Isso violaria uma das regras de que falamos anteriormente: n√£o podemos reutilizar os mesmos dados para criptografia.  Ent√£o, precisamos de um IV para misturar o resultado.  Mas, diferentemente da chave IV, ela pode ser p√∫blica. </p><br><p>  Portanto, quando voc√™ criptografa uma mensagem e a envia para algu√©m, tamb√©m pode adicionar: "Ei, aqui est√° o IV que eu usei".  Ainda √© fundamental que n√£o reutilizemos a combina√ß√£o de chave e IV, pois eles nos forneceriam dados aleat√≥rios repetidos.  Existem duas maneiras de atingir essa condi√ß√£o: 1) IV √© um tipo de contador que aumentamos a cada nova mensagem.  2) IV √© gerado aleatoriamente, embora tenha um valor bastante grande, portanto, n√£o precisamos nos preocupar muito com colis√µes.  Seja como for, mencionei que vou falar sobre blocos. </p><br><p>  As teclas e IV s√£o "misturadas" ou combinadas de forma a criar um conjunto de condi√ß√µes iniciais ... essas condi√ß√µes s√£o realmente o "bloco" inicial de dados aleat√≥rios.  O comprimento deste bloco √© de 128 bits para AES128, 256 bits para AES256 e 512 bits para ChaCha20.  E aqui se manifesta a verdadeira magia e individualidade de um algoritmo de criptografia espec√≠fico.  De fato, sua ess√™ncia est√° em como a sequ√™ncia de blocos √© gerada e como cada bloco est√° associado aos seus vizinhos.  O relacionamento entre esses bloqueios permanece previs√≠vel, mesmo para quem n√£o possui uma chave. </p><br><p>  N√£o vou me aprofundar em como esses algoritmos funcionam, mas se voc√™ quiser saber mais, recomendo que comece a explorar esse t√≥pico com os geradores congruenciais lineares (LCG).  LCG √© uma fun√ß√£o que cria blocos de dados "circulares" de maneira aleat√≥ria e n√£o repetitiva.  Ent√£o d√™ uma olhada nas redes Feistel, o pr√≥ximo n√≠vel de desenvolvimento de LCG.  Depois lide com as S-Boxes e veja como o Salsa20 cria entrela√ßamento no algoritmo ChaCha20.  Tudo isso √© muito mais acess√≠vel do que voc√™ imagina! </p><br><p>  Portanto, agora sabemos como um fluxo de dados aleat√≥rio pode ser combinado com o texto para criptografar e descriptograf√°-lo, e j√° estamos um pouco no assunto de como esses fluxos de dados aleat√≥rios s√£o criados.  N√£o √© tudo o que precisamos?  Para criptografia de disco, isso √© quase tudo.  Podemos criptografar cada bloco ou setor do armazenamento usando uma chave e IV, que podem ser obtidos a partir da "posi√ß√£o" no disco.  Assim, sempre podemos descriptografar qualquer bloco de dados em qualquer lugar do disco, desde que tenhamos a chave.  Mas h√° um problema ... algu√©m pode arruinar nossos dados criptografados.  Se eu alterar o valor de qualquer byte, mesmo que n√£o possua uma chave, no final n√£o poderemos descriptografar o bloco.  E n√£o h√° prote√ß√£o contra esse tipo de interfer√™ncia.  No caso de enviar mensagens e dados pela rede, isso se torna ainda mais cr√≠tico.  N√£o queremos que ningu√©m estrague nossos dados transmitidos.  Portanto, precisamos adicionar uma verifica√ß√£o de integridade!  Existem v√°rios esquemas para fazer isso. </p><br><p>  HMAC, GCM e Poly1305 s√£o os esquemas de verifica√ß√£o de integridade modernos mais comuns.  Esses algoritmos funcionam basicamente assim: eles s√£o fornecidos com dados e outra chave (a chamada chave de integridade).  Ap√≥s os c√°lculos, eles fornecem o MAC (c√≥digo de autentica√ß√£o de mensagem) ou tag, que por sua vez √© apenas mais um dado que atua como uma assinatura. </p><br><p>  Assim, para criptografia e prote√ß√£o, nosso esquema pode ser assim: </p><br><pre> <code class="plaintext hljs">AES(key, IV, "Ovaltine") -&gt; encrypted_output HMAC(key, encrypted_output) -&gt; MAC</code> </pre> <br><p>  e depois por fio enviamos: </p><br><pre> <code class="plaintext hljs">IV | encrypted_output | MAC</code> </pre> <br><p>  Para descriptografia, verificamos o MAC, gerando-o novamente e comparando o resultado com o MAC recebido e, em seguida, descriptografamos os dados.  Existem diferen√ßas internas na forma como HMAC, GCM e Poly1305 geram essas assinaturas, mas voc√™ n√£o precisa se preocupar com isso.  At√© o momento, essa combina√ß√£o de opera√ß√µes geralmente √© agrupada em uma fun√ß√£o chamada "AEAD" (Criptografia autenticada com dados adicionais).  Sob o cap√¥, ela faz tudo o que eu falei anteriormente: </p><br><pre> <code class="plaintext hljs">AEAD(key, IV, plaintext, additional_data) -&gt; IV_encrypted_data_MAC</code> </pre> <br><p>  Uma parte chamada "dados_ adicionais" s√£o apenas dados com os quais voc√™ pode garantir que a parte remetente possua esses dados, embora n√£o tenham sido enviados a eles.  √â como metadados que definem direitos de acesso.  Geralmente, este campo √© deixado em branco. </p><br><p>  No entanto, voc√™ pode ter problemas com o AEAD se voc√™ usar o mesmo IV.  Isso √© ruim!  Existem tentativas de melhorar essa situa√ß√£o: meu colega, cujo nome √© Shay, est√° trabalhando em um esquema legal de SIV que adiciona uma camada de prote√ß√£o contra esse problema.  Mas se voc√™ usar um IV exclusivo, a criptografia moderna √© muito segura.  Ou seja, voc√™ pode publicar o texto cifrado no New York Times e ningu√©m pode decifr√°-lo.  A cifra permanecer√° inacess√≠vel mesmo se "parte" do texto for conhecida.  Por exemplo, nos protocolos da Internet, uma grande quantidade de texto √© conhecida.  Os servidores HTTP sempre respondem da mesma forma e os primeiros bytes s√£o sempre conhecidos.  Mas esse fato n√£o importa - n√£o ajudar√° o invasor a descobrir uma √∫nica parte dos dados restantes ... Percorremos um longo caminho desde a Segunda Guerra Mundial. </p><br><p>  Mas h√° ataques que funcionam!  Se voc√™ enviar dados por uma rede e algu√©m rastrear a hora e o tamanho das mensagens, os dados criptografados poder√£o ser quebrados usando a an√°lise de tr√°fego. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0f3/159/f21/0f3159f21f88bfaa15fb4e2b7399792c.gif" alt="imagem"></p><br><p>  Vamos descobrir primeiro o comprimento.  Obviamente, o comprimento n√£o √© uma caracter√≠stica oculta.  E isso √© normal se voc√™ estiver tentando proteger sua senha ou n√∫mero do cart√£o de cr√©dito em algum lugar no meio da mensagem.  N√£o √© um grande problema.  Mas isso significa que potencialmente qualquer pessoa pode determinar o tipo de conte√∫do que voc√™ envia.  Um exemplo simples: se voc√™ enviar um gif usando um messenger e se o tamanho dessa imagem for √∫nico, o invasor que interceptar seus dados poder√° sugerir qual GIF acabou de ser enviado.  Existem vers√µes mais complicadas deste ataque para o Google Maps, Netflix, Wikipedia, etc.  Para se proteger contra esse ataque, voc√™ pode "finalizar" as mensagens enviadas com bytes adicionais, para que todas as mensagens enviadas tenham o mesmo tamanho, n√£o importa o qu√™.  A criptografia usada nas redes militares sempre ‚Äúfinaliza‚Äù o tr√°fego com dados adicionais, ou seja, para o interceptador sempre parece o mesmo!  Outro problema associado ao tamanho √© que, se voc√™ usar a compacta√ß√£o e permitir ao invasor alterar qualquer parte do conte√∫do da p√°gina que o usu√°rio v√™, isso permitir√° que o invasor descubra at√© os menores segredos.  Procure um ataque chamado CRIME.  Ela √© linda e assustadora. </p><br><p>  Eu tamb√©m disse que o outro problema √© o tempo.  Obviamente, o hor√°rio de envio de cada mensagem √© uma informa√ß√£o aberta.  Isso pode ser um problema?  Talvez!  Por exemplo, se voc√™ envia uma mensagem sempre que pressiona uma tecla, √© trivial descobrir exatamente o que √© impresso usando a an√°lise de tempo.  Legal!  Outro exemplo √© o VOIP.  Se o seu aplicativo de chamada enviar dados somente quando as pessoas falarem, mas n√£o durante o sil√™ncio, isso ser√° suficiente para restaurar 70% da fala em ingl√™s.  Apenas fora do sil√™ncio.  Legal assustador. </p><br><p>  Estes exemplos s√£o apenas a ponta do iceberg.  Mesmo quando voc√™ usa algoritmos e esquemas de criptografia que v√™m melhorando h√° 80 anos, ainda existem lacunas que podem ser usadas para quebrar a seguran√ßa.  √â por isso que √© valioso saber sobre isso! </p><br><p>  Seja como for, este √© o n√≠vel de explica√ß√£o em que quero me concentrar agora, mas consideramos as coisas mais necess√°rias a saber.  Se voc√™ ler at√© este ponto - obrigado!  Agora voc√™ deve entender melhor o que acontece durante a criptografia e o que observar. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sinta-se livre para fazer perguntas.</a> </p><br><p>  <em>A tradu√ß√£o √© publicada sob licen√ßa CC BY-NC-SA 4.0</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443050/">https://habr.com/ru/post/pt443050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443034/index.html">Novas esta√ß√µes de carregamento da Tesla: carregue a bateria por 120 quil√¥metros em 5 minutos</a></li>
<li><a href="../pt443038/index.html">Se a supercola entrar nos olhos</a></li>
<li><a href="../pt443040/index.html">7 principais raz√µes pelas quais os aplicativos est√£o bloqueados no Google Play e AppStore</a></li>
<li><a href="../pt443042/index.html">Lan√ßamento de 619 mil tetris no GLSL, sua renderiza√ß√£o e um bot simples</a></li>
<li><a href="../pt443046/index.html">Como os pesquisadores de seguran√ßa acessam sites protegidos do c√≥digo iOS</a></li>
<li><a href="../pt443052/index.html">Lindo rel√≥gio preciso de um smartphone antigo</a></li>
<li><a href="../pt443054/index.html">Uma sele√ß√£o de utilit√°rios para um programador no Linux</a></li>
<li><a href="../pt443056/index.html">Segundo paciente com HIV atinge remiss√£o</a></li>
<li><a href="../pt443058/index.html">Arquitetura limpa. Parte I - Introdu√ß√£o</a></li>
<li><a href="../pt443060/index.html">A nave estelar alcan√ßar√° Marte?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>