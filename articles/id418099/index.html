<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤µğŸ½ âšªï¸ ğŸ¥¢ Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 3 ğŸŒï¸ ğŸ—’ï¸ ğŸ§‘ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418099/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: â€œPendahuluan: model ancamanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: â€œBuffer Overflows: Exploits and Protectionâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Anda dapat menggunakan teknik menebak "kenari" untuk tujuan Anda sendiri untuk mengetahui keberadaan "lemah", dalam hal pemilihan, bit.  Artinya, jika Anda menebak dengan benar, server akan melakukan reboot, dan ini akan berfungsi sebagai sinyal bagi Anda bahwa nilai yang ditetapkan cukup mudah ditebak.  Dengan demikian, adalah mungkin untuk mengalahkan "kenari" acak, dengan asumsi bahwa setelah server reboot nilainya tidak akan berubah.  Anda juga dapat menggunakan gadget untuk menerapkan urutan terkait beberapa serangan. <br><br>  Selanjutnya, kita akan melihat cara yang lebih produktif di mana Anda dapat menggunakan semua metode ini untuk mengalahkan pencegahan eksekusi data, ruang alamat acak, dan "kenari". <br><br>  Mari kita mengalihkan perhatian kita ke arsitektur 64-bit alih-alih arsitektur 32-bit.  Yang pertama lebih cocok untuk pengacakan, sehingga mereka memberi Anda lebih banyak "peluang" untuk membela diri terhadap peretas.  Dan sistem ini terlihat jauh lebih menarik dalam hal pembentukan serangan. <br><br>  Arsitektur 64-bit jenis ini juga dipertimbangkan dari sudut pandang <b>BROP</b> , pemrograman â€œblindâ€ yang berorientasi terbalik.  Untuk kesederhanaan, kita mengasumsikan bahwa satu-satunya perbedaan antara mesin 64-bit dan 32-bit adalah bahwa pada mesin 64-bit, argumen diteruskan ke register, dan untuk mesin 32-bit, ke stack. <br><br><img src="https://habrastorage.org/webt/hg/z1/jc/hgz1jcij9zzqbaqc3fiztx1ctze.jpeg"><br><br>  Ketika suatu fungsi mulai dieksekusi, diambil untuk "melihat" ke register tertentu untuk menemukan di mana argumen berada. <br><br>  Sekarang mari kita masuk ke intisari dari kuliah hari ini - apa itu pemrograman berorientasi balik buta, atau <b>BROP</b> .  Hal pertama yang akan kita lakukan adalah menemukan stop gadget.  Ingat bahwa ketika kita mengatakan "gadget," kita pada dasarnya berarti mengembalikan alamat.  Gadget diidentifikasi dengan alamat pengirim, alamat awal dari urutan instruksi yang ingin kami tuju.  Jadi apa itu stop gadget? <br><br>  Pada dasarnya, ini adalah alamat pengirim ke suatu tempat dalam kode, namun, jika Anda melompat di sana, maka cukup jeda programnya, tetapi jangan menyebabkan program mogok.  Itulah mengapa ini disebut stop gadget. <br><br>  Anda bisa melompat ke suatu tempat dalam kode, yang kemudian memulai panggilan sistem tidur, atau berhenti sebentar, atau sesuatu seperti itu.  Ada kemungkinan bahwa program tersebut entah bagaimana akan â€œmacetâ€ dalam satu lingkaran tanpa akhir jika Anda melompat ke tempat ini.  Tidak masalah mengapa berhenti terjadi, tetapi Anda dapat membayangkan beberapa skenario yang akan mengarah ke sana. <br><br>  Apa gunanya gadget berhenti? <br><br>  Segera setelah penyerang berhasil mengalahkan "kenari" menggunakan teknik interaktif menebak bit, ia dapat mulai menulis ulang alamat pengirim ini, <b>alamat ret,</b> dan mulai "meraba-raba" gadget berhenti.  Perhatikan bahwa sebagian besar alamat acak yang dapat Anda tempatkan di tumpukan cenderung menyebabkan server mogok.  Sekali lagi, pesan ini untuk Anda, penyerang, ini merupakan indikasi bahwa apa yang Anda temukan bukanlah gadget yang berhenti.  Karena ketika server mogok, soket Anda ditutup, dan Anda, sebagai penyerang, mengerti bahwa Anda tidak mendapatkan gadget yang berhenti.  Tetapi jika Anda menebak sesuatu dan soket setelah itu tetap terbuka untuk sementara waktu, Anda berpikir: "Ya, saya menemukan stop gadget ini!"  Jadi ide dasar dari langkah pertama adalah menemukan gadget berhenti ini. <br><br><img src="https://habrastorage.org/webt/xb/af/zx/xbafzxirvhgep_31ahp8fuzpey4.jpeg"><br><br>  Langkah kedua adalah Anda ingin menemukan gadget yang menghapus entri tumpukan menggunakan perintah <b>pop</b> .  Oleh karena itu, Anda harus menggunakan urutan instruksi yang dirancang dengan cermat ini untuk mencari tahu kapan Anda mengambil salah satu dari tumpukan gadget ini.  Urutan ini akan terdiri dari <b>alamat probe dari alamat probe</b> , <b>alamat stop dari alamat stop,</b> dan <b>alamat</b> kegagalan sistem <b>dari alamat crash</b> . <br><br>  Dengan demikian, <b>alamat probe</b> adalah apa yang akan kita masukkan ke stack.  Ini akan menjadi alamat gadget potensial untuk menghapus stack, <b>stop address</b> - ini adalah apa yang kami pertimbangkan pada langkah pertama, ini adalah alamat gadget stop.  Kemudian <b>alamat crash</b> hanya akan menjadi alamat kode yang tidak dapat dieksekusi.  Di sini Anda cukup meletakkan alamat nol (0 x 0), dan jika Anda menerapkan fungsi <b>ret</b> ke alamat ini dan mencoba mengeksekusi kode di sana, ini akan menyebabkan crash program. <br><br><img src="https://habrastorage.org/webt/38/fa/ba/38fabavrj2kahtqh0_ruuxiigaa.jpeg"><br><br>  Jadi kita bisa menggunakan jenis alamat ini untuk mencari tahu di mana gadget ini membersihkan <b>tumpukan tumpukan bermunculan</b> . <br><br>  Saya akan memberikan contoh sederhana.  Misalkan kita memiliki dua contoh <b>probe</b> berbeda, trap <b>trap</b> dan <b>trap trap</b> .  Misalkan, dengan bantuan <b>probe,</b> kita akan "menyelidiki" beberapa alamat, misalkan dimulai dengan 4 dan berakhir dengan delapan: 0x4 ... 8, dan di belakangnya adalah alamat berikutnya dari bentuk 0x4 ... C.  Secara hipotesis, kita dapat berasumsi bahwa salah satu dari dua alamat ini adalah alamat gadget <b>popping stack</b> . <br><br>  <b>Perangkap perangkap</b> akan mendapatkan nol alamat 0x0 dan 0x0, dan biarkan gadget <b>berhenti berhenti</b> memiliki alamat acak seperti 0xS ... 0xS ..., itu tidak masalah.  Gadget berhenti ini menunjuk ke kode sleep (10), menyebabkan program berhenti. <br><br>  Mari kita mulai dengan operasi <b>penyelidikan</b> , yang menghapus beberapa register dan kembali dalam urutan berikut: <b>pop rax;</b>  <b>ret</b> .  Apa yang akan terjadi  Ketika sistem melompat ke alamat ini, penunjuk tumpukan akan pindah ke bagian tengah gadget kami.  Apa yang akan dilakukan gadget di sini?  Benar, lakukan operasi <b>pop rax</b> . <br><br><img src="https://habrastorage.org/webt/i2/eu/zr/i2euzrwlujsohfb4dl-szdeasac.jpeg"><br><br>  Dan kemudian ikuti <b>ret</b> , yang akan memindahkan fungsi ke baris teratas gadget, yaitu untuk <b>berhenti</b> , dan fungsi akan berhenti tanpa merusak keseluruhan program.  Jadi, menggunakan gadget ini, penyerang dapat mengatakan bahwa alamat <b>probe</b> milik salah satu fungsi ini, yang membersihkan tumpukan, karena koneksi klien server terbuka. <br><br>  Sekarang mari kita asumsikan bahwa alamat <b>probe</b> kedua menunjuk ke sesuatu seperti <b>xor rax, rax, ret</b> untuk beberapa register. <br><br><img src="https://habrastorage.org/webt/kw/5t/r3/kw5tr3vdtrqedphe0onl6ec-wa0.jpeg"><br><br>  Jadi apa yang terjadi jika kita mencoba beralih ke gadget ini?  Perhatikan bahwa itu tidak menghapus apa pun di stack, itu hanya mengubah isi register.  Jadi, kita akan kembali ke alamat 0x0 yang terletak di atas.  Dan ini akan menyebabkan sistem crash.  Sambungan klien ke server akan terputus, dan peretas akan mengerti bahwa ini bukan gadget untuk menghapus tumpukan <b>stack</b> . <br><br>  Dengan cara ini Anda dapat menggunakan serangkaian jebakan yang lebih aneh dan menghentikan gadget, misalnya Anda dapat menghapus dua item pada tumpukan.  Untuk melakukan ini, Anda hanya perlu menempatkan instruksi <b>jebakan</b> lain di sini, dan jika gadget ini tidak menghapus dua elemen, Anda akan menemukan diri Anda di salah satu perangkap ini, dan kode akan berhenti dijalankan.  Materi kuliah menjelaskan tentang sesuatu yang disebut <b>gadget BROP,</b> yang berguna jika Anda tidak ingin kembali ke pemrograman.  Tapi hari ini saya juga akan memberi tahu Anda bagaimana Anda dapat menggunakan gadget <b>pop</b> sederhana ini untuk meluncurkan serangan serupa.  Setelah Anda memahami hal ini, berurusan dengan <b>gadget BROP</b> akan jauh lebih mudah. <br><br>  Tetapi apakah Anda semua mengerti bagaimana kita dapat menggunakan fungsi <b>penyelidikan</b> untuk gadget ini?  Misalkan Anda menemukan lokasi potongan kode yang memungkinkan Anda untuk menghapus tumpukan dengan fungsi <b>pop</b> , hapus satu elemen dari itu, tetapi Anda tidak benar-benar tahu di mana mendaftar fungsi <b>pop</b> ini akan berfungsi.  Anda baru tahu bahwa dia sudah siap untuk dieksekusi.  Tetapi Anda perlu tahu di mana daftar gadget <b>pop</b> ini akan berfungsi, karena dalam arsitektur 64-bit, register mengontrol di mana argumen fungsi yang ingin Anda panggil berada. <br><br>  Dengan demikian, tujuan kami adalah untuk dapat membuat gadget yang memungkinkan kami menghapus nilai yang kami masukkan ke register tumpukan tertentu, dan pada akhirnya kami memulai pemanggilan <b>sistem panggilan sistem</b> , yang memungkinkan kami melakukan sesuatu yang buruk. <br>  Jadi sekarang kita perlu menentukan register mana yang digunakan oleh gadget <b>pop</b> . <br><br><img src="https://habrastorage.org/webt/xp/w-/hw/xpw-hw9rdgd2argq0yx6xgi3ece.jpeg"><br><br>  Untuk melakukan ini, kita dapat memanfaatkan panggilan sistem jeda.  Jika panggilan sistem dijeda, maka eksekusi program ditangguhkan, dan tidak menerima argumen apa pun.  Dan ini berarti bahwa sistem mengabaikan semua yang ada di register. <br><br>  Bahkan, untuk menemukan instruksi jeda yang sedang kami jalankan, Anda dapat menautkan semua gadget <b>pop</b> ini sehingga kami dapat meletakkan semuanya di tumpukan, dan di antara masing-masingnya kami <b>memasukkan nomor syscall</b> untuk dijeda.  Kemudian kita akan melihat apakah kita dapat "menunda" program dengan cara ini.  Biarkan saya memberi Anda sebuah contoh nyata. <br><br>  Di sini, kami meletakkan gadget di bilah alamat pengirim yang menghapus register <b>RDI</b> dan menerapkan fungsi <b>ret</b> padanya.  Di atasnya kita akan meletakkan <b>nomor syscall</b> untuk dijeda. <br><br>  Misalkan kita memiliki satu lagi gadget yang terletak di atas yang mengimplementasikan fungsi <b>pop</b> di register lain, katakan <b>RSI</b> , lalu <b>ret</b> .  Dan kemudian kita meletakkan <b>nomor syscall</b> lagi untuk berhenti.  Dan kami melakukan ini untuk semua gadget yang kami temukan, dan kemudian kami berakhir di bagian atas tumpukan dengan alamat diduga untuk <b>syscall</b> . <br><br><img src="https://habrastorage.org/webt/qd/yx/3v/qdyx3vymmlc13o-sceyeimho_ro.jpeg"><br><br>  Ingat kembali bagaimana Anda menggunakan panggilan sistem ini.  Anda harus memasukkan <b>nomor syscall</b> di register <b>RAX</b> , kemudian memanggil fungsi <b>syscall libc</b> , yang akan melakukan panggilan sistem yang diminta. <br><br>  Jadi apa yang terjadi ketika kita menjalankan kode ini?  Kami akan datang ke sini, ke baris <b>alamat ret</b> , kami akan melompat ke alamat gadget ini, perlu dicatat bahwa penyerang tahu bahwa gadget ini, terletak di sebelah kanan, menghapus sesuatu dari tumpukan, tetapi belum tahu di mana register itu berada. <br><br>  Jadi, jika kita lompat ke <b>alamat retret</b> , apa yang terjadi?  Dia akan menggunakan fungsi <b>pop</b> untuk menjeda <b>syscall</b> , di beberapa register yang tidak diketahui oleh penyerang, dan kemudian kita akan terus naik rantai operasi ini ke atas tumpukan. <br><br>  Dengan demikian, kami berharap bahwa salah satu gadget ini akan melakukan fungsi <b>pop</b> untuk <b>nomor syscall</b> dalam register <b>RAX yang</b> sesuai.  Jadi pada saat kami tiba di sini, di bagian atas tumpukan, dalam perjalanan "mengacaukan" semua register yang memiliki <b>nomor syscall</b> untuk dijeda, kami berharap bahwa kami masih memiliki satu register, yang seharusnya benar.  Karena jika salah satu gadget kita melakukan ini, dan kemudian, ketika melakukan <b>ret</b> , setelah beberapa saat kita akan kembali ke sini, di bagian atas tumpukan, maka kita akan mendapat jeda.  Sekali lagi, jeda bertindak sebagai sinyal kepada penyerang.  Karena jika anggapan alamat untuk <b>syscall</b> ini salah, maka program akan gagal. <br><br>  Jadi apa yang memungkinkan kita melakukan fase serangan ini?  Kami masih belum tahu di register mana gadget <b>pop</b> berada, tetapi kami tahu bahwa salah satunya akan membebaskan <b>RAX</b> yang ingin kami kontrol.  Dan kita mungkin tahu alamat <b>syscall</b> , karena kami berhasil menjeda sistem. <br><br>  Setelah kami melakukan ini, kami dapat memeriksa gadget ini satu per satu dan mencari tahu mana yang membuat sistem berhenti sementara.  Dengan kata lain, kami memotong segalanya antara baris <b>alamat ret</b> dan bagian atas tumpukan untuk langsung menuju <b>syscall</b> .  Kami akan memeriksa apakah jeda atau kegagalan sistem telah terjadi.  Jika terjadi kegagalan, kami mengidentifikasi gadget yang menyebabkannya, misalnya, ada di baris bawah di sebelah kanan, ini <b>pop rdi</b> .  Singkirkan dia dan coba yang berikutnya.  Letakkan di sini di baris di atas <b>ret alamat alamat</b> asli untuk <b>syscall</b> .  Bisakah kita menghentikan sementara program?  Ya, itu berarti kami mengetahui bahwa gadget populer ini harus membebaskan <b>RAX</b> .  Apakah itu jelas? <br><br>  <b>Hadirin:</b> Jadi, cara untuk menebak alamat untuk pemanggilan sistem hanyalah transfer perangkat secara buta? <br><br>  <b>Profesor:</b> ya, benar, dan ada cara untuk mengoptimalkan proses ini dalam materi kuliah ketika Anda menggunakan ekstensi file <b>PLT</b> dan hal-hal serupa.  Dengan serangan sederhana yang saya jelaskan, Anda benar-benar hanya menempelkan alamat di sini, dan memastikan apakah itu menyebabkan jeda atau tidak.  Sebagai hasil dari pengujian, kami menemukan lokasi <b>syscall</b> .  Kami akan mencari tahu di mana instruksi yang menjalankan <b>pop RAX berada</b> .  Kami juga membutuhkan gadget yang menjalankan <b>pop</b> di beberapa register lain juga.  Anda dapat melakukan tes serupa untuk mereka.  Oleh karena itu, alih-alih menjeda <b>nomor syscall</b> , gunakan <b>push</b> untuk beberapa perintah lain yang, misalnya, menggunakan argumen <b>RAX</b> dan <b>RDI</b> . <br><br>  Dengan demikian, Anda dapat menggunakan fakta bahwa untuk set register tertentu yang ingin Anda kendalikan, ada beberapa jenis <b>syscall</b> yang akan memberi Anda sinyal penyerang untuk mengetahui apakah Anda berhasil memecahkannya atau tidak.  Jadi, pada akhir fase ini, Anda akan memiliki alamat <b>syscall</b> dan alamat tumpukan gadget, yang memungkinkan Anda untuk masuk ke register sewenang-wenang. <br><br>  Dan sekarang mari kita lanjutkan ke langkah ke 4, yang akan disebut <b>menulis</b> - merekam.  Langkah keempat adalah merekam panggilan sistem.  Untuk memanggil <b>write</b> , kita harus memiliki gadget berikut: <br><br>  <b>pop rdi, ret;</b> <b><br></b>  <b>pop rsi, ret;</b> <b><br></b>  <b>pop rdx, ret;</b> <b><br></b>  <b>pop rax, ret;</b> <b><br></b>  <b>syscall</b> <br><br><img src="https://habrastorage.org/webt/kj/1h/ds/kj1hdsjhh1509eliv3vjxte7nw4.jpeg"><br><br>  Bagaimana register ini digunakan oleh system call?  Yang pertama adalah soket, atau, lebih umum, deskriptor file yang akan Anda transfer untuk ditulis.  Yang kedua adalah buffer, yang ketiga adalah panjang buffer ini, yang keempat adalah nomor panggilan sistem dan yang kelima adalah <b>syscall</b> itu sendiri. <br><br>  Jadi, jika kita menemukan semua gadget ini, maka kita dapat mengontrol nilai-nilai yang tertanam dalam argumen, yang, pada gilirannya, ditempatkan di register ini, karena kita hanya "mendorong" mereka ke stack. <br><br>  Apa yang seharusnya menjadi soket?  Di sini kita harus menebak sedikit.  Anda dapat memanfaatkan fakta bahwa Linux membatasi jumlah koneksi terbuka simultan untuk file yang mencapai nilai 2024. Dan juga bahwa itu harus menjadi minimum dari semua yang tersedia. <br><br>  Saya ingin tahu apa yang akan kita masukkan ke buffer pointer?  Itu benar, kami bermaksud menggunakan fragmen teks dari program di sini, kami akan meletakkannya di pointer di suatu tempat dalam kode program.  Ini memungkinkan kita untuk membaca file biner dari memori menggunakan panggilan klien yang benar dari soket.  Kemudian penyerang dapat mengambil file biner ini, menganalisisnya secara offline offline, menggunakan <b>GDB</b> atau alat lain untuk mencari tahu di mana semua ini berada.  Penyerang tahu bahwa sekarang, setiap kali server "crash", set hal-hal acak yang sama akan disimpan di dalamnya.  Jadi sekarang penyerang dapat mengetahui alamat dan penyeimbang untuk isi tumpukan, ia dapat menyerang gadget ini secara langsung.  Ini dapat langsung menyerang kerentanan lain, mencari tahu cara membuka shell dan sejenisnya.  Dengan kata lain, di tempat Anda memberikan biner peretas, Anda dikalahkan. <br><br>  Beginilah cara <b>kerja</b> serangan <b>BROP</b> .  Seperti yang saya katakan, dalam materi kuliah ada banyak cara untuk mengoptimalkan proses ini, tetapi pertama-tama Anda harus memahami materi utama, jika tidak optimasi kehilangan artinya.  Karena itu, Anda dapat berbicara dengan saya tentang pengoptimalan secara individu atau setelah kelas. <br><br>  Untuk saat ini, cukup mengatakan bahwa ini adalah dasar-dasar bagaimana Anda dapat meluncurkan serangan <b>BROP</b> .  Anda harus menemukan <b>stop</b> gadget, menemukan gadget yang menjalankan fungsi entri tumpukan <b>pop</b> , mencari tahu di mana register mereka berada, di mana <b>syscall</b> berada, dan kemudian memulai <b>menulis</b> , berdasarkan informasi yang diperoleh. <br><br><img src="https://habrastorage.org/webt/xb/-q/iq/xb-qiqqwytbciwpbxiow5i_fovi.jpeg"><br><br>  Jadi, cepat membahas topik, bagaimana Anda bertahan melawan <b>BROP</b> ?  Jadi hal yang paling jelas yang Anda miliki adalah pengacakan ulang.  Karena fakta bahwa server yang "jatuh" tidak muncul kembali, jangan membuat versi acak dari diri mereka sendiri, bertindak sebagai sinyal yang memberikan peluang bagi penyerang untuk menguji berbagai hipotesis tentang bagaimana program bekerja. <br><br>  Salah satu cara mudah untuk melindungi diri sendiri adalah memastikan Anda melakukan <b>exec</b> bukan <b>fork</b> saat menghidupkan kembali proses Anda.  Karena ketika Anda menjalankan proses, Anda membuat ruang yang benar-benar baru secara acak, setidaknya itulah yang terjadi di Linux.  Di Linux, ketika Anda mengkompilasi menggunakan <b>PIE</b> , <b>Eksekusi Independen Posisi</b> , executable independen lokasi, ketika Anda menggunakan <b>exec,</b> Anda hanya mendapatkan ruang alamat acak baru. <br><br>  Cara kedua adalah dengan menggunakan Windows, karena OS ini pada dasarnya tidak memiliki fungsi yang setara dengan <b>fork</b> .  Ini berarti bahwa ketika Anda menghidupkan kembali server di Windows, itu akan selalu memiliki ruang alamat acak baru. <br><br>  Seseorang di sini bertanya apa yang akan terjadi jika setelah kerusakan server ia tidak memutuskan?  Jadi, jika selama server crash kita entah bagaimana "menangkap" kesalahan ini dan menjaga koneksi terbuka untuk sementara waktu, kita dapat membingungkan penyerang sehingga dia tidak menerima sinyal tentang kegagalan dan berpikir bahwa dia telah menemukan alamat yang benar. <br><br>  Dalam hal ini, serangan <b>BROP</b> Anda akan berubah menjadi serangan <b>DOS</b> .  Karena Anda baru saja mendapatkan semua proses zombie potensial yang ada di sekitar.  Mereka tidak berguna, tetapi Anda tidak dapat membiarkan mereka melangkah lebih jauh, jika tidak, Anda harus menghapus informasi ini. <br><br>  Hal lain yang mungkin Anda pikirkan adalah melakukan pemeriksaan perbatasan yang kita bicarakan sebelumnya.  Materi perkuliahan mengatakan bahwa metode ini tidak produktif, karena harganya 2 kali lebih mahal, tetapi Anda masih bisa menggunakannya. <br><br>  Beginilah cara kerja <b>BROP</b> .  Sedangkan untuk pekerjaan rumah, pertanyaan yang lebih rumit ditanyakan di sana: bagaimana jika Anda menggunakan hash saat ini?  Artinya, lamanya waktu selama Anda me-restart program.  Apakah ini cukup untuk mencegah serangan seperti ini?  Perhatikan bahwa hashing tidak secara ajaib memberi Anda bit entropi jika data yang Anda masukkan ke hash mudah diprediksi.  Jika hash Anda mengandung miliaran bit, itu tidak masalah.  Tetapi jika Anda hanya memiliki beberapa makna di sana, penyerang hanya akan menebaknya.  Tentu saja, menggunakan hash waktu acak lebih baik daripada tidak menggunakan apa pun untuk melindungi terhadap peretas, tetapi ini tidak akan memberi Anda keamanan yang harus Anda andalkan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Versi lengkap dari kursus ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</a> di Belanda dan Amerika Serikat!</b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418099/">https://habr.com/ru/post/id418099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418087/index.html">80% dari checkout mandiri memiliki risiko</a></li>
<li><a href="../id418089/index.html">Ikhtisar Mesin Penggilingan SolidCraft CNC</a></li>
<li><a href="../id418091/index.html">Daftar artikel dan literatur tentang NAS</a></li>
<li><a href="../id418093/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 2</a></li>
<li><a href="../id418095/index.html">Tentang perangkat fungsionalitas pengujian bawaan di Rust (terjemahan)</a></li>
<li><a href="../id418101/index.html">Etimologi Istilah TI</a></li>
<li><a href="../id418103/index.html">Kepala Roscosmos ingat roket pertamanya dan berbagi rencana untuk masa depan</a></li>
<li><a href="../id418105/index.html">Mengapa membuka YouTube di Firefox atau Edge dapat memakan waktu 5 kali lebih lama daripada di Google Chrome</a></li>
<li><a href="../id418107/index.html">Mengatur awalan untuk pemindai MINDEO CS2190 untuk bekerja dengan 1C dalam mode istirahat keyboard</a></li>
<li><a href="../id418111/index.html">Pembelajaran Online Modern: Tantangan dan Tren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>