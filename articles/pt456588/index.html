<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎨 👼🏽 🐹 Estudo da injeção de dependência ◼️ 🖕🏾 💤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apesar do padrão existir há mais de uma dúzia de anos e de haver muitos artigos (e traduções), ainda assim, existem cada vez mais disputas, comentário...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estudo da injeção de dependência</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456588/">  Apesar do padrão existir há mais de uma dúzia de anos e de haver muitos artigos (e traduções), ainda assim, existem cada vez mais disputas, comentários, perguntas e várias realizações. <br><br><div class="spoiler">  <b class="spoiler_title">Antecedentes</b> <div class="spoiler_text">  Em 2004, Martin Fowler escreveu o famoso artigo “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inversão de contêineres de controle e o padrão de injeção de dependência</a> ”, que descreveu o padrão acima e sua implementação em Java.  Desde então, o padrão tornou-se amplamente debatido e implementado.  No desenvolvimento móvel, especialmente no iOS, isso ocorreu com um atraso significativo.  No Habré, existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">boas traduções do artigo</a> , boa sorte e karma brilhante para o autor. <br></div></div><br>  Há informações suficientes até no hub, mas o fato de ser discutido em todos os lugares <b>como</b> fazê-lo, mas praticamente em nenhum lugar - <b>POR QUE,</b> me inspirou a escrever o post.  É possível criar uma boa arquitetura se você não souber para que serve e para que deve ser bom?  Certos princípios e tendências claras podem ser levados em consideração - isso ajudará a minimizar problemas imprevistos, mas o entendimento é ainda melhor. <br><a name="habracut"></a><br>  <b>Injeção de dependência</b> é um padrão de design no qual campos ou parâmetros para criar um objeto são configurados externamente. <br><br>  Sabendo que muitos se limitarão à leitura dos primeiros parágrafos, mudei o artigo. <br>  Apesar de essa “definição” de DI ser encontrada em muitas fontes, ela é ambígua, porque faz o usuário pensar que a injeção é algo que substitui a criação / inicialização de objetos, ou pelo menos está muito ativamente envolvida nesse processo.  Obviamente, ninguém proibirá fazer essa implementação do DI.  Mas o DI pode ser um invólucro passivo em torno da criação de um objeto que fornece o fornecimento de parâmetros de entrada.  Nesta implementação, obtemos outro nível de abstração e uma excelente separação de tarefas: o objeto é responsável por sua inicialização e a injeção implementa o armazenamento de dados e fornece módulos de aplicativos. <br><br>  Agora, sobre tudo em ordem e em detalhes. <br>  Começarei com um simples, por que havia necessidade de novos padrões e por que alguns padrões antigos se tornaram muito limitados em escopo? <br><br>  Na minha opinião, a maior parte das mudanças foi introduzida pela introdução maciça do autoteste.  E para quem está escrevendo ativamente autotestes, este artigo é óbvio como um dia branco, você não pode ler mais.  Só você não pode imaginar quantas pessoas não as escrevem.  Entendo que pequenas empresas e empresas iniciantes não possuem esses recursos, mas, infelizmente, grandes empresas geralmente têm problemas mais prioritários. <br><br>  O raciocínio aqui é muito simples.  Suponha que você esteja testando uma função com os parâmetros <i>aeb</i> , e espere obter o resultado <i>x</i> .  Em algum momento, suas expectativas não se realizam, a função retorna o resultado <i>y</i> e, após passar algum tempo, você encontra um singleton dentro da função, que em alguns estados traz o resultado da função para um valor diferente.  Esse singleton foi chamado de <b>dependência implícita</b> e, de todas as formas possíveis, recusou-se a usá-lo nessas situações.  Infelizmente, você não jogará palavras para fora da música, caso contrário, será uma música completamente diferente.  Portanto, retiramos nosso singleton como uma variável de entrada na função.  Agora temos 3 variáveis ​​de entrada <i>a</i> , <i>b</i> , <i>s</i> .  Tudo parece óbvio: mudamos os parâmetros - obtemos um resultado inequívoco. <br><br>  Enquanto eu não vou dar exemplos.  Além disso, não estamos falando apenas de funções dentro de uma classe, é um argumento esquemático que também pode ser aplicado à criação de uma classe, módulo etc. <br><br><div class="spoiler">  <b class="spoiler_title">Singleton Notes</b> <div class="spoiler_text">  <i>Nota 1. Se, dada a crítica ao padrão singleton, você decidir substituí-lo, por exemplo, por UserDefaults, em relação a essa situação, a mesma dependência implícita aparece.</i> <br><br>  <i>Nota 2. Não é totalmente correto dizer que somente por causa do autoteste, não vale a pena usar singletones dentro do corpo da função.</i>  <i>Em geral, do ponto de vista da programação, não é inteiramente correto que, com a mesma entrada, a função produza resultados diferentes.</i>  <i>Só que nos autotestes esse problema apareceu mais claramente.</i> <br></div></div><br>  Complemente o exemplo acima.  Você tem um objeto que contém 9 configurações do usuário (variáveis), por exemplo, o direito de ler / editar / assinar / imprimir / encaminhar / excluir / bloquear / bloquear / executar / copiar um documento.  Sua função usa apenas três variáveis ​​dessas configurações.  O que você passa para a função: o objeto inteiro com 9 variáveis ​​como um parâmetro ou apenas três configurações necessárias com três parâmetros separados?  Muitas vezes aumentamos os objetos transferidos para não definir muitos parâmetros, ou seja, selecionamos a primeira opção.  Este método será considerado a transferência de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"dependências razoavelmente amplas"</a> .  Como você já adivinhou, para fins de autoteste, é melhor usar a segunda opção e passar apenas os parâmetros usados. <br><br>  Fizemos 2 conclusões: <br>  - a função deve receber todos os parâmetros necessários na entrada <br>  - a função não deve receber parâmetros de entrada desnecessários <br><br>  Queríamos o melhor - mas conseguimos uma função com 6 parâmetros.  Suponha que tudo esteja em ordem dentro da função, mas alguém deve assumir a responsabilidade de fornecer parâmetros de entrada para a função.  Como já escrevi, meu raciocínio é superficial.  Quero dizer, não apenas uma função de classe comum, mas uma função de inicialização / criação de módulo (vip, viper, objeto de dados, etc.).  Nesse contexto, reformulamos a pergunta: quem deve fornecer os parâmetros de entrada para criar o módulo? <br><br>  Uma solução seria mudar esse caso para o módulo de chamada.  Porém, o módulo de chamada precisa passar os parâmetros da criança.  Isso implica as seguintes complicações: <br><br>  Primeiro, um pouco antes, decidimos evitar "dependências excessivamente amplas".  Em segundo lugar, você não precisa se esforçar muito para entender que haverá muitos parâmetros e será muito tedioso editá-los toda vez que você adicionar módulos filhos, até custa pensar em excluir módulos filhos.  A propósito, em alguns aplicativos, é impossível construir uma hierarquia de módulos: veja qualquer rede social: perfil -&gt; amigos -&gt; perfil do amigo -&gt; amigos do amigo etc.  Em terceiro lugar, o princípio SOLI <u>D</u> pode ser lembrado neste tópico: “Os módulos de nível superior são independentes dos módulos de nível inferior” <br><br>  Isso dá origem à idéia de fazer a criação / inicialização do módulo em uma estrutura separada.  Então é hora de escrever algumas linhas como exemplo: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AccountList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showAccountDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(account: String)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accountDetail = <span class="hljs-type"><span class="hljs-type">AccountDetail</span></span>.make(account: account) <span class="hljs-comment"><span class="hljs-comment">// to do something with accountDetail } } class AccountDetail { private init(account: String, permission1: Bool, permission2: Bool) { print("account = \(account), p1 = \(permission1), p2 = \(permission2)") } } extension AccountDetail { public static func make(account: String) -&gt; AccountDetail? { let p1 = ... let p2 = ... return AccountDetail(account: account, permission1: p1, permission2: p2) } }</span></span></code> </pre> <br>  No exemplo, há um módulo da lista de contas AccountList, que chama o módulo de informações detalhadas na conta AccountDetail. <br><br>  Para inicializar o módulo AccountDetail, são necessárias 3 variáveis.  A variável Account AccountDetail recebe do módulo pai, as variáveis ​​permission1, permission2 são injetadas.  Devido à injeção, uma chamada de módulo com detalhes da fatura será semelhante a: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accountDetail = <span class="hljs-type"><span class="hljs-type">AccountDetail</span></span>.make(account: account)</code> </pre><br>  em vez de <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accountDetail = <span class="hljs-type"><span class="hljs-type">AccountDetail</span></span>(account: account, permission1: p1, permission2: p2)</code> </pre><br>  e o módulo pai da lista de contas, AccountList, ficará isento da obrigação de passar parâmetros com permissões sobre as quais ele não sabe nada. <br><br>  Transformei a implementação de injeção (montagem) em uma função estática em uma extensão de classe.  Mas a implementação pode ser a seu critério. <br><br>  Como vemos: <br><br><ol><li>  O módulo recebeu os parâmetros necessários.  Sua criação e execução podem ser testadas com segurança em todos os conjuntos de valores. </li><li>  Os módulos são independentes, não há necessidade de transferir nada para crianças ou apenas o mínimo necessário. </li><li>  Os módulos NÃO fazem o trabalho de fornecer dados, eles usam dados prontos (p1, p2).  Portanto, se você deseja alterar algo no armazenamento ou fornecimento de dados, não é necessário fazer alterações no código funcional dos módulos (assim como em seus autotestes), mas você só precisa alterar o próprio sistema de montagem ou as extensões com a montagem. </li></ol><br>  A essência da injeção de dependência é a construção de um processo no qual, ao chamar um módulo de outro, um objeto / mecanismo independente transfere (injeta) dados para o módulo chamado.  Em outras palavras, o módulo chamado é configurado externamente. <br><br>  Existem vários métodos de configuração: <br>  <b>Injeção de Construtor</b> , <b>Injeção de</b> <b>Propriedade</b> , <b>Injeção de Interface</b> . <br>  Para Swift: <br>  <b>Injeção de Inicializador</b> , <b>Injeção de</b> <b>Propriedade</b> , <b>Injeção de Método</b> . <br><br>  As mais comuns são injeções e propriedades do construtor (inicialização). <br>  <b>Importante: em</b> quase todas as fontes, recomenda-se que as injeções do construtor sejam preferidas.  Compare a injeção de construtor / inicializador e a injeção de propriedade: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> account = .. <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = ... <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = ... <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accountDetail = <span class="hljs-type"><span class="hljs-type">AccountDetail</span></span>(account: account, permission1: p1, permission2: p2)</code> </pre><br>  melhor que <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accountDetail = <span class="hljs-type"><span class="hljs-type">AccountDetail</span></span>() accountDetail.account = .. accountDetail.permission1 = ... accountDetail.permission2 = ...</code> </pre><br>  Parece que as vantagens do primeiro método são óbvias, mas por algum motivo alguns entendem a injeção como configurando um objeto já criado e usam o segundo método.  Eu sou o primeiro método: <br><br><ol><li>  a criação pelo designer garante um objeto válido; </li><li>  com a injeção de propriedade, não está claro se é necessário testar uma alteração em uma propriedade em locais que não sejam a criação; </li><li>  em idiomas que usam opcionalidade, para implementar a injeção de propriedade, você precisa tornar os campos opcionais ou criar métodos de inicialização inteligentes (os preguiçosos nem sempre funcionam).  Opcionalidade excessiva adiciona código e suítes de testes desnecessários. </li></ol><br>  No entanto, até nos livrarmos de algumas dependências, apenas as trocamos de um ombro para outro.  Uma pergunta lógica é de onde obter os dados no próprio assembly (função make no exemplo). <br><br>  O uso de singletones no mecanismo de montagem não leva mais aos problemas acima com dependência oculta, porque  Você pode testar a criação de módulos com qualquer conjunto de dados. <br>  Mas aqui estamos diante de outro ponto negativo do singleton: manuseio inadequado (você provavelmente pode trazer muitos argumentos odiosos, mas preguiça).  Não é bom espalhar suas muitas armazenadas / singletones em montagens, por analogia com qualquer pessoa, pois elas foram espalhadas em módulos funcionais.  Mas mesmo essa refatoração já será o primeiro passo para a higiene, pois é possível restaurar a ordem nas montagens quase sem afetar os testes de código e módulo. <br><br>  Se você deseja otimizar ainda mais a arquitetura, bem como testar transições e trabalhos de montagem, precisará trabalhar um pouco mais. <br><br>  O conceito de DI nos permite armazenar todos os dados necessários em um contêiner.  Isso é conveniente.  Em primeiro lugar, salvar (registrar) e receber (resolver) dados passa por um único objeto de contêiner, respectivamente, para que seja mais fácil gerenciar dados e testá-los.  Em segundo lugar, você pode levar em consideração a dependência dos dados entre si.  Em muitos idiomas, incluindo o rápido, existem contêineres prontos para gerenciamento de dependências, geralmente dependências formam uma árvore.  Os restantes prós e contras não vou listar, você pode ler sobre eles nos links que publiquei no início do post. <br><br>  Aqui está a aparência da montagem usando o contêiner. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Swinject public class Configurator { private static let container = Container() public static func register&lt;T&gt;(name: String, value: T) { container.register(type(of: value), name: name) { _ in value } } public static func resolve&lt;T&gt;(service: T.Type, name: String) -&gt; T? { return container.resolve(service, name: name) } } extension AccountDetail { public static func make(account: String) -&gt; AccountDetail? { if let p1 = Configurator.resolve(service: Bool.self, name: "permission1"), let p2 = Configurator.resolve(service: Bool.self, name: "permission2") { return AccountDetail(account: account, permission1: p1, permission2: p2) } else { return nil } } } <span class="hljs-comment"><span class="hljs-comment">// -   ,         //   ()  Configurator.register(name: "permission1", value: true) Configurator.register(name: "permission2", value: false) ...</span></span></code> </pre><br>  Este é um possível exemplo de implementação.  O exemplo usa a estrutura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Swinject</a> , que nasceu não muito tempo atrás.  O Swinject permite criar um contêiner para gerenciamento automatizado de dependências e também criar contêineres para Storyboards.  Mais informações sobre o Swinject podem ser encontradas nos exemplos em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">raywenderlich</a> .  Eu realmente gosto deste site, mas este exemplo não é o mais bem-sucedido, pois considera o uso do contêiner apenas em autotestes, enquanto o contêiner deve ser colocado na arquitetura do aplicativo.  Você, no seu código, pode escrever um contêiner por conta própria. <br><br>  Obrigado a todos por isso.  Espero que você não tenha se entediado ao ler este texto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456588/">https://habr.com/ru/post/pt456588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456572/index.html">40 anos de advergaming - uma retrospectiva de videogames publicitários</a></li>
<li><a href="../pt456574/index.html">Redes de TV a cabo para os menores. Parte 10: Solução de problemas de redes KTV</a></li>
<li><a href="../pt456580/index.html">O futuro autônomo do DBMS</a></li>
<li><a href="../pt456582/index.html">Por que a Internet ainda está online?</a></li>
<li><a href="../pt456584/index.html"># ITX5 reunirá um grupo de desenvolvedores JAVA</a></li>
<li><a href="../pt456592/index.html">Distorções cognitivas no desenvolvimento dos "tempos" da língua inglesa ou Quem interfere conosco nos ajudarão</a></li>
<li><a href="../pt456594/index.html">2 minutos com tremor de árvores Webpack e reexportação</a></li>
<li><a href="../pt456596/index.html">Microbiota. Como o teste funciona?</a></li>
<li><a href="../pt456600/index.html">Receitas Nginx: autorização LDAP com captcha</a></li>
<li><a href="../pt456602/index.html">Guia de Implementação de assinaturas renováveis ​​automaticamente em aplicativos iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>