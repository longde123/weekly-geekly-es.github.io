<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçö üëßüèª üë©üèæ‚ÄçüöÄ Mostramos contenido en la imagen reconocida de acuerdo con ciertas reglas üï¥üèΩ üõê üë®‚Äçüë®‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A veces, cuando lee una tarea t√©cnica y establece plazos para la implementaci√≥n, subestima la cantidad de tiempo y esfuerzo dedicado a resolver un pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mostramos contenido en la imagen reconocida de acuerdo con ciertas reglas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454452/"><p>  A veces, cuando lee una tarea t√©cnica y establece plazos para la implementaci√≥n, subestima la cantidad de tiempo y esfuerzo dedicado a resolver un problema en particular.  Sucede que un punto, que se estima por tiempo por semana, se lleva a cabo a una hora, y a veces viceversa.  Pero este art√≠culo no se trata de eso.  Esta es una demostraci√≥n de la evoluci√≥n de una soluci√≥n a un problema.  Desde su inicio hasta su implementaci√≥n. </p><br><p><img src="https://habrastorage.org/webt/qh/ns/i7/qhnsi7xrjjlbxp7ob1rqgsmpo9o.jpeg"></p><a name="habracut"></a><br>
<h1 id="ispolzuemye-terminy">  T√©rminos usados </h1><br><ul><li><p>  Marca o marcador: una imagen cargada en el motor AR, que es reconocida por la c√°mara del dispositivo (tableta o tel√©fono inteligente) y puede identificarse de manera √∫nica </p><br></li><li><p>  Encontrado: estado del marcador cuando se detect√≥ en el campo de visi√≥n de la c√°mara </p><br></li><li><p>  Perdido: estado del marcador cuando se perdi√≥ de la vista de la c√°mara </p><br></li><li><p>  Se puede mostrar: cuando se encuentra el marcador, mostramos el contenido adjunto al marcador </p><br></li><li><p>  No se puede mostrar - cuando encontramos el marcador, no mostrar el contenido - Contenido adjunto al marcador - ning√∫n objeto (modelo 3D, sprite, sistema de part√≠culas, etc.) que se puede adjuntar al marcador y que, en consecuencia, se mostrar√° en la pantalla si se encuentra un marcador </p><br></li><li><p>  Marca, marcador, encontrado, perdido: los estados b√°sicos inherentes a todos los motores que proporcionan funcionalidad de reconocimiento </p><br></li><li><p>  Se puede mostrar y no se puede mostrar: el estado utilizado para resolver este problema </p><br><p>  <strong>Un ejemplo:</strong> </p><br><ul><li>  Descargue la aplicaci√≥n =&gt; todas las marcas descargadas son reconocibles </li><li>  Estamos tratando de reconocer =&gt; el estado del marcador cambia a "encontrado" </li><li>  Si el marcador puede mostrarse =&gt; indica que el marcador est√° "encontrado" y mostramos el modelo adjunto al marcador </li><li>  Si el marcador no se puede mostrar =&gt; el estado del marcador es "encontrado", pero el modelo adjunto no se muestra </li><li>  La marca desapareci√≥ del campo de visi√≥n de la c√°mara =&gt; cambiamos el estado a "perdido" </li></ul><br></li></ul><br><h1 id="vvedenie">  Introduccion </h1><br><p>  Hay una postal grande del tama√±o de una hoja A4.  Se divide en 4 partes iguales (formato de una parte A5), en cada una de estas partes hay: </p><br><ul><li>  Una marca de esquina completa (1) </li><li>  La mitad de la marca lateral inferior (5) </li><li>  La mitad de la marca lateral superior (8) </li><li>  Cuarto centro marca (9) </li></ul><br><p><img src="https://habrastorage.org/webt/_k/87/c4/_k87c4c_mahdxfrbsijiidjauro.jpeg" alt="imagen"></p><br><p> Si trabaj√≥ con alg√∫n motor de reconocimiento, por ejemplo, Vuforia, entonces probablemente sepa que no existe la "calidad de reconocimiento".  La marca se reconoce o no se reconoce.  En consecuencia, si el motor "ve" la marca, cambia el estado a <code>Find</code> y se <code>OnSuccess()</code> m√©todo <code>OnSuccess()</code> , si se "pierde", el estado cambia a <code>Lost</code> y se <code>OnLost()</code> m√©todo <code>OnLost()</code> .  En consecuencia, a partir de las condiciones existentes y los datos de entrada, surgi√≥ una situaci√≥n en la que al tener una parte de la tarjeta (medio o cuarto) era posible reconocer la marca. </p><br><p>  La cuesti√≥n es que, seg√∫n la tarea t√©cnica, se planific√≥ un desbloqueo gradual de los personajes.  En esta situaci√≥n, es posible un desbloqueo gradual, pero dado que no hay personas que intenten reconocer una cuarta parte o la mitad de la marca. </p><br><h1 id="formulirovka-zadachi">  Declaraci√≥n de tarea </h1><br><p>  Es necesario implementar la l√≥gica en forma de c√≥digo de programa, que asegura el desbloqueo gradual del contenido adjunto a los marcadores.  Desde la ubicaci√≥n de los elementos en la tarjeta se sabe que los marcadores 1, 2, 3, 4 est√°n disponibles para mostrar inicialmente. </p><br><p><img src="https://habrastorage.org/webt/r_/a4/1-/r_a41-b9ezh2oxrcejsffh-ifus.jpeg" alt="imagen"></p><br><p>  Si el contenido se ha le√≠do y mostrado en 2 marcadores, por ejemplo, 2 y 3, entonces permitimos mostrar el contenido en el marcador 6. Si el marcador 1 a√∫n no se ha le√≠do, entonces se cierra el acceso al marcador 5.  Adem√°s por analog√≠a.  De alg√∫n modo, damos permiso para mostrar contenido en los marcadores laterales solo cuando hemos le√≠do los marcadores de esquina adyacentes. </p><br><p><img src="https://habrastorage.org/webt/ux/qs/xu/uxqsxuydrxzijfakmcumpguqkg8.jpeg" alt="imagen"></p><br><p>  Si los marcadores del 1 al 8 est√°n disponibles y se encuentran, abra el contenido en el marcador 9. Para visualizaci√≥n, cada marcador tiene 2 estados: el contenido est√° disponible y no est√° disponible para la visualizaci√≥n, de lo cual es responsable el campo <code>public bool IsActive;</code> </p><br><p>  Est√° claro de inmediato que esto deber√≠a ser una m√°quina de estados con una transici√≥n entre estados o una implementaci√≥n del patr√≥n "Estado". </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  El resultado no fue uno, ni otro.  No puedo decir que esto sea una muleta porque la soluci√≥n cumpli√≥ completamente con los requisitos al principio del art√≠culo.  Pero puedes discutir conmigo. </p></div></div><br><p>  En esto, le doy la oportunidad de pensar un poco sobre las posibles soluciones e implementaciones de esta tarea.  Me llev√≥ unas 5 horas darme cuenta y fijar en mi cabeza la imagen de la decisi√≥n. </p><br><p>  Para mayor claridad, grab√© un video en el que el resultado final del algoritmo (si se puede llamar as√≠) ya est√° capturado. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZcXxVQG2Rgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="podhody-k-resheniyu">  Enfoques de soluci√≥n </h1><br><h2 id="1-ot-uglovyh-markerov-k-centralnomu">  1. De los marcadores de esquina al centro </h2><br><p>  Lo primero que se me ocurri√≥ fue presentar las interacciones entre los marcadores desde la esquina hasta el centro.  En forma gr√°fica, se ve as√≠: </p><br><p><img src="https://habrastorage.org/webt/0u/0j/re/0u0jrellt_78kezlvsgr7poeex0.jpeg" alt="imagen"></p><br><p>  Los problemas: </p><br><ol><li>  ¬øC√≥mo determinar qu√© etiqueta lateral cambiar de estado?  ¬øEl de la izquierda o la derecha?  Tambi√©n forzamos a cada marcador a "saber" acerca de la existencia de uno central. </li><li>  Es necesario agregar dependencias no obvias de la categor√≠a: el marcador lateral se suscribe al evento de marcador de esquina IsChangedEventCallback (), se deben realizar acciones similares para el marcador central. </li><li>  Si consideramos cada tipo de marcador como una entidad, en la jerarqu√≠a de estas entidades reenviaremos el comando de cambio de estado de abajo hacia arriba.  Esto no es muy bueno, porque nos unimos estrechamente con el n√∫mero, en este caso, los marcadores angulares, perdiendo la capacidad de escalar. </li></ol><br><p>  Incapaz de poner en mi cabeza la soluci√≥n anterior debido a los muchos casos extremos y la complejidad de la percepci√≥n, cambi√© el enfoque para elegir el marcador en el que las dependencias comienzan a extenderse. </p><br><h2 id="2-bokovye-znayut-o-centralnom-i-uglovyh">  2. Los laterales saben sobre el centro y la esquina. </h2><br><p>  Pensando en la soluci√≥n del p√°rrafo 3 del enfoque anterior, surgi√≥ la idea de cambiar el tipo de marcador, a partir del cual los estados de otros marcadores comienzan a cambiar.  Como se tomaron los marcadores laterales principales.  En este escenario, las comunicaciones (dependencias) se ven as√≠: </p><br><p><img src="https://habrastorage.org/webt/t3/vz/3q/t3vz3qmk-wnhvwdbpgcdgemuciu.jpeg" alt="imagen"></p><br><p>  A partir de aqu√≠, queda claro de inmediato que las conexiones desde el lateral al central son superfluas, porque el marcador lateral no necesita saber nada sobre el marcador central, por lo tanto, este enfoque se transform√≥ inmediatamente en el √∫ltimo. </p><br><h2 id="3-centralnyy-znaet-o-vseh-bokovye-znayut-o-uglovyh">  3. El central sabe de todos, los secundarios saben de la esquina. </h2><br><p><img src="https://habrastorage.org/webt/24/y_/hm/24y_hmm09x-karjrpyddxkh6gqy.jpeg" alt="imagen"></p><br><p>  La soluci√≥n final es cuando el marcador lateral sabe acerca de las esquinas, las esquinas "viven su vida", y el marcador central sabe sobre el estado de todos los marcadores. </p><br><p><img src="https://habrastorage.org/webt/no/ls/fl/nolsflwoafqlnjbnanb9illn2wi.jpeg" alt="imagen"></p><br><p>  Trabajar con la vista de postal no es muy conveniente.  Las relaciones entre entidades no se ven lo suficientemente claras como para convertir esto f√°cilmente en c√≥digo.  Un intento de interpretar en forma de √°rbol binario puede introducir cierta ambig√ºedad.  Pero aqu√≠ se viola una de las propiedades del √°rbol binario, por lo que la ambig√ºedad desaparece de inmediato.  De lo cual podemos concluir que esta representaci√≥n puede ser interpretada sin ambig√ºedades y utilizada para representar gr√°ficamente la soluci√≥n al problema.  En base a estas conclusiones, utilizaremos la notaci√≥n gr√°fica, a saber: </p><br><ul><li>  Angle Marker - Angle Node (nivel 3) </li><li>  Marcador lateral - Nodo lateral (nivel 2) </li><li>  Marcador central - Nodo central (nivel 1) </li></ul><br><p>  Ventajas: </p><br><ol><li>  Las dependencias entre los marcadores son obvias y obvias. </li><li>  Cada uno de los niveles se puede representar en forma de 3 entidades, cada una de las cuales consta de partes b√°sicas, pero con sus adiciones inherentes a cada uno de los niveles. </li><li>  Para expandir, solo necesitar√° agregar un nuevo tipo de nodo con sus propias caracter√≠sticas </li><li>  Esta soluci√≥n es f√°cil de imaginar en un estilo OO (orientado a objetos) </li></ol><br><h1 id="realizaciya">  Implementaci√≥n </h1><br><h2 id="bazovye-suschnosti">  Entidades base </h2><br><p>  Creemos una interfaz que contenga los elementos inherentes a cada entidad (nombre, estado): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  A continuaci√≥n, describimos la esencia de cada nodo: </p><br><ul><li>  <strong>CornerNode</strong> : un nodo angular.  Simplemente implemente la interfaz <code>INode</code> : </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CornerNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  ¬øPor qu√© <code>IsActive = true</code> ? </p><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text"><p>  A partir de las condiciones del problema, el contenido de los marcadores de esquina est√° inicialmente disponible para su reconocimiento. </p></div></div><br><ul><li>  <strong>SideNode</strong> : un nodo lateral.  Implementamos la interfaz <code>INode</code> , pero agregamos los <code>RightCornerNode</code> <code>LeftCornerNode</code> y <code>RightCornerNode</code> .  Por lo tanto, el nodo lateral mantiene su estado en s√≠ mismo y solo conoce la existencia de nodos laterales. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SideNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode LeftCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode RightCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, CornerNode leftNode, CornerNode rightNode</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; LeftCornerNode = leftNode; RightCornerNode = rightNode; } }</code> </pre> <br><ul><li>  <strong>CenterNode</strong> es el nodo central.  Como en los anteriores, implementamos <code>INode</code> .  Agregue un campo de tipo <code>List&lt;INode&gt;</code> . </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CentralNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;INode&gt; NodesOnCard; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h2 id="klass-opencard">  Clase Opencard </h2><br><h3 id="privatnye-metody-i-polya">  M√©todos y campos privados. </h3><br><p>  Ahora que hemos creado todos los elementos de la tarjeta que hemos creado (todo tipo de marcadores), podemos comenzar a describir la esencia de la tarjeta en s√≠.  No estoy acostumbrado a comenzar una clase con un constructor.  Siempre empiezo con los m√©todos b√°sicos que son inherentes a una entidad en particular.  Comencemos con campos privados y m√©todos privados. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CornerNode&gt; cornerNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SideNode&gt; sideNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CentralNode centralNode;</code> </pre> <br><p>  Con los campos, todo es bastante simple.  2 listas con nodos angulares, laterales y un campo del nodo central. </p><br><p>  A continuaci√≥n, necesita aclarar un poco.  El hecho es que el marcador en s√≠ es del tipo <code>Trackable</code> y no tiene idea (y no deber√≠a tener) de que es parte de alguna otra l√≥gica all√≠.  Por lo tanto, todo lo que podemos usar para controlar la pantalla es su nombre.  En consecuencia, si el marcador en s√≠ no almacena el tipo de nodo al que pertenece, entonces debemos transferir esta responsabilidad a nuestra clase <code>OpenCard</code> .  En base a esto, primero describimos 3 m√©todos privados que son responsables de determinar el tipo de nodo. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == centralNode.Name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCornerNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Pero estos m√©todos no tienen sentido para usar directamente.  No es conveniente operar con valores booleanos cuando trabaja con objetos de otro nivel de abstracci√≥n.  Por lo tanto, crearemos un <code>enum NodeType</code> simple y un m√©todo privado <code>GetNodeType()</code> , que encapsula en s√≠ mismo toda la l√≥gica asociada con la determinaci√≥n del tipo de nodo. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NodeType { CornerNode, SideNode, CentralNode } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NodeType? GetNodeType(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCentralNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CentralNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsSideNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.SideNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCornerNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CornerNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><h3 id="publichnye-metody">  M√©todos p√∫blicos </h3><br><ul><li>  <code>IsExist</code> es un m√©todo que devuelve un valor booleano que indica si nuestra marca pertenece a una postal.  Este es un m√©todo auxiliar, que se realiza para que si el marcador no pertenece a ninguna tarjeta, podamos mostrar el contenido en √©l. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centralNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><ul><li>  <code>CheckOnActiveAndChangeStatus</code> : un m√©todo (como su nombre lo indica) en el que verificamos el estado actual del nodo y cambiamos su estado. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckOnActiveAndChangeStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetNodeType(name)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CornerNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.SideNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.LeftCornerNode.IsActive &amp;&amp; node.RightCornerNode.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CentralNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centralNode.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3 id="konstruktor">  Constructor </h3><br><p>  Cuando todas las cartas est√°n sobre la mesa, finalmente podemos ir al constructor.  Puede haber varios enfoques para la inicializaci√≥n.  Pero decid√≠ librar a la clase <code>OpenCard</code> de gestos innecesarios tanto como sea posible.  Deber√≠a responder con nosotros si el contenido est√° disponible para mostrar o no.  Por lo tanto, simplemente pedimos listas de entrada de nodos de 2 tipos y un nodo central. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;CornerNode&gt; listCornerNode, List&lt;SideNode&gt; listSideNode, CentralNode centralNode</span></span></span><span class="hljs-function">)</span></span> { CornerNodes = listCornerNode; SideNodes = listSideNode; CentralNodes = centralNode; CentralNodes.NodesOnCard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;INode&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CornerNodes) CentralNodes.NodesOnCard.Add(node); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SideNodes) CentralNodes.NodesOnCard.Add(node); }</code> </pre> <br><p>  Tenga en cuenta que dado que el nodo central solo necesita verificar la condici√≥n de todos los dem√°s nodos <code>true</code> , es suficiente para nosotros <code>INode</code> impl√≠citamente <code>INode</code> nodos angulados y centrales que entraron en el constructor al tipo <code>INode</code> . </p><br><h3 id="inicializaciya">  Inicializaci√≥n </h3><br><p>  ¬øCu√°l es la forma m√°s conveniente de crear objetos que no necesitan estar unidos (como los componentes <code>MonoBehaviour</code> ) a un GameObject?  - Correcto, <code>ScriptableObject</code> .  Adem√°s, para mayor comodidad, agregue el atributo <code>MenuItem</code> , que simplificar√° la creaci√≥n de nuevas tarjetas. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CreateAssetMenu(fileName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Open Card"</span></span></span><span class="hljs-meta">, menuName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"New Open Card"</span></span></span><span class="hljs-meta">, order = 51)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OpenCardScriptableObject</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> downSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> upSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> centralName; }</code> </pre> <br><p>  El acorde final en nuestra composici√≥n ser√° un pasaje a trav√©s del conjunto de <code>ScriptableObject</code> agregados (si los hay) y la creaci√≥n de postales a partir de ellos.  Despu√©s de eso, nos queda en el m√©todo <code>Update</code> simplemente verificar si podemos mostrar el contenido o no. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpenCardScriptableObject[] openCards; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;OpenCard&gt; _cardList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openCards.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { _cardList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;OpenCard&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> openCards) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.leftSideName, leftUp, leftDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> downSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.downSideName, leftDown, rightDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.rightSideName, rightDown, rightUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> upSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.upSideName, rightUp, leftUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> central = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CentralNode(card.centralName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CornerNode&gt;() {leftDown, rightDown, rightUp, leftUp}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;SideNode&gt;() {leftSide, downSide, rightSide, upSide}; _cardList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCard(nodes, sideNodes, central)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cardList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.IsExist(trackableName)) isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.CheckOnActiveAndChangeStatus(trackableName)) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNotPartCard) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); } }</code> </pre> <br><h1 id="vyvody">  Conclusiones </h1><br><p>  Para m√≠ personalmente, las conclusiones fueron las siguientes: </p><br><ol><li>  Cuando intente resolver un problema, debe intentar dividir sus elementos en partes at√≥micas.  Adem√°s, teniendo en cuenta todas las opciones posibles para la interacci√≥n entre estas partes at√≥micas, debe comenzar con el objeto, del que potencialmente surgir√°n m√°s conexiones.  De otra manera, puede formularse como: esforzarse por comenzar a resolver problemas con elementos que, potencialmente, ser√°n menos confiables </li><li>  Si es posible, debe intentar presentar los datos de origen en una forma diferente.  En mi caso, la representaci√≥n gr√°fica me ayud√≥ mucho. </li><li>  Cada entidad est√° separada de la otra por el n√∫mero de conexiones que potencialmente podr√≠an provenir de ella. </li><li>  Muchas tareas aplicadas que son m√°s habituales de resolver escribiendo un algoritmo pueden representarse en el estilo OO </li><li>  Una soluci√≥n que tiene dependencias de anillo es una mala soluci√≥n </li><li>  Si es dif√≠cil mantener todas las conexiones entre los objetos en tu cabeza, esta es una mala decisi√≥n </li><li>  Si no puede tener en cuenta la l√≥gica de la interacci√≥n de los objetos, esta es una mala decisi√≥n </li><li>  Tus muletas no siempre son una mala decisi√≥n </li></ol><br><p>  ¬øConoces otra soluci√≥n?  - Escribe en los comentarios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454452/">https://habr.com/ru/post/454452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454440/index.html">Petty Little Fun # 2: Starlette</a></li>
<li><a href="../454442/index.html">C√≥mo elegir una red proxy para su negocio: 3 consejos pr√°cticos</a></li>
<li><a href="../454444/index.html">Perfilamos la carga de Habr o c√≥mo 189 solicitudes en la p√°gina representan influencia</a></li>
<li><a href="../454446/index.html">¬øQu√© hay de nuevo en C # 8?</a></li>
<li><a href="../454450/index.html">C√≥mo Edison invent√≥ la tecnolog√≠a inal√°mbrica y no entendi√≥ nada</a></li>
<li><a href="../454456/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 7. Preguntas frecuentes</a></li>
<li><a href="../454458/index.html">Pruebas metam√≥rficas: por qu√© casi nadie sabe acerca de esta t√©cnica prometedora</a></li>
<li><a href="../454460/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 300 (27 de mayo - 2 de junio)</a></li>
<li><a href="../454462/index.html">Fotograma sin papel fotogr√°fico</a></li>
<li><a href="../454464/index.html">Desarrollo de pruebas visuales basadas en Gemini y Storybook.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>