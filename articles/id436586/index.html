<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ¤²ğŸ» âœ‹ğŸ½ Pertempuran JS: bagaimana saya menulis eval saya () ğŸ§ ğŸ™‹ğŸ¼ ğŸ°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anda dapat mengingat Alexander Korotayev dalam versi peramban "Heroes of Might and Magic": dekripsi laporannya tentang dia mengumpulkan sejumlah besar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pertempuran JS: bagaimana saya menulis eval saya ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/436586/">  Anda dapat mengingat <b>Alexander Korotayev</b> dalam versi peramban "Heroes of Might and Magic": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dekripsi</a> laporannya tentang dia mengumpulkan sejumlah besar pandangan tentang HabrÃ©.  Dan sekarang dia membuat game yang berfokus pada programmer: Anda harus memainkannya dengan kode JS. <br><br>  Kali ini pengembangannya tidak memakan waktu berminggu-minggu, tetapi berminggu-minggu, tetapi tanpa tantangan yang menarik itu tidak bisa dilakukan.  Bagaimana membuat game ini nyaman bahkan untuk pengembang yang belum pernah menyentuh JavaScript?  Bagaimana melindungi diri Anda dari cara sederhana untuk mengakali permainan? <br><br><img src="https://habrastorage.org/webt/to/1i/n0/to1in00dneigddmemqzjqonebuy.png"><br><br>  Akibatnya, Alexander sekali lagi membuat laporan tentang HolyJS, dan kami (penyelenggara konferensi) kembali menyiapkan versi teks untuk Habr. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/TJ7TGk5WJ5k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Nama saya Alexander Korotaev, saya bekerja di Tinkoff.ru, saya terlibat dalam front-end.  Selain itu, sebagai bagian dari komunitas Spb-frontend, saya membantu mengatur mitaps.  Saya membuat podcast Drinkcast, kami mengundang orang-orang yang menarik dan mendiskusikan berbagai topik. <br><br>  Apa inti dari mainan itu?  Pertama, Anda perlu memilih unit dari yang diusulkan, ini adalah sistem RPG: setiap unit memiliki kekuatan dan kelemahannya sendiri.  Anda melihat unit mana yang musuh pilih, dan pilih sebagai balas dendam padanya.  Maka Anda perlu menulis skrip JavaScript untuk perilaku pasukan Anda - dengan kata lain, skrip "apa yang harus dilakukan setiap unit di medan perang." <br><br>  Ini dilakukan dalam mode debug: pada kenyataannya, Anda mendebit kode, dan kemudian kedua lawan mendorong kode mereka, dan pertempuran antara kedua belah pihak dimulai. <br><br>  Dengan demikian, Anda dapat melihat bagaimana dua skrip, dua logika, dua algoritma saling bertarung.  Saya selalu ingin melakukan sesuatu seperti ini, dan sekarang akhirnya dilaksanakan. <br><br>  Dalam aksi, semuanya terlihat seperti ini: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/LfgaRFnmkhk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dan seperti apa pengerjaan itu?  Banyak pekerjaan masuk ke dokumentasi.  Ketika pemain duduk di laptop, dia melihat dokumentasi, di mana semuanya dijelaskan dengan cukup rinci. <br><br>  Saya membutuhkan banyak waktu untuk tata letak, revisi, dan mempertanyakan di antara orang-orang apakah itu jelas.  Akibatnya, ternyata jelas untuk sishnikov, javists dan pengembang lain yang tidak tahu apa-apa tentang JS.  Anda bahkan dapat mempromosikan JavaScript dengan mainan ini: "Ini tidak menakutkan, lihat bagaimana Anda dapat menulis di atasnya, bahkan sesuatu yang menyenangkan terjadi." <br><br><img src="https://habrastorage.org/webt/c3/9b/cf/c39bcfhakno9pvemjsm5rfj1_jo.png"><br><br>  Kami memiliki turnamen besar di perusahaan kami, di mana hampir semua programmer yang kami ikuti. <br><br>  Dari teknologi, saya menggunakan mesin game paling populer dari dunia JS - Phaser.  Editor Ace terbesar dan paling umum digunakan.  Ini adalah editor di web, sangat mirip dengan Sublime atau VSCode, dapat disematkan di halaman web.  Saya juga menggunakan RxJS untuk bekerja dengan interaksi asinkron dari pengguna yang berbeda dan Preact untuk merender html.  Dari teknologi asli, ia terutama bekerja dengan pekerja dan websocket. <br><br><img src="https://habrastorage.org/webt/hr/7e/hj/hr7ehjcuxfyljukymq0yeiwsvou.png"><br><br><hr><br><h2>  Game untuk programmer </h2><br>  Apa game untuk programmer pada umumnya?  Menurut pendapat saya, ini adalah permainan di mana Anda perlu kode, lalu dapatkan beberapa hasil lucu yang dapat dibandingkan dengan seseorang, ini adalah pertarungan.  Dari game online yang tersedia ini, saya tahu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Elevator Saga"</a> - Anda menulis skrip untuk elevator berdasarkan parameter tertentu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Screeps"</a> - tentang biologi, molekul, menulis skrip untuk mereka. <br><br>  Ada juga mainan yang terkadang ada di konferensi.  Yang paling populer dari mereka adalah "Code in the Dark", kami juga menyajikannya hari ini.  Ngomong-ngomong, "Kode dalam gelap" mengilhami saya dalam beberapa hal. <br><br><img src="https://habrastorage.org/webt/di/ri/xp/dirixpaaxzsners2q5wbecnqf_i.png"><br><br>  Mengapa ini dilakukan?  Saya mendapat tugas yang Anda butuhkan untuk membuat sesuatu yang keren dengan pendirian di konferensi, sesuatu yang tidak biasa.  Bukannya ada eychars dengan kuesioner.  Jelas bahwa setiap orang ingin menarik perhatian dan mengumpulkan kontak.  Kami memutuskan untuk melangkah lebih jauh dan membuat sesuatu yang keren dan menyenangkan bagi para programmer.  Saya menyadari bahwa programmer ingin bertarung, bersaing, dan kita perlu memberi mereka kesempatan seperti itu.  Hal ini diperlukan untuk membuat stand di mana mereka akan datang dan berkode. <br><br>  Gamifikasi  Kami melakukan ini tidak hanya di kalangan programmer yang berlatih, tetapi juga di kalangan siswa.  Kami mengadakan pertandingan semacam itu di institut pada Hari Karier.  Kami perlu entah bagaimana melihat pria macam apa di sana, cocok untuk kami atau tidak.  Kami menggunakan gamification untuk memikat orang ke dalam proses, untuk melihat bagaimana mereka bertindak, apa yang mereka lakukan.  Mereka bermain dan terganggu, tetapi itu memberi kami informasi.  Beberapa mendorong kode tanpa sekali pun menjalankannya, dan segera jelas bahwa itu terlalu dini untuk pengembangan. <br><br><img src="https://habrastorage.org/webt/zy/j7/-d/zyj7-dtcxgbzsnlm6eiakic1pri.png"><br><br>  Bagaimana tampilannya di versi pertama.  Itu adalah layar utama dan dua laptop untuk pemain.  Semua ini menghubungi server, server menyimpan State dan menggeledahnya di antara semua klien yang terhubung.  Setiap layar adalah klien yang terhubung.  Laptop pemain adalah layar interaktif dari mana keadaan ini dapat diubah.  Layar terpasang dengan kaku ke satu server. <br><br><h2>  Kurangnya waktu </h2><br>  Kisah pertama yang saya temui dalam perkembangan ini adalah kisah yang saya miliki sangat sedikit waktu.  Secara harfiah dalam lima menit sebuah ide muncul, dalam lima detik sebuah nama diciptakan ketika diperlukan untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> di GitHub.  Saya bisa menghabiskan semuanya hanya empat jam di malam hari, mengambilnya bahkan dari istri saya.  Sebagai hasilnya, saya hanya memiliki tiga minggu sebelum konferensi untuk menyadari hal ini setidaknya.  Dan itu semua dimulai sehingga itu hanya perlu untuk datang dengan ide dalam kerangka brainstorming, dalam lima menit ide itu lahir: "Mari kita menulis semacam kecerdasan buatan untuk RPG di JS".  Itu keren, menyenangkan, saya bisa menerapkannya. <br><br><img src="https://habrastorage.org/webt/un/tq/kh/untqkhyleylozw4th97etc8grc0.png"><br><br>  Pada implementasi pertama, layar memiliki editor kode dan layar pertempuran, di mana pertempuran itu sendiri.  Phaser, Ace Editor, dan Node.js murni digunakan sebagai server tanpa kerangka kerja apa pun.  Apa yang saya sesali kemudian, tetapi kemudian tidak ada yang khusus diperlukan dari server. <br><br><img src="https://habrastorage.org/webt/_g/lz/uz/_glzuzkixm5rkvgffsvxc6i0txi.png"><br><br>  Saya berhasil menyadari kemudian Renderer, yang melukis pertempuran itu sendiri.  Bagian yang paling sulit adalah kotak pasir untuk kode JS, yaitu kotak pasir di mana semuanya seharusnya dieksekusi secara terpisah untuk setiap pemain.  Ada juga State sharing yang berasal dari server.  Para pemain entah bagaimana berubah keadaan, melemparkannya ke server, server mengirim sisanya ke soket web.  Server adalah sumber kebenaran, dan semua klien yang terhubung memercayai apa yang datang dari server. <br><br><h2>  Kotak pasir </h2><br>  Apa yang sangat sulit untuk menerapkan kotak pasir?  Faktanya adalah kotak pasir adalah seluruh dunia untuk kode di mana kode itu harus ada.  Artinya, Anda membuat baginya tentang dunia yang sama seperti di sekitar, tetapi hanya terdiri dari beberapa konvensi, dari API yang dengannya Anda dapat berinteraksi.  Bagaimana cara mengimplementasikan ini di JS?  Tampaknya JS tidak mampu melakukan ini, sangat penuh lubang dan gratis sehingga tidak akan berfungsi untuk sepenuhnya memasukkan kode pengguna dalam kotak tanpa menggunakan mesin virtual terpisah dengan OS yang terpisah. <br><br><img src="https://habrastorage.org/webt/gb/ok/yi/gbokyimz5h1piufn5yfoudov554.png"><br><br>  Apa yang harus dilakukan kotak pasir? <br><br>  Pertama, seperti yang saya katakan, pisahkan kodenya.  Itu haruslah sebuah dunia yang darinya orang tidak bisa keluar. <br><br>  Juga, API manajemen unit harus dibuang di sana.  Pemain harus berinteraksi dengan medan perang, memindahkan unit, mengarahkan mereka, memberi mereka vektor serangan. <br>  Dan setiap tindakan unit asinkron, yaitu, entah bagaimana itu harus bekerja dengan kode asinkron. <br><br><img src="https://habrastorage.org/webt/or/q1/y1/orq1y1fcofatt5oz2qieinaixay.png"><br><br>  Apa yang ingin saya katakan tentang asinkron?  Faktanya adalah bahwa di JS pada dasarnya diimplementasikan menggunakan janji-janji.  Semuanya jelas bagi semua orang di sini, janji adalah hal yang hebat, mereka bekerja dengan sempurna, kita hampir selalu bersama kita.  Selama bertahun-tahun, semua orang tahu cara bekerja dengan mereka, tetapi mainan ini bukan hanya untuk javascript.  Bayangkan jika saya mulai menjelaskan kepada orang Jawa bagaimana menulis kode pertempuran menggunakan janji?  Bagaimana melakukannya kemudian-kemudian-kemudian, mengapa kadang-kadang tidak perlu ... Apa yang harus dilakukan dengan kondisi atau loop? <br><br><img src="https://habrastorage.org/webt/z2/qn/ir/z2qnirhdy_puuuliwdnfu0sxalg.png"><br><br>  Anda tentu saja dapat menggunakan cara terbaik dan mengambil sintaks async / menunggu.  [Slide 8:57] Tetapi bisakah Anda juga membayangkan bagaimana programmer non-javascript dapat menjelaskan bahwa Anda harus menunggu sebelum hampir setiap baris?  Akibatnya, cara terbaik untuk bekerja dengan asinkron adalah tidak menggunakannya sama sekali. <br><br><img src="https://habrastorage.org/webt/vm/yd/bi/vmydbi-ocp9npyl56wzqv-rnr4e.png"><br><br>  Buat kode paling sinkron dan API paling sederhana, mirip dengan hampir semua bahasa pemrograman.  Kami membuat mainan tidak hanya untuk orang-orang yang menulis dalam JS, kami ingin membuatnya dapat diakses oleh semua orang yang tahu cara membuat kode. <br><br><img src="https://habrastorage.org/webt/ng/et/2d/nget2dl8vrmwwi3y608ztrpn2pk.png"><br><br>  Kita semua harus memulainya.  Pengguna menulis kode, dan kita perlu menjalankannya, memindahkan unit di peta.  Hal pertama yang terlintas dalam pikiran adalah bahwa kita membutuhkan eval () plus pernyataan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak direkomendasikan</a> , yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak direkomendasikan untuk digunakan pada MDN</a> .  Ini akan berhasil, tetapi ada masalah. <br><br><img src="https://habrastorage.org/webt/ca/18/5a/ca185aygesba1t6wuxfymhvkghi.png"><br><br>  Sebagai contoh, kami memiliki kode yang benar-benar menghancurkan seluruh ide kami, yang mencegah kami dari melakukan sesuatu yang lebih jauh.  Ini adalah kode yang memblokir eksekusi.  Sesuatu harus dilakukan agar pengguna tidak dapat memblokir aplikasi.  Misalnya, loop tanpa akhir dapat merusak segalanya.  Jika peringatan () dan prompt () masih dapat didefinisikan ulang, maka kami tidak dapat mendefinisikan ulang loop yang tak terbatas sama sekali. <br><br><h2>  eval () jahat </h2><br>  Jadi kita sampai pada titik di mana eval () jahat.  Bukan untuk apa-apa mereka menyebutnya jahat, karena itu adalah fungsi berbahaya yang sebenarnya menggabungkan semua yang paling bebas dan terbuka yang ada di JS, dan membuat kita benar-benar tidak berdaya.  Dengan satu fungsi sederhana, kami membuat lubang besar dalam aplikasi kami. <br><br><img src="https://habrastorage.org/webt/-e/1s/yv/-e1syve2mujeqy_vpnr3obdk7sk.png"><br><br>  Tetapi bagaimana jika saya memberi tahu Anda, <i>[dalam suara Steve Jobs]</i> bahwa kami menemukan kembali eval ()? <br><br>  Kami melakukan eval () pada teknologi lain, kerjanya hampir sama dengan eval yang sama () yang sudah kami miliki.  Bahkan, saya memiliki fungsi eval () dalam kode saya, tetapi diimplementasikan menggunakan Pekerja, pernyataan with, dan Proxy. <br><br><img src="https://habrastorage.org/webt/wf/gj/ox/wfgjoxy3qrjkfnrnpvq-o06xr8k.png"><br><br>  Mengapa pekerja?  Faktanya adalah mereka membuat utas eksekusi yang terpisah, yaitu, JS adalah utas tunggal, tetapi berkat pekerja kita bisa mendapatkan utas lain.  Ini memberi kita banyak manfaat.  Misalnya, dalam loop tak berujung yang sama, kita dapat menyela utas yang dibuat melalui pekerja dari utas utama, mungkin ini adalah alasan utama mengapa saya menggunakan pekerja.  Jika pekerja berhasil bekerja lebih cepat daripada dalam satu detik, kami menganggapnya berhasil, kami mendapatkan hasilnya.  Jika tidak, maka kita potong saja.  Bahkan, kode pengguna untuk beberapa alasan tidak berfungsi, beberapa kesalahan aneh terjadi, atau diperlambat karena perulangan tak terbatas.  Banyak hari ini mencoba menulis sementara (benar), saya memperingatkan bahwa ini tidak akan berhasil. <br><br><img src="https://habrastorage.org/webt/ee/en/va/eeenvauyaknpsa7hizr52fvkcwk.png"><br><br>  Untuk menulis pekerja kami, kami hanya perlu memberi makan skrip ke konstruktor pekerja, yang akan diunduh melalui http.  Di dalam skrip, kita perlu membuat penangan pesan dari utas utama.  Menggunakan fungsi postMessage () di dalam pekerja, kita bisa merutekan pesan ke utas utama.  Dengan cara ini kami melakukan komunikasi antara dua utas.  API sederhana yang cukup nyaman, tetapi ada sesuatu yang hilang di dalamnya, yaitu kode pengguna yang harus kita laksanakan pada pekerja ini.  Kami tidak akan setiap kali membuat file skrip di server dan memberikannya kepada pekerja. <br><br><img src="https://habrastorage.org/webt/u2/4h/ia/u24hian_cjbwwi-06mtfn6qldmo.png"><br><br>  Saya menemukan cara menggunakan URL.createObjectURL ().  Kami membuat blok dan memberi makan kepada pekerja src.  Dengan demikian, itu membongkar kode kami langsung dari baris.  Ngomong-ngomong, cara ini berfungsi dengan objek apa pun di DOM yang memiliki src-image berfungsi seperti ini, misalnya, dan bahkan dalam iframe Anda dapat memuat html hanya dengan membuatnya dari string.  Cukup keren dan fleksibel, saya pikir.  Kami juga dapat mengelola pekerja dengan hanya mengirimkannya objek kami yang dibuat khusus dari URL.  Kami juga dapat menghentikannya dan sudah berfungsi sesuai kebutuhan, dan kami membuat kotak pasir pertama. <br><br><img src="https://habrastorage.org/webt/mq/kp/mk/mqkpmkw8-ufofb05g8qb94-mzm4.png"><br><br>  Interaksi asinkron lebih jauh, karena setiap pekerjaan dengan pekerja asinkron.  Kami mengirim beberapa pesan, dan kami tidak dapat secara sinkron menunggu pesan berikutnya, pekerja hanya mengembalikan contoh kepada kami, dan kami dapat berlangganan pesan.  Kami menangkap pesan menggunakan RxJS, kami membuat dua utas: satu untuk pesan yang berhasil dari pekerja, yang kedua untuk diselesaikan dengan batas waktu.  Dua utas yang kemudian kami kontrol dengan penggabungannya. <br><br><img src="https://habrastorage.org/webt/-x/mt/ny/-xmtnyqc5ytkd6w2zkzdeqfgsws.png"><br><br>  RxJS memiliki operator yang memungkinkan kami untuk bekerja dengan utas.  Bahkan, itu seperti lodash untuk operasi sinkron.  Kami dapat menunjukkan beberapa fungsi dan tidak berpikir tentang bagaimana itu diterapkan di dalam, itu membebaskan kita dari sakit kepala.  Kita perlu mulai berpikir dalam utas, operator gabungan menggabungkan utas kami, menanggapi pesan apa pun.  Ini akan merespon baik timeout dan pesan.  Kami hanya membutuhkan pesan pertama, masing-masing, setelah pesan pertama kami memberhentikan pekerja.  Jika terjadi kesalahan, cetak kesalahan ini, jika berhasil, kami menyelesaikannya. <br><br><img src="https://habrastorage.org/webt/l0/fj/lr/l0fjlrbzawogdkbhwkwkci-1osi.png"><br><br>  Semuanya sangat sederhana di sini.  Kode kami menjadi deklaratif, kompleksitas asynchrony pergi ke suatu tempat.  Yang utama adalah mempelajari operator ini. <br><br><img src="https://habrastorage.org/webt/mi/oc/ev/miocevejr1in0eyfg30wqmozb10.png"><br><br>  Ini adalah cara kami bekerja dengan API Unit.  Saya ingin Unit API sesederhana mungkin.  Berbicara tentang JS, banyak orang berpikir bahwa itu sulit, Anda harus naik ke suatu tempat, belajar sesuatu.  Dan saya ingin membuatnya sesederhana mungkin: semua yang ada di wilayah global, hanya ada ruang lingkup API Unit, tidak lebih.  Semuanya untuk manajemen unit, bahkan pelengkapan otomatis. <br><br><img src="https://habrastorage.org/webt/nl/-c/v8/nl-cv8_2s_3134omu8mqeanuiis.png"><br><br>  [Slide 15:20] Solusinya menunjukkan sendiri bahwa semua ini dapat didorong ke dalam pernyataan yang sangat terlarang.  Mari kita pahami mengapa itu dilarang. <br><br>  Faktanya adalah bahwa dengan memiliki masalah.  Misalnya, dengan, sayangnya, ada kebocoran di luar cakupan yang kami masukkan ke dalamnya, karena ia mencoba untuk melihat lebih dalam dari API Unit dan melihat ke dalam lingkup global. <br><br><img src="https://habrastorage.org/webt/tt/hw/gg/tthwggh1janwscz0t9poham_x44.png"><br>  Di sini contoh terakhir sangat keren, karena bahkan empat bisa berbahaya untuk kode kita, karena semua fungsi ini dapat dilakukan oleh kode pengguna.  Pengguna dapat melakukan apa saja.  Ini adalah permainan untuk programmer, dan mereka suka menjelajahi masalah dan cara meretas sesuatu. <br><br><img src="https://habrastorage.org/webt/b4/e0/hb/b4e0hbfhxr1l7xn51miw-qk8bzk.png"><br><br>  Seperti yang saya katakan, cakupan sangat bocor, sehingga cakupan global selalu tersedia.  Tidak peduli berapa banyak cakupan yang kami teliti pada kode kustom kami, tidak peduli berapa banyak cakupan yang kami bungkus, cakupan global akan tetap terlihat.  Dan semua karena dengan. <br><br>  Bahkan, itu tidak mengisolasi apa pun, itu hanya menambah kita lapisan abstraksi baru, ruang lingkup global baru.  Tapi kita bisa mengubah perilaku ini dengan Proxy. <br><br><img src="https://habrastorage.org/webt/zz/ed/qq/zzedqqwgeq-gxquunu4_ypeatak.png"><br><br>  Faktanya adalah bahwa Proxy mencari semua panggilan kami ke objek yang diproksi melalui API baru, dan kami dapat mengontrol bagaimana perilaku permintaan data baru dalam objek ini. <br><br><img src="https://habrastorage.org/webt/1u/lh/xa/1ulhxahfzy_yahdczgj7jbmacaw.png"><br><br>  Bahkan, dengan bekerja cukup sederhana.  Ketika kami memberinya beberapa jenis variabel, ia memeriksa di bawah kap apakah variabel ini ada di objek (yaitu, ia mengeksekusi operator in), dan jika demikian, ia menjalankannya di objek, dan jika tidak, ia mengeksekusi di lingkup atas, di Kasus kami bersifat global.  Cukup sederhana di sini.  Hal utama yang membantu proxy kami adalah bahwa kami dapat mengesampingkan perilaku ini. <br><br><img src="https://habrastorage.org/webt/c0/jg/ie/c0jgie64g9zgd4fukgnjadkj2g4.png"><br><br>  Ada yang namanya kait di Proxy.  Suatu hal yang luar biasa yang memungkinkan kita untuk mem-proxy setiap permintaan ke objek.  Kita dapat mengubah perilaku permintaan atribut, mengubah perilaku pekerjaan atribut, dan yang paling penting, kita dapat mengubah perilaku ini di operator.  Ada kait memiliki, yang kita dapat mengembalikan hanya benar.  Dengan demikian, kami mengambil dan sepenuhnya menipu pernyataan kami, membuat API kami jauh lebih aman dari sebelumnya. <br><br><img src="https://habrastorage.org/webt/4w/-n/vy/4w-nvyhnsledhvcyl0tetw33hvq.png"><br><br>  Jika kita mencoba menjalankan eval (), dia pertama kali akan menanyakan apakah eval () ini ada di unitApi, mereka akan menjawab "ya" dan mendapatkan "undefined bukan fungsi".  Ini tampaknya pertama kalinya saya senang dengan kesalahan ini!  Kesalahan ini persis apa yang seharusnya kita terima.  Kami mengambilnya dan memberi tahu pengguna: "Maaf, lupakan semua yang Anda ketahui tentang objek jendela, ini tidak ada lagi."  Kami telah meninggalkan beberapa masalah, tetapi bukan itu saja. <br><br><img src="https://habrastorage.org/webt/fo/yw/a2/foywa2mzbpbijvc3ndgpq-9tpxw.png"><br><br>  Faktanya adalah bahwa pernyataan with all sama dari JS, JS dinamis dan sedikit aneh.  Yang aneh adalah bahwa tidak semuanya berjalan seperti yang kita inginkan, tanpa melihat spesifikasi.  Faktanya adalah bahwa dengan juga bekerja dengan properti prototipe.  Artinya, kita bisa dengan mudah memberi dia sebuah array, jalankan kode tidak jelas ini.  Semua fungsi array tersedia secara global dalam lingkup ini, yang terlihat agak aneh. <br><br><img src="https://habrastorage.org/webt/ih/2g/yr/ih2gyrz7isyixyvx7bswlamgvbe.png"><br><br>  Ini tidak penting bagi kami, penting bagi kami bahwa pengguna dapat mengeksekusi valueOf () dan mendapatkan semua kotak pasir kami.  Langsung ambil dan angkat, lihat apa isinya.  Saya juga tidak ingin ini, jadi hal yang menarik diperkenalkan ke dalam spesifikasi: Symbol.unscopables.  Yaitu, dalam spesifikasi baru untuk simbol, Symbol.unscopables diperkenalkan khusus untuk pernyataan with, yang dilarang.  Karena mereka percaya ada orang lain yang menggunakannya.  Misalnya, saya! <br><br><img src="https://habrastorage.org/webt/fv/9o/ns/fv9ons58tbtnrnc5rp7biuexgfk.png"><br><br>  Jadi, kita akan membuat interseptor lain, di mana kita secara khusus memeriksa untuk melihat apakah simbol ini ada dalam daftar semua atribut yang tidak dapat dicopot.  Jika tidak, maka kembalikan, tetapi jika demikian, maka maaf, kami tidak akan kembali.  Kami juga tidak menggunakannya.  Dan karenanya, dengan kita bahkan tidak bisa mendapatkan prototipe kotak pasir kita. <br><br><img src="https://habrastorage.org/webt/07/5h/tt/075httw1dt0ekhe37frcstztzri.png"><br><br>  Kami masih memiliki lingkungan Pekerja.  Ini adalah sesuatu yang menggantung di area global dan masih dapat diakses.  Faktanya adalah bahwa jika Anda cukup menimpa ini, itu akan tersedia dalam prototipe.  Hampir semuanya bisa ditarik keluar melalui prototipe di JS.  Anehnya, semua metode ini masih tersedia melalui prototipe. <br><br><img src="https://habrastorage.org/webt/po/mt/fl/pomtflwlmxujubh-l8qzqqn2drg.png"><br><br>  Saya hanya harus mengambil dan membersihkan semua ini.  Kami melewati semua kunci dan membersihkan semuanya. <br><br><img src="https://habrastorage.org/webt/zg/9k/at/zg9katqtaothaqjip6trmosdig0.png"><br><br>  Dan kemudian kami meninggalkan sedikit telur Paskah untuk pengguna, yang masih mencoba menyebutnya.  Kami mengambil fungsi yang biasa, yang utama bukan fungsi panah, yang memiliki cakupan, dan mengubah cakupannya ke objek kami, di mana kami meninggalkan telur Paskah kecil untuk pengguna yang ingin tahu yang ingin menampilkan beberapa ini atau diri di konsol.  Saya percaya bahwa telur Paskah luar biasa dan harus dibiarkan dalam kode. <br><br><img src="https://habrastorage.org/webt/_s/7r/fq/_s7rfqdggfjikj2rjm7rcmhwja8.png"><br><br>  Lebih lanjut ternyata mereka hanya tersisa dengan API Unit kami.  Kami benar-benar memblokir semuanya - bahkan, meninggalkan daftar putih.  Kita perlu menambahkan API yang bermanfaat dan dibutuhkan.  Misalnya, API Matematika, yang memiliki fungsi acak berguna yang banyak digunakan orang ketika menulis kode untuk unit. <br><br>  Kita juga membutuhkan konsol dan banyak fungsi utilitarian lain yang tidak membawa fungsi destruktif.  Kami membuat daftar sementara untuk API kami.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini bagus, karena jika kami membuat daftar hitam, kami akan bergantung pada pembaruan peramban apa pun yang terjadi tanpa sepengetahuan kami. </font></font><br><br><img src="https://habrastorage.org/webt/nz/mc/0o/nzmc0or7a_svlqdlhcdg36_bzi8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan membuat daftar putih, kita dapat mulai menggunakan try-catch dalam kode kita. </font><font style="vertical-align: inherit;">Kode terbungkus kami telah menangkap kesalahan dan dapat mengirimkannya ke pengguna, yang sangat penting untuk debugging. </font></font><br><br><img src="https://habrastorage.org/webt/cl/pa/q1/clpaq1aarq_8svpxquxahgyrkym.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi kenyataannya adalah bahwa metode konsol dari Worker tidak memanifestasikan dirinya dalam kode pengguna. </font><font style="vertical-align: inherit;">Artinya, jika Anda membuka konsol dan masuk ke lingkungan pekerja, mereka akan tersedia, tetapi akan salah untuk memberi tahu pengguna "buka konsol dan lihat apa yang terjadi pada Anda". </font><font style="vertical-align: inherit;">Saya memutuskan untuk membuat konsol ramah untuk pemain, di mana pemain, bahkan tanpa pengalaman dalam JavaScript, dapat melihat dengan ramah apa yang terjadi.</font></font><br><br>  ,    , -   .      ,     .      ,         webpack   . <br><br><img src="https://habrastorage.org/webt/cl/pa/q1/clpaq1aarq_8svpxquxahgyrkym.png"><br><br>      patchMethod(),     ,     postMessage().    postMessage()   console log, error, warn, info.        ,    .  ,       &lt;div&gt;,      ,    ,      ,     ,        . <br><br><img src="https://habrastorage.org/webt/nf/oq/yw/nfoqywkngugbgug6i5wwv_tpuhy.png"><br><br>     ,      .      : -   -  â€”   ,     ,  -     . , ,    promises.   ,        actions,       . <br><br><img src="https://habrastorage.org/webt/jl/np/2f/jlnp2fcxsgtmghti8wzt4iwzbki.png"><br><br>          actions.   ,     real-time ?   ,  real-time    workers    ,        worker,       .       - ,    .    ,    , .   ,      ,   .        . <br><br><img src="https://habrastorage.org/webt/lk/zb/xp/lkzbxpal1f_bkmcq1pyk5sto8ey.png"><br><br>     workers,       .  workers ,           .      ,   .  ,     ,    (   ,  ),            .  :    â€” . <br><hr><br><h2>  Math.random() </h2><br>   ,   ,         ,     .      Math.random(). <br><br>     ,   ,      ,                   .   ,  Math.random()     - . <br><br><img src="https://habrastorage.org/webt/g5/xs/zj/g5xszjwvqxhjxp4slm1hfmdfct4.png"><br><br>  ,     ,        (   ), JS   ,        .         . <br><br><img src="https://habrastorage.org/webt/ds/ic/sy/dsicsy7ra1vb8fuzq6xkry7y9zg.png"><br><br>   ,              ,  ,          .       ,    - . <br><br>            ,      . ,        random(),     . <br><br><img src="https://habrastorage.org/webt/cp/ew/ou/cpewoullokdb8p903gddmmgguj8.png"><br><br>  ,  random()     â€”  Â« Â»      ,      .    ,    -  ,     random() ,       .    -    ,     .   ,          ,  random()    . <br><br><img src="https://habrastorage.org/webt/hu/tp/ot/hutpotesuqtwdc_p7yqelekwpjk.png"><br><br>       .    ,   ,   random()  .   - seed          (  ,        ,   ). <br><br><img src="https://habrastorage.org/webt/of/xs/da/ofxsdamysx7gcyfjgctqw1o72o0.png"><br>     ,     .            ,      random().                  ,  random()     -. <br><br>  <a href=""></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semua kode yang dikirim ke pekerja diperlukan untuk membuat JS sepenuhnya aman. </font><font style="vertical-align: inherit;">"Sisipan" oranye adalah kode pengguna yang sama. </font><font style="vertical-align: inherit;">yang disuntikkan di sana. </font><font style="vertical-align: inherit;">Itulah jumlah kode yang Anda perlukan untuk membuat JS aman. </font><font style="vertical-align: inherit;">Acak () dan API unit juga disuntikkan di sana. </font><font style="vertical-align: inherit;">Melalui suntikan, saya mendapatkan lebih banyak kode yang dikirim ke pekerja.</font></font><br><hr><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berbagi negara: RxJS, server dan klien </font></font></h2><br>  Jadi kami mencari tahu apa yang kami miliki dengan klien.  Sekarang mari kita bicara tentang berbagi negara, mengapa ini diperlukan dan bagaimana hal itu diatur.  Kami telah menyatakan disimpan di server, server harus meraba-raba dengan klien yang terhubung.  [Slide 28:48] <br><br>  Kami memiliki empat peran klien berbeda yang dapat terhubung ke server: "pengguna kiri", "pengguna kanan", pemirsa yang melihat layar utama, dan administrator yang dapat melakukan apa saja. <br><br>  Layar kiri tidak dapat mengubah status pemain yang tepat, pemirsa tidak dapat mengubah apa pun, dan admin dapat melakukan semuanya. <br><br><img src="https://habrastorage.org/webt/qo/nw/xz/qonwxz54aiudwbywh6msiilucss.png"><br><br>  Mengapa ini menjadi masalah?  Semuanya diatur dengan cukup sederhana.  Setiap klien yang terhubung dapat melakukan sesi, server menerimanya dan menggabungkannya dengan status, yang ada di dalam server dan kemudian mendistribusikannya ke semua klien.  Dia meraba-raba untuk setiap perubahan yang datang kepadanya.  Itu perlu untuk menyaringnya entah bagaimana. <br><br><img src="https://habrastorage.org/webt/th/ol/vu/tholvuuygb9shbr5-de-aemuxs8.png"><br><br>  Pertama, saya akan mengatakan mengapa server juga memiliki RxJS.  Semua interaksi dengan dua atau lebih pengguna yang terhubung menjadi tidak sinkron.  Kami harus menunggu hasil dari kedua pengguna.  Sebagai contoh, kedua pengguna mengklik tombol "Selesai", Anda harus menunggu keduanya untuk mengklik, dan hanya kemudian melakukan tindakan.  Itu semua sangat mudah pada RxJS dengan cara ini: <br><br><img src="https://habrastorage.org/webt/xa/dp/6z/xadp6zds6_xaucjyb7hdrpskcmu.png"><br><br>  Kami lagi beroperasi dengan utas, ada aliran dari soket, yang disebut soket.  Untuk membuat satu utas yang hanya memantau pemutar kiri, kami cukup mengambil dan memfilter pesan dari soket ini oleh pemain kiri (dan juga yang kanan).  Kemudian kita bisa menggabungkannya menggunakan operator forkJoin (), yang berfungsi seperti Promise.all () dan merupakan analognya.  Kami menunggu kedua tindakan ini dan memanggil metode setState (), yang membuat status kami "siap".  Ternyata kami menunggu kedua pemain dan mengubah status server.  Pada RxJS, ini keluar sebagai deklaratif mungkin, itulah sebabnya saya menggunakannya. <br><br>  Masih ada masalah dengan fakta bahwa para pemain dapat mengubah status satu sama lain.  Mereka harus dilarang melakukan ini.  Namun, mereka adalah programmer, ada preseden yang dicoba seseorang.  Mari kita buat kelas terpisah untuk mereka yang diwarisi dari Klien. <br><br><img src="https://habrastorage.org/webt/jz/9-/6v/jz9-6vskw2b3lqcf3fxasd2w4kq.png"><br><br>  Mereka akan memiliki logika dasar komunikasi pemain dengan server, dan di setiap kelas tertentu akan ada logika khusus untuk menyaring data. <br><br>  Klien sebenarnya adalah kumpulan koneksi, koneksi dengan klien. <br><br><img src="https://habrastorage.org/webt/sc/qz/kl/scqzklyflx8hylw3stj7drudpdy.png"><br><br>  Dia hanya menyimpannya dan memiliki aliran onUnsafeMessage, yang sama sekali tidak aman: dia tidak bisa dipercaya, ini hanya pesan mentah dari pengguna yang dia terima.  Kami menulis pesan mentah ini ke stream. <br><br>  Selanjutnya, ketika menerapkan pemain tertentu, kami mengambil ini diUnsafeMessage dan memfilternya. <br><br><img src="https://habrastorage.org/webt/yn/z0/1k/ynz01kbib00wt83k_5jwx5ix3ku.png"><br><br>  Kita hanya perlu memfilter data yang bisa kita dapatkan dari pemain ini, yang bisa kita percayai.  Pemain kiri hanya dapat mengubah keadaan pemain kiri, masing-masing, kami mengambil dari semua data yang bisa ia kirim, hanya keadaan pemain kiri.  Jika Anda tidak mengirimnya, oke.  Jika dikirim - kami terima.  Dengan demikian, dari pesan yang sama sekali tidak aman, kami mendapatkan pesan aman yang dapat kami percayai saat bekerja di ruangan. <br><br><img src="https://habrastorage.org/webt/g3/-a/dg/g3-adglwnncvagey8nojzmksixw.png"><br><br>  Kami memiliki ruang permainan yang menyatukan pemain.  Di dalam ruangan, kita bisa menulis fungsi yang bisa mengubah keadaan secara langsung, hanya dengan berlangganan aliran ini, yang sudah bisa kita percayai.  Kami mengabstraksi dari banyak cek.  Kami melakukan pemeriksaan berdasarkan peran, dan menyebutnya kelas terpisah.  Kami membagi kode sedemikian rupa sehingga di dalam controller, di mana fungsi penting dari mengubah keadaan dilakukan, kode tersebut telah menjadi sesederhana dan sesederhana mungkin. <br><br>  RxJS juga digunakan pada klien, itu terhubung ke soket di sisi sebaliknya, memancarkan peristiwa dan mengarahkan mereka dengan segala cara. <br><br>  Dalam hal ini, saya ingin memberi contoh ketika saya perlu mengubah pasukan musuh yang tepat. <br><br><img src="https://habrastorage.org/webt/qf/u8/oy/qfu8oy7syyrcekd2z424rxuhplw.png"><br><br>  Untuk berlangganan, kami membuat aliran dari soket yang sama dan memfilternya.  Kami memastikan bahwa ini benar-benar pemain yang tepat, dan menerima pesan darinya tentang pasukannya.  Jika tidak ada pesan seperti itu, streaming tidak akan mengembalikan apa pun, tidak akan ada satu pesan pun di dalamnya, itu akan tetap diam sampai pemain mengubah pasukan.  Kami segera memecahkan masalah pemfilteran secara deklaratif, kami tidak menganggapnya norak. <br><br>  Dan ketika sesuatu telah datang dari aliran, kami memanggil fungsi setState ().  Ini cukup sederhana, pendekatan yang memungkinkan kita melakukan segala sesuatu secara transparan dan deklaratif.  Hal yang saya ambil dari proyek RxJS dan apa yang sangat membantu saya. <br><br><img src="https://habrastorage.org/webt/gy/p9/qc/gyp9qchh3hadurc4_vmg0vjj1u4.png"><br><br>  Saya membuat utas yang saya punya nama yang cukup jelas, yang saya mengerti cara bekerja, semuanya deklaratif, fungsi-fungsi yang diperlukan dipanggil, tidak ada keributan dengan banyak jika dan peristiwa penyaringan, semua ini dilakukan oleh RxJS. <br><br><h2>  Sejarah: dari satu pemain ke multipemain </h2><br><br>  Jadi, versi pertama mainan saya ditulis.  Kita dapat mengatakan bahwa itu adalah pemain tunggal, karena hanya dua pemain yang dapat memainkannya, jumlah klien yang terhubung telah diperbaiki.  Kami memiliki pemain kiri, pemain kanan dan layar di belakang, semua ini terhubung langsung ke server.  Semuanya sudah dikeraskan, namun dalam tiga minggu hal itu dilakukan. <br><br>  Saya menerima tawaran baru: untuk memperluas mainan untuk semua programmer di perusahaan sehingga mereka dapat membuka dan memainkannya di komputer mereka.  Sehingga kami mendapatkan daftar pemimpin, multipemain sehingga mereka bisa bermain bersama.  Kemudian saya menyadari bahwa saya memiliki banyak refactoring. <br><br><img src="https://habrastorage.org/webt/qy/vs/-k/qyvs-khwziiaiv8xyfsnvcrlark.png"><br><br>  Ternyata tidak begitu sulit.  Saya hanya menggabungkan semua entitas yang saya miliki ke kamar yang terpisah.  Saya mendapat esensi "Kamar", yang bisa menggabungkan semua peran.  Sekarang bukan pemain itu sendiri yang berkomunikasi langsung dengan server, tetapi kamar.  Kamar-kamar sudah memproksikan permintaan langsung ke server, mengganti status, dan status telah terpisah untuk setiap kamar. <br><br><img src="https://habrastorage.org/webt/cc/au/tt/ccautts_bfhkftuja4joqqeg9vm.png"><br><br>  Saya mengambil dan menulis ulang semuanya, menambahkan daftar pemimpin, kami memberikan yang terbaik dengan hadiah.  Itu hanya perlu memiliki sejumlah besar pengguna, itu sudah tidak mungkin untuk mengikuti semua orang, itu perlu untuk menulis sesuatu di mana mengumpulkan semua data. <br><br><h2>  JS Gamedev dan masalahnya </h2><br><br>  Dengan demikian, saya menjadi lebih serius berkenalan dengan JS-gamedev.  Saya melakukan waddle tentang proyek terakhir selama sekitar tiga tahun, beristirahat secara berkala.  Dan di sini saya mengalami dua kali selama tiga minggu.  Setiap hari saya duduk dan melakukan sesuatu di malam hari. <br><br>  Apa masalah yang ada dalam mengembangkan game di JS?  Semuanya berbeda dari aplikasi bisnis kami, di mana tidak masalah untuk menulis sesuatu dari awal.  Selain itu, banyak yang bahkan disambut: kita akan melakukan hal kita sendiri, mengingat cerita dengan NPM dan meninggalkan sendiri. <br><br><img src="https://habrastorage.org/webt/f6/6l/zc/f66lzct-hy9vzyyixqvuplcd2qk.png"><br><br>  Tidak mungkin untuk melakukan ini di JS Gamedev, karena semua teknologi untuk menampilkan grafik sangat rendah sehingga secara ekonomis tidak menguntungkan untuk menulis sesuatu pada mereka.  Jika saya mengambil mainan ini dan mulai menulisnya dari awal di WebGL, saya juga akan duduk di belakangnya selama sekitar enam bulan, hanya mencoba mencari tahu beberapa bug aneh.  Mesin permainan paling populer Phaser menghapus masalah ini dari saya ... <br><br><img src="https://habrastorage.org/webt/x1/zs/aa/x1zsaafnaxys0r9tssldvcper38.png"><br><br>  ... dan menambahkan yang baru kepada saya: 5 megabita dalam satu bundel.  Dan tidak ada yang bisa dilakukan tentang itu, dia tidak tahu apa itu treeshaking sama sekali.  Selain itu, hanya versi terbaru dari Phaser yang dapat bekerja dengan webpack dan bundel.  Sebelum ini, Phaser hanya terhubung di tag html dari skrip, itu aneh bagi saya. <br><br>  Saya berasal dari semua jenis skrip webpacks, dan dalam game JS dev, hampir tidak ada yang bisa melakukannya.  Semua modul memiliki ketikan yang sangat buruk atau tidak memilikinya sama sekali, atau pada dasarnya tidak tahu cara menggunakan webpack, perlu untuk menemukan cara untuk membungkusnya.  Ternyata, bahkan Ace Editor dalam bentuknya yang murni tidak bekerja dengan webpack sama sekali.  Untuk mulai bekerja, Anda perlu mengunduh paket terpisah yang sudah dibungkus (brace). <br><br>  Itu hampir sama dengan Phaser, tetapi dalam versi baru mereka melakukannya lebih atau kurang normal.  Saya terus menulis di Phaser dan menemukan cara membuat semuanya berfungsi dengan webpack seperti dulu: mengetik dan tes bisa dilampirkan ke semua ini.  Saya menemukan bahwa Anda dapat mengambil <a href="">PixiJS</a> secara terpisah, yang merupakan render webpack, dan menemukan banyak modul untuknya yang siap untuk bekerja dengannya. <br><br><img src="https://habrastorage.org/webt/cz/cf/o7/czcfo7ib3-d7n3w-l1rpzxfo8cw.png"><br><br>  PixiJS adalah pustaka hebat yang dapat di-render baik di WebGL atau di Kanvas.  Selain itu, Anda bahkan dapat menulis kode seolah-olah untuk Canvas, dan itu akan dirender di WebGL.  Pustaka ini dapat membuat 2D dengan sangat cepat.  Hal utama adalah mengetahui cara kerjanya dengan memori, agar tidak jatuh ke posisi ketika memori selesai. <br><br>  Saya secara terpisah merekomendasikan repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">awesome-pixijs</a> di GitHub, di mana Anda dapat menemukan berbagai modul.  Kebanyakan saya suka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React-pixi</a> .  Kita bisa mengabaikan pemecahan masalah dengan tampilan ketika kita menulis fungsi imperatif langsung di controller untuk menggambar bentuk geometris, sprite, animasi, dan banyak lagi.  Kita semua dapat menandai di BEJ.  Kami datang dari dunia JSX dengan aplikasi bisnis kami dan dapat menggunakannya lebih lanjut.  Itulah yang saya suka abstraksi.  React-pixi memberi kita abstraksi yang akrab ini. <br><br>  Saya juga menyarankan Anda untuk mengambil tween.js - mesin animasi terkenal yang sama dari Phaser, yang memungkinkan Anda membuat animasi deklaratif yang agak mirip dengan animasi CSS: kami membuat transisi antar negara, dan tween.js memutuskan bagi kami cara memindahkan objek secara tepat. <br><br><h2>  Jenis pemain: siapa mereka dan bagaimana berteman dengan mereka </h2><br>  Saya menemukan pemain yang berbeda, dan saya juga ingin memberi tahu Anda tentang pengujian mainan.  Saya mengumpulkan rekan-rekan di satu ruangan tertutup dan tidak membiarkan mereka keluar sampai mereka menyelesaikan permainan.  Sayangnya, tidak semua orang bisa menyelesaikan permainan, karena pada awalnya saya punya banyak bug.  Untungnya, saya mulai menguji segera setelah setidaknya beberapa prototipe yang berfungsi muncul.  Jujur, tes pertama gagal karena beberapa pemain tidak memulai apa pun.  Itu memalukan, tetapi memberi saya tendangan yang memungkinkan saya untuk melanjutkan. <br><br>  Saat mainan Anda siap, Anda dapat diterima dengan sangat baik, atau dengan garpu rumput dan obor.  Semua orang menunggu penggemar dari game, menunggu kebahagiaan yang akan Anda berikan kepada mereka.  Dan Anda memberi mereka sesuatu yang tidak berfungsi sama sekali, meskipun tampaknya itu bekerja untuk Anda.  Ketika Anda memiliki mainan online, bahkan ada lebih banyak bug seperti itu. <br><br>  Sebagai hasilnya, orang-orang yang paling menyenangkan yang saya temui adalah "peneliti" yang selalu menemukan lebih banyak mainan Anda daripada yang sebenarnya.  Mereka dapat dengan senang hati menambahkannya dengan segala macam hal kecil, mendorong Anda untuk menambahkan sesuatu.  Namun, sayangnya, komunikasi dengan orang-orang ini tidak memberikan hal yang penting - stabilitas mainan. <br><br>  Ada pemain biasa yang datang semata-mata demi kipas.  Mereka kadang-kadang bahkan tidak menyadari adanya serangga, entah bagaimana menyelinap masuk dalam perjalanan menuju kesenangan. <br><br>  Kategori lain adalah pengumpul bug, yang hampir semuanya tidak berfungsi.  Orang-orang ini perlu menjadi teman, meskipun mereka akan berbicara banyak hal negatif.  Kami perlu memulai hubungan aneh dengan mereka: mereka menyakiti Anda, dan Anda mencoba mengambil sesuatu yang berguna bagi diri Anda dari mereka, "mari duduk di depan komputer Anda dan lihat."  Anda perlu bekerja dengan mereka, karena pada akhirnya orang-orang inilah yang akan membuat kualitas permainan Anda. <br><br>  Anda hanya perlu menguji orang yang masih hidup.  Mata Anda kabur, dan pengujian pasti akan menunjukkan apa yang disembunyikan.  Anda mengembangkan mainan dan menyelam lebih dalam, menggergaji beberapa fitur, tetapi bahkan mungkin tidak diperlukan.  Anda pergi langsung ke konsumen Anda, menunjukkan kepada mereka dan menonton bagaimana mereka bermain, tombol mana yang mereka tekan.  Ini memberi Anda insentif untuk melakukan apa yang Anda butuhkan.  Anda melihat bahwa beberapa orang terus-menerus menekan Ctrl + S, karena mereka terbiasa menyimpan kode - yah, setidaknya membuat kode berjalan pada Ctrl + S, pemain akan merasa lebih nyaman.  Anda perlu menciptakan lingkungan yang nyaman bagi pemain, untuk ini Anda harus mencintainya dan mengikutinya. <br><br>  Aturan 80/20 bekerja: Anda membuat demo 20% dari seluruh waktu pengembangan game, dan untuk pemain sepertinya 80% permainan selesai.  Persepsi berfungsi sehingga mekanika dasar siap, semuanya bergerak dan berfungsi, yang artinya game hampir siap, dan pengembang akan segera menyelesaikannya.  Namun pada kenyataannya, pengembang masih memiliki jalan keluar dari 80%.  Seperti yang saya katakan, untuk waktu yang lama saya harus mengerjakan dokumentasi sehingga bisa dimengerti oleh semua orang.  Saya menunjukkannya kepada banyak orang yang mengucapkan komentar mereka, saya menyaringnya, mencoba memahami esensi dari pernyataan itu.  Dan banyak waktu yang saya perlukan untuk mencari bug. <br><br>  Jadi dalam pengembangan game, saya hanya bisa menyarankan Anda untuk melakukan demo: mereka menyenangkan semua orang, tidak memerlukan banyak waktu, dan tidak ada yang benar-benar mengharapkan apa pun dari demo.  Menyelesaikan permainan adalah proses yang membosankan, tetapi memulai itu bagus. <br><br>  Akhirnya, saya meninggalkan Anda tautan: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori dengan permainan dan instruksi untuk peluncuran</a> (saya akan senang untuk menggabungkan permintaan jika Anda menemukan bug) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phaser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengagumkan-pixijs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Server game multiplayer Colyseus</a> (saya sendiri yang menulis multiplayer, dan kemudian saya melihat server yang sudah selesai dengan kamar) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Editor Ace</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyajian laporan ini</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konferensi berbahasa Rusia di mana Anda dapat mengirimkan laporan</a> </li></ul><br><blockquote>  <b>HolyJS 2019 Piter</b> , sebuah konferensi untuk pengembang JavaScript, akan diadakan 24-25 Mei di St. Petersburg.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembicara pertama</a> sudah muncul di situs. <br>  Anda juga dapat mengajukan permohonan laporan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Call for Papers</a> buka hingga 11 Maret. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Harga</a> tiket akan naik pada 1 Februari. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436586/">https://habr.com/ru/post/id436586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436568/index.html">Platform video sendiri atau cara mengambil banyak sumber daya komputasi. Bagian 1</a></li>
<li><a href="../id436570/index.html">Eksorsisme Programmer</a></li>
<li><a href="../id436572/index.html">Skolkovo Cybersecurity Challenge 2019 Kompetisi Proyek Cybersecurity</a></li>
<li><a href="../id436578/index.html">Harga keamanan pribadi untuk direktur perusahaan IT besar per tahun</a></li>
<li><a href="../id436584/index.html">Hukum Manajemen Runet - implementasi ketentuan dan bidang tanggung jawab</a></li>
<li><a href="../id436588/index.html">MegaSlerm di Moskow pada awal Juni: pengumuman dan diskon pertama</a></li>
<li><a href="../id436590/index.html">Kiat untuk pelanggan fungsional. Tekan Î” untuk membaca</a></li>
<li><a href="../id436592/index.html">Backend di Komponen File Tunggal VueJS</a></li>
<li><a href="../id436594/index.html">Selamat tinggal Chevy Volt: Cerita dan Legenda Hibrida yang Dapat Diisi Ulang</a></li>
<li><a href="../id436596/index.html">Pengembang tumpukan penuh sebenarnya terjebak di tingkat menengah. Bebaskan diri Anda dari penderitaan - jangan menempuh jalan itu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>