<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😖 👩🏾‍🤝‍👩🏻 🔉 Eintauchen in den Fahrer: das allgemeine Prinzip des Rückwärtsfahrens am Beispiel der Aufgabe NeoQUEST-2019 📚 😚 🚽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie alle Programmierer lieben Sie Code. Du und er sind beste Freunde. Aber früher oder später im Leben wird es einen solchen Moment geben, in dem kein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eintauchen in den Fahrer: das allgemeine Prinzip des Rückwärtsfahrens am Beispiel der Aufgabe NeoQUEST-2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/neobit/blog/446462/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/w3/1t/qlw31t-4mz--bhpo4qa81o_ptse.gif"></div><br>  Wie alle Programmierer lieben Sie Code.  Du und er sind beste Freunde.  Aber früher oder später im Leben wird es einen solchen Moment geben, in dem kein Code bei Ihnen ist.  Ja, es ist schwer zu glauben, aber es wird eine große Lücke zwischen Ihnen geben: Sie sind draußen und er ist tief drinnen.  Aus Hoffnungslosigkeit müssen Sie, wie jeder andere auch, auf die andere Seite gehen.  Auf der Seite des Reverse Engineering. <br><br>  Am Beispiel der Aufgabe Nr. 2 aus der Online-Phase von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NeoQUEST-2019 werden</a> wir das allgemeine Prinzip des Reverse-Treiber-Windows analysieren.  Natürlich ist das Beispiel ziemlich vereinfacht, aber das Wesentliche des Prozesses ändert sich nicht davon - die einzige Frage ist die Menge an Code, die angezeigt werden muss.  Mit Erfahrung und Glück können wir loslegen! <a name="habracut"></a><br><h2>  Gegeben </h2><br>  Der Legende nach erhielten wir zwei Dateien: einen Verkehrsdump und eine Binärdatei, die denselben Verkehr erzeugten.  Schauen Sie sich zunächst die Müllkippe mit Wireshark an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xb/4k/gs/xb4kgshocgnwhickftcvukhjqtk.png"></div><br>  Der Speicherauszug enthält einen Strom von UDP-Paketen, von denen jedes 6 Byte Daten enthält.  Diese Daten sind auf den ersten Blick eine zufällige Menge von Bytes - es ist nicht möglich, etwas aus dem Verkehr herauszuholen.  Deshalb wenden wir uns dem Binar zu, das Ihnen sagen soll, wie Sie alles entschlüsseln können. <br>  Öffnen Sie es in der IDA: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pp/v_/cq/ppv_cqotco3m7vjdjxdwyxmmqpc.png"></div><br>  Es scheint, dass wir vor einer Art Fahrer stehen.  Funktionen mit dem WSK-Präfix beziehen sich auf Winsock Kernel, die Netzwerkprogrammierschnittstelle im Windows-Kernelmodus.  Auf MSDN sehen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> Beschreibung der in WSK verwendeten Strukturen und Funktionen. <br><br>  Zur Vereinfachung können Sie das Windows Driver Kit 8 (Kernelmodus) - wdk8_km (oder eine neuere) Bibliothek in die IDA laden, um die dort definierten Typen zu verwenden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zf/8e/gu/zf8egusvoa5plmcn2uadxwtmapk.png"></div><br><h2>  Achtung, umgekehrt! </h2><br>  Beginnen Sie wie immer am Einstiegspunkt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z6/ry/e1/z6rye1bxurfesyaglba_f_4q9aq.png"></div><br>  Lass uns in Ordnung gehen.  Zunächst wird Wsk initialisiert, ein Socket erstellt und gebunden - wir werden diese Funktionen nicht im Detail beschreiben, sie enthalten keine Informationen, die für uns nützlich sind. <br><br>  Die Funktion sub_140001608 setzt 4 globale Variablen.  Nennen wir es InitVars.  In einem von ihnen wird ein Wert an die Adresse 0xFFFFF78000000320 geschrieben.  Wenn wir diese Adresse ein wenig googeln, können wir davon ausgehen, dass sie die Anzahl der Ticks des System-Timers ab dem Zeitpunkt des Systemstarts aufzeichnet.  Nennen wir zunächst die Variable TickCount. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e5/7_/2x/e57_2xuaa7zyx0fxfz7ebyc9kqu.png"></div><br>  EntryPoint richtet dann Funktionen zur Verarbeitung von IRP-Paketen ein (E / A-Anforderungspaket).  Sie können mehr darüber auf MSDN <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen</a> .  Für alle Arten von Anforderungen wird eine Funktion definiert, die das Paket einfach an den nächsten Treiber im Stapel weiterleitet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b3/xj/sa/b3xjsa1qqtxxc-r7zydxxlzu48w.png"></div><br>  Für den Typ IRP_MJ_READ (3) ist jedoch eine separate Funktion definiert;  Nennen wir es IrpRead. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gi/a1/5y/gia15yhygs63v9qm5nooaxboay4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hu/yd/9w/huyd9wgps6ubfztj72vrfl3pxfm.png"></div><br>  Darin ist wiederum CompletionRoutine installiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2l/5o/wq/2l5owqwqa0pqcmy3zrbfnen1h28.png"></div><br>  CompletionRoutine füllt die unbekannte Struktur mit Daten, die vom IRP empfangen wurden, und fügt sie in die Liste ein.  Bisher wissen wir nicht, was sich im Paket befindet - wir werden später auf diese Funktion zurückkommen. <br>  Wir schauen weiter in EntryPoint.  Nach dem Definieren der IRP-Handler wird die Funktion sub_1400012F8 aufgerufen.  Lassen Sie uns nach innen schauen und sofort feststellen, dass ein Gerät (IoCreateDevice) darin erstellt wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xn/bv/hg/xnbvhgsku6con1ppuedpwuo2kw8.png"></div><br>  Rufen Sie die Funktion AddDevice auf.  Wenn die Typen korrekt sind, sehen wir, dass der Gerätename "\\ Gerät \\ KeyboardClass0" lautet.  Unser Treiber interagiert also mit der Tastatur.  Wenn Sie im Kontext der Tastatur über IRP_MJ_READ googeln, können Sie feststellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> dass die KEYBOARD_INPUT_DATA-Struktur in Paketen übertragen wird.  Kehren wir zu CompletionRoutine zurück und sehen, welche Art von Daten übergeben werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/hi/rc/y1hirc1v347d7sqvedm0__ht01m.png"></div><br>  Die IDA hier analysiert die Struktur nicht gut, aber durch Offsets und weitere Aufrufe können Sie verstehen, dass sie aus ListEntry, KeyData (der Scan-Code des Schlüssels wird hier gespeichert) und KeyFlags besteht. <br>  Nach AddDevice wird in EntryPoint die Funktion sub_140001274 aufgerufen.  Sie erstellt einen neuen Stream. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/k2/bg/ank2bgcarpusbca9wgiydrkjmo0.png"></div><br>  Mal sehen, was in ThreadFunc passiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4b/ia/6f/4bia6fkojwowshkdfwfcj5e5xkq.png"></div><br>  Sie erhält den Wert aus der Liste und verarbeitet sie.  Achten Sie sofort auf die Funktion sub_140001A18. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oa/tp/6z/oatp6zuhwpkm-3yvwoi51heuqzw.png"></div><br>  Es übergibt die verarbeiteten Daten zusammen mit einem Zeiger auf WskSocket und der Nummer 0x89E0FEA928230002 an den Eingang der Funktion sub_140001A68.  Nachdem wir die Parameternummer in Bytes analysiert haben (0x89 = 137, 0xE0 = 224, 0xFE = 243, 0xA9 = 169, 0x2328 = 9000), erhalten wir genau dieselbe Adresse und denselben Port aus dem Verkehrsdump: 169.243.224.137:9000.  Es ist logisch anzunehmen, dass diese Funktion ein Netzwerkpaket an die angegebene Adresse und den angegebenen Port sendet - wir werden dies nicht im Detail betrachten. <br>  Mal sehen, wie die Daten vor dem Senden verarbeitet werden. <br><br>  Für die ersten beiden Elemente wird ein Äquivalent mit dem generierten Wert durchgeführt.  Da die Anzahl der Ticks zur Berechnung verwendet wird, kann davon ausgegangen werden, dass wir mit der Erzeugung einer Pseudozufallszahl konfrontiert sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h1/vi/xa/h1vixaqacqmhbn6nr0p6nbw03py.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2f/xg/xr/2fxgxrgvu-0be2wb5r2bbnszljy.png"></div><br>  Nach dem Generieren der Zahl wird der Wert der Variablen überschrieben, die wir zuvor TickCount genannt haben.  Variablen für die Formel werden in InitVars festgelegt.  Wenn wir zum Aufruf dieser Funktion zurückkehren, werden wir die Werte für diese Variablen herausfinden und als Ergebnis die folgende Formel erhalten: <br><br>  <b><i>(54773 + 7141 * prev_value)% 259200</i></b> <br><br>  Dies ist ein linearer kongruenter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pseudozufallszahlengenerator</a> .  Es wird in InitVars mit TickCount initialisiert.  Für jede nachfolgende Nummer fungiert die vorherige als Anfangswert (der Generator gibt einen Doppelbyte-Wert zurück und derselbe wird für die nachfolgende Generierung verwendet). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/td/pd/2f/tdpd2fq9xc9kvskq-tf4ax87xms.png"></div><br>  Nach dem Äquivalent mit einer Zufallszahl von zwei von der Tastatur übertragenen Werten wird eine Funktion aufgerufen, die die verbleibenden zwei Bytes der Nachricht bildet.  Es wird einfach <i>xor von</i> zwei bereits verschlüsselten Parametern und einem konstanten Wert erzeugt.  Es ist unwahrscheinlich, dass dies die Daten irgendwie entschlüsselt, sodass die letzten zwei Bytes der Nachricht für uns keine nützlichen Informationen enthalten und nicht berücksichtigt werden können.  Aber was tun mit verschlüsselten Daten? <br>  Schauen wir uns genauer an, was genau verschlüsselt ist.  KeyData ist ein Scan-Code, der einen ziemlich großen Wertebereich annehmen kann, was nicht einfach ist.  Aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KeyFlags</a> ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleines</a> Feld: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ww/rw/cp/wwrwcpfjwzk1ixnguh7jk-aafiw.png"></div><br>  Wenn Sie sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tabelle der</a> Scan-Codes ansehen, werden Sie feststellen, dass das Flag meistens entweder 0 (die Taste ist gedrückt) oder 1 (die Taste ist angehoben) ist.  KEY_E0 wird ziemlich selten ausgesetzt sein, aber es kann vorkommen, aber um KEY_E1 zu treffen, sind die Chancen sehr gering.  Daher können Sie Folgendes versuchen: Wir gehen die Daten aus dem Speicherauszug durch, wählen einen Wert aus, der mit KeyFlags verschlüsselt ist, machen ein Äquivalent mit 0 und generieren zwei aufeinanderfolgende PSCs.  Erstens ist KeyData ein einzelnes Byte, und wir können die Richtigkeit des generierten MSS durch ein hohes Byte überprüfen.  Und zweitens nehmen die nächsten verschlüsselten KeyFlags, wenn sie ein Äquivalent mit dem richtigen PSC ausführen, dieselben Bitwerte an.  Wenn sich herausstellt, dass dies falsch ist, nehmen wir an, dass die KeyFlags, die wir ursprünglich betrachtet haben, 1 usw. waren. <br>  Versuchen wir, unseren Algorithmus zu implementieren.  Wir werden dafür Python verwenden: <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung des Algorithmus</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  -   keymap = […] # ,   Wireshark traffic_dump = […] #  def bxnor(a, b): return ((~a &amp; 0xffff) | b) &amp; (a | (~b &amp; 0xffff)) #   def brgen(a): return ((7141 * a + 54773) % 259200) &amp; 0xffff def decode(): #     for i in range(0, len(traffic_dump) - 1): #   KeyFlags probe = traffic_dump[i][1] #   - scancode = traffic_dump[i+1][0] #    KeyFlags tester = traffic_dump[i+1][1] fail = True #     (  KEY_E1) for flag in range(4): rnd_flag = bxnor(flag, probe) rnd_sc = brgen(rnd_flag) next_flag = bxnor(tester, brgen(rnd_sc)) #   KeyFlags if next_flag in range(4): sc = bxnor(rnd_sc, scancode) if sc &lt; len(keymap): sym = keymap[sc] if next_flag % 2 == 0: print(sym, end='') fail = False break #   -      KeyFlags   if fail: print('Something went wrong on {} pair'.format(i)) return print() if __name__ == "__main__": decode()</span></span></code> </pre> <br></div></div><br>  Führen Sie unser Skript für die vom Speicherauszug empfangenen Daten aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ht/ct/lp/htctlp99gtxcxje2krcgsjkqnpu.png"></div><br>  Und im entschlüsselten Verkehr finden wir unsere begehrteste Leitung! <br><br>  <i><b>NQ2019DABE17518674F97DBA393415E9727982FC52C202549E6C1740BC0933C694B3DE</b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z9/3u/ma/z93umaswtxopnn-zbqi4qwbanfu.jpeg"></div><br>  Bald wird es Artikel mit Analyse der verbleibenden Aufgaben geben, nicht verpassen! <br><br>  PS Und wir erinnern Sie daran, dass jeder, der mindestens eine Aufgabe bei NeoQUEST-2019 vollständig erledigt hat, Anspruch auf einen Preis hat!  Überprüfen Sie Ihre E-Mails auf einen Brief. Wenn er nicht bei Ihnen <b>eingegangen ist</b> , schreiben Sie an <b>support@neoquest.ru</b> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446462/">https://habr.com/ru/post/de446462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446452/index.html">Mondmission "Bereshit" - 4. April 2019, der Übergang zur Mondumlaufbahn ist abgeschlossen, 7 Flugtage voraus, 6 Manöver und 1 Landung</a></li>
<li><a href="../de446454/index.html">Golang Webserver-Entwicklung - Von einfach zu komplex</a></li>
<li><a href="../de446456/index.html">Importsubstitution in der Praxis. Teil 1. Optionen</a></li>
<li><a href="../de446458/index.html">Universal DRO basierend auf Arduino Nano - shDRO. Teil 2</a></li>
<li><a href="../de446460/index.html">Food Design Digest März 2019</a></li>
<li><a href="../de446464/index.html">15 Papageien: Wählen Sie einen Hosting-Anbieter für VPS / VDS-Server</a></li>
<li><a href="../de446466/index.html">Content Marketing for Business: Habraseminar Nr. 6 und seine wichtigsten Punkte</a></li>
<li><a href="../de446468/index.html">Praktischer Leitfaden zu Umgebungsvariablen in Go</a></li>
<li><a href="../de446472/index.html">Globales Update zur Anzeige der Lamptest.ru-Ergebnisse</a></li>
<li><a href="../de446476/index.html">Pläne für Angular 8.0 und Ivy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>