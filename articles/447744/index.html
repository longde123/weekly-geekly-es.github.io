<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìü üîª ‚ô•Ô∏è Climbing Elbrus - Reconocimiento en batalla. Parte t√©cnica 2. Interrupciones, excepciones, temporizador del sistema. üêï ü§∫ üëë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos explorando Elbrus port√°ndole Embox . 

 Este art√≠culo es la segunda parte de un art√≠culo t√©cnico sobre la arquitectura de Elbrus. La prime...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Climbing Elbrus - Reconocimiento en batalla. Parte t√©cnica 2. Interrupciones, excepciones, temporizador del sistema.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447744/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  Continuamos explorando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elbrus</a> port√°ndole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embox</a> . <br><br>  Este art√≠culo es la segunda parte de un art√≠culo t√©cnico sobre la arquitectura de Elbrus.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte</a> trataba de pilas, registros, etc.  Antes de leer esta parte, le recomendamos que estudie la primera, ya que habla sobre las cosas b√°sicas de la arquitectura de Elbrus.  Esta secci√≥n se centrar√° en temporizadores, interrupciones y excepciones.  Esto, nuevamente, no es documentaci√≥n oficial.  Para ello, debe contactar a los desarrolladores de Elbrus en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ICST</a> . <a name="habracut"></a><br>  Al llegar al estudio de Elbrus, quer√≠amos iniciar r√°pidamente el temporizador porque, como saben, la multitarea preventiva no funciona sin ella.  Para hacer esto, parec√≠a suficiente implementar el controlador de interrupci√≥n y el temporizador en s√≠, pero nos topamos con <s>inesperadas</s> dificultades esperadas, ¬øa d√≥nde ir√≠amos sin ellas?  Comenzaron a buscar capacidades de depuraci√≥n y descubrieron que los desarrolladores se encargaron de esto mediante la introducci√≥n de varios comandos que le permiten generar varias situaciones excepcionales.  Por ejemplo, puede generar una excepci√≥n de un tipo especial a trav√©s de los registros PSR (Registro de estado del procesador) y UPSR (Registro de estado del procesador del usuario).  Para PSR, el bit exc_last_wish es el indicador de excepci√≥n exc_last_wish al regresar del procedimiento, y para UPSR, el exc_d_interrupt es el indicador de interrupci√≥n retardada generado por la operaci√≥n VFDI (Comprobar indicador de interrupci√≥n retardada). <br><br>  El c√≥digo es el siguiente: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UPSR_DI (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   .h  */</span></span></span><span class="hljs-meta"> rrs %upsr, %r1 ors %r1, UPSR_DI, %r1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* upsr |= UPSR_DI; */</span></span></span><span class="hljs-meta"> rws %r1, %upsr vfdi </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span></span></code> </pre> <br>  Lanzado  Pero no pas√≥ nada, el sistema se colg√≥ en alguna parte, no se emiti√≥ nada a la consola.  En realidad, vimos esto cuando intentamos iniciar la interrupci√≥n desde el temporizador, pero luego hab√≠a muchos componentes, y aqu√≠ estaba claro que algo interrump√≠a el progreso secuencial de nuestro programa, y ‚Äã‚Äãel control se transfiri√≥ a la tabla de excepciones (en t√©rminos de arquitectura de Elbrus, es m√°s correcto no hablar de la tabla interrupciones sobre una tabla de excepci√≥n).  Asumimos que, sin embargo, el procesador lanz√≥ una excepci√≥n, pero hubo algo de "basura" a la que transfiri√≥ el control.  Result√≥ que transfiere el control al mismo lugar donde colocamos la imagen Embox, lo que significa que hab√≠a un punto de entrada: la funci√≥n de entrada. <br><br>  Para la verificaci√≥n, hicimos lo siguiente.  Comenz√≥ un contador de entradas en entry ().  Inicialmente, todas las CPU comienzan con las interrupciones apagadas, entran en la entrada (), despu√©s de lo cual dejamos solo un n√∫cleo activo, el resto va a un bucle sin fin.  Una vez que el contador es igual al n√∫mero de CPU, consideramos que todos los hits posteriores en la entrada son excepciones.  Les recuerdo que antes era como se describe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestro primer art√≠culo sobre Elbrus</a> <br><br><pre> <code class="cpp hljs"> cpuid = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;last_cpuid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpuid &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* copy of trap table */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;_t_entry, <span class="hljs-number"><span class="hljs-number">0x1800</span></span>); kernel_start();</code> </pre> <br>  Lo hizo <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); ... } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> cpu_idle(); } e2k_kernel_start(); }</code> </pre> <br>  Y finalmente vimos la reacci√≥n al entrar en la interrupci√≥n (solo con la ayuda de printf imprimimos una l√≠nea). <br><br>  Aqu√≠ vale la pena explicar que inicialmente en la primera versi√≥n esper√°bamos copiar la tabla de excepciones, pero en primer lugar, result√≥ que estaba en nuestra direcci√≥n y, en segundo lugar, no pudimos hacer la copia correcta.  Tuve que reescribir los scripts del enlazador, el punto de entrada al sistema y el controlador de interrupciones, es decir, necesitaba la parte del ensamblador, un poco m√°s tarde. <br><br>  As√≠ es como se ve la parte de la parte modificada del enlazador de script: <br><br><pre> <code class="cpp hljs">.text : { _start = .; _t_entry = .; <span class="hljs-comment"><span class="hljs-comment">/* Interrupt handler */</span></span> *(.ttable_entry0) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Syscall handler */</span></span> *(.ttable_entry1) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* longjmp handler */</span></span> *(.ttable_entry2) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1800</span></span>; _t_entry_end = .; *(.e2k_entry) *(.cpu_idle) <span class="hljs-comment"><span class="hljs-comment">/* text */</span></span> }</code> </pre><br>  es decir, eliminamos la secci√≥n de entrada para la tabla de excepciones.  La secci√≥n cpu_idle tambi√©n se encuentra all√≠ para aquellas CPU que no se usan. <br><br>  As√≠ es como se ve la funci√≥n de entrada para nuestro n√∫cleo activo, en el que se ejecutar√° Embox: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> psr; <span class="hljs-comment"><span class="hljs-comment">/*    CPU ‚Äú‚Äù */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idled_cpus_count &lt; CPU_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) ; ... <span class="hljs-comment"><span class="hljs-comment">/*     ,     */</span></span> e2k_upsr_write(e2k_upsr_read() &amp; ~UPSR_FE); kernel_start(); <span class="hljs-comment"><span class="hljs-comment">/*   Embox */</span></span> }</code> </pre> <br>  Bueno, de acuerdo con la instrucci√≥n VFDI, se lanz√≥ una excepci√≥n.  Ahora necesita obtener su n√∫mero para asegurarse de que esta sea la excepci√≥n correcta.  Para esto, Elbrus tiene registros de informaci√≥n de interrupci√≥n TIR (registros de informaci√≥n de trampa).  Contienen informaci√≥n sobre los √∫ltimos comandos, es decir, la parte final de la traza.  La traza se re√∫ne durante la ejecuci√≥n del programa y se "congela" al entrar en una interrupci√≥n.  TIR incluye las partes baja (64 bits) y alta (64 bits).  La palabra baja contiene las banderas de excepci√≥n, y la palabra alta contiene un puntero a la instrucci√≥n que condujo a la excepci√≥n y al n√∫mero TIR actual.  En consecuencia, en nuestro caso, exc_d_interrupt es el cuarto bit. <br><br>  Nota Todav√≠a tenemos algunos malentendidos con respecto a la profundidad (n√∫mero) de TIR.  La documentaci√≥n proporciona: <br><blockquote>  "Se determina la profundidad de la memoria TIR, es decir, el n√∫mero de registros de informaci√≥n de trampas <br>  Macro TIR_NUM igual al n√∫mero de etapas de canalizaci√≥n de procesador requeridas para <br>  emitiendo todas las situaciones especiales posibles.  TIR_NUM = 19; " </blockquote>  En la pr√°ctica, vemos la profundidad = 1 y, por lo tanto, solo usamos el registro TIR0. <br><br>  Los especialistas del MCST nos explicaron que todo es correcto y que solo habr√° TIR0 para las interrupciones "precisas", pero para otras situaciones puede haber algo m√°s.  Pero como solo estamos hablando de interrupciones de temporizador, esto no nos molesta. <br><br>  Ok, ahora veamos qu√© se necesita para ingresar / salir correctamente del controlador de excepciones.  De hecho, es necesario guardar en la entrada y restaurar los siguientes 5 registros en la salida.  Tres registros de preparaci√≥n de transferencia de control son ctpr [1,2,3], y dos registros de control de ciclo son ILCR (Registro de valores iniciales del contador de ciclos) y LSR (Registro de estado del ciclo). <br><br><pre> <code class="cpp hljs">.type ttable_entry0,@function ttable_entry0: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">1</span></span>; rrd %ctpr1, %dr1 rrd %ctpr2, %dr2 rrd %ctpr3, %dr3 rrd %ilcr, %dr4 rrd %lsr, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* sizeof pt_regs */</span></span> getsp -(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>), %dr0 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + PT_CTRP1] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr1 = ctpr1 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + PT_CTRP2] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr2 = ctpr2 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + PT_CTRP3] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr3 = ctpr3 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + PT_ILCR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ilcr = ilcr */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + PT_LSR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;lsr = lsr */</span></span> disp %ctpr1, e2k_entry ct %ctpr1</code> </pre> <br>  En realidad, eso es todo, despu√©s de salir del controlador de excepciones, debe restaurar estos 5 registros. <br><br>  Hacemos esto con una macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_COMMON_REGS(regs) \ ({ \ uint64_t ctpr1 = regs-&gt;ctpr1, ctpr2 = regs-&gt;ctpr2, \ ctpr3 = regs-&gt;ctpr3, lsr = regs-&gt;lsr, \ ilcr = regs-&gt;ilcr; \ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ctpr2 is restored first because of tight time constraints \ * on restoring ctpr2 and aaldv. */</span></span></span><span class="hljs-meta"> \ E2K_SET_DSREG(ctpr1, ctpr1); \ E2K_SET_DSREG(ctpr2, ctpr2); \ E2K_SET_DSREG(ctpr3, ctpr3); \ E2K_SET_DSREG(lsr, lsr); \ E2K_SET_DSREG(ilcr, ilcr); \ })</span></span></code> </pre> <br>  Tambi√©n es importante no olvidar despu√©s de la restauraci√≥n de los registros para invocar la operaci√≥n HECHO (Devoluci√≥n desde el controlador de interrupci√≥n de hardware).  Esta operaci√≥n es necesaria, en particular, para procesar correctamente las operaciones de transferencia de control interrumpidas.  Hacemos esto con una macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_DONE \ do { \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{nop 3} {done}"</span></span></span><span class="hljs-meta"> ::: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ctpr3"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  En realidad, hacemos el retorno de la interrupci√≥n directamente en c√≥digo C usando estas dos macros. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE;</code> </pre> <br><h3>  Interrupciones externas </h3><br>  Comencemos con c√≥mo habilitar las interrupciones externas.  En Elbrus, APIC (o m√°s bien su an√°logo) se usa como controlador de interrupci√≥n; Embox ya ten√≠a este controlador.  Por lo tanto, fue posible recoger un temporizador del sistema para ello.  Hay dos temporizadores, uno que es muy similar al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PIT</a> , el otro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LAPIC Timer</a> , tambi√©n es bastante est√°ndar, por lo que no tiene sentido hablar de ellos.  Tanto eso como eso parec√≠an simples, y eso y eso ya exist√≠a en Embox, pero el controlador del temporizador LAPIC parec√≠a m√°s en perspectiva, adem√°s de que la implementaci√≥n del temporizador PIT nos parec√≠a m√°s no est√°ndar.  Por lo tanto, parec√≠a m√°s f√°cil de completar.  Adem√°s, la documentaci√≥n oficial describ√≠a los registros APIC y LAPIC, que eran ligeramente diferentes de los originales.  Traerlos no tiene sentido, como puedes ver en el original. <br><br>  Adem√°s de permitir interrupciones en APIC, debe habilitar el manejo de interrupciones a trav√©s de los registros PSR / UPSR.  Ambos registros tienen banderas para habilitar interrupciones externas e interrupciones no enmascarables.  <i>PERO</i> aqu√≠ es muy importante tener en cuenta que el registro PSR es <i>local</i> para la funci√≥n (esto se discuti√≥ en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte t√©cnica</a> ).  Y esto significa que si lo configura dentro de una funci√≥n, cuando llame a todas las funciones posteriores, se heredar√°, pero cuando regrese de la funci√≥n, volver√° a su estado original.  De ah√≠ la pregunta, pero ¬øc√≥mo gestionar las interrupciones? <br><br>  Usamos la siguiente soluci√≥n.  El registro PSR le permite habilitar la administraci√≥n a trav√©s de UPSR, que ya es global (lo que necesitamos).  Por lo tanto, habilitamos el control a trav√©s de UPSR directamente (¬°importante!) Antes de la funci√≥n de inicio de sesi√≥n principal de Embox: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* PSR is local register and makes sense only within a function, * so we set it here before kernel start. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rrs %%psr, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr) :)</span></span></span></span>; psr |= (PSR_IE | PSR_NMIE | PSR_UIE); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rws %0, %%psr"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ri"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr))</span></span></span></span>; kernel_start();</code> </pre> <br>  De alguna manera por casualidad despu√©s de refactorizar, tom√© y puse estas l√≠neas en una funci√≥n separada ... Y el registro es local para la funci√≥n.  Est√° claro que todo se ha roto :) <br><br>  Entonces, todo parece estar encendido en el procesador, vaya al controlador de interrupci√≥n. <br><br>  Como hemos visto anteriormente, la informaci√≥n sobre el n√∫mero de excepci√≥n est√° en el registro TIR.  Adem√°s, el bit 32 en este registro informa que se ha producido una interrupci√≥n externa. <br><br>  Despu√©s de encender el temporizador, siguieron un par de d√≠as de tormento, ya que no se pudo obtener ninguna interrupci√≥n.  La raz√≥n fue lo suficientemente divertida.  Hay punteros de 64 bits en Elbrus, y la direcci√≥n del registro en APIC entr√≥ en uint32_t, por eso los usamos.  Pero result√≥ que si necesita, por ejemplo, convertir 0xF0000000 en un puntero, no obtendr√° 0xF0000000, sino 0xFFFFFFFFF0000000.  Es decir, el compilador expandir√° su signo int sin firmar. <br><br>  Aqu√≠, por supuesto, era necesario usar uintptr_t, ya que, como result√≥, en el est√°ndar C99, este tipo de conversi√≥n est√° definida por la implementaci√≥n. <br><br>  Despu√©s de que finalmente vimos el bit 32 en relieve en TIR, comenzamos a buscar c√≥mo obtener el n√∫mero de interrupci√≥n.  Result√≥ ser bastante simple, aunque no se parece en nada a x86, esta es una de las diferencias entre las implementaciones de LAPIC.  Para Elbrus, para obtener el n√∫mero de interrupci√≥n, debe ingresar al registro especial de LAPIC: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APIC_VECT (0xFEE00000 + 0xFF0)</span></span></code> </pre> <br>  donde 0xFEE00000 es la direcci√≥n base de los registros LAPIC. <br><br>  Eso es todo, result√≥ recoger tanto el temporizador del sistema como el temporizador LAPIC. <br><br><h3>  Conclusi√≥n </h3><br>  La informaci√≥n proporcionada en las dos primeras partes t√©cnicas del art√≠culo sobre la arquitectura de Elbrus es suficiente para implementar interrupciones de hardware y multitarea preventiva en cualquier sistema operativo.  En realidad, las capturas de pantalla dadas dan testimonio de esto. <br><br><img src="https://habrastorage.org/webt/qm/qz/3p/qmqz3pbvuvohscm_qon1edf5jno.png"><br><br>  Esta no es la √∫ltima parte t√©cnica sobre la arquitectura de Elbrus.  Ahora estamos dominando la gesti√≥n de memoria (MMU) en Elbrus, esperamos hablar de ello pronto.  Necesitamos esto no solo para la implementaci√≥n de espacios de direcciones virtuales, sino tambi√©n para el trabajo normal con perif√©ricos, porque a trav√©s de este mecanismo puede deshabilitar o habilitar el almacenamiento en cach√© de un √°rea espec√≠fica del espacio de direcciones. <br><br>  Todo lo que est√° escrito en el art√≠culo se puede encontrar en el repositorio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embox</a> .  Tambi√©n puede compilar y ejecutar, por supuesto, si hay una plataforma de hardware.  Es cierto que se necesita un compilador para esto, y solo se puede obtener en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MCST</a> .  Se puede solicitar documentaci√≥n oficial all√≠. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447744/">https://habr.com/ru/post/447744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447732/index.html">Identificador de raza de perro: desarrollo de ciclo completo del programa Keras a la aplicaci√≥n de Android. en el mercado de juego</a></li>
<li><a href="../447734/index.html">Por qu√© el front-end deber√≠a comprender los principios de la interfaz de usuario</a></li>
<li><a href="../447736/index.html">Video de drones: una nueva tendencia en las redes sociales</a></li>
<li><a href="../447738/index.html">Julian Assange arrestado por la polic√≠a del Reino Unido</a></li>
<li><a href="../447742/index.html">¬øQu√© es la metodolog√≠a DevOps y qui√©n la necesita?</a></li>
<li><a href="../447748/index.html">Sistemas de archivos virtuales de Linux: ¬øpor qu√© son necesarios y c√≥mo funcionan? Parte 2</a></li>
<li><a href="../447752/index.html">C√≥mo overclockeamos CAD COMPASS-3D ‚Üí Parte 3</a></li>
<li><a href="../447754/index.html">Aplicaci√≥n de barra de men√∫ para macOS</a></li>
<li><a href="../447756/index.html">Nuevo Cuadrante de Gartner para Soluciones de Monitoreo de Aplicaciones (APM)</a></li>
<li><a href="../447784/index.html">M√∫sica en el d√≠a de la cosmon√°utica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>