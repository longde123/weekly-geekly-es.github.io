<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📟 🔻 ♥️ Climbing Elbrus - Reconocimiento en batalla. Parte técnica 2. Interrupciones, excepciones, temporizador del sistema. 🐕 🤺 👑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos explorando Elbrus portándole Embox . 

 Este artículo es la segunda parte de un artículo técnico sobre la arquitectura de Elbrus. La prime...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Climbing Elbrus - Reconocimiento en batalla. Parte técnica 2. Interrupciones, excepciones, temporizador del sistema.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447744/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  Continuamos explorando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elbrus</a> portándole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embox</a> . <br><br>  Este artículo es la segunda parte de un artículo técnico sobre la arquitectura de Elbrus.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte</a> trataba de pilas, registros, etc.  Antes de leer esta parte, le recomendamos que estudie la primera, ya que habla sobre las cosas básicas de la arquitectura de Elbrus.  Esta sección se centrará en temporizadores, interrupciones y excepciones.  Esto, nuevamente, no es documentación oficial.  Para ello, debe contactar a los desarrolladores de Elbrus en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ICST</a> . <a name="habracut"></a><br>  Al llegar al estudio de Elbrus, queríamos iniciar rápidamente el temporizador porque, como saben, la multitarea preventiva no funciona sin ella.  Para hacer esto, parecía suficiente implementar el controlador de interrupción y el temporizador en sí, pero nos topamos con <s>inesperadas</s> dificultades esperadas, ¿a dónde iríamos sin ellas?  Comenzaron a buscar capacidades de depuración y descubrieron que los desarrolladores se encargaron de esto mediante la introducción de varios comandos que le permiten generar varias situaciones excepcionales.  Por ejemplo, puede generar una excepción de un tipo especial a través de los registros PSR (Registro de estado del procesador) y UPSR (Registro de estado del procesador del usuario).  Para PSR, el bit exc_last_wish es el indicador de excepción exc_last_wish al regresar del procedimiento, y para UPSR, el exc_d_interrupt es el indicador de interrupción retardada generado por la operación VFDI (Comprobar indicador de interrupción retardada). <br><br>  El código es el siguiente: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UPSR_DI (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   .h  */</span></span></span><span class="hljs-meta"> rrs %upsr, %r1 ors %r1, UPSR_DI, %r1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* upsr |= UPSR_DI; */</span></span></span><span class="hljs-meta"> rws %r1, %upsr vfdi </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span></span></code> </pre> <br>  Lanzado  Pero no pasó nada, el sistema se colgó en alguna parte, no se emitió nada a la consola.  En realidad, vimos esto cuando intentamos iniciar la interrupción desde el temporizador, pero luego había muchos componentes, y aquí estaba claro que algo interrumpía el progreso secuencial de nuestro programa, y ​​el control se transfirió a la tabla de excepciones (en términos de arquitectura de Elbrus, es más correcto no hablar de la tabla interrupciones sobre una tabla de excepción).  Asumimos que, sin embargo, el procesador lanzó una excepción, pero hubo algo de "basura" a la que transfirió el control.  Resultó que transfiere el control al mismo lugar donde colocamos la imagen Embox, lo que significa que había un punto de entrada: la función de entrada. <br><br>  Para la verificación, hicimos lo siguiente.  Comenzó un contador de entradas en entry ().  Inicialmente, todas las CPU comienzan con las interrupciones apagadas, entran en la entrada (), después de lo cual dejamos solo un núcleo activo, el resto va a un bucle sin fin.  Una vez que el contador es igual al número de CPU, consideramos que todos los hits posteriores en la entrada son excepciones.  Les recuerdo que antes era como se describe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestro primer artículo sobre Elbrus</a> <br><br><pre> <code class="cpp hljs"> cpuid = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;last_cpuid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpuid &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* copy of trap table */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;_t_entry, <span class="hljs-number"><span class="hljs-number">0x1800</span></span>); kernel_start();</code> </pre> <br>  Lo hizo <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); ... } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> cpu_idle(); } e2k_kernel_start(); }</code> </pre> <br>  Y finalmente vimos la reacción al entrar en la interrupción (solo con la ayuda de printf imprimimos una línea). <br><br>  Aquí vale la pena explicar que inicialmente en la primera versión esperábamos copiar la tabla de excepciones, pero en primer lugar, resultó que estaba en nuestra dirección y, en segundo lugar, no pudimos hacer la copia correcta.  Tuve que reescribir los scripts del enlazador, el punto de entrada al sistema y el controlador de interrupciones, es decir, necesitaba la parte del ensamblador, un poco más tarde. <br><br>  Así es como se ve la parte de la parte modificada del enlazador de script: <br><br><pre> <code class="cpp hljs">.text : { _start = .; _t_entry = .; <span class="hljs-comment"><span class="hljs-comment">/* Interrupt handler */</span></span> *(.ttable_entry0) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Syscall handler */</span></span> *(.ttable_entry1) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* longjmp handler */</span></span> *(.ttable_entry2) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1800</span></span>; _t_entry_end = .; *(.e2k_entry) *(.cpu_idle) <span class="hljs-comment"><span class="hljs-comment">/* text */</span></span> }</code> </pre><br>  es decir, eliminamos la sección de entrada para la tabla de excepciones.  La sección cpu_idle también se encuentra allí para aquellas CPU que no se usan. <br><br>  Así es como se ve la función de entrada para nuestro núcleo activo, en el que se ejecutará Embox: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> psr; <span class="hljs-comment"><span class="hljs-comment">/*    CPU “” */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idled_cpus_count &lt; CPU_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) ; ... <span class="hljs-comment"><span class="hljs-comment">/*     ,     */</span></span> e2k_upsr_write(e2k_upsr_read() &amp; ~UPSR_FE); kernel_start(); <span class="hljs-comment"><span class="hljs-comment">/*   Embox */</span></span> }</code> </pre> <br>  Bueno, de acuerdo con la instrucción VFDI, se lanzó una excepción.  Ahora necesita obtener su número para asegurarse de que esta sea la excepción correcta.  Para esto, Elbrus tiene registros de información de interrupción TIR (registros de información de trampa).  Contienen información sobre los últimos comandos, es decir, la parte final de la traza.  La traza se reúne durante la ejecución del programa y se "congela" al entrar en una interrupción.  TIR incluye las partes baja (64 bits) y alta (64 bits).  La palabra baja contiene las banderas de excepción, y la palabra alta contiene un puntero a la instrucción que condujo a la excepción y al número TIR actual.  En consecuencia, en nuestro caso, exc_d_interrupt es el cuarto bit. <br><br>  Nota Todavía tenemos algunos malentendidos con respecto a la profundidad (número) de TIR.  La documentación proporciona: <br><blockquote>  "Se determina la profundidad de la memoria TIR, es decir, el número de registros de información de trampas <br>  Macro TIR_NUM igual al número de etapas de canalización de procesador requeridas para <br>  emitiendo todas las situaciones especiales posibles.  TIR_NUM = 19; " </blockquote>  En la práctica, vemos la profundidad = 1 y, por lo tanto, solo usamos el registro TIR0. <br><br>  Los especialistas del MCST nos explicaron que todo es correcto y que solo habrá TIR0 para las interrupciones "precisas", pero para otras situaciones puede haber algo más.  Pero como solo estamos hablando de interrupciones de temporizador, esto no nos molesta. <br><br>  Ok, ahora veamos qué se necesita para ingresar / salir correctamente del controlador de excepciones.  De hecho, es necesario guardar en la entrada y restaurar los siguientes 5 registros en la salida.  Tres registros de preparación de transferencia de control son ctpr [1,2,3], y dos registros de control de ciclo son ILCR (Registro de valores iniciales del contador de ciclos) y LSR (Registro de estado del ciclo). <br><br><pre> <code class="cpp hljs">.type ttable_entry0,@function ttable_entry0: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">1</span></span>; rrd %ctpr1, %dr1 rrd %ctpr2, %dr2 rrd %ctpr3, %dr3 rrd %ilcr, %dr4 rrd %lsr, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* sizeof pt_regs */</span></span> getsp -(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>), %dr0 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + PT_CTRP1] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr1 = ctpr1 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + PT_CTRP2] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr2 = ctpr2 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + PT_CTRP3] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr3 = ctpr3 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + PT_ILCR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ilcr = ilcr */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + PT_LSR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;lsr = lsr */</span></span> disp %ctpr1, e2k_entry ct %ctpr1</code> </pre> <br>  En realidad, eso es todo, después de salir del controlador de excepciones, debe restaurar estos 5 registros. <br><br>  Hacemos esto con una macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_COMMON_REGS(regs) \ ({ \ uint64_t ctpr1 = regs-&gt;ctpr1, ctpr2 = regs-&gt;ctpr2, \ ctpr3 = regs-&gt;ctpr3, lsr = regs-&gt;lsr, \ ilcr = regs-&gt;ilcr; \ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ctpr2 is restored first because of tight time constraints \ * on restoring ctpr2 and aaldv. */</span></span></span><span class="hljs-meta"> \ E2K_SET_DSREG(ctpr1, ctpr1); \ E2K_SET_DSREG(ctpr2, ctpr2); \ E2K_SET_DSREG(ctpr3, ctpr3); \ E2K_SET_DSREG(lsr, lsr); \ E2K_SET_DSREG(ilcr, ilcr); \ })</span></span></code> </pre> <br>  También es importante no olvidar después de la restauración de los registros para invocar la operación HECHO (Devolución desde el controlador de interrupción de hardware).  Esta operación es necesaria, en particular, para procesar correctamente las operaciones de transferencia de control interrumpidas.  Hacemos esto con una macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_DONE \ do { \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{nop 3} {done}"</span></span></span><span class="hljs-meta"> ::: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ctpr3"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  En realidad, hacemos el retorno de la interrupción directamente en código C usando estas dos macros. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE;</code> </pre> <br><h3>  Interrupciones externas </h3><br>  Comencemos con cómo habilitar las interrupciones externas.  En Elbrus, APIC (o más bien su análogo) se usa como controlador de interrupción; Embox ya tenía este controlador.  Por lo tanto, fue posible recoger un temporizador del sistema para ello.  Hay dos temporizadores, uno que es muy similar al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PIT</a> , el otro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LAPIC Timer</a> , también es bastante estándar, por lo que no tiene sentido hablar de ellos.  Tanto eso como eso parecían simples, y eso y eso ya existía en Embox, pero el controlador del temporizador LAPIC parecía más en perspectiva, además de que la implementación del temporizador PIT nos parecía más no estándar.  Por lo tanto, parecía más fácil de completar.  Además, la documentación oficial describía los registros APIC y LAPIC, que eran ligeramente diferentes de los originales.  Traerlos no tiene sentido, como puedes ver en el original. <br><br>  Además de permitir interrupciones en APIC, debe habilitar el manejo de interrupciones a través de los registros PSR / UPSR.  Ambos registros tienen banderas para habilitar interrupciones externas e interrupciones no enmascarables.  <i>PERO</i> aquí es muy importante tener en cuenta que el registro PSR es <i>local</i> para la función (esto se discutió en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte técnica</a> ).  Y esto significa que si lo configura dentro de una función, cuando llame a todas las funciones posteriores, se heredará, pero cuando regrese de la función, volverá a su estado original.  De ahí la pregunta, pero ¿cómo gestionar las interrupciones? <br><br>  Usamos la siguiente solución.  El registro PSR le permite habilitar la administración a través de UPSR, que ya es global (lo que necesitamos).  Por lo tanto, habilitamos el control a través de UPSR directamente (¡importante!) Antes de la función de inicio de sesión principal de Embox: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* PSR is local register and makes sense only within a function, * so we set it here before kernel start. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rrs %%psr, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr) :)</span></span></span></span>; psr |= (PSR_IE | PSR_NMIE | PSR_UIE); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rws %0, %%psr"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ri"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr))</span></span></span></span>; kernel_start();</code> </pre> <br>  De alguna manera por casualidad después de refactorizar, tomé y puse estas líneas en una función separada ... Y el registro es local para la función.  Está claro que todo se ha roto :) <br><br>  Entonces, todo parece estar encendido en el procesador, vaya al controlador de interrupción. <br><br>  Como hemos visto anteriormente, la información sobre el número de excepción está en el registro TIR.  Además, el bit 32 en este registro informa que se ha producido una interrupción externa. <br><br>  Después de encender el temporizador, siguieron un par de días de tormento, ya que no se pudo obtener ninguna interrupción.  La razón fue lo suficientemente divertida.  Hay punteros de 64 bits en Elbrus, y la dirección del registro en APIC entró en uint32_t, por eso los usamos.  Pero resultó que si necesita, por ejemplo, convertir 0xF0000000 en un puntero, no obtendrá 0xF0000000, sino 0xFFFFFFFFF0000000.  Es decir, el compilador expandirá su signo int sin firmar. <br><br>  Aquí, por supuesto, era necesario usar uintptr_t, ya que, como resultó, en el estándar C99, este tipo de conversión está definida por la implementación. <br><br>  Después de que finalmente vimos el bit 32 en relieve en TIR, comenzamos a buscar cómo obtener el número de interrupción.  Resultó ser bastante simple, aunque no se parece en nada a x86, esta es una de las diferencias entre las implementaciones de LAPIC.  Para Elbrus, para obtener el número de interrupción, debe ingresar al registro especial de LAPIC: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APIC_VECT (0xFEE00000 + 0xFF0)</span></span></code> </pre> <br>  donde 0xFEE00000 es la dirección base de los registros LAPIC. <br><br>  Eso es todo, resultó recoger tanto el temporizador del sistema como el temporizador LAPIC. <br><br><h3>  Conclusión </h3><br>  La información proporcionada en las dos primeras partes técnicas del artículo sobre la arquitectura de Elbrus es suficiente para implementar interrupciones de hardware y multitarea preventiva en cualquier sistema operativo.  En realidad, las capturas de pantalla dadas dan testimonio de esto. <br><br><img src="https://habrastorage.org/webt/qm/qz/3p/qmqz3pbvuvohscm_qon1edf5jno.png"><br><br>  Esta no es la última parte técnica sobre la arquitectura de Elbrus.  Ahora estamos dominando la gestión de memoria (MMU) en Elbrus, esperamos hablar de ello pronto.  Necesitamos esto no solo para la implementación de espacios de direcciones virtuales, sino también para el trabajo normal con periféricos, porque a través de este mecanismo puede deshabilitar o habilitar el almacenamiento en caché de un área específica del espacio de direcciones. <br><br>  Todo lo que está escrito en el artículo se puede encontrar en el repositorio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Embox</a> .  También puede compilar y ejecutar, por supuesto, si hay una plataforma de hardware.  Es cierto que se necesita un compilador para esto, y solo se puede obtener en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MCST</a> .  Se puede solicitar documentación oficial allí. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447744/">https://habr.com/ru/post/447744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447732/index.html">Identificador de raza de perro: desarrollo de ciclo completo del programa Keras a la aplicación de Android. en el mercado de juego</a></li>
<li><a href="../447734/index.html">Por qué el front-end debería comprender los principios de la interfaz de usuario</a></li>
<li><a href="../447736/index.html">Video de drones: una nueva tendencia en las redes sociales</a></li>
<li><a href="../447738/index.html">Julian Assange arrestado por la policía del Reino Unido</a></li>
<li><a href="../447742/index.html">¿Qué es la metodología DevOps y quién la necesita?</a></li>
<li><a href="../447748/index.html">Sistemas de archivos virtuales de Linux: ¿por qué son necesarios y cómo funcionan? Parte 2</a></li>
<li><a href="../447752/index.html">Cómo overclockeamos CAD COMPASS-3D → Parte 3</a></li>
<li><a href="../447754/index.html">Aplicación de barra de menú para macOS</a></li>
<li><a href="../447756/index.html">Nuevo Cuadrante de Gartner para Soluciones de Monitoreo de Aplicaciones (APM)</a></li>
<li><a href="../447784/index.html">Música en el día de la cosmonáutica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>