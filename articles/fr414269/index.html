<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚗 🏽 🕊️ "20 000 IOPS par nœud sont de bonnes performances avec une latence de 5 ms." Pour OLTP - non 🧜🏿 🔸 👩🏿‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La raison de la rédaction de cet article était un examen très utile de la façon dont nous avons testé VMware vSAN ... CROC. La critique en vaut la pei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"20 000 IOPS par nœud sont de bonnes performances avec une latence de 5 ms." Pour OLTP - non</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414269/"><p><img src="https://habrastorage.org/webt/fq/yy/2k/fqyy2kbw4iqx5ikqy7v-o60jfce.jpeg" alt="KDPV"></p><br><p>  La raison de la rédaction de cet article était un examen très <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utile</a> de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">façon dont nous avons testé VMware vSAN ...</a> CROC.  La critique en vaut la peine, mais elle contient une phrase avec laquelle je me bats depuis plus d'une décennie.  Les administrateurs de stockage, les virtualiseurs et les intégrateurs répètent encore et encore: "Les délais de 5 ms sont un excellent indicateur."  Même le chiffre de 5 ms pendant dix ans ne change pas.  J'ai entendu cela en direct d'administrateurs très respectés pas moins d'une douzaine de fois.  De moins respecté - des dizaines, et combien de fois j'ai lu sur Internet ... Non, non, non.  Pour les charges OLTP de 5 ms, d'autant plus qu'elles sont généralement mesurées, ce sont des échecs épiques.  J'ai dû expliquer les raisons de cela à plusieurs reprises, cette fois j'ai décidé de rassembler mes pensées sous une forme réutilisable. </p><br><p>  Je dois dire tout de suite qu'il n'y a pas de telles erreurs dans l'article mentionné ci-dessus, plutôt que la phrase a fonctionné comme déclencheur. </p><a name="habracut"></a><br><h2 id="tipichnoe-nachalo">  Début typique </h2><br><p>  Tout ce qui est décrit dans cet article s'applique aux SGBD courants utilisés pour les OLTP d'entreprise classiques.  Surtout, j'ai de l'expérience avec MS SQL Server, mais, au moins pour PostgeSQL, Oracle et Sybase, de nombreux points et conclusions resteront également vrais. </p><br><p>  Les SGBD de performance sont généralement mécontents de tout le monde.  S'il y a un SGBD dans un grand système - et il est soudainement presque toujours là - alors ce SGBD est un goulot d'étranglement.  Eh bien, ou cela deviendra immédiatement un goulot d'étranglement si vous commencez à optimiser tout le reste.  Et donc, le client vient et dit d'une voix humaine: "Aide! Économise! Ils ont payé $ NNNNNNNN pour le serveur et le stockage, mais la vitesse n'augmente pas! Oh, et l'administrateur s'est installé et le vendeur a consulté, mais ne bouge toujours pas."  Si les développeurs du système correspondent à la définition de Lavrov (nous pouvons nous passer d'un devis exact) et que les spécialistes de l'exploitation et de la maintenance «luttent contre les incidents en redémarrant le serveur», alors le problème est souvent simple et sans prétention: il n'y a pas d'index, de requêtes tordues, d'erreurs de configuration fatales (à propos desquelles la documentation est en gras il dit <strong>"vous ne pouvez pas faire ça !!!"</strong> ), des verrous excessifs, des blocages et autres bêtises simples et claires.  Il existe de nombreux cas de ce type, la plupart, mais pas tous.  Si le système, en complexité ou en charge, a franchi une limite invisible, alors il mourra de ces problèmes ou passera au niveau suivant. </p><br><div class="spoiler">  <b class="spoiler_title">Conseils de diagnostic SQL Server</b> <div class="spoiler_text"><p> À mon humble avis, le meilleur outil est désormais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kit SQL Server First Responder</a> , promu par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brent Ozar</a> .  Cet outil se développe très activement.  Il y a encore un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">set</a> digne de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Glenn Berry</a> , il n'a pas non plus abandonné son projet.  Les deux ensembles sont magnifiques à leur manière, la lecture des commentaires et des requêtes pour la première fois ouvre beaucoup de nouvelles choses.  Moi-même, je commence toujours à regarder autour de <code>sys.dm_os_waitsats</code> avec <code>sys.dm_os_waitsats</code> , un rapide coup d'œil au journal des erreurs et à savoir s'il existe au moins un système de sauvegarde qui fonctionne. </p></div></div><br><p>  À ce niveau, le serveur n'est plus sous la table du directeur, les disques ne sont plus à l'intérieur du serveur, mais dans le système de stockage, les développeurs connaissent les index et les administrateurs connaissent déjà PowerShell, et les responsables informatiques commencent à dire des mots intelligents comme SLA et RPO / RTO.  Une situation intéressante se présente à ce niveau: </p><br><ul><li>  Le SGBD est un goulot d'étranglement. </li><li>  Le serveur semble être suffisant à tous égards. </li><li>  Le SGBD peut être encore amélioré par programme, mais il est difficile (soit de passer à des licences plus chères, soit de passer à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"zone rouge de la courbe Shipilev"</a> pour l'optimisation) </li><li>  Le système de disques est acheté cher et, semble-t-il, est même en quelque sorte configuré. </li></ul><br><p>  Mais non.  Le crocodile n'est pas pris, la noix de coco ne pousse pas et les performances du système sont identiques ou inférieures à celles de l'ancien serveur.  Je regarde dans <code>sys.dm_os_waitsats</code> et vois <code>WRITELOG</code> , <code>PAGEIOLATCH_SH</code> et <code>PAGEIOLATCH_EX</code> en haut, le temps d'attente moyen est de 5+ ms.  Eh bien, typique, cho: "Hé, les administrateurs et DBA, ici vous avez un système de disque - goulot d'étranglement" et ici commence une vieille chanson d'environ 5 ms: </p><br><ul><li>  Nous avons 5 ms pour SLA </li><li>  Oui, nous avons un régiment de 20 000 IOPS </li><li>  Le vendeur nous a dit que tous les fichiers de base de données peuvent être sur une seule partition </li><li>  Nous avons la virtualisation et l'hyperconvergence et nous ne pouvons pas allouer de disques séparés sous la base de données </li><li>  Selon nos données, utilisation du serveur 5% </li><li>  Tout est configuré selon les recommandations </li><li>  Vos bases de données n'ont pas besoin de beaucoup de performances, elles ne font pas plus de 300 IOPS (et nous avons une étagère pour 20 000 IOPS) </li></ul><br><p>  Soit dit en passant, tout ce qui précède, non seulement sur "leurs" serveurs, mais aussi sur les services cloud et la virtualisation.  Il y a un tas de ses spécificités, mais le tableau clinique typique est à peu près le même: base de données modérément optimisée, personnel de développement et de maintenance intelligent, il y a une réserve pour le processeur et la mémoire, le "pot d'échappement" des investissements futurs est presque nul. </p><br><p>  Alors voilà.  Toute cette chanson sur "5 ms" est un non-sens et un non-sens.  Si vous le dites vous-même, lisez cet article.  Et s'ils vous le disent, préparez les arguments.  Avant, quand j'ai entendu ces mots, j'étais en colère, mais je ne suis plus en colère.  Moi, comme ce pot avec un pétunia du Guide de l'auto-stoppeur de la galaxie, je n'ai qu'une seule pensée: "Eh bien, encore une fois ...". </p><br><h2 id="kto-vinovat">  Qui est à blâmer? </h2><br><p>  Pourquoi la base de données est-elle si lente?  Eh bien, il semblerait qu'un serveur typique avec 20 à 64 cœurs à une fréquence de 2 à 3 GHz est capable d'effectuer 50 à 150 milliards d'opérations simples, et les tests de base de données (synthétiques) maximaux ne montrent sur ces machines que 10 000 à 5 000 transactions par seconde.  Hé!  Eh bien, cela représente un million à une douzaine de millions de transactions possibles par transaction.  Ce n'est pas seulement beaucoup, c'est beaucoup à ressentir. <br>  Ces frais généraux ont coûté les exigences <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACID</a> pour les transactions. </p><br><ul><li>  <strong>Une</strong> tomicité - soit l'ensemble de la transaction est terminée, soit l'ensemble n'est pas terminé. </li><li>  Cohérence - à l'entrée et à la sortie d'une transaction, le système est dans un état cohérent </li><li>  <strong>I</strong> solation - les transactions ne voient pas les états intermédiaires de l'autre </li><li>  <strong>D</strong> urabilité - si la transaction a été effectuée avec succès (validée), alors, quelles que soient les circonstances, les modifications apportées doivent rester dans le système. </li></ul><br><p>  Soit dit en passant, lettre par lettre, ces exigences ne sont pas remplies presque partout et jamais, mais simplement jamais dans les systèmes distribués (le théorème CAP interfère).  Pour notre situation, l'exigence «D» est plus susceptible d'être plus chère que d'autres, cette exigence est fournie par le mécanisme clé de tous les SGBD OLTP courants: WAL, journal d'écriture anticipée (PostgeSQL), c'est aussi un journal de transactions (SQL Server), alias journal REDO (Oracle).  Le voici - une pierre sur le goulot de la productivité, et c'est le fondement des transactions de durabilité. </p><br><h3 id="chto-takoe-wal">  Qu'est-ce que le WAL? </h3><br><p>  Oublions un instant les SSD modernes, les systèmes de stockage sympas.  Supposons que nous ayons un serveur, il a un ou plusieurs disques. <br>  Toute transaction, même l'insertion d'un enregistrement, est au moins potentiellement, mais en fait presque toujours et de manière réaliste une action non atomique.  Nous devons presque toujours changer non seulement la page où se trouve l'enregistrement, mais aussi les pages d'index, éventuellement les pages de service.  De plus, dans la même transaction, la même page peut changer plusieurs fois.  De plus, d'autres transactions peuvent être effectuées en parallèle avec nous.  De plus - les transactions voisines dans le temps "tirent" constamment les mêmes pages.  Si nous attendons que chaque page soit écrite sur le disque avant de continuer, ce qui est essentiellement ce que la durabilité exige, nous devrons écrire plusieurs fois plus et attendre que chaque enregistrement soit terminé sur un support non volatile.  Pas de caches, pas de réarrangement des opérations dans la file d'attente, sinon il n'y aura pas d'intégrité!  De plus, nous devons en quelque sorte noter quelles données sont déjà sur des transactions fixes et lesquelles ne le sont pas encore (et quelles données étaient antérieures).  Pour la compréhension - un disque dur unique typique (HDD) dans ce mode donnera 50-100 IOPS et cela a été une constante pendant 20 ans.  Une petite transaction nécessitera 5 à 10 opérations d'écriture.  Ah oui, pour savoir quoi enregistrer, il faut le lire.  Même les systèmes OLTP très, très inscriptibles lisent 3 fois plus qu’ils n’écrivent.  Ainsi, notre transaction coûte entre 20 et 40 E / S, ce qui signifie 0,2 à 0,8 seconde par disque. <br>  2 transactions par seconde.  Pas assez?  Essayons de disperser les disques?  Oh, mais nous devons encore attendre que le précédent soit enregistré et qu'il n'y ait pas de parallélisme à la fin.  Comment être  Et commençons un fichier journal dans lequel nous enregistrerons séquentiellement toutes les opérations d'écriture dans la base de données et les marques de transaction!  Avantages: </p><br><ul><li>  Les informations sur l'opération peuvent être beaucoup plus compactes que l'enregistrement de la page entière (une taille de page typique est de 8 Ko, les informations écrites dans le journal sont souvent de 0,5 à 1 Ko). </li><li>  Au lieu d'écrire si la transaction est enregistrée ou non directement sur la page, il y a suffisamment d'étiquettes sur le début et la fixation de la transaction dans le journal. </li><li>  Les pages ne peuvent pas être écrites après chaque transaction - plusieurs fois moins.  Le processus de lecture / écriture des données est complètement "délié" du journal. </li><li>  L'essentiel.  Si nous plaçons notre journal sur un disque séparé et écrivons des enregistrements séquentiellement, du fait que vous n'avez pas besoin de repositionner constamment les têtes de disque, même un disque dur domestique dans ce mode réduit jusqu'à 1000 IOPS, étant donné que les petites transactions "coûtent" 2-4 entrées de journal, alors vous pouvez presser 200-400 TPS </li><li>  En cas d'échec, l'état du fichier de données peut être restauré à l'aide d'un tel journal et si une transaction est annulée, les modifications peuvent être annulées. </li></ul><br><p>  Un tel journal est appelé journal d'écriture anticipée / journal des transactions / journal REDO. </p><br><p>  Hourra!  Super!  Il y avait 2 transactions par seconde, il est devenu 300 - amélioré 150 fois.  Et à quel prix?  Il s'avère que le prix est important: </p><br><ul><li>  Dans tous les SGBD courants, la journalisation est strictement cohérente.  Un thread est responsable de l'écriture dans le journal.  Avez-vous 100 processeurs?  Cool.  Et le journal écrit toujours un thread.  La profondeur de la file d'attente est exactement une. </li><li>  Toujours - pas de caches OS, pas de permutations d'opérations.  Les exigences de durabilité sont restées.  Opérations d'écriture: jusqu'à ce que le disque réponde "J'ai écrit, je l'ai écrit directement à la surface, pas dans le cache, c'est sûr" Le SGBD ne continue pas de fonctionner. </li><li>  Si vous placez le fichier journal sur le disque de données, presque tous les avantages de l'enregistrement séquentiel seront perdus.  De plus - pour de bon, s'il y a plusieurs bases de données sur le serveur, puis plusieurs disques pour les magazines. </li><li>  Restauration de transaction (au moins dans MS SQL Server) - lisez le journal et restaurez-en l'état.  Il s'agit d'autant d'opérations d'écriture, voire plus, que d'opérations d'écriture dans la transaction.  Le retour en arrière coûte cher! </li></ul><br><p>  Cette explication est très simplifiée, "sur les doigts".  Cela suffit pour notre sujet.  Le WAL est un mécanisme clé et fondamental pour garantir la transactionnalité, il est nécessairement écrit, l'accès est monothread uniquement pour l'enregistrement séquentiel, du point de vue du stockage, la profondeur de la file d'attente est de 1. </p><br><div class="spoiler">  <b class="spoiler_title">Si ce sujet vous intéresse</b> <div class="spoiler_text"><ul><li>  Un article très introductif sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conception des bases de données</a> </li><li>  Il existe une excellente série d'articles pour SQL Server: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment arrêter d'appeler le journal des transactions SQL Server un fichier journal et arrêter de se battre pour sa taille.</a> </li><li>  Il est intéressant de regarder un peu de l’autre côté, par exemple, la transcription d’un excellent rapport sur le SGBD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tarantool en</a> mémoire </li><li>  Chaque SGBD comporte de nombreuses sections expliquant le fonctionnement de WAL. </li></ul></div></div><br><p>  Le sujet de la journalisation en écriture anticipée dans la base de données doit être au moins minimal connu de toute personne qui, d'une manière ou d'une autre, administre le SGBD ou l'infrastructure du SGBD ou développe des bases de données. </p><br><h3 id="wal-i-shd">  WAL et SHD </h3><br><p>  Les fabricants de stockage «dès la naissance» sont confrontés au SGBD.  C'est pour les bases de données que les entreprises achètent ces complexes incroyablement chers: à partir des stockages de prix de rue de Dell-EMC, HP, Hitachi, NetApp, lors de la conception d'un budget, les yeux sont remplis de larmes de la plupart des cadres supérieurs, à moins, bien sûr, qu'ils n'obtiennent un pourcentage de ce prix.  Mais il y a un conflit d'ingénierie et de marketing.  Je vais l'expliquer en utilisant l'exemple de Dell-EMC, mais uniquement parce que je me souviens où ils ont la documentation. </p><br><p>  Donc: </p><br><ol><li>  Journal à fil unique </li><li>  Le journal d'écriture, c'est-à-dire la latence, est "éternel" par rapport aux performances du processeur </li><li>  Les charges OLTP sont beaucoup de transactions relativement petites, </li><li>  La plupart des autres charges SGBD sont parallèles d'une manière ou d'une autre. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La loi d'Amdahl</a> nous dit sans pitié qu'une charge basse performance à un seul thread rendra inutile l'ajout de processeurs, et les performances seront déterminées par le journal.  De plus, en ce moment, nous ne nous soucierons pas des performances de stockage dans les IOPS, et seule la latence deviendra importante. <br>  Mais ne négligez pas les autres opérations sur le disque - lecture et écriture dans les fichiers de données et <code>tempdb</code> .  La lecture est également une opération "en attente".  Tant qu'une page de données n'est pas lue du disque dans la mémoire, le processeur ne peut pas la traiter.  Mais pour ces opérations, de grandes files d'attente et la permutation des opérations dans cette file d'attente sont possibles: le SGBD sait souvent quelles pages charger en mémoire, quelles pages à vider et met beaucoup de files d'attente pour la lecture à la fois.  Étant donné que dans ce scénario, il est important lorsque la dernière opération du bundle se termine, dans cette charge, au contraire, l'IOPS est plus important pour nous que la latence d'une seule opération.  Pour comprendre la portée: les opérations de lecture dans un système OLTP typique sont de 85% à 95%.  Oui, oui, oui, les opérations d'écriture sont un ordre de grandeur moins. </p><br><p>  Les ingénieurs de stockage des fournisseurs travaillent en étroite collaboration avec les fournisseurs de SGBD et connaissent bien toutes les nuances techniques du fonctionnement d'un SGBD avec un sous-système de disque.  Une bonne planification, partitionnement et allocation des ressources disque pour le SGBD est une compétence complexe et importante de l' <strong>administrateur du système de stockage</strong> .  Le même Dell-EMC a même le livre blanc de base <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">H14621</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">H12341</a> pour les recommandations de partitionnement pour SQL Server - plus d'une centaine de pages.  Hé!  Ce n'est pas un dock détaillé, c'est le livre blanc le plus courant!  Il y en a encore <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plein</a> de spécifiques ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">h15142</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">h16389</a> ... il y a de l'obscurité là-bas).  Les «contigus» de VMware - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Architecture de Microsoft SQL Server sur VMware vSphere</a> ne sont pas loin derrière.  Veuillez noter que ces documents ne sont pas seulement et pas tant pour les administrateurs de base de données que pour les administrateurs d'infrastructure et de stockage. <br>  Je note également que dans tous ces documents, des LUN séparés sont coupés pour les données, les journaux et <code>tempdb</code> .  Oui, quelque part dans les derniers documents, ils disent clairement que pour les solutions All-Flash, cela n'a aucun sens de séparer les journaux sur des supports physiquement séparés, mais les LUN proposent toujours de les couper séparément.  Si vous transférez des données et vous connectez dans un LUN, du point de vue du système d'exploitation, ce sera une file d'attente IO.  Et il y aura un problème.  Les opérations de latence auront immédiatement un ordre de grandeur de plus.  Et du fait que des opérations de journalisation non déplaçables apparaîtront dans la file d'attente, IOPS glissera sur les fichiers de données et <code>tempdb</code> .  Ce n'est pas une "découverte du siècle", c'est une vérité élémentaire de travailler avec la base de données.  Il n'est pas obsolète ni annulé avec l'avènement de All-Flash.  Oui, les retards dans les opérations avec les disques SSD sont plus rapides d'un ordre de grandeur que dans les opérations avec les disques durs, mais toujours deux fois plus lents que les opérations avec mémoire.  IO est toujours le goulot d'étranglement du SGBD. <br>  Et les documents techniques soulignent correctement que dans les journaux de transactions, le nombre d'IOPS n'est pas important, mais il est important que la latence soit minimale (dans les temps modernes, il est écrit moins de 1 ms). </p><br><p>  Mais les commerçants doivent vendre.  Hyperconvergence!  Virtualisation!  Flexibilité de déploiement!  Déduplication!  Configuration facile!  Beaucoup, beaucoup d'IOPS!  Belles présentations, voix confiante, costumes formels.  Mais comment vendre autrement une solution avec un prix de 6 à 7 chiffres en dollars?  Pour cela, on oublie en quelque sorte que la latence ou le débit peuvent être obtenus à partir du système de stockage, mais pas les deux à la fois, qu'une sorte de licence pour l'équilibreur de charge est comme une autre étagère, que si l'enregistrement intensif dure plus d'une heure, alors la RAM des contrôleurs ce n'est pas suffisant et la productivité descendra "comme s'il n'y avait pas de cache", que la formation des employés du client coûte encore 100 000 roubles pour la première année, eh bien, de telles astuces ... </p><br><h3 id="5-ms">  5 ms </h3><br><p>  Soit avoir beaucoup entendu parler de la lecture des spécialistes du marketing, soit de la paresse, soit à cause d'une sorte de cafards, mais pour une raison quelconque, les administrateurs de stockage font souvent quelque chose comme ça.  Nous prenons une grande étagère, combinons le tout en quelque chose de plat, le coupons en LUN provisionnés fins et le distribuons par LUN au serveur.  Ou deux, parce que "la partition système est bien dédupliquée".  Et quand, je vois qu'avec le sous-système de disque du côté de l'enfer-enfer-enfer SQL, alors la chanson commence que "5 ms est un excellent indicateur", que "100000 IOPS", "Votre charge de stockage est inférieure à 5%" </p><br><p>  <strong>Non</strong> . </p><br><ul><li>  Pour les systèmes OLTP sur une partition avec WAL / journaux de transactions de 5 ms, il s'agit d'un indicateur non valide.  Sur le morceau de fer "presque marchandise" pour un prix de 1000 (en mots: mille) fois moins cher, l'indicateur normal sera désormais 0,1-0,3 ms.  Et demain - 0,01 ms.  La vitesse, comme celle du disque dur 2008, au prix de toute une entrée d'appartements à Moscou, n'est pas nécessaire.  Aucune «facilité d'entretien» n'en vaut la peine. </li><li>  Le fournisseur écrit-il que les journaux de transactions n'exigent pas d'IOPS et peuvent-ils être placés sur le disque dur?  Oui.  Mais pour cela, il est nécessaire qu'aucun de ces disques <del>  contagion </del>  En plus d'écrire des journaux, le SGBD n'a pas touché la tâche.  Et pour que le système de stockage réponde au serveur que les données sont écrites, immédiatement lorsque les données sont entrées dans la mémoire non volatile (c'est beaucoup plus tôt qu'elles ne seront écrites) </li><li>  Les disques minces pour les vraies bases de données OLTP sont mauvais. </li><li>  Pour WAL, il n'est absolument pas intéressant de savoir combien d'IOPS peut être compressé à une profondeur de file d'attente de 10 ou 20. Il n'y a pas de profondeur là-bas. </li><li>  Pour WAL, ce n'est absolument pas un indicateur que la file d'attente d'E / S dans le système d'exploitation est «seulement environ 1».  Elle ne sera plus. </li><li>  Non, les développeurs DBA et DB ne sont pas des "pics excentriques qui ne peuvent pas correctement configurer pour écrire sur le parallèle WAL" <em>(avis réel de l'administrateur)</em> </li><li>  La logique des fans de considérer le recyclage "puisque votre système que <em>nous avons configuré de manière tordue dans une partition</em> ne fait pas 10 000 IOPS, alors il doit être déplacé d'une baie haut de gamme vers le milieu de gamme" - c'est une logique incorrecte. </li><li>  Si le serveur à 40 cœurs a une charge de processeur de 2,5%, cela ne signifie pas qu'il n'a rien à faire, mais, très probablement, signifie qu'il existe une sorte de tâche qui bloque tout le monde. </li></ul><br><p>  Lorsque le chargement de certaines données sur l'ordinateur portable du développeur prend 5 minutes, et sur le 40e serveur nucléaire avec 1 TiB de RAM et un stockage pour un demi-million de dollars, la même tâche est effectuée pendant une heure, même les clients les plus patients auront des questions sur la faisabilité des coûts. </p><br><table><thead><tr><th>  Latence moyenne de la partition WAL </th><th>  il n'y aura jamais plus de transactions par seconde que: </th></tr></thead><tbody><tr><td>  5 ms </td><td>  200 </td></tr><tr><td>  1 ms </td><td>  1000 </td></tr><tr><td>  0,5 ms </td><td>  2000 </td></tr><tr><td>  0,1 ms </td><td>  10 000 </td></tr><tr><td>  0,05 ms </td><td>  20000 </td></tr></tbody></table><br><h2 id="chto-delat">  Que faire </h2><br><h3 id="sovety-administratoram-i-dba">  Conseils d'administration et DBA </h3><br><p>  Pour OLTP, arrêtez de compter «recyclage» et IOPS.  Séparément, je note - ne regardez pas du tout les IOPS avec de grandes profondeurs de file d'attente: même sur les partitions de données, les grandes files d'attente ont généralement une courte rafale ou quelque chose qui n'affecte pas les performances réelles d'OLTP. </p><br><p>  Le partage d'espace disque par LUN n'est pas un caprice DBA.  La base de données possède plusieurs profils de chargement de sous-système de disque différents.  Au minimum, on peut distinguer: </p><br><ul><li>  Travaillez avec des fichiers de données.  Il s'agit généralement de lire et d'écrire avec des blocs aléatoires de 8/64 Ko.  Lectures 80-95%.  Des files d'attente surviennent: pendant les périodes de service, pendant les périodes de chargement en vrac, sur des demandes inefficaces ou massives, et pendant le point de contrôle.  La performance est affectée par la réactivité à la lecture.  Il est important que l'alignement des blocs 8/64 KiB «à travers» passe par l'ensemble du système de stockage. </li><li>  Travailler avec <code>tempdb</code> est le même que travailler avec des fichiers de données, mais les lectures sont généralement de 40 à 75% et la réactivité en écriture peut être importante.  Dans les systèmes MS SQL modernes, cette base de données peut être chargée plusieurs fois plus fort que les bases de données.  Dans une configuration de SGBD non en cluster, cette section doit être exclue de toute réplication de stockage.  Son contenu après le redémarrage du service sera toujours détruit. </li><li>  Travailler avec des données archivées / DWH.  Les lectures sont proches de 100%.  La taille d'un bloc de lecture est généralement de 64 Ko.  Les demandes sont lues beaucoup et d'affilée, de sorte que la file d'attente peut sauter jusqu'à 1000 ou plus. </li><li>  Travaillez avec les journaux de transactions.  La lecture est uniquement destinée à la maintenance (sauvegarde, réplication, etc.), les performances des applications ne sont affectées que par l'écriture.  Enregistrement en blocs de 0,5 à 64 Ko.  Sans file d'attente, dans un seul fil.  Le délai est critique pour les applications. </li><li>  Sauvegarde et restauration.  Du point de vue de la base de données, on lit en gros blocs (souvent 1 Mio).  Il est important que cette charge puisse reposer sur les canaux / bus (FC et Ethernet) et sur les performances des processeurs de stockage dans certains cas.  La sauvegarde d'un serveur peut affecter les performances des autres serveurs du même SAN / SHD. </li><li>  Travailler avec des fichiers d'application: ce sont les journaux, la trace par défaut, les fichiers binaires, etc.  Cette charge est rarement importante et n'est importante qu'au début du système. </li></ul><br><p>  Il existe d'autres types de charge, mais ils sont légèrement exotiques (par exemple, il peut y avoir un référentiel de fichiers stockés dans la base de données sous la forme du répertoire FileStream).  Tous ces types de charges ont des exigences de disque différentes, souvent conflictuelles.  S'ils sont tous empilés sur une partition, vous dégrade non seulement les performances, mais il est très important que vous perdiez la capacité de comprendre pourquoi le système ralentit, et vous perdez également la possibilité d'améliorer uniquement la partie qui a besoin d'amélioration sans améliorations / mises à niveau globales du stockage.  Par conséquent, la principale recommandation: </p><br><p> <strong>      ,   "   "        .        .</strong> </p><br><p>     </p><br><ul><li>    ,   .  Dell/EMC  SQL Server     . </li><li>    .      ""  (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> NUC c SSD,  , </a> ).    --,    . </li><li>      <strong></strong>     DBA,    -   ( 200   ). </li><li>        (etrolaster   ), ,     ,  .      +0,5 ,    0,2,     0,7     3 . </li><li>   ,          .      <code>tempdb</code>  , , ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RCSI</a>   12      . </li><li> Latency    throughput.         ,   " ",   .    throughput  latency,    .      . </li></ul><br><h3 id="ms-sql-server"> MS SQL Server </h3><br><p>    MS SQL,            bottleneck  ,  - : </p><br><ol><li>        .  C'est correct.        . 1000          5-30      1000 <code>INSERT</code> . , , ,       ,      "  —  ". </li><li>  <code>tempdb</code>   " ".    . ,     ,       . </li><li>     ,    BULK INSERT      .            ,      "Simple"  "Bulk logged". , ,         Simple/Bulk logged  Full  .         — <a href="">The Data Loading Performance Guide</a> ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .   (  ETL,   OLTP)       <a href="">We Loaded 1TB in 30 Minutes with SSIS, and So Can You</a> </li><li>    SQL Server  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Delayed Transaction Durability</a> — ,       . </li><li>    SQL Server  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">In-Memory OLTP</a> .    ,        . </li><li> ,     ,   AlwaysOn . </li></ol><br><h2>  *** </h2><br><p>  C’est tout.   . 20000 IOPS  5  latency    4-16         OLTP.  OLTP    ,        . </p><br><div class="spoiler"> <b class="spoiler_title">PS:    SSD.</b> <div class="spoiler_text"><p>              .  Intel Optane.   SSD ""       4,       .            SSD, ,     ,      .    SSD  . ,      ""   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,    </a> .      Intel Optane:      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> )        1     20 .     ,  . SSD        100-300 .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>     SSD. <br>  , .         OLTP "",  in-memory     ACID.     latency 20      "" .  low-latency        Optane ( <em>    ?</em> ). <br>          ( ) Optane. </p></div></div><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">eugeneb0</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">apatyukov</a>     . </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414269/">https://habr.com/ru/post/fr414269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414255/index.html">Rêve breveté du programmeur - Partie II</a></li>
<li><a href="../fr414261/index.html">Où stockez-vous les données?</a></li>
<li><a href="../fr414263/index.html">Y a-t-il de la vie en dehors de Roscosmos? Aperçu de l'exploration de l'espace privé russe</a></li>
<li><a href="../fr414265/index.html">Richard Hamming: Chapitre 7. Intelligence artificielle - II</a></li>
<li><a href="../fr414267/index.html">Comment remplacer un comptable par un robot?</a></li>
<li><a href="../fr414271/index.html">Comment apprivoiser un disque dur dans un ordinateur portable et empêcher le stationnement en 8 secondes d'arrêt</a></li>
<li><a href="../fr414273/index.html">Ce que vous devez savoir avant de développer un backtester pour une stratégie de trading: problèmes typiques, types de systèmes et leurs paramètres</a></li>
<li><a href="../fr414277/index.html">L'homme, son environnement et l'Internet des objets</a></li>
<li><a href="../fr414279/index.html">Vote des rapports lors de la huitième réunion de bricolage du groupe Mail.Ru (07.07.2018)</a></li>
<li><a href="../fr414281/index.html">Développement d'un compteur de vitesse de vélo basé sur un écran du Nokia 3310</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>