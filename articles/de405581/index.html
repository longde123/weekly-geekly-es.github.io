<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíé üéì üóº Automatischer Antennenschalter mit MK-Steuerung üë®üèª‚Äçüè≠ üìΩÔ∏è üçÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Amateurfunkpraxis besteht manchmal die Notwendigkeit, etwas am Mikrocontroller zu tun. Wenn Sie diese Art des Bastelns nicht st√§ndig ausf√ºhren,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatischer Antennenschalter mit MK-Steuerung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/405581/"><div style="text-align:center;"><img src="https://habrastorage.org/web/263/1bc/d85/2631bcd85f59492fbe35cfccc226fb15.jpg" alt="Bild"></div><br>  In der Amateurfunkpraxis besteht manchmal die Notwendigkeit, etwas am Mikrocontroller zu tun.  Wenn Sie diese Art des Bastelns nicht st√§ndig ausf√ºhren, m√ºssen Sie lange Zeit die erforderliche Schaltungsl√∂sung und geeignete Bibliotheken f√ºr MK googeln, damit Sie das Problem schnell l√∂sen k√∂nnen.  Vor kurzem wollte ich einen automatischen Antennenschalter machen.  Dabei musste ich viele der Atmega MK-Funktionen in einem kompakten Projekt verwenden.  Diejenigen, die anfangen, AVR zu studieren, von Arduino zu wechseln oder gelegentlich MK zu programmieren, k√∂nnen n√ºtzliche Codeteile sein, die von mir im Projekt verwendet werden. <br><a name="habracut"></a><br>  Ich stellte mir den Antennenschalter als ein Ger√§t vor, das die Antenne automatisch mit dem Transceiver verbindet, der f√ºr den Arbeitsbereich von Kurzwellen am besten geeignet ist.  Ich habe zwei Antennen: Inverted V und Ground Plane. Sie sind mit dem MFJ-Antennentuner verbunden, in dem sie ferngeschaltet werden k√∂nnen.  Es gibt einen Marken-Handschalter MFJ, den ich ersetzen wollte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b6e/63f/073/b6e63f07338f40babb1c1cfb06eed94f.gif" alt="Bild"></div><br>  Zum betrieblichen Schalten von Antennen ist eine Taste mit dem MK verbunden.  Ich habe es angepasst, um die bevorzugte Antenne f√ºr jeden Bereich zu speichern: Wenn Sie die Taste l√§nger als 3 Sekunden dr√ºcken, wird die ausgew√§hlte Antenne gespeichert und nach dem n√§chsten Einschalten des Ger√§ts automatisch korrekt ausgew√§hlt.  Informationen √ºber den aktuellen Bereich, die ausgew√§hlte Antenne und den Status ihrer Abstimmung werden auf einem einzeiligen LCD-Display angezeigt. <br><br>  Sie k√∂nnen auf verschiedene Arten herausfinden, an welchem ‚Äã‚ÄãBereich der Transceiver gerade arbeitet: Sie k√∂nnen die Signalfrequenz messen, Sie k√∂nnen Daten √ºber die CAT-Schnittstelle empfangen, aber f√ºr mich ist es am einfachsten, die YAESU-Transceiver-Schnittstelle zum Anschlie√üen eines externen Verst√§rkers zu verwenden.  Es hat 4 Signalleitungen im Bin√§rcode, die den aktuellen Bereich anzeigen.  Sie geben ein logisches Signal von 0 bis 5 Volt und k√∂nnen √ºber ein Paar Abschlusswiderst√§nde mit den Beinen des MK verbunden werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/85f/6b9/ebf/85f6b9ebf2aa4fe496fc48501171675e.jpg" alt="Bild"></div><br>  Das ist noch nicht alles.  Im √úbertragungsmodus werden die PTT- und ALC-Signale √ºber dieselbe Schnittstelle √ºbertragen.  Dies ist ein logisches Signal zum Einschalten des Senders (auf den Boden gezogen) und ein analoges Signal von 0 bis -4 V √ºber den Betrieb des Leistungssteuerungssystems des automatischen Senders.  Ich habe mich auch entschlossen, es zu messen und im √úbertragungsmodus auf dem LCD anzuzeigen. <br><br>  Dar√ºber hinaus kann der MFJ-Tuner Signale an die Fernbedienung senden, dass er abstimmt und die Antenne abgestimmt ist.  Zu diesem Zweck verf√ºgt das Unternehmensbedienfeld MFJ √ºber zwei Steuer-LEDs.  Anstelle von LEDs habe ich die Optokoppler angeschlossen und ein Signal von ihnen an den MK gesendet, damit ich alle Informationen auf einem Display sehen konnte.  Das fertige Ger√§t sieht so aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e33/38f/2f8/e3338f2f8fff4187b523c0adbdda2d23.jpg" alt="Bild"></div><br>  Kurz √ºber hausgemacht wie alles.  Nun zum Software-Teil.  Der Code ist in Atmel Studio geschrieben (kostenloser Download von der Atmel-Website).  Das Projekt f√ºr Anf√§nger demonstriert die folgenden Funktionen der Verwendung des beliebten Atmega8 MK: <br><br><ol><li>  Verbindungstaste </li><li>  Schlie√üen Sie den Leitungseingang f√ºr das digitale Signal von Transceiver und Tuner an </li><li>  Anschlie√üen des Steuerausgangs des Antennenschaltrelais </li><li>  Anschlie√üen eines einzeiligen LCD-Displays </li><li>  Summeranschluss und Tonausgabe </li><li>  Analoge ADC-Eingangsleitung und Spannungsmessung </li><li>  Interrupts verwenden </li><li>  Verwenden eines Timers zum Z√§hlen der Zeit, die eine Taste gedr√ºckt wird </li><li>  Watchdog verwenden </li><li>  Verwenden eines nichtfl√ºchtigen Speichers zum Speichern ausgew√§hlter Antennen </li><li>  Verwenden von UART f√ºr den Debug-Druck </li><li>  Energie sparen im Leerlauf MK </li></ol><br>  Also fangen wir an.  Im Verlauf des Textes gibt es alle Arten von Registernamen und Konstanten, die f√ºr das angewendete MK charakteristisch sind.  Dies ist kein Arduino, hier muss man leider das Datenblatt auf MK lesen.  Andernfalls verstehen Sie nicht, was all diese Register bedeuten und wie Sie ihre Werte √§ndern k√∂nnen.  Die Struktur des gesamten Programms bleibt jedoch unver√§ndert. <br><br><h3>  Verbinden Sie zuerst den Knopf mit dem MK </h3><br>  Das ist das einfachste.  Wir verbinden einen Kontakt mit dem MK-Fu√ü, den zweiten Knopfkontakt mit dem Boden.  Damit die Taste funktioniert, m√ºssen Sie den Pull-up-Widerstand in MK einschalten.  Er verbindet den Knopf √ºber den Widerstand mit dem + 5V-Bus.  Dies zu tun ist ganz einfach: <br><br><pre><code class="cpp hljs">PORTB |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB2); <span class="hljs-comment"><span class="hljs-comment">// pullup resistor  </span></span></code> </pre> <br>  Ebenso werden alle digitalen Eing√§nge, die durch einen Erdschluss gesteuert werden (Optokoppler, Signalleitungen vom Transceiver, PTT-Signal), auf den + 5V-Bus gezogen.  Manchmal ist es besser, einen so kleineren Widerstand (z. B. 10k) zwischen dem Eingang des MK und dem + 5V-Bus physikalisch zu l√∂ten, aber die Diskussion dieses Problems geht √ºber den Rahmen des Artikels hinaus.  Da alle Eingangssignale im Projekt selten Werte √§ndern, werden sie zum Schutz vor Interferenzen von 10 Nanofarad-Kondensatoren auf den Boden geleitet. <br><br>  Jetzt haben wir die logische 1 am Eingang PB2, und wenn Sie die Taste dr√ºcken, ist sie logisch 0. Wenn Sie \ dr√ºcken, m√ºssen Sie den Kontaktsprung der Taste verfolgen und √ºberpr√ºfen, ob sich der Signalpegel im Laufe der Zeit nicht ge√§ndert hat, z. B. 50 Millisekunden.  Dies geschieht im Programm wie folgt: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(PINB&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;PINB2)) &amp;&amp; !timer_on) { <span class="hljs-comment"><span class="hljs-comment">//    _delay_ms(50); if( !(PINB&amp;(1&lt;&lt;PINB2)) ) { //        -   passed_secs = 0; timer_on = 1; } }</span></span></code> </pre><br><h3>  Schlie√üen Sie nun den Quietscher an </h3><br>  Es wird ein Audio-Best√§tigungssignal ausgegeben, dass die Antenne im MK-Speicher aufgezeichnet ist.  Ein Hocht√∂ner ist nur ein piezoelektrisches Element.  Es ist durch einen kleinen Widerstand mit dem MK-Fu√ü und durch einen zweiten Kontakt mit +5 V verbunden.  Damit dieser Summer funktioniert, m√ºssen Sie zuerst den MK-Fu√ü f√ºr die Ausgabe von Daten konfigurieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_buzzer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTB &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB0); <span class="hljs-comment"><span class="hljs-comment">// buzzer DDRB |= (1 &lt;&lt; PB0); // output PORTB &amp;= ~(1 &lt;&lt; PB0); }</span></span></code> </pre><br>  Jetzt kann es verwendet werden.  Zu diesem Zweck wird eine kleine Funktion geschrieben, die Zeitverz√∂gerungen verwendet, um die MK-Beine von 0 auf 1 und umgekehrt umzuschalten.  Durch Umschalten mit den erforderlichen Verz√∂gerungen kann am MK-Ausgang, dem Klang des piezoelektrischen Elements, ein 4-kHz-Audiosignal mit einer Dauer von etwa einer Viertelsekunde erzeugt werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buzz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    4 0,25  for(int i=0; i&lt;1000; i++) { wdt_reset(); //    PORTB |= (1 &lt;&lt; PB0); _delay_us(125); PORTB &amp;= ~(1 &lt;&lt; PB0); _delay_us(125); } }</span></span></code> </pre><br>  Vergessen Sie nicht, die Header-Datei einzuschlie√üen und die Prozessorgeschwindigkeitskonstante einzustellen, damit die Verz√∂gerungsfunktionen funktionieren.  Sie entspricht der Frequenz des an den MK angeschlossenen Quarzresonators.  In meinem Fall gab es 16 MHz Quarz. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> F_CPU # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000UL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;util/delay.h&gt;</span></span></span></span></code> </pre><br><h3>  Wir schlie√üen an die MK-Relais-Schaltantennen an </h3><br>  Hier m√ºssen Sie nur den MK-Fu√ü konfigurieren, um auf dem Weg nach drau√üen zu arbeiten.  Ein Reed-Relais ist in √ºblicher Weise √ºber einen Verst√§rkungstransistor mit diesem Zweig verbunden. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_tuner_relay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTB &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB1); <span class="hljs-comment"><span class="hljs-comment">// relay DDRB |= (1 &lt;&lt; PB1); // output PORTB &amp;= ~(1 &lt;&lt; PB1); }</span></span></code> </pre><br><h3>  Verbindung anzeigen </h3><br>  Ich habe ein einzeiliges 16-Zeichen-LCD-Display mit 1601 verwendet, das aus alter Hardware extrahiert wurde.  Es verwendet den bekannten HD44780-Controller, f√ºr dessen Verwaltung viele Bibliotheken im Netzwerk verf√ºgbar sind.  Eine freundliche Person hat eine leichtgewichtige Display-Steuerungsbibliothek geschrieben, die ich im Projekt verwendet habe.  Das Einrichten der Bibliothek reduziert sich darauf, in der Header-Datei HD44780_Config.h die Anzahl der MK-Beine anzugeben, die mit den gew√ºnschten Anzeigestiften verbunden sind.  Ich habe eine Displayverbindung √ºber 4 Datenleitungen angelegt. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Data_Length 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NumberOfLines 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Font 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Strob_Signal_E PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_Strob_Signal_E 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Strob_Signal_RS PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_Strob_Signal_RS 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_4 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_4 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_5 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_5 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_6 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_6 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_7 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_7 3</span></span></code> </pre><br>  Ein Merkmal meiner Anzeigeinstanz war, dass eine Zeile auf dem Bildschirm als zwei Zeilen mit 8 Zeichen angezeigt wurde, sodass im Programm ein Zwischenbildschirmpuffer erstellt wurde, um die Arbeit mit dem Bildschirm zu vereinfachen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTC &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PC0); <span class="hljs-comment"><span class="hljs-comment">// display DDRC |= (1 &lt;&lt; PC0); // output PORTC &amp;= ~(1 &lt;&lt; PC0); PORTC &amp;= ~(1 &lt;&lt; PC1); // display DDRC |= (1 &lt;&lt; PC1); // output PORTC &amp;= ~(1 &lt;&lt; PC1); PORTC &amp;= ~(1 &lt;&lt; PC2); // display DDRC |= (1 &lt;&lt; PC2); // output PORTC &amp;= ~(1 &lt;&lt; PC2); PORTC &amp;= ~(1 &lt;&lt; PC3); // display DDRC |= (1 &lt;&lt; PC3); // output PORTC &amp;= ~(1 &lt;&lt; PC3); PORTC &amp;= ~(1 &lt;&lt; PC4); // display DDRC |= (1 &lt;&lt; PC4); // output PORTC &amp;= ~(1 &lt;&lt; PC4); PORTC &amp;= ~(1 &lt;&lt; PC5); // display DDRC |= (1 &lt;&lt; PC5); // output PORTC &amp;= ~(1 &lt;&lt; PC5); LCD_Init(); LCD_DisplEnable_CursOnOffBlink(1,0,0); } /*   16  0-3   40M     4-8   A:GP  A:IV     9-15    : TUNING=, TUNED==, HI-SWR= */ uchar display_buffer[]={' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '}; // 16    void update_display() { LCD_Init(); LCD_DisplEnable_CursOnOffBlink(1,0,0); //   16      8         LCD for (uchar i=0; i&lt;8; i++){ LCD_Show(display_buffer[i],1,i); LCD_Show(display_buffer[i+8],2,i); } }</span></span></code> </pre><br>  Mit der Funktion update_display () k√∂nnen Sie den Inhalt des Puffers auf dem Bildschirm anzeigen.  Die Bytewerte im Puffer sind die ASCII-Codes der Ausgabezeichen. <br><br><h3>  Debuggen der Druckausgabe an den COM-Anschluss </h3><br>  MK hat UART und ich habe es verwendet, um das Programm zu debuggen.  Wenn Sie den MK an den Computer anschlie√üen, m√ºssen Sie nur ber√ºcksichtigen, dass die Signalpegel am MK-Ausgang dem TTL-Standard und nicht RS232 entsprechen. Daher ben√∂tigen Sie einen einfachen Adapter.  Ich habe einen USB-Serial-Adapter verwendet, √§hnlich wie bei aliexpress.  Jedes Terminalprogramm, zum Beispiel von Arduino, ist zum Lesen von Daten geeignet.  Setup-Code f√ºr den UART-Port: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BAUD 9600 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;avr/io.h&gt; // UART      RS232 void uart_init( void ) { /* //   UBRRH = 0; UBRRL = 103; //9600   16  */ #include &lt;util/setbaud.h&gt; UBRRH = UBRRH_VALUE; UBRRL = UBRRL_VALUE; #if USE_2X UCSRA |= (1 &lt;&lt; U2X); #else UCSRA &amp;= ~(1 &lt;&lt; U2X); #endif //8  , 1  ,    UCSRC = ( 1 &lt;&lt; URSEL ) | ( 1 &lt;&lt; UCSZ1 ) | ( 1 &lt;&lt; UCSZ0 ); //     // UCSRB = ( 1 &lt;&lt; TXEN ) | ( 1 &lt;&lt;RXEN ); UCSRB = ( 1 &lt;&lt; TXEN ); } int uart_putc( char c, FILE *file ) { //     while( ( UCSRA &amp; ( 1 &lt;&lt; UDRE ) ) == 0 ); UDR = c; wdt_reset(); return 0; } FILE uart_stream = FDEV_SETUP_STREAM( uart_putc, NULL, _FDEV_SETUP_WRITE ); stdout = &amp;uart_stream;</span></span></span></span></code> </pre><br>  Nach dem Einrichten des Ausgabestreams k√∂nnen Sie mit dem √ºblichen printf an den Port drucken: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"Start flag after reset = %u\r\n"</span></span>, mcusr_mirror );</code> </pre> <br>  Das Programm verwendet das Drucken von reellen Zahlen.  Normale Bibliotheken unterst√ºtzen diesen Ausgabemodus nicht, daher musste ich beim Verkn√ºpfen eines Projekts eine vollst√§ndige Bibliothek verbinden.  Es stimmt, es erh√∂ht die Menge an Code ernsthaft, aber ich hatte einen gro√üen Speichervorrat, also war es unkritisch.  In den Linker-Optionen m√ºssen Sie die Zeile angeben: <br><br> <code>-Wl,-u,vfprintf -lprintf_flt</code> <br> <br><h3>  Arbeiten Sie mit Timer und Interrupts </h3><br>  Um Zeitintervalle in einem Programm zu z√§hlen, ist es wichtig, einen Zeitz√§hler zu haben.  Es muss nachverfolgt werden, dass die Taste l√§nger als 3 Sekunden gedr√ºckt wurde. Daher m√ºssen Sie sich die neuen Einstellungen im nichtfl√ºchtigen Speicher merken.  Um die Zeit im AVR-Stil zu messen, m√ºssen Sie den Impulsz√§hler des Taktgenerators und den Interrupt konfigurieren, der ausgef√ºhrt wird, wenn der Z√§hler den eingestellten Wert erreicht.  Ich habe den Timer so eingestellt, dass er ungef√§hr einmal pro Sekunde einen Interrupt erzeugt.  Der Interrupt-Handler selbst z√§hlt die Anzahl der verstrichenen Sekunden.  Die Variable timer_on steuert das Ein- und Ausschalten des Timers.  Es ist wichtig, nicht zu vergessen, alle im Interrupt-Handler aktualisierten Variablen als fl√ºchtig zu deklarieren, da der Compiler sie sonst ‚Äûoptimieren‚Äú kann und das Programm nicht funktioniert. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   1    -     void timer1_init( void ) { TCCR1A = 0; //    1 -   /* 16000000 / 1024 = 15625 ,     15625      1  */ //  CTC, ICP1 interrupt sense (falling)(not used) + prescale /1024 +    (not used) TCCR1B = (0 &lt;&lt; WGM13) | (1 &lt;&lt; WGM12) | (0 &lt;&lt; ICES1) | ((1 &lt;&lt; CS12) | (0 &lt;&lt; CS11) | (1 &lt;&lt; CS10)) | (0 &lt;&lt; ICNC1); OCR1A = 15625; //  TIMSK |= (1 &lt;&lt; OCIE1A); } uchar timer_on = 0; volatile uchar passed_secs = 0; //      e ISR(TIMER1_COMPA_vect) { if (timer_on) passed_secs++; }</span></span></code> </pre><br>  Der Wert von √ºbergeben_secs wird in der Hauptschleife des Programms √ºberpr√ºft.  Wenn die Taste gedr√ºckt wird, startet der Timer und im Hauptprogrammzyklus wird der Timerwert √ºberpr√ºft, w√§hrend die Taste gedr√ºckt wird.  Wenn dieser Wert 3 Sekunden √ºberschreitet, wird das EEPROM geschrieben und der Timer stoppt. <br><br>  Last but not least m√ºssen Sie nach allen Initialisierungen Interrupts mit dem Befehl sei () aktivieren. <br><br><h3>  ALC-F√ºllstandsmessung </h3><br>  Es wird mit dem eingebauten Analog-Digital-Wandler (ADC) hergestellt.  Ich habe die Spannung am Eingang des ADC7 gemessen.  Es muss beachtet werden, dass Sie einen Wert von 0 bis 2,5 V messen k√∂nnen.  und meine Eingangsspannung war von -4V bis 0V.  Daher habe ich den MK √ºber den einfachsten Spannungsteiler an den Widerst√§nden angeschlossen, so dass der Spannungspegel am MK-Eingang auf einem bestimmten Pegel lag.  Au√üerdem brauchte ich keine hohe Genauigkeit, also habe ich eine 8-Bit-Konvertierung angewendet (es reicht aus, nur Daten aus dem ADCH-Register zu lesen).  Als Referenzquelle habe ich ein internes Ion bei 2,56 V verwendet, was die Berechnungen etwas vereinfacht.  Damit der ADC funktioniert, m√ºssen Sie einen 0,1-¬µF-Kondensator an den REF-Fu√ü am Boden anschlie√üen. <br><br>  In meinem Fall arbeitet ADC kontinuierlich und meldet das Ende der Konvertierung durch Aufrufen des Interrupts ADC_vect.  Es wird empfohlen, die Werte mehrerer Konvertierungszyklen zu mitteln, um den Fehler zu verringern.  In meinem Fall schlie√üe ich den Durchschnitt von 2500 Transformationen ab.  Der gesamte ADC-Code sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        ALC #define SAMPLES 2500 //    #define REFERENCEV 2.56 //       #define DIVIDER 2.0 double realV = 0; //     ALC double current_realV = 0; volatile int sampleCount = 0; volatile unsigned long tempVoltage = 0; //     volatile unsigned long sumVoltage = 0; //         void ADC_init() // ADC7 { //   2,56, 8 bit  -   ADCH ADMUX = (1 &lt;&lt; REFS0) | (1 &lt;&lt; REFS1) | (1 &lt;&lt; ADLAR) | (0 &lt;&lt; MUX3) | (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX1) | (1 &lt;&lt; MUX0); // ADC7 // , free running,   ADCSRA = (1 &lt;&lt; ADEN) | (1 &lt;&lt; ADFR) | (1 &lt;&lt; ADIE) | (1 &lt;&lt; ADPS2) | (1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0); //  128 ADCSRA |= (1 &lt;&lt; ADSC); // Start ADC Conversion } ISR(ADC_vect) //     2500  { if (sampleCount++) //    tempVoltage += ADCH; if (sampleCount &gt;= SAMPLES) { sampleCount = 0; sumVoltage = tempVoltage; tempVoltage = 0; } ADCSRA |=(1 &lt;&lt; ADIF); // Acknowledge the ADC Interrupt Flag } realV = -1.0*(DIVIDER * ((sumVoltage * REFERENCEV) / 256) / SAMPLES - 5.0); //   ALC if (realV &lt; 0.0) realV = 0.0; printf("ALC= -%4.2f\r\n", realV); //     </span></span></code> </pre><br><h3>  EEPROM verwenden </h3><br>  Dies ist ein nichtfl√ºchtiger Speicher in MK.  Es ist praktisch, es zum Speichern aller Arten von Einstellungen, Korrekturwerten usw. zu verwenden.  In unserem Fall wird es nur verwendet, um die ausgew√§hlte Antenne f√ºr den gew√ºnschten Bereich zu speichern.  Zu diesem Zweck wird im EEPROM ein 16-Byte-Array zugewiesen.  Sie k√∂nnen jedoch √ºber spezielle Funktionen darauf zugreifen, die in der Header-Datei avr / eeprom.h definiert sind.  Beim Start liest der MK Informationen √ºber die gespeicherten Einstellungen in den RAM und schaltet die gew√ºnschte Antenne je nach aktuellem Bereich ein.  Wenn die Taste l√§ngere Zeit gedr√ºckt wird, wird ein neuer Wert im Speicher aufgezeichnet, der von einem Tonsignal begleitet wird.  Beim Schreiben in das EEPROM werden Interrupts f√ºr alle F√§lle deaktiviert.  Speicherinitialisierungscode: <br><br><pre> <code class="cpp hljs">EEMEM <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ee_bands[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//         unsigned char avr_bands[16]; void EEPROM_init(void) { for(int i=0; i&lt;16; i++) { avr_bands[i] = eeprom_read_byte(&amp;ee_bands[i]); if (avr_bands[i] &gt; 1) avr_bands[i] = ANT_IV; //    EEPROM   ,     FF } }</span></span></code> </pre><br>  Ein Ausschnitt aus dem Verarbeitungscode zum Dr√ºcken einer Taste f√ºr 3 Sekunden und zum Schreiben in den Speicher: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(PINB&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;PINB2)) &amp;&amp; passed_secs &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    3  timer_on = 0; //   read_ant = avr_bands[read_band]; //     cli(); EEPROM_init(); //          sei(); if (read_ant) { avr_bands[read_band] = ANT_GP; } else { avr_bands[read_band] = ANT_IV; } cli(); eeprom_write_byte(&amp;ee_bands[read_band], avr_bands[read_band]); //    EEPROM sei(); buzz(); }</span></span></code> </pre><br><h3>  Watchdog verwenden </h3><br>  Es ist kein Geheimnis, dass der MK unter Bedingungen starker elektromagnetischer St√∂rungen einfrieren kann.  Wenn das Radio in Betrieb ist, gibt es solche St√∂rungen, dass ‚Äûdie Eisen anfangen zu sprechen‚Äú. Daher m√ºssen Sie im Falle eines H√§ngens einen sorgf√§ltigen Neustart des MK sicherstellen.  Ein Watchdog-Timer dient diesem Zweck.  Die Verwendung ist sehr einfach.  F√ºgen Sie zun√§chst die Header-Datei avr / wdt.h in das Projekt ein.  Zu Beginn des Programms m√ºssen Sie nach Abschluss aller Einstellungen den Timer durch Aufrufen der Funktion wdt_enable (WDTO_2S) starten und dann durch Aufrufen von wdt_reset () regelm√§√üig zur√ºcksetzen, da sonst der MK selbst neu gestartet wird.  Zum Debuggen k√∂nnen Sie den Wert des speziellen MCUSR-Registers verwenden, dessen Wert gespeichert und dann an den Debug-Druck ausgegeben werden kann, um herauszufinden, warum der MK neu gestartet wurde. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        //     uint8_t mcusr_mirror __attribute__ ((section (".noinit"))); void get_mcusr(void) \ __attribute__((naked)) \ __attribute__((section(".init3"))); void get_mcusr(void) { mcusr_mirror = MCUSR; MCUSR = 0; wdt_disable(); } printf( "Start flag after reset = %u\r\n", mcusr_mirror );</span></span></code> </pre><br><h3>  Energie sparen f√ºr Umweltliebhaber </h3><br>  W√§hrend MK mit nichts besch√§ftigt ist, kann er einschlafen und auf die n√§chste Unterbrechung warten.  In diesem Fall wird ein wenig elektrische Energie gespart.  Eine Kleinigkeit, aber warum nicht in einem Projekt verwenden.  Dar√ºber hinaus ist es sehr einfach.  F√ºgen Sie die Header-Datei avr / sleep.h hinzu.  Der Hauptteil des Programms besteht aus einer Endlosschleife, in der Sie die Funktion sleep_cpu () aufrufen m√ºssen. Danach schl√§ft der MC ein wenig ein und die Hauptschleife stoppt, bis der n√§chste Interrupt auftritt.  Sie treten w√§hrend des Betriebs des Timers und des ADC auf, sodass MK lange Zeit nicht schl√§ft.  Der Ruhezustand wird festgelegt, wenn der MK durch Aufrufen von zwei Funktionen initialisiert wird: <br><br><pre> <code class="cpp hljs"> set_sleep_mode(SLEEP_MODE_IDLE); <span class="hljs-comment"><span class="hljs-comment">//     IDLE sleep_enable();</span></span></code> </pre><br>  Das ist alles f√ºr jetzt.  Ich habe den Wechsel vorgenommen, er funktioniert erfolgreich bei meinem Amateurfunk ohne Fehler.  Ich hoffe, dass das bereitgestellte Material f√ºr Anf√§nger n√ºtzlich ist. <br><br>  73 de R2AJP </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de405581/">https://habr.com/ru/post/de405581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de405571/index.html">Elemente des nationalen Innovationssystems der USA, Teil 1: Unternehmensumfeld und Steuern, Handels- und Wirtschaftspolitik</a></li>
<li><a href="../de405573/index.html">Automatisches Warnsystem f√ºr Polizeiangriffe</a></li>
<li><a href="../de405575/index.html">Smartphone Bewertung ASUS ZenFone 4 max</a></li>
<li><a href="../de405577/index.html">Nationales Innovationssystem der USA</a></li>
<li><a href="../de405579/index.html">"Guten Morgen Vietnam!": So starten Sie Ihr Internetradio</a></li>
<li><a href="../de405583/index.html">Tragbarer Vibro Lautsprecher PartyFon</a></li>
<li><a href="../de405585/index.html">Lockheed Martin baut einen Prototyp eines bewohnbaren Moduls f√ºr den Weltraum</a></li>
<li><a href="../de405587/index.html">Wir verstehen die Teilchenphysik: 4) Wellen, die klassische Bewegungsgleichung</a></li>
<li><a href="../de405589/index.html">Google hilft Fusionsreaktoren dabei, Plasma im Reaktor mithilfe einer speziellen Software zu erw√§rmen</a></li>
<li><a href="../de405591/index.html">FAS-Beamte w√§hlen Steuerbetreiber f√ºr Waren aus, die von Russen im Ausland gekauft wurden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>