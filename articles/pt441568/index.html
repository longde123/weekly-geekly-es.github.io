<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèΩ üë©‚Äç‚öïÔ∏è üåã Gerenciamento de mem√≥ria Python üö¥ üì≤ üëÜüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Voc√™ j√° se perguntou como os dados com os quais trabalha aparecem nas entranhas do Python? Sobre como as vari√°veis ‚Äã‚Äãs√£o criadas e armazenadas na mem√≥...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gerenciamento de mem√≥ria Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441568/">  Voc√™ j√° se perguntou como os dados com os quais trabalha aparecem nas entranhas do Python?  Sobre como as vari√°veis ‚Äã‚Äãs√£o criadas e armazenadas na mem√≥ria?  Como e quando eles s√£o removidos?  O material, cuja tradu√ß√£o publicamos, √© dedicado √† pesquisa nas profundezas do Python, durante as quais tentaremos descobrir os recursos de gerenciamento de mem√≥ria nessa linguagem.  Depois de estudar este artigo, voc√™ entender√° como funcionam os mecanismos de baixo n√≠vel dos computadores, especialmente aqueles relacionados √† mem√≥ria.  Voc√™ entender√° como o Python abstrai opera√ß√µes de baixo n√≠vel e como ele gerencia a mem√≥ria. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ok/qc/59/okqc59rnficniaz3pfcaaae5onc.jpeg"></a> <br><br>  Saber o que est√° acontecendo no Python permitir√° que voc√™ entenda melhor o comportamento dessa linguagem.  Espero que isso d√™ a voc√™ a oportunidade de apreciar o enorme trabalho que est√° sendo feito na implementa√ß√£o da linguagem usada para que seus programas funcionem exatamente da maneira que voc√™ precisa. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">A mem√≥ria √© um livro vazio</font> </h2><br>  A mem√≥ria do computador, no in√≠cio de seu trabalho, pode ser representada na forma de um livro vazio destinado a contos.  Embora n√£o haja nada em suas p√°ginas, mas em breve os autores das hist√≥rias aparecer√£o, cada um deles quer escrever sua pr√≥pria hist√≥ria neste livro. <br><br>  Como uma hist√≥ria n√£o pode ser escrita em cima de outra, os autores precisam ter cuidado com as p√°ginas do livro em que escrevem.  Antes de escrever qualquer coisa, eles consultam o editor-chefe.  Ele decide onde exatamente os autores podem gravar hist√≥rias. <br><br>  Como o livro sobre o qual estamos falando j√° existe h√° algum tempo, muitas das hist√≥rias j√° est√£o desatualizadas.  Se ningu√©m l√™ uma hist√≥ria ou a menciona em seus trabalhos, essa hist√≥ria √© removida do livro, abrindo espa√ßo para novas hist√≥rias. <br><br>  Em geral, podemos dizer que a mem√≥ria do computador √© muito semelhante a esse livro.  De fato, blocos cont√≠nuos de mem√≥ria de tamanho fixo s√£o chamados de p√°ginas, ent√£o acreditamos que comparar a mem√≥ria com um livro √© muito bem-sucedido. <br><br>  Os autores que escrevem suas hist√≥rias em um livro s√£o aplicativos ou processos diferentes que precisam armazenar dados na mem√≥ria.  O editor-chefe, que decide em quais p√°ginas do livro os autores podem escrever, √© o mecanismo que lida com o gerenciamento de mem√≥ria.  E quem remove hist√≥rias antigas do livro, abrindo espa√ßo para novas, pode ser comparado ao mecanismo de coleta de lixo. <br><br><h2>  <font color="#3AC1EF">Gerenciamento de mem√≥ria: o caminho do ferro para os programas</font> </h2><br>  O gerenciamento de mem√≥ria √© um processo durante o qual os programas gravam dados na mem√≥ria e os l√™em a partir deles.  Um gerenciador de mem√≥ria √© uma entidade que determina onde exatamente um aplicativo pode colocar seus dados na mem√≥ria.  Como o n√∫mero de fragmentos de mem√≥ria que podem ser alocados para aplicativos n√£o √© infinito, assim como o n√∫mero de p√°ginas em qualquer livro n√£o √© infinito, o gerenciador de mem√≥ria, que atende aos aplicativos, precisa encontrar fragmentos de mem√≥ria livres e fornec√™-los aos aplicativos.  Esse processo, no qual a mem√≥ria √© alocada para aplicativos, √© chamado de aloca√ß√£o de mem√≥ria. <br><br>  Por outro lado, quando alguns dados n√£o s√£o mais necess√°rios, eles podem ser exclu√≠dos ou, em outras palavras, liberar a mem√≥ria que ocupam.  Mas o que exatamente eles ‚Äúisolam‚Äù e ‚Äúliberam‚Äù quando falam de mem√≥ria? <br><br>  Em algum lugar do seu computador, existe um dispositivo f√≠sico que armazena dados usados ‚Äã‚Äãpelos programas Python enquanto eles trabalham.  Antes de um objeto Python aparecer na mem√≥ria f√≠sica, o c√≥digo precisa passar por muitas camadas de abstra√ß√£o. <br><br>  Uma das principais camadas, localizada no topo do hardware (como RAM ou disco r√≠gido), √© o sistema operacional (SO).  Ele executa (ou se recusa a atender) solicita√ß√µes para ler dados da mem√≥ria e gravar dados na mem√≥ria. <br><br>  Existe um aplicativo no topo do SO, no nosso caso, uma das implementa√ß√µes do Python (pode ser um pacote de software que faz parte do seu SO ou baixado do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">python.org</a> ).  √â este pacote de software que se dedica ao gerenciamento de mem√≥ria, garantindo a opera√ß√£o do seu c√≥digo Python.  O foco deste artigo est√° nos algoritmos e estruturas de dados que o Python usa para gerenciar a mem√≥ria. <br><br><h2>  <font color="#3AC1EF">Implementa√ß√£o de refer√™ncia Python</font> </h2><br>  A implementa√ß√£o de refer√™ncia do Python √© chamada CPython.  Est√° escrito em C. Quando ouvi falar pela primeira vez, isso literalmente me perturbou.  Uma linguagem de programa√ß√£o escrita em outra linguagem?  Bem, na verdade, isso n√£o √© totalmente verdade. <br><br>  A especifica√ß√£o Python √© descrita em ingl√™s simples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste documento</a> .  No entanto, somente essa especifica√ß√£o, c√≥digo escrito em Python, √© claro, n√£o pode ser executado.  Para fazer isso, voc√™ precisa de algo que, seguindo as regras desta especifica√ß√£o, possa interpretar o c√≥digo escrito em Python. <br><br>  Al√©m disso, voc√™ precisa de algo que possa executar o c√≥digo interpretado no computador.  A implementa√ß√£o de refer√™ncia do Python resolve essas duas tarefas.  Ele converte o c√≥digo em instru√ß√µes que s√£o executadas na m√°quina virtual. <br><br>  M√°quinas virtuais s√£o semelhantes a computadores comuns feitos de sil√≠cio, metal e outros materiais, mas s√£o implementadas em software.  Eles geralmente est√£o ocupados processando instru√ß√µes b√°sicas, semelhantes √†s instru√ß√µes escritas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Assembler</a> . <br><br>  Python √© uma linguagem interpretada.  O c√≥digo escrito em Python √© compilado em um conjunto de instru√ß√µes convenientes para o computador, no chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo de bytes</a> .  Essas instru√ß√µes s√£o interpretadas pela m√°quina virtual quando voc√™ executa seu programa. <br><br>  Voc√™ j√° viu arquivos com a extens√£o <code>.pyc</code> ou a pasta <code>__pycache__</code> ?  Eles cont√™m o mesmo bytecode que √© interpretado pela m√°quina virtual. <br><br>  √â importante observar que, al√©m do CPython, existem outras implementa√ß√µes em Python.  Por exemplo, ao usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IronPython, o</a> c√≥digo Python √© compilado em uma instru√ß√£o Microsoft CLR.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jython, o</a> c√≥digo √© compilado no bytecode Java e executado em uma m√°quina virtual Java.  No mundo Python, existe algo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PyPy</a> , mas √© digno de um artigo separado, ent√£o aqui apenas mencionamos. <br><br>  Para os fins deste artigo, focarei em como os mecanismos de gerenciamento de mem√≥ria funcionam na implementa√ß√£o de refer√™ncia do Python - CPython. <br><br>  Deve-se notar que, embora a maior parte do que falaremos aqui seja verdadeira para novas vers√µes do Python, as coisas podem mudar no futuro.  Portanto, preste aten√ß√£o ao fato de que neste artigo eu me concentro na vers√£o mais recente do Python no momento da reda√ß√£o - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python 3.7</a> . <br><br>  Portanto, o pacote de software CPython √© escrito em C e interpreta o bytecode do Python.  O que isso tem a ver com gerenciamento de mem√≥ria?  O fato √© que os algoritmos e as estruturas de dados usadas para o gerenciamento de mem√≥ria existem no c√≥digo CPython escrito, como j√° foi dito em C. Para entender como o gerenciamento de mem√≥ria funciona no Python, primeiro voc√™ precisa entender um pouco sobre o CPython. <br><br>  A linguagem C na qual o CPython √© gravado n√£o possui suporte interno para programa√ß√£o orientada a objetos.  Por esse motivo, muitas solu√ß√µes arquiteturais interessantes s√£o usadas no c√≥digo CPython. <br><br>  Voc√™ deve ter ouvido falar que tudo no Python √© um objeto, mesmo tipos de dados primitivos como <code>int</code> e <code>str</code> .  E esse √© realmente o caso no n√≠vel de implementa√ß√£o da linguagem no CPython.  Existe uma estrutura chamada <code>PyObject</code> , usada por objetos criados no CPython. <br><br>  Uma estrutura √© um tipo de dados composto que pode agrupar dados de diferentes tipos.  Se voc√™ comparar isso com a programa√ß√£o orientada a objetos, a estrutura ser√° semelhante a uma classe que possui atributos, mas n√£o possui m√©todos. <br><br>  <code>PyObject</code> √© o ancestral de todos os objetos Python.  Essa estrutura cont√©m apenas dois campos: <br><br><ul><li>  <code>ob_refcnt</code> - contador de refer√™ncia. </li><li>  <code>ob_type</code> - ponteiro para outro tipo. </li></ul><br>  O contador de refer√™ncia √© usado para implementar o mecanismo de coleta de lixo.  Outro campo <code>PyObject</code> √© um ponteiro para um tipo espec√≠fico de objeto.  Esse tipo √© representado por outra estrutura que descreve o objeto Python (por exemplo, pode ser do tipo <code>dict</code> ou <code>int</code> ). <br><br>  Cada objeto possui um mecanismo exclusivo de aloca√ß√£o de mem√≥ria, √∫nico para esse objeto, que sabe como obter a mem√≥ria necess√°ria para armazenar esse objeto.  Al√©m disso, cada objeto possui seu pr√≥prio mecanismo para liberar mem√≥ria, o que "libera" a mem√≥ria depois que ela n√£o √© mais necess√°ria. <br><br>  No entanto, deve-se notar que em todas essas conversas sobre aloca√ß√£o e libera√ß√£o de mem√≥ria, h√° um fator importante.  O fato √© que a mem√≥ria do computador √© um recurso compartilhado.  Se, ao mesmo tempo, dois processos diferentes tentarem gravar algo na mesma √°rea de mem√≥ria, algo ruim poder√° acontecer. <br><br><h2>  <font color="#3AC1EF">Bloqueio Global para Int√©rpretes</font> </h2><br>  O Global Interpreter Lock (GIL) √© uma solu√ß√£o para um problema comum que ocorre ao trabalhar com recursos compartilhados do computador, como mem√≥ria.  Quando dois threads tentam modificar simultaneamente o mesmo recurso, eles podem "colidir" entre si.  O resultado ser√° uma bagun√ßa e nenhum dos fluxos alcan√ßar√° o que estava buscando. <br><br>  Vamos voltar √† analogia do livro novamente.  Imagine que dois autores decidiram arbitrariamente que agora era sua vez de fazer anota√ß√µes.  Mas eles tamb√©m decidiram fazer anota√ß√µes simultaneamente na mesma p√°gina. <br><br>  Cada um deles n√£o presta aten√ß√£o ao fato de que o outro est√° tentando escrever sua hist√≥ria.  Juntos, eles come√ßam a escrever texto na p√°gina.  Como resultado, duas hist√≥rias ser√£o gravadas l√°, uma em cima da outra, o que tornar√° a p√°gina completamente ileg√≠vel. <br><br>  Uma das solu√ß√µes para esse problema √© um √∫nico mecanismo global de int√©rpretes que bloqueia recursos compartilhados com os quais um determinado encadeamento est√° trabalhando.  No nosso exemplo, esse √© um "mecanismo" que "bloqueia" a p√°gina de um livro.  Esse mecanismo elimina a situa√ß√£o descrita acima, na qual dois autores escrevem simultaneamente texto na mesma p√°gina. <br><br>  O mecanismo GIL no Python realiza isso bloqueando todo o int√©rprete.  Como resultado, nada pode interferir na opera√ß√£o do encadeamento atual.  E quando o CPython est√° trabalhando com mem√≥ria, ele usa o GIL para garantir que esse trabalho seja realizado com seguran√ßa e efici√™ncia. <br><br>  Existem pontos fortes e fracos nessa abordagem, e o GIL √© objeto de intenso debate na comunidade Python.  Para saber mais sobre o GIL, voc√™ pode dar uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste material</a> . <br><br><h2>  <font color="#3AC1EF">Coleta de lixo</font> </h2><br>  Vamos voltar √† analogia do livro e imaginar que algumas das hist√≥rias registradas neste livro est√£o irremediavelmente desatualizadas.  Ningu√©m os l√™, ningu√©m os menciona em lugar nenhum.  E se ningu√©m l√™ ou se refere a algum material em suas obras, esse material pode ser descartado, abrindo espa√ßo para novos textos. <br><br>  Esses contos antigos e esquecidos podem ser comparados a objetos Python cujas contagens de refer√™ncia s√£o zero.  Esses s√£o os mesmos contadores sobre os quais falamos ao discutir a estrutura do <code>PyObject</code> . <br><br>  O contador de links √© incrementado por v√°rios motivos.  Por exemplo, o contador √© incrementado se o objeto armazenado em uma vari√°vel for gravado em outra vari√°vel: <br><br><pre> <code class="python hljs">numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   = 1 more_numbers = numbers #   = 2</span></span></code> </pre> <br>  Aumenta quando o objeto √© passado para alguma fun√ß√£o como argumento: <br><br><pre> <code class="python hljs">total = sum(numbers)</code> </pre> <br>  E aqui est√° outro exemplo de uma situa√ß√£o em que o n√∫mero no contador de refer√™ncia aumenta.  Isso acontece se o objeto estiver inclu√≠do na lista: <br><br><pre> <code class="python hljs">matrix = [numbers, numbers, numbers]</code> </pre> <br>  O Python permite ao programador descobrir o valor atual da contagem de refer√™ncia de um determinado objeto usando o m√≥dulo <code>sys</code> .  Para isso, √© utilizada a seguinte constru√ß√£o: <br><br><pre> <code class="python hljs">sys.getrefcount(numbers)</code> </pre> <br>  <code>getfefcount()</code> lo, lembre-se de que passar um objeto para o m√©todo <code>getfefcount()</code> aumenta o valor do contador em 1. <br><br>  De qualquer forma, se o objeto ainda for usado em algum lugar do c√≥digo, seu contador de refer√™ncia ser√° maior que 0. Quando o valor do contador cair para 0, uma fun√ß√£o especial entrar√° em jogo, o que "libera" a mem√≥ria ocupada pelo objeto.  Essa mem√≥ria pode ser usada por outros objetos. <br><br>  Agora nos perguntamos sobre o que √© "liberar mem√≥ria" e como outros objetos podem usar essa mem√≥ria.  Para responder a essas perguntas, vamos falar sobre os mecanismos de gerenciamento de mem√≥ria no CPython. <br><br><h2>  <font color="#3AC1EF">Mecanismos de gerenciamento de mem√≥ria no CPython</font> </h2><br>  Agora, falaremos sobre como o CPython tem uma arquitetura de mem√≥ria e como o gerenciamento de mem√≥ria √© feito l√°. <br><br>  Como j√° mencionado, existem v√°rias camadas de abstra√ß√£o entre o CPython e a mem√≥ria f√≠sica.  O sistema operacional abstrai a mem√≥ria f√≠sica e cria uma camada de mem√≥ria virtual com a qual os aplicativos podem trabalhar (isso tamb√©m se aplica ao Python). <br><br>  O gerenciador de mem√≥ria virtual de um sistema operacional espec√≠fico aloca uma parte da mem√≥ria para o processo Python.  As √°reas cinza escuras na imagem a seguir s√£o os peda√ßos de mem√≥ria que pertencem ao processo Python. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/f01/548/e51f0154800b0ae223bf1c7d96f5bab8.png"><br>  <i><font color="#999999">√Åreas de mem√≥ria usadas pelo CPython</font></i> <br><br>  O Python usa uma certa quantidade de mem√≥ria para uso interno e para necessidades n√£o relacionadas √† aloca√ß√£o de mem√≥ria para objetos.  Outra parte da mem√≥ria √© usada para armazenar objetos (esses s√£o valores dos tipos <code>int</code> , <code>dict</code> e outros assim).  Observe que este √© um diagrama simplificado.  Se voc√™ quiser ver a imagem completa, d√™ uma olhada no c√≥digo fonte do <a href="">CPython</a> , onde tudo o que estamos falando est√° acontecendo. <br><br>  O CPython possui um recurso para alocar mem√≥ria para objetos, respons√°vel por alocar mem√≥ria na √°rea destinada ao armazenamento de objetos.  A coisa mais interessante acontece quando esse mecanismo funciona.  √â chamado quando o objeto precisa de mem√≥ria ou nos casos em que a mem√≥ria precisa ser liberada. <br><br>  Normalmente, adicionar ou excluir dados de objetos Python como <code>list</code> e <code>int</code> n√£o envolve o processamento simult√¢neo de grandes quantidades de informa√ß√µes.  Portanto, a arquitetura da ferramenta de aloca√ß√£o de mem√≥ria √© criada com o olho no processamento de pequenas quantidades de dados.  Al√©m disso, essa ferramenta procura n√£o alocar mem√≥ria at√© que fique claro que √© absolutamente necess√°rio. <br><br>  Os coment√°rios no <a href="">c√≥digo-fonte</a> descrevem a ferramenta de aloca√ß√£o de mem√≥ria como "uma ferramenta r√°pida e especializada de aloca√ß√£o de mem√≥ria para pequenos blocos projetados para serem usados ‚Äã‚Äãno topo do malloc universal".  Nesse caso, <code>malloc</code> √© uma fun√ß√£o da biblioteca C projetada para alocar mem√≥ria. <br><br>  Vamos discutir a estrat√©gia de aloca√ß√£o de mem√≥ria usada pelo CPython.  Primeiro, falaremos sobre tr√™s entidades - os chamados blocos (blocos), piscinas (piscinas) e arenas (arena), e como elas se relacionam. <br><br>  As arenas s√£o os maiores fragmentos de mem√≥ria.  Eles est√£o alinhados nas bordas das p√°ginas da mem√≥ria.  O limite da p√°gina √© onde o bloco cont√≠nuo de mem√≥ria de tamanho fixo termina em uso pelo sistema operacional.  O Python, enquanto trabalha com mem√≥ria, assume que o tamanho da p√°gina de mem√≥ria do sistema √© de 256 KB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/4d2/dc2/75e4d2dc2e0f6985363952432b7c169d.png"><br>  <i><font color="#999999">Arenas, Piscinas e Blocos</font></i> <br><br>  Os pools est√£o localizados nas arenas, que s√£o p√°ginas de mem√≥ria virtual de 4 KB.  Eles se assemelham √†s p√°ginas do livro do nosso exemplo.  Os pools s√£o divididos em pequenos blocos de mem√≥ria. <br><br>  Todos os blocos no mesmo pool pertencem √† mesma classe de tamanho.  A classe de tamanho √† qual o bloco pertence determina o tamanho desse bloco, que √© selecionado levando em considera√ß√£o o tamanho da mem√≥ria solicitada.  Aqui est√° uma tabela tirada do c√≥digo-fonte que demonstra a quantidade de dados que o sistema solicita para armazenar na mem√≥ria, os tamanhos dos blocos alocados e os identificadores das classes de tamanho. <br><table><tbody><tr><td>  A quantidade de dados em bytes <br></td><td>  Tamanho do bloco <br></td><td>  tamanho da classe idx <br></td></tr><tr><td>  1-8 <br></td><td>  8 <br></td><td>  0 0 <br></td></tr><tr><td>  9-16 <br></td><td>  16 <br></td><td>  1 <br></td></tr><tr><td>  17-24 <br></td><td>  24 <br></td><td>  2 <br></td></tr><tr><td>  25-32 <br></td><td>  32. <br></td><td>  3 <br></td></tr><tr><td>  33-40 <br></td><td>  40. <br></td><td>  4 <br></td></tr><tr><td>  41-48 <br></td><td>  48. <br></td><td>  5 <br></td></tr><tr><td>  49-56 <br></td><td>  56. <br></td><td>  6 <br></td></tr><tr><td>  57-64 <br></td><td>  64 <br></td><td>  7 <br></td></tr><tr><td>  65-72 <br></td><td>  72 <br></td><td>  8 <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td></tr><tr><td>  497-504 <br></td><td>  504 <br></td><td>  62 <br></td></tr><tr><td>  505-512 <br></td><td>  512 <br></td><td>  63. <br></td></tr></tbody></table><br>  Por exemplo, se for solicitado que 42 bytes sejam armazenados, os dados ser√£o colocados em um bloco de 48 bytes. <br><br><h2>  <font color="#3AC1EF">Piscinas</font> </h2><br>  Pools consistem em blocos pertencentes √† mesma classe de tamanho.  Cada conjunto √© associado a outros conjuntos que cont√™m blocos da mesma classe de tamanho usando o mecanismo de lista duplamente vinculado.  Com essa abordagem, o algoritmo de aloca√ß√£o de mem√≥ria pode encontrar facilmente espa√ßo livre para um bloco de um determinado tamanho, mesmo que seja para encontrar espa√ßo livre em conjuntos diferentes. <br><br>  A lista <code>usedpools</code> permite acompanhar todos os conjuntos nos quais h√° espa√ßo para dados pertencentes a uma classe de tamanho espec√≠fica.  Quando √© solicitado que voc√™ salve um bloco de um determinado tamanho, o algoritmo verifica essa lista em busca de uma lista de conjuntos que armazenam blocos do tamanho necess√°rio. <br><br>  As piscinas em si devem estar em um dos tr√™s estados.  Ou seja, eles podem ser usados ‚Äã‚Äã(estado <code>used</code> ), podem ser preenchidos ( <code>full</code> ) ou vazios ( <code>empty</code> ).  O pool usado possui blocos livres nos quais √© poss√≠vel salvar dados de tamanho adequado.  Todos os blocos do pool preenchido s√£o alocados para dados.  Um conjunto vazio n√£o cont√©m dados e, se necess√°rio, pode ser atribu√≠do para armazenar blocos pertencentes a qualquer classe de tamanho. <br><br>  A lista <code>freepools</code> armazena informa√ß√µes sobre todos os conjuntos que est√£o no estado <code>empty</code> .  Por exemplo, se n√£o houver entradas na lista <code>usedpools</code> sobre pools que armazenam blocos de 8 bytes (classe com idx 0), um novo pool ser√° inicializado, no estado <code>empty</code> , projetado para armazenar esses blocos.  Este novo pool √© adicionado √† lista de <code>usedpools</code> usados ‚Äã‚Äãe pode ser usado para atender a solicita√ß√µes de salvamento de dados recebidos ap√≥s sua cria√ß√£o. <br><br>  Suponha que em um pool que esteja no estado <code>full</code> , alguns blocos sejam liberados.  Isso se deve ao fato de os dados armazenados neles n√£o serem mais necess√°rios.  Esse pool estar√° novamente na lista <code>usedpools</code> e pode ser usado para dados da classe de tamanho correspondente. <br><br>  O conhecimento desse algoritmo nos permite entender como o estado dos conjuntos muda durante a opera√ß√£o (e como as classes de tamanho s√£o alteradas, os blocos pertencentes aos quais podem ser armazenados neles). <br><br><h2>  <font color="#3AC1EF">Blocos</font> </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/627/407/ef5/627407ef5dafac3533d81ae0beec66f2.png"><br>  <i><font color="#999999">Piscinas usadas, cheias e vazias</font></i> <br><br>  Como voc√™ pode ver na ilustra√ß√£o anterior, os pools cont√™m ponteiros para os blocos de mem√≥ria "livres" que eles cont√™m.  No que diz respeito ao trabalho com blocos, um pequeno recurso deve ser observado, indicado no c√≥digo fonte.  O sistema de gerenciamento de mem√≥ria usado no CPython, em todos os n√≠veis (arenas, conjuntos, blocos), esfor√ßa-se para alocar mem√≥ria somente quando √© absolutamente necess√°rio. <br><br>  Isso significa que os conjuntos podem conter blocos que est√£o em um dos tr√™s estados: <br><br><ul><li>  <code>untouched</code> √© a parte da mem√≥ria que ainda n√£o foi alocada. </li><li>  <code>free</code> - a parte da mem√≥ria que j√° foi alocada, mas depois foi liberada pelo CPython e n√£o cont√©m mais dados valiosos. </li><li>  <code>allocated</code> √© a parte da mem√≥ria que cont√©m dados valiosos. </li></ul><br>  O ponteiro de <code>freeblock</code> aponta para uma lista isolada de blocos de mem√≥ria livre.  Em outras palavras, esta √© uma lista de lugares onde voc√™ pode colocar dados.  Se mais de um bloco livre for necess√°rio para colocar os dados, a ferramenta de aloca√ß√£o de mem√≥ria retirar√° v√°rios blocos do pool que est√£o no estado <code>untouched</code> . <br><br>  Como a ferramenta de gerenciamento de mem√≥ria torna os blocos "livres", eles, quando adquirem o estado <code>free</code> , chegam ao topo da lista de <code>freeblock</code> .  Os blocos contidos nesta lista n√£o representam necessariamente uma regi√£o de mem√≥ria cont√≠gua semelhante √† mostrada na figura anterior.  Eles podem realmente parecer com o abaixo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cca/0c7/725/cca0c7725ce480809ee3d59b4a1b28fa.png"><br>  <i><font color="#999999">Lista de bloqueio gratuito vinculada √∫nica</font></i> <br><br><h2>  <font color="#3AC1EF">Arenas</font> </h2><br>  Arenas cont√™m piscinas.  Esses conjuntos, como j√° mencionado, podem residir nos estados <code>used</code> , <code>full</code> ou <code>empty</code> .  Deve-se notar que as arenas n√£o t√™m estados semelhantes aos das piscinas. <br><br>  As arenas s√£o organizadas em uma lista duplamente vinculada chamada <code>usable_arenas</code> .  Essa lista √© classificada pelo n√∫mero de pools gratuitos dispon√≠veis.  Quanto menos piscinas gratuitas na arena, mais pr√≥xima a arena fica do topo da lista. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f91/17d/6f1/f9117d6f1b6670afd7235a2efc936713.png"><br>  <i><font color="#999999">Lista de arenas utiliz√°veis</font></i> <br><br>  Isso significa que a arena, mais forte que outras preenchidas com dados, ser√° selecionada para colocar novos dados nela.  E por que n√£o vice-versa?  Por que n√£o postar novos dados na arena com mais espa√ßo livre? <br><br>  De fato, esse recurso nos leva √† id√©ia de realmente liberar mem√≥ria.  Voc√™ deve ter notado que frequentemente usamos o conceito de "liberar mem√≥ria" aqui, colocando-o entre aspas.  A raz√£o pela qual isso foi feito √© que, embora o bloco possa ser considerado "livre", a parte da mem√≥ria que ele representa n√£o √© realmente devolvida ao sistema operacional.  O processo Python mant√©m esse peda√ßo de mem√≥ria e depois o usa para armazenar novos dados.  A verdadeira libera√ß√£o da mem√≥ria √© o retorno do seu sistema operacional, que pode tirar vantagem disso. <br><br>  As arenas s√£o a √∫nica entidade no esquema considerado aqui, cuja mem√≥ria representada pode ser verdadeiramente liberada.  O senso comum determina que o esquema acima descrito de trabalhar com arenas visa permitir que as arenas quase vazias esvaziem completamente.  Com essa abordagem, a parte da mem√≥ria representada por uma arena completamente vazia pode ser realmente liberada, o que reduzir√° a quantidade de mem√≥ria consumida pelo Python. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Aqui est√° o que voc√™ aprendeu lendo este material: <br><br><ul><li>  O que √© gerenciamento de mem√≥ria e por que √© importante. </li><li>  Como √© organizada a implementa√ß√£o de refer√™ncia do Python, Cpython, escrita na linguagem de programa√ß√£o C. </li><li>  Quais estruturas e algoritmos de dados s√£o usados ‚Äã‚Äãno CPython para gerenciamento de mem√≥ria. </li></ul><br>  O gerenciamento de mem√≥ria √© parte integrante do trabalho dos programas de computador.  O Python resolve quase todas as tarefas de gerenciamento de mem√≥ria despercebidas pelo programador.  O Python permite que qualquer pessoa que escreva nesta linguagem ignore os muitos pequenos detalhes relacionados ao trabalho com computadores.  Isso d√° ao programador a oportunidade de trabalhar em um n√≠vel superior, criar seu pr√≥prio c√≥digo, sem se preocupar com o local onde seus dados est√£o armazenados. <br><br>  <b>Caros leitores!</b>  Se voc√™ tem experi√™ncia no desenvolvimento de Python, conte-nos como voc√™ aborda o uso de mem√≥ria em seus programas.  Por exemplo, voc√™ procura salv√°-lo? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441568/">https://habr.com/ru/post/pt441568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441550/index.html">A vida de um programador simples √© dif√≠cil e clara</a></li>
<li><a href="../pt441554/index.html">Toda a hist√≥ria do Linux. Parte I: como tudo come√ßou</a></li>
<li><a href="../pt441560/index.html">Eventos digitais em Moscou, de 25 de fevereiro a 3 de mar√ßo</a></li>
<li><a href="../pt441562/index.html">Galope do pixel - parte cinco - anima√ß√£o do car√°ter. Caminhada</a></li>
<li><a href="../pt441566/index.html">12 conceitos de JavaScript para conhecer</a></li>
<li><a href="../pt441570/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 353 (17 a 24 de fevereiro de 2019)</a></li>
<li><a href="../pt441572/index.html">Frontend Weekly Digest (18 a 24 de fevereiro de 2019)</a></li>
<li><a href="../pt441574/index.html">Docker de aprendizagem Parte 6: Trabalhando com dados</a></li>
<li><a href="../pt441576/index.html">Redes Kubernetes: Pods</a></li>
<li><a href="../pt441578/index.html">Tutorial Reagir Parte 19: M√©todos do Ciclo de Vida dos Componentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>