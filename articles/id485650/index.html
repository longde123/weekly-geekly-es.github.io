<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏿 🧖🏿 🉐 Teknik Pengurangan Gambar Docker ✊🏼 🎞️ 🚶🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernahkah Anda bertanya-tanya mengapa ukuran wadah Docker yang hanya berisi satu aplikasi bisa sekitar 400 MB? Atau mungkin Anda khawatir tentang ukur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teknik Pengurangan Gambar Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/485650/">  Pernahkah Anda bertanya-tanya mengapa ukuran wadah Docker yang hanya berisi satu aplikasi bisa sekitar 400 MB?  Atau mungkin Anda khawatir tentang ukuran gambar Docker yang agak besar berisi biner tunggal dengan ukuran beberapa puluh MB? <br><br> <a href="https://habr.com/ru/company/ruvds/blog/485650/"><img src="https://habrastorage.org/webt/ny/az/k8/nyazk8uqdkaog5lwtukn8qz1zpu.jpeg"></a> <br><br>  Penulis artikel, terjemahan yang kami terbitkan hari ini, ingin menganalisis faktor utama yang mempengaruhi ukuran wadah Docker.  Dia, di samping itu, akan berbagi rekomendasi untuk mengurangi ukuran kontainer. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Lapisan Gambar Docker</font> </h2><br>  Gambar wadah Docker pada dasarnya adalah kumpulan file yang ditumpuk satu sama lain dalam beberapa lapisan.  Wadah yang berfungsi dirakit dari file-file ini.  Docker menggunakan sistem file <a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a> , di mana file dikelompokkan dalam lapisan.  Lapisan dapat berisi satu file atau beberapa file, lapisan saling tumpang tindih.  Selama pelaksanaan wadah, konten lapisan digabungkan, sebagai akibatnya, pengguna akhir wadah menganggap materi “ditata” berlapis-lapis sebagai sistem file tunggal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/3ba/eea/0a23baeea85753e1a66d8399ff188b4c.png"></div><br>  <i><font color="#999999">Tampilan UnionFS yang Sederhana</font></i> <br><br>  Sistem file yang dihasilkan disajikan kepada pengguna akhir menggunakan beberapa implementasi UnionFS (Docker <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">mendukung</a> banyak implementasi serupa melalui driver penyimpanan plug-in).  Ukuran total file yang diterima oleh pengguna akhir sama dengan jumlah ukuran file dalam lapisan.  Ketika Docker membuat wadah berdasarkan gambar, ia menggunakan semua lapisan read-only dari gambar, menambahkan satu lapisan tipis di atas lapisan ini yang mendukung membaca dan menulis.  Lapisan inilah yang memungkinkan Anda untuk memodifikasi file dalam wadah yang sedang berjalan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/895/c00/aaf895c00a3353efa96934aeabd85f6f.png"></div><br>  <i><font color="#999999">Wadah yang sedang berjalan berisi lapisan baca-tulis yang terletak di atas lapisan baca-saja</font></i> <br><br>  Apa yang terjadi jika suatu file dihapus pada <code>Layer 4</code> wadah yang disajikan secara skematis di atas?  Meskipun file ini tidak akan tersedia dalam sistem file yang dilihat pengguna, pada kenyataannya, ukuran file ini akan tetap menjadi salah satu komponen dari ukuran kontainer, karena file ini akan tetap berada di salah satu lapisan read-only. <br><br>  Sangat mudah untuk mulai membangun gambar dengan file yang dapat dieksekusi aplikasi kecil dan sampai ke gambar yang sangat besar.  Di bawah ini kita akan melihat berbagai metode untuk membuat wadah sekecil mungkin. <br><br><h2>  <font color="#3AC1EF">Perhatikan jalur ke folder, berdasarkan pada materi yang dikumpulkan gambar</font> </h2><br>  Apa cara paling umum untuk merakit gambar Docker?  Rupanya - seperti ini: <br><br><pre> <code class="plaintext hljs">docker build .</code> </pre> <br>  Poin dalam perintah ini memberi tahu Docker bahwa kami menganggap direktori kerja saat ini sebagai root dari sistem file yang digunakan dalam proses perakitan gambar. <br><br>  Untuk lebih memahami apa yang terjadi setelah perintah di atas dijalankan, perlu diingat bahwa membangun gambar Docker adalah proses client-server.  Antarmuka baris perintah Docker (klien), yang kami berikan <code>docker build</code> , menggunakan mesin Docker (server) untuk membuat gambar wadah.  Untuk membatasi akses ke sistem file dasar klien, sistem perakitan gambar perlu tahu di mana root dari sistem file virtual berada.  Di sanalah instruksi dari file <code>Dockerfile</code> mencari sumber daya file yang akhirnya mungkin berakhir pada gambar yang sedang dirakit. <br><br>  Bayangkan tempat dimana <code>Dockerfile</code> biasanya ditempatkan.  Ini mungkin direktori root proyek?  Jika ada <code>Dockerfile</code> di root proyek, yang digunakan oleh <code>docker build</code> untuk membangun gambar, maka ternyata semua file proyek dapat masuk ke dalam gambar.  Ini dapat mengarah pada fakta bahwa ribuan file sampah yang ukurannya megabita banyak dapat masuk ke dalam konteks perakitan gambar.  Jika Anda dengan ringan menggunakan perintah <code>ADD</code> dan <code>COPY</code> di <code>Dockerfile</code> , maka semua file proyek mungkin menjadi bagian dari gambar yang sudah jadi.  Paling sering, mereka yang mengumpulkan gambar tidak memerlukan ini, karena gambar akhir biasanya hanya menyertakan beberapa file yang dipilih. <br><br>  Selalu pastikan bahwa perintah <code>docker build</code> jalur yang benar, dan bahwa tidak ada perintah di <code>Dockerfile</code> yang menambahkan file yang tidak perlu ke gambar.  Jika karena alasan tertentu Anda perlu membuat root proyek konteks pembangunan, Anda dapat secara selektif memasukkan file di dalamnya dan mengecualikannya dari itu menggunakan <code>.dockerignore</code> . <br><br><h2>  <font color="#3AC1EF">Optimalkan lapisan gambar</font> </h2><br>  Jumlah lapisan maksimum yang dapat dimiliki gambar adalah 127 (diberikan dukungan untuk sejumlah lapisan yang digunakan oleh driver data warehouse).  Keterbatasan ini, jika benar-benar diperlukan, dapat dilonggarkan, tetapi dengan pendekatan ini rentang sistem yang dapat mengumpulkan gambar-gambar tersebut dipersempit.  Intinya adalah bahwa mesin Docker harus berjalan pada sistem yang kernelnya dimodifikasi sesuai. <br><br>  Seperti disebutkan di bagian sebelumnya, karena fakta bahwa UnionFS digunakan ketika merakit gambar, file yang jatuh ke dalam lapisan tertentu tetap ada bahkan jika mereka dihapus dari lapisan atasnya.  Mari kita cari tahu menggunakan Dockerfile eksperimental: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp RUN rm /tmp/10MB.zip</code> </pre> <br>  Mari kita kumpulkan gambar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/d7c/e6d/44bd7ce6d60c71fd0856e96bd48ec5b7.png"></div><br>  <i><font color="#999999">Perakitan gambar eksperimental di mana ada ruang yang digunakan secara tidak rasional</font></i> <br><br>  Jelajahi gambar menggunakan <a href="https://github.com/wagoodman/dive">menyelam</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/e7f/1a5/2dae7f1a5875ece43a52042632a21401.png"></div><br>  <i><font color="#999999">Indikator kinerja gambar adalah 34%</font></i> <br><br>  Indikator efisiensi gambar 34% menunjukkan bahwa sejumlah besar ruang gambar digunakan secara tidak rasional.  Hal ini menyebabkan peningkatan waktu boot gambar, pemborosan sumber daya jaringan yang tidak perlu, ke waktu mulai yang lebih lambat dari wadah. <br><br>  Bagaimana cara mengatasi masalah ini?  Mari kita pertimbangkan beberapa opsi. <br><br><h3>  <font color="#3AC1EF">▍ Menggabungkan hasil kerja tim</font> </h3><br>  Pernahkah Anda melihat <code>Dockerfile</code> berisi arahan <code>RUN</code> sangat panjang di mana banyak perintah shell digabungkan menggunakan <code>&amp;&amp;</code> ?  Ini adalah penggabungan dari hasil tim. <br><br>  Dengan menggunakan metode ini, kami membuat, berdasarkan hasil dari tim panjang tunggal, hanya satu lapisan.  Karena tidak akan ada lapisan dalam gambar yang berisi file yang dihapus di lapisan berikut, gambar akhir tidak akan menyertakan "file hantu" tersebut.  Pertimbangkan ini sebagai contoh, membawa <code>Dockerfile</code> atas ke status ini: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp &amp;&amp; rm /tmp/10MB.zip</code> </pre> <br>  Setelah itu, kami menganalisis gambar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/87f/a16/fbe87fa1633aec55d8fdcbe4d8d1014e.png"></div><br>  <i><font color="#999999">Penggabungan tim memungkinkan Anda membuat gambar yang 100% dioptimalkan</font></i> <br><br>  Aplikasi teknik ini untuk mengoptimalkan ukuran gambar dalam praktek adalah bahwa setelah Anda selesai bekerja pada file <code>Dockerfile</code> , Anda perlu menganalisisnya dan mencari tahu apakah penggabungan perintah dapat digunakan untuk mengurangi jumlah ruang yang terbuang. <br><br><h3>  <font color="#3AC1EF">▍Menerapkan opsi --sashash</font> </h3><br>  Dalam kasus di mana Anda menggunakan <code>Dockerfile</code> orang lain yang tidak Anda inginkan atau tidak dapat diubah, alternatif untuk menggabungkan perintah dapat merakit gambar menggunakan opsi <code>--squash</code> . <br><br>  Versi modern Docker (dimulai dengan 1.13) memungkinkan Anda untuk membawa semua lapisan menjadi satu lapisan, dengan demikian menyingkirkan "sumber daya hantu".  Dalam hal ini, Anda dapat menggunakan <code>Dockerfile</code> asli yang tidak dimodifikasi, yang berisi banyak perintah terpisah.  Tetapi Anda perlu membangun gambar menggunakan opsi <code>--squash</code> : <br><br><pre> <code class="plaintext hljs">docker build --squash .</code> </pre> <br>  Gambar yang dihasilkan juga ternyata dioptimalkan 100%: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/10f/5fc/92310f5fc60ee677d39db75f3d0bac93.png"></div><br>  <i><font color="#999999">Menggunakan opsi --sashash selama perakitan diperbolehkan membuat gambar yang 100% dioptimalkan</font></i> <br><br>  Di sini Anda dapat memperhatikan satu detail menarik.  Yaitu, di <code>Dockerfile</code> lapisan dibuat untuk menambahkan file dan lapisan lain untuk menghapus file ini.  Opsi <code>--squash</code> cukup cerdas untuk memahami bahwa dalam skenario ini Anda tidak perlu membuat layer tambahan sama sekali (pada gambar akhir hanya ada <code>9ccd9…</code> layer <code>9ccd9…</code> dari gambar dasar yang kami gunakan).  Secara umum, untuk ini kita dapat menaruh <code>--squash</code> plus tambahan.  Benar, menggunakan <code>--squash</code> , Anda perlu mempertimbangkan bahwa ini dapat mengganggu penggunaan lapisan cache. <br><br>  Akibatnya, disarankan untuk mempertimbangkan fakta bahwa ketika bekerja dengan <code>Dockerfile</code> orang lain yang tidak ingin Anda ubah, Anda dapat meminimalkan jumlah ruang gambar yang digunakan secara tidak rasional dengan mengumpulkan gambar menggunakan opsi <code>--squash</code> .  Untuk menganalisis gambar yang sudah jadi, Anda bisa menggunakan alat <a href="https://github.com/wagoodman/dive">selam</a> . <br><br><h2>  <font color="#3AC1EF">Hapus cache dan file sementara</font> </h2><br>  Saat menyimpan aplikasi, situasi sering muncul ketika Anda perlu menempatkan alat, pustaka, utilitas tambahan di dalam gambar.  Ini dilakukan dengan menggunakan manajer paket seperti <code>apk</code> , <code>yum</code> , <code>apt</code> . <br><br>  Manajer paket berusaha untuk menghemat waktu pengguna dan tidak memuat koneksi jaringannya sekali lagi ketika menginstal paket.  Karena itu, mereka menyimpan data yang diunduh.  Agar ukuran gambar Docker akhir menjadi sekecil mungkin, kita tidak perlu menyimpan cache pengelola paket di gambar ini.  Lagi pula, jika kita membutuhkan gambar lain, kita selalu dapat membangunnya kembali menggunakan <code>Dockerfile</code> diperbarui. <br><br>  Untuk menghapus cache yang dibuat oleh tiga manajer paket populer yang disebutkan di atas, di akhir perintah gabungan (yaitu, yang menjalankan untuk membuat satu lapisan), Anda bisa menambahkan yang berikut ini: <br><br><pre> <code class="plaintext hljs">APK: ... &amp;&amp; rm -rf /etc/apk/cache YUM: ... &amp;&amp; rm -rf /var/cache/yum APT: ... &amp;&amp; rm -rf /var/cache/apt</code> </pre> <br>  Akibatnya, disarankan agar sebelum menyelesaikan pekerjaan di <code>Dockerfile</code> tambahkan <code>Dockerfile</code> untuk itu yang menghapus cache dari manajer paket yang digunakan untuk membangun gambar.  Hal yang sama berlaku untuk semua file sementara yang tidak memengaruhi pengoperasian wadah dengan benar. <br><br><h2>  <font color="#3AC1EF">Pilih gambar dasar Anda dengan hati-hati</font> </h2><br>  Setiap <code>Dockerfile</code> dimulai dengan arahan <code>FROM</code> .  Di sinilah kita menetapkan gambar dasar atas dasar mana gambar kita akan dibuat. <br><br>  Berikut adalah apa yang dikatakan <a href="https://docs.docker.com/engine/reference/builder/">dokumentasi</a> Docker tentangnya: “Instruksi <code>FROM</code> menginisialisasi fase build baru dan mengatur gambar dasar untuk instruksi yang mengikuti.  Akibatnya, <code>Dockerfile</code> disusun dengan benar harus dimulai dengan pernyataan <code>FROM</code> .  Sebuah gambar bisa berupa gambar apa pun yang bisa diterapkan.  Paling mudah untuk mulai merakit gambar Anda sendiri, dengan mengambil gambar dari repositori publik sebagai dasar. " <br><br>  Jelas, ada banyak gambar dasar, yang masing-masing memiliki fitur dan kemampuan sendiri.  Pemilihan gambar dasar yang benar yang berisi persis apa yang dibutuhkan aplikasi, tidak lebih dan tidak kurang, memiliki dampak besar pada ukuran gambar akhir. <br><br>  Seperti yang Anda duga, ukuran gambar dasar populer sangat bervariasi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/e59/97c/847e5997cf00104e3b212874ee830243.png"></div><br>  <i><font color="#999999">Ukuran gambar buruh pelabuhan dasar populer</font></i> <br><br>  Jadi, kontainerisasi aplikasi menggunakan gambar dasar <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/19.10/images/sha256-bceb2fb47400491f75a9056a3d4e219cbe5f9512d4220ca43f3f5cb3d08e9d04">Ubuntu 19.10</a> akan mengarah pada fakta bahwa ukuran gambar, di samping ukuran aplikasi, akan ditambahkan lagi 73 MB.  Jika kami mengumpulkan gambar yang sama berdasarkan gambar <a href="https://hub.docker.com/layers/alpine/library/alpine/3.10.3/images/sha256-77cbe97593c890eb1c4cadcbca37809ebff2b5f46a036666866c99f08a708967">Alpine 3.10.3</a> , maka kami akan mendapatkan "aditif" hanya dalam jumlah 6 MB.  Sejak Docker melakukan cache lapisan gambar, sumber daya jaringan dihabiskan untuk memuat gambar hanya ketika wadah diluncurkan untuk pertama kalinya dengan cara yang sesuai (dengan kata lain, ketika gambar pertama kali dimuat).  Namun ukuran gambarnya sendiri tidak semakin kecil dari ini. <br><br>  Di sini Anda bisa sampai pada kesimpulan (sepenuhnya logis) berikut: "Jadi - Saya akan selalu menggunakan Alpine!".  Namun, sayangnya, di dunia pengembangan perangkat lunak, tidak semuanya begitu sederhana. <br><br>  Mungkin <a href="https://gitlab.alpinelinux.org/groups/alpine/-/activity">pengembang Alpine Linux</a> menemukan beberapa bahan rahasia yang masih belum ditemukan Ubuntu atau Debian?  Tidak.  Faktanya adalah bahwa untuk membuat gambar Docker, yang ukurannya adalah urutan besarnya lebih kecil dari ukuran gambar Debian yang sama, pengembang Alpine harus membuat beberapa keputusan tentang apa yang perlu dimasukkan dalam gambar dan apa yang tidak diperlukan.  Sebelum memanggil Alpine gambar dasar yang akan selalu Anda gunakan, Anda harus bertanya apakah Alpine memiliki semua yang Anda butuhkan.  Selain itu, meskipun Alpine memiliki manajer paket, mungkin paket spesifik yang digunakan di lingkungan kerja Anda, misalnya, di Ubuntu, tidak tersedia di Alpine.  Atau - bukan paket, tetapi versi paket yang diinginkan.  Ini adalah kompromi yang harus Anda ketahui sebelum memilih dan menguji gambar dasar yang paling cocok untuk proyek Anda. <br><br>  Dan akhirnya, jika Anda benar-benar membutuhkan salah satu gambar dasar terbesar, Anda dapat menggunakan alat ini untuk memperkecil ukuran gambar.  Misalnya - alat open source <a href="https://dockersl.im/">DockerSlim gratis</a> .  Ini akan mengurangi ukuran gambar jadi. <br><br>  Pada akhirnya, kita dapat mengatakan bahwa penggunaan gambar dasar yang dipilih dengan cermat sangat penting dalam menciptakan gambar ringkas Anda sendiri.  Nilai kebutuhan proyek Anda dan pilih gambar yang berisi apa yang Anda butuhkan, dan pada saat yang sama memiliki dimensi yang dapat Anda terima. <br><br><h2>  <font color="#3AC1EF">Pertimbangkan untuk membuat gambar yang tidak memiliki gambar dasar.</font> </h2><br>  Jika aplikasi Anda dapat berjalan tanpa lingkungan tambahan yang disediakan dengan cara dasar, Anda dapat memutuskan untuk tidak menggunakan gambar dasar.  Tentu saja, karena instruksi <code>FROM</code> harus ada di <code>Dockerfile</code> , Anda tidak dapat melakukannya tanpa itu.  Selain itu, ia harus menunjuk pada semacam citra.  Gambar apa yang digunakan dalam situasi seperti itu? <br><br>  Tampilan <a href="https://hub.docker.com/_/scratch">awal</a> mungkin berguna di sini.  Dari deskripsinya, Anda dapat mengetahui bahwa itu dibuat khusus kosong dan dirancang untuk membuat gambar, jika Anda berbicara bahasa <code>Dockerfile</code> , <code>FROM scratch</code> , yaitu dari awal.  Gambar ini sangat berguna saat membuat gambar dasar (seperti gambar debian dan busybox) atau gambar yang sangat minimal (yang berisi file biner tunggal dan apa yang diperlukan untuk operasinya, katakan sesuatu seperti hello-world).  Menggunakan gambar ini sebagai dasar gambar yang dijelaskan oleh <code>Dockerfile</code> mirip dengan menggunakan "operasi kosong" di beberapa program.  Menerapkan gambar <code>scratch</code> tidak akan membuat lapisan tambahan pada gambar selesai. <br><br>  Akibatnya, jika aplikasi Anda adalah executable mandiri yang dapat bekerja sendiri, memilih gambar <code>scratch</code> dasar akan memungkinkan Anda untuk meminimalkan ukuran wadah. <br><br><h2>  <font color="#3AC1EF">Gunakan bangunan multi-tahap</font> </h2><br>  Pembangunan multi-tahap telah menjadi fokus perhatian sejak Docker 05/17.  Itu adalah kesempatan yang telah dinanti sejak lama.  Ini memungkinkan pembuat gambar untuk meninggalkan skrip mereka sendiri untuk membuat gambar dan mengimplementasikan semua yang mereka butuhkan menggunakan format <code>Dockerfile</code> terkenal. <br><br>  Secara umum, majelis multi-tahap dapat dianggap sebagai menggabungkan beberapa <code>Dockerfile</code> , atau sebagai <code>Dockerfile</code> , yang memiliki beberapa instruksi <code>FROM</code> . <br><br>  Sebelum munculnya majelis multi-tahap, jika Anda harus membuat perakitan proyek Anda dan mendistribusikannya dalam wadah menggunakan <code>Dockerfile</code> , maka Anda mungkin perlu melakukan proses perakitan, yang akan mengarah pada penampilan wadah, seperti yang ditunjukkan di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/270/1b9/0602701b97e37b957b0e77663b79faec.png"></div><br>  <i><font color="#999999">Bangun dan distribusikan aplikasi tanpa menggunakan teknologi multi-stage build</font></i> <br><br>  Meskipun, dari sudut pandang teknis, semuanya dilakukan dengan benar, gambar akhir dan wadah yang dihasilkan diisi dengan lapisan yang dibuat dalam proses mempersiapkan bahan proyek.  Dan lapisan-lapisan ini tidak diperlukan untuk membentuk lingkungan runtime proyek. <br><br>  Majelis multistage memungkinkan Anda untuk memisahkan fase pembuatan dan persiapan bahan proyek dari lingkungan di mana kode proyek dijalankan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b30/938/c61/b30938c61707b5fb08866fac84df1c85.png"></div><br>  <i><font color="#999999">Perakitan multi-tahap, pemisahan proses pembuatan dan persiapan bahan proyek dari lingkungan eksekusi</font></i> <br><br>  Pada saat yang sama, satu <code>Dockerfile</code> cukup untuk menggambarkan proses lengkap membangun proyek.  Tetapi sekarang Anda dapat menyalin materi dari satu tahap ke tahap lainnya dan menyingkirkan data yang tidak perlu. <br><br>  Majelis multistage memungkinkan Anda membuat majelis lintas-platform yang dapat digunakan berulang kali tanpa menggunakan skrip perakitan sendiri yang ditulis untuk sistem operasi tertentu.  Ukuran akhir gambar dapat diminimalkan karena kemungkinan inklusi selektif dari bahan yang dihasilkan pada tahap sebelumnya dari proses perakitan gambar. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Membuat gambar wadah Docker adalah proses yang sering harus dihadapi oleh programmer modern.  Ada banyak sumber daya untuk membuat <code>Dockerfile</code> , dan Anda dapat menemukan banyak contoh file seperti itu di Internet.  Tapi apa pun yang Anda gunakan, saat membuat <code>Dockerfile</code> Anda sendiri <code>Dockerfile</code> selalu layak untuk mempertimbangkan ukuran gambar yang dihasilkan. <br><br>  Di sini kami melihat beberapa teknik untuk meminimalkan ukuran gambar Docker.  Perhatian pada isi <code>Dockerfile</code> , termasuk hanya apa yang benar-benar Anda butuhkan, memilih gambar dasar yang tepat, menggunakan teknologi multi-stage build - semua ini dapat membantu secara serius mengurangi ukuran gambar Docker yang Anda buat. <br><br>  <b>PS</b> Kami meluncurkan <a href="https://ruvds.com/ru-rub/marketplace">pasar</a> di situs web RUVDS.  Di pasar, gambar <a href="https://ruvds.com/ru-rub/marketplace/docker">Docker</a> dipasang dalam satu klik, Anda dapat memeriksa bagaimana wadah bekerja pada <a href="https://ruvds.com/">VPS</a> , 3 hari untuk pengujian disediakan gratis untuk semua pelanggan baru. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda mengoptimalkan ukuran gambar Docker Anda? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485650/">https://habr.com/ru/post/id485650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485634/index.html">Dasbor Dungeons and Dragons membantu saya belajar bahasa Inggris</a></li>
<li><a href="../id485636/index.html">Virus yang resistan terhadap CRISPR membangun tempat perlindungan untuk melindungi genom dari enzim penembus DNA</a></li>
<li><a href="../id485640/index.html">Metode penyembunyian halaman web</a></li>
<li><a href="../id485646/index.html">Kiat-kiat Python yang berguna yang belum pernah Anda temui sebelumnya. Bagian 2</a></li>
<li><a href="../id485648/index.html">Pendekatan pythonic untuk for: range () dan enumerate () loop</a></li>
<li><a href="../id485652/index.html">Statistik komentar inline pertemuan</a></li>
<li><a href="../id485654/index.html">Sebuah ide yang diambil dari fisika membantu AI bekerja dalam dimensi yang lebih tinggi.</a></li>
<li><a href="../id485660/index.html">Perusahaan perlindungan DDoS sendiri meluncurkan serangan DDoS, diakui pendirinya</a></li>
<li><a href="../id485664/index.html">Membuat parameter dinamis dalam pekerjaan Jenkins, atau cara membuat tugas Anda lebih mudah digunakan</a></li>
<li><a href="../id485672/index.html">Redis Praktik Terbaik, Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>