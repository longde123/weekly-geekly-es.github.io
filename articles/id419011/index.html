<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèæ üïπÔ∏è üå∫ Jinja2 di dunia C ++, bagian dua. Rendering ü•Ñ üôáüèΩ üâê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua dari cerita tentang porting mesin template Jinja2 ke C ++. Anda dapat membaca yang pertama di sini: Templat urutan ketiga, ata...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jinja2 di dunia C ++, bagian dua. Rendering</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419011/"><p><img src="https://habrastorage.org/getpro/habr/post_images/c81/fe0/548/c81fe0548837b911b9569cdf49d90ca2.jpg" alt="Logo Jinja2" align="left">  Ini adalah bagian kedua dari cerita tentang porting mesin template Jinja2 ke C ++.  Anda dapat membaca yang pertama di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Templat urutan ketiga, atau bagaimana saya mengirim Jinja2 ke C ++</a> .  Ini akan fokus pada proses rendering template.  Atau, dengan kata lain, tentang menulis dari awal, juru bahasa seperti python. </p><a name="habracut"></a><br><h2 id="rendering-kak-takovoy">  Rendering seperti itu </h2><br><p> Setelah parsing, templat berubah menjadi pohon yang berisi simpul dari tiga jenis: <strong>teks biasa</strong> , <strong>ekspresi yang dihitung,</strong> dan <strong>struktur kontrol</strong> .  Dengan demikian, selama proses rendering, teks biasa harus ditempatkan tanpa perubahan apa pun dalam aliran output, ekspresi harus dihitung, dikonversi menjadi teks, yang akan ditempatkan dalam aliran, dan struktur kontrol harus dijalankan.  Pada pandangan pertama, tidak ada yang sulit dalam mengimplementasikan proses rendering: Anda hanya perlu berkeliling semua node pohon, menghitung semuanya, menjalankan semuanya dan menghasilkan teks.  Semuanya sederhana.  Persis selama dua kondisi terpenuhi: a) semua pekerjaan dilakukan dengan string hanya satu jenis (string atau wstring);  b) hanya ekspresi sederhana dan dasar yang digunakan.  Sebenarnya, dengan pembatasan seperti itulah inja dan Jinja2CppLight diimplementasikan.  Dalam kasus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jinja2Cpp</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> kedua kondisi tidak berfungsi.  Pertama, saya awalnya memberikan dukungan transparan untuk kedua jenis string.  Kedua, seluruh pengembangan dimulai hanya untuk mendukung spesifikasi Jinja2 hampir secara penuh, dan ini, pada dasarnya, adalah bahasa scripting yang lengkap.  Karena itu, saya harus menggali lebih dalam dengan rendering daripada dengan parsing. </p><br><h3 id="vychislenie-vyrazheniy">  Evaluasi Ekspresi </h3><br><p><img src="https://habrastorage.org/webt/46/i0/0y/46i00yfhkcaiybpae4famsictho.png" align="right">  Templat tidak akan menjadi templat jika tidak bisa diparameterisasi.  Pada prinsipnya, Jinja2 memungkinkan opsi templat "dengan sendirinya" - semua variabel yang diperlukan dapat diatur di dalam templat itu sendiri, dan kemudian merendernya.  Tetapi bekerja dalam templat dengan parameter yang diperoleh "di luar" tetap merupakan kasus utama.  Dengan demikian, hasil evaluasi ekspresi tergantung pada variabel (parameter) mana yang nilainya terlihat pada titik perhitungan.  Dan hasilnya adalah bahwa di Jinja2 tidak hanya ruang lingkup (yang dapat disarangkan), tetapi juga dengan aturan rumit "transparansi".  Sebagai contoh, ini adalah templat: </p><br><pre><code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">set</span></span></span><span class="hljs-template-tag"> param1=10 %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  Sebagai hasil rendernya, teks <code>10</code> akan diterima <br>  Opsi ini sedikit lebih rumit: </p><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">set</span></span></span><span class="hljs-template-tag"> param1=10 %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">for</span></span></span></span></span><span class="hljs-template-tag"> param1 </span><span class="hljs-keyword"><span class="hljs-template-tag"><span class="hljs-keyword">in</span></span></span><span class="hljs-template-tag"> range(10) %}</span></span><span class="xml"><span class="xml">-</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"><span class="xml">-</span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">endfor</span></span></span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  Memberikan sedini <code>10-0--1--2--3--4--5--6--7--8--9-10</code> <br>  Siklus menghasilkan lingkup baru di mana Anda dapat menentukan parameter variabel Anda sendiri, dan parameter ini tidak akan terlihat di luar lingkup, sama seperti mereka tidak akan menggiling nilai-nilai parameter yang sama di eksternal.  Bahkan lebih rumit dengan ekstensi / blok konstruksi, tetapi lebih baik untuk membaca tentang ini di dokumentasi Jinja2. </p><br><p>  Dengan demikian, konteks perhitungan muncul.  Atau lebih tepatnya, rendering secara umum: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RenderContext</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: RenderContext(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InternalValueMap&amp; extValues, IRendererCallback* rendererCallback); <span class="hljs-function"><span class="hljs-function">InternalValueMap&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExitScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; found)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = m_scopes.rbegin(); p != m_scopes.rend(); ++ p) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> valP = p-&gt;find(val); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valP != p-&gt;end()) { found = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valP; } } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> valP = m_externalScope-&gt;find(val); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valP != m_externalScope-&gt;end()) { found = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valP; } found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_externalScope-&gt;end(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrentScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrentScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetGlobalScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRendererCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">RenderContext </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> includeCurrentContext)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: InternalValueMap* m_currentScope; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InternalValueMap* m_externalScope; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;InternalValueMap&gt; m_scopes; IRendererCallback* m_rendererCallback; };</code> </pre> <br><p>  <a href="">Dari sini</a> </p><br><p>  Konteksnya berisi pointer ke kumpulan nilai yang diperoleh ketika fungsi rendering dipanggil, daftar (tumpukan) lingkup, lingkup aktif saat ini, dan pointer ke antarmuka panggilan balik, dengan berbagai fungsi yang berguna untuk rendering.  Tetapi tentang dia sedikit kemudian.  Fungsi pencarian parameter secara berurutan naik daftar konteks ke yang eksternal sampai menemukan parameter yang diperlukan. </p><br><p>  Sekarang sedikit tentang parameternya sendiri.  Dari sudut pandang antarmuka eksternal (dan penggunanya), Jinja2 mendukung daftar tipe yang valid berikut ini: </p><br><ul><li>  Bilangan (int, dobel) </li><li>  String (sempit, lebar) </li><li>  bool </li><li>  Array (lebih seperti tuple tanpa dimensi) </li><li>  Kamus </li><li>  Struktur C ++ yang Tercermin </li></ul><br><p>  Semua ini dijelaskan oleh tipe data khusus yang dibuat berdasarkan boost :: varian: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueData = boost::variant&lt;EmptyValue, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wstring, <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, boost::recursive_wrapper&lt;ValuesList&gt;, boost::recursive_wrapper&lt;ValuesMap&gt;, GenericList, GenericMap&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Value() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; Value(T&amp;&amp; val, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;, Value&gt;::value&gt;::type* = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) : m_data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;T&gt;(val)) { } Value(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* val) : m_data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(val)) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; Value(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp;val)[N]) : m_data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(val)) { } Value(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_data(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt;(val)) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> ValueData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data;} <span class="hljs-function"><span class="hljs-function">ValueData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ValueData m_data; };</code> </pre> <br><p>  <a href="">Dari sini</a> </p><br><p>  Tentu saja, elemen array dan kamus dapat berupa tipe yang terdaftar.  Tetapi masalahnya adalah untuk penggunaan internal, rangkaian tipe ini terlalu sempit.  Untuk menyederhanakan implementasi, diperlukan dukungan untuk jenis tambahan berikut: </p><br><ul><li>  String dalam format target.  Itu bisa sempit atau lebar tergantung pada jenis template apa yang diberikan. </li><li>  jenis yang bisa dipanggil </li><li>  Perakitan pohon AST </li><li>  Pasangan nilai kunci </li></ul><br><p>  Melalui perluasan ini, menjadi mungkin untuk mentransfer data layanan melalui konteks render, yang sebaliknya harus "disinari" di header publik, serta lebih berhasil menggeneralisasi beberapa algoritma yang bekerja dengan array dan kamus. </p><br><p>  Boost :: varian tidak dipilih secara kebetulan.  Kemampuannya yang kaya digunakan untuk bekerja dengan parameter tipe tertentu.  Jinja2CppLight menggunakan kelas polimorfik untuk tujuan yang sama, sementara inja menggunakan sistem tipe perpustakaan nlohmann json.  Kedua alternatif ini, sayangnya, tidak cocok untuk saya.  Alasan: kemungkinan pengiriman n-ary untuk boost :: varian (dan sekarang - std :: varian).  Untuk jenis varian, Anda dapat membuat pengunjung statis yang menerima dua jenis tersimpan tertentu dan mengaturnya terhadap sepasang nilai.  Dan semuanya akan bekerja sebagaimana mestinya!  Dalam kasus kelas polimorfik atau serikat sederhana, kemudahan ini tidak akan berfungsi: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringJoiner</span></span></span><span class="hljs-class"> :</span></span> BaseVisitor&lt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BaseVisitor::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> (); <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EmptyValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; str)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; right)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left + right; } };</code> </pre> <br><p>  <a href="">Dari sini</a> </p><br><p>  Pengunjung seperti itu disebut sangat sederhana: </p><br><pre> <code class="hljs php">InternalValue delimiter = m_args[<span class="hljs-string"><span class="hljs-string">"d"</span></span>]-&gt;Evaluate(context); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InternalValue&amp; val : values) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFirst) isFirst = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = Apply2&lt;visitors::StringJoiner&gt;(result, delimiter); result = Apply2&lt;visitors::StringJoiner&gt;(result, val); }</code> </pre> <br><p>  <code>Apply2</code> sini adalah wrapper over <code>boost::apply_visitor</code> , yang menerapkan pengunjung tipe yang ditentukan oleh parameter template ke sepasang nilai varian, yang sebelumnya membuat beberapa konversi jika perlu.  Jika perancang pengunjung membutuhkan parameter, mereka akan diteruskan setelah objek yang pengunjung terapkan: </p><br><pre> <code class="hljs vbscript">comparator = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> KeyValuePair&amp; <span class="hljs-built_in"><span class="hljs-built_in">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> KeyValuePair&amp; <span class="hljs-built_in"><span class="hljs-built_in">right</span></span>) { return ConvertToBool(Apply2&lt;visitors::BinaryMathOperation&gt;(<span class="hljs-built_in"><span class="hljs-built_in">left</span></span>.value, <span class="hljs-built_in"><span class="hljs-built_in">right</span></span>.value, BinaryExpression::LogicalLt, BinaryExpression::CaseSensitive)); };</code> </pre> <br><p><img src="https://habrastorage.org/webt/ql/6e/qd/ql6eqdbjul3yrvjblr0nwjgqet8.png" align="left" width="60%" height="60%">  Dengan demikian, logika operasi dengan parameter keluar sebagai berikut: varian (s) -&gt; membongkar menggunakan pengunjung -&gt; melakukan tindakan yang diinginkan pada nilai spesifik jenis tertentu -&gt; mengemas hasilnya kembali ke varian.  Dan penyamaran sihir minimal.  Mungkin saja untuk mengimplementasikan semuanya seperti pada js: melakukan operasi (misalnya, penambahan) dalam hal apa pun, memilih sistem tertentu untuk mengubah string menjadi angka, angka menjadi string, string ke daftar, dll. Dan mendapatkan hasil yang aneh dan tidak terduga.  Saya memilih cara yang lebih sederhana dan lebih dapat diprediksi: jika operasi pada nilai (atau sepasang nilai) tidak mungkin atau tidak logis, maka hasil kosong dikembalikan.  Oleh karena itu, ketika menambahkan angka ke string, Anda bisa mendapatkan string sebagai hasilnya hanya jika operasi penggabungan ('~') digunakan.  Jika tidak, hasilnya akan menjadi nilai kosong.  Prioritas operasi ditentukan oleh tata bahasa, oleh karena itu, tidak ada pemeriksaan tambahan yang diperlukan selama pemrosesan AST. </p><br><h3 id="filtry-i-testy">  Filter dan Tes </h3><br><p><img src="https://habrastorage.org/webt/iy/zr/pp/iyzrppwjtrqdunkvflnjf1bv5ak.png" align="right" width="50%" height="50%">  Apa bahasa lain memanggil "perpustakaan standar" di Jinja2 disebut "filter."  Intinya, filter adalah semacam operasi kompleks pada nilai di sebelah kiri tanda '|', yang hasilnya akan menjadi nilai baru.  Filter dapat diatur dalam rantai dengan mengatur saluran pipa: <br> <code>{{ menuItems | selectattr('visible') | map(attribute='title') | map('upper') | join(' -&gt; ') }}</code> <br>  Di sini, hanya elemen-elemen dengan atribut terlihat diatur ke true akan dipilih dari array menuItems, maka atribut judul akan diambil dari elemen-elemen ini, dikonversi ke huruf besar, dan daftar garis yang dihasilkan akan direkatkan dengan pemisah '-&gt;' menjadi satu baris.  Atau, katakanlah, sebagai contoh dari kehidupan: </p><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">macro</span></span></span><span class="hljs-template-tag"> MethodsDecl(class, access) %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">for</span></span></span></span></span><span class="hljs-template-tag"> method </span><span class="hljs-keyword"><span class="hljs-template-tag"><span class="hljs-keyword">in</span></span></span><span class="hljs-template-tag"> class.methods | rejectattr('isImplicit') | selectattr('accessType', '</span><span class="hljs-keyword"><span class="hljs-template-tag"><span class="hljs-keyword">in</span></span></span><span class="hljs-template-tag">', access) %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ method.fullPrototype }}</span></span><span class="xml"><span class="xml">; </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">endfor</span></span></span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">endmacro</span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  <a href="">Dari sini</a> </p><br><div class="spoiler">  <b class="spoiler_title">Opsi alternatif</b> <div class="spoiler_text"><pre> <code class="hljs mel">{% macro MethodsDecl(class, access) %} {{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> method <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> class.methods | rejectattr(<span class="hljs-string"><span class="hljs-string">'isImplicit'</span></span>) | selectattr(<span class="hljs-string"><span class="hljs-string">'accessType'</span></span>, <span class="hljs-string"><span class="hljs-string">'in'</span></span>, access) | map(attribute=<span class="hljs-string"><span class="hljs-string">'fullPrototype'</span></span>) | join(<span class="hljs-string"><span class="hljs-string">';\n'</span></span>) }}; {% endmacro %}</code> </pre> </div></div><br><p>  Makro ini mengulangi semua metode dari kelas yang diberikan, membuang yang atribut isImplicit disetel ke true, memilih yang tersisa yang nilai atribut accessType cocok dengan salah satu yang diberikan, dan menampilkan prototipe mereka.  Cukup jelas.  Dan semuanya lebih mudah daripada siklus tiga lantai dan jika perlu dipagari.  By the way, sesuatu yang mirip di C ++ dapat dilakukan dalam spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kisaran v.3</a> . </p><br><p>  Sebenarnya, kesalahan utama dalam waktu dikaitkan dengan penerapan sekitar empat puluh filter, yang saya sertakan dalam set dasar.  Untuk beberapa alasan saya mengambil bahwa saya bisa menanganinya dalam satu atau dua minggu.  Itu terlalu optimis.  Dan walaupun implementasi tipikal dari filter ini cukup sederhana: ambil nilai dan terapkan beberapa functor padanya, ada terlalu banyak, dan saya harus mengotak-atik. <br>  Tugas menarik yang terpisah dalam proses implementasi adalah logika pemrosesan argumen.  Dalam Jinja2, seperti dalam python, argumen yang diteruskan ke panggilan dapat berupa nama atau posisi.  Dan parameter dalam deklarasi filter dapat berupa wajib atau opsional (dengan nilai default).  Selain itu, tidak seperti C ++, parameter opsional dapat ditemukan di mana saja di iklan.  Itu perlu untuk menghasilkan suatu algoritma untuk menggabungkan kedua daftar ini, dengan mempertimbangkan kasus-kasus yang berbeda.  Di sini, katakanlah, ada fungsi <code>range([start, ]stop[, step])</code> : <code>range([start, ]stop[, step])</code> .  Ini dapat dipanggil dengan cara berikut: </p><br><pre> <code class="hljs lisp">range(<span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">1</span></span>) range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">1</span></span>) range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">3</span></span>) range(<span class="hljs-name"><span class="hljs-name">step=2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">2</span></span>) range(<span class="hljs-number"><span class="hljs-number">2</span></span>, step=2, <span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Dan sebagainya.  Dan saya sangat ingin itu dalam kode untuk menerapkan fungsi filter itu tidak perlu untuk mempertimbangkan semua kasus ini.  Akibatnya, ia menentukan fakta bahwa dalam kode filter, tester, atau kode fungsi, parameter diperoleh secara ketat berdasarkan nama.  Dan fungsi terpisah membandingkan daftar argumen aktual dengan daftar parameter yang diharapkan di sepanjang jalan dengan memeriksa bahwa semua parameter yang diperlukan diberikan dengan satu atau lain cara: </p><br><div class="spoiler">  <b class="spoiler_title">Sepotong besar kode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ParsedArguments </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseCallParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">initializer_list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ArgumentInfo&gt;&amp; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CallParams&amp; params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; isSucceeded)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgInfo</span></span></span><span class="hljs-class"> {</span></span> ArgState state = NotFound; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevNotFound = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextNotFound = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ArgumentInfo* info = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }; boost::container::small_vector&lt;ArgInfo, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; argsInfo(args.size()); boost::container::small_vector&lt;ParamState, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; posParamsInfo(params.posParams.size()); isSucceeded = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ParsedArguments result; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstMandatoryIdx = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevNotFound = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundKwArgs = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Find all provided keyword args for (auto&amp; argInfo : args) { argsInfo[argIdx].info = &amp;argInfo; auto p = params.kwParams.find(argInfo.name); if (p != params.kwParams.end()) { result.args[argInfo.name] = p-&gt;second; argsInfo[argIdx].state = Keyword; ++ foundKwArgs; } else { if (argInfo.mandatory) { argsInfo[argIdx].state = NotFoundMandatory; if (firstMandatoryIdx == -1) firstMandatoryIdx = argIdx; } else { argsInfo[argIdx].state = NotFound; } if (prevNotFound != -1) argsInfo[prevNotFound].nextNotFound = argIdx; argsInfo[argIdx].prevNotFound = prevNotFound; prevNotFound = argIdx; } ++ argIdx; } int startPosArg = firstMandatoryIdx == -1 ? 0 : firstMandatoryIdx; int curPosArg = startPosArg; int eatenPosArgs = 0; // Determine the range for positional arguments scanning bool isFirstTime = true; for (; eatenPosArgs &lt; posParamsInfo.size(); ++ eatenPosArgs) { if (isFirstTime) { for (; startPosArg &lt; args.size() &amp;&amp; (argsInfo[startPosArg].state == Keyword || argsInfo[startPosArg].state == Positional); ++ startPosArg) ; isFirstTime = false; continue; } int prevNotFound = argsInfo[startPosArg].prevNotFound; if (prevNotFound != -1) { startPosArg = prevNotFound; } else if (curPosArg == args.size()) { break; } else { int nextPosArg = argsInfo[curPosArg].nextNotFound; if (nextPosArg == -1) break; curPosArg = nextPosArg; } } // Map positional params to the desired arguments int curArg = startPosArg; for (int idx = 0; idx &lt; eatenPosArgs &amp;&amp; curArg != -1; ++ idx, curArg = argsInfo[curArg].nextNotFound) { result.args[argsInfo[curArg].info-&gt;name] = params.posParams[idx]; argsInfo[curArg].state = Positional; } // Fill default arguments (if missing) and check for mandatory for (int idx = 0; idx &lt; argsInfo.size(); ++ idx) { auto&amp; argInfo = argsInfo[idx]; switch (argInfo.state) { case Positional: case Keyword: continue; case NotFound: { if (!IsEmpty(argInfo.info-&gt;defaultVal)) result.args[argInfo.info-&gt;name] = std::make_shared&lt;ConstantExpression&gt;(argInfo.info-&gt;defaultVal); break; } case NotFoundMandatory: isSucceeded = false; break; } } // Fill the extra positional and kw-args for (auto&amp; kw : params.kwParams) { if (result.args.find(kw.first) != result.args.end()) continue; result.extraKwArgs[kw.first] = kw.second; } for (auto idx = eatenPosArgs; idx &lt; params.posParams.size(); ++ idx) result.extraPosArgs.push_back(params.posParams[idx]); return result; }</span></span></code> </pre> <br><p>  <a href="">Dari sini</a> </p></div></div><br><p>  Ini disebut cara ini (untuk, katakanlah, <code>range</code> ): </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isArgsParsed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> args = helpers::ParseCallParams({{<span class="hljs-string"><span class="hljs-string">"start"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"stop"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"step"</span></span>}}, m_params, isArgsParsed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isArgsParsed) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InternalValue();</code> </pre> <br><p>  dan mengembalikan struktur berikut: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParsedArguments</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, ExpressionEvaluatorPtr&lt;&gt;&gt; args; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, ExpressionEvaluatorPtr&lt;&gt;&gt; extraKwArgs; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; extraPosArgs; ExpressionEvaluatorPtr&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = args.find(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == args.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p-&gt;second; } };</code> </pre> <br><p>  argumen yang diperlukan dari mana ia diambil hanya dengan namanya: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> startExpr = args[<span class="hljs-string"><span class="hljs-string">"start"</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> stopExpr = args[<span class="hljs-string"><span class="hljs-string">"stop"</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> stepExpr = args[<span class="hljs-string"><span class="hljs-string">"step"</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">InternalValue</span></span> startVal = startExpr ? startExpr-&gt;Evaluate(values) : InternalValue(); <span class="hljs-attribute"><span class="hljs-attribute">InternalValue</span></span> stopVal = stopExpr ? stopExpr-&gt;Evaluate(values) : InternalValue(); <span class="hljs-attribute"><span class="hljs-attribute">InternalValue</span></span> stepVal = stepExpr ? stepExpr-&gt;Evaluate(values) : InternalValue();</code> </pre> <br><p>  Mekanisme serupa digunakan ketika bekerja dengan makro dan penguji.  Dan meskipun tampaknya tidak ada yang rumit dalam menggambarkan argumen dari setiap filter dan pengujian, tidak ada (bagaimana mengimplementasikannya), tetapi bahkan set "dasar", yang mencakup sekitar lima puluh dari mereka dan yang lainnya, ternyata cukup produktif untuk implementasi.  Dan ini asalkan itu tidak termasuk segala macam hal yang rumit, seperti memformat string untuk HTML (atau C ++), menghasilkan nilai dalam format seperti xml atau json, dan sejenisnya. </p><br><p>  Pada bagian selanjutnya, kita akan fokus pada implementasi pekerjaan dengan beberapa templat (ekspor, termasuk, makro), serta pada petualangan yang mempesona dengan implementasi penanganan kesalahan dan bekerja dengan string dengan lebar yang berbeda. </p><br><p>  Secara tradisional, tautan: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi Jinja2</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi Jinja2Cpp</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419011/">https://habr.com/ru/post/id419011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419001/index.html">5 "keterampilan super" diperlukan untuk pekerjaan di masa depan</a></li>
<li><a href="../id419003/index.html">Intisari Blockchain</a></li>
<li><a href="../id419005/index.html">Wisata ke gardu 220/110/20</a></li>
<li><a href="../id419007/index.html">Tekstur untuk intro 64k: bagaimana hal itu dilakukan hari ini</a></li>
<li><a href="../id419009/index.html">dentang dan IDE: sebuah cerita tentang persahabatan dan persahabatan</a></li>
<li><a href="../id419013/index.html">Atribusi berbasis corong untuk bisnis SaaS B2B - karena kami mempertimbangkan nilai semua upaya pemasaran</a></li>
<li><a href="../id419017/index.html">Apa yang Baru di ConstraintLayout 1.1</a></li>
<li><a href="../id419019/index.html">AlterEgo: perangkat yang dapat membaca (beberapa) pikiran</a></li>
<li><a href="../id419021/index.html">Jenis-jenis utama pencetakan dan fitur-fiturnya</a></li>
<li><a href="../id419023/index.html">Bagaimana Kami Meningkatkan Nginx dan Menyelamatkan Dunia, 54 Tahun Menunggu Setiap Hari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>