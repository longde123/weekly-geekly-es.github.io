<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏾 🎲 🕖 Spring中的客户端请求同步 🎡 🍌 🕠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我建议您分析一个有关为我的移动应用程序MT_FREE开发后端时在MaximTelecom中遇到的客户请求竞争的实际任务。 

 启动时，客户端应用程序将请求的“数据包”异步发送到API。 该应用程序具有clientId标识符，基于该标识符可以区分来自一个客户端的请求与另一个客户端的请求。 对于...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring中的客户端请求同步</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/maximatelecom/blog/434714/"> 今天，我建议您分析一个有关为我的移动应用程序MT_FREE开发后端时在MaximTelecom中遇到的客户请求竞争的实际任务。 <br><br> 启动时，客户端应用程序将请求的“数据包”异步发送到API。 该应用程序具有clientId标识符，基于该标识符可以区分来自一个客户端的请求与另一个客户端的请求。 对于服务器上的每个请求，将执行以下形式的代码： <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      Client client = clientRepository.findByClientId(clientId); //      if(client == null){ client = clientRepository.save(new Client(clientId)); } //   </span></span></code> </pre> <br> 其中，客户实体具有一个clientId字段，该字段必须是唯一的，并且为此在数据库中具有唯一的约束。 由于在Spring中，每个请求都将在单独的线程中执行此代码，即使这些请求是来自同一客户端应用程序的请求，也会出现以下形式的错误： <br><blockquote> 完整性约束违规：唯一约束或索引违规；  UK_BFJDOY2DPUSSYLQ7G1S3S1TN8表：客户端 </blockquote><br> 发生错误的原因很明显：2个或更多具有相同clientId的线程接收到client == null实体并开始创建它，然后在提交时收到错误。 <br><br><h3> 挑战： </h3><br> 必须同步来自一个clientId的请求，以便只有第一个请求才能完成Client实体的创建，其余请求将在创建时被阻止并接收已经创建的对象。 <br><a name="habracut"></a><br><h3> 解决方案1 </h3><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   synchronized (this){ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } }</span></span></code> </pre><br> 由于需要创建的所有请求（线程）都会被阻止，即使它们使用不同的clientId创建Client并且彼此不竞争，该解决方案仍然有效，但代价非常高。 <br><br> 请注意，同步与@Transactional批注的组合 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> Client </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String clientId)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      Client client = clientRepository.findByClientId(clientId); //      if(client == null){ client = clientRepository.save(new Client(clientId)); } return client; }</span></span></code> </pre><br> 同样的错误将再次发生。 原因是监视器（已同步）首先被释放，下一个线程进入同步区域，并且只有在此之后，事务才由代理对象中的第一个线程提交。 解决此问题的方法很简单-您需要在提交后释放监视器，因此必须在上面调用synced： <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>){ client = clientService.getOrCreateUser(clientId); }</code> </pre><br><h3> 决定2 </h3><br> 我真的很想使用表单的设计： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (clientId)</code> </pre> <br> 但是问题是，即使它们的值相等，也会为每个请求创建一个新的clientId对象，因此，无法以这种方式执行同步。 为了解决使用不同clientId对象的问题，您需要使用池： <br><br><pre> <code class="java hljs">Client client = clientRepository.findByClientId(clientId); <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   synchronized (clientId.intern()){ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } }</span></span></code> </pre><br> 此解决方案使用java字符串池，分别具有等效clientId的请求，通过调用clientId.intern（），将接收相同的对象。 不幸的是，在实践中，此解决方案不适用，因为不可能管理“腐烂”的clientId，迟早会导致OutOfMemory。 <br><br><h3> 决定3 </h3><br> 为了使用ReentrantLock，您需要以下形式的池： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ConcurrentMap&lt;String, ReentrantLock&gt; locks;</code> </pre> <br> 然后： <br><br><pre> <code class="java hljs">Client client = clientRepository.findByClientId(clientId); <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   ReentrantLock lock = locks.computeIfAbsent(clientId, (k) -&gt; new ReentrantLock()); lock.lock(); try{ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } finally { //   lock.unlock(); } }</span></span></code> </pre><br> 唯一的问题是“过时的” clientId的管理，可以使用ConcurrentMap的非标准实现来解决，该实现已经支持expire，例如，使用guava Cache： <br><br><pre> <code class="java hljs">locks = CacheBuilder.newBuilder() .concurrencyLevel(<span class="hljs-number"><span class="hljs-number">4</span></span>) .expireAfterWrite(Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .&lt;String, ReentrantLock&gt;build().asMap();</code> </pre><br><h3> 决定4 </h3><br> 上述解决方案在单个实例内同步请求。 如果您的服务在N个节点上旋转，并且请求可以同时转到不同的位置，该怎么办？ 对于这种情况，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redisson</a>库是一种完美的解决方案： <br><br><pre> <code class="java hljs"> Client client = clientRepository.findByClientId(clientId); <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   RLock lock = redissonClient.getFairLock(clientId); lock.lock(); try{ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } finally { //   lock.unlock(); } }</span></span></code> </pre><br> 该库使用redis作为存储库解决了分布式锁问题。 <br><br><h2> 结论 </h2><br> 应采用哪种决定当然取决于问题的规模：解决方案1-3非常适合小型单实例服务，解决方案4针对分布式服务。 值得一提的是，使用Redisson或类似物（例如经典的Zookeeper）解决此问题当然是一种特殊情况，因为它们是为分布式系统的更多任务而设计的。 <br><br> 在我们的案例中，我们选择了解决方案4，因为我们的服务是分布式的，与类似物相比，Redisson集成最容易。 <br><br> 朋友们，请在评论中建议您解决该问题的选择，我将非常高兴！ <br> 示例的源代码在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可用</a> 。 <br><br> 顺便说一下，我们正在不断扩充开发人员，有关职位空缺可以在我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">职业页面</a>上找到。 <br><br><h3>  UPD 1.读者的解决方案1 </h3><br> 此解决方案建议不要同步请求，但是如果出现以下形式的错误： <br><blockquote> 完整性约束违规：唯一约束或索引违规；  UK_BFJDOY2DPUSSYLQ7G1S3S1TN8表：客户端 </blockquote><br> 必须处理并召回 <br><pre> <code class="java hljs">client = clientRepository.findByClientId(clientId);</code> </pre><br> 或通过spring-retry来完成： <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retryable</span></span>(value = { SQLException.class }, maxAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span>, backoff = <span class="hljs-meta"><span class="hljs-meta">@Backoff</span></span>(delay = <span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Client </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String clientId)</span></span></span></span></code> </pre><br>  （以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Throwable</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为例</a> ） <br> 在这种情况下，将对数据库进行“额外”查询，但是实际上，客户端实体的创建通常不会发生，并且如果仅需要同步来解决插入数据库的问题，则可以省去此解决方案。 <br><br><h3>  UPD 2.读者的解决方案2 </h3><br> 该解决方案建议通过会话进行同步： <br><pre> <code class="java hljs">HttpSession session = request.getSession(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (session != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Object mutex = WebUtils.getSessionMutex(session); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (mutex) { ... } }</code> </pre><br> 该解决方案适用于单实例服务，但是必须解决该问题，以便从一个客户端到API的所有请求都在同一会话中执行。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434714/">https://habr.com/ru/post/zh-CN434714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434704/index.html">俄罗斯移动流量成本下降的原因以及对2019年的预测</a></li>
<li><a href="../zh-CN434706/index.html">UDB。 这是什么 第3部分。数据路径FIFO</a></li>
<li><a href="../zh-CN434708/index.html">HL2018。报告摘要“再次设置密码！ 如何击败暴力，让黑客一无所获”</a></li>
<li><a href="../zh-CN434710/index.html">RUVDS关于Habr的博客：三年</a></li>
<li><a href="../zh-CN434712/index.html">俄语第三次图灵测试</a></li>
<li><a href="../zh-CN434716/index.html">移至数据中心：准备</a></li>
<li><a href="../zh-CN434718/index.html">两年后，我仍然想念耳机插孔</a></li>
<li><a href="../zh-CN434720/index.html">零知识的反面：zk-SNARK中的后门无法检测</a></li>
<li><a href="../zh-CN434722/index.html">疼痛，吃药和两辆救护车，或者我们如何在索契攀升到第五名IronStar 226</a></li>
<li><a href="../zh-CN434724/index.html">中国农民直播</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>