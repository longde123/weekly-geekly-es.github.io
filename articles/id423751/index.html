<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜– ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ‘â€ğŸ—¨ Java untuk Playstation 2 - apakah mungkin? ğŸ½ ğŸ‹ ğŸ‘³ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Dengan proyek ini saya ingin menjawab satu pertanyaan: apakah mungkin untuk menulis Java API untuk Playstation 2 dan membuat demo grafis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java untuk Playstation 2 - apakah mungkin?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423751/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a7/fd3/7b6/7a7fd37b645e7bd2c38240c53a9ab6a5.jpg" alt="gambar"></div><br><h2>  Pendahuluan </h2><br>  Dengan proyek ini saya ingin menjawab satu pertanyaan: apakah mungkin untuk menulis Java API untuk Playstation 2 dan membuat demo grafis di atasnya.  Saya tidak ingin mengungkapkan spoiler, tetapi jawabannya adalah ya. <br><br>  Beberapa tahun yang lalu, saya memulai proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Grinder</a> yang menerima file Java .class yang dikompilasi dan benar-benar berfungsi sebagai disassembler.  Tetapi alih-alih membongkar menjadi kode assembler Java, itu membongkar menjadi kode sumber assembler untuk prosesor nyata.  Jika file kelas membutuhkan file kelas lain, maka mereka juga dibaca dan diproses.  Semua panggilan metode API ditulis ke output, baik sebagai kode assembler bawaan, atau sebagai panggilan ke fungsi pra-tertulis yang melakukan tugas yang dimaksud. <br><a name="habracut"></a><br>  Karena <a href="">Java Grinder</a> ditulis dalam bahasa C ++, berorientasi objek, abstrak, polimorfik, dan banyak lagi profil HR favorit lainnya, untuk mengembangkannya, terutama diperlukan untuk membuat kelas Playstation2, memperluas kelas R5900 baru, memperluas kelas Generator utama. <br><br>  Hasilnya, proyek itu ternyata lebih besar dari yang saya harapkan.  Sistemnya sendiri cukup sederhana, tetapi saya masih harus banyak belajar, dan menemukan informasi yang berkualitas tidak begitu sederhana.  Bahkan, untuk pertama kalinya dalam proyek ini, saya mengambil pemrograman 3D nyata.  Di posting lain, saya sudah berbicara tentang apa yang saya pelajari di halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman Playstation 2</a> saya. <br><br>  Di bawah ini adalah video dan penjelasan rinci tentang proses pengembangan. <br><br><h2>  Video </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AjM069oKUGs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Saya merekam demo pada PS2 slim dengan menghubungkan kabel audio dan video ke DVD burner.  Saya agak khawatir bahwa PS2 memiliki semacam perlindungan Macrovision yang akan merusak sinyal video, tetapi entah dimatikan atau perekam DVD mengabaikannya.  Video dimulai dengan demonstrasi Playstation 2 nyata, yang menjalankan demo.  Konsol terhubung ke konverter sinyal ke VGA, terhubung ke layar LCD, membuktikan bahwa demo berjalan pada mesin nyata.  Kemudian saya menambahkan perekatan dengan video nyata yang direkam langsung dari PS2 dalam perekam DVD. <br><br>  YouTube: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtu.be/AjM069oKUGs</a> <br><br><h2>  Proyek serupa di mikekohn.net </h2><br><table><tbody><tr><td>  Java Grinder: </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Playstation 2 Java</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sega Genesis Java</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apple IIgs Java</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TI99 / 4A Java</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C64 Java</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dsPIC Mandelbrots</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Atari 2600 Jawa</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chipKIT Java</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Grinder</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">naken_asm</a> </td></tr></tbody></table><br><h2>  Demo </h2><br>  Mengingat demo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sega Genesis Java</a> , saya sedikit menyesal bahwa saya tidak membuatnya lebih menarik.  Maka lebih menarik bagi saya untuk menunjukkan kemampuan Java API.  Ketika saya memulai proyek ini, saya memutuskan untuk melakukan sesuatu yang lebih serius.  Sayangnya, saya sekali lagi sangat lelah dalam proses mempelajari sistem dan membuat API sehingga saya tidak memiliki kekuatan yang cukup untuk demo besar. <br><br><ul><li>  3 Billion Devices Logo: Ini adalah 3 miliar perangkat beresolusi rendah yang menjalankan logo Java yang dibuat oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Joe Davisson</a> untuk demo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Commodore 64 Java-nya</a> . </li><li>  Logo: Saya menggambar mereka dengan spidol dan memindai mereka (dengan pengecualian logo Java). </li><li>  Bintang: Saya benar-benar menyalin kode dari demo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sega Genesis Java</a> dan memodifikasinya agar berfungsi dengan Playstation 2 API.  Teks di sini juga ditulis dengan spidol dan dipindai. </li><li>  Mandelbrot fractals: mereka ditunjukkan menggunakan unit vektor 0, yang menghitung fraktal, dan unit vektor 1 melakukan perhitungan 3D.  MIPS mengontrol apa yang dilakukan kedua perangkat vektor. </li><li>  Kubus: Saya menggambar kubus ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wings3d</a> dan menulis kode C untuk mengkonversi file STL ke array yang dapat digunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Grinder</a> .  Saya menambahkan warna secara manual. </li><li>  Cincin kotak: hanya upaya untuk menggambar banyak objek bergerak di layar.  Mungkin perlu menambahkan lebih banyak objek sebelum sistem mulai melambat. </li></ul><br><h2>  Musik </h2><br>  Untuk demo, saya membuat dan merekam tiga lagu, tetapi sebagai hasilnya saya hanya menggunakan dua lagu.  Komposisi pertama sebenarnya adalah melodi yang saya tulis untuk proyek lain yang diterbitkan di situs web saya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek akseptor koin</a> ) sekitar setahun yang lalu ... awalnya hanya ada satu bagian.  Setelah proyek selesai, saya pikir akan menarik untuk menempatkan solo gitar di atasnya, dan setelah merekam, saya membayangkan bahwa musik ini diputar sementara bintang-bintang terbang dalam demo.  Saya berhasil menggunakannya hanya setelah beberapa bulan.  Gitar dalam komposisi adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fender Strat I bergigi</a> . <br><br>  Saya mencatat komposisi kedua hanya sehari sebelum publikasi artikel.  Gitar solo terdengar agak ... mabuk karena dimainkan pada gitar yang saya ubah menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fretless</a> .  Saya tidak pandai memainkannya, dan nada tinggi memudar dengan sangat cepat, tetapi slide terdengar cukup keren.  Bagian ritmik dimainkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kit calon Yngwie</a> saya (Squier Strat yang bergigi murah, overdrive DOD YJM308 dan Mini-Marshall ditenagai oleh baterai 9-volt). <br><br>  Saya memprogram drum untuk kedua komposisi menggunakan program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Drums ++ yang</a> ditulis lama.  Ia menerima input file teks yang direkam dalam bahasa saya sendiri, dan mengubahnya menjadi file .mid, yang saya impor ke Apple Garage Band, setelah itu Anda dapat merekam track base dan gitar.  File sumber <a href="">fretless.dpp</a> dan <a href="">shoebox.dpp</a> ada di folder aset repositori demo saya. <br><br>  Musik diputar oleh Playstation 2 SPU2, dan berkat R5900, ia dapat melakukan pekerjaan lain.  Karena kurangnya dokumentasi yang baik, saya hampir menyelesaikan demo tanpa musik sama sekali.  Lebih lanjut tentang ini di bawah ini. <br><br>  Berikut adalah dua lagu dalam format MP3: <br><br><ul><li>  <a href="">shoebox_full.mp3</a> </li><li>  <a href="">fretless.mp3</a> </li></ul><br><h2>  Pengembangan </h2><br>  Proyek ini telah dikembangkan sejak lama.  Saya mulai menambahkan instruksi Mesin Emosi R5900 ke assembler MIPS di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">naken_asm</a> , kemudian masuk untuk instruksi floating point dan instruksi unit makro / mikro vektor.  Membuat jeda besar untuk bekerja pada proyek-proyek lain, saya mempelajari semua aspek lain yang diperlukan untuk demo ini, dan melanjutkan untuk menambahkan dukungan mereka ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Grinder</a> .  Jika seseorang tertarik pada detail level rendah, maka saya membuat halaman di mana saya mencoba mendokumentasikan semua informasi yang dikumpulkan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman Playstation 2</a> . <br><br>  Saya terutama diprogram menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">emulator PCXS2</a> .  Cukup nyaman, karena di dalamnya saya bisa memeriksa register dan sejenisnya di layar.  Tapi jelas tidak sefleksibel dan sesederhana MAME saat mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sega Genesis</a> .  Misalnya, dalam MAME lebih mudah untuk memeriksa memori, dan RAM, dan register video / audio untuk memastikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Grinder</a> berfungsi dengan baik. <br><br>  Ketika bekerja dengan kode untuk Sega, saya membuat satu kesalahan - saya tidak mengujinya di mesin sampai demo ditulis.  Setidaknya ada tiga keanehan dalam kode Sega yang diabaikan oleh emulator, tetapi mereka tidak menyukai mesin asli.  Kali ini, setelah menulis masing-masing bagian dari kode, saya mengujinya pada mesin nyata, sehingga setelah demo selesai bekerja pada peralatan nyata dan emulator.  Saya kembali menemukan hal-hal yang bekerja di emulator, tetapi tidak memulai pada PS2 nyata.  Saya juga menemukan bahwa itu bekerja pada Playstation 2 nyata, tetapi itu tidak berfungsi dengan baik di emulator. <br><br><h2>  Fitur API </h2><br><ul><li>  Unit Vector 0 memiliki metode untuk memuat / menjalankan kode dan memuat / membongkar data. </li><li>  Unit Vektor 1 melakukan rotasi dan proyeksi 3D. </li><li>  Tekstur menggunakan format 16- atau 24-bit (transparansi ditunjukkan dalam warna hitam). </li><li>  Tekstur dalam format 16-bit dapat dikodekan RLE. </li><li>  Kode untuk menggambar titik, garis, segitiga, dengan dan tanpa tekstur. </li><li>  Kabut dan naungan oleh Guro. </li><li>  Metode untuk mengakses generator nomor acak. </li><li>  Menggunakan dua konteks (mengganti halaman) </li><li>  Masukkan data biner besar ke dalam kode assembler terkompilasi. </li><li>  Memutar musik. </li></ul><br><h2>  API </h2><br>  Bagian utama API diatur dalam kelas <a href="">Playstation2</a> .  Awalnya, saya akan memberinya kebebasan besar - kemampuan untuk mengatur mode video dan sejenisnya, tapi kemudian saya pikir mungkin lebih baik untuk menyembunyikan semua kesulitan ini.  Pada dasarnya, itu hanya mengatur tampilan 640x448 interlaced.  Seperti proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Grinder</a> lainnya, saya pada dasarnya menambahkan metode / fitur yang diperlukan. <br><br>  Ada satu set kelas yang saya beri nama membosankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Draw3D</a> .  Pada intinya, mereka mendefinisikan semua jenis primitif yang dapat dihasilkan Graphics Synthesizer dengan dukungan untuk tekstur 16-, 24- dan 32-bit.  Saya berpikir untuk menambahkan tekstur 8-bit, tetapi memutuskan untuk belum melakukannya.  Draw3D menyediakan rotasi 3D, proyeksi, transfer perangkat keras DMA, tekstur, dll.  Anda mungkin akan bertanya mengapa saya tidak membuatnya berdasarkan OpenGL, tetapi saya belum pernah bekerja dengan OpenGL sebelumnya.  Sekali waktu saya terlibat dalam pemrograman ps2dev sederhana, tetapi tidak ada yang serius di sana dan saya hampir tidak ingat proyek itu, jadi saya ulangi - kita dapat berasumsi bahwa ini adalah pertama kalinya saya melakukan sesuatu yang serius dalam 3D. <br><br>  Ada contoh menggunakan semua hal ini, tidak hanya di demo, tetapi juga di folder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sampel</a> . <br>  Hampir semua kesulitan disembunyikan di API.  Pengembang tidak perlu khawatir tentang menghapus cache, tentang komputasi 3D, dll.  Namun, pengembalian untuk ini adalah penurunan fleksibilitas.  Oleh karena itu, jika, misalnya, tekstur diubah oleh prosesor, tetapi hanya 64 piksel pertama yang berubah, maka Anda hanya perlu menghapus satu baris cache 64-byte, tetapi Java Grinder menghapus seluruh gambar.  Ini menandai objek, oleh karena itu mereka dibersihkan hanya jika perlu, tetapi membersihkan seluruh fragmen memori.  Dengan probabilitas tinggi ketika mengubah 64 byte, seluruh gambar juga berubah. <br><br><h2>  Unit Vektor 0 (VU0) </h2><br>  Pengguna Java Grinder bebas menggunakan VU0.  Saya menggunakan bagian demo yang disebut "Dua Unit Vektor, Satu MIPS" untuk membuat fraktal Mandelbrot.  Kode dapat dioptimalkan dengan lebih baik, misalnya, sebagian besar instruksi unit floating point vektor memiliki waktu berjalan 1 dan latensi 4. Sejauh yang saya mengerti, ini berarti bahwa jika register adalah target untuk instruksi, maka dapat dieksekusi dalam 1 siklus, tetapi untuk agar hasilnya tersedia, diperlukan 4 siklus.  Jika register ini digunakan, maka unit vektor akan tetap menganggur sampai siap.  Oleh karena itu, idenya adalah Anda perlu mengatur instruksi sehingga Anda dapat menjalankan setiap instruksi dalam 1 siklus tanpa downtime.  Ketika saya membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fraktal Mandelbrot di Playstation 3</a> tahun lalu, saya mengoptimalkan kode ini sambil secara bersamaan menghitung 8 piksel (2 register SIMD), sambil memperhatikan peningkatan kecepatan yang besar.  Dalam kasus saat ini, saya mencoba membuat kode lebih mudah dibaca, jadi saya tidak repot dengan optimasinya. <br><br>  VU0 hanya berisi 4 KB memori data, dan Anda tidak akan menulis seluruh gambar fraktal di sana, jadi MIPS mengirimkan koordinat hanya 1/8 gambar pada satu waktu. <br><br>  Keanehan yang saya temui ketika bekerja dengan VU0: Saya awalnya menjalankan kode VU0 menggunakan instruksi dan menggunakan VIF0_STAT untuk memverifikasi penyelesaian eksekusi mereka.  Tampaknya VIF0_STAT tidak berfungsi jika Anda tidak memulai VU0 dengan paket VIF.  Ini diperbaiki di emulator, tetapi kesalahannya masih di perangkat keras nyata.  Akibatnya, saya menemukan bahwa vcallms dan menggunakan cfc2 di register 29 berfungsi di kedua kasus. <br><br>  Sepertinya saya bahwa set instruksi unit vektor tidak memiliki instruksi perbandingan paralel yang ditemukan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intel X86_64, Playstation 3,</a> dan bahkan set instruksi MIPS R5900 Emotion Engine.  Fraktal mandelbrot harus secara iteratif menghitung rumus sampai hasilnya lebih unggul, jadi dengan serangkaian instruksi yang berbeda, saya hanya akan melakukan perbandingan paralel yang akan membuat masker untuk semua biner 1 atau 0. Topeng dapat digunakan untuk menghentikan kenaikan penghitung warna.  Untuk Playstation 2, saya harus mendapatkan formula yang sangat aneh, yang cukup dekat dengan rumus fraktal.  Saya mendokumentasikan ini dalam kode sumber <a href="">mandelbrot_vu0.asm</a> sesuai dengan komentar Python. <br><br>  Saya merasa keren di perangkat unit vektor konsol Playstation 2 yang sangat bagus bahwa saya belum pernah melihat set instruksi SIMD lain di mana semua instruksi FPU dapat memiliki atribut .xyzw memberi tahu instruksi mana dari empat angka floating-point yang dimilikinya. mempengaruhi.  Artinya, jika saya membutuhkan hasil instruksi untuk mempengaruhi hanya komponen-x dari vektor, maka saya hanya akan menambahkan .x di akhir instruksi.  Hal lain yang menarik adalah bahwa itu adalah satu set instruksi VLIW, yaitu, dalam setiap siklus, dua instruksi dieksekusi secara bersamaan.  Sebenarnya, modul ini lebih seperti DSP daripada prosesor tujuan umum. <br><br><h2>  Unit Vektor 1 (VU1) </h2><br>  VU1 dicadangkan oleh Java Grinder untuk melakukan rotasi, gerakan, dan proyeksi 3D.  Objek Draw3D diteruskan ke VU1 menggunakan metode draw (), yang menggunakan assembler unit vektor untuk mengonversi titik dan mentransfernya ke Graphics Synthesizer.  Kode assembler di VU1 bisa jauh lebih baik dioptimalkan untuk kecepatan, tetapi cocok untuk tujuan saya, jadi saya memutuskan untuk membiarkan kode mudah dibaca (tidak dioptimalkan). <br><br>  Untuk mempelajari rumus proyeksi dan belokan, saya menggunakan Wikipedia: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyeksi</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">belokan</a> . <br><br>  Kode transformasi 3D juga ada di repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">naken_asm</a> sebagai file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.asm: rotasi_vu1.asm</a> sederhana. <br><br><h2>  MIPS R5900 </h2><br>  Saya tidak terlalu suka set instruksi MIPS sampai saya mulai mengerjakan proyek ini.  Bahkan, cukup mudah untuk bekerja dengan CPU ini.  Versi Emotion Engine CPU ini memiliki fitur yang sangat nyaman.  Paling khusus, register adalah 128 bit, tetapi pada kenyataannya mereka hanya digunakan untuk memuat / penyimpanan dan SIMD.  Pada kenyataannya, ini adalah register 128-bit, 64-bit ALU dan pointer 32-bit. <br><br>  Dimungkinkan juga untuk memperkenalkan optimasi ke dalam kode MIPS utama, tetapi saya tidak melakukan ini untuk menjaga keterbacaan kode atau karena kurangnya waktu.  Sebagai contoh, CPU MIPS menganggur untuk satu siklus jika register instruksi target digunakan segera setelah pengaturannya.  Perilaku ini bisa diperbaiki. <br><br><h2>  Hacks Java </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Grinder sendiri</a> juga memiliki ... keanehan, tetapi ada sesuatu yang hilang, terutama karena saya awalnya bertujuan pada MSP430 dan sebagian besar merupakan percobaan.  Salah satu elemen yang hilang adalah ketidakmampuan untuk mengalokasikan memori untuk objek.  Saya menambahkan fitur ini di Playstation 2 untuk membuat instance banyak objek, terutama menggunakan Draw3D API.  Saya tidak menulis pengalokasi memori atau pengumpul sampah, jadi semua panggilan baru dilakukan di stack.  Saya berpikir untuk mengimplementasikan sesuatu seperti pengalokasi memori yang dinamis, tetapi pada akhirnya saya memutuskan untuk tidak mempersulitnya.  Saya juga menambahkan dukungan tambahan Playstation 2 untuk angka floating point (mengambang) (sebagian dukungan ini masih dalam kode Epiphany / Parallella).  Beberapa hal lain, seperti tipe panjang dan ganda, masih belum didukung. <br><br>  Mungkin hal yang paling menyebalkan yang saya lakukan adalah terkait dengan pembatasan mengerikan dari file kelas Java.  Metode Java tidak boleh lebih besar dari 64K jika saya ingat dengan benar.  Mungkin ini normal, tetapi masalah muncul ketika ada array statis di file kelas dan tidak membuang ke file kelas sebagai data biner.  Itu ditempatkan di file kelas sebagai instruksi assembler Java dalam initializer statis untuk membuat array.  Saya mencoba untuk menyimpan gambar ke file kelas sebagai array byte statis [], tetapi beberapa di antaranya tidak cocok, jadi saya menambahkan metode ke file kelas Memory <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Grinder</a> : <br><br><pre><code class="cpp hljs">byte[] Memory.preloadByteArray(String filename);</code> </pre> <br>  Itu tidak mengunduh file ini saat runtime, tetapi mengunduhnya saat membangun menggunakan direktif .binfile <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">naken_asm</a> .  Gambar disalin ke biner keluaran selama perakitan. <br><br>  Dengan semua ini dalam pikiran, saya sangat berharap bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">James Gosling</a> tidak akan pernah tersandung pada proyek saya. <br><br><h2>  Gambar </h2><br>  Draw3D API dapat menggunakan tekstur 16-, 24- dan 32-bit.  Pixel tekstur dapat diatur piksel demi piksel atau dengan memuat menggunakan array byte [].  Saya juga menambahkan kemampuan untuk RLE-kompres gambar dalam format {length, lo16, hi16}, di mana lo16 dan hi16 adalah warna 16-bit dalam format endian kecil, yang disalin ke waktu "panjang" tekstur. <br><br><h2>  Alat-alatnya </h2><br>  Ketika bekerja pada Sega untuk membuat alat untuk membuat gambar, musik, dan sejenisnya, saya menggunakan bahasa Google Go, hanya untuk belajar bahasa baru.  Kali ini saya mencoba Rust.  Alat pertama mengkonversi binari ke kode sumber Java, dan yang kedua mengubah BMP ke format biner, yang dapat dimuat ke dalam tekstur, termasuk dalam format RLE.  Akibatnya, saya menulisnya dengan Python, kalau-kalau ada yang mau bergabung dengan saya membuat demo. <br><br><h2>  Suara </h2><br>  Setelah menemukan cara kerja perangkat grafik dan vektor, langkah terakhir adalah suara.  Saya pikir itu akan menjadi bagian yang paling mudah, terutama setelah mempelajari PDF dengan deskripsi Sony SPU2.  Betapa salahnya saya.  Bagian dari sistem ini sangat buruk didokumentasikan. <br><br>  Hal pertama yang saya temukan adalah bahwa SPU2 (unit pemrosesan suara) terhubung ke IOP (prosesor I / O, alias prosesor Playstation 1).  CPU Playstation 2 terhubung ke IOP ini melalui sesuatu yang disebut SIF.  PDF Sony hanya menyebutkan SIF DMA, tetapi tidak mengatakan apa-apa tentang penggunaannya. <br><br>  Akibatnya, saya menolak untuk menggunakan SIF, tetapi memutuskan untuk menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">naken_asm</a> sehingga saya bisa menggunakan kernel.a dari PS2DEV SDK.  Linker diterima, tetapi gagal. <br><br>  Pada tahap ini, saya sudah memutuskan bahwa saya tidak bisa mendapatkan suara untuk bekerja, dan saya hanya ingin menyelesaikan demo tanpa itu.  Tapi itu menyiksaku, jadi aku memutuskan untuk melihat kode sumber berbagai emulator Playstation 2 untuk memahami cara kerja SIF.  Akhirnya, saya menemukan cara untuk langsung mengakses memori dari kode MIPS R3000 di IOP dan menjalankannya (ada contoh di folder sampel repositori naken_asm).  Saya berhasil membuat suara bekerja di emulator. <br><br>  Pada akhirnya, saya menemukan bahwa memori TIO (termasuk SPU2) terletak di ruang Mesin Emosi, jadi saya berusaha keras (dokumentasinya sangat kecil dan tidak ada satu pun emulator yang diimplementasikan sepenuhnya dengan benar, tetapi tidak masalah bagi mereka untuk bekerja ), Saya belajar bekerja dengan suara. <br><br><h2>  Perbandingan emulator dan besi </h2><br>  Saya menemukan beberapa perbedaan antara eksekusi pada mesin nyata dan dalam sebuah emulator. <br><br><ul><li>  Jika paket GIF menetapkan register PRIM kedua nilai IIP (metode shading), dan bit FIX semuanya 1, maka emulator memperhitungkan bit IIP dan melakukan shading Gouro, sementara peralatan nyata melakukan shading datar. </li><li>  Jika paket GIF ditransmisikan melalui PATH3 (EE langsung ke GS), dan bendera EOP (akhir paket) tidak disetel, maka jika VU1 mencoba mengirim paket GIF melalui PATH 1 (VU1 ke GS), ini akan menyebabkan hang di perangkat keras nyata, tetapi akan bekerja di emulator. </li><li>  Melewatkan membersihkan cache CPU sebelum transfer DMA tidak diperlukan, tetapi pada mesin nyata menyebabkan perilaku aneh. </li><li>  Saat menempatkan SPU2 di ruang EE, emulator dapat dengan mudah merekam data audio dalam FIFO SPU2.  Pada Playstation 2 yang sebenarnya, setelah merekam 32 kata, perlu untuk menulis ke register untuk memberikan perintah untuk menghapus FIFO.  Juga, pada perangkat keras nyata, ketika mengatur transmisi / mulai alamat SPU2, mode transmisi harus diatur ke 0. Emulator tidak peduli jika mode memiliki nilai 0. </li><li>  Menulis TIO dari EE ke register memori yang dialokasikan crash pada mesin nyata, meskipun itu dalam mode kernel.  Emulator memungkinkan operasi seperti itu bekerja terlepas dari mode CPU saat ini. </li><li>  Menggunakan saluran DMA SIF bekerja di emulator, tapi saya masih belum bisa membuatnya bekerja pada peralatan nyata.  Saya mendapatkan kesalahan akses memori untuk register SIF DMA bahkan dalam mode kernel. </li><li>  Emulator terlalu lambat untuk menjalankan demo ketika menghitung fraktal menggunakan VU0, sehingga suara tidak sinkron. </li></ul><br><h2>  Untuk meringkas </h2><br>  Saya ingin menulis beberapa program untuk Playstation 2 hampir sejak saat pembelian.  Sebenarnya, saya sudah memiliki kit Linux untuk PS2 untuk waktu yang lama (saya pikir itu sebabnya saya membeli Playstation 2), dan saya bahkan mencoba bekerja dengan perpustakaan PS2DEV di C, tetapi ini adalah pengalaman yang sangat berbeda dibandingkan dengan pemrograman dalam bahasa assembly secara langsung untuk besi. <br><br>  Saya harus berterima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lukash</a> karena menyimpan kode sumber assembler lama dan dokumen PS2.  Tidak yakin apakah saya bisa memulai tanpa demo Duke 3 Star, yang membantu saya menginisialisasi peralatan.  Saya juga berterima kasih kepada para pengembang emulator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PCSX2</a> , yang sangat mempercepat proses debugging.  Selain itu, saya tidak dapat menemukan suara jika saya tidak melihat kode sumber emulator dan tidak mengerti apa yang salah. <br><br>  Dan terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sony</a> untuk komputer kecil yang cantik ini.  Jika seseorang dari Sony membaca artikel ini, inilah tipnya: mengapa tidak menyusutkan ke ukuran Rapsberry Pi dan menjualnya sebagai papan untuk proyek hobi?  :) <br><br><h2>  Bangun demo </h2><br> <code>git clone https://github.com/mikeakohn/playstation2_demo.git <br> git clone https://github.com/mikeakohn/java_grinder.git <br> git clone https://github.com/mikeakohn/naken_asm.git <br> cd naken_asm <br> ./configure <br> make <br> cd .. <br> cd java_grinder <br> make java <br> make <br> cd .. <br> cd playstation2_demo <br> make</code> </div> </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423751/">https://habr.com/ru/post/id423751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423741/index.html">Abstrak CRUD dari repositori ke controller: apa lagi yang bisa Anda lakukan dengan Spring + Generics</a></li>
<li><a href="../id423743/index.html">Di bawah kontrol: alat pemantauan disk server VDS</a></li>
<li><a href="../id423745/index.html">Menggunakan Python untuk menganalisis keterampilan yang diminta terkait di antara pengembang</a></li>
<li><a href="../id423747/index.html">Alat pengembangan baru dengan LEGO Education - dari Microsoft, MIT, dan lainnya</a></li>
<li><a href="../id423749/index.html">8 langkah mudah untuk gagal manajer pengembangan pemula</a></li>
<li><a href="../id423753/index.html">Jaga token otorisasi tetap aman</a></li>
<li><a href="../id423759/index.html">Fintech-digest: data pribadi warga Federasi Rusia, pasar Bank Sentral, layanan baru dari CloudFlare</a></li>
<li><a href="../id423763/index.html">Apa Uang Tunai yang Mengajarkan Para Inovator</a></li>
<li><a href="../id423765/index.html">Kami sedang menulis aplikasi untuk remote control pemutar MPV dari RetroOrangePi</a></li>
<li><a href="../id423767/index.html">Peretas menyerang British Airways: 380.000 kartu bank pelanggan dicuri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>