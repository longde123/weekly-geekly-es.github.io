<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèª üéõÔ∏è ü§• Bereaksi praktik terbaik dan kiat yang harus diketahui setiap pengembang. Bagian 1 üå©Ô∏è üõí ü§∏üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan artikel "Bereaksi Praktik Terbaik & Tip yang Harus Diketahui Setiap Pengembang Reaksi Pt. 1" o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereaksi praktik terbaik dan kiat yang harus diketahui setiap pengembang. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465685/">  Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bereaksi Praktik Terbaik &amp; Tip yang Harus Diketahui Setiap Pengembang Reaksi Pt. 1"</a> oleh Alex Devero. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c4/dc3/379/3c4dc337915c44904f1ad1aab1f3aa58.jpg" alt="gambar"><br><br>  React adalah salah satu perpustakaan paling populer untuk membangun antarmuka pengguna interaktif.  Dalam artikel ini, saya akan menunjukkan kepada Anda beberapa contoh Bereaksi praktik terbaik yang akan membantu Anda menjadi pengembang yang lebih baik.  Lihatlah instruksi ini untuk menjadi lebih baik dalam menulis kode Bereaksi. <br><br>  Konten: <br><br><ol><li>  <b>Jaga komponen Anda kecil</b> </li><li>  <b>Hindari menumpuk komponen</b> </li><li>  <b>Kurangi penggunaan komponen stateful</b> </li><li>  <b>Gunakan komponen fungsional dengan kait dan memo, bukan komponen di kelas</b> </li><li>  <b>Jangan gunakan alat peraga dalam kondisi asli.</b> </li></ol><a name="habracut"></a><br>  <b>Epilog: Bereaksi Praktik Terbaik dan Kiat Yang Harus Diketahui Setiap Pengembang Bagian 1</b> <br><br><h3>  1. Jaga agar komponen Anda kecil </h3><br>  Menjaga komponen tetap kecil adalah salah satu praktik terbaik React yang dapat bekerja dengan sangat baik.  Menerapkan hanya praktik yang tampaknya sederhana ini dapat membantu Anda menulis kode yang lebih bersih dan lebih dapat dikelola.  Belum lagi itu dapat membantu mempertahankan alasan, atau setidaknya apa yang tersisa. <br><br>  Ada satu aturan praktis yang terbukti yang bisa Anda gunakan.  Lihatlah metode render.  Jika memiliki lebih dari 10 baris, maka komponen Anda mungkin terlalu besar, dan merupakan kandidat yang baik untuk melakukan refactoring dan pemisahan menjadi beberapa komponen yang lebih kecil.  Ingatlah bahwa salah satu ide untuk menggunakan React, atau bagian dari filosofinya, adalah menggunakan kembali kode. <br><br>  Tujuannya adalah untuk membuat potongan kode yang Anda tulis sekali, dan kemudian menggunakannya lagi dan lagi ketika Anda perlu.  Dari sudut pandang ini, tidak masuk akal untuk menggabungkan semua data Anda menjadi satu komponen besar, satu file.  Dan, bahkan jika Anda benar-benar tidak peduli dengan kode yang dapat digunakan kembali, pikirkanlah.  Seberapa mudah komponen dengan ratusan baris kode didukung? <br><br>  Komponen seperti itu akan sulit dipertahankan, didebug, dan diperbarui.  Ini juga berarti bahwa pekerjaan apa pun dengan komponen ini akan memakan waktu lebih lama.  Dengan kata lain, kinerja keseluruhan Anda akan berkurang.  Dan cepat atau lambat itu akan membuat Anda gila.  Atau itu akan membuat rekan tim dan kolega Anda gila, dan mereka akan mulai membuat Anda gila. <br><br>  Apa pun yang Anda pilih, Anda akan segera kehilangan akal dan mungkin membuat musuh untuk diri sendiri.  Itu tidak layak.  Jaga komponen Anda kecil.  Pertahankan pertemanan, kewarasan, waktu, dan produktivitas.  Sederhanakan debugging, perbarui, dan pertahankan kode.  Pertimbangkan satu contoh. <br><br>  Apakah <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/// // file: index.jsx import React from 'react' const books = [ { category: 'Business', price: '$20.00', name: 'Private Empires', author: 'Steve Coll' }, { category: 'Philosophy', price: '$25.00', name: 'The Daily Stoic', author: 'Ryan Holiday' }, { category: 'Sport', price: '$15.95', name: 'Moneyball', author: 'Michael Lewis' }, { category: 'Biography', price: '$21.00', name: 'Titan', author: 'Ron Chernow' }, { category: 'Business', price: '$29.99', name: 'The Hard Thing About Hard Things', author: 'Ben Horowitz' }, { category: 'Fiction', price: '$4.81', name: 'Limitless: A Novel', author: 'Alan Glynn' } ] class Bookshelf extends React.Component { render() { const tableRows = [] this.props.books.forEach((book) =&gt; { tableRows.push( &lt;tr&gt; &lt;td&gt;{book.name}&lt;/td&gt; &lt;td&gt;{book.author}&lt;/td&gt; &lt;td&gt;{book.price}&lt;/td&gt; &lt;td&gt;{book.category}&lt;/td&gt; &lt;/tr&gt; ) }) return ( &lt;div&gt; &lt;form&gt; &lt;input type="text" placeholder="Search..." /&gt; &lt;button&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Author&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;th&gt;Category&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;{tableRows}&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; ) } } // Render Bookshelf component ReactDOM.render(&lt;Bookshelf books={booksData} /&gt;, document.getElementById('container'))</span></span></code> </pre> <br>  Telah menjadi <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/// // file: books-data.js const books = [ { category: 'Business', price: '$20.00', name: 'Private Empires', author: 'Steve Coll' }, { category: 'Philosophy', price: '$25.00', name: 'The Daily Stoic', author: 'Ryan Holiday' }, { category: 'Sport', price: '$15.95', name: 'Moneyball', author: 'Michael Lewis' }, { category: 'Biography', price: '$21.00', name: 'Titan', author: 'Ron Chernow' }, { category: 'Business', price: '$29.99', name: 'The Hard Thing About Hard Things', author: 'Ben Horowitz' }, { category: 'Fiction', price: '$4.81', name: 'Limitless: A Novel', author: 'Alan Glynn' } ] export default booksData /// // file: components/books-table.jsx import React from 'react' class BooksTable extends React.Component { render() { const tableRows = [] this.props.books.forEach((book) =&gt; { tableRows.push( &lt;tr&gt; &lt;td&gt;{book.name}&lt;/td&gt; &lt;td&gt;{book.author}&lt;/td&gt; &lt;td&gt;{book.price}&lt;/td&gt; &lt;td&gt;{book.category}&lt;/td&gt; &lt;/tr&gt; ) }) return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Author&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;th&gt;Category&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;{tableRows}&lt;/tbody&gt; &lt;/table&gt; ) } } export default BooksTable /// // file: components/search-bar.jsx import React from 'react' class SearchBar extends React.Component { render() { return ( &lt;form&gt; &lt;input type="text" placeholder="Search..." /&gt; &lt;button&gt;Search&lt;/button&gt; &lt;/form&gt; ) } } export default SearchBar /// // file: components/bookshelf.jsx import React from 'react' // Import components import BooksTable from './components/books-table' import SearchBar from './components/search-bar' class Bookshelf extends React.Component { render() { return ( &lt;div&gt; &lt;SearchBar /&gt; &lt;BooksTable books={this.props.books} /&gt; &lt;/div&gt; ) } } export default Bookshelf /// // file: index.jsx import React from 'react' // Import components import Bookshelf from './components/bookshelf // Import data import booksData from './books-data' // Render Bookshelf component ReactDOM.render(&lt;Bookshelf books={booksData} /&gt;, document.getElementById('container'))</span></span></code> </pre> <br><h3>  2. Hindari menumpuk komponen </h3><br>  Setiap aturan harus diterapkan dengan hati-hati.  Ini juga berlaku untuk Praktik terbaik Bereaksi ini, terutama yang sebelumnya.  Ketika datang ke komponen, sangat mudah untuk berlebihan dan menulis bahkan bagian terkecil dari kode dalam bentuk komponen.  Jangan lakukan ini.  Tidak masuk akal untuk membuat setiap paragraf, rentang atau div komponen. <br>  Pikirkan sebelum Anda mulai membagi setiap komponen menjadi bagian-bagian kecil.  Anda dapat menganggap komponen tersebut sebagai campuran "HTML", yang hanya melakukan satu hal, independen, dan pengguna akan melihatnya secara keseluruhan.  Apakah masuk akal untuk membuat bagian kode ini komponen?  Jika tidak, gabungkan kode ini.  Kalau tidak, bagi saja. <br><br>  Mari kita lihat beberapa contoh untuk menggambarkan definisi komponen ini.  Salah satu contoh adalah dialog modal.  Komponen ini dapat terdiri dari banyak elemen kecil, seperti divs, heading, paragraf teks, tombol, dll.  Secara teoritis, semua elemen ini dapat dibedakan menjadi komponen kecil. <br><br>  Dalam praktiknya, ini tidak ada gunanya.  Ya, beberapa elemen ini dapat eksis secara independen satu sama lain.  Namun, apakah benar-benar berguna untuk membuat komponen yang hanya terdiri dari satu paragraf atau satu judul?  Apa yang akan terjadi selanjutnya?  Komponen untuk label, input atau bahkan rentang?  Pendekatan ini tidak berkelanjutan. <br><br>  Untungnya, ada cara lain untuk melihatnya.  Anda dapat menggunakan metodologi desain atom sebagai panduan.  Dalam desain atom, semuanya dibagi menjadi enam kategori: atom, molekul, organisme, templat, halaman, dan utilitas.  Anda mulai dengan elemen terkecil, seperti tombol, tautan, pintasan, input, dll.  Ini adalah atom. <br><br>  Kemudian Anda menggabungkan atom dan membuat molekul.  Contoh molekul dapat berupa dialog modal, formulir, jendela sembul, menu tarik-turun, navigasi, dll.  Selanjutnya, Anda dapat menggabungkan satu molekul dengan yang lain atau dengan atom dan membuat organisme.  Contoh organisme adalah tajuk, daftar produk, atau keranjang belanja.  Template, halaman, dan utilitas tidak lagi penting. <br><br>  Bagaimana menggabungkan desain atomik dengan dua contoh praktik terbaik ini untuk komponen Bereaksi?  Jangan ribet.  Komponen dapat berupa sesuatu yang lebih dari sekadar atom, mis.  molekul, organisme, atau bahkan templat atau halaman, jika diambil hingga batasnya.  Dalam hal ini, label, pos, paragraf bukan komponen, karena mereka adalah atom. <br>  Namun, dialog modal, formulir, pop-up, daftar drop-down, dll.  adalah komponen, karena semuanya berhubungan baik dengan molekul atau dengan kategori suatu organisme.  Masih ada beberapa elemen yang meragukan, seperti tombol.  Ya, dari sudut pandang struktur atom itu adalah atom.  Namun, ia dapat eksis secara mandiri, dalam banyak variasi, dan masih berfungsi. <br><br>  Dalam kasus seperti itu, saya sarankan untuk tidak memikirkan praktik terbaik React, dan hanya dibimbing oleh insting batin saya.  Pada akhirnya, Andalah yang akan bekerja dengan kode tersebut.  Yang penting Anda merasa nyaman.  Jadi jangan hanya membabi buta mengikuti beberapa praktik terbaik.  Dan jika Anda bekerja dalam tim?  Bagikan pemikiran Anda tentang ini dengan kolega Anda. <br><br><h3>  3. Kurangi penggunaan komponen stateful </h3><br>  Ini adalah salah satu praktik Bereaksi terbaik yang telah diterapkan selama beberapa waktu.  Namun, praktik ini telah menjadi lebih populer dengan munculnya React 16.8.0 dan React hooks.  Sebelum itu, ketika Anda ingin menggunakan keadaan atau metode siklus hidup apa pun, Anda juga harus menggunakan komponen stateful.  Tidak ada jalan lain. <br><br>  Kait mengubah itu.  Setelah mereka secara resmi diluncurkan, React developer tidak lagi terbatas pada komponen stateful karena mereka perlu menggunakan state.  Berkat kaitannya, pengembang Bereaksi sekarang dapat menulis komponen stateless menggunakan negara dan bahkan metode siklus hidup yang mereka inginkan. <br><br>  Mengapa ini penting?  Komponen stateless atau fungsional umumnya lebih baik daripada komponen stateful ketika datang ke kinerja.  Alasannya adalah bahwa tidak ada metode keadaan atau siklus hidup.  Dengan kata lain, lebih sedikit kode yang harus dieksekusi serta transpiling.  Tentu saja, perbedaan ini hampir tidak terlihat, hampir tidak terlihat, jika Anda mengerjakan proyek yang sangat kecil. <br><br>  Namun, perbedaan kecil ini dapat bertambah seiring dengan pertumbuhan proyek Anda.  Pikirkan juga berapa banyak baris kode yang diperlukan komponen stateful dibandingkan dengan yang fungsional.  Fungsionalitasnya juga lebih pendek dan seringkali lebih mudah dibaca.  Mari kita lihat komponen tombol, yang didefinisikan sebagai komponen dengan kontrol dan fungsi keadaan.  Yang mana yang lebih Anda sukai? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Button defined as a stateful component class Button extends React.Component { handleClick = () =&gt; { // Do something } render() { return( &lt;button type="button" onClick={this.handleClick}&gt;Click me&lt;/button&gt; ) } } // Button defined as a functional component const Button = () =&gt; { const handleClick = () =&gt; { // Do something } return( &lt;button type="button" onClick={handleClick}&gt;Click me&lt;/button&gt; ) }</span></span></code> </pre><br><h3>  4. Gunakan komponen fungsional dengan kait dan memo, bukan komponen di kelas </h3><br>  Seperti yang sudah kita bahas, Anda tidak perlu lagi menggunakan komponen stateful hanya untuk menggunakan status.  Selain itu, beberapa pengembang Bereaksi juga percaya bahwa di masa depan, Bereaksi akan mulai menjauh dari kelas.  Apakah ini benar, sekarang tidak masalah.  Yang penting adalah bahwa satu komponen fungsional sekarang dapat menggunakan status berkat kait. <br>  Dan kedua, penggunaan komponen fungsional memiliki kelebihan.  TLDR?  Tidak ada kelas, warisan dan konstruktor.  Tidak ada kata kunci ini.  Praktik-Praktik Terbaik Bereaksi Ketat.  Rasio sinyal terhadap noise tinggi.  Komponen yang bengkak dan struktur data yang buruk lebih mudah dikenali.  Kode lebih mudah dipahami dan diverifikasi.  Dan, sekali lagi, kinerja lebih baik. <br><br>  Dan satu hal lagi.  Banyak pengembang Bereaksi menentang komponen fungsional.  Salah satu masalah adalah bahwa Anda, sebagai pengembang Bereaksi, tidak dapat mengontrol proses rendering saat menggunakan komponen fungsional.  Ketika sesuatu berubah, React mengembalikan komponen fungsional, terlepas dari apakah komponen itu sendiri telah diubah. <br>  Di masa lalu, solusinya adalah menggunakan komponen murni.  Komponen bersih menyediakan kemampuan untuk membandingkan keadaan dan alat peraga.  Ini berarti bahwa Bereaksi dapat "memeriksa" apakah isi komponen, alat peraga, atau komponen itu sendiri telah berubah.  Jika demikian, ia akan mengembalikannya.  Kalau tidak, itu akan melewati rendering ulang dan akan menggunakan kembali hasil yang diberikan terakhir.  Kurang rendering sama dengan kinerja yang lebih baik. <br>  Dengan Bereaksi 16.6.0, ini tidak lagi menjadi masalah, dan argumen terhadap komponen fungsional tidak lagi valid.  Yang mengubah permainan adalah memo.  Memo membawa perbandingan yang dangkal dengan komponen fungsional, kemampuan untuk "memeriksa" apakah konten komponen, alat peraga, atau komponen itu sendiri telah berubah. <br><br>  Sekali lagi, berdasarkan perbandingan ini, Bereaksi akan mengembalikan komponen kembali atau menggunakan kembali hasil rendering terakhir.  Singkatnya, memo memungkinkan Anda membuat komponen fungsional "bersih".  Tidak ada alasan lagi untuk menggunakan komponen statefull, atau komponen murni.  Paling tidak jika Anda tidak perlu mengatasi kondisi yang sulit. <br><br>  Dalam hal ini, Anda harus mempertimbangkan untuk menggunakan sesuatu yang lebih skalabel dan dapat diatur, seperti MobX, Redux, atau Flux, alih-alih keadaan komponen.  Pilihan lain yang mungkin adalah menggunakan konteks.  Bagaimanapun, berkat kait dan memo, komponen fungsional tentu saja merupakan beberapa praktik React terbaik yang layak untuk dipikirkan. <br><br><h3>  5. Jangan gunakan alat peraga dalam kondisi asli </h3><br>  Ini adalah salah satu praktik React terbaik yang ingin saya ketahui ketika saya mulai belajar.  Kemudian saya tidak tahu bahwa itu adalah ide yang sangat buruk untuk menggunakan alat peraga di kondisi awal.  Mengapa ini ide yang buruk?  Masalahnya adalah bahwa konstruktor dipanggil hanya sekali selama pembuatan komponen. <br><br>  Ini berarti bahwa ketika Anda membuat beberapa perubahan pada alat peraga di waktu berikutnya, keadaan komponen tidak akan diperbarui.  Itu akan mempertahankan makna sebelumnya.  Kemudian saya keliru menganggap bahwa alat peraga disinkronkan dengan negara.  Jadi, ketika beberapa detail berubah, negara akan berubah untuk mencerminkan perubahan ini.  Sayangnya, ini tidak benar. <br><br>  Ini mungkin tidak menjadi masalah jika Anda ingin negara bagian menerima nilai dari properti hanya sekali selama rendering awal, dan Anda akan mengontrol keadaan di dalam komponen.  Jika tidak, Anda bisa menyelesaikan masalah ini dengan componentDidUpdate.  Seperti namanya, metode siklus hidup ini memungkinkan Anda untuk memperbarui komponen ketika ada perubahan, seperti alat peraga. <br><br>  Jika Anda memutuskan untuk menggunakan metode ini, ingat satu hal.  Ini tidak akan terlibat dalam rendering awal, tetapi hanya di berikutnya.  Oleh karena itu, pastikan untuk menginisialisasi keadaan komponen dengan nilai yang diperlukan, mungkin diperoleh dari alat peraga.  Kemudian gunakan componentDidUpdate untuk memperbarui nilai-nilai ini dan komponen yang diperlukan. <br><br><h3>  Epilog: Bereaksi Praktik Terbaik dan Kiat Yang Harus Diketahui Setiap Pengembang Bagian 1 </h3><br>  Selamat!  Anda baru saja menyelesaikan bagian pertama dari seri-mini artikel tentang praktik terbaik React ini.  Hari ini, Anda telah belajar tentang lima praktik yang dapat Anda gunakan untuk membuat kode Bereaksi lebih pendek, lebih sederhana, lebih baik, lebih cepat, dan lebih mudah dibaca dan dipelihara.  Sekarang terserah Anda untuk menerapkan praktik yang Anda setujui dan mulai menggunakannya. <br><br>  Di bagian selanjutnya, Anda akan belajar tentang serangkaian praktik terbaik dan kiat untuk membantu Anda meningkatkan kode Bereaksi, serta keterampilan pemrograman Anda.  Sampai saat itu, ambil apa yang Anda pelajari hari ini dan habiskan sebagian waktu Anda untuk berlatih. <br><br>  Jika Anda menyukai artikel ini, silakan berlangganan. <br><br>  Awalnya diposting ke Blog Alex Devero. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465685/">https://habr.com/ru/post/id465685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465675/index.html">Bagaimana NASA peduli dengan keselamatan dan kecerdasan para astronotnya</a></li>
<li><a href="../id465677/index.html">Lupakan Walkman: itu semua tentang headphone</a></li>
<li><a href="../id465679/index.html">Apa yang dapat dilakukan arloji selain menunjukkan waktu dan cara memilih arloji pertama Anda</a></li>
<li><a href="../id465681/index.html">Seperti derak api, derit pintu dan suara paling biasa menjadi musik dan jatuh ke trek elektro-akustik</a></li>
<li><a href="../id465683/index.html">"The Curse of Cinema": siapa yang tidak puas dengan perataan gerakan di TV modern - bagaimana situasinya berkembang</a></li>
<li><a href="../id465687/index.html">Bagian dari mesin laboratorium untuk "Hackthebox - Querier" Pentest</a></li>
<li><a href="../id465689/index.html">Russian Railway Simulator (RRS): rilis publik pertama</a></li>
<li><a href="../id465691/index.html">Menggunakan REST di ENM Ericsson dengan Python</a></li>
<li><a href="../id465703/index.html">Cara mendapatkan penghasilan tambahan untuk perusahaan menggunakan pertukaran: investasi dalam produk struktural</a></li>
<li><a href="../id465709/index.html">JustCode - peramban berkecepatan tinggi untuk komputer dan tablet beranggaran di Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>