<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëò üçà ü•¢ Mesin rendering sudut 6 dan Ivy üç¶ üö£ ü¶î</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat sore, kolega. Kami sedang mempertimbangkan apakah akan memperbarui buku oleh Jacob Fine dan Anton Moiseev " Angular dan TypeScript. Membangun ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesin rendering sudut 6 dan Ivy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/419389/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/wl/x_/u9/wlx_u9fwbjqm0in1o-f790lshsg.jpeg" align="left" alt="gambar"></a>  Selamat sore, kolega.  Kami sedang mempertimbangkan apakah akan memperbarui buku oleh Jacob Fine dan Anton Moiseev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Angular dan TypeScript. Membangun situs web untuk para profesional</a> ."  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Edisi baru</a> keluar musim gugur ini dan mencakup materi tentang Angular 5 dan 6. <br><br>  Awalnya kami berpikir untuk menerbitkan materi tentang mesin Ivy, yang kemungkinan akan menjadi inovasi paling menarik di Angular 6, tetapi kemudian kami berhenti pada publikasi yang lebih umum dari Cedric Exbright (aslinya dirilis pada Mei). <br><br>  Di Angular 6, ada banyak inovasi serius, apalagi, yang paling penting dari mereka Anda tidak dapat menyebutkan fitur: ini Ivy, mesin render baru.  Karena mesin ini masih eksperimental, kami akan membicarakannya di akhir artikel ini, dan mulai dengan fitur baru dan perubahan revolusioner lainnya. <br><a name="habracut"></a><br>  <b>Penyedia yang bisa digerakkan pohon</b> <br><br>  Sekarang ada cara baru yang disarankan untuk mendaftarkan penyedia secara langsung di dekorator <code>@Injectable()</code> , menggunakan atribut baru yang <code>providedIn</code> .  Dibutuhkan <code>'root'</code> sebagai nilai modul apa pun dalam aplikasi Anda.  Saat menggunakan <code>'root'</code> objek yang diimplementasikan akan didaftarkan dalam aplikasi sebagai penyendiri, dan Anda tidak perlu menambahkannya ke penyedia di modul root.  Demikian pula, ketika menggunakan <code>providedIn: UsersModule</code> objek yang diimplementasikan terdaftar sebagai penyedia <code>UsersModule</code> , dan tidak ditambahkan ke penyedia modul. <br><br><pre> <code class="javascript hljs">@Injectable({ <span class="hljs-attr"><span class="hljs-attr">providedIn</span></span>: <span class="hljs-string"><span class="hljs-string">'root'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserService</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Metode baru seperti itu diperkenalkan untuk menghapus kode non-fungsional dengan lebih baik dalam aplikasi (tree-shaking).  Saat ini, situasinya sedemikian rupa sehingga layanan yang ditambahkan ke penyedia modul akan berakhir pada set terakhir, bahkan jika itu tidak digunakan dalam aplikasi - dan membiarkan ini sedikit sedih.  Jika Anda menggunakan lazy loading, Anda dapat jatuh ke dalam beberapa perangkap sekaligus, atau menemukan diri Anda dalam situasi di mana layanan akan dimasukkan dalam rangkaian yang salah. <br><br>  Situasi seperti itu dalam aplikasi tidak mungkin sering terjadi (jika Anda menulis layanan, lalu menggunakannya), tetapi modul pihak ketiga terkadang menawarkan layanan yang tidak kita butuhkan - sebagai hasilnya, kita memiliki sejumlah besar JavaScript yang tidak berguna. <br><br>  Jadi, fitur ini akan sangat berguna bagi pengembang perpustakaan, tetapi sekarang dianjurkan untuk mendaftarkan objek yang diimplementasikan dengan cara ini - ini juga berlaku untuk pengembang aplikasi.  CLI baru sekarang bahkan menggunakan scaffolding yang <code>providedIn: 'root'</code> secara default ketika bekerja dengan layanan. <br><br>  Dengan nada yang sama, Anda sekarang dapat mendeklarasikan <code>InjectionToken</code> , mendaftarkannya langsung dengan yang <code>providedIn</code> dan menambahkan <code>factory</code> sini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baseUrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectionToken&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'baseUrl'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, { providedIn: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'root'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, factory: (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'http://localhost:8080/'</span></span> });</code> </pre> <br>  Harap dicatat: ini juga menyederhanakan pengujian unit.  Untuk keperluan pengujian semacam itu, mereka digunakan untuk mendaftarkan layanan dengan penyedia modul uji.  Inilah yang kami lakukan sebelumnya: <br><br><pre> <code class="javascript hljs">beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> TestBed.configureTestingModule({ <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [UserService] }));</code> </pre><br>  Sekarang, jika Layanan Pengguna menggunakan <code>providedIn: 'root'</code> : <br><br><pre> <code class="javascript hljs">beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> TestBed.configureTestingModule({}));</code> </pre> <br>  Hanya saja, jangan khawatir: semua layanan yang terdaftar dengan In tidak dimasukkan ke dalam tes, tetapi malas dipakai, hanya dalam kasus ketika mereka benar-benar diperlukan. <br><br>  <b>Rxjs 6</b> <br><br>  Angular 6 sekarang menggunakan RxJS 6 secara internal, jadi Anda perlu memperbarui aplikasi dengan mempertimbangkan hal ini. <br><br>  Dan ... RxJS 6 mengubah pendekatan untuk mengimpor! <br><br>  Di RxJS 5, Anda bisa menulis: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/observable/of'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/operator/map'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = Observable.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n);</code> </pre> <br>  Dalam RxJS 5.5, pernyataan yang dapat disambungkan muncul: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/observable/of'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { map } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n) );</code> </pre><br>  Dan di RxJS 6.0, impor telah berubah: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { map } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n) );</code> </pre> <br>  Jadi, suatu hari Anda harus mengubah impor dalam seluruh aplikasi.  Saya menulis "sekali", dan bukan "sekarang", karena perpustakaan rxJs-compat dirilis di RxJS, yang memungkinkan mengunduh RxJS ke versi 6.0, bahkan jika versi lama masih digunakan di seluruh aplikasi Anda atau di salah satu perpustakaan yang digunakan sintaksis. <br><br>  Tim Angular telah menulis <a href="">seluruh dokumen</a> tentang hal ini, dan mutlak diperlukan untuk membacanya sebelum bermigrasi ke Angular 6.0. <br><br>  Harap dicatat: di sini adalah seperangkat aturan tslint yang sangat keren yang disebut <code>rxjs-tslint</code> .  Hanya ada 4 aturan di dalamnya, dan jika Anda menambahkannya ke proyek, sistem akan secara otomatis memigrasi semua impor dan kode RxJS Anda, dan ini dilakukan oleh <code>tslint --fix</code> !  Lagi pula, jika Anda masih belum tahu, di <code>tslint</code> ada opsi <code>fix</code> yang secara otomatis memperbaiki semua kesalahan yang ditemukannya!  Ini dapat digunakan lebih sederhana lagi: instal <code>rxjs-tslint</code> secara global dan jalankan <code>rxjs-5-to-6-migrate -p src/tsconfig.app.json</code> .  Saya mencoba <code>rxjs-tslint</code> di salah satu proyek kami dan itu bekerja dengan cukup baik (jalankan setidaknya dua kali untuk juga menutup semua impor).  Lihat README dari proyek ini untuk lebih jelasnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/ReactiveX/rxjs-tslint</a> . <br><br>  Jika Anda tertarik untuk mempelajari lebih lanjut tentang RxJS 6.0, saya merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> Ben Lesch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berikutnya</a> tentang ng-conf. <br><br>  <b>i18n</b> <br><br>  Prospek terpenting yang terkait dengan i18n adalah kemampuan untuk membuat "i18n saat runtime", tanpa harus membuat aplikasi secara terpisah untuk setiap titik lokal.  Fitur ini belum tersedia (hanya ada prototipe), dan mesin Ivy akan diperlukan untuk operasinya (lebih lanjut tentang itu di bawah). <br><br>  Perubahan lain terkait i18n telah terjadi dan tersedia.  Saluran mata uang dioptimalkan dengan cara yang paling efisien: sekarang ia membulatkan semua mata uang tidak menjadi 2 digit, seperti sebelumnya, tetapi ke jumlah digit yang diinginkan (misalnya, ke 3 dalam kasus dinar Bahrain atau ke 0 untuk peso Chili). <br><br>  Jika diperlukan, nilai ini dapat diambil secara terprogram menggunakan fungsi <code>getNumberOfCurrencyDigits</code> i18n baru. <br><br>  Fungsi pemformatan nyaman lainnya, seperti <code>formatDate</code> , <code>formatCurrency</code> , <code>formatPercent</code> dan <code>formatNumber</code> juga muncul di <code>formatNumber</code> <code>formatPercent</code> . <br><br>  Cukup nyaman, jika Anda ingin menerapkan transformasi yang sama yang dilakukan di saluran, tetapi lakukan dari kode TypeScript. <br><br>  <b>Animasi</b> <br><br>  Di Angular 6.0, animasi sudah dimungkinkan tanpa polyfill <code>web-animations-js</code> , kecuali Anda menggunakan <code>AnimationBuilder</code> .  Aplikasi Anda dapat memenangkan beberapa byte berharga!  Jika browser tidak mendukung API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>element.animate</code></a> , Angular 6.0 memutar kembali ke penggunaan kerangka kunci CSS. <br><br>  <b>Elemen Sudut</b> <br><br>  Angular Elements adalah proyek yang memungkinkan Anda untuk membungkus komponen Angular sebagai komponen web dan menyematkannya dalam aplikasi yang tidak menggunakan Angular.  Pada awalnya, proyek ini hanya ada di "Angular Lab" (artinya, masih eksperimental).  Dengan v6, ia muncul sedikit di garis depan dan secara resmi dimasukkan dalam kerangka kerja.  Ini adalah topik besar yang layak mendapat artikel terpisah. <br><br>  <b>ElementRef &lt;T&gt;</b> <br><br>  Jika Anda ingin mengambil tautan elemen dalam templat Anda, Anda bisa menggunakan <code>@ViewChild</code> atau <code>@ViewChildren</code> , atau bahkan langsung mengimplementasikan <code>ElementRef</code> .  Kekurangan dalam hal ini adalah ini: dalam Angular 5.0 atau lebih rendah, <code>ElementRef</code> ditentukan akan mendapatkan jenis <code>any</code> untuk properti <code>nativeElement</code> . <br><br>  Di Angular 6.0 Anda bisa mengetik ElementRef lebih ketat jika Anda mau: <br><br><pre> <code class="javascript hljs">@ViewChild(<span class="hljs-string"><span class="hljs-string">'loginInput'</span></span>) loginInput: ElementRef&lt;HTMLInputElement&gt;; ngAfterViewInit() { <span class="hljs-comment"><span class="hljs-comment">// nativeElement  `HTMLInputElement` this.loginInput.nativeElement.focus(); }</span></span></code> </pre> <br>  <b>Apa yang diakui sebagai yang tidak diinginkan dan apa yang berubah secara fundamental</b> <br><br>  Mari kita bicara tentang apa yang perlu Anda ingat ketika memulai migrasi! <br><br>  <i><b><code>preserveWhitespaces</code> : default <code>false</code></b></i> <br><br>  Di bagian "Masalah yang mungkin terjadi selama pemutakhiran", kami mencatat bahwa preserveWhitespaces sekarang <code>false</code> secara default.  Opsi ini muncul di Angular 4.4, dan jika Anda bertanya-tanya apa yang diharapkan pada saat yang sama - di sini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seluruh posting</a> tentang topik ini.  Spoiler: semuanya bisa dilakukan, atau sepenuhnya dapat merusak templat Anda. <br><br>  <i><b><code>ngModel</code> dan formulir reaktif</b></i> <br><br>  Sebelumnya, dimungkinkan untuk menyediakan bidang formulir yang sama dengan <code>ngModel</code> dan <code>formControl</code> , tetapi hari ini praktik ini dianggap tidak diinginkan dan tidak akan lagi didukung dalam Angular 7.0. <br><br>  Ada sedikit kebingungan di sini, dan seluruh mekanisme bekerja, mungkin tidak seperti yang Anda harapkan ( <code>ngModel</code> - ini adalah arahan yang belum lama Anda kenal, tetapi input / output dari direktif <code>formControl</code> , yang melakukan hampir sama, tetapi bukan tugas yang identik). <br><br>  Jadi sekarang, jika kita menerapkan kode: <br><br><pre> <code class="javascript hljs">&lt;input [(ngModel)]=<span class="hljs-string"><span class="hljs-string">"user.name"</span></span> [formControl]=<span class="hljs-string"><span class="hljs-string">"nameCtrl"</span></span>&gt;</code> </pre> <br>  maka kita mendapat peringatan. <br><br>  Anda dapat mengkonfigurasi aplikasi untuk menampilkan peringatan <code>always</code> ( <code>once</code> ), <code>once</code> (sekali) atau <code>never</code> (tidak pernah).  Default <code>always</code> . <br><br><pre> <code class="javascript hljs">imports: [ ReactiveFormsModule.withConfig({ <span class="hljs-attr"><span class="hljs-attr">warnOnNgModelWithFormControl</span></span>: <span class="hljs-string"><span class="hljs-string">'never'</span></span> }); ]</code> </pre> <br>  Dengan satu atau lain cara, mempersiapkan transisi ke Angular 7, Anda perlu menyesuaikan kode untuk menggunakan formulir berorientasi template atau formulir reaktif. <br><br>  <b>Proyek Ivy: mesin render baru (baru) di Angular</b> <br><br>  Soooo ...  Ini adalah rilis Angular utama ke-4 (2, 4, 5, 6), dan mesin rendering sedang ditulis ulang untuk ketiga kalinya! <br><br>  Ingat: Angular mengkompilasi template Anda menjadi kode TypeScript yang setara.  Kemudian TypeScript ini dikompilasi dengan TypeScript yang Anda tulis dalam JavaScript, dan hasilnya ada di tangan pengguna.  Dan sebelum kita sudah versi ke-3 dari mesin rendering ini di Angular (yang pertama adalah dalam rilis awal Angular 2.0, dan yang kedua di Angular 4.0). <br><br>  Dalam versi baru dari mesin render ini, pendekatan penulisan templat tidak berubah, namun, ia mengoptimalkan sejumlah indikator, khususnya: <br><br><ul><li>  Bangun waktu </li><li>  Ukuran dial </li></ul><br>  Semua ini masih sangat eksperimental, dan mesin rendering Ivy baru dihidupkan oleh kotak centang, yang harus Anda masukkan ke dalam opsi kompiler (dalam file <code>tsconfig.json</code> ) jika Anda ingin mencobanya. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  Harap dicatat bahwa mekanisme ini mungkin tidak terlalu dapat diandalkan, jadi jangan menggunakannya dalam produksi.  Mungkin dia masih tidak bekerja.  Tetapi dalam waktu dekat ini akan diterima sebagai opsi default, jadi Anda harus mencobanya sekali, lihat apakah itu berfungsi di aplikasi Anda, dan apa yang Anda manfaatkan darinya. <br><br>  Mari kita bahas secara lebih rinci perbedaan Ivy dari mesin rendering yang lebih lama. <br><br>  <b>Kode yang dihasilkan oleh mesin lama</b> <br><br>  Mari kita <code>PonyComponent</code> contoh kecil: mari kita memiliki komponen <code>PonyComponent</code> yang mengambil model <code>PonyModel</code> (dengan parameter <code>name</code> dan <code>color</code> ) dan menampilkan gambar kuda poni (tergantung pada setelannya), serta nama kuda poni. <br><br>  Ini terlihat seperti ini: <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'ns-pony'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`&lt;div&gt; &lt;ns-image [src]="getPonyImageUrl()"&gt;&lt;/ns-image&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;`</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PonyComponent</span></span></span><span class="hljs-class"> </span></span>{ @Input() ponyModel: PonyModel; getPonyImageUrl() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`images/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.ponyModel.color}</span></span></span><span class="hljs-string">.png`</span></span>; } }</code> </pre> <br>  Mesin rendering yang diperkenalkan pada Angular 4 menghasilkan kelas yang disebut <code>ngfactory</code> untuk setiap templat.  Kelas biasanya berisi (kode disederhanakan): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">View_PonyComponent_0</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewDef(<span class="hljs-number"><span class="hljs-number">0</span></span>, [ elementDef(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>), elementDef(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ns-image"</span></span>, View_ImageComponent_0), directiveDef(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">49152</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, i2.ImageComponent, { <span class="hljs-attr"><span class="hljs-attr">src</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"src"</span></span>] }), elementDef(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>), elementDef(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]) ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">check, view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = view.component; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currVal_0 = component.getPonyImageUrl(); check(view, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, currVal_0); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">check, view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = view.component; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currVal_1 = component.ponyModel.name; check(view, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, currVal_1); }); }</code> </pre> <br>  Sulit dibaca, tetapi bagian utama dari kode ini dijelaskan sebagai berikut: <br><br><ul><li>  Struktur DOM yang dibuat, yang berisi definisi elemen ( <code>figure</code> , <code>img</code> , <code>figcaption</code> ), atribut dan definisi node teks.  Setiap elemen struktur DOM dalam array definisi tampilan diwakili oleh indeksnya sendiri. </li><li>  Ubah fungsi deteksi;  kode yang terkandung di dalamnya memeriksa untuk melihat apakah ekspresi yang digunakan dalam templat menghasilkan nilai yang sama seperti sebelumnya.  Di sini, hasil dari metode <code>getPonyImageUrl</code> dan, jika berubah, nilai input untuk komponen gambar diperbarui.  Hal yang sama berlaku untuk nama panggilan pony: jika berubah, simpul teks yang berisi nama panggilan ini akan diperbarui. </li></ul><br>  <b>Ivy menghasilkan kode</b> <br><br>  Jika kita bekerja dengan Angular 6, dan flag <code>enableIvy</code> disetel ke <code>true</code> , maka pabrik terpisah tidak akan dihasilkan dalam contoh yang sama;  Informasi akan tertanam langsung ke bidang statis komponen itu sendiri (kode yang disederhanakan): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PonyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = defineComponent({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: PonyComponent, <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: [[<span class="hljs-string"><span class="hljs-string">'ns-pony'</span></span>]], <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PonyComponent(), <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag, component</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag &amp; RenderFlags.Create</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'figure'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'ns-image'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'div'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag &amp; RenderFlags.Update</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">property</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'src'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, component.getPonyImageUrl(</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolate(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, component.ponyModel.name, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">)); } }, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputs</span></span></span><span class="hljs-function">: { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ponyModel</span></span></span><span class="hljs-function">: '</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ponyModel</span></span></span><span class="hljs-function">' }, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">directives</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> [ImageComponent]; }); <span class="hljs-comment"><span class="hljs-comment">// ...   }</span></span></code> </pre> <br>  Sekarang semuanya terkandung dalam bidang statis ini.  Atribut <code>template</code> berisi yang setara dengan <code>ngfactory</code> sudah <code>ngfactory</code> , dengan struktur yang sedikit berbeda.  Fungsi <code>template</code> , seperti sebelumnya, akan diluncurkan pada setiap perubahan, tetapi sekarang ia memiliki dua mode: <br><br><ul><li>  Mode kreasi: komponen baru saja dibuat, ini berisi node DOM statis yang perlu dibuat </li><li>  Sisa fungsi dijalankan dengan setiap perubahan (jika perlu, memperbarui sumber gambar dan simpul teks). </li></ul><br>  <b>Apa yang berubah?</b> <br><br>  Sekarang semua dekorator dibangun langsung ke dalam kelas mereka (sama untuk <code>@Injectable</code> , <code>@Pipe</code> , <code>@Directive</code> ), dan untuk menghasilkannya Anda hanya perlu tahu tentang dekorator saat ini.  Fenomena ini disebut oleh tim Angular sebagai "prinsip lokalitas": untuk mengkompilasi ulang komponen, Anda tidak perlu menganalisis ulang aplikasi. <br><br>  Kode yang dihasilkan sedikit berkurang, tetapi yang lebih penting, adalah mungkin untuk menghilangkan sejumlah dependensi, sehingga mempercepat kompilasi ulang jika salah satu bagian dari aplikasi berubah.  Selain itu, dengan kolektor modern, misalnya, Webpack, semuanya ternyata jauh lebih cantik: kode non-fungsional terputus dengan aman, bagian-bagian kerangka kerja yang tidak Anda gunakan.  Misalnya, jika Anda tidak memiliki saluran dalam aplikasi, maka kerangka kerja yang diperlukan untuk interpretasinya bahkan tidak termasuk dalam set terakhir. <br><br>  Kami terbiasa membuat kode Angular berat.  Kadang tidak menakutkan, tetapi Hello World dengan berat 37 kb setelah minifikasi dan kompresi terlalu banyak.  Ketika Ivy bertanggung jawab untuk menghasilkan kode, kode non-fungsional terputus jauh lebih efisien.  Sekarang Hello World setelah minifikasi dikompresi menjadi 7,3 kb, dan setelah kompresi - hanya 2,7 kb, dan ini adalah perbedaan besar.  Aplikasi TodoMVC setelah kompresi - hanya 12,2 kb.  Ini adalah data dari tim Angular, dan yang lain tidak bisa bekerja bersama kami, karena untuk Ivy bekerja seperti yang dijelaskan di sini, Anda masih perlu menambalnya secara manual. <br><br>  Untuk lebih jelasnya, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembicaraan</a> ini dengan ng-conf. <br><br>  <b>Kompatibilitas dengan perpustakaan yang ada</b> <br><br>  Anda mungkin tertarik pada: apa yang akan terjadi pada perpustakaan yang sudah diterbitkan dalam format lama jika Ivy digunakan dalam proyek Anda?  Jangan khawatir: mesin akan membuat versi dependensi proyek Anda yang kompatibel dengan Ivy, bahkan jika mereka dikompilasi tanpa Ivy.  Saya tidak akan mengekspos interior sekarang, tetapi semua detail harus transparan. <br><br>  <i><b>Fitur baru</b></i> <br><br>  Mari kita pertimbangkan peluang baru apa yang akan kita miliki ketika bekerja dengan mesin layar ini. <br><br>  <i>Properti pribadi di templat</i> <br><br>  Mesin baru menambahkan fitur baru atau perubahan potensial. <br>  Situasi ini terkait langsung dengan fakta bahwa fungsi templat tertanam dalam bidang statis komponen: sekarang kita dapat menggunakan properti pribadi komponen kita di templat.  Ini sebelumnya tidak mungkin, karena itu kami dipaksa untuk mempublikasikan semua bidang dan metode komponen yang digunakan dalam templat, dan mereka jatuh ke kelas yang terpisah ( <code>ngfactory</code> ).  Saat mengakses properti pribadi dari kelas lain, kompilasi TypeScript akan gagal.  Sekarang sudah ada di masa lalu: karena fungsi templat berada di bidang statis, ia memiliki akses ke properti pribadi komponen. <br><br>  Saya melihat komentar dari anggota tim Angular tentang fakta bahwa tidak disarankan untuk menggunakan properti pribadi dalam templat, meskipun sekarang mungkin - karena mungkin dilarang lagi di masa depan ... karena itu, mungkin lebih bijaksana untuk terus menggunakan hanya bidang publik dalam templat!  Bagaimanapun, penulisan unit test sekarang lebih mudah, karena tes dapat memeriksa keadaan komponen tanpa membuat dan memeriksa DOM untuk ini. <br><br>  <i>i18n saat runtime</i> <br><br>  Harap dicatat: mesin rendering baru akhirnya membuka peluang yang sudah lama ditunggu-tunggu bagi kami dan memberikan "i18n saat runtime".  Pada saat penulisan, dia masih belum siap, tetapi kami melihat beberapa komitmen sekaligus, dan ini adalah pertanda baik! <br>  Yang keren adalah Anda tidak perlu banyak mengubah aplikasi jika Anda sudah bekerja dengan i18n.  Tetapi sekarang Anda tidak perlu membangun kembali aplikasi untuk setiap lokal yang Anda rencanakan untuk dukung - cukup unggah JSON dengan terjemahan untuk setiap lokal, dan Angular akan mengurus sisanya! <br><br>  <i>Perpustakaan AoT</i> <br><br>  Saat ini, perpustakaan yang dirilis di NPM harus menerbitkan file metadata.json dan tidak dapat menerbitkan kode AoT dari komponen-komponennya.  Ini menyedihkan, karena biaya yang terkait dengan perakitan seperti itu diteruskan ke aplikasi kita.  Dengan Ivy, tidak perlu untuk file metadata, dan penulis perpustakaan sekarang akan dapat mempublikasikan kode AoT mereka langsung ke NPM! <br><br>  <i>Track stack yang ditingkatkan</i> <br><br>  Sekarang kode yang dihasilkan harus memberikan jejak tumpukan ditingkatkan, jika Anda mendapatkan masalah dengan template Anda - menghasilkan kesalahan rapi yang menunjukkan garis templat di mana itu terjadi.  Anda bahkan dapat mengatur breakpoint di templat dan melacak apa yang sebenarnya terjadi di Angular. <br><br>  <i><code>NgModule</code> menghilang?</i> <br><br>  Ini masih merupakan prospek yang jauh, tetapi mungkin di masa depan akan mungkin dilakukan tanpa NgModules.  Tanda-tanda pertama dari perubahan tersebut adalah penyedia pohon-goyang, dan logis untuk mengasumsikan bahwa Ivy memiliki semua blok dasar yang diperlukan bagi mereka yang siap untuk secara bertahap meninggalkan NgModules (atau, setidaknya, membuat mereka kurang responsif).  Benar, semua ini masih di masa depan, kita akan bersabar. <br><br>  Tidak akan ada banyak fitur baru dalam rilis ini, tetapi Ivy jelas menarik untuk masa depan.  Percobaan dengan itu - Saya ingin tahu bagaimana Anda akan menyukainya! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419389/">https://habr.com/ru/post/id419389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419379/index.html">Mengapa Tesla dan Deutsche Bank menolak kontrak kertas</a></li>
<li><a href="../id419381/index.html">Bagaimana orang-orang dari Storyline kembali dari Silicon Valley ke Minsk dengan $ 770 ribu untuk sebuah startup</a></li>
<li><a href="../id419383/index.html">Teknik serangan WPA2 baru yang tidak memerlukan klien di AP</a></li>
<li><a href="../id419385/index.html">Operasi jantung: bagaimana kami menulis ulang komponen utama sistem DLP</a></li>
<li><a href="../id419387/index.html">Kerentanan dari OWASP Top 10. A1: 2017 - Suntikan (Bagian 1)</a></li>
<li><a href="../id419391/index.html">Kekuasaan, uang, dan sumber terbuka. Memberitahu cara kerja komunitas dengan Apache Ignite</a></li>
<li><a href="../id419393/index.html">Buat gateway API sederhana di ASP.NET Core</a></li>
<li><a href="../id419395/index.html">Penjelasan ekspresi lambda</a></li>
<li><a href="../id419397/index.html">Bagaimana kami membuat aplikasi seluler untuk enam negara</a></li>
<li><a href="../id419399/index.html">OpenAI Five mengalahkan tim orang dalam pertandingan pertunjukkan Dota 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>