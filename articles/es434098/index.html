<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥒 🧑🏿‍🤝‍🧑🏼 🐵 Post y preprocesamiento CSS 🧐 💇🏿 👇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola lector En su camino a aprender diseños, ¿ha aprendido CSS y quiere seguir adelante? Luego a ti debajo del gato. Precaución, mucho código. 

 En e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Post y preprocesamiento CSS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434098/">  Hola lector  En su camino a aprender diseños, ¿ha aprendido CSS y quiere seguir adelante?  Luego a ti debajo del gato.  Precaución, mucho código. <a name="habracut"></a><br><br>  En este artículo, revisaré los preprocesadores y postprocesadores. <br><br>  No entraré en detalles sobre CSS, lo que implica que ya lo sabes.  Voy a nombrar clases en notación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BEM</a> .  Además, no profundizaré en la instalación y configuración de todo lo que escribo, pero dejaré enlaces que puede seguir y aprenderé cómo hacerlo usted mismo. <br><br>  Comencemos con los preprocesadores. <br><br><h2>  Preprocesadores </h2><br>  ¿Qué es un preprocesador fuera de contexto con CSS?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vicki</a> sabe la respuesta. <br><br>  ¿Qué es un preprocesador en el contexto de CSS?  En nuestro caso, el preprocesador es un programa que recibe el código escrito en el lenguaje del preprocesador como entrada, y en la salida obtenemos CSS que podemos dar entrada a nuestro navegador. <br><br>  ¿Qué son los preprocesadores?  Hay varios representantes, por ejemplo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sass</a> (.sass, .scss), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Less</a> (.less) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Stylys</a> (.stylus). <br>  También entre los preprocesadores, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PostCSS</a> (o más bien su analizador SugarSS y el complemento PreCSS) se pueden identificar por separado.  Mirando hacia el futuro, diré que sí, PostCSS no es solo un postprocesador. <br><br>  Haré una revisión sobre el ejemplo de Sass.  Más precisamente, en su nueva sintaxis: SCSS, ya que está más cerca de CSS que la sintaxis anterior.  Comencemos con las capacidades que agregan los preprocesadores que no están en CSS, y terminemos con los problemas que se están resolviendo. <br><br><h3>  Las posibilidades </h3><br><h4>  Variables </h4><br><pre><code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-id"><span class="hljs-selector-id">#fff</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: $color; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: $color; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span>; }</code> </pre> <br>  La utilidad de las variables es difícil de sobreestimar.  Ahora puede dar nombres significativos a los colores ($ tomate: rgb (255,99,71)), calcular valores no a través de constantes, sino a través de variables (altura: $ body_height - $ footer_height) y mucho más.  Muchos pueden argumentar que hay variables en CSS.  Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Can I Use</a> dice que no hay soporte para IE (y por razones obvias, no se espera). <br><br><h4>  Anidamiento </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">40%</span></span>; &amp;__button { // &amp; -    (   &amp; = .chat-area) <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: inline-block; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>:<span class="hljs-number"><span class="hljs-number">36px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">40%</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area__button</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: inline-block; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>:<span class="hljs-number"><span class="hljs-number">36px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  Al comienzo del artículo, me referí a BEM.  En este ejemplo, el elemento con la clase de área de chat es un bloque.  En caso de que haya una necesidad repentina de cambiarle el nombre, ahora será posible hacerlo en un solo lugar, y esto se convierte en una rutina si se escriben varias docenas de selectores en un archivo que contiene el nombre del bloque.  También quiero señalar que este es un tipo de protección contra errores tipográficos, porque el nombre del bloque se escribe una vez. <br><br><h4>  Mixins </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">mixin</span></span> border-radius($radius) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">-webkit-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-moz-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ms-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { @include border-radius(10px); } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-webkit-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">-moz-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">-ms-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; }</code> </pre><br>  Los mixins son uno de los temas más difíciles de entender.  En términos generales, un mixin es una función que toma argumentos y aplica reglas que dependen de esos argumentos a un selector dado.  En este ejemplo, la mezcla de borde y radio se aplicó al selector .box <br><br><h4>  Funciones adicionales </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-id"><span class="hljs-selector-id">#202020</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">h1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">h2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">lighten</span></span>($color, 40%); } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">h1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">h2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#868686</span></span>; }</code> </pre><br>  Básicamente, las nuevas funciones facilitan el trabajo con el color.  Por ejemplo, la función aclarar: aclara el color en la cantidad especificada de porcentaje (lo opuesto es la función oscurecer). <br><br><h3>  Problemas resueltos </h3><br><h4>  Modularidad </h4><br>  El problema con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">importación</a> estándar es que crea una solicitud adicional al servidor, que es una operación costosa.  Sería bueno si la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">importación</a> insertara inmediatamente todo el texto de la importación en el archivo fuente, ¿verdad? <br><br>  De una forma u otra, no había preprocesadores antes, y el problema tenía que resolverse de alguna manera.  Por ejemplo, puede escribir todo el código en un archivo. <br><br><div class="spoiler">  <b class="spoiler_title">Como se ve</b> <div class="spoiler_text"><pre> <code class="css hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Cómo se ve realmente</b> <div class="spoiler_text"><pre> <code class="css hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  -  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span></code> </pre><br></div></div><br></div></div><br>  Sin embargo, tenemos preprocesadores y resolverán este problema por nosotros.  El preprocesador anula la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">importación</a> estándar y ahora, en lugar de preguntar por el servidor, inserta la importación en el archivo de origen, tal como yo quería. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"selector1"</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"selector2"</span></span>; //<span class="hljs-selector-tag"><span class="hljs-selector-tag">selector1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">selector2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; }</code> </pre><br>  Tenga en cuenta que los archivos de origen se convirtieron en uno.  Una solicitud al servidor de estadísticas: una respuesta. <br><br><h4>  Herencia </h4><br>  &lt;sarcasm&gt; Tenemos clases, pero no herencia, ¿cómo? &lt;/sarcasm&gt;.  Ahora es posible seleccionar los llamados "selectores de plantilla" y expandirlos con otros selectores. <br><br><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> %<span class="hljs-selector-tag"><span class="hljs-selector-tag">equal-heights</span></span> { //   <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; } %<span class="hljs-selector-tag"><span class="hljs-selector-tag">message</span></span> { //   <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span> { @extend %message; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { @extend %message; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } // <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span>, <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  La belleza de los selectores de plantillas es que no encajan en los estilos generados.  El ecualizador de plantilla% equal-heights no estuvo involucrado en el código y no dejó ningún rastro en CSS.  El mensaje selector% se reflejó en forma de reglas para los selectores que lo expandieron.  Puede heredar de selectores comunes, pero es preferible usar selectores de plantilla para que no haya exceso de basura. <br><br><h4>  Formateo </h4><br>  Después de escribir el código, debe formatearse (comprimido para producción).  Puede hacerlo con la ayuda de coleccionistas como webpack, o puede hacerlo a través de herramientas estándar. <br><br>  Hay 4 tipos de formato en Sass. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">expanded</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">nested</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">compact</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">compressed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:gold;<span class="hljs-attribute"><span class="hljs-attribute">display</span></span>:block}<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:red}</code> </pre><br>  expandido: más similar al código escrito por humanos. <br>  anidado: aproximado al formato de la sintaxis anterior.  La legibilidad no se pierde, pero es un problema de Hollywood. <br>  compacto: aún mantiene la legibilidad, pero con dificultad.  Útil para determinar el número de selectores en un proyecto a simple vista. <br>  comprimido - Formato ya completamente ilegible.  Todos los caracteres que se pueden eliminar se eliminan.  Adecuado para alimentar el navegador. <br><br><h3>  Postdata </h3><br>  No entendí algunas de las características agregadas por Sass.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bucles</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">características de operadores aritméticos</a> .  Los dejaré para que te familiarices. <br><br><h2>  Postprocesadores </h2><br>  Habiendo tratado con preprocesadores, pasamos a postprocesadores. <br><br>  En el contexto de Css, el postprocesador es esencialmente el mismo que el preprocesador, pero la entrada al postprocesador no recibe un código escrito en el lenguaje del preprocesador, sino también css.  Es decir, el postprocesador es un programa en la entrada de la cual se da css, y la salida es css.  No está muy claro por qué esto es necesario. <br><br>  Explicaré un ejemplo concreto del funcionamiento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PostCSS</a> , el único representante de los posprocesadores en el contexto de css. <br><br>  PostCSS listo para usar realmente no hace nada con CSS.  Simplemente devuelve el archivo que se le dio en la entrada.  Los cambios comienzan cuando los complementos están conectados a PostCSS. <br><br>  El ciclo completo de PostCSS se puede describir de la siguiente manera: <br><br><ul><li>  El archivo fuente se entrega a la entrada PostCSS y se analiza. </li><li>  El complemento 1 hace algo </li><li>  ... </li><li>  El complemento n hace algo </li><li>  El resultado se convierte en una cadena y se escribe en el archivo de salida. </li></ul><br>  Considere los principales complementos que existen en el ecosistema PostCSS <br><br><h3>  Complementos </h3><br><h4>  Autoprefixer </h4><br>  Este complemento es tan popular que muchas personas piensan que usan este complemento pero no usan PostCSS.  Están equivocados <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -webkit-box; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -webkit-flex; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -moz-box; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -ms-flexbox; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Autoprefixer</a> agrega prefijos de navegador a sus reglas.  Uno de los complementos más importantes que comenzó la historia de PostCSS sin nada reemplazable.  Incluso podría decir que tiene sentido poner PostCss solo por el bien de este complemento. <br><br><h2>  Env preestablecido </h2><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">custom</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> --med (width &lt;= <span class="hljs-number"><span class="hljs-number">50rem</span></span>); @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (--med) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:hover</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">color-mod</span></span>(black alpha(54%)); } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (max-width: <span class="hljs-number"><span class="hljs-number">50rem</span></span>) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:hover</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgba</span></span>(0, 0, 0, 0.54); } }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PostCSS Preset Env</a> agrega características que solo se discuten en borradores preliminares de desarrolladores CSS.  En este ejemplo, se implementó la directiva @ custom-media, así como la función de mod de color.  ¡Comience a usar el CSS del futuro hoy! <br><br><h4>  Módulos CSS </h4><br>  Todos estos BEM no son para usted, pero ¿hay algún problema con los conflictos de nombres de clase?  Entonces PostCSS ofrece una solución diferente. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.name</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gray; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.Logo__name__SVK0g</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gray; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los Módulos CSS</a> cambian los nombres de las clases de acuerdo con cierto patrón (todo es personalizable).  Ahora no sabemos de antemano el nombre de la clase, porque se determina dinámicamente.  ¿Cómo ahora clasificar los elementos si no los conocemos de antemano?  Combinando PostCSS, Webpack y ES6 puedo ofrecer esta solución: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./style.css'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  import styles from './style.css'; // </span></span></code> </pre><br>  Ahora no solo estamos importando un archivo con estilos (por ejemplo, en el archivo React de un componente) y sustituyendo valores que conocemos antes, sino importando un objeto.  Las claves de este objeto serán los selectores originales, y los valores se convertirán.  Es decir, en este ejemplo, styles ['name'] = 'Logo__name__SVK0g'. <br><br><h4>  Corto </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">size</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.canvas</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#abccfc</span></span> <span class="hljs-number"><span class="hljs-number">#212231</span></span>; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.canvas</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#abccfc</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: <span class="hljs-number"><span class="hljs-number">#212231</span></span>; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PostCSS Short</a> agrega un montón de entradas acortadas para varias reglas.  El código se está acortando y, por lo tanto, hay menos espacio para errores.  Además aumenta la legibilidad. <br><br><h4>  Reinicio automático </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">all</span></span>: initial; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PostCSS Auto Reset</a> nos permite no crear un archivo separado con un reinicio de todos los estilos.  El complemento crea un selector grande para todos los selectores, donde coloca las reglas y restablece todos los estilos.  Por defecto, solo la regla all se crea con el valor inicial.  Esto es útil en combinación con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento postcss-initial</a> , que a su vez convierte esta regla en una bolsa de reglas para 4 pantallas.  Sin embargo, todo se puede configurar y restablecer, por ejemplo, de esta manera: <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; }</code> </pre><br>  ¿Recuerdas que al principio del artículo dije que PostCSS no es solo un postprocesador? <br><br><h3>  PostCSS - preprocesador? </h3><br>  Considere un analizador y un complemento, después de lo cual cambiará su opinión actual sobre PostCSS. <br><br><h4>  Sugararss </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sss</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">white</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> &gt; <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white } <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> &gt; <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SugarSS</a> es un analizador sintáctico (no un complemento), que se basa en la <u>sangría</u> , y no en llaves, como estándar.  Tiene una extensión separada ".sss".  El código escrito usando SugarSS es similar en estilo a la sintaxis Sass anterior, pero sin sus lociones como variables, mixins, herencia, etc. <br><br>  ¿Adivinaste qué agregará el próximo complemento? <br><br><h4>  Precss </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span> //  <span class="hljs-selector-tag"><span class="hljs-selector-tag">SugarSS</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span>; <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { .child { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: $color } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PreCSS</a> simplemente agrega las capacidades de los preprocesadores que se escriben en la primera mitad del artículo. <br><br>  ¿Y por qué PostCSS no es un preprocesador ahora? <br><br><h3>  Pelusa </h3><br>  Ya se ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrito mucho</a> sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Stylelint</a> .  Se metió en esta revisión porque usa PostCSS como un analizador de líneas de archivos CSS.  Supongamos que tenemos un archivo así. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>(1, 1, 1) } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>(0, 0, 0) }</code> </pre><br>  Aquí está su salida para el archivo actual: <br><br><pre> <code class="plaintext hljs"> 2:21 Expected a trailing semicolon declaration-block-trailing-semicolon 6:21 Expected a trailing semicolon declaration-block-trailing-semicolon 7:1 Unexpected missing end-of-source newline no-missing-end-of-source-newline</code> </pre><br>  La utilidad de esta herramienta es bastante difícil de sobreestimar. <br><br><h2>  Conclusiones </h2><br>  Los preprocesadores agregan muchas funcionalidades nuevas que no están en CSS.  Una vez que lo intentes, difícilmente volverás a CSS normal. <br><br>  PostCSS está mucho más cerca del CSS original que los preprocesadores, pero sin embargo, con ciertos complementos conectados, puede tener la misma funcionalidad (e incluso una sintaxis similar).  Los principiantes pueden componer sin siquiera pensar que los diseños no están en CSS puro.  Algunos complementos (por ejemplo, Autoprefixer) no tienen análogos en el mundo de los preprocesadores. <br><br>  Nadie se molesta en usar preprocesadores y PostCSS en conjunto.  La opción es bastante buena para proyectos que ya usan preprocesadores y tienen una vivienda. <br><br>  Para nuevos proyectos, recomendaría usar solo PostCSS.  Los diseñadores de diseño están acostumbrados a la sintaxis del preprocesador?  Instale el complemento PreCSS y el analizador SugarSS.  ¿Necesita compatibilidad entre navegadores?  Instale el complemento Autoprefixer.  ¿Ya no es necesaria la compatibilidad entre navegadores (por ejemplo, su proyecto fue envuelto en un electrón y se convirtió en escritorio)?  ¡Simplemente desinstale Autoprefixer!  Con PostCSS, puede, como con el constructor, construir exactamente lo que su proyecto necesita. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434098/">https://habr.com/ru/post/es434098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434086/index.html">Implementación integrada de Windows y Linux</a></li>
<li><a href="../es434088/index.html">Cómo ayudar a los empleados remotos a evitar la soledad y el agotamiento</a></li>
<li><a href="../es434090/index.html">Presentación de un transistor de vacío: un dispositivo hecho del vacío</a></li>
<li><a href="../es434092/index.html">Las personas que salvaron 1968</a></li>
<li><a href="../es434096/index.html">Heisenbug 2018 Moscú: una vista de la multitud</a></li>
<li><a href="../es434100/index.html">Descripción general de la impresora 3D Anet A6 y Anet A8</a></li>
<li><a href="../es434102/index.html">Animación bella e informativa: casos de movimiento circular y vibraciones.</a></li>
<li><a href="../es434104/index.html">Tierra VHF o desmitificación de antenas cuadradas dobles / triples</a></li>
<li><a href="../es434106/index.html">Confíe en los SDK móviles</a></li>
<li><a href="../es434110/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 344 (17-23 de diciembre de 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>