<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦖 🧑🏻‍🤝‍🧑🏻 🛂 uMCPIno: Écriture d'un protocole simple avec livraison garantie pour Arduino 👨🏿‍🍳 🧑🏽‍🤝‍🧑🏻 👩🏼‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salutations, chers amis! 
 À un certain stade de leur vie, chaque boîte de bricolage tenace et tenace cesse de manquer le Kantian Arduino en tant que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>uMCPIno: Écriture d'un protocole simple avec livraison garantie pour Arduino</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480110/"><h3>  Salutations, chers amis! </h3><br>  À un certain stade de leur vie, chaque boîte de bricolage tenace et tenace cesse de manquer le Kantian Arduino en tant que «choses en soi» <s>qu'ils ne peuvent tout simplement pas!</s>  : Faire clignoter la LED, prendre les données des capteurs et les transférer sur le fil vers le PC est certes amusant, mais le Saint Graal est en mobilité, en libération des «liens de cuivre», en véritable liberté parmi les vagues d'éther universel. <br>  C'est là que la dure réalité des canaux de communication instables, des erreurs de transmission, des messages non livrés s'ouvre pour nous. <br>  Dieu ne plaise à revendiquer l'originalité dans ce domaine: l'humanité a longtemps utilisé tout un tas de protocoles pour toutes les occasions. <br>  Mais notre objectif est d'apprendre, et comme je suis un ardent partisan de la reconnaissance au combat, nous étudierons en inventant notre propre protocole «vélo». <br>  Aujourd'hui, je propose de développer un protocole qui garantit la livraison, l'intégrité et la séquence des messages entre deux abonnés (point à point, point à point), sache comment et applique l'algorithme <a href="https://en.wikipedia.org/wiki/Nagle%2527s_algorithm" rel="nofollow">Nagle</a> et le <a href="https://en.wikipedia.org/wiki/Protocol_pipelining" rel="nofollow">pipelining du protocole</a> , quoi que cela signifie.  Dans le même temps, il devrait avoir une <a href="https://en.wikipedia.org/wiki/Overhead_(computing)" rel="nofollow">surcharge</a> minimale et se faufiler jusque dans l'Arduino UNO exigu. <br><br><img src="https://habrastorage.org/webt/jt/7a/_b/jt7a_bc6uynr5uu08ab3plyuucq.png"><br><br>  Je demande à tous ceux qui sont intéressés à bord, on ferme les écoutilles, on ouvre les pierres de taille, on remplit les ballasts.  Nous avons une excursion dans le passé, destination: année 1974! <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Pour les impatients (je le suis moi-même!)</b> <div class="spoiler_text">  Voici le référentiel github où les implémentations sont: <br><ul><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/Arduino" rel="nofollow">Pour Arduino</a> </li><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/STM32" rel="nofollow">Pour STM32</a> </li><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/CSharp" rel="nofollow">Pour PC (C #)</a> </li></ul><br></div></div><br>  Selon la bonne vieille tradition, au moins deux experts reconnus dans ce domaine sont impliqués dans la description des algorithmes et protocoles cryptographiques, si quelqu'un d'autre ne les connaît pas, faites connaissance: <br><div class="spoiler">  <b class="spoiler_title">Alice</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/fb4/6f4/f08/fb46f4f081e1affbfba68c39dcbc7768.jpg" alt="image"><br></div></div><br>  Et <br><div class="spoiler">  <b class="spoiler_title">Bob</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/048/a75/668/048a75668215c8147df3f5720f283899.jpg" alt="image"><br></div></div><br><br><h3>  Nous décrivons d'abord une tâche simple </h3><br>  Alice et Bob sont assis dans des tranchées adjacentes et ne peuvent pas lever la tête pour se voir.  Ils ne peuvent parler que par la voix, à côté d'eux des balles sifflent et des obus éclatent, noyant leurs cris, et en plus, quand l'un d'eux parle, vous devez crier pour ne rien entendre du tout. <br>  La situation est compliquée par le fait qu'ils sont entendus par des ennemis - et vous devez utiliser un langage de code, pour une raison quelconque composé de longues séquences de nombres. <br>  Étant donné qu'Alice et Bob sont des gens, ils doivent périodiquement sortir manger ou aller aux toilettes, et ils sont tellement impatients qu'ils peuvent l'être au moment le plus inopportun! <br><br><h3>  Comment et pourquoi établir une connexion? </h3><br>  Comment organiser un transfert de données fiable dans une situation aussi déprimante, alors qu'il semblerait que tout soit simplement voué à l'échec? <br><br>  La première solution qui peut vous venir à l'esprit est d'utiliser des phrases codées en mots vides pour démarrer et terminer le transfert. <br><br>  Eh bien, disons que si Alice veut envoyer un message, alors elle doit crier «Commencer la transmission!» Et attendre que Bob réponde «Commencer la réception!». <br>  Si Alice n'attend pas la réponse de Bob, elle répète simplement sa demande pour commencer le transfert.  Naturellement, vous ne devriez pas le faire trop souvent, sinon, comme nous le savons, vous n’entendez simplement pas la réponse de Bob. <br><br>  Super.  Mais que se passe-t-il si Alice en réponse entend de la prochaine tranchée, "Commencer la transmission!"? <br>  Il s'avère que Bob a également décidé de transférer des informations importantes dès maintenant.  Alice a un caractère doux, et elle aurait pu penser: "D'accord, je vais attendre, mon message n'est, en principe, pas urgent, laissez Bob le transmettre en premier."  Pensant à cela, elle répond: "Commencez la réception!". <br><br>  Comme <s>en temps de guerre, la valeur du sinus peut atteindre quatre, la</s> vitesse du son est finie, et il faut un certain temps pour comprendre ce qu'Alice et Bob ont entendu, et même Bob, en tant que gentleman, peut décider de céder à la dame, il hausse les épaules et crie «Je commence à recevoir!» ... <br><br>  Pour illustrer l'indignation, nous utiliserons des chronogrammes.  Le temps leur revient. <br><br>  Le cas où Alice et Bob n'étaient pas d'accord sur le temps: <br><img src="https://habrastorage.org/webt/cz/ye/hn/czyehnoehw9e3wnxveaiwvef5ok.png"><br><br>  Le cas où le message a été perdu: <br><img src="https://habrastorage.org/webt/5u/yk/md/5uykmdq7sxiagt-5twd3uhpnxas.png"><br><br>  Ceci est un fiasco.  Tout devient trop confus et est aggravé par le fait que le destinataire peut entendre ou ne pas entendre l'une des phrases, et dans chaque cas, l'interlocuteur ne sait pas si son message a été entendu par le destinataire. <br><br>  Maintenant, Alice et Bob attendent un accueil.  Il serait logique de réaliser qu'un conflit s'est produit et que quelqu'un doit reprendre la transmission.  Mais que se passe-t-il si tout se reproduit d'une nouvelle manière?  Et nous voici à nouveau là où nous avons commencé. <br><br>  Si vous pensez que la situation est extrêmement rare, rappelez-vous la dernière fois que vous avez parlé à quelqu'un via la voix, lorsque votre abonné ou vous (ou les deux) avez une connexion Internet lente.  "Bonjour bonjour bonjour, tu disparais."  "Tu n'entends pas bonjour bonjour." <br><br>  Pendant ce temps, dans les tranchées, la situation se réchauffe, les commandants demandent la transmission des rapports. <br>  Il est temps <s>de se tourner vers les sources primaires: pour étudier Marx, Engels</s> reviendra il y a plus de 40 ans et verra comment ces problèmes ont été résolus par <a href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation" rel="nofollow">les</a> ingénieurs <a href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation" rel="nofollow">DEC</a> lors de la conception du protocole <a href="https://en.wikipedia.org/wiki/Digital_Data_Communications_Message_Protocol" rel="nofollow">DDCMP</a> . <br><br>  Selon les développeurs de DDCMP, Alice et Bob doivent rejeter les émotions et devenir comme <a href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="nofollow">des machines à états finis</a> . <br>  Cela signifie qu'à partir de maintenant, nos Alice et Bob n'auront que quelques états fixes, les transitions entre ces états peuvent se produire strictement selon certaines règles lorsque certains événements se produisent. <br><br>  Tout d'abord, nous listons simplement les états: <br><br><ul><li>  Arrêté </li><li>  DÉBUT INITIAL </li><li>  DÉMARRAGE RECONNU </li><li>  COURIR </li></ul><br><br>  Comme vous pouvez le voir, il n'y en a que quatre.  Et maintenant, quoi qu'il arrive, chacun des abonnés sait au moins avec certitude que son vis-à-vis est dans un seul de ces états.  En fait, en regardant un peu plus loin, je dirai que presque toujours un abonné saura dans quel état se trouve le deuxième abonné, <s>mais ce n'est pas exact</s> . <br><br><h3>  Examinons les états séparément, en détail </h3><br>  <b>HALTED</b> est l'état le plus simple, personne ne va nulle part, tout le monde reste à sa place, rien n'est transmis et non reçu, les stimuli externes sont ignorés.  Tous sauf un - la volonté des autorités supérieures.  Dans le protocole DDCMP d'origine, la transition de l'état <b>HALTED</b> ne peut être dans l'état <b>INITIAL START</b> qu'à la demande de l'utilisateur - Alice ou Bob reçoivent une commande pour établir une connexion. <br><br>  Que se passe-t-il lorsque Alice ou Bob reçoivent une telle commande? <br>  Ils constatent immédiatement que l'État est passé de <b>HALTED</b> à <b>INITIAL START</b> , cette transition, comme toute autre, implique une séquence d'actions strictement définie.  Dans ce cas, vous devez crier "DO IT!" Et régler l'horloge sur l'horloge.  C’est tout. <br><br>  Alors Alice a crié ce qu'on attendait d'elle et a appuyé sur un bouton du chronomètre.  Maintenant, pour comprendre à quoi s'attendre de Bob, nous allons découvrir ce qui peut arriver à Alice lorsqu'elle est à l'état <b>DÉBUT INITIAL</b> . <br><br>  - À partir du moment où Alice a remarqué que le temps s'est écoulé, disons 10 secondes et qu'elle n'a entendu aucune réaction de Bob (remarque, je ne dis pas que Bob ne lui a rien crié - cela n'est pas connu, mais seulement qu'Alice ne sait rien entendu pendant ce temps, Alice est une femme sage et rationnelle et se fie uniquement aux faits).  Nous appelons cet événement un délai d'attente - l'intervalle d'attente a été dépassé.  Dans ce cas, le protocole nous dit de répéter: criez «FAITES-LE UNE FOIS!» Et recommencez.  Pas encore épais. <br><br>  - Si Alice a entendu que Bob a crié la même chose - "FAIRE UNE FOIS!", Alice passe alors de <b>manière non sélective</b> à l'état <b>DE DÉPART RECONNU</b> , à propos duquel elle devrait immédiatement crier "FAIRE DEUX!" Et régler à nouveau l'horloge. <br><br>  - Encore une fois, si Alice a entendu parler de Bob "FAITES DEUX!", Alors elle passe immédiatement à l'état <b>EN COURS</b> (!), Crie "ACCEPTÉ NOOOOOL!".  Si son chronomètre a été démarré, elle l'éteint par prudence. <br><br>  Il est très important de ne pas faire de mouvements inutiles qui ne sont pas prévus par l'état actuel.  Quoi que Bob pleure, peu importe comment maudire ou mendier, Alice ne réagit que comme convenu. <br><br>  Il est commode de présenter de telles choses sous la forme d'un tableau.  Commençons donc par les <b>états HALTED</b> et <b>INITIAL START</b> déjà décrits, puis nous réapprovisionnerons davantage le tableau. <br><br><div class="scrollable-table"><table><tbody><tr><th>  ÉTAT ACTUEL </th><th>  ÉVÉNEMENT <br></th><th>  NOUVELLE CONDITION </th><th>  ACTION <br></th></tr><tr><td>  N'IMPORTE QUI </td><td>  L'ordre "rompre la connexion" </td><td>  Arrêté <br></td><td></td></tr><tr><td>  Arrêté <br></td><td>  Commandez «Connect» <br></td><td>  ÉTAT INITIAL </td><td>  1) Criez «FAITES-LE UNE FOIS!» <br>  2) Démarrer la minuterie <br></td></tr><tr><td rowspan="3">  DÉBUT INITIAL <br></td><td>  J'ai entendu "FAITES-LE UNE FOIS!" <br></td><td>  DÉMARRAGE RECONNU <br></td><td>  1) Criez "FAITES DEUX!" <br>  2) Démarrer la minuterie <br></td></tr><tr><td>  J'ai entendu "FAIRE DEUX!" </td><td>  COURIR <br></td><td>  1) Criez «NOOOL ACCEPTÉ!» <br>  2) Arrêtez la minuterie <br></td></tr><tr><td>  Le temps est écoulé - timeout </td><td>  DÉBUT INITIAL <br></td><td>  1) Criez «FAITES-LE UNE FOIS!» <br>  2) Démarrer la minuterie <br></td></tr></tbody></table></div><br><br>  J'omet consciemment certains points de la description originale du DDCMP - nous n'en avons pas besoin, nous voulons non seulement répéter le DDCMP, mais construire sur sa base <s>le même, seulement un autre</s> nouveau protocole. <br><br>  Mais revenons à la description des états et des transitions.  Le prochain état est <b>ACKNOWLEDGED START</b> . <br>  Dans cet état, tout ce qui peut inquiéter Alice ou Bob est: <br><br>  - comme avant, l'expiration du temps d'attente, dans ce cas, vous devez rester dans le même état, crier "FAITES DEUX!" Et redémarrez le chronomètre <br><br>  - le «DO TWO!» entendu se traduit par l'état <b>RUNNING</b> , tout en criant «ACCEPTED NOOOOL!» Et arrête le chronomètre; <br><br>  - le "DO IT!" entendu laisse dans le même état, vous devez crier "DO TWO!" Et démarrer le chronomètre; <br><br>  - entendu «NOOOL ACCEPTED!» - transition vers l'état <b>RUNNING</b> , arrêtez la minuterie. <br><br>  Nous avons mis tout ce qui précède dans un tableau. <br><div class="scrollable-table"><table><tbody><tr><th>  ÉTAT ACTUEL </th><th>  ÉVÉNEMENT <br></th><th>  NOUVELLE CONDITION </th><th>  ACTION <br></th></tr><tr><td rowspan="4">  DÉMARRAGE RECONNU <br></td><td>  J'ai entendu "FAITES-LE UNE FOIS!" <br></td><td>  DÉMARRAGE RECONNU <br></td><td>  1) Criez "FAITES DEUX!" <br>  2) Démarrer la minuterie <br></td></tr><tr><td>  J'ai entendu "FAIRE DEUX!" </td><td>  COURIR <br></td><td>  1) Criez «NOOOL ACCEPTÉ!» <br>  2) Arrêtez la minuterie <br></td></tr><tr><td>  J'ai entendu "NOOOL ACCEPTÉ!" </td><td>  COURIR <br></td><td>  1) Arrêtez la minuterie <br></td></tr><tr><td>  Le temps est écoulé - timeout </td><td>  DÉMARRAGE RECONNU </td><td>  1) Criez "FAITES DEUX!" <br>  2) Démarrer la minuterie <br></td></tr></tbody></table></div><br><br>  Avec une poignée de main, presque tout est prêt - il ne reste à considérer qu'un seul état <b>RUNNING</b> , car l'un des abonnés peut déjà y entrer, et le second - se précipiter immédiatement aux toilettes, et quand il revient, oubliez tout et essayez d'établir une nouvelle connexion. <br><br>  Du point de vue de la procédure de prise de contact (nous ne traitons pas encore du transfert de données, pour lequel tout a commencé - c'est une histoire distincte) dans l'état <b>RUNNING</b> , nous sommes intéressés par deux événements: <br><br>  - s’ils nous crient "FAITES-LE UNE FOIS!" - tout va très mal, c’est une désynchronisation complète, il faut tout recommencer.  Le protocole d'origine vous <b>demande d'</b> entrer simplement l'état <b>HALTED</b> .  Mais cela ne nous aidera en rien - si pour une raison quelconque, cela s'est produit sur un Arduino autonome, qui transmet certaines données de certains capteurs, alors pour nous, c'est un échec complet.  Comme nous le savons, à partir de <b>HALTED,</b> vous ne pouvez accéder à <b>INITIAL START</b> que sur ordre des autorités. <br>  Par conséquent, nous <b>modifions</b> le protocole ici: la réception à l'état <b>HALTED</b> de la commande "DO ONCE!" <b>Devrait</b> fonctionner comme un ordre des autorités - c'est-à-dire  <b>passer à l'</b> état <b>DÉMARRAGE INITIAL</b> , crier «FAITES-LE UNE FOIS!», démarrez la minuterie.  De plus, dans certains cas, il est pratique de donner un ordre pour établir la communication immédiatement après vous être alimenté. <br>  Ainsi, maintenant, dans le cas le plus gênant, nous allons simplement réinitialiser la connexion. <br><br>  - le deuxième événement auquel il faut réagir à l'état <b>COURANT</b> - si nous entendons «FAIRE DEUX!» D'une tranchée voisine.  C'est déjà plus intéressant.  Dans ce cas, vous devez crier «ER ACCEPTÉ!» Où, par ER, on entend le nombre de messages reçus avec succès dans la session de communication en cours.  Ceci est un nouveau concept.  Ci-dessous, nous examinerons tout plus en détail, mais pour le moment, nous allons mettre tout ce que nous avons appris à l'heure actuelle dans un tableau: <br><br><div class="scrollable-table"><table><tbody><tr><th>  ÉTAT ACTUEL </th><th>  ÉVÉNEMENT <br></th><th>  NOUVELLE CONDITION </th><th>  ACTION <br></th></tr><tr><td rowspan="4">  DÉMARRAGE RECONNU <br></td><td>  J'ai entendu "FAITES-LE UNE FOIS!" <br></td><td>  DÉMARRAGE RECONNU <br></td><td>  1) Criez "FAITES DEUX!" <br>  2) Démarrer la minuterie <br></td></tr><tr><td>  J'ai entendu "FAIRE DEUX!" </td><td>  COURIR <br></td><td>  1) Criez «NOOOL ACCEPTÉ!» <br>  2) Arrêtez la minuterie <br></td></tr><tr><td>  J'ai entendu "NOOOL ACCEPTÉ!" </td><td>  COURIR <br></td><td>  1) Arrêtez la minuterie <br></td></tr><tr><td>  Le temps est écoulé - timeout </td><td>  DÉMARRAGE RECONNU </td><td>  1) Criez "FAITES DEUX!" <br>  2) Démarrer la minuterie <br></td></tr></tbody></table></div><br><br>  Maintenant, si Alice et Bob suivent strictement le protocole, ils n'ont tout simplement pas d'options <s>pour entrer dans</s> quelque chose d' <s>incompréhensible</s> , sauf comment établir une connexion, passer conjointement à l'état <b>RUNNING</b> ou, dans un mauvais cas, essayer de l'établir avant de <s>cliquer sur</s> la victoire. <br><br>  Un lecteur agressif peut essayer de trier toutes les options et arriver à la conclusion que la série d'états et de transitions s'avère être fermée et strictement déterminée.  Nous (avec l'aide des esprits des ingénieurs de DEC) avons maintenant lié Alice et Bob à un ensemble de règles qui, simplement, après quoi ils établiront une connexion, si dans les conditions actuelles cela est généralement possible en principe. <br><br><h3>  Comment transférer des données maintenant? </h3><br>  D'accord, c'était un bon entraînement.  Période de bouquet de bonbons dans la relation de deux nœuds de réseau.  Rappelons que nous avons démarré une entreprise: nous devons transférer des données avec une livraison garantie et prioritaire!  Avec reprise après sinistre.  Dans la mesure où les ressources matérielles le permettent (après tout, Alice et Bob peuvent s'avérer être de faibles contrôleurs 8 bits avec 2 kilo-octets de RAM!). <br><br>  Les ingénieurs DEC nous apprennent que les messages dont nous avons besoin pour numéroter, nous devons compter combien nous avons envoyé, combien nous avons reçu et combien de messages que nous avons envoyés ont atteint le destinataire. <br><br><div class="spoiler">  <b class="spoiler_title">Il est temps de faire une digression!</b> <div class="spoiler_text">  Admettez-le.  quand j'ai vu les noms des variables dans la description du protocole DDCMP, j'ai décidé que ce n'était pas un hasard: les Américains aiment beaucoup attirer de belles abréviations par leurs oreilles. <br><br>  Pour notre commodité, il existe même plusieurs ressources où les personnes intéressées peuvent toucher la beauté. <br>  Mon préféré est celui-ci - <a href="https://www.cfa.harvard.edu/~gpetitpas/Links/Astroacro.html" rel="nofollow">Site d'acronymes astronomiques stupides ou trop forcés (ou DOOFAAS)</a> <br><br>  Que valent ces fabrications! <br>  Voici un exemple: <br><br>  <b>WASP</b> - Spectromètre analogique à large bande (mais pas du tout ce que vous pensiez!) <br>  <b>SAURON</b> - Unité <b>surfacique</b> spectroscopique pour la recherche sur les nébuleuses optiques <br>  <b>CISCO</b> - Spectrographe infrarouge refroidi et caméra pour SST (c'est donc ce que cela signifie!) <br><br>  Et ici, il suffit de tirer: <br>  <b>SQUIRT</b> (oh oui, article 18+!) - Satettile QUick Research Testbed <br>  <b>MERDE</b> (Ni plus ni moins!) - Télescope interférométrique super énorme, avec l'inscription «regarde par toi-même», auquel le lien vers le résumé est attaché à l'article du même nom. <br><br>  Ainsi, les variables indiquant le nombre de paquets reçus, envoyés et livrés sur le nœud dans la description originale du protocole sont appelées <b>ARN</b> . <br><br>  Ah, pourquoi n'ont-ils pas nommé le protocole de cette façon - l'ARN!  Une sorte de réseau d'ARN.  Les protocoles DECnet avaient toutes les chances de devenir des protocoles Internet si l'histoire avait tourné différemment. <br></div></div><br><br><h3>  Mais revenons à nos tranchées </h3><br>  La norme de protocole d'origine définit que tous les compteurs sont à 8 bits et incrémentent le module 256. Cela signifie qu'il peut y avoir un maximum de 256 messages envoyés pour lesquels aucune confirmation n'a encore été reçue. <br>  Et si la confirmation n'est pas reçue, alors ils peuvent avoir besoin d'être retransmis, et si cela peut être requis, alors ils doivent être stockés jusqu'à la confirmation.  Après tout, nous avons garanti la livraison! <br><br>  Les paramètres physiques de nos Alice et Bob nous dictent des conditions différentes.  Dans Arduino 8 bits, cette quantité de données est simplement nulle part où stocker et nous devons faire des compromis.  Et je ne parle pas du fait que dans la norme, la longueur des paquets (messages) en octets est limitée à un nombre de 16 bits, c'est-à-dire  64 kilo-octets est un luxe inadmissible! <br><br><h3>  Ainsi, la connexion est établie.  Et ensuite? </h3><br>  Au moment où Alice ou Bob <b>entre dans l'</b> état <b>RUNNING</b> , les compteurs sont réinitialisés. <br>  Comme je l'ai déjà mentionné, le protocole d'origine implique la numérotation des messages modulo 256, mais nous devons réduire ce nombre pour convenir à la petite quantité de mémoire dans les choses de type Arduino. <br>  Afin de pouvoir immédiatement limiter tous les incréments de compteurs, nous allons introduire une certaine constante UMCP_PACKETS_NUMBER, et maintenant tous les incréments se produiront dans ce module. <br><br>  Si vous prenez UMCP_PACKETS_NUMBER = 8 et que la taille maximale des paquets est UMCP_PACKET_DATA_SIZE - les parties des données transmises à la fois sont limitées à 64 octets, alors tout ira dans l'Arduino UNO et restera un peu pour les besoins des utilisateurs. <br>  Il est important de se rappeler que ces deux paramètres doivent être les mêmes pour les deux parties. <br><br>  De toute évidence, maintenant, si Alice et Bob ont réussi à établir une connexion et que l'un d'eux a besoin de transférer des données, les données doivent d'abord être divisées en portions ne dépassant pas 64 octets, et deuxièmement, chaque paquet doit également contenir un état deux compteurs d'expéditeur: le nombre de messages reçus et envoyés (R et N). <br><br>  Voyez comme il est maintenant facile d'organiser ce que l'on appelle  pipelining et comment il est facile de gérer les situations d'erreur! <br><br>  Si Alice envoie 3 paquets d'affilée juste après l'établissement de la connexion, alors le compteur R sera mis à 0 à tous (elle n'a encore reçu aucun paquet) et le compteur N augmentera de un à chaque nouveau paquet. <br><br>  Si Bob les accepte tous avec succès, alors pour confirmer la réception des trois paquets, il lui suffira d'envoyer une confirmation uniquement pour le dernier, en fait, s'il renvoie simplement le statut de ses compteurs R = 3 et N = 0, alors Alice comprendra immédiatement que tous les messages envoyés ses messages ont atteint le destinataire. <br><br>  C'était un cas idéal où aucun cas de force majeure ne s'était produit.  Voyons maintenant ce qui pourrait mal tourner et comment y faire face. <br><br>  Si pour une raison quelconque, Bob saute le premier paquet et accepte l'un des suivants, il attire immédiatement l'attention sur le fait que le compteur N qu'il contient (le nombre de paquets transmis par Alice) dépasse clairement le compteur R du côté de Bob et Bob se rend facilement compte qu'il a raté le premier paquet .  Dans ce cas, il a juste besoin de jouer les preuves de capitaine les plus plates et de dire à Alice l'état de son compteur de paquets reçus (R = 0).  Alice comprend en même temps qu'elle est N = 3, et Bob a R = 0, c'est-à-dire qu'il est nécessaire de transférer les paquets d'une nouvelle manière, en commençant par la première. <br><br>  Si vous examinez attentivement ce schéma, vous pouvez voir que toute transmission du statut de ses compteurs par un abonné l'informe immédiatement du résultat de la transmission des paquets de données, et la différence entre le compteur transmis d'un côté et reçu de l'autre indique combien de paquets ont été perdus et de quel nombre il est parti. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est-à-dire que dans le pire des cas, il y a une retransmission complète de la transmission, dans le cas moyen, le compteur A du côté de l'émetteur augmente à la valeur du compteur R du côté de la réception et "envoie" les paquets perdus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est facile de comprendre que de cette manière la continuité de l'incrément des compteurs est maintenue, ce qui signifie que la transmission des messages (paquets) est garantie. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus des variables d'ARN, chaque abonné a deux drapeaux SACK et SPEP. Si le premier est installé, vous devez envoyer une confirmation (Envoyer un accusé de réception), si le second - alors vous devez envoyer une demande de confirmation (Envoyer REPly à un message).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soit dit en passant, un autre indicateur a été impliqué dans le DDCMP - SNAK d'origine (accusé de réception négatif). Son installation implique l'envoi d'un message d'erreur avec une sorte de code. Mais dans notre version du protocole, nous résoudrons toutes les erreurs exclusivement à l'aide du mécanisme de temporisation, car le protocole peut être utilisé, par exemple, dans des communications sonar ou radio dans une bande de fréquence commune - cela n'a aucun sens de colmater l'environnement commun avec des codes d'erreur. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le message a été reçu avec une erreur d'intégrité, il s'agit à proprement parler d'un message non accepté. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, le lecteur corrosif devrait avoir le sentiment que quelque chose manque. Quelque chose ne va pas avec ce schéma mince.</font></font> Et c'est vrai.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus d'informations à ce sujet plus tard. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En attendant, je propose, en suivant l'exemple du processus de configuration de la connexion, de collecter toutes les réflexions fragmentaires sur le transfert de données vers une table. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous n'avons maintenant qu'un seul état, le tableau ne contiendra que deux colonnes - l'événement et les actions à entreprendre. </font><font style="vertical-align: inherit;">Pour éviter toute confusion entre ceux à qui appartiennent les variables, nous marquons les locales avec l'index L et les distantes (celles qui sont contenues dans le message reçu avec l'index R).</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ÉVÉNEMENT </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ACTION </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le paquet de données est venu NR = RL + 1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Arrêtez le temporisateur </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Envoyez le paquet à l'utilisateur </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) RL = RL + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) Si RR = NL ou AL &lt;= RR &lt;= NL marquez tous </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les paquets transmis avec des nombres de AL à RR comme </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">confirmé </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) AL = RR</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une demande de confirmation est arrivée - REP </font></font></td><td> 1) SACK = true <br> 2) SREP = false <br></td></tr><tr><td>   — ACK </td><td> 1)   <br> 2) SREP = false <br> 3)  RR=NL  AL&lt;=RR&lt;=NL   <br>      AL  RR  <br>  <br> 4) AL=RR <br></td></tr><tr><td>    </td><td> 1) SREP = true </td></tr><tr><td>      SREP </td><td> 1)     REP(RL, NL) <br> 2)   <br></td></tr><tr><td>    AL&lt;NL </td><td> 1)     AL+1 <br> 2)   <br></td></tr><tr><td>  ,   SACK </td><td> 1)   ACK(RL,NL) </td></tr><tr><td>  , AL=NL,  SACK  SREP <br>  ,     <br></td><td> 1) NL=NL+1 <br> 2)     <br></td></tr></tbody></table></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, regardez bien, faites défiler tout le circuit dans la tête. Nous réalisons ce qui manque ici. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la description originale de DDCMP, dont nous nous sommes éloignés assez fortement, cela s'appelle l'indicateur SELECT - un nœud (Alice ou Bob) peut ou non être «choisi». </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce qui nous a déroutés, c'est qu'aucun mécanisme n'était autorisé à autoriser ou à interdire le transfert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, le voici: c'est le drapeau SELECT. Il est appliqué très simplement: si le drapeau est positionné, alors il est possible de transmettre, sinon, c'est impossible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les messages de contrôle tels que ACK et REP doivent contenir cet indicateur. </font><font style="vertical-align: inherit;">Le dernier paquet de la file d'attente doit également contenir cet indicateur. </font><font style="vertical-align: inherit;">Si un nœud «coud» un drapeau dans un paquet, il le «donne» et, par conséquent, il n'est plus installé. </font><font style="vertical-align: inherit;">Le nœud qui détecte cet indicateur dans le package, au contraire, doit l'installer seul. </font><font style="vertical-align: inherit;">Cela revient à passer un bâton ou à jouer une viande hachée (rappelez-vous cela?). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La chose la plus importante dans l'utilisation de cet indicateur est que l'un des nœuds doit avoir cet indicateur par défaut, et l'autre non. </font><font style="vertical-align: inherit;">C'est un autre temporisateur très important - le temporisateur de retour du drapeau SELECT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant un ensemble complet de règles pour établir une connexion et transmettre des données par-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons pas abordé uniquement la mise en œuvre concrète de cet ensemble de règles. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, corrigez-le!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formation et format du package </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est ce qu'on appelle le cadrage des messages - les règles d'analyse et de génération des messages et le format. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculons combien nous avons besoin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Au minimum, nous avons besoin que chaque message contienne l'état des compteurs R et N de l'expéditeur. </font><font style="vertical-align: inherit;">Pour Arduino, nous avons convenu que nous pouvons avoir un maximum de 8 messages envoyés mais non confirmés. </font><font style="vertical-align: inherit;">Mais puisque nous transférons des octets, nous poussons les deux compteurs dans un octet, qu'ils soient de 4 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet octet sera formé comme ceci:</font></font><br><pre><code class="cpp hljs"> = (RL &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | (NL &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Et nous lirons le statut des compteurs comme ceci: <br><pre> <code class="cpp hljs">NR = (c &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; RR = c &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>;</code> </pre> <br>  c - octet correspondant du message <br><br>  2. Nous rappelons également que chaque message doit contenir l'état de l'indicateur SELECT.  Et les différents types de messages eux-mêmes seront: <br><div class="scrollable-table"><table><tbody><tr><th>  Nom drôle <br></th><th>  Nom sérieux <br></th><th>  La description <br></th><th>  Valeur de l'indicateur SELECT <br></th><th>  Valeur PTYPE </th></tr><tr><td>  "FAITES-LE UNE FOIS!" <br></td><td>  STR <br></td><td>  STaRt <br></td><td>  vrai </td><td>  40 <br></td></tr><tr><td>  "FAITES DEUX!" <br></td><td>  STA <br></td><td>  STart acquitté </td><td>  vrai </td><td>  36 </td></tr><tr><td>  "NOOL ACCEPTÉ!" <br></td><td>  ACK (NL = 0, RL = 0) <br></td><td>  Reconnaissance <br></td><td>  vrai </td><td>  33 <br></td></tr><tr><td>  "ACCEPTÉ PAR ER, ENVOYÉ PAR EN" </td><td>  ACK (NL, RL) </td><td>  Reconnaissance </td><td>  vrai </td><td>  33 </td></tr><tr><td>  "CONFIRMER COMMENT JE COMPRENDS?" <br></td><td>  REP (NL, RL) <br></td><td>  REPly à un message </td><td>  vrai </td><td>  34 </td></tr><tr><td>  "PAQUET DE DONNÉES" <br></td><td>  DTA (NL, RL) <br></td><td>  Paquet de données </td><td>  faux </td><td>  17 </td></tr><tr><td>  FORFAIT DE DONNÉES EXTRÊMES <br></td><td>  DTE (NL, RL) </td><td>  Paquet DaTa - Fin </td><td>  vrai </td><td>  49 </td></tr></tbody></table></div><br><br>  Autrement dit, seulement 6 types de messages différents.  Tous les messages sauf DTA "libèrent" l'indicateur SELECT - ils ont besoin d'une réponse immédiate de l'abonné distant et sans l'indicateur, il ne pourra pas le transmettre.  Le message DTA ne renvoie pas d'indicateur pour rendre le pipelining possible. <br><br>  En général, nous avons suffisamment de 3 bits pour le type de message, mais afin de ne pas jouer avec les bits, nous attribuons un octet entier au type - en cas de révision, nous aurons une certaine liberté d'action. <br><br>  Si le message contient des données, nous devons transférer leur quantité et leur somme de contrôle.  Étant donné que la taille maximale des paquets est de 64 octets, nous prendrons également un octet pour la somme de contrôle et pour la longueur - tout à coup, vous devrez augmenter la taille des paquets. <br><br>  3. Nous avons également besoin d'une signature du début du message et d'une somme de contrôle distincte pour l'en-tête. <br><br>  Avec tout cela à l'esprit, l'en-tête (alias messages de contrôle) ressemble à ceci: <br><div class="scrollable-table"><table><tbody><tr><th>  Décalage, octet <br></th><th>  La description </th><th>  Taille, peu </th></tr><tr><td>  0 </td><td>  SIGN = 0xAD <br></td><td>  8 </td></tr><tr><td>  1 </td><td>  PTYPE </td><td>  8 </td></tr><tr><td>  2 </td><td>  TCNT </td><td>  4 <br></td></tr><tr><td>  2 </td><td>  RCNT </td><td>  4 </td></tr><tr><td>  3 </td><td>  Hchk </td><td>  8 </td></tr></tbody></table></div><br><br>  Et le bloc de données est comme ceci: <br><div class="scrollable-table"><table><tbody><tr><th>  Décalage, octet <br></th><th>  La description </th><th>  Taille, peu </th></tr><tr><td>  4 </td><td>  DCNT <br></td><td>  8 </td></tr><tr><td>  5..5 + DCNT-1 <br></td><td>  DONNÉES <br></td><td>  8 * DCNT </td></tr><tr><td>  5 + DCNT </td><td>  Dchk </td><td>  8 </td></tr></tbody></table></div><br><br>  C'est tout.  Ceci est une description complète du protocole que nous avons obtenu de DDCMP. <br>  Vous pouvez maintenant passer par l'implémentation. <br><br><h3>  Comment est-il organisé et comment l'utiliser? </h3><br>  Tout d'abord, un peu sur la structure du référentiel. <br>  Comme je l'ai mentionné au début, le code du projet se trouve sur le github: <a href="https://github.com/AlekUnderwater/uMCPIno" rel="nofollow">uMCPIno</a> <br><br>  Afin de voir comment tout fonctionne, vous pouvez exécuter une <a href="" rel="nofollow">application de test</a> sur un PC. <br><br>  Dans l'archive, exécutez uMCPIno_Test.exe, sélectionnez le port COM souhaité et essayez son fonctionnement. <br>  Vous pouvez vérifier une paire de ports COM virtuels (je fais généralement cela). <br>  Pourquoi vous pouvez exécuter deux copies de l'application.  N'oubliez pas d'activer «SELECTED BY DEFAULT» dans une copie - ce sera Master, et dans l'autre - désactivez-le.  Au fait, si vous êtes intéressé, vous pouvez voir ce qui se passe si vous ne respectez pas cette règle =) <br><br>  L'option EXTRAS vous permet de voir tous les mouvements de pensées à l'intérieur du cerveau du protocole.  Tous les changements dans l'état des drapeaux SELECT, les événements des temporisateurs, les changements dans l'état du nœud, ainsi que les valeurs des variables R et N dans les messages transmis et reçus seront affichés. <br><br>  Je connecte mon Arduino UNO à mon ordinateur portable via un convertisseur USB UART &lt;-&gt;.  Les connecteurs à broches vous permettent de simuler un saut de ligne à tout moment: <br><img src="https://habrastorage.org/webt/nn/vg/kp/nnvgkplqtoqbazpubopcb8bff-g.jpeg"><br><br>  Si vous exécutez maintenant l'application sur l'ordinateur portable, après avoir appuyé sur le bouton "CONNECTER", l'arduina établira une connexion: <br><img src="https://habrastorage.org/webt/cy/jm/lx/cyjmlxn_ga-_zvrzel5yjmfwdz4.png"><br><br>  Et voici comment le système réagit à une tentative d'envoi via une ligne «déchirée»: <br><img src="https://habrastorage.org/webt/lu/kb/dw/lukbdwxot1xuopxjdqxgpq1xqsq.png"><br><br>  Pour intégrer uMCPIno dans votre application pour PC: <br><ol><li>  Le référentiel possède une bibliothèque uMCPIno.  Connectez-le aux références de votre projet </li><li>  Il contient la classe uMCPInoPort.  Nous déclarons son instance: <br><pre> <code class="cs hljs">uMCPInoPort port; port = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uMCPInoPort(<span class="hljs-string"><span class="hljs-string">"COM1"</span></span>, UCNLDrivers.BaudRate.baudRate9600, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-number"><span class="hljs-number">8100</span></span>, <span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>);</code> </pre><br>  Paramètres dans l'ordre: nom du port, puis vitesse du port, état SELECT par défaut, intervalle pour SELECT, intervalle de temporisation, taille du paquet et nombre maximal de messages non acquittés. <br></li><li>  Abonnez-vous aux événements: <br>  lorsque l'indicateur SELECT - port.Select change: <br><pre> <code class="cs hljs">OnSelectChangedEventHandler</code> </pre> <br>  lorsque l'état change - port.État: <br><pre> <code class="cs hljs">OnStateChangedEventHandler</code> </pre> <br>  L'hôte distant confirme la réception du code: <br><pre> <code class="cs hljs">OnDataBlockAcknowledgedEventHandler</code> </pre> <br>  quand arrive le paquet de données: <br><pre> <code class="cs hljs">OnDataBlockReceivedEventHandler</code> </pre> <br></li><li>  Avant de travailler, ouvrez le port <br><pre> <code class="cs hljs">port.Open();</code> </pre> <br></li><li>  Pour envoyer des données, nous appelons la méthode: <pre> <code class="cs hljs">port.Send(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data);</code> </pre> <br></li><li>  Une fois l'opération terminée, fermez le port: <pre> <code class="cs hljs">port.Close();</code> </pre> <br></li></ol><br><br>  Envoyez simplement deux octets! <br><br>  Passons maintenant à l'implémentation d'Arduino.  Deux exemples se trouvent dans le dossier <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/Arduino" rel="nofollow">github.com/AlekUnderwater/uMCPIno/tree/master/Arduino</a> <br><br>  <a href="" rel="nofollow">Le premier</a> est juste un convertisseur de et vers uMCP.  Le premier Serial sert à communiquer avec l'hôte, et Serial1 (s'il est sur votre carte) ou SoftwareSerial sur les broches 2 et 3 - pour communiquer avec un autre nœud uMCPIno.  Vous pouvez connecter Bluetooth ou un module radio ici. <br><br>  <a href="" rel="nofollow">Le second</a> est un modèle de projet avec prise en charge du protocole uMCPIno <br><br>  Les deux projets ont des paramètres où vous pouvez et devez grimper.  Les voici: <br><br>  L'état par défaut de l'indicateur SELECT.  S'il est défini sur (true), même si le nœud distant ne renvoie pas l'indicateur, il sera défini sur true par le temporisateur. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_SELECT_DEFAULT_STATE (false)</span></span></code> </pre> <br><br>  Pour définir la période de ce temporisateur, il existe le paramètre suivant: intervalle pour renvoyer l'indicateur SELECT en millisecondes <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_SELECT_DEFAULT_INTERVAL_MS (4000)</span></span></code> </pre> <br><br>  L'intervalle d'attente d'une réponse en millisecondes, il est préférable de le laisser légèrement inférieur à l'intervalle de retour de l'indicateur SELECT. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_TIMEOUT_INTERVAL_MS (3000)</span></span></code> </pre> <br><br>  Le débit en bauds réel de la ligne.  Ce paramètre est nécessaire pour déterminer la fin du transfert. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_LINE_BAUDRATE_BPS (9600)</span></span></code> </pre> <br><br>  Intervalle d'accumulation de données pour l'algorithme Nagle.  Insolemment, prenez-le égal à 100 millisecondes.  Pendant ce temps, nous attendons un ensemble de paquets, s'il n'est pas tapé, nous l'envoyons tel quel.  La tâche de l'algorithme Nagle est de débarrasser le réseau d'un tas de petits paquets d'un à plusieurs octets. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_NAGLE_DELAY_MS (100)</span></span></code> </pre> <br><br>  Ces paramètres définissent les vitesses de port pour la communication avec le système de contrôle (hôte) et la ligne.  Ne confondez pas la vitesse du port avec une ligne avec un taux de transfert physique. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_HOST_CONNECTION_BAUDRATE_BPS (9600) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Host connection port speed #define CFG_LINE_CONNECTION_BAUDRATE_BPS (9600) // Line connection port speed</span></span></span></span></code> </pre> <br><br>  Si ce paramètre est activé, lorsque le courant est fourni au contrôleur, le protocole lui-même se commandera pour commencer à établir une connexion. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_IS_AUTOSTART_ON_POWERON (true)</span></span></code> </pre> <br><br>  Il s'agit de la taille en octets de la mémoire tampon pour les paquets de données entrants. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_IL_RING_SIZE (255)</span></span></code> </pre> <br><br>  Voyons ensuite à quoi ressemble la boucle d'esquisse principale: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uMCP_ITimers_Process(); DC_Input_Process(); DC_Output_Process(); <span class="hljs-comment"><span class="hljs-comment">//  ip_ready  ,      if (ip_ready) { uMCP_OnIncomingPacket(); } //        ,     -  if ((state == uMCP_STATE_HALTED) &amp;&amp; ((ih_Cnt &gt; 0) || (isStartup &amp;&amp; CFG_IS_AUTOSTART_ON_POWERON))) { if (isStartup) { isStartup = false; } uMCP_STATE_Set(uMCP_STATE_ISTART); uMCP_CtrlSend(uMCP_PTYPE_STR, 0, 0, true); } else if (state == uMCP_STATE_RUNNING) { uMCP_Protocol_Perform(); //      -   if (il_ready) { il_ready = false; USER_uMCPIno_DataPacketReceived(); } } }</span></span></code> </pre><br><br>  Voyons maintenant comment fonctionne le protocole.  La logique principale est contenue dans la fonction uMCP_Protocol_Perform ();  Voici son code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCP_Protocol_Perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == uMCP_STATE_RUNNING) { <span class="hljs-comment"><span class="hljs-comment">//              SELECT  if ((!iTimer_State[uMCP_Timer_TX]) &amp;&amp; (!iTimer_State[uMCP_Timer_TMO]) &amp;&amp; (select)) { //     if (ih_Cnt == 0) { //    REP -  if (srep) { uMCP_CtrlSend(uMCP_PTYPE_REP, N, R, true); srep = false; } //     -   else if (sentBlocksCnt &gt; 0) { uMCP_DataBlockResend((A + 1) % UMCP_PACKETS_NUMBER, true, true); } //    SACK  -        //  -       ACK else if ((!selectDefaultState) || (sack)) { uMCP_CtrlSend(uMCP_PTYPE_ACK, N, R, false); sack = false; } } //     -  else if (ih_Cnt &gt; 0) { //              -  if ((ih_Cnt &gt;= UMCP_PACKET_DATA_SIZE) || (millis() &gt;= ih_TS + CFG_NAGLE_DELAY_MS)) { //   N N = (N + 1) % UMCP_PACKETS_NUMBER; uMCP_NextDataBlockSend(); } } } } }</span></span></code> </pre><br><br>  Un analyseur de paquets qui vit dans une fonction <pre> <code class="cpp hljs">On_NewByte_From_Line</code> </pre>  également organisé selon le principe d'une machine à états finis et fonctionne "octet par octet".  Ceci est fait afin d'économiser de la mémoire. <br><br>  Le reste de la mise en œuvre ne présente pas d'intérêt particulier.  Nous analyserons mieux la façon dont l'utilisateur interagit avec le protocole.  Dans cet exemple, il existe quatre «points de contact». <br><br>  Le premier est la fonction d'envoi de données sur la ligne uMCPIno: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCPIno_SendData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte* dataToSend, byte dataSize)</span></span></span></span>;</code> </pre> <br>  Tout est simple ici - vous avez un tampon d'octets dataToSend, sa taille est dataSize.  La fonction renvoie vrai si l'envoi est possible (il y a de la place pour ajouter des données), et faux sinon. <br>  Afin de ne pas conduire en vain, vous pouvez immédiatement vérifier la disponibilité de suffisamment d'espace en utilisant la fonction: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCP_IsCanSend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte dataSize)</span></span></span></span>;</code> </pre> <br><br>  Afin d'analyser les paquets de données entrants, vous devez ajouter votre code au corps de la fonction <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USER_uMCPIno_DataPacketReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><br>  Les données entrantes sont écrites dans le tampon en anneau il_ring.  La lecture peut être organisée comme ceci: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (il_Cnt &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { c = il_ring[il_rPos]; il_rPos = (il_rPos + <span class="hljs-number"><span class="hljs-number">1</span></span>) % CFG_IL_RING_SIZE; il_Cnt--; <span class="hljs-comment"><span class="hljs-comment">//   "c" -      }</span></span></code> </pre><br><br>  Pour les plaisirs sophistiqués, il y a une fonction <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USER_uMCP_OnTxBufferEmptry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  Qui est appelé lorsque toutes les données ont été envoyées avec succès.  Il est également possible et nécessaire d'y mettre une sorte de code. <br><br><h3>  Pourquoi tout cela et où? </h3><br>  Je m'occupais principalement de Just for fun.  De plus, j'avais besoin d'un protocole simple et, surtout, «léger» pour envoyer des données via nos modems sonar <a href="https://habr.com/ru/post/428367/">uWAVE</a> .  Puisqu'ils transmettent des données dans l'eau à une vitesse de seulement 80 bps, et avec leur portée de communication maximale de 1000 mètres et la vitesse du son dans l'eau d'environ 1500 m / s, la transmission est associée à des retards notables, et il n'y a qu'un seul canal sonar (sinon le plus !) des plus bruyants, des plus lents et des plus instables. <br>  En grande partie à cause de cela, j'ai dû abandonner le mécanisme de reconnaissance négative (NAK) - s'il est possible de ne pas transmettre - dans l'eau il vaut mieux ne pas transmettre à 100%. <br>  En réalité, le protocole a été utile lors de la transmission de données sur un canal radio à l'aide de modules <a href="http://www.dorji.com/products.php%3FCateId%3D9" rel="nofollow">DORJI</a> et du <a href="https%253A%252F%252Fwww.elecrow.com%252Fdownload%252FHC-12.pdf%26usg%3DAOvVaw2rNtYm7nLdpqPN6HR-LAS8" rel="nofollow">NS-012</a> bien connu des arduinoes. <br><br><h3>  Et ensuite? </h3><br>  S'il reste du temps, je prévois d'ajouter la possibilité d'adressage (qui, soit dit en passant, était en DDCMP).  Puisque la tâche principale de ce protocole est maintenant de fournir une commodité pour toutes sortes de tests de nos modems sonar et d'autres réseaux de capteurs, il y a (littéralement!) Des pièges là-bas.  Je peux seulement dire que le problème ne peut pas être résolu en ajoutant simplement les champs "Sender" et "Target". <br>  Cela viendra peut-être du <a href="https://en.wikipedia.org/wiki/Geographic_routing" rel="nofollow">routage géographique</a> et de tout ce jazz. <br><br><h3>  PS </h3><br>  Traditionnellement, je serai très reconnaissant des critiques constructives, des souhaits et des suggestions.  Il est toujours important de comprendre si vous faites quelque chose d'utile pour les gens ou si vous perdez du temps. <br>  Peut-être, en essayant d'éviter la transition de cette longue lecture au roman "Guerre et paix", j'ai manqué quelques détails - n'hésitez pas à demander. <br><br><h3>  PPS </h3><br>  Un grand merci à la honte de mon analphabétisme, signalant des erreurs (grammaticales et logiques): <br><ul><li>  <a href="https://habr.com/ru/users/berez/" class="user_link">berez</a> </li><li>  <a href="https://habr.com/ru/users/edo1h/" class="user_link">edo1h</a> </li></ul><br>  Le projet était à l'origine open source, mais maintenant l'article est également open source. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480110/">https://habr.com/ru/post/fr480110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480100/index.html">Débutants sur le référencement</a></li>
<li><a href="../fr480102/index.html">Sommaire de novembre sur la gestion des produits</a></li>
<li><a href="../fr480104/index.html">9 astuces HTML utiles</a></li>
<li><a href="../fr480106/index.html">Comment assembler une image Oracle DB pour Testcontainers</a></li>
<li><a href="../fr480108/index.html">La physique dans un projet Unity utilisant le combat mobile comme exemple</a></li>
<li><a href="../fr480112/index.html">Différences entre C ++ / Visual Basic et Java au niveau général (pour débutants et étudiants)</a></li>
<li><a href="../fr480114/index.html">Tout sur les taxes pour les indépendants IT. IE et indépendants. Partie 1</a></li>
<li><a href="../fr480116/index.html">Position du groupe Mail.ru sur le développement de l'open source en Russie</a></li>
<li><a href="../fr480118/index.html">Nous écrivons un simulateur de saisie tactile en utilisant du JavaScript pur. Partie 1</a></li>
<li><a href="../fr480120/index.html">Une nouvelle réalisation en cryptographie - Factorisation d'un RSA 795 bits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>