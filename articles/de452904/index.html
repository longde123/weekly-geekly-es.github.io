<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕚 🍧 👨🏿‍🔧 Wie Maschinen kommunizieren - MQTT-Protokoll 👨🏾‍💻 🧒 🚺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem früheren Artikel haben wir uns mit dem Modbus-Protokoll befasst , dem De-facto-Industriestandard für M2M- Interaktion. MQTT wurde 1979 entwic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Maschinen kommunizieren - MQTT-Protokoll</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/advantech/blog/452904/"><div style="text-align:center;"><img width="400" src="https://habrastorage.org/webt/nb/fv/om/nbfvom_zwqoyqg4e4bcxwl1ax7a.png"></div><br>  In einem früheren Artikel haben wir uns mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Modbus-Protokoll befasst</a> , dem De-facto-Industriestandard für <abbr title="Maschine zu Maschine">M2M-</abbr> Interaktion.  MQTT wurde 1979 entwickelt und weist eine Reihe bedeutender Nachteile auf, die MQTT löst. <br><br>  Das MQTT-Protokoll ist noch recht jung (erst 2016 standardisiert), hat es jedoch bereits geschafft, in der Industrie und im Internet der Dinge weit verbreitet zu sein.  Es wurde speziell entwickelt, um so kompakt wie möglich für instabile Internetkanäle und Geräte mit geringem Stromverbrauch zu sein, und ermöglicht Ihnen die garantierte Zustellung von Nachrichten bei Paketverlust und -trennung. <br><br>  Hauptmerkmale des MQTT-Protokolls: <br><br><ul><li>  <b>Kompakt und leicht</b> - minimaler Datenübertragungsaufwand, um Datenverkehr zu sparen. </li><li>  <b>Widerstandsfähigkeit gegen Verluste</b> - garantierte Lieferung bei instabilen Netzwerkverbindungen. </li><li>  <b>Asynchron</b> - Ermöglicht die Bedienung einer großen Anzahl von Geräten und ist nicht von Netzwerkverzögerungen abhängig. </li><li>  <b>QoS-Unterstützung</b> - die Möglichkeit, die Nachrichtenpriorität zu steuern und die Nachrichtenübermittlung an den Empfänger zu gewährleisten. </li><li>  <b>Dynamische Konfiguration</b> - erfordert keine vorherige Koordination von Feldern und Datenformaten, kann im laufenden Betrieb konfiguriert werden. </li><li>  <b>Funktioniert für NAT</b> - Clients können sich hinter NAT befinden, nur der Server (Broker) muss eine echte IP haben.  Ermöglicht den Verzicht auf VPN und Portweiterleitung. </li><li>  <b>Bequeme Adressierung</b> - Datenfelder haben Textnamen, die für den Menschen verständlich sind.  Sie müssen sich keine digitalen Adressen und Bit-Offsets merken. </li></ul><a name="habracut"></a><br>  In diesem Artikel werden wir MQTT und Modbus vergleichen, die Protokollstruktur und grundlegende Konzepte analysieren und versuchen, den Cloud-MQTT-Broker als Beispiel für eine instabile Internetverbindung zu verwenden. <br><br><h2>  MQTT-Protokollverlauf </h2><br>  MQTT wurde 1999 von IBM entwickelt und ursprünglich intern für seine Lösungen verwendet. <br><br>  Im November 2011 gaben IBM und Eurotech ihre Teilnahme an der Eclipse M2M-Arbeitsgruppe und die Übertragung des MQTT-Codes an das Eclipse Paho-Projekt bekannt. <br><br>  Im Jahr 2013 begann das Konsortium der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OASIS</a> (Organisation zur Förderung strukturierter Informationsstandards) mit der Standardisierung des MQTT-Protokolls.  Bis zu diesem Zeitpunkt wurde die Protokollspezifikation unter einer kostenlosen Lizenz veröffentlicht, und Unternehmen wie Eurotech (früher bekannt als Arcom) verwenden das Protokoll bereits in ihren Produkten. <br><br>  Im Oktober 2014 veröffentlichte OASIS den ersten offiziellen MQTT-Protokollstandard. <br><br>  2016 wurde das Protokoll von der Internationalen Organisation für Normung ISO standardisiert und erhielt die Nummer ISO / IEC 20922. <br><br>  Seit 2014 wächst das Interesse an dem Protokoll rapide und nach dem Google Trends-Zeitplan übersteigt es heute das Interesse an Modbus. <br><br><img src="https://habrastorage.org/webt/ia/6q/cw/ia6qcwyvn9p6yi_10xrdgkwbcqu.png"><br>  <font color="999999">Google Trends Benchmark</font> <br><br><h2>  Grundbegriffe </h2><br>  MQTT verfügt über eine Client-Server-Architektur.  Das Messaging erfolgt über einen zentralen Server, der als Broker bezeichnet wird.  Unter normalen Bedingungen können Clients nicht direkt miteinander kommunizieren, und der gesamte Datenaustausch erfolgt über einen Broker. <br><br>  Clients können als Datenanbieter (Publisher) und als Datenempfänger (Subscriber) fungieren.  In einer russischen Übersetzung werden diese Begriffe häufig als Herausgeber und Abonnent übersetzt. Um jedoch Verwirrung zu vermeiden, verwenden wir nur die ursprüngliche Terminologie. <br><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/webt/ex/ri/7r/exri7rw8067vln4jiqq5ma9dine.png"></div><br>  <font color="999999">Im MQTT-Protokoll kommunizieren Clients über einen zentralen Knoten miteinander</font> <br><br>  Auf Anwendungsebene läuft das Protokoll über TCP / IP und kann problemlos Remote-Objekte direkt über das Internet verbinden, ohne dass VPN-Tunnel erforderlich sind.  Es reicht aus, wenn der Broker eine echte IP-Adresse hat und alle Clients eine Verbindung herstellen können.  In diesem Fall befinden sich Clients möglicherweise hinter NAT.  Da Clients die Verbindung im MQTT-Protokoll initiieren, ist keine Portweiterleitung erforderlich, um eine Verbindung herzustellen, während der Server in Modbus / TCP eine Verbindung (Master) initiiert, für die ein direkter Netzwerkzugriff erforderlich ist. <br><br>  Der Standard-MQTT-Broker-Port für eingehende TCP-Verbindungen ist <b>1883</b> .  Bei Verwendung einer sicheren SSL-Verbindung wird Port <b>8883 verwendet</b> . <br><br><h4>  Makler </h4><br>  Ein Broker ist der zentrale MQTT-Hub für die Kundeninteraktion.  Der Datenaustausch zwischen Kunden erfolgt nur über einen Broker.  Der Broker kann eine Serversoftware oder ein Controller sein.  Zu seinen Aufgaben gehören das Empfangen von Daten von Kunden, das Verarbeiten und Speichern von Daten, das Liefern von Daten an Kunden und das Überwachen der Nachrichtenübermittlung. <br><br><h4>  Herausgeber / Abonnent </h4><br>  Um den Unterschied zwischen Publisher und Subscriber zu verstehen, nehmen wir ein einfaches Beispiel: Ein Feuchtigkeitssensor misst die Luftfeuchtigkeit in einem Raum. Wenn sie unter einen bestimmten Wert fällt, schaltet sich der Luftbefeuchter ein. <br><br>  In diesem Fall fungiert der Feuchtigkeitssensor als <b>Herausgeber</b> : Seine Aufgabe besteht nur darin, Daten im Broker zu veröffentlichen.  Der Luftbefeuchter fungiert als <b>Abonnent</b> : Er abonniert Aktualisierungen der Feuchtigkeitsdaten und empfängt aktuelle Daten vom Broker, während der Luftbefeuchter entscheiden kann, wann die Luftbefeuchtung eingeschaltet werden soll. <br><br>  In diesem Schema sind sich MQTT-Clients, dh der Sensor und der Luftbefeuchter, der Existenz des anderen nicht bewusst und interagieren nicht direkt.  Der Broker kann Daten aus verschiedenen Quellen empfangen, bearbeiten, beispielsweise den Durchschnittswert von mehreren Sensoren berechnen und die verarbeiteten Daten an den Teilnehmer zurückgeben. <br><br><img src="https://habrastorage.org/webt/xc/pb/t8/xcpbt8th_jxzdzfglqwxt4wnpwo.png"><br>  <font color="9999999">Der Publisher sendet Daten an den Broker, der Abonnent abonniert Aktualisierungen dieser Daten</font> <br><br>  Gleichzeitig bietet der Asynchronismus des MQTT-Protokolls, dass der Sensor und der Luftbefeuchter zu unterschiedlichen Zeiten online sein können, Pakete verlieren und nicht erreichbar sind.  Der Broker sorgt dafür, dass die zuletzt vom Sensor empfangenen Daten im Speicher gespeichert werden und dass sie an den Luftbefeuchter geliefert werden. <br><br><h4>  Thema </h4><br>  MQTT verwendet Themen, um Entitäten zu identifizieren. In der russischen Übersetzung werden sie auch als Kanäle bezeichnet.  Themen bestehen aus UTF8-Zeichen und haben eine Baumstruktur ähnlich einem UNIX-Dateisystem.  Dies ist ein praktischer Mechanismus zum Benennen von Entitäten in einer für Menschen lesbaren Form. <br><br>  Ein Beispiel für Themen in MQTT <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#     home/kitchen/temperature #     home/sleeping-room/temperature #     home/outdoor/light</span></span></code> </pre> <br>  Mit diesem Ansatz können Sie visuell sehen, welche Daten übertragen werden, und Sie können den Code bequem entwickeln und debuggen, ohne sich die digitale Adresse der Datenplatzierung merken zu müssen, wie dies bei Modbus der Fall ist. <br><br>  Zu den Themen gehört auch die Platzhaltersyntax, die denjenigen vertraut ist, die mit dem UNIX-Dateisystem gearbeitet haben.  Platzhalter können einstufig und mehrstufig sein. <br><br>  Ein einstufiger Platzhalter ist mit einem <b>+ gekennzeichnet</b> . <br><br>  Um beispielsweise Daten von Temperatursensoren in allen Räumen des Hauses zu empfangen, muss der Teilnehmer ein solches Thema abonnieren: <br><br><pre> <code class="plaintext hljs">home/+/temperature</code> </pre><br>  Infolgedessen abonniert er den Empfang von Daten von solchen Sensoren: <br><br><pre> <code class="plaintext hljs">home/kitchen/temperature home/sleeping-room/temperature home/living-room/temperature home/outdoor/temperature</code> </pre><br>  Ein mehrstufiger Platzhalter wird durch das Symbol " <b>#</b> " angezeigt. <br>  Ein Beispiel für das Abrufen von Daten von allen Sensoren in allen Räumen des Hauses: <br><br><pre> <code class="plaintext hljs">home/#</code> </pre><br>  Wenn Sie ein solches Thema abonnieren, können Sie Daten von solchen Sensoren empfangen: <br><br><pre> <code class="plaintext hljs">home/kitchen/temperature home/kitchen/humidity home/kitchen/light home/sleeping-room/temperature home/sleeping-room/humidity home/sleeping-room/light ....</code> </pre><br><h3>  Kundenidentifikation </h3><br>  Für die Zugriffskontrolle bietet MQTT im Gegensatz zum Modbus-Protokoll, das keine solche Funktion hat, eine Clientauthentifizierung.  Die folgenden Felder werden für die Zugriffskontrolle verwendet: <br><br>  <b>ClientId</b> - (erforderliches Feld) eindeutige Kennung des Clients.  Muss für jeden Kunden einzigartig sein.  In der aktuellen Version des MQTT 3.1.1-Standards können Sie das leere Feld ClientId verwenden, wenn Sie den Verbindungsstatus nicht speichern müssen. <br><br>  <b>Benutzername</b> - (optionales Feld) Anmeldung zur Authentifizierung im UTF-8-Format.  Kann nicht einzigartig sein.  Beispielsweise kann sich eine Gruppe von Clients mit demselben Benutzernamen / Kennwort anmelden. <br><br>  <b>Passwort</b> - (optionales Feld) kann nur zusammen mit dem Feld Benutzername gesendet werden, während der Benutzername ohne das Feld Passwort übertragen werden kann.  Maximal 65535 Bytes.  Es ist wichtig zu wissen, dass der Name und das Passwort im Klartext übertragen werden. Wenn die Daten über öffentliche Netzwerke übertragen werden, müssen Sie die Verbindung mit SSL verschlüsseln. <br><br><h3>  Paketstruktur </h3><br>  Wie oben erwähnt, initiieren Clients im MQTT-Protokoll immer eine Verbindung, unabhängig davon, ob sie Empfänger (Abonnent) oder Lieferant (Herausgeber) von Daten sind.  Wir werden das Paket mit der Verbindung analysieren, die mit dem Wireshark-Programm abgefangen wurde. <br><br><img src="https://habrastorage.org/webt/ep/0t/hv/ep0thv6e3zsvyzgizw89gpxgytg.png"><br>  <font color="999999">MQTT-Paket, das über einen unverschlüsselten Kanal übertragen wird</font> <br><br>  Der TCP-Header zeigt an, dass das Paket über Port 1883 gesendet wurde, dh, es wird keine Verschlüsselung verwendet. Dies bedeutet, dass alle Daten in klarer Form verfügbar sind, einschließlich Login und Passwort. <br><br><h4>  Überschrift </h4><br>  <b>Der Nachrichtentyp</b> ist Connect (Befehl 0x0001), wodurch eine Verbindung zum Broker hergestellt wird.  Hauptteams: Verbinden, Trennen, Veröffentlichen, Abonnieren, Abbestellen.  Es gibt auch Bestätigungsbefehle, am Leben bleiben usw. <br><br>  <b>Flag DUP</b> - bedeutet, dass die Nachricht erneut übertragen wird. Sie wird nur in den Nachrichtentypen PUBLISH, SUBSCRIBE, UNSUBSCRIBE, PUBREL verwendet, wenn der Broker keine Bestätigung über den Empfang der vorherigen Nachricht erhalten hat. <br>  <b>QoS-Level</b> - Flag der Servicequalität.  Wir werden dieses Thema später genauer diskutieren. <br>  <b>Aufbewahrung</b> - Mit dem Aufbewahrungsflag veröffentlichte Daten werden auf dem Broker gespeichert.  Beim anschließenden Abonnement dieses Themas sendet der Broker sofort eine Nachricht mit diesem Flag.  Wird nur in Nachrichten vom Typ Veröffentlichen verwendet. <br><br><h2>  Praktische Anwendung </h2><br><img width="100" src="https://habrastorage.org/webt/v9/m9/2k/v9m92kvqrkibu8zt9pfsdjkngg8.png"><br><br>  Nachdem wir uns mit der Theorie vertraut gemacht haben, versuchen wir nun, in der Praxis mit MQTT zu arbeiten.  Dazu verwenden wir das offene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mosquitto-</a> Programm, das sowohl im Client-Modus als auch im Server-Modus (Broker-Modus) arbeiten kann.  Es funktioniert unter Windows, MacOS, Linux.  Das Programm ist sehr praktisch zum Debuggen und Studieren des MQTT-Protokolls, während es auch im industriellen Betrieb weit verbreitet ist.  Wir werden es als Client verwenden, um Daten von einem Remote-Cloud-Broker zu senden und zu empfangen. <br><br>  Viele Cloud-Anbieter bieten MQTT-Broker-Services an, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Azure IoT Hub</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amazon AWS IoT</a> und andere.  In diesem Beispiel verwenden wir den Cloudmqtt.com-Dienst, da er die einfachste Registrierung aufweist und ein kostenloser Tarif für Schulungen ausreicht. <br><br>  Nach der Registrierung finden Sie in Ihrem Konto Details zur Verbindung mit einem Broker.  Da wir über öffentliche Internetnetzwerke eine Verbindung zum Server herstellen, ist es sinnvoll, einen SSL-Port zum Verschlüsseln des Datenverkehrs zu verwenden. <br><br><img src="https://habrastorage.org/webt/gh/rq/t5/ghrqt5ady8x8twccmfrtngm-htu.png"><br>  <font color="999999">Zugangsdaten zum MQTT-Broker im persönlichen Konto des Cloud-Anbieters</font> <br><br>  Die Flexibilität des MQTT-Protokolls ermöglicht es dem Client, Daten zu übertragen, die zuvor nicht auf dem Broker definiert wurden.  Das heißt, es ist nicht erforderlich, die erforderlichen Themen vorab zu erstellen, in die Publisher Daten schreiben kann.  Unter Verwendung der von Ihrem persönlichen Konto erhaltenen Daten werden wir versuchen, manuell eine Anforderung zum Veröffentlichen von Daten für das Thema <i>habr / test / random</i> zu <i>erstellen</i> und daraus zu lesen. <br><br>  <b>mosquitto_sub</b> - Abonnenten-Client-Dienstprogramm <br>  <b>mosquitto_pub</b> - Publisher-Client-Dienstprogramm <br><br>  Stellen Sie zunächst als Abonnent eine Verbindung zum Broker her und abonnieren Sie, um Daten vom Thema zu erhalten <br>  <i>habr / test / random</i> . <br><br><pre> <code class="plaintext hljs">mosquitto_sub -d --capath /etc/ssl/certs/ --url mqtts://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random Client mosq/zEPZz0glUiR4aEipZA sending CONNECT Client mosq/zEPZz0glUiR4aEipZA received CONNACK (0) Client mosq/zEPZz0glUiR4aEipZA sending SUBSCRIBE (Mid: 1, Topic: habr/test/random, QoS: 0, Options: 0x00) Client mosq/zEPZz0glUiR4aEipZA received SUBACK</code> </pre><br>  Es ist ersichtlich, dass die Verbindung erfolgreich war und wir das Thema <b>habr / test / random</b> abonniert haben. Jetzt warten wir auf Daten in diesem Thema vom Broker. <br><blockquote>  Da eine SSL-Verbindung verwendet wird, müssen Sie zur Überprüfung des Zertifikats den Pfad angeben, über den das Programm nach Stammverschlüsselungszertifikaten sucht.  Da der Dienst in unserem Beispiel ein Zertifikat verwendet, das von einer vertrauenswürdigen Zertifizierungsstelle ausgestellt wurde, geben wir den Pfad zum Systemspeicher für <i><b>Stammzertifikate an</b></i> : <i><b>--capath / etc / ssl / certs /</b></i> <br><br>  Bei einem selbstsignierten Zertifikat müssen Sie den Pfad zur gewünschten Zertifizierungsstelle angeben.  Es ist auch wichtig, den Unterschied im URI-Format für SSL-Verbindungen - mqtt <b>s</b> : // und nicht verschlüsselte Verbindungen - mqtt: // zu berücksichtigen.  Bei einem Zertifikatüberprüfungsfehler wird das Programm ohne Fehlermeldung beendet.  Für eine detailliertere Ausgabe können Sie den Schalter --debug verwenden </blockquote>  Versuchen wir nun, die Daten im Thema zu veröffentlichen, ohne das erste Programm zu unterbrechen. <br><br><pre> <code class="plaintext hljs">mosquitto_pub -d --capath /etc/ssl/certs/ --url mqtt://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random -m " !" Client mosq/sWjh9gf8DRASrRZjk6 sending CONNECT Client mosq/sWjh9gf8DRASrRZjk6 received CONNACK (0) Client mosq/sWjh9gf8DRASrRZjk6 sending PUBLISH (d0, q0, r0, m1, 'habr/test/random', ... (22 bytes)) Client mosq/sWjh9gf8DRASrRZjk6 sending DISCONNECT</code> </pre><br>  Es ist ersichtlich, dass die Daten erfolgreich vom Server empfangen und im gewünschten Thema veröffentlicht wurden.  Gleichzeitig sehen wir im ersten Fenster, in dem das Programm mosquitto_sub ausgeführt wird, wie die Nachricht empfangen wurde, auch wenn Unicode funktioniert, die Nachricht ist in russischer Sprache. <br><br><pre> <code class="plaintext hljs">Client mosq/zEPZz0glUiR4aEipZA received PUBLISH (d0, q0, r0, m0, 'habr/test/random', ... (22 bytes))  !</code> </pre><br><h2>  QoS und Liefergarantie </h2><br>  Das Senden einer Nachricht in Echtzeit wird jedoch niemanden überraschen, da dies auch mit dem banalen Dienstprogramm <b>nc möglich ist</b> .  Daher werden wir versuchen, eine instabile Verbindung zwischen dem Teilnehmer und dem Absender zu simulieren.  Stellen Sie sich vor, beide Clients arbeiten über GPRS mit einem enormen Paketverlust, und selbst eine erfolgreiche TCP-Verbindung ist selten. Sie müssen sicherstellen, dass der Teilnehmer garantiert eine Absendernachricht erhält.  In diesem Fall helfen QoS-Optionen. <br><br>  Standardmäßig ist das <b>QoS-</b> Flag für Nachrichten <b>auf 0 gesetzt</b> , was "Feuer und Vergessen" bedeutet: Publisher veröffentlicht die Nachricht auf dem Broker, erfordert jedoch nicht, dass die Nachricht garantiert an den Abonnenten zugestellt wird.  Dies ist für Daten geeignet, deren Verlust nicht kritisch ist, beispielsweise für regelmäßige Messungen der Luftfeuchtigkeit oder Temperatur. <br><br>  <b>QoS 1: Mindestens einmal - mindestens einmal</b> .  Dieses Flag bedeutet, dass diese Veröffentlichung an den Broker und dann an den Abonnenten gesendet wird, bis der Publisher eine Zustellbestätigung an den Abonnenten erhält.  Daher muss der Teilnehmer diese Nachricht mindestens einmal empfangen. <br><br>  <b>QoS 2: Genau einmal - garantiert eine</b> .  Das QoS-Flag, das die höchste Garantie für die Zustellung von Nachrichten bietet, indem zusätzliche Verfahren zur Bestätigung und zum Abschluss der Veröffentlichung verwendet werden (PUBREC, PUBREL, PUBCOMP).  Anwendbar für Situationen, in denen der Verlust und die Vervielfältigung von Daten von Sensoren ausgeschlossen werden müssen.  Wenn beispielsweise ein Alarm von einer empfangenen Nachricht ausgelöst wird, wird ein Notruf getätigt. <br><br>  Um eine schlechte Kommunikation zu simulieren, deaktivieren Sie beide Clients und versuchen Sie, eine Nachricht mit der höchsten QoS-Priorität zu senden. Fügen Sie außerdem die Option Beibehalten hinzu, damit die gesendete Nachricht auf dem Broker gespeichert wird. <br><br><pre> <code class="plaintext hljs">mosquitto_pub --retain --qos 2 -d --capath /etc/ssl/certs/ --url mqtt://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random -m "  !" Client mosq/Xwhua3GAyyY9mMd05V sending CONNECT Client mosq/Xwhua3GAyyY9mMd05V received CONNACK (0) Client mosq/Xwhua3GAyyY9mMd05V sending PUBLISH (d0, q2, r1, m1, 'habr/test/random', ... (37 bytes)) Client mosq/Xwhua3GAyyY9mMd05V received PUBREC (Mid: 1) Client mosq/Xwhua3GAyyY9mMd05V sending PUBREL (m1) Client mosq/Xwhua3GAyyY9mMd05V received PUBCOMP (Mid: 1, RC:0) Client mosq/Xwhua3GAyyY9mMd05V sending DISCONNECT</code> </pre><br>  Nach einiger Zeit konnte unser Empfänger nun endlich eine Verbindung zum Internet herstellen und eine Verbindung zum Broker herstellen: <br><br><pre> <code class="plaintext hljs">mosquitto_sub -d --capath /etc/ssl/certs/ -d --url mqtts://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random Client mosq/VAzcLVMB1MiWhYxoJS sending CONNECT Client mosq/VAzcLVMB1MiWhYxoJS received CONNACK (0) Client mosq/VAzcLVMB1MiWhYxoJS sending SUBSCRIBE (Mid: 1, Topic: habr/test/random, QoS: 0, Options: 0x00) Client mosq/VAzcLVMB1MiWhYxoJS received SUBACK Subscribed (mid: 1): 0 Client mosq/r6UwPnDvx8aNInpPF6 received PUBLISH (d0, q0, r1, m0, 'habr/test/random', ... (37 bytes))   !</code> </pre><br><h2>  Fazit </h2><br>  MQTT ist ein modernes, fortschrittliches Protokoll, das viele der Nachteile seiner Vorgänger nicht aufweist.  Dank seiner Flexibilität können Sie Clientgeräte hinzufügen, ohne einen Broker einzurichten, was erheblich Zeit spart.  Die Eingabeschwelle zum Verständnis und zur Konfiguration des Protokolls ist recht niedrig, und das Vorhandensein von Bibliotheken für viele Programmiersprachen ermöglicht es Ihnen, einen beliebigen Technologie-Stack für die Entwicklung auszuwählen.  Die Garantie für die Nachrichtenübermittlung unterscheidet MQTT erheblich von seinen Vorgängern und ermöglicht es Ihnen, keine Zeit damit zu verschwenden, Ihre eigenen Integritätskontrollmechanismen auf Netzwerkebene unnötig zu entwickeln. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452904/">https://habr.com/ru/post/de452904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452890/index.html">23. Mai, 18.30 Uhr - Live-Übertragung von QIWI Kitchen</a></li>
<li><a href="../de452892/index.html">Wie kann ein Nicht-Programmierer in die USA ziehen: Schritt-für-Schritt-Anleitung</a></li>
<li><a href="../de452894/index.html">Face Anti-Spoofing oder technologisch einen Betrüger von tausend Gesichtern erkennen</a></li>
<li><a href="../de452900/index.html">Indizes in PostgreSQL - 9 (BRIN)</a></li>
<li><a href="../de452902/index.html">Nach 4 Jahren Ausbildung zum Programmierer verstehe ich, dass ich weit von einem Programmierer entfernt bin</a></li>
<li><a href="../de452906/index.html">JavaScript-Engines: Wie funktionieren sie? Vom Call-Stack bis zu den Versprechungen (fast) alles, was Sie wissen müssen</a></li>
<li><a href="../de452908/index.html">Selenium WebDriver - Echtzeit-Testmetrik mit Grafana und InfluxDB</a></li>
<li><a href="../de452910/index.html">Hallo Habr! Hallo Tercon</a></li>
<li><a href="../de452914/index.html">ML auf der Scala mit einem Lächeln für diejenigen, die keine Angst vor Experimenten haben</a></li>
<li><a href="../de452916/index.html">Steh auf und geh. Wirbelsäulenchirurgie: Wann, was ist gefährlich?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>