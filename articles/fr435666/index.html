<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèΩ üç† ü§∏üèª D√©synchronisation asynchrone: antipatterns avec async / wait dans .NET üöµüèΩ üë©üèº‚Äçüîß ü§Æ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lequel d'entre nous ne tond pas? Je rencontre r√©guli√®rement des erreurs dans le code asynchrone et je les fais moi-m√™me. Pour arr√™ter cette roue de Sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©synchronisation asynchrone: antipatterns avec async / wait dans .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/435666/"><p>  Lequel d'entre nous ne tond pas?  Je rencontre r√©guli√®rement des erreurs dans le code asynchrone et je les fais moi-m√™me.  Pour arr√™ter cette roue de Samsara, je partage avec vous les jambages les plus typiques de ceux qui sont parfois assez difficiles √† attraper et √† r√©parer. </p><br><img src="https://habrastorage.org/webt/os/oz/lt/osozltujeowuulzfvdaxvehuvpg.png"><br><a name="habracut"></a><br><blockquote>  Ce texte est inspir√© du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog de Stephen Clary</a> , un homme qui sait tout sur la comp√©titivit√©, l'asynchronie, le multithreading et autres mots effrayants.  Il est l'auteur du livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Concurrency in C # Cookbook</a> , qui a rassembl√© un grand nombre de mod√®les pour travailler avec la concurrence. </blockquote><br><h2>  Blocage asynchrone classique </h2><br><p>  Pour comprendre le blocage asynchrone, il vaut la peine de d√©terminer quel thread ex√©cute la m√©thode invoqu√©e √† l'aide du mot cl√© wait. </p><br><p>  Tout d'abord, la m√©thode va plonger dans la cha√Æne d'appels de m√©thodes asynchrones jusqu'√† ce qu'elle rencontre une source d'asynchronie.  La fa√ßon dont la source d'asynchronie est impl√©ment√©e est un sujet qui d√©passe le cadre de cet article.  Maintenant, pour simplifier, nous supposons qu'il s'agit d'une op√©ration qui ne n√©cessite pas de flux de travail en attendant son r√©sultat, par exemple, une requ√™te de base de donn√©es ou une requ√™te HTTP.  Le d√©marrage synchrone d'une telle op√©ration signifie qu'en attendant son r√©sultat dans le syst√®me, il y aura au moins un thread endormi qui consomme des ressources mais ne fait aucun travail utile. </p><br><p> Dans un appel asynchrone, nous interrompons en quelque sorte le flux d'ex√©cution des commandes sur "avant" et "apr√®s" de l'op√©ration asynchrone, et dans .NET, il n'y a aucune garantie que le code qui se trouve apr√®s l'attente sera ex√©cut√© dans le m√™me thread que le code avant l'attente.  Dans la plupart des cas, cela n'est pas n√©cessaire, mais que faire lorsqu'un tel comportement est vital pour que le programme fonctionne?  Besoin d'utiliser <code>SynchronizationContext</code> .  Il s'agit d'un m√©canisme qui vous permet d'imposer certaines restrictions sur les threads dans lesquels le code est ex√©cut√©.  Ensuite, nous traiterons de deux contextes de synchronisation ( <code>WindowsFormsSynchronizationContext</code> et <code>AspNetSynchronizationContext</code> ), mais Alex Davis √©crit dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son livre</a> qu'il y en a environ une douzaine en .NET.  √Ä propos de <code>SynchronizationContext</code> bien √©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici, l'</a> auteur a impl√©ment√© le sien, pour lequel il a un grand respect. </p><br><p>  Ainsi, d√®s que le code arrive √† la source de l'asynchronie, il enregistre le contexte de synchronisation, qui √©tait dans la propri√©t√© statique du thread de <code>SynchronizationContext.Current</code> , puis l'op√©ration asynchrone d√©marre et lib√®re le thread actuel.  En d'autres termes, en attendant la fin de l'op√©ration asynchrone, nous ne bloquons pas un seul thread et c'est le principal b√©n√©fice de l'op√©ration asynchrone par rapport √† l'op√©ration synchrone.  Apr√®s avoir termin√© l'op√©ration asynchrone, nous devons suivre les instructions qui se trouvent apr√®s la source asynchrone, et ici, pour d√©cider dans quel thread ex√©cuter le code apr√®s l'op√©ration asynchrone, nous devons consulter le contexte de synchronisation enregistr√© pr√©c√©demment.  Comme il le dit, nous le ferons.  Il vous dira d'ex√©cuter dans le m√™me thread que le code avant d'attendre - nous ex√©cuterons dans le m√™me thread, ne dirons pas - nous prendrons le premier thread du pool. </p><br><p>  Mais que se passe-t-il si, dans ce cas particulier, il est important pour nous que le code apr√®s wait soit ex√©cut√© dans n'importe quel thread libre du pool de threads?  Vous devez utiliser le mantra <code>ConfigureAwait(false)</code> .  La fausse valeur transmise au param√®tre <code>continueOnCapturedContext</code> indique au syst√®me que n'importe quel thread du pool peut √™tre utilis√©.  Et que se passe-t-il si au moment de l'ex√©cution de la m√©thode avec wait, il n'y avait aucun contexte de synchronisation ( <code>SynchronizationContext.Current == null</code> ), comme par exemple dans une application console.  Dans ce cas, nous n'avons aucune restriction sur le thread dans lequel le code doit √™tre ex√©cut√© apr√®s attendre et le syst√®me prendra le premier thread du pool, comme dans le cas de <code>ConfigureAwait(false)</code> . </p><br><p>  Qu'est-ce qu'un blocage asynchrone? </p><br><h4>  Blocage dans WPF et WinForms </h4><br><p>  La diff√©rence entre les applications WPF et WinForms est le contexte de synchronisation m√™me.  Le contexte de synchronisation de WPF et WinForms a un thread sp√©cial - le thread d'interface utilisateur.  Il existe un thread d'interface utilisateur par <code>SynchronizationContext</code> et seul ce thread peut interagir avec les √©l√©ments de l'interface utilisateur.  Par d√©faut, le code qui a commenc√© √† fonctionner dans le thread d'interface utilisateur reprend son fonctionnement apr√®s une op√©ration asynchrone dans celui-ci. </p><br>  Voyons maintenant un exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br>  Que se passe-t-il lorsque vous appelez <code>StartWork().Wait()</code> : <br><br><ol><li>  Le thread appelant (et il s'agit du thread d'interface utilisateur) entrera dans la m√©thode <code>StartWork</code> et <code>StartWork</code> √† l' <code>await Task.Delay(100)</code> . </li><li>  Le thread d'interface utilisateur d√©marrera l'op√©ration asynchrone <code>Task.Delay(100)</code> , et il retournera le contr√¥le √† la m√©thode <code>Button_Click</code> , et l√†, la m√©thode <code>Wait()</code> de la classe <code>Task</code> l'attendra.  Lorsque la m√©thode <code>Wait()</code> est appel√©e, le thread d'interface utilisateur se bloquera jusqu'√† la fin de l'op√©ration asynchrone, et nous nous attendons √† ce que d√®s qu'il se termine, le thread d'interface utilisateur reprendra imm√©diatement l'ex√©cution et ira plus loin dans le code, cependant, tout ira mal. </li><li>  D√®s que <code>Task.Delay(100)</code> termin√©, le thread d'interface utilisateur devra d'abord continuer √† ex√©cuter la m√©thode <code>StartWork()</code> et pour cela, il a besoin exactement du thread dans lequel l'ex√©cution a commenc√©.  Mais le thread d'interface utilisateur attend maintenant le r√©sultat de l'op√©ration. </li><li>  <code>StartWork()</code> : <code>StartWork()</code> ne peut pas continuer l'ex√©cution et renvoyer le r√©sultat, et <code>Button_Click</code> attend le m√™me r√©sultat, et en raison du fait que l'ex√©cution a commenc√© dans le thread d'interface utilisateur, l'application se bloque simplement sans possibilit√© de continuer √† fonctionner. </li></ol><br>  Cette situation peut √™tre trait√©e tout simplement en changeant l'appel √† <code>Task.Delay(100)</code> en <code>Task.Delay(100).ConfigureAwait(false)</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br><p>  Ce code fonctionnera sans blocages, car maintenant un thread du pool peut √™tre utilis√© pour terminer la m√©thode <code>StartWork()</code> , plut√¥t qu'un thread d'interface utilisateur bloqu√©.  Stephen Clary recommande d'utiliser <code>ConfigureAwait(false)</code> dans toutes les ¬´m√©thodes de biblioth√®que¬ª de son blog, mais souligne sp√©cifiquement que l'utilisation de <code>ConfigureAwait(false)</code> pour traiter les blocages n'est pas une bonne pratique.  Au lieu de cela, il conseille de NE PAS utiliser de m√©thodes de blocage telles que <code>Wait()</code> , <code>Result</code> , <code>GetAwaiter().GetResult()</code> et de <code>GetAwaiter().GetResult()</code> toutes les m√©thodes pour utiliser async / wait, si possible (le soi-disant principe Async all the way). </p><br><h4>  Blocage dans ASP.NET </h4><br><p>  ASP.NET a √©galement un contexte de synchronisation, mais il a des limitations l√©g√®rement diff√©rentes.  Il vous permet d'utiliser un seul thread par demande √† la fois et requiert √©galement que le code apr√®s attente soit ex√©cut√© dans le m√™me thread que le code avant wait. </p><br>  Un exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HomeController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deadlock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StartWork().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the code following await"</span></span>; } }</code> </pre><br><p>  Ce code provoquera √©galement un blocage, car au moment de l'appel √† <code>StartWork().Wait()</code> seul thread autoris√© sera bloqu√© et attendra la <code>StartWork()</code> op√©ration <code>StartWork()</code> , et il ne se terminera jamais, car le thread dans lequel l'ex√©cution doit se poursuivre est occup√©. en attente. </p><br><p>  Tout cela est corrig√© par le m√™me <code>ConfigureAwait(false)</code> . </p><br><h4>  Blocage dans ASP.NET Core (en fait pas) </h4><br><p>  Essayons maintenant d'ex√©cuter le code de l'exemple pour ASP.NET dans le projet pour ASP.NET Core.  Si nous le faisons, nous verrons qu'il n'y aura pas d'impasse.  En effet, ASP.NET Core <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'a pas de contexte de synchronisation</a> .  Super!  Et maintenant, vous pouvez couvrir le code avec des appels bloquants et ne pas avoir peur des blocages?  Strictement parlant, oui, mais rappelez-vous que cela provoque l'endormissement du thread en attendant, c'est-√†-dire que le thread consomme des ressources, mais ne fait aucun travail utile. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/qe/hc/pvqehcevrmzzqhylr7vtedbqwtc.png"></div><br><br><p></p><blockquote>  <b>N'oubliez pas que l'utilisation des appels bloquants √©limine tous les avantages d'une programmation asynchrone en la transformant en synchrone</b> .  Oui, parfois sans utiliser <code>Wait()</code> cela ne fonctionnera pas pour √©crire un programme, mais la raison doit √™tre s√©rieuse. </blockquote><br><h2>  Utilisation erron√©e de Task.Run () </h2><br><p>  La m√©thode <code>Task.Run()</code> √©t√© cr√©√©e pour d√©marrer les op√©rations dans un nouveau thread.  Comme il sied √† une m√©thode √©crite dans un mod√®le TAP, elle retourne <code>Task</code> ou <code>Task&lt;T&gt;</code> et les personnes confront√©es √† async / wait pour la premi√®re fois ont un grand d√©sir d'envelopper le code synchrone dans <code>Task.Run()</code> et eutite le r√©sultat de cette m√©thode.  Le code semblait devenir asynchrone, mais en fait, rien n'a chang√©.  Voyons ce qui se passe avec cette utilisation de <code>Task.Run()</code> . </p><br>  Un exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteOperation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Before: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(() =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside before sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside after sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"After: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  Le r√©sultat de ce code sera: <br><br><pre> <code class="plaintext hljs">Before: 1 Inside before sleep: 3 Inside after sleep: 3 After: 3</code> </pre><br><p>  Ici, <code>Thread.Sleep(1000)</code> est une sorte d'op√©ration synchrone qui n√©cessite un thread pour se terminer.  Supposons que nous voulons rendre notre solution asynchrone et que cette op√©ration puisse √™tre euthanasi√©e, nous l'avons envelopp√©e dans <code>Task.Run()</code> . </p><br><p>  D√®s que le code atteint la m√©thode <code>Task.Run()</code> , un autre thread est extrait du pool de threads et le code que nous avons transmis √† <code>Task.Run()</code> est ex√©cut√©.  L'ancien thread, comme il sied √† un thread d√©cent, retourne dans le pool et attend qu'il soit √† nouveau appel√© pour effectuer le travail.  Le nouveau thread ex√©cute le code transmis, atteint l'op√©ration synchrone, l'ex√©cute de mani√®re synchrone (attend que l'op√©ration soit termin√©e) et va plus loin dans le code.  En d'autres termes, l'op√©ration est rest√©e synchrone: nous utilisons, comme pr√©c√©demment, le flux lors de l'ex√©cution de l'op√©ration synchrone.  La seule diff√©rence est que nous avons pass√© du temps √† changer de contexte lors de l'appel de <code>Task.Run()</code> et du retour √† <code>ExecuteOperation()</code> .  Tout est devenu un peu pire. </p><br><p>  Il faut comprendre que malgr√© le fait que dans les lignes <code>Inside after sleep: 3</code> et <code>After: 3</code> nous voyons le m√™me Id du flux, le contexte d'ex√©cution est compl√®tement diff√©rent √† ces endroits.  ASP.NET est simplement plus intelligent que nous et essaie d'√©conomiser des ressources lors du changement de contexte du code √† l'int√©rieur de <code>Task.Run()</code> vers du code externe.  Ici, il a d√©cid√© de ne pas modifier au moins le flux d'ex√©cution. </p><br><p>  Dans de tels cas, cela n'a aucun sens d'utiliser <code>Task.Run()</code> .  Au lieu de cela, Clary <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conseille de</a> rendre toutes les op√©rations asynchrones, c'est-√†-dire, dans notre cas, de remplacer <code>Thread.Sleep(1000)</code> par <code>Task.Delay(1000)</code> , mais cela, bien s√ªr, n'est pas toujours possible.  Que faire dans les cas o√π nous utilisons des biblioth√®ques tierces que nous ne pouvons pas ou ne voulons pas r√©√©crire et rendre asynchrones √† la fin, mais pour une raison ou une autre, nous avons besoin de la m√©thode async?  Il est pr√©f√©rable d'utiliser <code>Task.FromResult()</code> pour <code>Task.FromResult()</code> le r√©sultat des m√©thodes de fournisseur dans Task.  Bien s√ªr, cela ne rendra pas le code asynchrone, mais nous √©conomiserons au moins sur le changement de contexte. </p><br><p></p><blockquote>  <b>Pourquoi alors utiliser Task.Run ()?</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La r√©ponse est simple:</a> pour les op√©rations li√©es au processeur, lorsque vous devez maintenir la r√©activit√© de l'interface utilisateur ou parall√©liser les calculs.  Il faut dire ici que les op√©rations li√©es au CPU sont de nature synchrone.  C'est pour lancer des op√©rations synchrones dans un style asynchrone que <code>Task.Run()</code> √©t√© invent√©. </blockquote><br><h2>  Utilisation abusive de l'async void </h2><br>  La possibilit√© d'√©crire des m√©thodes asynchrones qui retournent <code>void</code> √©t√© ajout√©e afin d'√©crire des gestionnaires d'√©v√©nements asynchrones.  Voyons pourquoi ils peuvent pr√™ter √† confusion s'ils sont utilis√©s √† d'autres fins: <br><br><ol><li>  Vous ne pouvez pas attendre le r√©sultat. </li><li>  La gestion des exceptions via try-catch n'est pas prise en charge. </li><li>  Il est impossible de combiner des appels via <code>Task.WhenAll()</code> , <code>Task.WhenAny()</code> et d'autres m√©thodes similaires. </li></ol><br><p>  De toutes ces raisons, le point le plus int√©ressant est le traitement des exceptions.  Le fait est que dans les m√©thodes asynchrones qui renvoient <code>Task</code> ou <code>Task&lt;T&gt;</code> , les exceptions sont intercept√©es et envelopp√©es dans un objet <code>Task</code> , qui sera ensuite transmis √† la m√©thode appelante.  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son article MSDN,</a> Clary √©crit que puisqu'il n'y a pas de valeur de retour dans les m√©thodes async-void, il n'y a rien pour encapsuler les exceptions et elles sont lev√©es directement dans le contexte de la synchronisation.  Le r√©sultat est une exception non g√©r√©e en raison de laquelle le processus se bloque, ayant le temps, peut-√™tre, d'√©crire une erreur sur la console.  Vous pouvez obtenir et r√©server ces exceptions en vous abonnant √† l'√©v√©nement <code>AppDomain.UnhandledException</code> , mais vous ne pourrez plus arr√™ter le plantage du processus m√™me dans le gestionnaire de cet √©v√©nement.  Ce comportement est typique du gestionnaire d'√©v√©nements, mais pas de la m√©thode habituelle, √† partir de laquelle nous nous attendons √† une gestion standard des exceptions via try-catch. </p><br>  Par exemple, si vous √©crivez comme ceci dans une application ASP.NET Core, le processus est garanti de tomber: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowInAsyncVoid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ThrowAsynchronously(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowAsynchronously</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Obviously, something happened"</span></span>); }</code> </pre><br><p>  Mais cela vaut la peine de changer le type de retour de la m√©thode <code>ThrowAsynchronously</code> en <code>Task</code> (sans m√™me ajouter le mot-cl√© <code>ThrowAsynchronously</code> ) et l'exception sera intercept√©e par le gestionnaire d'erreurs ASP.NET Core standard, et le processus continuera √† vivre malgr√© l'ex√©cution. </p><br><p></p><blockquote>  <b>Soyez prudent avec les m√©thodes async-void</b> - elles peuvent vous mettre dans le processus. </blockquote><br><h2>  attendre en une seule ligne </h2><br><p>  Le dernier contre-mod√®le n'est pas aussi effrayant que les pr√©c√©dents.  L'essentiel est qu'il n'a aucun sens d'utiliser async / wait dans des m√©thodes qui, par exemple, transmettent simplement le r√©sultat d'une autre m√©thode async, √† l'exception possible de l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wait dans using</a> . </p><br>  Au lieu de ce code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br>  il serait tout √† fait possible (et de pr√©f√©rence) d'√©crire: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br><p>  Pourquoi √ßa marche?  Parce que le mot cl√© wait peut √™tre appliqu√© aux objets de type t√¢che, et non aux m√©thodes marqu√©es avec le mot cl√© async.  √Ä son tour, le mot cl√© async indique simplement au compilateur que cette m√©thode doit √™tre d√©ploy√©e sur une machine d'√©tat, et toutes les valeurs retourn√©es doivent √™tre encapsul√©es dans une <code>Task</code> (ou dans un autre objet de type t√¢che). </p><br><p>  En d'autres termes, le r√©sultat de la premi√®re version de la m√©thode est <code>Task</code> , qui deviendra <code>Completed</code> d√®s que l'attente de <code>Task.Delay(1000)</code> se termine, et le r√©sultat de la deuxi√®me version de la m√©thode est <code>Task</code> , renvoy√© par <code>Task.Delay(1000)</code> - <code>Task.Delay(1000)</code> , qui deviendra <code>Completed</code> d√®s 1000 millisecondes. . </p><br><p>  Comme vous pouvez le voir, les deux versions sont √©quivalentes, mais en m√™me temps, la premi√®re n√©cessite beaucoup plus de ressources pour cr√©er un ¬´kit carrosserie¬ª asynchrone. </p><br><p></p><blockquote>  Alex Davis √©crit que le <b>co√ªt de l'invocation directe de la m√©thode asynchrone peut √™tre dix fois sup√©rieur √† celui de l'invocation de la m√©thode synchrone</b> , donc il y a quelque chose √† essayer. </blockquote><br><br>  <b>UPD:</b> <br>  Comme le soulignent √† juste titre les commentaires, le fait de scinder asynchrone / attendre des m√©thodes √† ligne unique entra√Æne des effets secondaires n√©gatifs.  Par exemple, lors du lancement d'une exception, la m√©thode qui l√®ve Task vers le haut ne sera pas visible dans la pile.  Par cons√©quent, la <b>suppression des valeurs par d√©faut n'est pas recommand√©e par d√©faut</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Message de Clary</a> avec analyse. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435666/">https://habr.com/ru/post/fr435666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435652/index.html">Comment ne pas mots de passe dans les scripts Python</a></li>
<li><a href="../fr435654/index.html">Pi√®ges des propri√©t√©s CSS personnalis√©es</a></li>
<li><a href="../fr435656/index.html">Scooter Rolls Royce - Ninebot KickScooter ES4 par Segway</a></li>
<li><a href="../fr435662/index.html">¬´Fiabilit√© et fiabilit√© comme dans Google¬ª - et pas seulement: traduction de l'article ¬´Calcul de la fiabilit√© du service¬ª</a></li>
<li><a href="../fr435664/index.html">Usurpation de moteur de recherche Google</a></li>
<li><a href="../fr435668/index.html">Autre loi du printemps: le d√©put√© a propos√© de permettre √† la police de suivre la localisation des enfants gr√¢ce √† la g√©olocalisation</a></li>
<li><a href="../fr435670/index.html">Algorithme supr√™me - r√©partition des algorithmes par niveau de difficult√©</a></li>
<li><a href="../fr435672/index.html">Comment se recycler en intelligence d'affaires</a></li>
<li><a href="../fr435678/index.html">Ne faites pas confiance aux informations sur la m√©moire dans le Gestionnaire des t√¢ches</a></li>
<li><a href="../fr435680/index.html">AWS a montr√© le doigt du milieu open source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>