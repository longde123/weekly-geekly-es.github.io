<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóëÔ∏è üë©üèø‚Äçüéì üë©üèø‚Äçü§ù‚Äçüë©üèΩ Math√©matiques √† virgule fixe rapides pour les applications financi√®res en Java üïñ üë©‚Äçüë¶ üç©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce n'est un secret pour personne que les informations financi√®res (comptes, √©critures et autres livres comptables) ne sont pas tr√®s conviviales avec l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Math√©matiques √† virgule fixe rapides pour les applications financi√®res en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425565/"><p>  Ce n'est un secret pour personne que les informations financi√®res (comptes, √©critures et autres livres comptables) ne sont pas tr√®s conviviales avec les nombres √† virgule flottante, et de nombreux articles recommandent d'utiliser une arithm√©tique √† virgule fixe.  En Java, ce format n'est en fait repr√©sent√© que par la classe BigDecimal, qui ne peut pas toujours √™tre utilis√©e pour des raisons de performances.  Nous devons chercher des alternatives.  Cet article d√©crit une biblioth√®que Java auto-√©crite pour effectuer des op√©rations arithm√©tiques sur des nombres √† pr√©cision fixe.  La biblioth√®que a √©t√© cr√©√©e pour fonctionner dans des applications financi√®res hautes performances et vous permet de travailler avec une pr√©cision de 9 d√©cimales tout en conservant des performances acceptables.  Un lien vers les sources et les r√©f√©rences est donn√© √† la fin de l'article. </p><a name="habracut"></a><br><h1 id="arifmetika-s-plavayuschey-tochkoy">  Arithm√©tique en virgule flottante </h1><br><p>  Les ordinateurs modernes ne peuvent effectuer des op√©rations arithm√©tiques qu'avec une pr√©cision limit√©e.  Ce sont des appareils discrets qui peuvent ne pas fonctionner avec tous les nombres possibles, mais seulement avec certains sous-ensembles d√©nombrables d'entre eux.  Le format le plus courant pour travailler avec des nombres r√©els dans la m√©moire de l'ordinateur est un point flottant (binaire) - flottant (binaire), lorsque les nombres sont stock√©s sous la forme M * 2 ^ E, o√π M et E sont des mantisses enti√®res et l'ordre du nombre.  Mais certains nombres, tels que 0,1, ne peuvent pas √™tre repr√©sent√©s avec pr√©cision dans ce format.  Par cons√©quent, au cours de calculs complexes, certaines erreurs s'accumulent in√©vitablement.  Autrement dit, le r√©sultat du calcul de la machine, par exemple 0,1 + 0,1 + 0,1, ne co√Øncide pas avec le 0,3 math√©matiquement correct.  Compte tenu de ce qui pr√©c√®de, lors de la programmation d'une arithm√©tique complexe, vous pouvez suivre plusieurs strat√©gies: </p><br><p>  Strat√©gie 1 - ignorer.  Ne faites pas attention √† l'erreur, consid√©rez toutes les op√©rations comme math√©matiques id√©ales et esp√©rez que la pr√©cision disponible est suffisante pour des r√©sultats acceptables.  L'option la plus courante. </p><br><p>  Strat√©gie 2 - calculer m√©ticuleusement.  Les formules de calcul des erreurs machine sont connues depuis des d√©cennies.  Ils permettent d'estimer par dessus l'erreur relative de toute op√©ration arithm√©tique.  C'est probablement ce que vous devez faire pour une simulation num√©rique s√©rieuse.  Le probl√®me est que cela prend beaucoup de temps.  En effet, chaque caract√®re + - * / du code doit √™tre accompagn√© d'un calcul d'erreur.  Vous devez prendre en compte toutes les d√©pendances entre les calculs et r√©p√©ter la proc√©dure √† chaque fois que vous modifiez le code. </p><br><p>  Strat√©gie 3 - utilisez un point d√©cimal (point d√©cimal flottant) au lieu du binaire.  Autrement dit, stockez les nombres sous la forme M * 10 ^ E.  Cela ne r√©sout pas les probl√®mes d'erreur (la mantisse est toujours arrondie √† un nombre fini de chiffres significatifs), mais au moins tous les nombres ¬´simples¬ª pour une personne (comme 1.1) sont maintenant repr√©sent√©s avec pr√©cision dans la m√©moire.  Le retour sur investissement sera la performance.  Toute normalisation des nombres (c'est-√†-dire une diminution √©quivalente de la mantisse et une augmentation de l'ordre) n√©cessite une division par une puissance de 10, ce qui n'est pas tr√®s rapide, contrairement √† une division par une puissance de 2. Et vous devez normaliser beaucoup - √† chaque addition ou soustraction avec des ordres diff√©rents. </p><br><p>  Strat√©gie 4 - utilisez un point fixe (point d√©cimal fixe).  Simplification de la strat√©gie 3, lorsque nous fixons l'ordre E. Dans ce cas, la normalisation n'est pas n√©cessaire pour l'addition / soustraction.  De plus, tous les calculs auront la m√™me erreur absolue.  Cet article est consacr√© √† cette strat√©gie. </p><br><h1 id="arifmetika-s-fiksirovannoy-tochkoy">  Arithm√©tique √† virgule fixe </h1><br><p>  Contrairement √† la physique, o√π l'erreur relative est importante, un absolu suffit en finance.  Si, apr√®s une transaction financi√®re complexe, le client est factur√© 1 000 000,23 $ alors qu'il attend 1 000 000,18 $, des difficult√©s peuvent survenir.  Des explications telles que "pourquoi avez-vous besoin d'une pr√©cision √† 8 chiffres significatifs ??"  ne peut pas rouler.  Et il ne s'agit pas ici de 5 centimes de perte (√† se tromper au contraire, ¬´en faveur¬ª du client n'est pas beaucoup mieux), mais des incoh√©rences comptables.  Par cons√©quent, les r√®gles de calcul et d'arrondi sont clairement sp√©cifi√©es entre les parties, et les artefacts li√©s √† l'utilisation de variables doubles et flottantes compliquent parfois la vie. </p><br><p>  Java a une classe standard pour l'arithm√©tique √† virgule fixe - BigDecimal.  Elle pr√©sente deux probl√®mes: elle est lente (en raison de son universalit√©) et elle n'est pas stable.  La non-stabilit√© signifie que toute op√©ration alloue un objet sur le tas.  La s√©lection et la lib√©ration en termes d'un objet prennent un peu de temps, mais des calculs intensifs dans le code ¬´chaud¬ª cr√©ent une charge d√©cente sur le GC, ce qui est inacceptable dans certains cas.  Vous pouvez compter sur l'analyse d'√©chappement et la scalarisation, mais elles sont tr√®s instables dans le sens o√π m√™me un l√©ger changement dans le code ou dans le JIT (tel que le chargement paresseux d'une nouvelle impl√©mentation d'interface) peut bouleverser la structure en ligne enti√®re, et la m√©thode a bien fonctionn√© il y a une minute, commence soudainement √† allouer furieusement la m√©moire. <br>  UPD en raison de questions dans les commentaires: <strong>La principale raison de l'</strong> abandon de BigDecimal et BigInteger n'est pas du tout les faibles performances de calcul, mais le manque de stabilit√© et de s√©lection des objets. </p><br><p>  La biblioth√®que d√©crite est le r√©sultat d'√™tre fatigu√© de r√©√©crire √† partir de z√©ro l'arithm√©tique non m√©moire √† virgule fixe pour chaque nouvel employeur, et j'ai d√©cid√© d'√©crire ma propre biblioth√®que pour une externalisation ult√©rieure. </p><br><p>  Je vais imm√©diatement montrer un exemple d'utilisation avant de passer aux d√©tails d'impl√©mentation: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Decimal margin; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity contraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumContraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price priceWithMargin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price avgPrice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> marginBp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 + margin / 10000 this.margin = Decimal.create(marginBp).divRD(10000L).add(1); } public Price calculateAvgPrice(Quantity[] quantities, Price[] prices) { cumQuantity.set(0); contraQuantity.set(0); // avg = sum(q * p * margin) / sum(q) for (int i = 0; i &lt; quantities.length; i++) { cumQuantity.add(quantities[i]); priceWithMargin.set(prices[i]).mulRD(margin); contraQuantity.set(quantities[i]).mulRD(priceWithMargin); cumContraQuantity.add(contraQuantity); } return avgPrice.quotientRD(cumContraQuantity, cumQuantity); } public static void main(String[] args) throws ParseException { Price p1 = Price.create("1.5"); Price p2 = Price.create(1.6); Quantity q1 = Quantity.create("100"); Quantity q2 = Quantity.create(200); // apply 0.05% margin to the prices Sample sample = new Sample(5); System.out.println(sample.calculateAvgPrice(new Quantity[]{q1, q2}, new Price[]{p1, p2})); } }</span></span></code> </pre> <br><h1 id="ideya-realizacii">  Id√©e de mise en ≈ìuvre </h1><br><p>  Donc, nous avons besoin d'un wrapper mutable d'une primitive enti√®re, plus pr√©cis√©ment, d'un long'a, qui nous donnera pr√®s de 19 chiffres significatifs (assez pour l'entier et la partie fractionnaire).  En long, nous entendons N d√©cimales.  Par exemple, avec N = 2, le nombre 2,56 est stock√© sous la forme 256 (binaire 100000000).  Les nombres n√©gatifs sont stock√©s en standard, dans un code suppl√©mentaire: </p><br><p>  <em>-2,56</em> <br>  <strong>-256</strong> </p><br><p>  (Ci-apr√®s, l' <em>italique</em> indique les nombres et calculs ¬´math√©matiques¬ª, et <strong>en gras</strong> leur repr√©sentation interne) </p><br><p>  Il m'a √©galement sembl√© utile de saisir NaN en tant que valeur distincte, qui est renvoy√©e en cas d'erreurs arithm√©tiques (au lieu d'une exception ou d'ordures).  <em>NaN</em> est repr√©sent√© en interne par <strong>Long.MIN_VALUE</strong> , ¬´propag√©¬ª √† travers toutes les op√©rations et permet de d√©terminer l'inversion de signe pour tous les nombres restants. </p><br><p>  Essayons d'estimer les algorithmes d'op√©rations arithm√©tiques pour le cas o√π N = 2. </p><br><p>  L'addition et la soustraction ne n√©cessitent aucun geste suppl√©mentaire, utilisez simplement les valeurs telles qu'elles sont: </p><br><p>  <em>1,20 + 2,30 = 3,50</em> <br>  <strong>120 + 230 = 350</strong> </p><br><p>  La multiplication et la division n√©cessitent une normalisation suppl√©mentaire, c'est-√†-dire une multiplication / division par 10 ^ N (par 100 dans notre exemple) </p><br><p>  <em>1,20 * 2,00 = 2,40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  <em>1,20 / 2,00 = 0,60</em> <br>  <strong>100 * 120/200 = 60</strong> </p><br><p>  La division suppl√©mentaire n'est pas l'op√©ration la plus rapide.  Mais dans ce cas, il s'agit d'une division par une constante, car nous avons pr√©c√©demment fix√© N = 2 et 10 ^ N = 100.  La division par constante, notamment par ¬´belle¬ª (type 10), est intensivement optimis√©e dans le CPU et beaucoup plus rapide que la division par un nombre al√©atoire.  Nous effectuons beaucoup de divisions par 10 chaque fois que nous convertissons un nombre en cha√Æne (par exemple, dans les journaux), et les fabricants de CPU le savent ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour plus de d√©tails sur l'optimisation,</a> voir "Division par une constante"). </p><br><p>  Pour consolider la compr√©hension de ce que nous faisons, je donnerai une op√©ration de plus: l'inversion unaire d'un nombre, c'est-√†-dire 1 / x.  Ceci est un cas particulier de division, il vous suffit de soumettre 1,00 dans notre format et n'oubliez pas de normaliser: </p><br><p>  <em>1,00 / 2,00 = 0,50</em> <br>  <strong>100 * 100/200 = 50</strong> </p><br><p>  Eh bien, alors que tout est assez simple, essayons de plonger dans les d√©tails. </p><br><h1 id="okruglenie">  Arrondi </h1><br><p>  Essayons de tirer un autre nombre: </p><br><p>  <em>1,00 / 3,00 = 0,33</em> <br>  <strong>100 * 100/300 = 33</strong> </p><br><p>  Un r√©sultat math√©matique honn√™te se situe entre 0,33 et 0,34, mais nous ne pouvons pas l'imaginer exactement.  Quelle fa√ßon d'arrondir?  G√©n√©ralement arrondi √† 0, et c'est le moyen le plus rapide (mat√©riel pris en charge).  Mais, revenant √† de vrais probl√®mes financiers, ce n'est pas toujours le cas.  En r√®gle g√©n√©rale, lors du traitement des transactions avec un client, l'arrondi est "en faveur du client".  Autrement dit, le prix est arrondi vers le haut si le client vend, et vers le bas si le client ach√®te.  Mais d'autres options peuvent √™tre n√©cessaires, par exemple, l'arrondissement arithm√©tique au nombre le plus proche avec des sous-types (mi-haut, mi-bas, mi-pair) pour minimiser les incoh√©rences comptables.  Ou arrondi √† ¬± infini pour les prix n√©gatifs (pour certains instruments financiers).  Java BigDecimal contient d√©j√† une liste de modes d'arrondi standard, et la biblioth√®que d√©crite les prend en charge tous.  UNNECESSARY renvoie NaN si l'op√©ration n√©cessite de mani√®re inattendue l'arrondi. </p><br><p>  En mode arrondi, notre calcul devrait donner: </p><br><p>  <em>1,00 / 3,00 = 0,34</em> <br>  <strong>100 * 100/300 + 1 = 34</strong> </p><br><p>  Comment savoir ce dont vous avez besoin pour ajouter une unit√©?  Vous avez besoin du reste de la division 10 000% 300 = 100. Ce qui est aussi lent que la division elle-m√™me.  Heureusement, si vous √©crivez dans une ligne dans le code "a / b; a% b", alors JIT se rendra compte que 2 divisions ne sont pas n√©cessaires, juste une commande div d'assembleur qui retourne 2 nombres (quotient et reste). </p><br><p>  Les autres options d'arrondi sont un peu plus compliqu√©es, mais peuvent √©galement √™tre calcul√©es en fonction du reste et du diviseur. </p><br><p>  Dans l'API, j'ai fait intentionnellement une mention d'arrondi partout o√π il se produit, soit en tant que param√®tre, soit en tant que suffixe Round <strong>D</strong> dans les m√©thodes o√π il est d√©fini par d√©faut sur z√©ro. </p><br><h1 id="perepolnenie">  D√©bordement </h1><br><p>  Nous arrivons √† la partie la plus difficile.  Rappelons encore notre multiplication: </p><br><p>  <em>1,20 * 2,00 = 2,40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  Imaginez maintenant que nous sommes dans les ann√©es 80 et que nous avons des processeurs 16 bits.  Autrement dit, seul le short est √† notre disposition avec une valeur maximale de 65535. La premi√®re multiplication d√©bordera et sera √©gale √† 240000 &amp; 0xFFFF = 44392 (si elle n'est pas sign√©e, avec un signe, elle sera √©galement n√©gative), ce qui cassera le r√©sultat pour nous. </p><br><p>  √áa ne marchera pas.  Nous avons 2 arguments normaux (adapt√©s √† notre plage de valeurs) et le m√™me r√©sultat normal attendu, mais nous d√©bordons √† mi-chemin.  La m√™me situation exacte est possible avec un long'om 64 bits, seuls les nombres ont besoin de plus. </p><br><p>  Dans les ann√©es 80, nous aurions besoin d'une multiplication donnant un r√©sultat 32 bits.  Aujourd'hui, nous avons besoin d'une multiplication avec un r√©sultat de 128 bits.  Le plus ennuyeux est que les deux multiplications sont disponibles dans les assembleurs 8086 et x86-64, respectivement, mais nous ne pouvons pas les utiliser depuis Java!  JNI, m√™me dans le cas d'un hack avec JavaCritical rapide, donne un surco√ªt de dizaines de nanosecondes, introduit des difficult√©s de d√©ploiement et de compatibilit√©, fige le GC pendant la dur√©e de l'appel.  De plus, il nous faudrait en quelque sorte renvoyer un r√©sultat 128 bits √† partir de la m√©thode native, et l'√©criture par r√©f√©rence √† un tableau (en m√©moire) est un d√©lai suppl√©mentaire. </p><br><p>  En g√©n√©ral, je devais √©crire la multiplication et la division manuelles.  Colonne  J'avais besoin de 2 op√©rations auxiliaires: </p><br><ol><li>  A (64) * B (64) = T (128);  T (128) / N (32) = Q (64), R (32) - dans le cadre du point de multiplication fixe A * B </li><li>  N (32) * A (64) = T (96);  T (96) / B (64) = Q (64), R (64) - dans le cadre de la division des points fixes A / B <br>  (entre parenth√®ses indique la dimension des donn√©es en bits, T est une variable temporaire qui ne doit pas √™tre d√©bord√©e) </li></ol><br><p>  Les deux op√©rations renvoient le quotient et le reste (l'un r√©sultant de la m√©thode, le second dans le champ objet).  Ils peuvent √©galement d√©border, mais uniquement √† la derni√®re √©tape, lorsque cela est in√©vitable.  Voici un exemple (des ann√©es 1980): </p><br><p>  <em>500,00 / 0,50 = 1000,00</em> <br>  <strong>100 * 50 000/50 = 100 000</strong> - d√©bordement! </p><br><p>  La division des colonnes √† la Knut n'est pas l'algorithme le plus simple.  De plus, il devrait √©galement √™tre relativement rapide.  Par cons√©quent, le code des deux op√©rations est des centaines de lignes de magie un peu s√©v√®re, il me faudra beaucoup de temps pour me rappeler √† nouveau ce qui se passe exactement l√†-bas.  Je les ai amen√©s dans une classe s√©par√©e et j'ai comment√© en d√©tail autant que possible. </p><br><p>  L'algorithme de multiplication n'est pas limit√© √† l'appel de l'op√©ration 1, mais le code restant n'est pas si compliqu√© et ajoute simplement la prise en charge des nombres n√©gatifs, de l'arrondi et de NaN. </p><br><p>  Habituellement (sauf cas particuliers), les deux op√©rations contiennent 4 multiplications et 2 divisions.  L'op√©ration 1 est nettement plus rapide que 2, car en elle ces divisions se font par une constante. </p><br><p>  Soit dit en passant, si quelqu'un l'a remarqu√©, N (32) est notre 10 ^ N pour la normalisation.  Il est de 32 bits, d'o√π il r√©sulte que N peut √™tre un maximum de 9. Dans les applications r√©elles que j'ai vues, 2, 4 ou 8 d√©cimales ont √©t√© utilis√©es.  Je n'en ai pas vu plus de 9, cela devrait donc suffire.  Si vous faites 10 ^ N 64 bits, le code devient plus compliqu√© (et ralentit) encore plus. </p><br><h1 id="neskolko-raznyh-tochnostey">  Plusieurs pr√©cision diff√©rentes </h1><br><p>  Parfois, il est n√©cessaire d'effectuer une op√©ration sur des arguments avec un nombre diff√©rent de d√©cimales.  Saisissez au minimum les op√©rations impliquant la dur√©e habituelle. </p><br><p>  Par exemple: </p><br><p>  <em>2 000 (N = 4) + 3,00 (N = 2) = 5,0000 (N = 4)</em> <br>  <strong>20 000 + 300 * 100 = 50 000</strong> </p><br><p>  <em>3,00 (N = 2) + 2 000 (N = 4) = 5,00 (N = 2)</em> <br>  <strong>300 + 20 000/100 = 500</strong> </p><br><p>  Dans ce cas, une normalisation suppl√©mentaire de l'un des arguments est requise.  Notez que math√©matiquement les deux op√©rations sont √©quivalentes, mais en raison de la pr√©cision diff√©rente du r√©sultat, elles sont calcul√©es diff√©remment.  Il convient √©galement de noter que la deuxi√®me op√©ration n√©cessite g√©n√©ralement un arrondi. </p><br><p>  Le nombre de d√©cimales n'est PAS stock√© dans l'objet.  Au lieu de cela, une sous-classe distincte est suppos√©e pour chaque pr√©cision.  Les noms de classe peuvent √™tre orient√©s m√©tier, par exemple Prix (N = 8), Quantit√© (N = 2).  Et ils peuvent √™tre g√©n√©ralis√©s: Decimal1, Decimal2, Decimal3, ... Plus la pr√©cision est grande, plus la plage de valeurs stock√©es est petite, la plage minimale a Decimal9: ¬± 9223372036.  On suppose qu'une ou deux classes suffiront pour couvrir les fonctionnalit√©s n√©cessaires, auquel cas la m√©thode abstraite getScale sera tr√®s probablement d√©virtualis√©e et int√©gr√©e.  Les sous-classes (au lieu d'un champ suppl√©mentaire) vous permettent de typifier strictement la pr√©cision des arguments et des r√©sultats, ainsi que de signaler les arrondis possibles au stade de la compilation. </p><br><p>  La biblioth√®que permet des op√©rations avec un maximum de 2 (mais pas 3) de pr√©cision diff√©rente.  Autrement dit, soit l'exactitude des deux arguments doit co√Øncider, soit l'exactitude de l'un des arguments et du r√©sultat.  Encore une fois, la prise en charge de 3 pr√©cisions diff√©rentes ralentirait consid√©rablement le code et compliquerait l'API.  Comme arguments, vous pouvez passer un long r√©gulier, pour lequel une pr√©cision de N = 0 est suppos√©e. </p><br><p>  <em>2.0000 / 3.0 = 0.6667</em> - ok (2 pr√©cision diff√©rente) <br>  <em>2/3 = 0,6667</em> - ok (arguments longs, r√©sultat d√©cimal) <br>  <em>2 / 3,0 = 0,6667</em> - impossible!  (3 pr√©cision diff√©rente) </p><br><h1 id="dostoinstva-i-nedostatki">  Avantages et inconv√©nients </h1><br><p>  De toute √©vidence, le calcul √† haut bit effectu√© par la biblioth√®que est plus lent que celui pris en charge par le mat√©riel.  Cependant, les frais g√©n√©raux ne sont pas si importants (voir les rep√®res ci-dessous). </p><br><p>  De plus, en raison du manque de surcharge des op√©rateurs en Java, l'utilisation de m√©thodes au lieu d'op√©rateurs arithm√©tiques complique la perception du code. </p><br><p>  Sur cette base, la biblioth√®que est g√©n√©ralement utilis√©e dans des endroits o√π la perte de pr√©cision absolue est critique.  Par exemple, calculer des statistiques financi√®res pr√©cises, en tenant compte des indicateurs financiers actuels (positions de n√©gociation, PnL, ordres ex√©cut√©s).  Dans l'√©change r√©seau d'informations financi√®res entre les syst√®mes, il est √©galement plus pratique d'utiliser des formats avec un point d√©cimal (au lieu de binaire). </p><br><p>  Les algorithmes math√©matiques complexes (mod√©lisation, statistiques, pr√©visions) sont g√©n√©ralement plus faciles √† r√©aliser de mani√®re standard en double, car leur r√©sultat n'est en tout cas pas absolument pr√©cis. </p><br><h1 id="kod-i-benchmarki">  Code et rep√®res </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code</a> </p><br><table><tbody><tr><th>  Benchmark </th><th>  Le mode </th><th>  Cnt </th><th>  Score </th><th>  Erreur </th><th>  Unit√©s <br></th></tr><tr><td>  DecimalBenchmark.control </td><td>  avgt </td><td>  200 </td><td>  10.072 </td><td>  ¬± 0,074 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyNative </td><td>  avgt </td><td>  200 </td><td>  10,625 </td><td>  ¬± 0,142 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyMyDecimal </td><td>  avgt </td><td>  200 </td><td>  35,840 </td><td>  ¬± 0,121 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyBigDecimal </td><td>  avgt </td><td>  200 </td><td>  126.098 </td><td>  ¬± 0,408 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientNative </td><td>  avgt </td><td>  200 </td><td>  70,728 </td><td>  ¬± 0,230 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientMyDecimal </td><td>  avgt </td><td>  200 </td><td>  138,581 </td><td>  ¬± 7,102 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientBigDecimal </td><td>  avgt </td><td>  200 </td><td>  179,650 </td><td>  ¬± 0,849 </td><td>  ns / op <br></td></tr></tbody></table><br><p>  En g√©n√©ral, la multiplication est 4 fois plus rapide que BigDecimal, la division est de 1,5.  Le taux de division d√©pend <em>fortement</em> des arguments, d'o√π la dispersion des valeurs. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425565/">https://habr.com/ru/post/fr425565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425555/index.html">Charles Nutter sur les langages dynamiques dans la JVM sur jug.msk.ru</a></li>
<li><a href="../fr425557/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 10: Ex√©cution symbolique, partie 1</a></li>
<li><a href="../fr425559/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 10: Ex√©cution symbolique, partie 3</a></li>
<li><a href="../fr425561/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 10: Ex√©cution symbolique, partie 2</a></li>
<li><a href="../fr425563/index.html">La Californie interdit la vente d'appareils IoT avec ou sans mots de passe simples</a></li>
<li><a href="../fr425569/index.html">Test fonctionnel PCB</a></li>
<li><a href="../fr425571/index.html">S√©curiser un serveur Web sous Linux</a></li>
<li><a href="../fr425575/index.html">Neuroinflammation</a></li>
<li><a href="../fr425581/index.html">Jetpack 11 octobre 1961: le pr√©sident ouvre la bouche ...</a></li>
<li><a href="../fr425583/index.html">Tout ce qui d√©route encore les robots, √† commencer par les mouettes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>