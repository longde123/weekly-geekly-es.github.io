<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏿 ⏲️ 👼 "Rahasia" DPAPI atau DPAPI untuk Pentester 🏭 🍹 👧🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel kedua berdasarkan hasil kinerja tim kami di OFFZONE-2018. Kali ini, pertimbangkan pembicaraan dengan MainTrack “Windows DPAPI“ Sekretiki ”atau...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Rahasia" DPAPI atau DPAPI untuk Pentester</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434514/">  Artikel kedua berdasarkan hasil kinerja tim kami di OFFZONE-2018.  Kali ini, pertimbangkan pembicaraan dengan MainTrack “Windows DPAPI“ Sekretiki ”atau DPAPI untuk pentester”. <br><br>  Perhatian!  Banyak beech! <br><br>  Saat melakukan kampanye RedTeam, saya ingin memberikan lebih sedikit alasan untuk reaksi BlueTeam, tetapi bisa ada banyak.  Misalnya, menjalankan mimikatz untuk mendapatkan kata sandi atau sertifikat pengguna.  Bahkan jika kami dapat "otmazyvat" dari Kaspersky, BlueTeam memiliki kemampuan untuk melacak menggunakan alat khusus seperti Sysmon, Microsoft ATA, dll.  Pada saat yang sama, saya ingin mendapatkan informasi maksimum dari mesin pengguna yang dikompromikan.  Dalam perjalanan kampanye yang dilakukan berulang kali oleh RedTeam untuk melawan tim BlueTeam yang sebenarnya, kami sampai pada kesimpulan bahwa perlu untuk menghindari tindakan yang dapat berfungsi sebagai indikator kompromi sistem.  Untuk mencapai tujuan ini dimungkinkan melalui penggunaan mekanisme dan tindakan hukum yang disediakan oleh sistem operasi untuk pengguna. <br><br>  Salah satu alat hukum tersebut adalah mekanisme DPAPI (Windows Data Protection API), yang digunakan oleh sistem operasi dan berbagai aplikasi untuk mengenkripsi data pengguna yang sensitif (terutama kata sandi, kunci kriptografi, dll.) Untuk pengguna akhir dan aplikasinya, DPAPI terlihat sangat sederhana : Hanya ada 2 fungsi - "mengenkripsi data" dan "mendekripsi data".  Dalam artikel ini saya ingin mempertimbangkan bagaimana mekanisme seperti itu berguna untuk pentester selama kampanye RedTeam. <br><a name="habracut"></a><br><h3>  Apa itu DPAPI?  Hanya sebentar dan dalam bahasa Rusia </h3><br>  Sejak tahun 2000, semua OS Windows telah mulai menggunakan mesin DPAPI untuk menjaga data pengguna tetap aman. <br><br>  Jika kita melewatkan semua kriptografi yang kami periksa dalam laporan, untuk mendekripsi data yang dienkripsi melalui DPAPI, kita perlu: kunci master, SID pengguna, hash kata sandi pengguna, dan gumpalan DPAPI itu sendiri (data DPAPI terenkripsi). <br><br>  Secara umum, prosesnya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/n1/ex/ah/n1exahepzml5ykake_tcy_qaj6i.jpeg"><br><br>  Di dalam "topi kriptografi" kami, ada banyak mekanisme kripto berbeda yang tidak akan kami pertimbangkan dalam artikel ini, agar tidak membebani pembaca.  Kami hanya mencatat bahwa bagian utama DPAPI adalah yang disebut Masterkey (master key).  Secara sederhana, kunci master adalah 64 byte data acak yang dienkripsi menggunakan prekey, yang dihasilkan dari kata sandi pengguna dan SID-nya. <br><img src="https://habrastorage.org/webt/dr/gu/b2/drgub2ccge4pjhkz1czilfleveg.jpeg"><br><br>  Parameter tambahan juga mengambil bagian dalam generasi prekey: jumlah iterasi (IterN), garam dan HMAC, yang dapat bervariasi dari kasus ke kasus.  Nilai-nilai parameter ini disimpan bersama dengan kunci utama dalam satu file. <br><br>  Dengan demikian, mengetahui kata sandi pengguna, SID-nya dan membaca parameter pembuatan dari file kunci utama (HMAC, Salt, InterN), kita dapat menghasilkan prekey dan mendekripsi kunci utama, yaitu.  dapatkan 64 byte yang sangat acak yang akan kita gunakan untuk mendekripsi gumpalan DPAPI. <br><br><h3>  Bagaimana jika saya mengubah kata sandi saya? </h3><br>  Biasanya, kata sandi pengguna berubah secara berkala.  Apa yang terjadi jika pengguna mengubah kata sandi?  Kemana perginya yang sebelumnya?  Memang, untuk mendekripsi kunci master, Anda perlu mengetahui kata sandi pengguna, dan memasukkan kembali semua kunci master pengguna setiap kali terlalu mahal.  Dalam hal ini, semuanya dipikirkan di Windows. <br><br>  Ada file khusus (CREDHIST), tugasnya adalah menyimpan semua kata sandi pengguna sebelumnya.  Itu juga dienkripsi dengan kata sandi pengguna saat ini dan disimpan di tumpukan.  Jika sistem tiba-tiba gagal mendekripsi kunci master, maka ia melanjutkan sebagai berikut: menggunakan kata sandi saat ini, ia mendekripsi catatan pertama dalam CREDHIST.  Kata sandi mencoba mendekripsi kunci master lagi, dan seterusnya hingga kata sandi dalam rantai habis atau kunci master didekripsi. <br><br><h3>  Sedikit tentang kunci pribadi pengontrol domain </h3><br>  Seperti yang mungkin sudah Anda duga, DPAPI diterapkan untuk semua pengguna, termasuk pengguna domain.  Agar dapat mengatur ulang kata sandi kepada pengguna yang berhasil melupakannya setelah pesta Jumat malam, Anda memerlukan kunci cadangan yang akan disimpan di tempat yang aman.  Menurut Microsoft, tempat yang dapat diandalkan adalah pengontrol domain. <br><br>  Inti dari mekanisme untuk mendekripsi kunci master setelah mengatur ulang kata sandi pengguna adalah sebagai berikut: sepasang kunci RSA - pribadi dan publik - dibuat pada pengontrol domain.  Kunci pribadi disimpan pada pengontrol domain di basis data NTDS dan disebut BCKUPKEY_xxxx (lihat gambar di bawah), dan kunci publik didistribusikan ke semua sistem domain dan digunakan untuk membuat duplikat kunci master saat dihasilkan. <br><br>  Setelah membuat kunci utama pada mesin domain, duplikatnya juga dibuat (atau lebih tepatnya, materi kunci utama adalah 64 byte), yang disimpan bersama dengan kunci master utama dalam satu file dan disebut Domain Key.  Jika Anda kehilangan kunci master utama, mis.  ketika mengatur ulang kata sandi pengguna, sistem mengirimkan duplikatnya ke pengontrol domain dan meminta untuk mendekripsi.  Kontroler, setelah mengotorisasi pengguna, mendekripsi duplikat dan mengembalikannya ke sistem, setelah itu materi kunci utama sudah dienkripsi ulang dengan kata sandi baru. <br><br><img src="https://habrastorage.org/webt/jj/7h/zr/jj7hzrqypjkdjwiaooxks9wcbj0.jpeg"><br><br>  Memiliki hak istimewa yang sesuai dalam domain (paling sering admin), Anda bisa mendapatkan kunci RSA pribadi ini dari pengontrol domain melalui mekanisme replikasi dan menggunakannya untuk dekripsi lebih lanjut dari kunci master yang dibuat pada mesin domain.  Ini dapat dilakukan dengan menggunakan mimikatz atau DSInternals.  Anda dapat membaca lebih lanjut tentang ini di mimikatz wiki atau blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DSInternals</a> . <br><br><h3>  Di mana kunci master disimpan dan apa itu? </h3><br>  Kunci master dapat berupa pengguna dan sistem, tergantung pada rahasia siapa yang dienkripsi.  Kunci master pengguna disimpan dalam profil pengguna dengan cara berikut: <br><br> <code>Users\%USER%\AppData\Roaming\Microsoft\Protect\%SID%\</code> <br> <br>  Untuk berjaga-jaga, sistem menyimpan semua kunci utama yang pernah digunakan oleh pengguna.  Lagipula, dia tidak tahu sebelumnya master mana yang perlu mendekripsi sesuatu dengan kunci.  GUID dari kunci saat ini yang digunakan disimpan dalam file yang dipilih. <br><br><img src="https://habrastorage.org/webt/xf/vm/dr/xfvmdrhqgsspxyznypourrwceh8.jpeg"><br><br>  Kunci master sistem disimpan dengan cara berikut: <br> <code>windows\system32\Microsoft\Protect\S-1-5-18\</code> <br> <br>  Demikian pula dengan pengguna - satu kunci master digunakan, nama yang dapat ditemukan dalam file yang dipilih, di mana semua kunci yang pernah digunakan disimpan. <br><br><img src="https://habrastorage.org/webt/zt/xt/xj/ztxtxjcblhgk7ugrwxwgosbtmjw.jpeg"><br><br><h3>  Nah, apa yang bisa diberikan DPAPI ini pada Pentester? </h3><br>  Karena DPAPI adalah mekanisme yang legal dan sederhana, berbagai aplikasi mencoba menggunakannya.  Karena nyaman dan aman.  Untuk saat ini, tentu saja. <br><br>  Misalnya, DPAPI digunakan untuk mengenkripsi kunci pribadi dari klien dan sertifikat sistem, kunci WIFI, Chrome (cookie, kata sandi), DropBox, Skype, RSA SecurID (aplikasi perangkat lunak yang menghasilkan kunci satu kali).  Dan ini bukan daftar lengkap. <br><br>  Tugas pentester adalah mendekripsi gumpalan yang diperlukan dan mendapatkan kata sandi, cookie, dll. <br><br>  Ada beberapa cara untuk melakukan ini.  Dengan satu atau lain cara, semuanya bermuara pada dua transkrip - online dan offline.  Dekripsi online adalah ketika pada mesin pengguna, kami cukup memanggil fungsi sistem untuk mendekripsi data dan meneruskan gumpalan DPAPI ke input, dan sistem melakukan semuanya dengan sendirinya - ia mencari kunci master yang digunakan untuk mengacak gumpalan, mendekripsi menggunakan SID pengguna dan hash kata sandi yang disimpan dalam memori LSASS. <br><br>  Gambar di bawah ini menunjukkan contoh memanggil fungsi DPAPI untuk enkripsi dan dekripsi pada PowerShell. <br><br><img src="https://habrastorage.org/webt/nj/h3/ko/njh3koyjpr5f1yft8o6zllkpjfw.jpeg"><br><br>  Pertama, kami mengenkripsi rahasia kami (dalam hal ini, kata "Kata Sandi") dengan memanggil fungsi [Security.Cryptography.ProtectedData] :: Protect ().  Dan kami melakukan ini dua kali - dalam kasus pertama menggunakan kunci master pengguna (parameter CurrentUser), dan yang kedua - kunci sistem master (parameter LocalMachine).  Kemudian kita dapat mendekripsi gumpalan yang dihasilkan dengan memanggil fungsi invers - [Security.Cryptography.ProtectedData] :: UnProtect (). <br><br>  Selain itu, dalam hal ini, nilai parameter CurrentUser atau LocalMachine tidak masalah, karena  sistem itu sendiri menemukan kunci utama yang cocok untuk decoding gumpalan, dan melakukan semua yang diperlukan.  Dalam kedua kasus, kami mendapatkan rahasia awal kami - kata "Kata Sandi" (representasi byte-by-bitnya). <br><br>  Saat mendekripsi online, penting untuk memahami dalam konteks apa Anda memanggil fungsi UnProtect ().  Agar dekripsi berhasil, Anda harus berada di sesi pengguna atau masuk di bawah sesi baru.  Masalahnya adalah hash kata sandi, yang disimpan dalam memori LSASS.  Jika Anda melakukan panggilan di luar sesi pengguna (misalnya, Anda masuk ke sistem melalui jaringan melalui psexec atau meterpreter), maka Anda karenanya tidak memiliki hash kata sandi yang diperlukan untuk mendekripsi kunci utama.  Dia, tentu saja, ada di sesi berikutnya, tetapi LSASS tidak akan memberikannya kepada Anda, karena  ini adalah sesi lain, meskipun itu dibuat di bawah pengguna yang sama.  Agar dekripsi online berhasil, Anda harus bermigrasi ke proses apa pun yang diluncurkan oleh pengguna yang masuk melalui GUI, atau sepenuhnya masuk ke sistem, misalnya, melalui RDP. <br><br>  Sebuah alternatif untuk powershell untuk dekripsi online gumpalan DPAPI dapat menjadi panggilan ke mimiktaz :: blob dengan parameter / unsotect.  Pada input, dia diberikan file biner dengan gumpalan DPAPI, dan pada output kita mendapatkan data yang didekripsi.  Lebih banyak kasus menggunakan mimikatz dijelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di blog</a> HarmJ0y. <br><br><h3>  Bola isyarat jatuh.  Apa yang harus dilakukan dengan peternakan saya dengan vidyuhi? </h3><br>  Karena fakta bahwa kunci utama DPAPI dienkripsi pada kata sandi pengguna, Anda dapat mencoba proses sebaliknya - paksa paksa kata sandi pengguna dengan kunci masternya.  Misalnya, kami menerima koneksi terbalik dari makro atau DDE kami dari file docx yang dikirim.  Kami dapat mengambil kunci utama pengguna dan mengembalikan kata sandi pengguna tanpa ada peningkatan hak istimewa dan peluncuran mimikatz. <br><br>  Bisakah saya menggunakan Hashcat atau JohnTheRipper untuk kata sandi bruteforce?  Tetapi sebelum itu, Anda perlu mendapatkan parameter brute force dari komposisi John dengan skrip yang sesuai: <br><br><pre> <code class="xml hljs">./DPAPImk2john.py –S <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sid</span></span></span><span class="hljs-tag">&gt;</span></span> -mk <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkey</span></span></span><span class="hljs-tag">&gt;</span></span> -c <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">domain|local</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Kemudian kita sudah dapat mengirim hasil skrip ke peternakan kami dengan kartu video dan berharap bahwa pengguna memiliki kata sandi yang lemah, karena  kecepatan brute force master key kira-kira sebanding dengan kecepatan enumerasi WPA2, mis.  cukup lambat. <br><br>  Perlu dicatat di sini bahwa dalam kasus ketika kunci master dihasilkan pada domain Windows 10, 10.000 putaran algoritma PBKDF2 ditambahkan ke generasi prekey.  Tetapi lebih buruk lagi, baik Hashcat maupun JohnTheRipper tidak tahu tentang ini (setidaknya pada saat penulisan ini), yang berarti bahwa mereka tidak akan dapat menghapus kata sandi dari kunci master semacam itu. <br><br><h3>  "Untuk mengambil semua yang buruk, dan kemudian mencari tahu ..." </h3><br>  Seperti yang kami sebutkan sebelumnya, eksekusi tindakan mencurigakan pada mesin pengguna dapat memancing minat tambahan dari tim Blueteam, dan ini, karenanya, penuh dengan fakta bahwa semua RedTeam akan berakhir di sana.  Contohnya adalah peluncuran PowerShell di komputer seorang akuntan atau sekretaris, diikuti oleh investigasi insiden tersebut.  Agar tidak menimbulkan kecurigaan yang tidak perlu, lebih baik menggunakan metode offline untuk mendekode gumpalan DPAPI.  Untuk melakukan ini, Anda harus terlebih dahulu mengambil semua yang Anda butuhkan dari mesin, yaitu: <br><br><ul><li>  Kunci master pengguna </li><li>  Kunci utama sistem </li><li>  File CREDHIST (jika bukan mesin domain); </li><li>  Kata sandi pengguna (atau hash sha1 / ntlmnya); </li><li>  SID pengguna; </li><li>  Gumpalan DPAPI yang ingin kita dekripsi. </li></ul><br>  Untuk dekripsi dalam mode offline, kita tidak dapat melakukannya tanpa alat khusus.  Alat tersebut mungkin: <br><br><ul><li>  Mimikatz; </li><li>  Impacket (dimulai dengan versi ke-18, ia memiliki fungsi DPAPI); </li><li>  Kerangka dpapick. </li></ul><br>  Ini tentang kerangka kerja dpapick yang akan kita bicarakan secara lebih rinci. <br><br>  Kerangka kerja python dpapick sendiri dibuat oleh peneliti Jean-Michel Pikode pada tahun 2014 dan merupakan implementasi dari mekanisme DPAPI di perpustakaan Python crypto.  Penggunaan python, serta struktur kerangka kerja, memungkinkannya untuk dengan mudah disesuaikan dengan berbagai mekanisme DPAPI.  Dalam versi aslinya, dpapick tidak dapat menggunakan kunci cadangan domain untuk mendekripsi kunci master, dan tidak memiliki mekanisme untuk mendekripsi kunci utama yang dibuat pada Windows 10 dalam mode mesin domain. <br><br>  Setelah memperbaiki kekurangan ini dan memperluas fungsionalitas untuk mendekripsi gumpalan DPAPI, dpapick berubah menjadi alat yang cukup bagus untuk decoding offline DPAPI.  Di bawah, sebagai contoh, kami akan menunjukkan opsi untuk menggunakan kerangka kerja ini untuk mendekripsi data pengguna yang dienkripsi melalui DPAPI. <br><br><h3>  Chrome - ambil dan dekripsi cookie dan kata sandi </h3><br>  <code>%localappdata%\Google\Chrome\User Data\Default\Cookies</code> Chrome disimpan dalam file <code>%localappdata%\Google\Chrome\User Data\Default\Cookies</code> <br>  Data masuk ada dalam file <code>%localappdata%\Google\Chrome\User Data\Default\Login Data</code> <br><br>  Kedua file adalah database sqlite3 di mana data sensitif disimpan sebagai gumpalan DPAPI.  Sebagai bagian dari dpapick ada dissector yang sudah jadi (parser) dari data ini (contoh / chrome.py).  Agar berhasil mendekripsi, ia perlu menentukan direktori dengan kunci utama, sisi pengguna, kata sandi atau lokasi kunci pribadi pengendali domain, serta file sqlite3 dari Chrome (cookie atau data masuk). <br><br>  Dekripsi cookie Chrome secara offline dengan kata sandi pengguna <br><br><pre> <code class="xml hljs">./chrome.py --cookie <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cookiefile</span></span></span><span class="hljs-tag">&gt;</span></span> --sid <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SID</span></span></span><span class="hljs-tag">&gt;</span></span> --password <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dekripsi offline cookie Chrome menggunakan hash dari kata sandi pengguna <br><br><pre> <code class="xml hljs">./chrome.py --cookie <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cookiefile</span></span></span><span class="hljs-tag">&gt;</span></span> --sid <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SID</span></span></span><span class="hljs-tag">&gt;</span></span> --hash <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dekripsi offline kata sandi Chrome menggunakan kunci pribadi dari pengontrol domain <br><br><pre> <code class="xml hljs">./chrome.py --chrome <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">login</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">file</span></span></span><span class="hljs-tag">&gt;</span></span> --pkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rsa-priv.pem</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  DPAPI untuk sertifikat klien </h3><br>  Sertifikat klien banyak digunakan di mana - untuk menghasilkan OTP, EFS atau otentikasi dalam VPN, aplikasi Web, dll. <br><br>  Sertifikat kunci publik sendiri disimpan di profil pengguna: <br> <code>%APPDATA%\Microsoft\SystemCertificates\My\Certificates\</code> <br>  Dan kunci pribadi, dengan bantuan yang mana tanda tangan benar-benar dilakukan atau operasi kriptografi lainnya dienkripsi melalui DPAPI dan juga terletak di profil pengguna di sepanjang jalur: <br><br><pre> <code class="bash hljs">%APPDATA%\Roaming\Microsoft\Crypto\RSA\&lt;SID&gt;\</code> </pre> <br>  Agar berhasil mendekripsi kunci sertifikat pribadi dan kemudian membuat kembali file PFX, selain file di atas, kita juga memerlukan kunci master pengguna, serta SID dan kata sandi (atau kunci RSA pribadi dari controller). <br><br>  Menggunakan Dpapick dan kata sandi pengguna, kami mendekripsi ini: <br><br><pre> <code class="xml hljs">./efs.py --certificates <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cert</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dir</span></span></span><span class="hljs-tag">&gt;</span></span> --rsakyes <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RSA</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dir</span></span></span><span class="hljs-tag">&gt;</span></span> --sid <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --password <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/tx/kf/bp/txkfbp91hcb6pg_rq7wgh8w7v5u.jpeg"><br><br>  Parameter rsaout opsional dalam tangkapan layar memungkinkan Anda untuk mengekspor kunci RSA yang didekripsi tambahan dalam format PEM.  Hasil skrip adalah file PFX yang dibuat ulang tanpa kata sandi, yang sudah dapat diimpor ke diri Anda dan digunakan untuk tujuan yang dimaksud.  Jika dalam direktori di atas ada beberapa sertifikat dan kunci pribadi, maka dpapick akan mencoba mendekripsi masing-masing dan membuat beberapa file pfx. <br><br>  Tindakan yang sama dapat dilakukan menggunakan kunci pribadi domain untuk mendekripsi kunci utama dengan menetapkan parameter yang sesuai: <br><br><pre> <code class="xml hljs">./efs.py --certificates <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cert</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dir</span></span></span><span class="hljs-tag">&gt;</span></span> --rsakyes <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RSA</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dir</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span> --pkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">domain</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bkp</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  Sedikit lagi tentang "keping" domain </h3><br>  Berbicara tentang domain Active Directory, ada baiknya menyebutkan fitur luar biasa seperti Kredensial Roaming - fungsi domain ketika kunci master, kata sandi terenkripsi, dan sertifikat "perjalanan" untuk pengguna di seluruh domain Active Directory.  Mereka tidak terikat pada mesin tertentu dan akan "tiba" ke komputer tempat pengguna domain itu masuk. <br><br>  Ketika "fitur" ini dihidupkan, semua sertifikat yang diimpor pengguna, serta semua kunci dan kata sandi pribadinya, terbang ke AD dan disimpan dalam atribut akun yang sesuai: msPKIAccountCrdentailas dan msPKIDPAPIMasterKeys. <br><br>  Anda dapat melihat tampilannya di dalam AD, misalnya, melalui ldapsearch: <br><br><pre> <code class="xml hljs">ldapsearch -x -h dc1.lab.local -D “user1@lab.local" -s sub "samAccountname=user1" ldapsearch -x -h dc1.lab.local -D "admin@lab.local" -s sub "samAccountname=anyuser"</code> </pre> <br><img src="https://habrastorage.org/webt/vl/sh/01/vlsh019lykontfubtr-g5rx__dc.jpeg"><br><br>  Secara default, pengguna hanya dapat menerima atribut DPAPI untuk akunnya.  Tetapi dengan hak istimewa yang ditingkatkan, ini dapat dilakukan untuk akun apa pun, termasuk akun komputer. <br><br>  Roaming Credential adalah teknologi yang sangat nyaman tidak hanya untuk admin, tetapi juga untuk pentester.  Setelah mengakses pengontrol domain melalui ldap, Anda dapat menggabungkan semua sertifikat pengguna, kunci master dan kata sandi yang dienkripsi melalui DPAPI (misalnya, kata sandi untuk menghubungkan ke drive jaringan). <br><br>  Dan mengapa tidak menambahkan fungsionalitas seperti itu ke dpapick, kami pikir - dan mengajarinya cara mengekstrak sertifikat secara otomatis dari pengontrol domain melalui ldap, mendekripsi mereka dan menghasilkan file pfx. <br><br><pre> <code class="xml hljs">./efs.py –ldap-server <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --ldap-connect admin:Passw0rd@lab.local --ldap-user user1 --password Password1 ./efs.py –ldap-server <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --ldap-connect admin:Passw0rd@lab.local --ldap-user user1 --pkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rsa-priv.pem</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><img src="https://habrastorage.org/webt/an/_p/bi/an_pbimm2jjr-iuapm945q43rzs.jpeg"><br><br>  Untuk menjalankan skrip, perlu untuk menentukan pengontrol domain sebagai server ldap, perincian koneksi ke sana, nama akun tempat kami menerima sertifikat dan kata sandi untuk mendekripsi kunci master (atau kunci cadangan pribadi pengendali). <br><br><h3>  Dropbox  Hilang dalam 60 Detik ... </h3><br>  Dropbox adalah contoh lain dari menggunakan DPAPI untuk menyimpan rahasia pengguna.  Token otorisasi untuk dropbox disimpan dalam file: <br><br><pre> <code class="bash hljs">c:\users\&lt;username&gt;\Appdata\Local\Dropbox\instance1\config.dbx c:\users\&lt;username&gt;\Appdata\Local\Dropbox\instance_db\instanse.dbx</code> </pre> <br>  Ini adalah database sqlite3 terenkripsi yang berisi data untuk koneksi.  Untuk enkripsi, kunci simetris digunakan, yang pada gilirannya dienkripsi melalui DPAPI dan disimpan dalam registri: <br><br> <code>HKCU\SOFTWARE\Dropbox\ks <br> HKCU\SOFTWARE\Dropbox\ks1</code> <br> <br>  Dengan demikian, urutan umum pembajakan dropbox adalah sebagai berikut: <br><br><ol><li>  kami mengambil dua file database dari komputer; </li><li>  kami mendapatkan kunci dari registri dan mendekripsi menggunakan dpapick; </li><li>  menggunakan DPAPI, kami mengenkripsi kunci yang diterima pada mesin kami dan memasukkannya ke dalam registri; </li><li>  di mesin kami, kami mengganti file database dan menjalankan Dropbox. </li></ol><br>  Anda harus menyadari bahwa izin khusus ditetapkan untuk cabang registri di atas.  Mereka hanya bisa dibaca oleh pengguna.  Baik administrator maupun sistem tidak dapat membacanya.  Dengan demikian, jika Anda mengakses registri atas nama pengguna lain (bahkan seorang administrator), Anda harus terlebih dahulu mengatur izin yang sesuai pada cabang registri yang ditentukan.  Misalnya, jadi (PowerShell): <br><br><pre> <code class="xml hljs">$Sid="S-1-5-21-3463664321-2923530833-3546627382-1000"; $key=[Microsoft.Win32.Registry]::USERS.OpenSubKey("$sid\SOFTWARE\Dropbox\ks",[Microsoft.Win32.RegistryKeyPermissionCheck]::ReadWriteSubTree,[System.Security.AccessControl.RegistryRights]::ChangePermissions); $acl = $key.GetAccessControl(); $rule = New-Object System.Security.AccessControl.RegistryAccessRule ("administrator","FullControl","Allow"); $acl.SetAccessRule($rule); $key.SetAccessControl($acl); $key_path = "REGISTRY::HKEY_USERS\$Sid\SOFTWARE\Dropbox\ks"; (Get-ItemProperty -Path $key_path -Name Client).Client;</code> </pre> <br>  Kunci ks dan ks1 berisi header (8 byte) dari versi dbx sebelum gumpalan DPAPI dan gumpalan md5 HMAC DPAPI (16 byte terakhir).  Gumpalan DPAPI sendiri dimulai dengan byte 9 0x01000000D0 ... Bytes ini harus disalin dalam format base64 ke file, yang kemudian didekripsi melalui dpapick: <br><br><pre> <code class="xml hljs">./filegeneric.py --sid <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --password <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --base64file <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Kemudian, pada mesin Anda, Anda perlu mengenkripsi kunci yang diterima pada tahap terakhir dengan kunci master kami dan memasukkan hasilnya ke cabang registri yang sesuai. <br><br>  Untuk enkripsi, paling mudah menggunakan PowerShell: <br><br><pre> <code class="xml hljs">$hdata="4efebbdf394d4003317fc5c357beac4b"; [Byte[]] $dv0_entropy = 0xd1,0x14,0xa5,0x52,0x12,0x65,0x5f,0x74,0xbd,0x77,0x2e,0x37,0xe6,0x4a,0xee,0x9b; $data = ($hdata -split "(?<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">=\G\w{2})(?=\w{2})"</span></span></span><span class="hljs-tag"> | %{ [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Convert</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">::ToByte</span></span></span><span class="hljs-tag">( $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">_</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">16</span></span></span><span class="hljs-tag"> ) }); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Add-Type</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-AssemblyName</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">System.Security</span></span></span><span class="hljs-tag">; $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dk1</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">[system.security.cryptography.protecteddata]::Protect($data,$dv0_entropy,[System.Security.Cryptography.DataProtectionScope]::CurrentUser);</span></span></span><span class="hljs-tag"> $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pr</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">([System.BitConverter]::ToString($dk1));$pr</span></span></span><span class="hljs-tag"> $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">OBJ_hmac</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">New-Object</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">System.Security.Cryptography.HMACMD5</span></span></span><span class="hljs-tag"> $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hmac</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">$OBJ_hmac.ComputeHash($dk1)</span></span></span><span class="hljs-tag"> $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pr</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">([System.BitConverter]::ToString($hmac));$pr</span></span></span></span></code> </pre> <br>  Dalam kasus ini, hdata adalah kunci yang diterima pada tahap dekripsi.  dv0_entropy adalah konstanta entropi yang digunakan oleh DBOX di DPAPI.  Untuk gumpalan yang dihasilkan, perlu untuk menetapkan di depan header 8 byte 0x00000000F6000000, dan di belakang - HMACMD5 + 0x00 <br>  Setelah itu, Anda dapat menulis data ke kunci registri yang sesuai. <br><br><h3>  DPAPI dan RSA SecurID </h3><br>  RSA SecurID adalah program klien yang digunakan untuk menghasilkan kata sandi satu kali, yang dikembangkan oleh RSA. <br><br>  Ini adalah hal yang cukup populer untuk perusahaan besar dan juga menggunakan DPAPI, hanya sedikit lebih rumit.  Dalam hal ini, insinyur RSA memutuskan untuk menjadi bingung dan menerapkan skema DPAPI yang lebih kompleks. <br><br>  Data token disimpan dalam file <code>%LOCALAPPDATA%\RSA\SecurIDStorage</code> , yang merupakan basis data sqlite3.  Setiap token terenkripsi berisi EnTokenSid terenkripsi (parameter untuk inisialisasi awal dari algoritma pembuatan kode).  EnTokenSid dibuat berdasarkan DBKey, SID token dan SID pengguna, dan DBKey sudah dibentuk oleh dekripsi DPAPI DBKeyEnc dengan urutan sebagai berikut: <br> <code>DBKeyEnc = DPAPI(CurrenUser, DPAPI(LocalSystem(DBKey))</code> <br> <br>  Yaitu  Pertama, Kunci DB dienkripsi dengan kunci master sistem, dan kemudian gumpalan DPAPI yang dihasilkan dienkripsi lagi dengan kunci master pengguna. <br><br>  Juga di database ada CryptoCheckSum dari CheckSum: <br>  CryptoCheckSum = Gumpalan DPAPI (CurrenUser) <br><br>  Dengan demikian, agar SecurIDStorage yang digabungkan dapat bekerja pada mesin Anda, Anda harus: <br><br><ol><li>  Karena fakta bahwa SID pengguna terlibat dalam pembentukan EncTokenSid, maka perlu menetapkan SID pengguna saat ini di mesin virtual dengan nilai yang sama dengan SID pengguna yang diambil dari basis SecurIDStorage.  Utilitas NewSid dari SysInternals akan membantu kami dalam hal ini; </li><li>  Dekripsi DBKeyEnc menggunakan kunci utama pengguna dan kata sandi atau kunci pribadi domain (jika mesin adalah domain); </li><li>  Dekripsi hasil dekripsi sebelumnya menggunakan kunci master sistem dan nilai parameter DPAPI_SYSTEM; </li><li>  Dekripsi CryptoCheckSum menggunakan kunci utama pengguna </li><li>  Enkripsi nilai-nilai DBKey dan CheckSum yang diterima dalam urutan terbalik yang sudah ada di mesin virtual Anda; </li><li>  Di beberapa versi SecurID, Anda juga perlu mengatur ukuran HDD mesin virtual ke ukuran yang sama dengan ukuran HDD mesin sumber, seperti  program memeriksanya saat startup. </li></ol><br>  Seperti disebutkan di atas, untuk mendekripsi DBKeyEnc, selain kunci master pengguna, kita juga akan memerlukan kunci master sistem, serta nilai DPAPI_SYSTEM, yang dengannya kunci-kunci sistem master didekripsi.  DAPPI_SYSTEM sebenarnya prekey sudah terbentuk, berpartisipasi dalam pembentukan kunci master sistem.  Anda bisa mendapatkannya dari memori LSASS (melalui mimikatz atau dengan menganalisis proses dump) atau dari cabang registri yang sesuai (HKLM \ SYSTEM, HKLM \ SECURITY), membuangnya dan menganalisis Impacket yang sama. <br><br>  Kemudian kita dapat menggunakan DPAPI_SYSTEM yang diperoleh untuk mendekripsi gumpalan yang diperlukan menggunakan dpapick (parser adalah contoh / filegeneric.py), seperti yang ditunjukkan pada tangkapan layar berikut: <br><br>  1) Mendapatkan DPAPI_SYSTEM via mimikatz offline <br><br><img src="https://habrastorage.org/webt/ww/xi/ov/wwxiovhm-6gdcbn7tmmpr7-qsim.jpeg"><br><br>  2) Mendapatkan DPAPI_SYSTEM melalui Impacket offline <br><br><img src="https://habrastorage.org/webt/s7/9v/5g/s79v5gxvzjjccekaklg8gtefyfw.jpeg"><br><br>  3) Dekripsi DPAPIck dengan kunci master pengguna dan sistem <br><br><img src="https://habrastorage.org/webt/ip/th/qm/ipthqmqacvzvixntzgk_n1vsgvs.jpeg"><br><br><h3>  Lembar curang </h3><br>  Agar Anda tidak lupa tempat data tertentu - kami akan menempatkannya di bagian terpisah: <br><br>  <b>Kunci master khusus</b> <br><br><pre> <code class="bash hljs">%APPDATA%\Microsoft\Protect\&lt;SID&gt;\*</code> </pre> <br>  <b>Kunci Master Sistem</b> <br><br><pre> <code class="bash hljs">Windows\System32\Microsoft\Protect\*</code> </pre> <br>  <b>DPAPI_SYSTEM</b> <br><br><pre> <code class="bash hljs">LSASecrets – online SYSTEM, SECURITY (reg save …, system\backup, etc)</code> </pre> <br>  <b>Sertifikat pengguna</b> <br><br><pre> <code class="bash hljs">%APPDATA%\Microsoft\SystemCertificates\My\Certificates\ %APPDATA%\Microsoft\Crypto\RSA\&lt;SID&gt;\</code> </pre> <br>  <b>Sertifikat sistem</b> <br><br><pre> <code class="bash hljs">HKLM:\SOFTWARE\Microsoft\SystemCertificates\MY\Certificates\* C:\Programdata\Microsoft\Crypto\RSA\MachineKeys\</code> </pre> <br>  <b>Chrome</b> <br><br><pre> <code class="bash hljs">%localappdata%\Google\Chrome\User Data\Default\Cookies %localappdata%\Google\Chrome\User Data\Default\Login Data</code> </pre> <br>  <b>Dropbox</b> <br><br><pre> <code class="bash hljs">HKCU\SOFTWARE\Dropbox\ks HKCU\SOFTWARE\Dropbox\ks1 %APPDATA%\Local\Dropbox\instance1\config.dbx %APPDATA%\Local\Dropbox\instance_db\instanse.dbx</code> </pre> <br>  <b>Rsa securid</b> <br><br><pre> <code class="bash hljs">%LOCALAPPDATA%\RSA\SecurIDStorage</code> </pre> <br><h3>  Kesimpulan kecil </h3><br>  DPAPI adalah hal yang luar biasa - hal utama adalah untuk memahami bagaimana hal itu dapat digunakan ketika melakukan studi pentest dan RedTeam. <br><br>  Pada artikel ini, kami melihat beberapa contoh di mana dekripsi DPAPI dapat diterapkan.  Padahal, ruang lingkupnya jauh lebih luas.  Misalnya, kami tidak mempertimbangkan RDP (* .rdg), Icloud (file pList), Skype (*. Xml), kunci untuk menghubungkan ke Wi-Fi.  Di mana-mana DPAPI diterapkan dan parser terkait diimplementasikan sebagai bagian dari kerangka kerja dpapick. <br><br>  Versi dpapick yang dimodifikasi tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> kami.  Kami mendesak Anda untuk menggunakan alat ini untuk mendekripsi DPAPI dan kami akan berterima kasih atas pengembangan dpapick lebih lanjut. <br><br>  Dan beberapa informasi menarik dapat ditemukan di saluran kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telegram</a> .  Kami menceritakan tentang IB melalui mata RedTeam. <br><br>  PS Terima kasih kepada penyelenggara OFFZONE-2018 untuk konferensi yang keren! <br><br>  PPS Bagian kedua artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434514/">https://habr.com/ru/post/id434514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434504/index.html">20 tahun Fast Reports “Produk ini dibuat dalam satu nafas, cukup tinggi ...”</a></li>
<li><a href="../id434506/index.html">Pengalaman menerbitkan aplikasi pengeditan video di Microsoft Store</a></li>
<li><a href="../id434508/index.html">Sisi Gelap Pemasaran Mesin Pencari: Bagaimana dan Mengapa Google Mengumpulkan Informasi Pribadi Kami</a></li>
<li><a href="../id434510/index.html">Secara singkat tentang bekerja dengan RabbitMQ dari Python</a></li>
<li><a href="../id434512/index.html">Corporate perusahaan</a></li>
<li><a href="../id434516/index.html">Cara mudah untuk menangani aspirasi karier Anda.</a></li>
<li><a href="../id434518/index.html">Tepuk tangan dan tepuk tangan: drama yang dikendalikan dengan cermat di toko-toko Apple</a></li>
<li><a href="../id434522/index.html">Pola justifikasi tugas dan antipatterns</a></li>
<li><a href="../id434524/index.html">Kubernetes Ingress melalui mata seorang pemula</a></li>
<li><a href="../id434528/index.html">Dekripsi pelacak sinar seukuran kartu pos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>