<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÑÔ∏è üë®üèª üöè Umgang mit schmutzigen Nebenwirkungen in reinem, funktionalem JavaScript-Code üë©üèø‚Äçüè≠ üßëüèª üêã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie sich in der funktionalen Programmierung versuchen, werden Sie bald auf das Konzept der reinen Funktionen sto√üen. Wenn Sie fortfahren, werden ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Umgang mit schmutzigen Nebenwirkungen in reinem, funktionalem JavaScript-Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422589/">  Wenn Sie sich in der funktionalen Programmierung versuchen, werden Sie bald auf das Konzept der reinen Funktionen sto√üen.  Wenn Sie fortfahren, werden Sie feststellen, dass Programmierer, die einen funktionalen Stil bevorzugen, von diesen Funktionen besessen zu sein scheinen.  Sie sagen, dass reine Funktionen es Ihnen erm√∂glichen, √ºber Code zu sprechen.  Sie sagen, dass reine Funktionen Einheiten sind, die wahrscheinlich nicht so unvorhersehbar funktionieren, dass sie zu einem thermonuklearen Krieg f√ºhren werden.  Sie k√∂nnen auch von solchen Programmierern lernen, dass reine Funktionen referenzielle Transparenz bieten.  Und so - bis ins Unendliche. <br><br>  Funktionale Programmierer haben √ºbrigens recht.  Reine Funktionen sind gut.  Aber es gibt ein Problem ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q_/uc/lc/q_uclcvzexyauvwqhrp4c84pwpi.jpeg"></div><br>  Der Autor des Materials, dessen √úbersetzung wir Ihnen zur Kenntnis bringen, m√∂chte dar√ºber sprechen, wie mit Nebenwirkungen in reinen Funktionen umgegangen werden kann. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Das Problem der reinen Funktionen</font> </h2><br>  Eine reine Funktion ist eine Funktion, die keine Nebenwirkungen hat (tats√§chlich ist dies keine vollst√§ndige Definition einer reinen Funktion, aber wir werden auf diese Definition zur√ºckkommen).  Wenn Sie jedoch zumindest etwas in der Programmierung verstehen, wissen Sie, dass das Wichtigste hier genau die Nebenwirkungen sind.  Warum die Zahl Pi bis zur hundertsten Dezimalstelle berechnen, wenn niemand diese Zahl lesen kann?  Um etwas auf dem Bildschirm anzuzeigen oder auf einem Drucker zu drucken oder es in einer anderen Form darzustellen, die f√ºr die Wahrnehmung zug√§nglich ist, m√ºssen wir den entsprechenden Befehl aus dem Programm aufrufen.  Und was n√ºtzen Datenbanken, wenn nichts darauf geschrieben werden kann?  Um den Betrieb von Anwendungen sicherzustellen, m√ºssen Sie Daten von Eingabeger√§ten lesen und Informationen von Netzwerkressourcen anfordern.  All dies kann nicht ohne Nebenwirkungen durchgef√ºhrt werden.  Trotz dieses Zustands basiert die funktionale Programmierung auf reinen Funktionen.  Wie schaffen es Programmierer, die Programme in einem funktionalen Stil schreiben, dieses Paradoxon zu l√∂sen? <br><br>  Wenn Sie diese Frage auf den Punkt bringen, tun funktionale Programmierer dasselbe wie Mathematiker: Sie betr√ºgen.  Trotz dieser Anschuldigung muss gesagt werden, dass sie aus technischer Sicht einfach bestimmten Regeln folgen.  Aber sie finden L√ºcken in diesen Regeln und erweitern sie auf unglaubliche Gr√∂√üen.  Sie tun dies auf zwei Arten: <br><br><ol><li>  Sie nutzen die Abh√§ngigkeitsinjektion.  Ich nenne es ein Problem √ºber einen Zaun werfen. </li><li> Sie benutzen Funktoren, was mir eine extreme Form des Aufschubs erscheint.  Hierbei ist zu beachten, dass es in Haskell als "IO-Funktor" oder "IO-Monade" bezeichnet wird. In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PureScript wird der</a> Begriff "Effekt" verwendet, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meiner Meinung nach</a> etwas besser f√ºr die Beschreibung des Wesens von Funktoren ist. </li></ol><br><h2>  <font color="#3AC1EF">Abh√§ngigkeitsinjektion</font> </h2><br>  Die Abh√§ngigkeitsinjektion ist der erste Weg, um mit Nebenwirkungen umzugehen.  Mit diesem Ansatz nehmen wir alles, was den Code verschmutzt, und f√ºgen ihn in die Parameter der Funktion ein.  Dann k√∂nnen wir all dies als etwas betrachten, das Teil der Verantwortung einer anderen Funktion ist.  Ich werde dies anhand des folgenden Beispiels erkl√§ren: <br><br><pre><code class="hljs powershell">// logSomething :: String -&gt; String <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(something)</span></span></span></span> {    const dt = (new Date())toISOString();    console.log(`${dt}: <span class="hljs-variable"><span class="hljs-variable">$</span></span>{something}`);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something; }</code> </pre> <br>  Hier m√∂chte ich eine Notiz f√ºr diejenigen machen, die mit Typensignaturen vertraut sind.  Wenn wir uns strikt an die Regeln halten w√ºrden, m√ºssten wir hier die Nebenwirkungen ber√ºcksichtigen.  Aber wir werden uns sp√§ter darum k√ºmmern. <br><br>  Die Funktion <code>logSomething()</code> weist zwei Probleme auf, die verhindern, dass sie als sauber deklariert wird: Sie erstellt ein <code>Date</code> Objekt und gibt etwas an die Konsole aus.  Das hei√üt, unsere Funktion f√ºhrt nicht nur Eingabe-Ausgabe-Operationen aus, sondern erzeugt auch unterschiedliche Ergebnisse, wenn sie zu unterschiedlichen Zeiten aufgerufen wird. <br><br>  Wie macht man diese Funktion sauber?  Mit der Abh√§ngigkeitsinjektionstechnik k√∂nnen wir alles, was die Funktion verschmutzt, zu Funktionsparametern machen.  Anstatt einen Parameter zu akzeptieren, akzeptiert unsere Funktion daher drei Parameter: <br><br><pre> <code class="hljs powershell">// logSomething: Date -&gt; Console -&gt; String -&gt; * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d, cnsl, something)</span></span></span></span> {   const dt = d.toIsoString();   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cnsl.log(`${dt}: <span class="hljs-variable"><span class="hljs-variable">$</span></span>{something}`); }</code> </pre> <br>  Um die Funktion aufzurufen, m√ºssen wir nun alles darauf √ºbertragen, was sie zuvor verschmutzt hat: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">"Curiouser and curiouser!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); logSomething(d, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>, something); <span class="hljs-comment"><span class="hljs-comment">//  "Curiouser and curiouser!"</span></span></code> </pre> <br>  Hier denken Sie vielleicht, dass dies alles Unsinn ist, dass wir das Problem nur um eine Ebene nach oben verschoben haben und dass dies unserem Code keine Reinheit verlieh.  Und Sie wissen, das sind die richtigen Gedanken.  Dies ist eine L√ºcke in ihrer reinsten Form. <br><br>  Dies ist wie ein Schein-Analphabetismus: ‚ÄûIch wusste nicht, dass das Aufrufen der <code>log</code> des <code>cnsl</code> Objekts zur Ausf√ºhrung der E / A-Anweisung f√ºhren w√ºrde.  Jemand hat es mir gerade gegeben, aber ich wei√ü nicht, woher das alles kommt. "  Diese Einstellung ist falsch. <br><br>  Und tats√§chlich ist das, was passiert, nicht so dumm, wie es auf den ersten Blick erscheinen mag.  Schauen <code>logSomething()</code> sich die Funktionen der Funktion <code>logSomething()</code> .  Wenn Sie etwas Unreines tun m√∂chten, m√ºssen Sie es selbst tun.  Angenommen, Sie k√∂nnen dieser Funktion verschiedene Parameter √ºbergeben: <br><br><pre> <code class="hljs coffeescript">const d = {toISOString: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'1865-11-26T16:00:00.000Z'</span></span>}; const cnsl = {   log: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      }, }; logSomething(d, cnsl, <span class="hljs-string"><span class="hljs-string">"Off with their heads!"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">"Off with their heads!"</span></span></code> </pre> <br>  Jetzt macht unsere Funktion nichts (sie gibt nur den Parameter "Something" zur√ºck).  Aber sie ist v√∂llig rein.  Wenn Sie es mehrmals mit denselben Parametern aufrufen, wird jedes Mal dasselbe zur√ºckgegeben.  Und das ist der springende Punkt.  Um diese Funktion unrein zu machen, m√ºssen wir absichtlich bestimmte Aktionen ausf√ºhren.  Oder anders ausgedr√ºckt: Alles, von dem eine Funktion abh√§ngt, befindet sich in ihrer Signatur.  Es greift nicht auf globale Objekte wie <code>console</code> oder <code>Date</code> .  Dies formalisiert alles. <br><br>  Dar√ºber hinaus ist zu beachten, dass wir andere Funktionen auf unsere Funktion √ºbertragen k√∂nnen, die zuvor nicht sauber war.  Schauen Sie sich ein anderes Beispiel an.  Stellen Sie sich vor, dass es in irgendeiner Form einen Benutzernamen gibt und wir den Wert des entsprechenden Feldes dieser Form erhalten m√ºssen: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> getUserNameFromDOM :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> String function getUserNameFromDOM() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#username'</span></span>).value; } const username = getUserNameFromDOM(); username; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">"mhatter"</span></span></code> </pre> <br>  In diesem Fall versuchen wir, einige Informationen aus dem DOM zu laden.  Reine Funktionen tun dies nicht, da das <code>document</code> ein globales Objekt ist, das sich jederzeit √§ndern kann.  Eine M√∂glichkeit, eine solche Funktion zu bereinigen, besteht darin, ihr das globale <code>document</code> als Parameter zu √ºbergeben.  Sie k√∂nnen die Funktion <code>querySelector()</code> an <code>querySelector()</code> .  Es sieht so aus: <br><br><pre> <code class="hljs powershell">// getUserNameFromDOM :: (String -&gt; Element) -&gt; String <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserNameFromDOM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-variable"><span class="hljs-function"><span class="hljs-params"><span class="hljs-variable">$</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>(<span class="hljs-string"><span class="hljs-string">'#username'</span></span>).value; } // qs :: String -&gt; Element const qs = document.querySelector.bind(document); const username = getUserNameFromDOM(qs); username; //   <span class="hljs-string"><span class="hljs-string">"mhatter"</span></span></code> </pre> <br>  Auch hier k√∂nnten Sie auf den Gedanken kommen, dass dies dumm ist.  Schlie√ülich haben wir hier einfach die Funktion <code>getUsernameFromDOM()</code> , was es uns nicht erlaubt, sie als sauber zu bezeichnen.  Wir haben dies jedoch nicht beseitigt, sondern nur den Aufruf an das DOM an eine andere Funktion, <code>qs()</code> .  Es scheint, dass das einzige auff√§llige Ergebnis dieses Schritts war, dass der neue Code l√§nger als der alte war.  Anstelle einer unreinen Funktion haben wir jetzt zwei Funktionen, von denen eine noch unrein ist. <br><br>  Warten Sie kurz.  Stellen Sie sich vor, wir m√ºssen einen Test f√ºr die Funktion <code>getUserNameFromDOM()</code> schreiben.  √úberlegen Sie nun beim Vergleich der beiden Optionen f√ºr diese Funktion, mit welcher Option Sie leichter arbeiten k√∂nnen.  Damit die Dirty-Version der Funktion √ºberhaupt funktioniert, ben√∂tigen wir ein globales Dokumentobjekt.  Dar√ºber hinaus sollte dieses Dokument ein Element mit der <code>username</code> ID enthalten.  Wenn Sie eine √§hnliche Funktion au√üerhalb des Browsers testen m√ºssen, m√ºssen Sie JSDOM oder einen Browser ohne Benutzeroberfl√§che verwenden.  Bitte beachten Sie, dass dies alles nur ben√∂tigt wird, um eine kleine Funktion mit einer L√§nge von mehreren Zeilen zu testen.  Um die zweite, saubere Version dieser Funktion zu testen, reicht Folgendes aus: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> qsStub = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'mhatter'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = getUserNameFromDOM(qsStub); assert.strictEqual(<span class="hljs-string"><span class="hljs-string">'mhatter'</span></span>, username, <span class="hljs-string"><span class="hljs-string">`Expected username to be </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${username}</span></span></span><span class="hljs-string">`</span></span>);</code> </pre> <br>  Dies bedeutet nat√ºrlich nicht, dass zum Testen solcher Funktionen Integrationstests, die in einem echten Browser durchgef√ºhrt werden (oder zumindest etwas wie JSDOM verwenden), nicht erforderlich sind.  Dieses Beispiel zeigt jedoch eine sehr wichtige Sache: Die Funktion <code>getUserNameFromDOM()</code> ist jetzt vollst√§ndig vorhersehbar.  Wenn wir <code>qsStub()</code> , wird immer <code>mhatter</code> .  Die "Unvorhersehbarkeit" haben wir auf die kleine Funktion <code>qs()</code> verschoben. <br><br>  Bei Bedarf k√∂nnen wir unvorhersehbare Mechanismen auf Ebenen bringen, die noch weiter von der Hauptfunktion entfernt sind.  Infolgedessen k√∂nnen wir sie relativ gesehen in die ‚ÄûGrenzbereiche‚Äú des Codes verschieben.  Dies f√ºhrt dazu, dass wir eine d√ºnne H√ºlle aus unreinem Code haben, die einen gut getesteten und vorhersehbaren Kernel umgibt.  Die Vorhersagbarkeit des Codes erweist sich als √§u√üerst wertvoll, wenn die Gr√∂√üe der von Programmierern erstellten Projekte zunimmt. <br><br><h3>  <font color="#3AC1EF">‚ñç Nachteile des Abh√§ngigkeitsinjektionsmechanismus</font> </h3><br>  Mit der Abh√§ngigkeitsinjektion k√∂nnen Sie eine gro√üe und komplexe Anwendung schreiben.  Ich wei√ü das, da ich selbst eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solche Bewerbung geschrieben habe</a> .  Mit diesem Ansatz wird das Testen vereinfacht und Funktionsabh√§ngigkeiten werden deutlich sichtbar.  Die Abh√§ngigkeitsinjektion ist jedoch nicht ohne M√§ngel.  Das wichtigste ist, dass bei Verwendung sehr lange Funktionssignaturen erhalten werden k√∂nnen: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(doc, con, ftch, store, config, ga, d, random)</span></span></span></span> {   //     } app(document, console, fetch, store, <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>, ga, (new Date()), Math.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>);</code> </pre> <br>  In der Tat ist das nicht so schlimm.  Die Nachteile solcher Konstruktionen zeigen sich, wenn einige der Parameter an bestimmte Funktionen √ºbergeben werden m√ºssen, die sehr tief in andere Funktionen eingebettet sind.  Es sieht so aus, als m√ºssten Parameter √ºber viele Ebenen von Funktionsaufrufen √ºbergeben werden.  Wenn die Anzahl solcher Ebenen zunimmt, beginnt es zu nerven.  Beispielsweise kann es erforderlich sein, das Objekt, das das Datum darstellt, durch 5 Zwischenfunktionen zu √ºbertragen, w√§hrend keine der Zwischenfunktionen dieses Objekt verwendet.  Obwohl nat√ºrlich nicht gesagt werden kann, dass eine solche Situation so etwas wie eine universelle Katastrophe ist.  Dar√ºber hinaus ist es m√∂glich, die Abh√§ngigkeiten von Funktionen klar zu erkennen.  Wie dem auch sei, dies ist immer noch nicht so angenehm.  Daher betrachten wir den folgenden Mechanismus. <br><br><h3>  <font color="#3AC1EF">‚ñç Faule Funktionen</font> </h3><br>  Werfen wir einen Blick auf die zweite L√ºcke, die von Anh√§ngern der funktionalen Programmierung genutzt wird.  Es besteht aus der folgenden Idee: Eine Nebenwirkung ist keine Nebenwirkung, bis sie tats√§chlich auftritt.  Ich wei√ü, das klingt mysteri√∂s.  Um dies herauszufinden, betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs lua">// fZero :: () -&gt; Number <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Launching nuclear missiles'</span></span>);   //          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Ein Beispiel ist vielleicht ein dummes, das wei√ü ich.  Wenn wir die Nummer 0 ben√∂tigen, geben Sie sie einfach an der richtigen Stelle im Code ein, damit sie angezeigt wird.  Und ich wei√ü auch, dass Sie keinen JavaScript-Code zur Kontrolle von Atomwaffen schreiben werden.  Wir ben√∂tigen diesen Code jedoch, um die betreffende Technologie zu veranschaulichen. <br><br>  Hier ist ein Beispiel f√ºr eine unreine Funktion.  Es gibt Daten an die Konsole aus und ist auch die Ursache des Atomkrieges.  Stellen Sie sich jedoch vor, wir brauchen die Null, die diese Funktion zur√ºckgibt.  Stellen Sie sich ein Szenario vor, in dem wir nach dem Start einer Rakete etwas berechnen m√ºssen.  Angenommen, wir m√ºssen m√∂glicherweise einen Countdown-Timer oder √§hnliches starten.  In diesem Fall w√§re es v√∂llig nat√ºrlich, im Voraus √ºber die Berechnungen nachzudenken.  Und wir m√ºssen sicherstellen, dass die Rakete genau bei Bedarf startet.  Wir m√ºssen die Berechnungen nicht so durchf√ºhren, dass sie versehentlich zum Start dieser Rakete f√ºhren k√∂nnten.  <code>fZero()</code> wir uns also, was passiert, wenn wir die Funktion <code>fZero()</code> in eine andere Funktion <code>fZero()</code> , die sie einfach zur√ºckgibt.  Nehmen wir an, es wird so etwas wie ein Sicherheits-Wrapper sein: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fZero :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number function fZero() {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Launching nuclear missiles'</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> returnZeroFunc :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function returnZeroFunc() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fZero; }</code> </pre> <br>  Sie k√∂nnen die Funktion <code>returnZeroFunc()</code> beliebig <code>returnZeroFunc()</code> aufrufen.  In diesem Fall sind wir (theoretisch) sicher, bis die Implementierung dessen, was es zur√ºckgibt, durchgef√ºhrt wird.  In unserem Fall bedeutet dies, dass die Ausf√ºhrung des folgenden Codes nicht zu einem Atomkrieg f√ºhrt: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zeroFunc1 = returnZeroFunc(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zeroFunc2 = returnZeroFunc(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zeroFunc3 = returnZeroFunc(); <span class="hljs-comment"><span class="hljs-comment">//     .</span></span></code> </pre> <br>  Gehen wir nun etwas strenger als zuvor zur Definition des Begriffs ‚Äûreine Funktion‚Äú √ºber.  Auf diese Weise k√∂nnen wir die Funktion <code>returnZeroFunc()</code> genauer untersuchen.  Die Funktion ist also unter folgenden Bedingungen sauber: <br><br><ul><li>  Keine beobachteten Nebenwirkungen. </li><li>  Transparenz verkn√ºpfen.  Das hei√üt, das Aufrufen einer solchen Funktion mit denselben Eingabewerten f√ºhrt immer zu denselben Ergebnissen. </li></ul><br>  <code>returnZeroFunc()</code> die Funktion <code>returnZeroFunc()</code> analysieren. <br><br>  Hat sie irgendwelche Nebenwirkungen?  Wir haben gerade herausgefunden, dass das Aufrufen von <code>returnZeroFunc()</code> keine Raketen <code>returnZeroFunc()</code> .  Wenn Sie nicht aufrufen, was diese Funktion zur√ºckgibt, geschieht nichts.  Daher k√∂nnen wir schlie√üen, dass diese Funktion keine Nebenwirkungen hat. <br><br>  Ist diese Funktion referenziell transparent?  Das hei√üt, gibt es immer dasselbe zur√ºck, wenn dieselben Eingabedaten an es √ºbergeben werden?  Wir werden dies √ºberpr√ºfen und dabei die Tatsache ausnutzen, dass wir im obigen Codefragment diese Funktion mehrmals aufgerufen haben: <br><br><pre> <code class="hljs ruby">zeroFunc1 === zeroFunc2; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> zeroFunc2 === zeroFunc3; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Es sieht alles gut aus, aber die Funktion <code>returnZeroFunc()</code> ist noch nicht vollst√§ndig sauber.  Sie bezieht sich auf eine Variable, die au√üerhalb ihres eigenen Bereichs liegt.  Um dieses Problem zu l√∂sen, schreiben wir die Funktion neu: <br><br><pre> <code class="hljs powershell">// returnZeroFunc :: () -&gt; (() -&gt; Number) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnZeroFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {       console.log(<span class="hljs-string"><span class="hljs-string">'Launching nuclear missiles'</span></span>);       //              <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fZero; }</code> </pre> <br>  Jetzt kann die Funktion als sauber betrachtet werden.  In dieser Situation spielen jedoch JavaScript-Regeln gegen uns.  Wir k√∂nnen n√§mlich den Operator <code>===</code> nicht mehr verwenden, um die referenzielle Transparenz einer Funktion zu √ºberpr√ºfen.  Dies liegt daran, dass <code>returnZeroFunc()</code> immer einen neuen Verweis auf die Funktion <code>returnZeroFunc()</code> .  Die Transparenz der Links kann √ºberpr√ºft werden, indem der Code selbst √ºberpr√ºft wird.  Eine solche Analyse zeigt, dass bei jedem Funktionsaufruf eine Verkn√ºpfung zu derselben Funktion zur√ºckgegeben wird. <br><br>  Vor uns liegt eine nette kleine L√ºcke.  Aber kann es in realen Projekten verwendet werden?  Die Antwort auf diese Frage ist positiv.  Bevor wir jedoch dar√ºber sprechen, wie dies in der Praxis angewendet werden kann, werden wir unsere Idee ein wenig weiterentwickeln.  <code>fZero()</code> n√§mlich zur gef√§hrlichen Funktion <code>fZero()</code> : <br><br><pre> <code class="hljs lua">// fZero :: () -&gt; Number <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Launching nuclear missiles'</span></span>);   //          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Wir werden versuchen, die von dieser Funktion zur√ºckgegebene Null zu verwenden, aber wir werden es tun, damit (bisher) kein Atomkrieg beginnt.  Erstellen Sie dazu eine Funktion, die die von der Funktion <code>fZero()</code> Null nimmt und eine hinzuf√ºgt: <br><br><pre> <code class="hljs powershell">// fIncrement :: (() -&gt; Number) -&gt; Number <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fIncrement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f() + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fIncrement(fZero); //      //   <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Das ist Pech ... Wir haben versehentlich einen Atomkrieg begonnen.  Versuchen wir es noch einmal, aber dieses Mal geben wir keine Nummer zur√ºck.  Stattdessen geben wir eine Funktion zur√ºck, die eines Tages eine Zahl zur√ºckgibt: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fIncrement :: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function fIncrement(f) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; f() + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fIncrement(zero); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   [Function]</code> </pre> <br>  Jetzt k√∂nnen Sie ruhig atmen.  Die Katastrophe wird abgewendet.  Wir setzen die Studie fort.  Dank dieser beiden Funktionen k√∂nnen wir eine ganze Reihe von ‚Äûm√∂glichen Zahlen‚Äú erstellen: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fOne   = fIncrement(zero); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fTwo   = fIncrement(one); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fThree = fIncrement(two); <span class="hljs-comment"><span class="hljs-comment">//   ‚Ä¶</span></span></code> </pre> <br>  Dar√ºber hinaus k√∂nnen wir viele Funktionen erstellen, deren Namen mit <code>f</code> beginnen (nennen wir sie <code>f*()</code> Funktionen), die f√ºr die Arbeit mit ‚Äûm√∂glichen Zahlen‚Äú ausgelegt sind: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fMultiply :: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function fMultiply(a, b) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; a() * b(); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fPow :: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function fPow(a, b) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; Math.pow(a(), b()); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fSqrt :: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function fSqrt(x) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; Math.sqrt(x()); } const fFour = fPow(fTwo, fTwo); const fEight = fMultiply(fFour, fTwo); const fTwentySeven = fPow(fThree, fThree); const fNine = fSqrt(fTwentySeven); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,   . !</code> </pre> <br>  Sehen Sie, was wir hier gemacht haben?  Mit "m√∂glichen Zahlen" k√∂nnen Sie dasselbe tun wie mit gew√∂hnlichen Zahlen.  Mathematiker nennen dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isomorphismus</a> .  Eine gew√∂hnliche Zahl kann immer in eine "m√∂gliche Zahl" umgewandelt werden, indem sie in eine Funktion eingef√ºgt wird.  Sie k√∂nnen die "m√∂gliche Nummer" durch Aufrufen der Funktion erhalten.  Mit anderen Worten, wir haben eine Zuordnung zwischen regul√§ren Zahlen und "m√∂glichen Zahlen".  Dies ist in der Tat viel interessanter, als es scheinen mag.  Bald werden wir auf diese Idee zur√ºckkommen. <br><br>  Die obige Technik unter Verwendung der Wrapper-Funktion ist eine g√ºltige Strategie.  Wir k√∂nnen uns so oft wie n√∂tig hinter Funktionen verstecken.  Und da wir noch keine dieser Funktionen aufgerufen haben, sind theoretisch alle rein.  Und niemand beginnt einen Krieg.  Im regul√§ren Code (nicht raketenbezogen) brauchen wir am Ende tats√§chlich Nebenwirkungen.  Wenn wir alles, was wir brauchen, in eine Funktion einwickeln, k√∂nnen wir diese Effekte pr√§zise steuern.  Wir w√§hlen den Zeitpunkt, zu dem diese Effekte auftreten. <br><br>  Es sollte beachtet werden, dass es nicht sehr bequem ist, √ºberall einheitliche Konstruktionen mit Haufen von Klammern zu verwenden, um Funktionen zu deklarieren.  Das Erstellen neuer Versionen jeder Funktion ist ebenfalls keine angenehme Aktivit√§t.  JavaScript hat einige gro√üartige integrierte Funktionen wie <code>Math.sqrt()</code> .  Es w√§re gro√üartig, wenn es eine M√∂glichkeit g√§be, diese gew√∂hnlichen Funktionen mit unseren ‚Äûausstehenden Werten‚Äú zu verwenden.  Eigentlich werden wir jetzt dar√ºber sprechen. <br><br><h2>  <font color="#3AC1EF">Funktoreffekt</font> </h2><br>  Hier werden wir √ºber Funktoren sprechen, die durch Objekte dargestellt werden, die unsere ‚Äûverz√∂gerten Funktionen‚Äú enthalten.  Zur Darstellung des Funktors verwenden wir das <code>Effect</code> .  Wir werden unsere Funktion <code>fZero()</code> in ein solches Objekt <code>fZero()</code> .  Aber bevor wir dies tun, werden wir diese Funktion ein wenig sicherer machen: <br><br><pre> <code class="hljs lua">// zero :: () -&gt; Number <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Starting with nothing'</span></span>);   //  , ,     .   //       .   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Nun beschreiben wir die Konstruktorfunktion zum Erstellen von Objekten vom Typ <code>Effect</code> : <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}; }</code> </pre> <br>  Da hier nichts besonders Interessantes ist, werden wir an dieser Funktion arbeiten.  Wir wollen also die √ºbliche Funktion <code>fZero()</code> mit dem <code>fZero()</code> .  Um ein solches Szenario bereitzustellen, werden wir eine Methode schreiben, die eine regul√§re Funktion akzeptiert und sie eines Tages auf unseren ‚Äûausstehenden Wert‚Äú anwendet.  Und wir werden dies tun, ohne die <code>Effect</code> aufzurufen.  Wir nennen eine solche Funktionskarte <code>map()</code> .  Es hat einen solchen Namen, weil es eine Zuordnung zwischen der √ºblichen Funktion und der <code>Effect</code> .  Es kann so aussehen: <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       }   } }</code> </pre> <br>  Wenn Sie nun genau beobachten, was passiert, haben Sie m√∂glicherweise Fragen zur Funktion <code>map()</code> .  Es sieht dem Lied verd√§chtig √§hnlich.  Wir werden sp√§ter auf dieses Problem zur√ºckkommen, aber jetzt werden wir testen, was wir im Moment in Aktion haben: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zero = Effect(fZero); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> increment = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   . const one = zero.map(increment);</span></span></code> </pre> <br>  Also ... Jetzt haben wir keine Gelegenheit zu beobachten, was hier passiert ist.  √Ñndern wir daher den <code>Effect</code> , um sozusagen die M√∂glichkeit zu erhalten, "den Abzug zu bet√§tigen": <br><br><pre> <code class="hljs pgsql">// Effect :: <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> -&gt; Effect <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Effect(f) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       },       runEffects(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }   } } const zero = Effect(fZero); const <span class="hljs-keyword"><span class="hljs-keyword">increment</span></span> = x =&gt; x + <span class="hljs-number"><span class="hljs-number">1</span></span>; //  . const one = zero.map(<span class="hljs-keyword"><span class="hljs-keyword">increment</span></span>); one.runEffects(); //       //   <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Bei Bedarf k√∂nnen wir die <code>map()</code> -Funktion weiter aufrufen: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> = x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cube = x =&gt; Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(x, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> eight = Effect(fZero)   .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(increment)   .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)   .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(cube); eight.runEffects(); <span class="hljs-comment"><span class="hljs-comment">//       //   8</span></span></code> </pre> <br>  Hier wird das, was gerade passiert, schon interessanter.  Wir nennen es einen "Funktor".  All dies bedeutet, dass das <code>Effect</code> eine <code>map()</code> Funktion hat und einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regeln</a> befolgt.  Dies sind jedoch keine Regeln, die etwas verbieten.  In diesen Regeln geht es darum, was Sie tun k√∂nnen.  Sie sind eher wie Privilegien.  Da das <code>Effect</code> ein Funktor ist, befolgt es diese Regeln.  Dies ist insbesondere die sogenannte ‚ÄûKompositionsregel‚Äú. <br><br>  Es sieht so aus: <br><br>  Wenn es ein <code>e.map(g).map(f)</code> Namen <code>e</code> und zwei Funktionen <code>f</code> und <code>g</code> , entspricht <code>e.map(g).map(f)</code> <code>e.map(x =&gt; f(g(x)))</code> . <br><br>  Mit anderen Worten, zwei aufeinanderfolgende <code>map()</code> -Methoden entsprechen dem Zusammensetzen von zwei Funktionen.  Dies bedeutet, dass ein Objekt vom Typ <code>Effect</code> √§hnliche Aktionen ausf√ºhren kann (denken Sie an eines der obigen Beispiele): <br><br><pre> <code class="hljs lisp">const incDoubleCube = x =&gt; cube(<span class="hljs-name"><span class="hljs-name">double</span></span>(<span class="hljs-name"><span class="hljs-name">increment</span></span>(<span class="hljs-name"><span class="hljs-name">x</span></span>)))<span class="hljs-comment"><span class="hljs-comment">; //       Ramda  lodash/fp      : // const incDoubleCube = compose(cube, double, increment); const eight = Effect(fZero).map(incDoubleCube);</span></span></code> </pre> <br>  Wenn wir das tun, was hier gezeigt wird, erhalten wir garantiert das gleiche Ergebnis wie bei Verwendung einer Version dieses Codes mit einem dreifachen Aufruf von <code>map()</code> .  Wir k√∂nnen dies verwenden, wenn wir den Code umgestalten, und wir k√∂nnen sicher sein, dass der Code korrekt funktioniert.  In einigen F√§llen kann das √Ñndern eines Ansatzes zu einem anderen sogar die Leistung verbessern. <br><br>  Jetzt schlage ich vor, nicht mehr mit Zahlen zu experimentieren und dar√ºber zu sprechen, wie der in realen Projekten verwendete Code eher aussieht. <br><br><h3>  <font color="#3AC1EF">‚ñçMethode von ()</font> </h3><br>  Der Konstruktor des <code>Effect</code> akzeptiert als Argument eine Funktion.  Dies ist praktisch, da die meisten Nebenwirkungen, die wir verschieben m√∂chten, Funktionen sind.  Dies sind beispielsweise <code>Math.random()</code> und <code>console.log()</code> .  Manchmal m√ºssen Sie jedoch einen Wert in ein <code>Effect</code> einf√ºgen, das keine Funktion ist. , ,       <code>window</code>       .      ,       .       ,       (      -, ,   ,  Haskell   <code>pure</code> ): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> :: a -&gt; Effect a Effect.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span> = function <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(val) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> val); }</code> </pre> <br>     ,      , ,     -.       , ,         .      HTML-      .       ,           .        .  Zum Beispiel: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.myAppConf = {   selectors: {       <span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>:     <span class="hljs-string"><span class="hljs-string">'.userbio'</span></span>,       <span class="hljs-string"><span class="hljs-string">'article-list'</span></span>: <span class="hljs-string"><span class="hljs-string">'#articles'</span></span>,       <span class="hljs-string"><span class="hljs-string">'user-name'</span></span>:    <span class="hljs-string"><span class="hljs-string">'.userfullname'</span></span>,   },   templates: {       <span class="hljs-string"><span class="hljs-string">'greet'</span></span>:  <span class="hljs-string"><span class="hljs-string">'Pleased to meet you, {name}'</span></span>,       <span class="hljs-string"><span class="hljs-string">'notify'</span></span>: <span class="hljs-string"><span class="hljs-string">'You have {n} alerts'</span></span>,   } };</code> </pre> <br> ,    <code>Effect.of()</code> ,          <code>Effect</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> win = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); userBioLocator = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>]); <span class="hljs-comment"><span class="hljs-comment">//   Effect('.userbio')</span></span></code> </pre> <br><h3> <font color="#3AC1EF">‚ñç     Effect    </font> </h3><br>          .      ,   <code>Effect</code> . ,   <code>getElementLocator()</code> ,    <code>Effect</code> ,  .      DOM,    <code>document.querySelector()</code> ‚Äî   ,    .    : <br><br><pre> <code class="hljs powershell">// <span class="hljs-variable"><span class="hljs-variable">$</span></span> :: String -&gt; Effect DOMElement <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> $</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(selector)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect.of(document.querySelector(s)); }</code> </pre> <br> ,      ,     <code>map()</code> : <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userBio = userBioLocator.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>($); <span class="hljs-comment"><span class="hljs-comment">//   Effect(Effect(&lt;div&gt;))</span></span></code> </pre> <br>  ,     ,   .         <code>div</code> ,    <code>map()</code>  ,    ,      . ,    <code>innerHTML</code> ,     : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> innerHTML = userBio.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">eff</span></span></span><span class="hljs-function"> =&gt;</span></span> eff.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">domEl</span></span></span><span class="hljs-function"> =&gt;</span></span> domEl.innerHTML)); <span class="hljs-comment"><span class="hljs-comment">//   Effect(Effect('&lt;h2&gt;User Biography&lt;/h2&gt;'))</span></span></code> </pre> <br>     ,    .   <code>userBio</code> ,    .    ,      ,      ,   . ,   ,      <code>Effect('user-bio')</code> .       ,  ,        ,     : <br><br><pre> <code class="hljs coffeescript">Effect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'.userbio'</span></span>);</code> </pre> <br>    ‚Äî    .     : <br><br><pre> <code class="hljs coffeescript">Effect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>]);</code> </pre> <br> ,     <code>map()</code> ,          (    ).  , ,       <code>$</code> ,    : <br><br><pre> <code class="hljs lisp">Effect(() =&gt; $(<span class="hljs-name"><span class="hljs-name">window</span></span>.myAppConf.selectors['user-bio']))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>    ,   : <br><br><pre> <code class="hljs coffeescript">Effect(   <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Effect.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>]))) );</code> </pre> <br>     <code>Effect.of</code> ,        : <br><br><pre> <code class="hljs coffeescript">Effect(   <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Effect(       <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>])   ) );</code> </pre> <br>    ,   ,    ,      .    <code>Effect</code>   . <br><br><h3> <font color="#3AC1EF">‚ñç join()</font> </h3><br>      ?     ,       <code>Effect</code> .     ,      ,          . <br><br>          <code>Effect</code>    <code>.runEffect()</code>   .     .     , - ,        ,   ,   ,  .      ,    .   <code>join()</code> .          <code>Effect</code> ,   <code>runEffect()</code>   ,        .       ,        . <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       },       runEffects(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       join(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }   } }</code> </pre> <br>       ,          : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userBioHTML = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>])   .map($)   .join()   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.innerHTML); <span class="hljs-comment"><span class="hljs-comment">//   Effect('&lt;h2&gt;User Biography&lt;/h2&gt;')</span></span></code> </pre> <br><h3> <font color="#3AC1EF">‚ñç chain()</font> </h3><br>  ,      <code>.map()</code> ,      <code>.join()</code> ,   .   ,  ,           .         ,     ,   <code>Effect</code> .         ,     <code>.map()</code>  <code>.join()</code> .  ,    ,      <code>Effect</code> : <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       },       runEffects(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       join(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       chain(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(f).map(g).join();       }   } }</code> </pre> <br>      <code>chain()</code> - ,     ,    <code>Effect</code> (  ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>      ).       HTML-        : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userBioHTML = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>])   .chain($)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.innerHTML); <span class="hljs-comment"><span class="hljs-comment">//   Effect('&lt;h2&gt;User Biography&lt;/h2&gt;')</span></span></code> </pre> <br>          -.        . ,    <code>flatMap</code> .     ,       ,   ‚Äî  ,  ,   <code>join()</code> .  Haskell, ,          <code>bind</code> . ,    -       , ,  <code>chain</code> , <code>flatMap</code>  <code>bind</code> ‚Äî     . <br><br><h3> <font color="#3AC1EF">‚ñç  Effect</font> </h3><br>        <code>Effect</code> ,      .              . ,          DOM,      ,    ?  , ,          ,  .    ,      .        ‚Äî   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br><pre> <code class="hljs powershell">// tpl :: String -&gt; Object -&gt; String const tpl = curry(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pattern, data)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.keys(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>).reduce(       (str, key) =&gt; str.replace(new RegExp(`{<span class="hljs-variable"><span class="hljs-variable">$</span></span>{key}}`, data[<span class="hljs-type"><span class="hljs-type">key</span></span>]),       pattern   ); });</code> </pre> <br>    .     : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> win = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.selectors[<span class="hljs-string"><span class="hljs-string">'user-name'</span></span>])   .chain($)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.innerHTML)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: str}); <span class="hljs-comment"><span class="hljs-comment">//   Effect({name: 'Mr. Hatter'}); const pattern = win.map(w =&gt; w.myAppConfig.templates('greeting')); //   Effect('Pleased to meet you, {name}');</span></span></code> </pre> <br> ,        .        .     ( <code>name</code>  <code>pattern</code> )    <code>Effect</code> .     <code>tpl()</code>    ,  ,      <code>Effect</code> . <br>    ,      <code>map()</code>  <code>Effect</code>      <code>tpl()</code> : <br><br><pre> <code class="hljs swift">pattern.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(tpl); <span class="hljs-comment"><span class="hljs-comment">//   Effect([Function])</span></span></code> </pre> <br>   ,    .     <code>map()</code>   : <br><br><pre> <code class="hljs erlang-repl">map :: Effect a ~&gt; (a -&gt; b) -&gt; Effect b</code> </pre> <br>       : <br><br><pre> <code class="hljs rust">tpl :: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; Object -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br> ,      <code>map()</code>  <code>pattern</code> ,      (  ,     <code>tpl()</code> )   <code>Effect</code> . <br><br><pre> <code class="hljs lisp">Effect (<span class="hljs-name"><span class="hljs-name">Object</span></span> -&gt; String)</code> </pre> <br>        <code>pattern</code>  <code>Effect</code> .           .       <code>Effect</code> ,    .   <code>ap()</code> : <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       },       runEffects(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       join(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       chain(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(f).map(g).join();       }       ap(eff) {            //  -  ap,    ,   eff   (  ).           //    map  ,    eff       (  <span class="hljs-string"><span class="hljs-string">'g'</span></span>)           //   g,     f()           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eff.map(g =&gt; g(f()));       }   } }</code> </pre> <br>    <code>.ap()</code>        : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> win = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.selectors[<span class="hljs-string"><span class="hljs-string">'user-name'</span></span>])   .chain($)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.innerHTML)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: str})); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pattern = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.templates(<span class="hljs-string"><span class="hljs-string">'greeting'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = name.ap(pattern.map(tpl)); <span class="hljs-comment"><span class="hljs-comment">//   Effect('Pleased to meet you, Mr Hatter')</span></span></code> </pre> <br>   ,       ‚Ä¶   ,   ,   <code>.ap()</code>    .  ,  ,      <code>map()</code> ,    <code>ap()</code> . ,    ,     . <br><br>      .   ,              .  ,     ,   ,       <code>Effect</code> ,     <code>ap()</code> .    ,    : <br><br><pre> <code class="hljs powershell">// liftA2 :: (a -&gt; b -&gt; c) -&gt; (Applicative a -&gt; Applicative b -&gt; Applicative c) const liftA2 = curry(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">liftA2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y.ap(x.map(f));   //      :   // <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.map(f).chain(g =&gt; y.map(g)); });</code> </pre> <br>    <code>liftA2()</code> ,      ,    .       <code>liftA3()</code> : <br><br><pre> <code class="hljs erlang-repl">// liftA3 :: (a -&gt; b -&gt; c -&gt; d) -&gt; (Applicative a -&gt; Applicative b -&gt; Applicative c -&gt; Applicative d) const liftA3 = curry(function liftA3(f, a, b, c) {   return c.ap(b.ap(a.map(f))); });</code> </pre> <br>    ,    <code>liftA2()</code>  <code>liftA3()</code>   <code>Effect</code>   .  ,      ,    <code>ap()</code> . <br><br>      <code>liftA2()</code>   : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> win = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.selectors[<span class="hljs-string"><span class="hljs-string">'user-name'</span></span>])   .chain($)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.innerHTML)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: str}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pattern = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.templates[<span class="hljs-string"><span class="hljs-string">'greeting'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = liftA2(tpl)(pattern, user); <span class="hljs-comment"><span class="hljs-comment">//   Effect('Pleased to meet you, Mr Hatter')</span></span></code> </pre> <br><h2> <font color="#3AC1EF">  ?</font> </h2><br>      ,   ,    ,   .   ?     ,      <code>Effect</code>     <code>ap()</code>       .   ,        ?         ? <br><br>           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> : ¬´     ,     ,     ¬ª. <br><br>       : <br><br><ul><li>     ‚Äî   ? </li><li>      ,    <code>Effect</code> ,      ? </li></ul><br><h3> <font color="#3AC1EF">‚ñç    </font> </h3><br>   ‚Äî  .      ,      ,     ,    .    <code>const pattern = window.myAppConfig.templates['greeting'];</code>   ,  , , : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pattern = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.templates(<span class="hljs-string"><span class="hljs-string">'greeting'</span></span>));</code> </pre> <br>    ‚Äî ,       ,   ,  ,   .        .   ‚Äî    ,   ,        .       ,    ,    , ,  ,   ,  .      ,           .         ‚Äî  .     ,       ,       ,   .        ,    . <br><br>          .         . <br><br><h3> <font color="#3AC1EF">‚ñç Effect   </font> </h3><br> ,        ,        .    -  <code>Facebook</code>  <code>Gmail</code> .         ?     . <br><br> ,     .       .         CSV-     .     . , ,  ,        . ,         .   ,         .    ,   ,    ,     . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,         . ,      <code>map()</code>  <code>reduce()</code> ,     .     . ,    . ,   ,    ,    .      4  (,  , 8,  16,   ).    ,     ,      .     ,      . ,    -  . <br><br>      ,     ,    .    ,      .  √Ñhnelt nichts?  ,  ,     ,     .                 .           ,     . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TensorFlow</a> ,      . <br><br>  TensorFlow,       ,    .      ¬´¬ª. ,      ,     : <br><br><pre> <code class="hljs pgsql">node1 = tf.<span class="hljs-keyword"><span class="hljs-keyword">constant</span></span>(<span class="hljs-number"><span class="hljs-number">3.0</span></span>, tf.float32) node2 = tf.<span class="hljs-keyword"><span class="hljs-keyword">constant</span></span>(<span class="hljs-number"><span class="hljs-number">4.0</span></span>, tf.float32) node3 = tf.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(node1, node2)</code> </pre> <br>     Python,        JavaScript. ,          <code>Effect</code> ,   <code>add()</code>      ,          (        <code>sess.run()</code> ). <br><br><pre> <code class="hljs go"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"node3: "</span></span>, node3) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"sess.run(node3): "</span></span>, sess.run(node3)) #  node3:  Tensor(<span class="hljs-string"><span class="hljs-string">"Add_2:0"</span></span>, shape=(), dtype=<span class="hljs-keyword"><span class="hljs-keyword">float32</span></span>) #  sess.run(node3):  <span class="hljs-number"><span class="hljs-number">7.0</span></span></code> </pre> <br>  ,  (7.0)      ,    <code>sess.run()</code> .  ,        .       ,  ,   ,   . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>       ,    .  ,        .       <code>Effect</code> . <br>       ,    ,    ,  ,   ,    . ,    ,      .  <code>Effect</code> ,   ,   ,     .      ,     . <br><br>    ‚Äî    .         ,    .     ,  ,  .    .         .          ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br>  <b>Liebe Leser!</b>         ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422589/">https://habr.com/ru/post/de422589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422577/index.html">Kopien und Urheberrechte: Wie Patent und Urheberrecht die Entwicklung des 3D-Drucks beeinflussen</a></li>
<li><a href="../de422581/index.html">Quantenschalter nach Schr√∂dinger</a></li>
<li><a href="../de422583/index.html">Tough Middling: Snom D735 IP-Telefon Bewertung</a></li>
<li><a href="../de422585/index.html">Die praktische Verwendung neuronaler Netze</a></li>
<li><a href="../de422587/index.html">Vorbereitung und Weitergabe von IELTS: pers√∂nliche Erfahrung</a></li>
<li><a href="../de422591/index.html">Anomalie der Corona SDK json-Bibliothek</a></li>
<li><a href="../de422593/index.html">Verstecke dich ohne dich zu verstecken. Noch einmal √ºber LSB-Steganographie, Chi-Quadrat und ... Singularit√§t?</a></li>
<li><a href="../de422595/index.html">Russische Wissenschaftler haben einen Motor f√ºr Cubesat mit einer 40% igen Alkoholl√∂sung entwickelt</a></li>
<li><a href="../de422597/index.html">Backend United # 2: F√ºllung</a></li>
<li><a href="../de422601/index.html">Chrome 69 verf√ºgt √ºber einen Zufallskennwortgenerator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>