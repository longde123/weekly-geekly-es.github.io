<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ΩüèΩ üèçÔ∏è üöÄ JavaScript-Handbuch Teil 4: Funktionen üö∂üèº ‚ö™Ô∏è ü••</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute ver√∂ffentlichen wir den vierten Teil der √úbersetzung des JavaScript-Handbuchs, das den Funktionen gewidmet ist. 

 ‚Üí Teil 1: Erstes Programm, Sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Handbuch Teil 4: Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/430382/">  Heute ver√∂ffentlichen wir den vierten Teil der √úbersetzung des JavaScript-Handbuchs, das den Funktionen gewidmet ist. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Erstes Programm, Sprachfunktionen, Standards</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Codestil und Programmstruktur</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Variablen, Datentypen, Ausdr√ºcke, Objekte</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Funktionen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Arrays und Loops</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6: Ausnahmen, Semikolons, Platzhalterliterale</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7: Strict Mode, dieses Schl√ºsselwort, Ereignisse, Module, mathematische Berechnungen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 8: √úbersicht √ºber die ES6-Funktionen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 9: √úbersicht √ºber die ES7-, ES8- und ES9-Standards</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><br><h2>  <font color="#3AC1EF">JavaScript-Funktionen</font> </h2><br>  Lassen Sie uns √ºber Funktionen in JavaScript sprechen, sie allgemein √ºberpr√ºfen und die Details zu ihnen betrachten, deren Kenntnis es Ihnen erm√∂glicht, sie effektiv zu nutzen. <br><a name="habracut"></a><br>  Eine Funktion ist ein unabh√§ngiger Codeblock, der nach seiner Deklaration beliebig oft aufgerufen werden kann.  Eine Funktion kann Parameter akzeptieren, obwohl dies nicht erforderlich ist.  Funktionen geben einen einzelnen Wert zur√ºck. <br><br>  Funktionen in JavaScript sind Objekte bzw. Objekte vom Typ <code>Function</code> .  Ihr Hauptunterschied zu gew√∂hnlichen Objekten, der ihnen die au√üergew√∂hnlichen F√§higkeiten verleiht, die sie besitzen, besteht darin, dass Funktionen aufgerufen werden k√∂nnen. <br><br>  Dar√ºber hinaus werden Funktionen in JavaScript als ‚Äûerstklassige Funktionen‚Äú bezeichnet, da sie Variablen zugewiesen, als Argumente an andere Funktionen √ºbergeben und von anderen Funktionen zur√ºckgegeben werden k√∂nnen. <br><br>  Zun√§chst betrachten wir die Merkmale der Arbeit mit Funktionen und die entsprechenden syntaktischen Konstruktionen, die in der Sprache vor dem Aufkommen des ES6-Standards existierten und immer noch relevant sind. <br><br>  So sieht eine Funktionsdeklaration aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Heutzutage werden diese Funktionen als "normal" bezeichnet und unterscheiden sie von den "Pfeil" -Funktionen, die in ES6 angezeigt wurden. <br><br>  Sie k√∂nnen einer Variablen oder Konstante eine Funktion zuweisen.  Eine solche Konstruktion wird als Funktionsausdruck bezeichnet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  M√∂glicherweise stellen Sie fest, dass die Funktion im obigen Beispiel einer Konstanten zugewiesen ist, aber selbst keinen Namen hat.  Solche Funktionen werden anonym genannt.  √Ñhnlichen Funktionen k√∂nnen Namen zugewiesen werden.  In diesem Fall handelt es sich um einen benannten Funktionsausdruck (benannten Funktionsausdruck). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Die Verwendung solcher Ausdr√ºcke erh√∂ht die Benutzerfreundlichkeit des Debuggens (in Fehlermeldungen, in denen die Stapelverfolgung ausgef√ºhrt wird, ist der Name der Funktion sichtbar).  Der Name der Funktion in einem Funktionsausdruck kann auch ben√∂tigt werden, damit sich die Funktion selbst aufrufen kann, was f√ºr die Implementierung rekursiver Algorithmen unabdingbar ist. <br><br>  Im ES6-Standard sind Pfeilfunktionen erschienen, die besonders bequem in Form von sogenannten ‚ÄûInline-Funktionen‚Äú zu verwenden sind - als Argumente, die an andere Funktionen √ºbergeben werden (R√ºckrufe). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Pfeilfunktionen sind zus√§tzlich zu der Tatsache, dass die Strukturen, mit denen sie deklariert werden, kompakter sind als die Verwendung gew√∂hnlicher Funktionen, sie unterscheiden sich von ihnen in einigen wichtigen Merkmalen, die wir unten diskutieren werden. <br><br><h2>  <font color="#3AC1EF">Funktionsparameter</font> </h2><br>  Parameter sind Variablen, die in der Phase der Deklaration einer Funktion festgelegt werden und die an sie √ºbergebenen Werte enthalten (diese Werte werden als Argumente bezeichnet).  Funktionen in JavaScript haben m√∂glicherweise entweder keine Parameter oder einen oder mehrere Parameter. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const doSomethingElse = foo =&gt; { // - } const doSomethingElseAgain = (foo, bar) =&gt; { // - }</span></span></code> </pre> <br>  Hier sind einige Beispiele f√ºr Pfeilfunktionen. <br><br>  Ab dem ES6-Standard k√∂nnen Funktionen sogenannte ‚ÄûStandardparameter‚Äú haben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Sie stellen Standardwerte dar, die durch die Parameter von Funktionen festgelegt werden, wenn beim Aufruf die Werte einiger Parameter nicht festgelegt werden.  Zum Beispiel kann die oben gezeigte Funktion sowohl durch √úbergabe aller zwei empfangenen Parameter als auch durch andere Methoden aufgerufen werden. <br><br><pre> <code class="javascript hljs">doSomething(<span class="hljs-number"><span class="hljs-number">3</span></span>) doSomething()</code> </pre> <br>  In ES8 k√∂nnen Sie jetzt nach dem letzten Argument einer Funktion ein Komma setzen (dies wird als nachfolgendes Komma bezeichnet).  Mit dieser Funktion k√∂nnen Sie den Code einfacher bearbeiten, wenn Sie Versionskontrollsysteme w√§hrend der Programmentwicklung verwenden.  Details dazu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  An Funktionen √ºbergebene Argumente k√∂nnen als Arrays dargestellt werden.  Um diese Argumente zu analysieren, k√∂nnen Sie einen Operator verwenden, der wie drei Punkte aussieht (dies ist der sogenannte "Erweiterungsoperator" oder "Spread-Operator").  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const args = [2, 'ho!'] doSomething(...args)</span></span></code> </pre> <br>  Wenn Funktionen viele Parameter annehmen m√ºssen, kann es schwierig sein, sich die Reihenfolge ihrer Reihenfolge zu merken.  In solchen F√§llen werden Objekte mit Parametern und M√∂glichkeiten zur Destrukturierung von ES6-Objekten verwendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - console.log(foo) // 2 console.log(bar) // 'ho!' } const args = { foo: 2, bar: 'ho!' } doSomething(args)</span></span></code> </pre> <br>  Diese Technik erm√∂glicht es, die Parameter in Form von Objekteigenschaften zu beschreiben und die Funktion an das Objekt zu √ºbergeben, um der Funktion den Zugriff auf die Parameter anhand ihrer Namen zu erm√∂glichen, ohne zus√§tzliche Konstruktionen zu verwenden.  Lesen Sie hier mehr √ºber diese Technik. <br><br><h2>  <font color="#3AC1EF">Von Funktionen zur√ºckgegebene Werte</font> </h2><br>  Alle Funktionen geben einen bestimmten Wert zur√ºck.  Wenn der R√ºckgabebefehl nicht explizit angegeben wird, gibt die Funktion <code>undefined</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } console.log(doSomething())</span></span></code> </pre> <br>  Die Funktionsausf√ºhrung endet entweder, nachdem der gesamte darin enthaltene Code ausgef√ºhrt wurde, oder nachdem das Schl√ºsselwort <code>return</code> im Code gefunden wurde.  Wenn dieses Schl√ºsselwort in einer Funktion gefunden wird, ist seine Operation abgeschlossen und die Steuerung wird an den Ort √ºbertragen, von dem aus die Funktion aufgerufen wurde. <br><br>  Wenn Sie nach dem Schl√ºsselwort <code>return</code> einen bestimmten Wert angeben, kehrt dieser Wert als Ergebnis der Ausf√ºhrung dieser Funktion an die Stelle des Funktionsaufrufs zur√ºck. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = doSomething() <span class="hljs-comment"><span class="hljs-comment">// result === 'test'</span></span></code> </pre> <br>  Von einer Funktion kann nur ein Wert zur√ºckgegeben werden.  Um mehrere Werte zur√ºckgeben zu k√∂nnen, k√∂nnen Sie sie entweder als Objekt mit einem Objektliteral oder als Array zur√ºckgeben und beim Aufrufen einer Funktion das destruktive Zuweisungskonstrukt verwenden.  Parameternamen werden gespeichert.  Wenn Sie gleichzeitig mit einem Objekt oder einem Array arbeiten m√ºssen, das von einer Funktion zur√ºckgegeben wird, und zwar in Form eines Objekts oder eines Arrays, k√∂nnen Sie auf eine destruktive Zuweisung verzichten. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [ name, age ] = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br>  Die Konstruktion <code>const [ name, age ] = doSomething()</code> kann wie folgt gelesen werden: "Deklarieren Sie die Konstanten <code>name</code> und <code>age</code> und weisen Sie ihnen die Werte der Elemente des Arrays zu, die die Funktion zur√ºckgeben wird." <br>  So sieht das gleiche mit einem Objekt aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, age } = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Verschachtelte Funktionen</font> </h2><br>  Funktionen k√∂nnen in anderen Funktionen deklariert werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingElse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {} doSomethingElse() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } doSomething()</code> </pre> <br>  Der Umfang einer verschachtelten Funktion wird durch eine externe Funktion begrenzt, die nicht von au√üen aufgerufen werden kann. <br><br><h2>  <font color="#3AC1EF">Objektmethoden</font> </h2><br>  Wenn Funktionen als Eigenschaften von Objekten verwendet werden, werden solche Funktionen als Objektmethoden bezeichnet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started`</span></span>) } } car.start()</code> </pre> <br><h2>  <font color="#3AC1EF">Dieses Schl√ºsselwort</font> </h2><br>  Wenn wir Pfeil- und gew√∂hnliche Funktionen vergleichen, die als Methoden von Objekten verwendet werden, k√∂nnen wir ihren wichtigen Unterschied feststellen, der in der Bedeutung des Schl√ºsselworts <code>this</code> .  Betrachten Sie ein Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Stopped </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) } } car.start() <span class="hljs-comment"><span class="hljs-comment">//Started Ford Fiesta car.stop() //Stopped undefined undefined</span></span></code> </pre> <br>  Wie Sie sehen, f√ºhrt der Aufruf der Methode <code>start()</code> zum erwarteten Ergebnis, aber die Methode <code>stop()</code> funktioniert offensichtlich nicht richtig. <br><br>  Dies liegt an der Tatsache, dass sich das Schl√ºsselwort this bei Verwendung in Pfeil- und normalen Funktionen unterschiedlich verh√§lt.  Das <code>this</code> in der Pfeilfunktion enth√§lt n√§mlich einen Link zu dem Kontext, der die Funktion enth√§lt.  In diesem Fall ist dieser Kontext beim Browser das <code>window</code> . <br><br>  So sieht die Ausf√ºhrung eines solchen Codes in der Browserkonsole aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">arrFn</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } test.fn() test.arrFn()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b3/7c4/c29/4b37c4c299f7f21c40c77c372d34974f.png"></div><br>  <i><font color="#999999">Dieses Schl√ºsselwort ist in herk√∂mmlichen und Pfeilfunktionen enthalten</font></i> <br><br>  Wie Sie sehen k√∂nnen, bedeutet das Aufrufen in einer regul√§ren Funktion das Aufrufen des Objekts, und <code>this</code> in der Pfeilfunktion zeigt auf das <code>window</code> . <br><br>  All dies bedeutet, dass Pfeilfunktionen nicht f√ºr die Rolle von Objekt- und Konstruktormethoden geeignet sind (wenn Sie versuchen, die <code>TypeError</code> als Konstruktor zu verwenden, wird ein <code>TypeError</code> ). <br><br><h2>  <font color="#3AC1EF">Funktionsausdr√ºcke werden sofort aufgerufen</font> </h2><br>  Der sofort aufgerufene Funktionsausdruck (IIFE) ist eine Funktion, die unmittelbar nach ihrer Deklaration automatisch aufgerufen wird. <br><br><pre> <code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'executed'</span></span>) })()</code> </pre> <br>  Das Semikolon vor IIFE ist optional, aber seine Verwendung erm√∂glicht es Ihnen, sich gegen Fehler zu versichern, die mit der automatischen Platzierung von Semikolons verbunden sind. <br><br>  Im obigen Beispiel wird das <code>executed</code> Wort an die Konsole gesendet, wonach IIFE beendet wird.  IIFE kann wie andere Funktionen die Ergebnisse ihrer Arbeit zur√ºckgeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'IIFE'</span></span> })() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(something)</code> </pre> <br>  Nach dem Ausf√ºhren dieses einfachen Beispiels erh√§lt die Konsole die <code>IIFE</code> Zeile, die sich nach dem Ausf√ºhren des sofort aufgerufenen Funktionsausdrucks als <code>something</code> herausstellte.  Es scheint, dass ein solches Design keinen besonderen Nutzen bringt.  Wenn jedoch in IIFE einige komplexe Berechnungen durchgef√ºhrt werden, die nur einmal durchgef√ºhrt werden m√ºssen, wonach die entsprechenden Mechanismen nicht mehr erforderlich sind, liegt der Nutzen von IIFE auf der Hand.  Bei diesem Ansatz ist n√§mlich nach Ausf√ºhrung von IIFE nur das von der Funktion zur√ºckgegebene Ergebnis im Programm verf√ºgbar.  Dar√ºber hinaus k√∂nnen wir uns daran erinnern, dass Funktionen andere Funktionen und Objekte zur√ºckgeben k√∂nnen.  Wir sprechen √ºber Schlie√üungen, wir werden unten dar√ºber sprechen. <br><br><h2>  <font color="#3AC1EF">Funktionserweiterung</font> </h2><br>  Bevor der JavaScript-Code ausgef√ºhrt wird, wird er neu organisiert.  Wir haben bereits √ºber den Hebemechanismus f√ºr Variablen gesprochen, die mit dem Schl√ºsselwort <code>var</code> deklariert wurden.  Ein √§hnlicher Mechanismus funktioniert mit Funktionen.  Wir sprechen n√§mlich von der Tatsache, dass Deklarationen von Funktionen w√§hrend der Verarbeitung des Codes vor seiner Ausf√ºhrung in den oberen Teil ihres G√ºltigkeitsbereichs verschoben werden.  Als Ergebnis stellt sich beispielsweise heraus, dass Sie die Funktion aufrufen k√∂nnen, bevor sie deklariert wird. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//did something function doSomething() { console.log('did something') }</span></span></code> </pre> <br>  Wenn Sie einen Funktionsaufruf so verschieben, dass er seiner Deklaration folgt, √§ndert sich nichts. <br><br>  Wenn in einer √§hnlichen Situation ein Funktionsausdruck verwendet wird, gibt ein √§hnlicher Code einen Fehler aus. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//TypeError var doSomething = function () { console.log('did something') }</span></span></code> </pre> <br>  In diesem Fall stellt sich heraus, dass die Deklaration der Variablen <code>doSomething</code> an die Spitze des Bereichs steigt, dies jedoch nicht f√ºr die Zuweisungsoperation gilt. <br>  Wenn Sie in einer √§hnlichen Situation anstelle von <code>var</code> die Schl√ºsselw√∂rter <code>let</code> oder <code>const</code> , funktioniert dieser Code ebenfalls nicht. Das System zeigt jedoch eine andere Fehlermeldung an ( <code>ReferenceError</code> anstelle von <code>TypeError</code> ), da bei Verwendung von <code>let</code> und <code>const</code> keine Variablen- und Konstantendeklarationen <code>TypeError</code> werden. <br><br><h2>  <font color="#3AC1EF">Pfeilfunktionen</font> </h2><br>  Jetzt werden wir mehr √ºber Pfeilfunktionen sprechen, die wir bereits getroffen haben.  Sie k√∂nnen als eine der bedeutendsten Neuerungen des ES6-Standards angesehen werden. Sie unterscheiden sich von gew√∂hnlichen Funktionen nicht nur im Aussehen, sondern auch in ihrem Verhalten.  Heutzutage sind sie extrem weit verbreitet.  Vielleicht gibt es kein einziges modernes Projekt, bei dem sie in den allermeisten F√§llen nicht verwendet w√ºrden.  Wir k√∂nnen sagen, dass ihr Aussehen das Aussehen des JS-Codes und die Merkmale seiner Arbeit f√ºr immer ver√§ndert hat. <br><br>  Aus rein externer Sicht ist die Syntax zum Deklarieren von Pfeilfunktionen kompakter als die Syntax gew√∂hnlicher Funktionen.  Hier ist eine regul√§re Funktionsdeklaration. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Hier ist die Ank√ºndigung der Pfeilfunktion, die im Allgemeinen, wenn Sie die Merkmale der Pfeilfunktionen nicht ber√ºcksichtigen, der vorherigen √§hnlich ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Wenn der Hauptteil einer Pfeilfunktion nur einen Befehl enth√§lt, dessen Ergebnis diese Funktion zur√ºckgibt, kann er ohne geschweifte Klammern und ohne das Schl√ºsselwort <code>return</code> .  Eine solche Funktion gibt beispielsweise die Summe der an sie √ºbergebenen Argumente zur√ºck. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//3</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, sind die Parameter der Pfeilfunktionen wie bei normalen Funktionen in Klammern beschrieben.  Wenn eine solche Funktion nur einen Parameter akzeptiert, kann sie au√üerdem ohne Klammern angegeben werden.  Hier ist beispielsweise eine Funktion, die das Ergebnis der Division der √ºbergebenen Zahl durch 2 zur√ºckgibt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">8</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//4</span></span></code> </pre> <br>  Infolgedessen stellt sich heraus, dass Pfeilfunktionen in Situationen, in denen kleine Funktionen ben√∂tigt werden, sehr praktisch sind. <br><br><h3>  <font color="#3AC1EF">‚ñç Implizite R√ºckgabe von Funktionsergebnissen</font> </h3><br>  Wir haben dieses Merkmal der Pfeilfunktionen bereits angesprochen, aber es ist so wichtig, dass es ausf√ºhrlicher besprochen werden sollte.  Wir sprechen √ºber die Tatsache, dass einzeilige Pfeilfunktionen die implizite R√ºckgabe der Ergebnisse ihrer Arbeit unterst√ºtzen.  Ein Beispiel f√ºr die R√ºckgabe eines primitiven Werts aus einer einzeiligen Pfeilfunktion, die wir bereits gesehen haben.  Was ist, wenn eine solche Funktion ein Objekt zur√ºckgeben sollte?  In diesem Fall k√∂nnen die geschweiften Klammern des Objektliteral das System verwirren, sodass im Hauptteil der Funktion Klammern verwendet werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'test'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = myFunction() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.value) <span class="hljs-comment"><span class="hljs-comment">//test</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Schl√ºsselwort this und Pfeilfunktionen</font> </h3><br>  Als wir uns oben die Funktionen <code>this</code> , haben wir regul√§re und Pfeilfunktionen verglichen.  Dieser Abschnitt soll Ihre Aufmerksamkeit auf die Bedeutung ihrer Unterschiede lenken.  Das <code>this</code> kann an sich bestimmte Schwierigkeiten verursachen, da es vom Kontext der Codeausf√ºhrung abh√§ngt und davon, ob der strikte Modus aktiviert ist oder nicht. <br><br>  Wie wir gesehen haben, zeigt dies bei Verwendung des <code>this</code> in einer Methode eines Objekts, das durch eine regul√§re Funktion dargestellt wird, auf das Objekt, zu dem die Methode geh√∂rt.  In diesem Fall geht es darum, das Schl√ºsselwort <code>this</code> an einen Wert zu binden, der den Kontext der Funktion darstellt.  Insbesondere wenn eine Funktion als Objektmethode aufgerufen wird, ist das Schl√ºsselwort this an dieses Objekt gebunden. <br><br>  Bei Pfeilfunktionen stellt sich heraus, dass <code>this</code> Bindung in ihnen nicht ausgef√ºhrt wird. Sie verwenden das <code>this</code> aus ihrem G√ºltigkeitsbereich.  Daher werden sie nicht zur Verwendung als Objektmethoden empfohlen. <br><br>  Das gleiche Problem tritt auf, wenn Funktionen als Ereignishandler f√ºr DOM-Elemente verwendet werden.  Beispielsweise wird die HTML-Elementschaltfl√§che verwendet, um Schaltfl√§chen zu beschreiben.  Das <code>click</code> wird <code>click</code> wenn ein Benutzer auf eine Schaltfl√§che klickt.  Um auf dieses Ereignis im Code zu reagieren, m√ºssen Sie zuerst einen Link zum entsprechenden Element abrufen und ihm dann als Funktion einen <code>click</code> zuweisen.  Als solcher Handler k√∂nnen Sie sowohl die regul√§re Funktion als auch die Pfeilfunktion verwenden.  Wenn Sie jedoch im Ereignishandler auf das Element zugreifen m√ºssen, f√ºr das es aufgerufen wird (dh <code>this</code> ), funktioniert die Pfeilfunktion hier nicht, da der darin verf√ºgbare Wert auf das <code>window</code> verweist.  Um dies in der Praxis zu testen, erstellen Sie eine HTML-Seite, deren Code unten angezeigt wird, und klicken Sie auf die Schaltfl√§chen. <br><br><pre> <code class="javascript hljs">&lt;!DOCTYPE html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Arrow function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="xml"><span class="javascript">     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> f = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="javascript">)     f.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></span><span class="xml"><span class="javascript"><span class="hljs-function"> (</span></span></span><span class="hljs-params"></span><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span></span><span class="xml"><span class="javascript">{         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === f)     })     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> af = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="javascript">)     af.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, () =&gt; {         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">window</span></span></span></span><span class="xml"><span class="javascript">)     })   </span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  In diesem Fall werden beim Klicken auf diese Schaltfl√§chen Fenster mit <code>true</code> angezeigt.  In der Klickereignishandler der Schaltfl√§che mit dem Bezeichner <code>fn</code> wird jedoch die Gleichheit von <code>this</code> der Schaltfl√§che √ºberpr√ºft, und in der Schaltfl√§che mit dem BezeichnerpfeilFn wird die Gleichheit von <code>this</code> und dem Objekt des <code>window</code> √ºberpr√ºft. <br><br>  Wenn Sie <code>this</code> im Ereignishandler des HTML-Elements aufrufen m√ºssen, funktioniert die Pfeilfunktion daher f√ºr das Design eines solchen Handlers nicht. <br><br><h2>  <font color="#3AC1EF">Kurzschl√ºsse</font> </h2><br>  Verschl√ºsse sind ein wichtiges Konzept in JavaScript.  Wenn Sie JS-Funktionen geschrieben haben, haben Sie auch Verschl√ºsse verwendet.  Verschl√ºsse werden in einigen Entwurfsmustern verwendet - f√ºr den Fall, dass Sie eine strikte Kontrolle des Zugriffs auf bestimmte Daten oder Funktionen organisieren m√ºssen. <br><br>  Wenn eine Funktion aufgerufen wird, hat sie Zugriff auf alles, was sich im externen Bereich befindet.  Es gibt jedoch keinen Zugriff auf das, was in der Funktion deklariert ist.  Das hei√üt, wenn eine Variable (oder eine andere Funktion) in einer Funktion deklariert wurde, kann entweder w√§hrend der Ausf√ºhrung der Funktion oder nach Abschluss ihrer Arbeit nicht auf externen Code zugegriffen werden.  Wenn jedoch eine andere Funktion von der Funktion zur√ºckgegeben wird, hat diese neue Funktion Zugriff auf alles, was in der urspr√ºnglichen Funktion deklariert wurde.  In diesem Fall wird all dies vor dem externen Code im Abschluss verborgen. <br><br>  Betrachten Sie ein Beispiel.  Hier ist eine Funktion, die den Namen des Hundes √ºbernimmt und ihn dann in der Konsole anzeigt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> ;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say))() } bark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  Der von dieser Funktion zur√ºckgegebene Wert interessiert uns noch nicht, der Text wird mit IIFE in der Konsole angezeigt, was in diesem Fall keine besondere Rolle spielt. Dies hilft uns jedoch, den Zusammenhang zwischen dieser Funktion und ihrer Variante zu erkennen, in der anstelle einer angezeigten Funktion eine Funktion aufgerufen wird Text an die Konsole, wir werden diese Funktion von der umgeschriebenen Funktion <code>bark()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) bark() <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  Das Ergebnis des Codes ist in zwei F√§llen dasselbe.  Im zweiten Fall wird jedoch das, was beim Aufrufen auf die urspr√ºngliche Funktion √ºbertragen wurde (der Name des Hundes, <code>Roger</code> ), im Verschluss gespeichert und anschlie√üend von einer anderen vom Original zur√ºckgegebenen Funktion verwendet. <br><br>  Lassen Sie uns ein weiteres Experiment durchf√ºhren - erstellen Sie mit der urspr√ºnglichen Funktion zwei neue f√ºr verschiedene Hunde. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rogerBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sydBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Syd`</span></span>) rogerBark() sydBark()</code> </pre> <br>  Dieser Code gibt Folgendes aus. <br><br><pre> <code class="javascript hljs">Roger barked! Syd barked!</code> </pre> <br>  Es stellt sich heraus, dass der Wert der <code>say</code> Konstante an die Funktion gebunden ist, die von der <code>prepareBark()</code> -Funktion zur√ºckgegeben wird. <br><br>  Beachten Sie, <code>say</code> beim <code>prepareBark()</code> Aufruf von <code>prepareBark()</code> ein neuer Wert <code>prepareBark()</code> wird, w√§hrend sich der Wert, der beispielsweise <code>say</code> ersten Aufruf von <code>prepareBark()</code> aufgezeichnet wurde <code>say</code> nicht √§ndert.  Der Punkt ist, dass mit jedem Aufruf dieser Funktion ein neuer Abschluss erstellt wird. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir √ºber gew√∂hnliche und Pfeilfunktionen gesprochen, √ºber die Merkmale ihrer Deklaration und Verwendung, dar√ºber, wie sich <code>this</code> Schl√ºsselwort in verschiedenen Situationen verh√§lt, und √ºber Schlie√üungen.  Das n√§chste Mal diskutieren wir Arrays und Schleifen. <br><br>  <b>Liebe Leser!</b>  Wie stehen Sie zu Pfeilfunktionen in JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430382/">https://habr.com/ru/post/de430382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430372/index.html">Wasserstoffauto. Ist es Zeit, sich vom Benzin zu verabschieden?</a></li>
<li><a href="../de430374/index.html">Data Engineering und mehr: Wrike-Videob√§nder und -Dias aus dem Meeting</a></li>
<li><a href="../de430376/index.html">JavaScript-Handbuch Teil 6: Ausnahmen, Semikolons, Vorlagenliterale</a></li>
<li><a href="../de430378/index.html">J2CL - Besser sp√§t als nie</a></li>
<li><a href="../de430380/index.html">JavaScript-Handbuch Teil 5: Arrays und Loops</a></li>
<li><a href="../de430384/index.html">Erstellen von Karten aus Rauschfunktionen</a></li>
<li><a href="../de430386/index.html">Festk√∂rperspeicherkraftwerk in Indien gebaut werden</a></li>
<li><a href="../de430388/index.html">Web Summit Unconference</a></li>
<li><a href="../de430392/index.html">Wie ich APIs mit meinem PieceofScript-Fahrrad entwickle und teste</a></li>
<li><a href="../de430394/index.html">Implementierung der Sofort-Suche in Android mit RxJava</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>