<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏽 🏍️ 🚀 JavaScript-Handbuch Teil 4: Funktionen 🚶🏼 ⚪️ 🥥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute veröffentlichen wir den vierten Teil der Übersetzung des JavaScript-Handbuchs, das den Funktionen gewidmet ist. 

 → Teil 1: Erstes Programm, Sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Handbuch Teil 4: Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/430382/">  Heute veröffentlichen wir den vierten Teil der Übersetzung des JavaScript-Handbuchs, das den Funktionen gewidmet ist. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Erstes Programm, Sprachfunktionen, Standards</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Codestil und Programmstruktur</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Variablen, Datentypen, Ausdrücke, Objekte</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Funktionen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Arrays und Loops</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6: Ausnahmen, Semikolons, Platzhalterliterale</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7: Strict Mode, dieses Schlüsselwort, Ereignisse, Module, mathematische Berechnungen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 8: Übersicht über die ES6-Funktionen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 9: Übersicht über die ES7-, ES8- und ES9-Standards</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><br><h2>  <font color="#3AC1EF">JavaScript-Funktionen</font> </h2><br>  Lassen Sie uns über Funktionen in JavaScript sprechen, sie allgemein überprüfen und die Details zu ihnen betrachten, deren Kenntnis es Ihnen ermöglicht, sie effektiv zu nutzen. <br><a name="habracut"></a><br>  Eine Funktion ist ein unabhängiger Codeblock, der nach seiner Deklaration beliebig oft aufgerufen werden kann.  Eine Funktion kann Parameter akzeptieren, obwohl dies nicht erforderlich ist.  Funktionen geben einen einzelnen Wert zurück. <br><br>  Funktionen in JavaScript sind Objekte bzw. Objekte vom Typ <code>Function</code> .  Ihr Hauptunterschied zu gewöhnlichen Objekten, der ihnen die außergewöhnlichen Fähigkeiten verleiht, die sie besitzen, besteht darin, dass Funktionen aufgerufen werden können. <br><br>  Darüber hinaus werden Funktionen in JavaScript als „erstklassige Funktionen“ bezeichnet, da sie Variablen zugewiesen, als Argumente an andere Funktionen übergeben und von anderen Funktionen zurückgegeben werden können. <br><br>  Zunächst betrachten wir die Merkmale der Arbeit mit Funktionen und die entsprechenden syntaktischen Konstruktionen, die in der Sprache vor dem Aufkommen des ES6-Standards existierten und immer noch relevant sind. <br><br>  So sieht eine Funktionsdeklaration aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Heutzutage werden diese Funktionen als "normal" bezeichnet und unterscheiden sie von den "Pfeil" -Funktionen, die in ES6 angezeigt wurden. <br><br>  Sie können einer Variablen oder Konstante eine Funktion zuweisen.  Eine solche Konstruktion wird als Funktionsausdruck bezeichnet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Möglicherweise stellen Sie fest, dass die Funktion im obigen Beispiel einer Konstanten zugewiesen ist, aber selbst keinen Namen hat.  Solche Funktionen werden anonym genannt.  Ähnlichen Funktionen können Namen zugewiesen werden.  In diesem Fall handelt es sich um einen benannten Funktionsausdruck (benannten Funktionsausdruck). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Die Verwendung solcher Ausdrücke erhöht die Benutzerfreundlichkeit des Debuggens (in Fehlermeldungen, in denen die Stapelverfolgung ausgeführt wird, ist der Name der Funktion sichtbar).  Der Name der Funktion in einem Funktionsausdruck kann auch benötigt werden, damit sich die Funktion selbst aufrufen kann, was für die Implementierung rekursiver Algorithmen unabdingbar ist. <br><br>  Im ES6-Standard sind Pfeilfunktionen erschienen, die besonders bequem in Form von sogenannten „Inline-Funktionen“ zu verwenden sind - als Argumente, die an andere Funktionen übergeben werden (Rückrufe). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Pfeilfunktionen sind zusätzlich zu der Tatsache, dass die Strukturen, mit denen sie deklariert werden, kompakter sind als die Verwendung gewöhnlicher Funktionen, sie unterscheiden sich von ihnen in einigen wichtigen Merkmalen, die wir unten diskutieren werden. <br><br><h2>  <font color="#3AC1EF">Funktionsparameter</font> </h2><br>  Parameter sind Variablen, die in der Phase der Deklaration einer Funktion festgelegt werden und die an sie übergebenen Werte enthalten (diese Werte werden als Argumente bezeichnet).  Funktionen in JavaScript haben möglicherweise entweder keine Parameter oder einen oder mehrere Parameter. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const doSomethingElse = foo =&gt; { // - } const doSomethingElseAgain = (foo, bar) =&gt; { // - }</span></span></code> </pre> <br>  Hier sind einige Beispiele für Pfeilfunktionen. <br><br>  Ab dem ES6-Standard können Funktionen sogenannte „Standardparameter“ haben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Sie stellen Standardwerte dar, die durch die Parameter von Funktionen festgelegt werden, wenn beim Aufruf die Werte einiger Parameter nicht festgelegt werden.  Zum Beispiel kann die oben gezeigte Funktion sowohl durch Übergabe aller zwei empfangenen Parameter als auch durch andere Methoden aufgerufen werden. <br><br><pre> <code class="javascript hljs">doSomething(<span class="hljs-number"><span class="hljs-number">3</span></span>) doSomething()</code> </pre> <br>  In ES8 können Sie jetzt nach dem letzten Argument einer Funktion ein Komma setzen (dies wird als nachfolgendes Komma bezeichnet).  Mit dieser Funktion können Sie den Code einfacher bearbeiten, wenn Sie Versionskontrollsysteme während der Programmentwicklung verwenden.  Details dazu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  An Funktionen übergebene Argumente können als Arrays dargestellt werden.  Um diese Argumente zu analysieren, können Sie einen Operator verwenden, der wie drei Punkte aussieht (dies ist der sogenannte "Erweiterungsoperator" oder "Spread-Operator").  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const args = [2, 'ho!'] doSomething(...args)</span></span></code> </pre> <br>  Wenn Funktionen viele Parameter annehmen müssen, kann es schwierig sein, sich die Reihenfolge ihrer Reihenfolge zu merken.  In solchen Fällen werden Objekte mit Parametern und Möglichkeiten zur Destrukturierung von ES6-Objekten verwendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - console.log(foo) // 2 console.log(bar) // 'ho!' } const args = { foo: 2, bar: 'ho!' } doSomething(args)</span></span></code> </pre> <br>  Diese Technik ermöglicht es, die Parameter in Form von Objekteigenschaften zu beschreiben und die Funktion an das Objekt zu übergeben, um der Funktion den Zugriff auf die Parameter anhand ihrer Namen zu ermöglichen, ohne zusätzliche Konstruktionen zu verwenden.  Lesen Sie hier mehr über diese Technik. <br><br><h2>  <font color="#3AC1EF">Von Funktionen zurückgegebene Werte</font> </h2><br>  Alle Funktionen geben einen bestimmten Wert zurück.  Wenn der Rückgabebefehl nicht explizit angegeben wird, gibt die Funktion <code>undefined</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } console.log(doSomething())</span></span></code> </pre> <br>  Die Funktionsausführung endet entweder, nachdem der gesamte darin enthaltene Code ausgeführt wurde, oder nachdem das Schlüsselwort <code>return</code> im Code gefunden wurde.  Wenn dieses Schlüsselwort in einer Funktion gefunden wird, ist seine Operation abgeschlossen und die Steuerung wird an den Ort übertragen, von dem aus die Funktion aufgerufen wurde. <br><br>  Wenn Sie nach dem Schlüsselwort <code>return</code> einen bestimmten Wert angeben, kehrt dieser Wert als Ergebnis der Ausführung dieser Funktion an die Stelle des Funktionsaufrufs zurück. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = doSomething() <span class="hljs-comment"><span class="hljs-comment">// result === 'test'</span></span></code> </pre> <br>  Von einer Funktion kann nur ein Wert zurückgegeben werden.  Um mehrere Werte zurückgeben zu können, können Sie sie entweder als Objekt mit einem Objektliteral oder als Array zurückgeben und beim Aufrufen einer Funktion das destruktive Zuweisungskonstrukt verwenden.  Parameternamen werden gespeichert.  Wenn Sie gleichzeitig mit einem Objekt oder einem Array arbeiten müssen, das von einer Funktion zurückgegeben wird, und zwar in Form eines Objekts oder eines Arrays, können Sie auf eine destruktive Zuweisung verzichten. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [ name, age ] = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br>  Die Konstruktion <code>const [ name, age ] = doSomething()</code> kann wie folgt gelesen werden: "Deklarieren Sie die Konstanten <code>name</code> und <code>age</code> und weisen Sie ihnen die Werte der Elemente des Arrays zu, die die Funktion zurückgeben wird." <br>  So sieht das gleiche mit einem Objekt aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, age } = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Verschachtelte Funktionen</font> </h2><br>  Funktionen können in anderen Funktionen deklariert werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingElse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {} doSomethingElse() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } doSomething()</code> </pre> <br>  Der Umfang einer verschachtelten Funktion wird durch eine externe Funktion begrenzt, die nicht von außen aufgerufen werden kann. <br><br><h2>  <font color="#3AC1EF">Objektmethoden</font> </h2><br>  Wenn Funktionen als Eigenschaften von Objekten verwendet werden, werden solche Funktionen als Objektmethoden bezeichnet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started`</span></span>) } } car.start()</code> </pre> <br><h2>  <font color="#3AC1EF">Dieses Schlüsselwort</font> </h2><br>  Wenn wir Pfeil- und gewöhnliche Funktionen vergleichen, die als Methoden von Objekten verwendet werden, können wir ihren wichtigen Unterschied feststellen, der in der Bedeutung des Schlüsselworts <code>this</code> .  Betrachten Sie ein Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Stopped </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) } } car.start() <span class="hljs-comment"><span class="hljs-comment">//Started Ford Fiesta car.stop() //Stopped undefined undefined</span></span></code> </pre> <br>  Wie Sie sehen, führt der Aufruf der Methode <code>start()</code> zum erwarteten Ergebnis, aber die Methode <code>stop()</code> funktioniert offensichtlich nicht richtig. <br><br>  Dies liegt an der Tatsache, dass sich das Schlüsselwort this bei Verwendung in Pfeil- und normalen Funktionen unterschiedlich verhält.  Das <code>this</code> in der Pfeilfunktion enthält nämlich einen Link zu dem Kontext, der die Funktion enthält.  In diesem Fall ist dieser Kontext beim Browser das <code>window</code> . <br><br>  So sieht die Ausführung eines solchen Codes in der Browserkonsole aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">arrFn</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } test.fn() test.arrFn()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b3/7c4/c29/4b37c4c299f7f21c40c77c372d34974f.png"></div><br>  <i><font color="#999999">Dieses Schlüsselwort ist in herkömmlichen und Pfeilfunktionen enthalten</font></i> <br><br>  Wie Sie sehen können, bedeutet das Aufrufen in einer regulären Funktion das Aufrufen des Objekts, und <code>this</code> in der Pfeilfunktion zeigt auf das <code>window</code> . <br><br>  All dies bedeutet, dass Pfeilfunktionen nicht für die Rolle von Objekt- und Konstruktormethoden geeignet sind (wenn Sie versuchen, die <code>TypeError</code> als Konstruktor zu verwenden, wird ein <code>TypeError</code> ). <br><br><h2>  <font color="#3AC1EF">Funktionsausdrücke werden sofort aufgerufen</font> </h2><br>  Der sofort aufgerufene Funktionsausdruck (IIFE) ist eine Funktion, die unmittelbar nach ihrer Deklaration automatisch aufgerufen wird. <br><br><pre> <code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'executed'</span></span>) })()</code> </pre> <br>  Das Semikolon vor IIFE ist optional, aber seine Verwendung ermöglicht es Ihnen, sich gegen Fehler zu versichern, die mit der automatischen Platzierung von Semikolons verbunden sind. <br><br>  Im obigen Beispiel wird das <code>executed</code> Wort an die Konsole gesendet, wonach IIFE beendet wird.  IIFE kann wie andere Funktionen die Ergebnisse ihrer Arbeit zurückgeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'IIFE'</span></span> })() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(something)</code> </pre> <br>  Nach dem Ausführen dieses einfachen Beispiels erhält die Konsole die <code>IIFE</code> Zeile, die sich nach dem Ausführen des sofort aufgerufenen Funktionsausdrucks als <code>something</code> herausstellte.  Es scheint, dass ein solches Design keinen besonderen Nutzen bringt.  Wenn jedoch in IIFE einige komplexe Berechnungen durchgeführt werden, die nur einmal durchgeführt werden müssen, wonach die entsprechenden Mechanismen nicht mehr erforderlich sind, liegt der Nutzen von IIFE auf der Hand.  Bei diesem Ansatz ist nämlich nach Ausführung von IIFE nur das von der Funktion zurückgegebene Ergebnis im Programm verfügbar.  Darüber hinaus können wir uns daran erinnern, dass Funktionen andere Funktionen und Objekte zurückgeben können.  Wir sprechen über Schließungen, wir werden unten darüber sprechen. <br><br><h2>  <font color="#3AC1EF">Funktionserweiterung</font> </h2><br>  Bevor der JavaScript-Code ausgeführt wird, wird er neu organisiert.  Wir haben bereits über den Hebemechanismus für Variablen gesprochen, die mit dem Schlüsselwort <code>var</code> deklariert wurden.  Ein ähnlicher Mechanismus funktioniert mit Funktionen.  Wir sprechen nämlich von der Tatsache, dass Deklarationen von Funktionen während der Verarbeitung des Codes vor seiner Ausführung in den oberen Teil ihres Gültigkeitsbereichs verschoben werden.  Als Ergebnis stellt sich beispielsweise heraus, dass Sie die Funktion aufrufen können, bevor sie deklariert wird. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//did something function doSomething() { console.log('did something') }</span></span></code> </pre> <br>  Wenn Sie einen Funktionsaufruf so verschieben, dass er seiner Deklaration folgt, ändert sich nichts. <br><br>  Wenn in einer ähnlichen Situation ein Funktionsausdruck verwendet wird, gibt ein ähnlicher Code einen Fehler aus. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//TypeError var doSomething = function () { console.log('did something') }</span></span></code> </pre> <br>  In diesem Fall stellt sich heraus, dass die Deklaration der Variablen <code>doSomething</code> an die Spitze des Bereichs steigt, dies jedoch nicht für die Zuweisungsoperation gilt. <br>  Wenn Sie in einer ähnlichen Situation anstelle von <code>var</code> die Schlüsselwörter <code>let</code> oder <code>const</code> , funktioniert dieser Code ebenfalls nicht. Das System zeigt jedoch eine andere Fehlermeldung an ( <code>ReferenceError</code> anstelle von <code>TypeError</code> ), da bei Verwendung von <code>let</code> und <code>const</code> keine Variablen- und Konstantendeklarationen <code>TypeError</code> werden. <br><br><h2>  <font color="#3AC1EF">Pfeilfunktionen</font> </h2><br>  Jetzt werden wir mehr über Pfeilfunktionen sprechen, die wir bereits getroffen haben.  Sie können als eine der bedeutendsten Neuerungen des ES6-Standards angesehen werden. Sie unterscheiden sich von gewöhnlichen Funktionen nicht nur im Aussehen, sondern auch in ihrem Verhalten.  Heutzutage sind sie extrem weit verbreitet.  Vielleicht gibt es kein einziges modernes Projekt, bei dem sie in den allermeisten Fällen nicht verwendet würden.  Wir können sagen, dass ihr Aussehen das Aussehen des JS-Codes und die Merkmale seiner Arbeit für immer verändert hat. <br><br>  Aus rein externer Sicht ist die Syntax zum Deklarieren von Pfeilfunktionen kompakter als die Syntax gewöhnlicher Funktionen.  Hier ist eine reguläre Funktionsdeklaration. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Hier ist die Ankündigung der Pfeilfunktion, die im Allgemeinen, wenn Sie die Merkmale der Pfeilfunktionen nicht berücksichtigen, der vorherigen ähnlich ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Wenn der Hauptteil einer Pfeilfunktion nur einen Befehl enthält, dessen Ergebnis diese Funktion zurückgibt, kann er ohne geschweifte Klammern und ohne das Schlüsselwort <code>return</code> .  Eine solche Funktion gibt beispielsweise die Summe der an sie übergebenen Argumente zurück. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//3</span></span></code> </pre> <br>  Wie Sie sehen können, sind die Parameter der Pfeilfunktionen wie bei normalen Funktionen in Klammern beschrieben.  Wenn eine solche Funktion nur einen Parameter akzeptiert, kann sie außerdem ohne Klammern angegeben werden.  Hier ist beispielsweise eine Funktion, die das Ergebnis der Division der übergebenen Zahl durch 2 zurückgibt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">8</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//4</span></span></code> </pre> <br>  Infolgedessen stellt sich heraus, dass Pfeilfunktionen in Situationen, in denen kleine Funktionen benötigt werden, sehr praktisch sind. <br><br><h3>  <font color="#3AC1EF">▍ Implizite Rückgabe von Funktionsergebnissen</font> </h3><br>  Wir haben dieses Merkmal der Pfeilfunktionen bereits angesprochen, aber es ist so wichtig, dass es ausführlicher besprochen werden sollte.  Wir sprechen über die Tatsache, dass einzeilige Pfeilfunktionen die implizite Rückgabe der Ergebnisse ihrer Arbeit unterstützen.  Ein Beispiel für die Rückgabe eines primitiven Werts aus einer einzeiligen Pfeilfunktion, die wir bereits gesehen haben.  Was ist, wenn eine solche Funktion ein Objekt zurückgeben sollte?  In diesem Fall können die geschweiften Klammern des Objektliteral das System verwirren, sodass im Hauptteil der Funktion Klammern verwendet werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'test'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = myFunction() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.value) <span class="hljs-comment"><span class="hljs-comment">//test</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Schlüsselwort this und Pfeilfunktionen</font> </h3><br>  Als wir uns oben die Funktionen <code>this</code> , haben wir reguläre und Pfeilfunktionen verglichen.  Dieser Abschnitt soll Ihre Aufmerksamkeit auf die Bedeutung ihrer Unterschiede lenken.  Das <code>this</code> kann an sich bestimmte Schwierigkeiten verursachen, da es vom Kontext der Codeausführung abhängt und davon, ob der strikte Modus aktiviert ist oder nicht. <br><br>  Wie wir gesehen haben, zeigt dies bei Verwendung des <code>this</code> in einer Methode eines Objekts, das durch eine reguläre Funktion dargestellt wird, auf das Objekt, zu dem die Methode gehört.  In diesem Fall geht es darum, das Schlüsselwort <code>this</code> an einen Wert zu binden, der den Kontext der Funktion darstellt.  Insbesondere wenn eine Funktion als Objektmethode aufgerufen wird, ist das Schlüsselwort this an dieses Objekt gebunden. <br><br>  Bei Pfeilfunktionen stellt sich heraus, dass <code>this</code> Bindung in ihnen nicht ausgeführt wird. Sie verwenden das <code>this</code> aus ihrem Gültigkeitsbereich.  Daher werden sie nicht zur Verwendung als Objektmethoden empfohlen. <br><br>  Das gleiche Problem tritt auf, wenn Funktionen als Ereignishandler für DOM-Elemente verwendet werden.  Beispielsweise wird die HTML-Elementschaltfläche verwendet, um Schaltflächen zu beschreiben.  Das <code>click</code> wird <code>click</code> wenn ein Benutzer auf eine Schaltfläche klickt.  Um auf dieses Ereignis im Code zu reagieren, müssen Sie zuerst einen Link zum entsprechenden Element abrufen und ihm dann als Funktion einen <code>click</code> zuweisen.  Als solcher Handler können Sie sowohl die reguläre Funktion als auch die Pfeilfunktion verwenden.  Wenn Sie jedoch im Ereignishandler auf das Element zugreifen müssen, für das es aufgerufen wird (dh <code>this</code> ), funktioniert die Pfeilfunktion hier nicht, da der darin verfügbare Wert auf das <code>window</code> verweist.  Um dies in der Praxis zu testen, erstellen Sie eine HTML-Seite, deren Code unten angezeigt wird, und klicken Sie auf die Schaltflächen. <br><br><pre> <code class="javascript hljs">&lt;!DOCTYPE html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Arrow function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="xml"><span class="javascript">     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> f = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="javascript">)     f.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></span><span class="xml"><span class="javascript"><span class="hljs-function"> (</span></span></span><span class="hljs-params"></span><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span></span><span class="xml"><span class="javascript">{         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === f)     })     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> af = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="javascript">)     af.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, () =&gt; {         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">window</span></span></span></span><span class="xml"><span class="javascript">)     })   </span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  In diesem Fall werden beim Klicken auf diese Schaltflächen Fenster mit <code>true</code> angezeigt.  In der Klickereignishandler der Schaltfläche mit dem Bezeichner <code>fn</code> wird jedoch die Gleichheit von <code>this</code> der Schaltfläche überprüft, und in der Schaltfläche mit dem BezeichnerpfeilFn wird die Gleichheit von <code>this</code> und dem Objekt des <code>window</code> überprüft. <br><br>  Wenn Sie <code>this</code> im Ereignishandler des HTML-Elements aufrufen müssen, funktioniert die Pfeilfunktion daher für das Design eines solchen Handlers nicht. <br><br><h2>  <font color="#3AC1EF">Kurzschlüsse</font> </h2><br>  Verschlüsse sind ein wichtiges Konzept in JavaScript.  Wenn Sie JS-Funktionen geschrieben haben, haben Sie auch Verschlüsse verwendet.  Verschlüsse werden in einigen Entwurfsmustern verwendet - für den Fall, dass Sie eine strikte Kontrolle des Zugriffs auf bestimmte Daten oder Funktionen organisieren müssen. <br><br>  Wenn eine Funktion aufgerufen wird, hat sie Zugriff auf alles, was sich im externen Bereich befindet.  Es gibt jedoch keinen Zugriff auf das, was in der Funktion deklariert ist.  Das heißt, wenn eine Variable (oder eine andere Funktion) in einer Funktion deklariert wurde, kann entweder während der Ausführung der Funktion oder nach Abschluss ihrer Arbeit nicht auf externen Code zugegriffen werden.  Wenn jedoch eine andere Funktion von der Funktion zurückgegeben wird, hat diese neue Funktion Zugriff auf alles, was in der ursprünglichen Funktion deklariert wurde.  In diesem Fall wird all dies vor dem externen Code im Abschluss verborgen. <br><br>  Betrachten Sie ein Beispiel.  Hier ist eine Funktion, die den Namen des Hundes übernimmt und ihn dann in der Konsole anzeigt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> ;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say))() } bark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  Der von dieser Funktion zurückgegebene Wert interessiert uns noch nicht, der Text wird mit IIFE in der Konsole angezeigt, was in diesem Fall keine besondere Rolle spielt. Dies hilft uns jedoch, den Zusammenhang zwischen dieser Funktion und ihrer Variante zu erkennen, in der anstelle einer angezeigten Funktion eine Funktion aufgerufen wird Text an die Konsole, wir werden diese Funktion von der umgeschriebenen Funktion <code>bark()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) bark() <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  Das Ergebnis des Codes ist in zwei Fällen dasselbe.  Im zweiten Fall wird jedoch das, was beim Aufrufen auf die ursprüngliche Funktion übertragen wurde (der Name des Hundes, <code>Roger</code> ), im Verschluss gespeichert und anschließend von einer anderen vom Original zurückgegebenen Funktion verwendet. <br><br>  Lassen Sie uns ein weiteres Experiment durchführen - erstellen Sie mit der ursprünglichen Funktion zwei neue für verschiedene Hunde. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rogerBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sydBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Syd`</span></span>) rogerBark() sydBark()</code> </pre> <br>  Dieser Code gibt Folgendes aus. <br><br><pre> <code class="javascript hljs">Roger barked! Syd barked!</code> </pre> <br>  Es stellt sich heraus, dass der Wert der <code>say</code> Konstante an die Funktion gebunden ist, die von der <code>prepareBark()</code> -Funktion zurückgegeben wird. <br><br>  Beachten Sie, <code>say</code> beim <code>prepareBark()</code> Aufruf von <code>prepareBark()</code> ein neuer Wert <code>prepareBark()</code> wird, während sich der Wert, der beispielsweise <code>say</code> ersten Aufruf von <code>prepareBark()</code> aufgezeichnet wurde <code>say</code> nicht ändert.  Der Punkt ist, dass mit jedem Aufruf dieser Funktion ein neuer Abschluss erstellt wird. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir über gewöhnliche und Pfeilfunktionen gesprochen, über die Merkmale ihrer Deklaration und Verwendung, darüber, wie sich <code>this</code> Schlüsselwort in verschiedenen Situationen verhält, und über Schließungen.  Das nächste Mal diskutieren wir Arrays und Schleifen. <br><br>  <b>Liebe Leser!</b>  Wie stehen Sie zu Pfeilfunktionen in JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430382/">https://habr.com/ru/post/de430382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430372/index.html">Wasserstoffauto. Ist es Zeit, sich vom Benzin zu verabschieden?</a></li>
<li><a href="../de430374/index.html">Data Engineering und mehr: Wrike-Videobänder und -Dias aus dem Meeting</a></li>
<li><a href="../de430376/index.html">JavaScript-Handbuch Teil 6: Ausnahmen, Semikolons, Vorlagenliterale</a></li>
<li><a href="../de430378/index.html">J2CL - Besser spät als nie</a></li>
<li><a href="../de430380/index.html">JavaScript-Handbuch Teil 5: Arrays und Loops</a></li>
<li><a href="../de430384/index.html">Erstellen von Karten aus Rauschfunktionen</a></li>
<li><a href="../de430386/index.html">Festkörperspeicherkraftwerk in Indien gebaut werden</a></li>
<li><a href="../de430388/index.html">Web Summit Unconference</a></li>
<li><a href="../de430392/index.html">Wie ich APIs mit meinem PieceofScript-Fahrrad entwickle und teste</a></li>
<li><a href="../de430394/index.html">Implementierung der Sofort-Suche in Android mit RxJava</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>