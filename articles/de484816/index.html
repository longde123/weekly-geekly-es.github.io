<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàÇÔ∏è üôÉ üöÄ Verwenden von Operations Hooks zum Sichern von Dateien unter macOS im laufenden Betrieb üéûÔ∏è üíä üëø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr Mein Name ist Denis Kopyrin und ich m√∂chte heute dar√ºber sprechen, wie wir das Problem des Backups auf Abruf unter macOS gel√∂st haben. Eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von Operations Hooks zum Sichern von Dateien unter macOS im laufenden Betrieb</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/484816/">  Hallo habr  Mein Name ist Denis Kopyrin und ich m√∂chte heute dar√ºber sprechen, wie wir das Problem des Backups auf Abruf unter macOS gel√∂st haben.  Eine interessante Aufgabe, der ich am Institut begegnete, entwickelte sich schlie√ülich zu einem gro√üen Forschungsprojekt √ºber die Arbeit mit dem Dateisystem.  Alle Details sind unter dem Schnitt. <br><br> <a href="https://habr.com/ru/company/acronis/blog/484816/"><img src="https://habrastorage.org/getpro/habr/post_images/e81/10c/67b/e8110c67b5fe5edb2a8259a8a68fe632.jpg" alt="Bild"></a> <br><a name="habracut"></a><br>  Ich werde nicht von weitem anfangen, ich kann nur sagen, dass alles mit einem Projekt am Moskauer Institut f√ºr Physik und Technologie begann, das ich mit meinem Vorgesetzten an der Acronis-Basisabteilung entwickelt habe.  Wir standen vor der Aufgabe, die Remote-Speicherung von Dateien zu organisieren bzw. den aktuellen Status ihrer Sicherungen beizubehalten. <br><br>  Um die Datensicherheit zu gew√§hrleisten, verwenden wir die macOS-Kernel-Erweiterung, die Informationen zu Ereignissen im System sammelt.  KPI f√ºr Entwickler verf√ºgt √ºber eine KAUTH-API, die es Ihnen erm√∂glicht, Benachrichtigungen √ºber das √ñffnen und Schlie√üen einer Datei zu erhalten - das ist alles.  Wenn Sie KAUTH verwenden, m√ºssen Sie die Datei beim √ñffnen zum Schreiben vollst√§ndig speichern, da die Ereignisse zum Schreiben in die Datei den Entwicklern nicht zur Verf√ºgung stehen.  Solche Informationen reichten f√ºr unsere Aufgaben nicht aus.  In der Tat m√ºssen Sie genau wissen, wo der Benutzer (oder die Malware :) die neuen Daten in die Datei geschrieben hat, um eine Sicherungskopie der Daten dauerhaft zu erg√§nzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d12/250/d5e/d12250d5e699b0841d0059eb5ba8846c.png" alt="Bild"><br><br>  Aber welche Entwickler hatten Angst vor Betriebssystemeinschr√§nkungen?  Wenn Sie mit der Kernel-API keine Informationen √ºber Schreibvorg√§nge abrufen k√∂nnen, m√ºssen Sie einen eigenen Weg finden, um andere Kernel-Tools abzufangen. <br><br>  Zun√§chst wollten wir den Kern und seine Strukturen nicht patchen.  Stattdessen haben sie versucht, ein ganzes virtuelles Volume zu erstellen, mit dem wir alle Lese- und Schreibanforderungen abfangen k√∂nnen, die es durchlaufen.  Aber es stellte sich heraus, dass macOS ein unangenehmes Merkmal ist: Das Betriebssystem glaubt, dass es nicht √ºber 1, sondern √ºber 2 USB-Sticks, zwei Festplatten usw. verf√ºgt.  Und aufgrund der Tatsache, dass sich das zweite Volume beim Arbeiten mit dem ersten √§ndert, funktioniert macOS bei Laufwerken nicht mehr richtig.  Es gab so viele Probleme mit dieser Methode, dass ich darauf verzichten musste. <br><br><h3>  Suchen Sie nach einer anderen L√∂sung </h3><br>  Trotz der Einschr√§nkungen von KAUTH k√∂nnen Sie mit diesem KPI vor allen Vorg√§ngen √ºber die Verwendung einer Datei f√ºr die Aufzeichnung benachrichtigt werden.  Entwickler erhalten Zugriff auf die BSD-Dateiabstraktion im Kernel-vnode.  Seltsamerweise stellte sich heraus, dass das Patchen von vnode einfacher ist als das Filtern von Volumes.  Die vnode-Struktur enth√§lt eine Tabelle mit Funktionen, die die Arbeit mit realen Dateien erm√∂glichen.  Daher hatten wir die Idee, diese Tabelle zu ersetzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b1/6c7/a9b/6b16c7a9b87a054f0ae5898d043aa91d.png" alt="Bild"><br><br>  Die Idee wurde sofort als gute Idee angesehen, aber f√ºr ihre Umsetzung war es notwendig, die Tabelle selbst in der vnode-Struktur zu finden, da Apple ihren Standort nirgendwo dokumentiert.  Dazu war es notwendig, den Maschinencode des Kernels zu studieren und auch herauszufinden, ob es m√∂glich ist, auf diese Adresse zu schreiben, damit das System danach nicht abstirbt. <br><br>  Wenn die Tabelle gefunden wird, kopieren wir sie einfach in den Speicher, setzen den Zeiger auf und f√ºgen den Link zur neuen Tabelle in den vorhandenen vnode ein.  Dadurch werden alle Vorg√§nge mit Dateien √ºber unseren Treiber ausgef√ºhrt, und wir k√∂nnen alle Benutzeranforderungen, einschlie√ülich Lesen und Schreiben, registrieren.  Daher ist die Suche nach dem begehrten Tisch zu unserem Hauptziel geworden. <br><br>  Da Apple dies nicht wirklich m√∂chte, m√ºssen Sie zur L√∂sung des Problems versuchen, die Position der Tabelle mithilfe von Heuristiken f√ºr die relative Position der Felder zu erraten, oder eine bereits bekannte Funktion verwenden, sie zerlegen und nach einem Offset aus diesen Informationen suchen. <br><br>  <b>So suchen Sie nach einem Offset: auf einfache Weise</b> <br><br>  Der einfachste Weg, um Tabellenvers√§tze in vnode zu finden, ist eine Heuristik, die auf der Position von Feldern in einer Struktur basiert ( <a href="">Link zu Github</a> ). <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnode</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (**v_op)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">/* vnode operations vector */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> v_mount; <span class="hljs-comment"><span class="hljs-comment">/* ptr to vfs we are in */</span></span> ... }</code> </pre> <br>  Wir gehen davon aus, dass das von uns ben√∂tigte v_op-Feld genau 8 Bytes von v_mount entfernt ist.  Der Wert der letzteren kann mit √∂ffentlichen KPI erhalten werden ( <a href="">Link zu Github</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> vnode_mount(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> vp);</code> </pre><br>  Wenn wir den Wert von v_mount kennen, werden wir nach einer ‚ÄûNadel im Heuhaufen‚Äú suchen - wir werden den Wert des Zeigers auf vnode 'vp' als uintptr_t *, den Wert von vnode_mount (vp) als uintptr_t wahrnehmen.  Darauf folgen Iterationen auf den ‚Äûangemessenen‚Äú Wert von i, bis die Bedingung ‚ÄûHeuhaufen [i] == Nadel‚Äú erf√ºllt ist.  Und wenn die Annahme √ºber die Position der Felder korrekt ist, ist der Versatz v_op i-1. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVOPPtr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vnode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> haystack = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>*) vp; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> needle = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>) vnode_mount(vp); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ATTEMPTCOUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (haystack[i] == needle) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> haystack + (i - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre><br>  <b>So suchen Sie nach einem Versatz: Demontage</b> <br><br>  Trotz seiner Einfachheit weist das erste Verfahren einen signifikanten Nachteil auf.  Wenn Apple die Reihenfolge der Felder in der vnode-Struktur √§ndert, bricht die einfache Methode ab.  Eine universellere, aber weniger triviale Methode ist das dynamische Zerlegen des Kernels. <br><br>  Betrachten Sie zum Beispiel die disassemblierte Kernelfunktion VNOP_CREATE ( <a href="">Link zu Github</a> ) unter macOS 10.14.6.  Hinweise, die uns interessieren, sind mit einem Pfeil -&gt; gekennzeichnet. <br><br> <code>_VNOP_CREATE: <br> 1 push rbp <br> 2 mov rbp, rsp <br> 3 push r15 <br> 4 push r14 <br> 5 push r13 <br> 6 push r12 <br> 7 push rbx <br> 8 sub rsp, 0x48 <br> 9 mov r15, r8 <br> 10 mov r12, rdx <br> 11 mov r13, rsi <br> -&gt; 12 mov rbx, rdi <br> 13 lea rax, qword [___stack_chk_guard] <br> 14 mov rax, qword [rax] <br> 15 mov qword [rbp+-48], rax <br> -&gt; 16 lea rax, qword [_vnop_create_desc] ; _vnop_create_desc <br> 17 mov qword [rbp+-112], rax <br> 18 mov qword [rbp+-104], rdi <br> 19 mov qword [rbp+-96], rsi <br> 20 mov qword [rbp+-88], rdx <br> 21 mov qword [rbp+-80], rcx <br> 22 mov qword [rbp+-72], r8 <br> -&gt; 23 mov rax, qword [rdi+0xd0] <br> -&gt; 24 movsxd rcx, dword [_vnop_create_desc] <br> 25 lea rdi, qword [rbp+-112] <br> -&gt; 26 call qword [rax+rcx*8] <br> 27 mov r14d, eax <br> 28 test eax, eax <br> ‚Ä¶.</code> <br> <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">errno_t</span></span> VNOP_CREATE(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> dvp, <span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> * vpp, struct componentname * cnp, struct vnode_attr * vap, <span class="hljs-keyword"><span class="hljs-keyword">vfs_context_t</span></span> ctx) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _err; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnop_create_args</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> a.a_desc = &amp;vnop;_create_desc; a.a_dvp = dvp; a.a_vpp = vpp; a.a_cnp = cnp; a.a_vap = vap; a.a_context = ctx; _err = (*dvp-&gt;v_op[vnop_create_desc.vdesc_offset])(&amp;a;); ‚Ä¶</code> </pre><br>  Wir werden die Assembler-Anweisungen scannen, um die Verschiebung im VNode-DVP zu finden.  Der ‚ÄûZweck‚Äú des Assembler-Codes besteht darin, eine Funktion aus der Tabelle v_op aufzurufen.  Dazu muss der Prozessor die folgenden Schritte ausf√ºhren: <br><br><ol><li>  Laden Sie dvp hoch, um sich zu registrieren </li><li>  Dereferenzieren, um v_op zu erhalten (Zeile 23) </li><li>  Holen Sie sich vnop_create_desc.vdesc_offset (Zeile 24) </li><li>  Rufe eine Funktion auf (Zeile 26) </li></ol><br>  Wenn bei den Schritten 2 bis 4 alles klar ist, treten beim ersten Schritt Schwierigkeiten auf.  Wie kann ich nachvollziehen, in welches Register dvp geladen wurde?  Dazu haben wir eine Methode zum Emulieren einer Funktion verwendet, die die Bewegungen des gew√ºnschten Zeigers √ºberwacht.  Gem√§√ü der System V x86_64-Aufrufkonvention wird das erste Argument im rdi-Register √ºbergeben.  Aus diesem Grund haben wir uns entschlossen, alle Register, die rdi enthalten, im Auge zu behalten.  In meinem Beispiel sind dies die Register rbx und rdi.  Au√üerdem kann eine Kopie des Registers auf dem Stapel gespeichert werden, der sich in der Debug-Version des Kernels befindet. <br><br>  Wenn wir wissen, dass die Register rbx und rdi dvp speichern, finden wir heraus, dass Zeile 23 vnode dereferenziert, um v_op zu erhalten.  Wir gehen also davon aus, dass die Verschiebung in der Struktur 0xd0 ist.  Um die richtige Entscheidung zu best√§tigen, scannen wir weiter und stellen sicher, dass die Funktion korrekt aufgerufen wird (Zeilen 24 und 26). <br><br>  Diese Methode ist sicherer, hat aber leider auch Nachteile.  Wir m√ºssen uns auf die Tatsache verlassen, dass das Funktionsmuster (dh die 4 Schritte, √ºber die wir oben gesprochen haben) dasselbe ist.  Die Wahrscheinlichkeit, das Muster der Funktion zu √§ndern, ist jedoch um eine Gr√∂√üenordnung geringer als die Wahrscheinlichkeit, die Reihenfolge der Felder zu √§ndern.  Also beschlossen wir, mit der zweiten Methode aufzuh√∂ren. <br><br><h3>  Ersetzen Sie die Zeiger in der Tabelle </h3><br>  Nachdem Sie v_op gefunden haben, stellt sich die Frage, wie Sie diesen Zeiger verwenden sollen.  Es gibt zwei M√∂glichkeiten: √úberschreiben Sie die Funktion in der Tabelle (dritter Pfeil im Bild) oder √ºberschreiben Sie die Tabelle in vnode (zweiter Pfeil im Bild). <br><br>  Auf den ersten Blick scheint die erste Option rentabler zu sein, da wir nur einen Zeiger ersetzen m√ºssen.  Dieser Ansatz weist jedoch zwei wesentliche Nachteile auf.  Erstens ist die v_op-Tabelle f√ºr alle vnode eines bestimmten Dateisystems gleich (v_op f√ºr HFS +, v_op f√ºr APFS, ...). Daher ist das Filtern nach vnode erforderlich, was sehr teuer sein kann. Sie m√ºssen bei jedem Schreibvorgang zus√§tzlichen vnode herausfiltern.  Zweitens wird die Tabelle auf der schreibgesch√ºtzten Seite geschrieben.  Diese Einschr√§nkung kann umgangen werden, wenn Sie die Aufzeichnung √ºber IOMappedWrite64 verwenden und Systempr√ºfungen umgehen.  Wenn kext mit dem Dateisystemtreiber ausgeliefert wird, ist es schwierig, herauszufinden, wie der Patch entfernt werden kann. <br><br>  Die zweite Option erweist sich als zielgerichteter und sicherer - der Interceptor wird nur f√ºr den erforderlichen vNode aufgerufen, und der vNode-Speicher erm√∂glicht zun√§chst Lese- / Schreibvorg√§nge.  Da die gesamte Tabelle ersetzt wird, muss etwas mehr Speicher zugewiesen werden (80 Funktionen statt einer).  Und da die Anzahl der Tabellen in der Regel der Anzahl der Dateisysteme entspricht, ist das Speicherlimit v√∂llig vernachl√§ssigbar. <br><br>  Deshalb wendet kext die zweite Methode an, obwohl es auf den ersten Blick so aussieht, als w√§re diese Option schlechter. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f6/adc/957/0f6adc957cded9d732080d3f32cfa4d1.png" alt="Bild"><br><br>  Infolgedessen arbeitet unser Fahrer wie folgt: <br><br><ol><li>  Die KAUTH-API stellt vnode bereit </li><li>  Wir ersetzen die VNode-Tabelle.  Bei Bedarf fangen wir Operationen nur f√ºr "interessante" Knoten ab, zum Beispiel f√ºr Benutzerdokumente </li><li>  Wenn wir abfangen, pr√ºfen wir, welcher Prozess gerade aufgezeichnet wird, filtern wir ‚Äûunsere‚Äú </li><li>  Wir senden eine synchrone UserSpace-Anfrage an den Client, der entscheidet, was genau gespeichert werden soll. </li></ol><br><h3>  Was ist passiert? </h3><br>  Heute haben wir ein experimentelles Modul, das eine Erweiterung des macOS-Kernels ist und alle √Ñnderungen am Dateisystem auf granularer Ebene ber√ºcksichtigt.  Es ist erw√§hnenswert, dass Apple in macOS 10.15 ein neues Framework ( <a href="https://developer.apple.com/documentation/endpointsecurity%3Flanguage%3Dobjc">Link zu EndpointSecurity</a> ) eingef√ºhrt hat, um Benachrichtigungen √ºber √Ñnderungen am Dateisystem zu erhalten, das f√ºr die Verwendung in Active Protection vorgesehen ist. Aus diesem Grund wurde die im Artikel beschriebene L√∂sung f√ºr veraltet erkl√§rt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484816/">https://habr.com/ru/post/de484816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484802/index.html">Selbstzerst√∂rungsmodus: Zersetzung der endoskopischen Kapsel durch Licht</a></li>
<li><a href="../de484804/index.html">Was muss in einem Unternehmenssystem verschl√ºsselt werden? Und warum das machen?</a></li>
<li><a href="../de484806/index.html">Unterschied zwischen cPanel und Plesk Obsidian</a></li>
<li><a href="../de484812/index.html">Meine Erfahrung mit Plesk</a></li>
<li><a href="../de484814/index.html">6. Fortinet Getting Started v6.0. Webfilterung und Anwendungskontrolle</a></li>
<li><a href="../de484818/index.html">Das Buch "C ++. Die Praxis der Multithread-Programmierung "</a></li>
<li><a href="../de484820/index.html">FAQ.Net - ein kostenloses Notizenprogramm f√ºr Windows mit aktualisiertem Design</a></li>
<li><a href="../de484822/index.html">Blazor: Wie verhindert man, dass eine Komponente krank wird, oder wie trennt man Code vom Markup?</a></li>
<li><a href="../de484824/index.html">Der Krieg um das Licht auszuschalten</a></li>
<li><a href="../de484826/index.html">K√ºnstliche Intelligenz verschlimmert die schlechte Medizin noch mehr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>