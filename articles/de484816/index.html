<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈂️ 🙃 🚀 Verwenden von Operations Hooks zum Sichern von Dateien unter macOS im laufenden Betrieb 🎞️ 💊 👿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr Mein Name ist Denis Kopyrin und ich möchte heute darüber sprechen, wie wir das Problem des Backups auf Abruf unter macOS gelöst haben. Eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von Operations Hooks zum Sichern von Dateien unter macOS im laufenden Betrieb</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/484816/">  Hallo habr  Mein Name ist Denis Kopyrin und ich möchte heute darüber sprechen, wie wir das Problem des Backups auf Abruf unter macOS gelöst haben.  Eine interessante Aufgabe, der ich am Institut begegnete, entwickelte sich schließlich zu einem großen Forschungsprojekt über die Arbeit mit dem Dateisystem.  Alle Details sind unter dem Schnitt. <br><br> <a href="https://habr.com/ru/company/acronis/blog/484816/"><img src="https://habrastorage.org/getpro/habr/post_images/e81/10c/67b/e8110c67b5fe5edb2a8259a8a68fe632.jpg" alt="Bild"></a> <br><a name="habracut"></a><br>  Ich werde nicht von weitem anfangen, ich kann nur sagen, dass alles mit einem Projekt am Moskauer Institut für Physik und Technologie begann, das ich mit meinem Vorgesetzten an der Acronis-Basisabteilung entwickelt habe.  Wir standen vor der Aufgabe, die Remote-Speicherung von Dateien zu organisieren bzw. den aktuellen Status ihrer Sicherungen beizubehalten. <br><br>  Um die Datensicherheit zu gewährleisten, verwenden wir die macOS-Kernel-Erweiterung, die Informationen zu Ereignissen im System sammelt.  KPI für Entwickler verfügt über eine KAUTH-API, die es Ihnen ermöglicht, Benachrichtigungen über das Öffnen und Schließen einer Datei zu erhalten - das ist alles.  Wenn Sie KAUTH verwenden, müssen Sie die Datei beim Öffnen zum Schreiben vollständig speichern, da die Ereignisse zum Schreiben in die Datei den Entwicklern nicht zur Verfügung stehen.  Solche Informationen reichten für unsere Aufgaben nicht aus.  In der Tat müssen Sie genau wissen, wo der Benutzer (oder die Malware :) die neuen Daten in die Datei geschrieben hat, um eine Sicherungskopie der Daten dauerhaft zu ergänzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d12/250/d5e/d12250d5e699b0841d0059eb5ba8846c.png" alt="Bild"><br><br>  Aber welche Entwickler hatten Angst vor Betriebssystemeinschränkungen?  Wenn Sie mit der Kernel-API keine Informationen über Schreibvorgänge abrufen können, müssen Sie einen eigenen Weg finden, um andere Kernel-Tools abzufangen. <br><br>  Zunächst wollten wir den Kern und seine Strukturen nicht patchen.  Stattdessen haben sie versucht, ein ganzes virtuelles Volume zu erstellen, mit dem wir alle Lese- und Schreibanforderungen abfangen können, die es durchlaufen.  Aber es stellte sich heraus, dass macOS ein unangenehmes Merkmal ist: Das Betriebssystem glaubt, dass es nicht über 1, sondern über 2 USB-Sticks, zwei Festplatten usw. verfügt.  Und aufgrund der Tatsache, dass sich das zweite Volume beim Arbeiten mit dem ersten ändert, funktioniert macOS bei Laufwerken nicht mehr richtig.  Es gab so viele Probleme mit dieser Methode, dass ich darauf verzichten musste. <br><br><h3>  Suchen Sie nach einer anderen Lösung </h3><br>  Trotz der Einschränkungen von KAUTH können Sie mit diesem KPI vor allen Vorgängen über die Verwendung einer Datei für die Aufzeichnung benachrichtigt werden.  Entwickler erhalten Zugriff auf die BSD-Dateiabstraktion im Kernel-vnode.  Seltsamerweise stellte sich heraus, dass das Patchen von vnode einfacher ist als das Filtern von Volumes.  Die vnode-Struktur enthält eine Tabelle mit Funktionen, die die Arbeit mit realen Dateien ermöglichen.  Daher hatten wir die Idee, diese Tabelle zu ersetzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b1/6c7/a9b/6b16c7a9b87a054f0ae5898d043aa91d.png" alt="Bild"><br><br>  Die Idee wurde sofort als gute Idee angesehen, aber für ihre Umsetzung war es notwendig, die Tabelle selbst in der vnode-Struktur zu finden, da Apple ihren Standort nirgendwo dokumentiert.  Dazu war es notwendig, den Maschinencode des Kernels zu studieren und auch herauszufinden, ob es möglich ist, auf diese Adresse zu schreiben, damit das System danach nicht abstirbt. <br><br>  Wenn die Tabelle gefunden wird, kopieren wir sie einfach in den Speicher, setzen den Zeiger auf und fügen den Link zur neuen Tabelle in den vorhandenen vnode ein.  Dadurch werden alle Vorgänge mit Dateien über unseren Treiber ausgeführt, und wir können alle Benutzeranforderungen, einschließlich Lesen und Schreiben, registrieren.  Daher ist die Suche nach dem begehrten Tisch zu unserem Hauptziel geworden. <br><br>  Da Apple dies nicht wirklich möchte, müssen Sie zur Lösung des Problems versuchen, die Position der Tabelle mithilfe von Heuristiken für die relative Position der Felder zu erraten, oder eine bereits bekannte Funktion verwenden, sie zerlegen und nach einem Offset aus diesen Informationen suchen. <br><br>  <b>So suchen Sie nach einem Offset: auf einfache Weise</b> <br><br>  Der einfachste Weg, um Tabellenversätze in vnode zu finden, ist eine Heuristik, die auf der Position von Feldern in einer Struktur basiert ( <a href="">Link zu Github</a> ). <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnode</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (**v_op)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">/* vnode operations vector */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> v_mount; <span class="hljs-comment"><span class="hljs-comment">/* ptr to vfs we are in */</span></span> ... }</code> </pre> <br>  Wir gehen davon aus, dass das von uns benötigte v_op-Feld genau 8 Bytes von v_mount entfernt ist.  Der Wert der letzteren kann mit öffentlichen KPI erhalten werden ( <a href="">Link zu Github</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mount_t</span></span> vnode_mount(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> vp);</code> </pre><br>  Wenn wir den Wert von v_mount kennen, werden wir nach einer „Nadel im Heuhaufen“ suchen - wir werden den Wert des Zeigers auf vnode 'vp' als uintptr_t *, den Wert von vnode_mount (vp) als uintptr_t wahrnehmen.  Darauf folgen Iterationen auf den „angemessenen“ Wert von i, bis die Bedingung „Heuhaufen [i] == Nadel“ erfüllt ist.  Und wenn die Annahme über die Position der Felder korrekt ist, ist der Versatz v_op i-1. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVOPPtr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vnode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> haystack = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>*) vp; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> needle = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>) vnode_mount(vp); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ATTEMPTCOUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (haystack[i] == needle) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> haystack + (i - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre><br>  <b>So suchen Sie nach einem Versatz: Demontage</b> <br><br>  Trotz seiner Einfachheit weist das erste Verfahren einen signifikanten Nachteil auf.  Wenn Apple die Reihenfolge der Felder in der vnode-Struktur ändert, bricht die einfache Methode ab.  Eine universellere, aber weniger triviale Methode ist das dynamische Zerlegen des Kernels. <br><br>  Betrachten Sie zum Beispiel die disassemblierte Kernelfunktion VNOP_CREATE ( <a href="">Link zu Github</a> ) unter macOS 10.14.6.  Hinweise, die uns interessieren, sind mit einem Pfeil -&gt; gekennzeichnet. <br><br> <code>_VNOP_CREATE: <br> 1 push rbp <br> 2 mov rbp, rsp <br> 3 push r15 <br> 4 push r14 <br> 5 push r13 <br> 6 push r12 <br> 7 push rbx <br> 8 sub rsp, 0x48 <br> 9 mov r15, r8 <br> 10 mov r12, rdx <br> 11 mov r13, rsi <br> -&gt; 12 mov rbx, rdi <br> 13 lea rax, qword [___stack_chk_guard] <br> 14 mov rax, qword [rax] <br> 15 mov qword [rbp+-48], rax <br> -&gt; 16 lea rax, qword [_vnop_create_desc] ; _vnop_create_desc <br> 17 mov qword [rbp+-112], rax <br> 18 mov qword [rbp+-104], rdi <br> 19 mov qword [rbp+-96], rsi <br> 20 mov qword [rbp+-88], rdx <br> 21 mov qword [rbp+-80], rcx <br> 22 mov qword [rbp+-72], r8 <br> -&gt; 23 mov rax, qword [rdi+0xd0] <br> -&gt; 24 movsxd rcx, dword [_vnop_create_desc] <br> 25 lea rdi, qword [rbp+-112] <br> -&gt; 26 call qword [rax+rcx*8] <br> 27 mov r14d, eax <br> 28 test eax, eax <br> ….</code> <br> <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">errno_t</span></span> VNOP_CREATE(<span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> dvp, <span class="hljs-keyword"><span class="hljs-keyword">vnode_t</span></span> * vpp, struct componentname * cnp, struct vnode_attr * vap, <span class="hljs-keyword"><span class="hljs-keyword">vfs_context_t</span></span> ctx) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _err; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vnop_create_args</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> a.a_desc = &amp;vnop;_create_desc; a.a_dvp = dvp; a.a_vpp = vpp; a.a_cnp = cnp; a.a_vap = vap; a.a_context = ctx; _err = (*dvp-&gt;v_op[vnop_create_desc.vdesc_offset])(&amp;a;); …</code> </pre><br>  Wir werden die Assembler-Anweisungen scannen, um die Verschiebung im VNode-DVP zu finden.  Der „Zweck“ des Assembler-Codes besteht darin, eine Funktion aus der Tabelle v_op aufzurufen.  Dazu muss der Prozessor die folgenden Schritte ausführen: <br><br><ol><li>  Laden Sie dvp hoch, um sich zu registrieren </li><li>  Dereferenzieren, um v_op zu erhalten (Zeile 23) </li><li>  Holen Sie sich vnop_create_desc.vdesc_offset (Zeile 24) </li><li>  Rufe eine Funktion auf (Zeile 26) </li></ol><br>  Wenn bei den Schritten 2 bis 4 alles klar ist, treten beim ersten Schritt Schwierigkeiten auf.  Wie kann ich nachvollziehen, in welches Register dvp geladen wurde?  Dazu haben wir eine Methode zum Emulieren einer Funktion verwendet, die die Bewegungen des gewünschten Zeigers überwacht.  Gemäß der System V x86_64-Aufrufkonvention wird das erste Argument im rdi-Register übergeben.  Aus diesem Grund haben wir uns entschlossen, alle Register, die rdi enthalten, im Auge zu behalten.  In meinem Beispiel sind dies die Register rbx und rdi.  Außerdem kann eine Kopie des Registers auf dem Stapel gespeichert werden, der sich in der Debug-Version des Kernels befindet. <br><br>  Wenn wir wissen, dass die Register rbx und rdi dvp speichern, finden wir heraus, dass Zeile 23 vnode dereferenziert, um v_op zu erhalten.  Wir gehen also davon aus, dass die Verschiebung in der Struktur 0xd0 ist.  Um die richtige Entscheidung zu bestätigen, scannen wir weiter und stellen sicher, dass die Funktion korrekt aufgerufen wird (Zeilen 24 und 26). <br><br>  Diese Methode ist sicherer, hat aber leider auch Nachteile.  Wir müssen uns auf die Tatsache verlassen, dass das Funktionsmuster (dh die 4 Schritte, über die wir oben gesprochen haben) dasselbe ist.  Die Wahrscheinlichkeit, das Muster der Funktion zu ändern, ist jedoch um eine Größenordnung geringer als die Wahrscheinlichkeit, die Reihenfolge der Felder zu ändern.  Also beschlossen wir, mit der zweiten Methode aufzuhören. <br><br><h3>  Ersetzen Sie die Zeiger in der Tabelle </h3><br>  Nachdem Sie v_op gefunden haben, stellt sich die Frage, wie Sie diesen Zeiger verwenden sollen.  Es gibt zwei Möglichkeiten: Überschreiben Sie die Funktion in der Tabelle (dritter Pfeil im Bild) oder überschreiben Sie die Tabelle in vnode (zweiter Pfeil im Bild). <br><br>  Auf den ersten Blick scheint die erste Option rentabler zu sein, da wir nur einen Zeiger ersetzen müssen.  Dieser Ansatz weist jedoch zwei wesentliche Nachteile auf.  Erstens ist die v_op-Tabelle für alle vnode eines bestimmten Dateisystems gleich (v_op für HFS +, v_op für APFS, ...). Daher ist das Filtern nach vnode erforderlich, was sehr teuer sein kann. Sie müssen bei jedem Schreibvorgang zusätzlichen vnode herausfiltern.  Zweitens wird die Tabelle auf der schreibgeschützten Seite geschrieben.  Diese Einschränkung kann umgangen werden, wenn Sie die Aufzeichnung über IOMappedWrite64 verwenden und Systemprüfungen umgehen.  Wenn kext mit dem Dateisystemtreiber ausgeliefert wird, ist es schwierig, herauszufinden, wie der Patch entfernt werden kann. <br><br>  Die zweite Option erweist sich als zielgerichteter und sicherer - der Interceptor wird nur für den erforderlichen vNode aufgerufen, und der vNode-Speicher ermöglicht zunächst Lese- / Schreibvorgänge.  Da die gesamte Tabelle ersetzt wird, muss etwas mehr Speicher zugewiesen werden (80 Funktionen statt einer).  Und da die Anzahl der Tabellen in der Regel der Anzahl der Dateisysteme entspricht, ist das Speicherlimit völlig vernachlässigbar. <br><br>  Deshalb wendet kext die zweite Methode an, obwohl es auf den ersten Blick so aussieht, als wäre diese Option schlechter. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f6/adc/957/0f6adc957cded9d732080d3f32cfa4d1.png" alt="Bild"><br><br>  Infolgedessen arbeitet unser Fahrer wie folgt: <br><br><ol><li>  Die KAUTH-API stellt vnode bereit </li><li>  Wir ersetzen die VNode-Tabelle.  Bei Bedarf fangen wir Operationen nur für "interessante" Knoten ab, zum Beispiel für Benutzerdokumente </li><li>  Wenn wir abfangen, prüfen wir, welcher Prozess gerade aufgezeichnet wird, filtern wir „unsere“ </li><li>  Wir senden eine synchrone UserSpace-Anfrage an den Client, der entscheidet, was genau gespeichert werden soll. </li></ol><br><h3>  Was ist passiert? </h3><br>  Heute haben wir ein experimentelles Modul, das eine Erweiterung des macOS-Kernels ist und alle Änderungen am Dateisystem auf granularer Ebene berücksichtigt.  Es ist erwähnenswert, dass Apple in macOS 10.15 ein neues Framework ( <a href="https://developer.apple.com/documentation/endpointsecurity%3Flanguage%3Dobjc">Link zu EndpointSecurity</a> ) eingeführt hat, um Benachrichtigungen über Änderungen am Dateisystem zu erhalten, das für die Verwendung in Active Protection vorgesehen ist. Aus diesem Grund wurde die im Artikel beschriebene Lösung für veraltet erklärt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484816/">https://habr.com/ru/post/de484816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484802/index.html">Selbstzerstörungsmodus: Zersetzung der endoskopischen Kapsel durch Licht</a></li>
<li><a href="../de484804/index.html">Was muss in einem Unternehmenssystem verschlüsselt werden? Und warum das machen?</a></li>
<li><a href="../de484806/index.html">Unterschied zwischen cPanel und Plesk Obsidian</a></li>
<li><a href="../de484812/index.html">Meine Erfahrung mit Plesk</a></li>
<li><a href="../de484814/index.html">6. Fortinet Getting Started v6.0. Webfilterung und Anwendungskontrolle</a></li>
<li><a href="../de484818/index.html">Das Buch "C ++. Die Praxis der Multithread-Programmierung "</a></li>
<li><a href="../de484820/index.html">FAQ.Net - ein kostenloses Notizenprogramm für Windows mit aktualisiertem Design</a></li>
<li><a href="../de484822/index.html">Blazor: Wie verhindert man, dass eine Komponente krank wird, oder wie trennt man Code vom Markup?</a></li>
<li><a href="../de484824/index.html">Der Krieg um das Licht auszuschalten</a></li>
<li><a href="../de484826/index.html">Künstliche Intelligenz verschlimmert die schlechte Medizin noch mehr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>