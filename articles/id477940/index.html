<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿 🗽 👩🏽‍🎨 ORM Benchmarking digunakan saat membuat aplikasi Android ⏯️ ⌛️ 🔚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Artyom Dobrovinsky dan saya adalah seorang pengembang Android di FINCH . 


 Suatu hari, sambil membungkus diri dalam asap cerut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ORM Benchmarking digunakan saat membuat aplikasi Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477940/"><p>  Halo, Habr!  Nama saya Artyom Dobrovinsky dan saya adalah seorang pengembang Android di <a href="https://www.facebook.com/FinchMoscow">FINCH</a> . </p><br><p> Suatu hari, sambil membungkus diri dalam asap cerutu pagi, saya mempelajari kode sumber satu ORM untuk Android.  Melihat ada paket yang disebut <code>benchmarks</code> segera melihat ke sana, dan terkejut bahwa semua evaluasi dilakukan menggunakan <code>Log.d(System.nanoTime())</code> .  Ini bukan pertama kalinya saya melihat ini.  Sejujurnya, saya bahkan melihat benchmark dibuat menggunakan <code>System.currentTimeMillis()</code> .  Kesadaran runtuh bahwa sesuatu perlu diubah memaksa saya untuk mengesampingkan segelas wiski dan duduk di keyboard. </p><a name="habracut"></a><br><h3 id="pochemu-napisana-eta-statya">  Mengapa artikel ini ditulis? </h3><br><p>  Situasi dengan memahami bagaimana mengukur kinerja kode di Android menyedihkan. <br>  Jangan berbicara tentang profiler, tetapi pada tahun 2019 seseorang tetap yakin bahwa JVM melakukan semua yang ditulis pengembang dan dalam urutan yang tepat di mana kode ditulis.  Pada kenyataannya, tidak ada yang lebih jauh dari kebenaran. </p><br><p>  Kenyataannya, mesin virtual yang malang itu berkelahi melawan satu miliar pembaca tombol yang ceroboh yang menulis kode mereka sendiri, tidak perlu khawatir tentang bagaimana prosesor akan bekerja dengan semua ini.  Pertempuran ini telah berlangsung selama beberapa tahun, dan dia memiliki sejuta optimisasi rumit di lengan bajunya yang (jika diabaikan) akan mengubah pengukuran kinerja program apa pun menjadi buang-buang waktu. </p><br><p>  Artinya, pengembang terkadang tidak menganggap perlu untuk mengukur kinerja kode, dan bahkan lebih sering tidak tahu caranya.  Kesulitannya terletak pada kenyataan bahwa untuk melakukan penilaian kinerja, perlu untuk menciptakan kondisi yang paling mirip dan ideal untuk semua kasus - ini adalah satu-satunya cara untuk mendapatkan informasi yang bermanfaat.  Kondisi ini diciptakan oleh solusi yang tidak tertulis di lutut. </p><br><p>  Jika Anda memerlukan argumen tentang apakah akan menggunakan kerangka kerja pihak ketiga untuk mengukur kinerja, Anda selalu dapat membaca <a href="https://shipilev.net/blog/2014/nanotrusting-nanotime/">Alexei Shipilev</a> dan mengagumi kedalaman masalahnya.  Semuanya ada dalam artikel dengan referensi: mengapa pemanasan diperlukan sebelum melakukan benchmark, mengapa <code>System.currentTimeMillis()</code> tidak dapat dipercaya sama sekali ketika menghitung waktu yang berlalu, dan lelucon untuk 300. Bacaan yang bagus. </p><br><h5 id="pochemu-ya-mogu-ob-etom-rasskazyvat">  Mengapa saya bisa membicarakan ini? </h5><br><p>  Faktanya adalah bahwa saya adalah pengembang yang dikembangkan secara komprehensif: Saya tidak hanya memiliki Android SDK seolah-olah itu adalah proyek hewan peliharaan saya, tetapi selama sebulan lagi saya menulis kode untuk backend. </p><br><p>  Ketika saya membawa microservice pertama saya ke review, dan tidak ada pembandingan di <code>README</code> , dia menatap saya dengan kesalahpahaman.  Saya ingat ini dan tidak pernah mengulangi kesalahan ini lagi.  Karena dia pergi dalam seminggu. </p><br><p>  Ayo pergi. </p><br><h3 id="chto-izmeryaem">  Apa yang kita ukur </h3><br><p>  Sebagai bagian dari kasus untuk pembandingan basis data untuk Android, saya memutuskan untuk mengukur kecepatan inisialisasi dan kecepatan tulis / baca untuk ORM seperti Paper, Hawk, Realm and Room. <br>  Ya, saya mengukur dalam satu tes NoSQL dan basis data relasional - apa pertanyaan berikutnya? </p><br><h3 id="chem-izmeryaem">  Daripada kita mengukur </h3><br><p>  Tampaknya jika kita berbicara tentang JVM, maka pilihannya jelas - ada <a href="https://openjdk.java.net/projects/code-tools/jmh/">JMH yang</a> <a href="https://mvnrepository.com/tags/benchmark">dimuliakan</a> , <a href="https://groups.google.com/d/msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ">disempurnakan</a> dan <a href="http://hg.openjdk.java.net/code-tools/jmh/file/f2e982b7c51b/jmh-samples/src/main/java/org/openjdk/jmh/samples/">didokumentasikan dengan sempurna</a> .  Tapi tidak, itu tidak memulai tes instrumentasi untuk Android. </p><br><p>  Google <a href="https://github.com/google/caliper">Calipher</a> mengikutinya - dengan hasil yang sama. </p><br><p>  Ada garpu Calipher yang disebut <a href="https://github.com/cmelchior/spanner">Spanner</a> - yang selama bertahun-tahun telah zeppercay dan mendorong penggunaan <a href="https://developer.android.com/jetpack/androidx/releases/benchmark">Androidx Benchmark</a> . </p><br><p>  Mari kita fokus pada yang terakhir.  Kalau saja karena kita tidak punya pilihan. </p><br><p>  Seperti semua yang ditambahkan ke Jetpack dan tidak dipikirkan kembali saat bermigrasi dari Support Library, Androidx Benchmark terlihat dan berperilaku seolah-olah itu ditulis dalam satu setengah minggu sebagai tugas tes, dan tidak ada orang lain yang akan menyentuhnya.  Plus, lib ini sedikit lalu - karena, lebih untuk mengevaluasi tes UI.  Tetapi karena menginginkan yang terbaik, Anda dapat bekerja dengannya.  Ini akan menyelamatkan kita setidaknya dari <a href="">kesalahan nyata</a> , dan juga membantu pemanasan. </p><br><p>  Untuk mengurangi kekonyolan hasil, saya akan menjalankan semua tes 10 kali dan menghitung rata-rata. </p><br><p>  Perangkat pengujian - Xiaomi A1.  Bukan yang terlemah di pasaran, "bersih" Android. </p><br><h3 id="podklyuchenie-biblioteki-v-proekt">  Menghubungkan perpustakaan ke proyek </h3><br><p>  Ada <a href="">instruksi yang sangat baik</a> tentang menghubungkan Andoridx Benchmark ke proyek.  Saya sangat menyarankan Anda untuk tidak malas dan menghubungkan modul terpisah untuk melakukan pengukuran. </p><br><h3 id="hod-eksperimenta">  Kemajuan percobaan </h3><br><p>  Semua tolok ukur kami akan dieksekusi dalam urutan berikut: </p><br><ol><li>  Pertama, kami menginisiasi database di dalam badan uji. </li><li>  Kemudian, di blok <code>benchmarkRule.scope.runWithTimingDisabled</code> , kami menghasilkan data yang kami beri makan basis data.  Kode yang ditempatkan di sirkuit ini tidak akan diperhitungkan dalam evaluasi. </li><li>  Dalam penutupan yang sama kami menambahkan logika membersihkan database;  pastikan database kosong sebelum menulis. </li><li>  Berikut ini adalah logika penulisan dan membaca.  Pastikan untuk menginisialisasi variabel dengan hasil membaca sehingga JVM tidak menghapus logika ini dari jumlah eksekusi sebagai tidak terpakai. </li><li>  Kami mengukur kinerja inisialisasi basis data dalam fungsi terpisah. </li><li>  Kami merasa seperti orang sains. </li></ol><br><p>  Kode dapat ditemukan di <a href="https://github.com/dobrowins/androiddbbenchmarks/tree/master/tests/src/androidTest/java/com/dobrowins/dbbenchmarking/tests">sini</a> .  Jika Anda malas berjalan, fungsi pengukuran untuk PaperDb terlihat seperti ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paperdbInsertReadTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = benchmarkRule.measureRepeated { <span class="hljs-comment"><span class="hljs-comment">//   (     ) benchmarkRule.scope.runWithTimingDisabled { Paper.book().destroy() if (Paper.book().allKeys.isNotEmpty()) throw RuntimeException() } //    repository.store(persons, { list -&gt; Paper.book().write(KEY_CONTACTS, list) }) val persons = repository.read { Paper.book().read&lt;List&lt;Person&gt;&gt;(KEY_CONTACTS, emptyList()) } }</span></span></code> </pre> <br><p>  Benchmark untuk sisa ORM terlihat serupa. </p><br><h4 id="rezultaty">  Hasil </h4><br><h5 id="inicializaciya">  Inisialisasi </h5><br><div class="scrollable-table"><table><thead><tr><th>  nama tes </th><th>  jahat </th><th>  1 </th><th>  2 </th><th>  3 </th><th>  4 </th><th>  5 </th><th>  6 </th><th>  7 </th><th>  8 </th><th>  9 </th><th>  10 </th></tr></thead><tbody><tr><td>  HawkInitTest </td><td>  49_512 </td><td>  49_282 </td><td>  50_021 </td><td>  49_119 </td><td>  50_145 </td><td>  49_970 </td><td>  50_047 </td><td>  46_649 </td><td>  50_230 </td><td>  49_863 </td><td>  49_794 </td></tr><tr><td>  PaperdbInitTest </td><td>  224 </td><td>  223 </td><td>  223 </td><td>  223 </td><td>  233 </td><td>  223 </td><td>  223 </td><td>  223 </td><td>  223 </td><td>  223 </td><td>  223 </td></tr><tr><td>  RealmInitTest </td><td>  218 </td><td>  217 </td><td>  217 </td><td>  217 </td><td>  217 </td><td>  217 </td><td>  217 </td><td>  217 </td><td>  227 </td><td>  217 </td><td>  217 </td></tr><tr><td>  RoomInitTest </td><td>  61_695.5 </td><td>  63_450 </td><td>  59_714 </td><td>  58_527 </td><td>  59_175 </td><td>  63_544 </td><td>  62_980 </td><td>  63_252 </td><td>  59_670 </td><td>  63_868 </td><td>  62_775 </td></tr></tbody></table></div><br><p>  Pemenangnya adalah Realm, di tempat kedua adalah Kertas.  Apa yang dilakukan Room, Anda masih dapat membayangkan bahwa Hawk melakukan jumlah waktu yang hampir sama - benar-benar tidak dapat dipahami. </p><br><h5 id="zapis-i-chtenie">  Menulis dan membaca </h5><br><div class="scrollable-table"><table><thead><tr><th>  nama tes </th><th>  jahat </th><th>  1 </th><th>  2 </th><th>  3 </th><th>  4 </th><th>  5 </th><th>  6 </th><th>  7 </th><th>  8 </th><th>  9 </th><th>  10 </th></tr></thead><tbody><tr><td>  HawkInsertReadTest </td><td>  278_736_469.2 </td><td>  278_098_654 </td><td>  283_956_846 </td><td>  276_748_308 </td><td>  282_447_384 </td><td>  272_609_500 </td><td>  284_699_653 </td><td>  271_869_770 </td><td>  278_719_693 </td><td>  278_836_115 </td><td>  279_378_769 </td></tr><tr><td>  PaperdbInsertReadTest </td><td>  173_519_957.3 </td><td>  172_953_347 </td><td>  174_702_2000 </td><td>  169_740_846 </td><td>  174_401_192 </td><td>  173_930_037 </td><td>  174_179_616 </td><td>  173_937_460 </td><td>  173_739_115 </td><td>  176_215_038 </td><td>  171_400_922 </td></tr><tr><td>  RealmInsertReadTest </td><td>  111_644_042.3 </td><td>  108_501_578 </td><td>  110_616_078 </td><td>  102_056_461 </td><td>  112_946_577 </td><td>  111_701_231 </td><td>  114_922_962 </td><td>  106_198_2000 </td><td>  118_742_498 </td><td>  120_888_230 </td><td>  109_866_808 </td></tr><tr><td>  RoomInsertReadTest </td><td>  1_863_499_483.3 </td><td>  187_250_3614 </td><td>  1_837_078_614 </td><td>  1_872_482_538 </td><td>  1_827_338_460 </td><td>  1_869_147_999 </td><td>  1_857_126_229 </td><td>  1_842_427_537 </td><td>  1_870_630_652 </td><td>  1_878_862_538 </td><td>  1_907_396_652 </td></tr></tbody></table></div><br><p>  Di sini lagi pemenang Realm, tetapi dalam hasil ini bernada kegagalan. </p><br><p>  Perbedaan empat kali antara dua database "paling lambat" dan enam belas kali antara "tercepat" dan "paling lambat" sangat mencurigakan.  Bahkan dengan mempertimbangkan fakta bahwa perbedaannya stabil. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Mengukur kinerja kode Anda setidaknya karena penasaran.  Bahkan jika kita berbicara tentang kasus yang paling banyak diluncurkan oleh industri (seperti evaluasi tes instrumental untuk Android). </p><br><p>  Ada banyak alasan untuk menggunakan kerangka kerja pihak ketiga untuk bisnis ini (daripada menulis sendiri sesuai waktu dan pemandu sorak). </p><br><p>  Situasi dalam basis kode sedemikian rupa sehingga setiap orang berusaha menulis dalam arsitektur yang bersih, karena sebagian besar, modul dengan logika bisnis adalah modul java - menghubungkan modul dengan JMH terdekat dan memeriksa kode untuk kemacetan - ia bekerja selama sehari.  Dan manfaatnya - untuk tahun-tahun mendatang. </p><br><p>  Selamat coding! </p><br><p>  PS: Jika pembaca yang penuh perhatian tahu tentang kerangka kerja untuk melakukan benchmark tes instrumental untuk Android, tidak tercantum dalam artikel - silakan berbagi di komentar. </p><br><p>  PPS: Gudang uji terbuka untuk permintaan tarik. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477940/">https://habr.com/ru/post/id477940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477928/index.html">Rekaman laporan dari QA-mitap Redmadrobot</a></li>
<li><a href="../id477930/index.html">Arsitektur terbaik untuk MVP: monolith, SOA, microservices atau serverless? .. Bagian 2</a></li>
<li><a href="../id477934/index.html">Diskon dari hosters pada Black Friday 2019</a></li>
<li><a href="../id477936/index.html">Kamus IT atau Apa? Dimana? Kemana? Bagian 2</a></li>
<li><a href="../id477938/index.html">Pasar server yang digunakan di Rusia: semuanya dimulai dengan Habr</a></li>
<li><a href="../id477944/index.html">Situasi: Dukungan Python 2.7 dihentikan sejak 2020</a></li>
<li><a href="../id477950/index.html">Aturan pertama anti-penipuan adalah tidak memberi tahu siapa pun tentang anti-penipuan</a></li>
<li><a href="../id477954/index.html">Bagaimana posting jawaban akan membuat internet lebih pintar</a></li>
<li><a href="../id477956/index.html">JavaScript dalam 3D: pengantar Three.js</a></li>
<li><a href="../id477958/index.html">10 tren teratas dari laporan Tren Kejahatan Berteknologi-Tinggi baru 2019/2020 Group-IB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>