<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏼 👩🏿‍🔧 ⏸️ Assembleur sale pirate 6502 🤛🏻 🦂 👩🏻‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article répertorie certaines des astuces utilisées par les participants à mon petit concours de programmation Commodore 64 . Les règles du concour...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembleur sale pirate 6502</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464377/">  Cet article répertorie certaines des astuces utilisées par les participants à mon petit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">concours de programmation Commodore 64</a> .  Les règles du concours étaient simples: créer un fichier exécutable C64 (PRG) qui dessine deux lignes pour former l'image ci-dessous.  Celui dont le fichier est plus petit a gagné. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/5d1/afc/3f45d1afc9817c6530b6b34c44dd0497.png"></div><br>  Les candidatures au concours ont été publiées dans des tweets ouverts et dans des messages privés ne contenant que des octets du fichier PRG et un hachage MD5. <br><a name="habracut"></a><br>  Liste des participants avec des liens vers le code source: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Philip Heron</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> - 34 octets, gagnant) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Geir Straume</a> ( <a href="">code</a> - 34 octets) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Petri Hakkinen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> - 37 octets) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Matlev Raksenblatts</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> - 38 octets) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jan Ahrenius</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> - 48 octets) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jamie Fuller</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> - 50 octets) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">David A. Gershman</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> - 53 octets) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Janne Hellsten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> - 56 octets) </li></ul><br>  (Si j'ai raté quelqu'un, faites-le moi savoir, je mettrai à jour la liste). <br><br>  Le reste de l'article est consacré à quelques astuces d'assembleur qui ont été utilisées dans la compétition. <br><br><h1>  Les bases </h1><br>  Graphics C64 fonctionne par défaut en mode d'encodage 40x25 caractères.  Le framebuffer en RAM est divisé en deux tableaux: <br><br><ul><li> <code>$0400</code> (RAM écran, 40 x 25 octets) <br></li><li>  <code>$d800</code> (RAM couleur, 40x25 octets) </li></ul><br>  Pour définir un caractère, vous enregistrez l'octet dans la RAM à l'écran, à <code>$0400</code> (par exemple, <code>$0400+y*40+x</code> ).  La couleur RAM est initialisée par bleu clair par défaut (couleur 14): c'est la couleur que nous utilisons pour les lignes, c'est-à-dire que la couleur RAM peut être laissée sans toucher. <br><br>  Vous contrôlez les couleurs de la bordure et de l'arrière-plan à l'aide des registres d'E / S mémoire dans <code>$d020</code> (bordure) et <code>$d021</code> (arrière-plan). <br><br>  Tracer deux lignes est assez facile si vous programmez directement la pente d'une ligne fixe.  Voici une implémentation C qui dessine des lignes et vide le contenu de l'écran vers stdout ( <code>malloc()</code> est utilisé pour faire fonctionner le code sur un PC): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void dump(const uint8_t* screen) { const uint8_t* s = screen; for (int y = 0; y &lt; 25; y++) { for (int x = 0; x &lt; 40; x++, s++) { printf("%c", *s == 0xa0 ? '#' : '.'); } printf("\n"); } } void setreg(uintptr_t dst, uint8_t v) { // *((uint8_t *)dst) = v; } int main() { // uint8_t* screenRAM = (uint_8*)0x0400; uint8_t* screenRAM = (uint8_t *)calloc(40*25, 0x20); setreg(0xd020, 0); // Set border color setreg(0xd021, 0); // Set background color int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; for (int x = 0; x &lt; 40; x++) { int yi = yf &gt;&gt; 8; // First line screenRAM[x + yi*40] = 0xa0; // Second line (X-mirrored) screenRAM[(39-x) + yi*40] = 0xa0; yf += yslope; } dump(screenRAM); }</span></span></span></span></code> </pre> <br>  Les codes d'écran ci-dessus sont <code>$20</code> (vide) et <code>$a0</code> (bloc 8 × 8 rempli).  Si vous exécutez, vous verrez une image ASCII avec deux lignes: <br><br><pre>  ## .................................... ##
 .. # .................................. # ..
 ... ## .............................. ## ...
 ..... # ............................ # .....
 ...... ## ........................ ## ......
 ........ ## .................... ## ........
 .......... # .................. # ..........
 ........... ## .............. ## ...........
 ............. # ............ # .............
 .............. ## ........ ## ..............
 ................ ## .... ## ................
 .................. # .. # ..................
 ................... ## ...................
 .................. # .. # ..................
 ................ ## .... ## ................
 .............. ## ........ ## ..............
 ............. # ............ # .............
 ........... ## .............. ## ...........
 .......... # .................. # ..........
 ........ ## .................... ## ........
 ...... ## ........................ ## ......
 ..... # ............................ # .....
 ... ## .............................. ## ...
 .. # .................................. # ..
 ## .................................... ## </pre><br>  La même chose est trivialement implémentée dans l'assembleur: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) entry: { lda #0 ; black color sta $d020 ; set border to 0 sta $d021 ; set background to 0 ; clear the screen ldx #0 lda #$20 clrscr: !for i in [0, $100, $200, $300] { sta $0400 + i, x } inx bne clrscr ; line drawing, completely unrolled ; with assembly pseudos lda #$a0 !for i in range(40) { !let y0 = Math.floor(25/40*(i+0.5)) sta $0400 + y0*40 + i sta $0400 + (24-y0)*40 + i } inf: jmp inf ; halt }</code> </pre> <br>  Il s'avère que PRG a une taille assez grande de 286 octets. <br><br>  Avant de plonger dans l'optimisation, nous faisons quelques observations. <br><br>  Premièrement, nous travaillons sur C64 avec les routines ROM en place.  Il existe des tonnes de routines qui peuvent être utiles.  Par exemple, effacer l'écran avec <code>JSR $E544</code> . <br><br>  Deuxièmement, les calculs d'adresse sur un processeur 8 bits tel que 6502 peuvent être fastidieux et consommer beaucoup d'octets.  Ce processeur n'a pas non plus de multiplicateur, donc un calcul comme <code>y*40+i</code> inclut généralement un groupe de décalages logiques ou une table de recherche qui mange également des octets.  Pour éviter de multiplier par 40, il est préférable d'avancer le curseur à l'écran de manière incrémentielle: <br><br><pre> <code class="plaintext hljs"> int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xa0; dst[(39-x)] = 0xa0; yf += yslope; if (yf &amp; 256) { // Carry set? dst += 40; yf &amp;= 255; } }</code> </pre> <br>  Nous continuons d'ajouter la pente de la ligne au compteur fixe <code>yf</code> , et lorsque l'addition 8 bits définit le drapeau de report, ajoutez 40. <br><br>  Voici une approche d'assembleur incrémentiel: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) !let screenptr = $20 !let x0 = $40 !let x1 = $41 !let yf = $60 entry: { lda #0 sta x0 sta $d020 sta $d021 ; kernal clear screen jsr $e544 ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1 lda #80 sta yf lda #39 sta x1 xloop: lda #$a0 ldy x0 ; screenRAM[x] = 0xA0 sta (screenptr), y ldy x1 ; screenRAM[39-x] = 0xA0 sta (screenptr), y clc lda #160 ; line slope adc yf sta yf bcc no_add ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1 no_add: inc x0 dec x1 bpl xloop inf: jmp inf }</code> </pre> <br>  Avec 82 octets, c'est encore assez lourd.  Un problème évident est le calcul d'adresse 16 bits.  Définissez la valeur <code>screenptr</code> pour l' <code>screenptr</code> indirecte: <br><br><pre> <code class="plaintext hljs"> ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1</code> </pre> <br>  Nous traduisons <code>screenptr</code> à la ligne suivante en ajoutant 40: <br><br><pre> <code class="plaintext hljs"> ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1</code> </pre> <br>  Bien sûr, ce code peut être optimisé, mais qu'en est-il si vous vous débarrassez des adresses 16 bits?  Voyons comment faire. <br><br><h1>  Astuce 1. Défilement! </h1><br>  Au lieu de construire une ligne dans la RAM à l'écran, nous ne dessinons que dans la dernière ligne d'écran Y = 24 et faisons défiler l'écran vers le haut, en appelant la fonction de défilement ROM avec <code>JSR $E8EA</code> ! <br><br>  Voici comment xloop est optimisé: <br><br><pre> <code class="plaintext hljs"> lda #0 sta x0 lda #39 sta x1 xloop: lda #$a0 ldx x0 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: inc x0 dec x1 bpl xloop</code> </pre> <br>  Voici à quoi ressemble le rendu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/081/6a6/63f0816a6728ec839de0197b6e0a3179.gif"></div><br><br>  C'est l'un de mes trucs préférés dans ce programme.  Presque tous les participants au concours l'ont découvert indépendamment. <br><br><h1>  Astuce 2. Code auto-modifiant </h1><br>  Le code de stockage des valeurs de pixels se termine comme suit: <br><br><pre> <code class="plaintext hljs"> ldx x1 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x0 sta $0400 + 24*40, x inc x0 dec x1</code> </pre> <br>  Ceci est codé dans la séquence suivante de 14 octets: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: A6 20 LDX $20 080A: 9D C0 07 STA $07C0,X 080D: E6 22 INC $22 080F: C6 20 DEC $20</code> </pre> <br>  En utilisant du code auto-modifiable (SMC), vous pouvez écrire ceci de manière plus compacte: <br><br><pre> <code class="plaintext hljs"> ldx x1 sta $0400 + 24*40, x addr0: sta $0400 + 24*40 ; advance the second x-coord with SMC inc addr0+1 dec x1</code> </pre> <br>  ... qui est codé à 13 octets: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: 8D C0 07 STA $07C0 080B: EE 09 08 INC $0809 080E: C6 22 DEC $22</code> </pre> <br><h1>  Astuce 3. État de fonctionnement «sous tension» </h1><br>  Il a été jugé normal dans la compétition de faire des hypothèses folles sur l'environnement de travail.  Par exemple, le dessin au trait est la première chose qui commence après la mise sous tension du C64, et il n'y a aucune exigence pour une sortie propre à la ligne de commande BASIC.  Par conséquent, tout ce que vous trouvez dans l'environnement initial en entrant dans le PRG peut et doit être utilisé à votre avantage: <br><br><ul><li>  Les registres A, X, Y sont pris comme des zéros <br></li><li>  Tous les drapeaux CPU effacés <br></li><li>  Contenu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zeropage</a> (adresse <code>$00</code> <code>$ff</code> - <code>$ff</code> ) </li></ul><br>  De la même manière, lorsque vous appelez certaines procédures KERNAL ROM, vous pouvez profiter pleinement de tous les effets secondaires: indicateurs CPU renvoyés, valeurs de zéros temporaires, etc. <br><br>  Après les premières optimisations, recherchons quelque chose d'intéressant dans la mémoire de la machine: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/43f/93c/0df43f93c58a142911607d3ba5ba44dd.png"></div><br><br>  Zeropage contient des valeurs utiles pour nos besoins: <br><br><ul><li>  <code>$d5</code> : 39 / $ 27 == longueur de ligne - 1 <br></li><li>  <code>$22</code> : 64/40 $ == valeur initiale pour le compteur de pente de ligne </li></ul><br>  Cela permettra d'économiser quelques octets lors de l'initialisation.  Par exemple: <br><br><pre> <code class="plaintext hljs">!let x0 = $20 lda #39 ; 0801: A9 27 LDA #$27 sta x0 ; 0803: 85 20 STA $20 xloop: dec x0 ; 0805: C6 20 DEC $20 bpl xloop ; 0807: 10 FC BPL $0805</code> </pre> <br>  Puisque <code>$d5</code> contient la valeur 39, vous pouvez l'indiquer au compteur <code>x0</code> , en vous débarrassant de la paire LDA / STA: <br><br><pre> <code class="plaintext hljs">!let x0 = $d5 ; nothing here! xloop: dec x0 ; 0801: C6 D5 DEC $D5 bpl xloop ; 0803: 10 FC BPL $0801</code> </pre> <br>  Philip, le vainqueur du concours, pousse les choses à l'extrême dans <a href="">son code</a> .  Rappelez l'adresse du dernier caractère de la chaîne <code>$07C0</code> (== <code>$0400+24*40</code> ).  Cette valeur n'est pas présente dans la page zéro lors de l'initialisation.  Cependant, comme effet secondaire de la façon dont la routine de défilement à partir de la ROM utilise des valeurs de zéros temporaires, les adresses <code>$D1-$D2</code> à la sortie de la fonction contiendront la valeur <code>$07C0</code> .  Par conséquent, pour stocker un pixel, au lieu de <code>STA $07C0,x</code> vous pouvez utiliser l'adressage d'index indirect plus court <code>STA ($D1),y</code> pour un octet. <br><br><h1>  Astuce 4. Optimisation du téléchargement </h1><br>  Un binaire C64 PRG typique contient les éléments suivants: <br><br><ul><li>  2 premiers octets: adresse de téléchargement (généralement <code>$0801</code> ) <br></li><li>  12 octets de la séquence de démarrage BASIC </li></ul><br>  La séquence de démarrage principale ressemble à ceci (adresse <code>$801-$80C</code> ): <br><br><pre> <code class="plaintext hljs">0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00 080D: 8D 20 D0 STA $D020</code> </pre> <br>  Sans entrer dans les détails de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">disposition de la mémoire tokenisée BASIC</a> , cette séquence correspond plus ou moins à '10 SYS 2061 '.  L'adresse <code>2061</code> ( <code>$080D</code> ) est l'endroit où notre programme de code machine réel s'exécute lorsque l'interpréteur BASIC exécute la commande SYS. <br><br>  Il semble juste que 14 octets, c'est trop.  Philip, Matlev et Geir ont utilisé plusieurs astuces pour se débarrasser complètement de la séquence principale.  Cela nécessite de charger le PRG avec <code>LOAD"*",8,1</code> , car <code>LOAD"*",8</code> ignore l'adresse de chargement du PRG (deux premiers octets) et se charge toujours à <code>$0801</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/d07/fdb/911d07fdb2c0e2e13b07e360bb16d03c.png"></div><br><br>  Deux méthodes ont été utilisées ici: <br><br><ul><li>  Astuce de pile <br></li><li>  Astuce de réinitialisation à chaud BASIC </li></ul><br><h3>  Astuce de pile </h3><br>  L'astuce consiste à faire <code>$01F8</code> dans la pile du processeur à <code>$01F8</code> valeur qui indique notre point d'entrée souhaité.  Cela se fait en créant un PRG qui commence par un pointeur 16 bits sur notre code et en chargeant le PRG à <code>$01F8</code> : <br><br><pre> <code class="plaintext hljs"> * = $01F8 !word scroll - 1 ; overwrite stack scroll: jsr $E8EA</code> </pre> <br>  Dès que le chargeur BASIC (voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code après le démontage</a> ) a fini de charger et veut retourner à l'objet appelant en utilisant <code>RTS</code> , il revient directement à notre PRG. <br><br><h3>  Astuce de réinitialisation à chaud BASIC </h3><br>  C'est un peu plus facile à expliquer simplement en regardant le PRG après le démontage. <br><br><pre> <code class="plaintext hljs">02E6: 20 EA E8 JSR $E8EA 02E9: A4 D5 LDY $D5 02EB: A9 A0 LDA #$A0 02ED: 99 20 D0 STA $D020,Y 02F0: 91 D1 STA ($D1),Y 02F2: 9D B5 07 STA $07B5,X 02F5: E6 D6 INC $D6 02F7: 65 90 ADC $90 02F9: 85 90 STA $90 02FB: C6 D5 DEC $D5 02FD: 30 FE BMI $02FD 02FF: 90 E7 BCC $02E8 0301: 4C E6 02 JMP $02E6</code> </pre> <br>  Faites attention à la dernière ligne ( <code>JMP $02E6</code> ).  L'instruction JMP commence à <code>$0301</code> avec une adresse de saut de <code>$0302-$0303</code> . <br><br>  Lorsque ce code est chargé en mémoire à partir de l'adresse <code>$02E6</code> , la valeur <code>$02E6</code> écrite aux adresses <code>$0302-$0303</code> .  Eh bien, cet emplacement a une signification particulière: il contient un pointeur sur le «cycle d'attente BASIC» (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la carte mémoire C64</a> pour plus de détails).  Le téléchargement de PRG l'écrase avec <code>$02E6</code> et par conséquent, lorsque l'interpréteur BASIC après une réinitialisation à chaud essaie de passer à la boucle d'attente, il n'entre jamais dans cette boucle, mais entre dans le programme de rendu! <br><br><h3>  Autres astuces avec le lancement de BASIC </h3><br>  Petri a découvert <a href="">une autre astuce de lancement BASIC</a> qui vous permet d'entrer vos propres constantes dans zeropage.  Dans cette méthode, vous créez manuellement votre propre séquence de démarrage BASIC à jetons et codez les constantes dans les numéros de ligne du programme BASIC.  À l'entrée, les numéros de ligne BASIC, ahem, c'est-à-dire que vos constantes seront stockées dans les adresses <code>$39-$3A</code> .  Très intelligent! <br><br><h1>  Astuce 5. Flux de contrôle personnalisé </h1><br>  Voici une version légèrement simplifiée de la boucle x qui n'imprime qu'une seule ligne puis arrête l'exécution: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: dec x1 bpl xloop ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Mais il y a une erreur.  Lorsque nous avons dessiné le dernier pixel, nous ne pouvons plus faire défiler l'écran.  Ainsi, des branches supplémentaires sont nécessaires pour arrêter le défilement après l'enregistrement du dernier pixel: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x dec x1 ; skip scrolling if last pixel bmi done adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: jmp xloop done: ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Le flux de contrôle est très similaire à ce que le compilateur C produira à partir d'un programme structuré.  Le code pour ignorer le dernier défilement introduit une nouvelle instruction <code>JMP abs</code> qui prend 3 octets.  Les sauts conditionnels ne font que deux octets, car ils codent les adresses de saut à l'aide d'un opérande relatif de 8 bits avec adressage direct. <br><br>  JMP pour «ignorer le dernier défilement» peut être évité en déplaçant l'appel de défilement vers le haut de la boucle et en modifiant légèrement la structure du flux de contrôle.  Voici comment Philip l'a implémenté: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 scroll: jsr $e8ea xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf dec x1 ; doesn't set carry! inf: bmi inf ; hang here if last pixel! bcc xloop ; next pixel if no scroll bcs scroll ; scroll up and continue</code> </pre> <br>  Cela élimine complètement un JMP de trois octets et convertit l'autre JMP en une branche conditionnelle de deux octets, économisant un total de 4 octets. <br><br><h1>  Astuce 6. Lignes avec compression de bits </h1><br>  Certains éléments n'utilisent pas le compteur de pente de ligne, mais compressent plutôt les bits en une constante de 8 bits.  Un tel conditionnement est basé sur le fait que la position du pixel le long de la ligne correspond à un motif répétitif de 8 pixels: <br><br><pre> <code class="plaintext hljs">int mask = 0xB6; // 10110110 uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xA0; if (mask &amp; (1 &lt;&lt; (x&amp;7))) { dst += 40; // go down a row } }</code> </pre> <br>  Cela se traduit par un assembleur assez compact.  Cependant, les options de compteur d'inclinaison sont généralement encore plus petites. <br><br><h3>  Gagnant </h3><br>  Voici <a href="">le programme gagnant de 34 octets</a> de Philip.  La plupart des astuces ci-dessus fonctionnent bien dans son code: <br><br><pre> <code class="plaintext hljs">ov = $22 ; == $40, initial value for the overflow counter ct = $D5 ; == $27 / 39, number of passes. Decrementing, finished at -1 lp = $D1 ; == $07C0, pointer to bottom line. Set by the kernal scroller ; Overwrite the return address of the kernal loader on the stack ; with a pointer to our own code * = $01F8 .word scroll - 1 scroll: jsr $E8EA ; Kernal scroll up, also sets lp pointer to $07C0 loop: ldy ct ; Load the decrementing counter into Y (39 &gt; -1) lda #$A0 ; Load the PETSCII block / black col / ov step value sta $D020, y ; On the last two passes, sets the background black p1: sta $07C0 ; Draw first block (left &gt; right line) sta (lp), y ; Draw second block (right &gt; left line) inc p1 + 1 ; Increment pointer for the left &gt; right line adc ov ; Add step value $A0 to ov sta ov dec ct ; Decrement the Y counter bmi * ; If it goes negative, we're finished bcc loop ; Repeat. If ov didn't overflow, don't scroll bcs scroll ; Repeat. If ov overflowed, scroll</code> </pre> <br><h3>  Mais pourquoi s'attarder sur 34 octets? </h3><br>  Dès la fin du concours, tout le monde a partagé son code et ses notes - et une série de discussions animées ont eu lieu sur la façon de l'améliorer davantage.  Après la date limite, plusieurs autres options ont été présentées: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Philip - 33 octets</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Philip - 32 octets</a> <br></li><li>  <a href="">Petri - 31 octets</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Philip - 29 octets</a> </li></ul><br>  Soyez sûr de regarder - il y a plusieurs vraies perles. <br><br><hr><br>  Merci d'avoir lu.  Et un merci spécial à Matlev, Phil, Geir, Petri, Jamie, Ian et David pour leur participation (j'espère que personne ne m'a manqué - c'était vraiment difficile de suivre toutes les mentions sur Twitter!) <br><br>  PS Petri a appelé mon concours "annuel", donc, euh, je vous verrai probablement l'année prochaine. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464377/">https://habr.com/ru/post/fr464377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464367/index.html">Et une autre escalade des privilèges locaux du client Steam Windows 0day</a></li>
<li><a href="../fr464369/index.html">Quel bloqueur utilisez-vous? Résultats</a></li>
<li><a href="../fr464371/index.html">/etc/resolv.conf pour les pods Kubernetes, option ndots: 5, car cela peut nuire aux performances de l'application</a></li>
<li><a href="../fr464373/index.html">Edge-to-edge sur Android: bien faire les choses</a></li>
<li><a href="../fr464375/index.html">Fonctionnement des moteurs de recherche</a></li>
<li><a href="../fr464381/index.html">Voyage en Alaska ou KDD'19 à travers les yeux d'un témoin oculaire</a></li>
<li><a href="../fr464383/index.html">Comment je mets les choses en ordre dans un projet où il y a une forêt de mains directes (paramètres tslint, plus joli, etc.)</a></li>
<li><a href="../fr464385/index.html">Python comme cas ultime de C ++. Partie 1/2</a></li>
<li><a href="../fr464387/index.html">Empreinte russe dans la saga scandinave des jeux vidéo, fin</a></li>
<li><a href="../fr464391/index.html">10 rapports intéressants de conférences de hackers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>