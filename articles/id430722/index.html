<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚼 🍠 🤢 Kinerja PHP: perencanaan, pembuatan profil, optimisasi 🏣 🎼 🈷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Dua tahun lalu kami menulis tentang bagaimana kami beralih ke PHP 7.0 dan menghemat satu juta dolar. Pada profil memuat kami, versi baru t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kinerja PHP: perencanaan, pembuatan profil, optimisasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/430722/"><img src="https://habrastorage.org/webt/k_/fe/vv/k_fevvrhhn2aruuz19gpne_jypy.jpeg"><br><br>  Halo, Habr!  Dua tahun lalu kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis</a> tentang bagaimana kami beralih ke PHP 7.0 dan menghemat satu juta dolar.  Pada profil memuat kami, versi baru ternyata dua kali lebih efisien dalam penggunaan CPU: beban yang kami gunakan untuk melayani ~ 600 server, setelah transisi mulai melayani ~ 300.  Akibatnya, selama dua tahun kami memiliki cadangan kapasitas. <br><br>  Tapi Badoo berkembang.  Jumlah pengguna aktif terus meningkat.  Kami meningkatkan dan mengembangkan fungsionalitas kami, berkat pengguna yang menghabiskan lebih banyak waktu dalam aplikasi.  Dan ini, pada gilirannya, tercermin dalam jumlah permintaan, yang selama dua tahun terakhir meningkat 2–2,5 kali. <br><br>  Kami mendapati diri kami dalam situasi di mana peningkatan kinerja dua kali lipat diratakan oleh lebih dari dua kali lipat permintaan, dan kami mulai mendekati batas-batas cluster kami.  Dalam inti PHP, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">optimisasi</a> bermanfaat (JIT, preloading) sekali lagi diharapkan, tetapi mereka hanya direncanakan untuk PHP 7.4, dan versi ini akan dirilis tidak lebih awal dari setahun.  Oleh karena itu, trik transisi tidak dapat diulangi sekarang - Anda perlu mengoptimalkan kode aplikasi itu sendiri. <br><br>  Di bawah potongan, saya akan memberi tahu Anda bagaimana kami mendekati tugas-tugas seperti itu, alat apa yang kami gunakan, dan memberikan contoh optimisasi, ide dan pendekatan yang kami terapkan dan yang membantu kami di waktu kami. <br><a name="habracut"></a><br><h1>  Mengapa mengoptimalkan? </h1><br>  Cara termudah dan paling jelas untuk menyelesaikan masalah kinerja adalah menambahkan zat besi.  Jika kode Anda berjalan di server yang sama, maka menambahkan satu lagi akan menggandakan kinerja cluster Anda.  Mentransfer biaya-biaya ini ke waktu kerja pengembang, kami bertanya pada diri sendiri: apakah ia akan mendapatkan peningkatan dua kali lipat dalam produktivitas selama waktu ini karena optimisasi?  Mungkin ya, tapi mungkin tidak: itu tergantung pada seberapa optimal sistem sudah bekerja dan seberapa baik pengembangnya.  Di sisi lain, server yang dibeli akan tetap menjadi milik perusahaan, dan waktu yang dihabiskan tidak akan dikembalikan. <br><br>  Ternyata pada volume kecil solusi yang tepat akan sering berupa penambahan zat besi. <br><br>  Tetapi ambil situasi kita.  Sekarang, setelah keuntungan dari beralih ke PHP 7.0 diimbangi oleh pertumbuhan aktivitas dan jumlah pengguna, kami kembali memiliki 600 server yang melayani permintaan ke aplikasi PHP.  Untuk meningkatkan kapasitas sebanyak satu setengah kali, kita perlu menambah 300 server. <br><br>  Ambil untuk perhitungan biaya rata-rata server - $ 4.000.  300 * 4000 = $ 1.200.000 - biaya peningkatan kapasitas satu setengah kali. <br><br>  Artinya, dalam kondisi kami, kami dapat menginvestasikan sejumlah besar waktu kerja untuk mengoptimalkan sistem, dan itu masih akan lebih menguntungkan daripada membeli besi. <br><br><h1>  Perencanaan kapasitas </h1><br>  Sebelum melakukan sesuatu, penting untuk dipahami jika ada masalah.  Jika dia tidak ada di sana, maka ada baiknya mencoba memprediksi kapan dia muncul.  Proses ini disebut perencanaan kapasitas. <br><br>  Indikator nyata dari adanya masalah kinerja adalah waktu respons.  Memang, tidak masalah jika CPU (atau sumber daya lainnya) dimuat pada 6% atau 146%: jika klien menerima layanan dengan kualitas yang dibutuhkan dalam waktu yang memuaskan, maka semuanya bekerja dengan baik. <br><br>  Kerugian dari berfokus pada waktu respons adalah bahwa biasanya mulai meningkat hanya ketika masalah sudah muncul.  Jika belum, maka sulit untuk memprediksi penampilannya.  Selain itu, waktu respons mencerminkan hasil pengaruh semua faktor (layanan pengereman, jaringan, drive, dll.) Dan tidak memberikan pemahaman tentang penyebab masalah. <br><br>  Dalam kasus kami, CPU biasanya merupakan hambatan, jadi ketika merencanakan ukuran dan kinerja cluster, kami terutama memperhatikan metrik yang terkait dengan penggunaannya.  Kami mengumpulkan penggunaan CPU dari semua mesin kami dan membuat grafik dengan nilai rata-rata, median, persentil ke-75 dan ke-95: <br><br><img src="https://habrastorage.org/webt/pt/xs/dr/ptxsdr6jybv45cznqjykeqd11_g.png"><br>  <i>Pemanfaatan CPU dari mesin cluster dalam persen: rata-rata, median, persentil</i> <br><br>  Ada ratusan mesin di cluster kami yang telah ditambahkan di sana selama bertahun-tahun.  Mereka berbeda dalam konfigurasi dan kinerja (cluster tidak homogen).  Penyeimbang kami memperhitungkan ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> ) dan memuat mesin sesuai dengan kemampuan mereka.  Untuk mengendalikan proses ini, kami juga memiliki jadwal mesin bermuatan maksimum dan minimum. <br><br><img src="https://habrastorage.org/webt/nf/we/f7/nfwef7cixau-uxenwsglrnvfzho.png"><br>  <i>Mesin cluster paling banyak dan paling sedikit dimuat</i> <br><br>  Jika Anda melihat grafik ini (atau hanya pada output dari perintah atas) dan melihat beban CPU 50%, Anda mungkin berpikir bahwa kami masih memiliki margin untuk peningkatan beban dua kali lipat.  Tetapi sebenarnya ini biasanya tidak demikian.  Dan inilah alasannya. <br><br><h1>  Threading hiper </h1><br>  Bayangkan satu inti tanpa hipertensi.  Kami memuatnya dengan satu utas terikat-CPU.  Kita akan melihat 100% memuat di atas. <br><br>  Sekarang nyalakan hyperreading pada kernel ini dan muat dengan cara yang persis sama.  Di atas, kita akan melihat dua core logis, dan total beban akan menjadi 50% (biasanya pada satu 0%, dan yang lain - 100%). <br><br><img src="https://habrastorage.org/webt/gr/zi/hw/grzihwfkj986zatrfrsrgg4-ykk.png"><br>  <i>Pemanfaatan CPU: data teratas dan apa yang sebenarnya terjadi</i> <br><br>  Seolah prosesor hanya dimuat 50%.  Tetapi secara fisik tidak ada inti gratis tambahan yang muncul.  Hypertreading memungkinkan <i>dalam beberapa kasus</i> untuk mengeksekusi pada satu inti fisik lebih dari satu proses pada satu waktu.  Tapi ini jauh dari menggandakan kinerja dalam situasi khusus, meskipun pada grafik penggunaan CPU sepertinya setengah sumber daya: dari 50% menjadi 100%. <br><br>  Ini berarti bahwa setelah 50% penggunaan CPU ketika hipertensi diaktifkan, itu tidak akan tumbuh sama seperti sebelumnya. <br><br>  Saya menulis kode ini untuk menunjukkan (ini adalah semacam kasus sintetis, dalam kenyataannya hasilnya akan berbeda): <br><br><div class="spoiler">  <b class="spoiler_title">Kode skrip</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $concurrency = $_SERVER[<span class="hljs-string"><span class="hljs-string">'argv'</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] ?? <span class="hljs-number"><span class="hljs-number">1</span></span>; $hashes = <span class="hljs-number"><span class="hljs-number">100000000</span></span>; $chunkSize = intval($hashes / $concurrency); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $children = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $concurrency; $i++) {    $pid = pcntl_fork();    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> === $pid) {        $first = $i * $chunkSize;        $last = ($i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * $chunkSize - <span class="hljs-number"><span class="hljs-number">1</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($j = $first; $j &lt; $last; $j++) {            $dummy = md5($j);        }        printf(<span class="hljs-string"><span class="hljs-string">"[%d]: %d hashes in %0.4f sec\n"</span></span>, $i, $last - $first, microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) - $t1);        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        $children[$pid] = <span class="hljs-number"><span class="hljs-number">1</span></span>;    } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count($children) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {    $pid = pcntl_waitpid(<span class="hljs-number"><span class="hljs-number">-1</span></span>, $status);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($children[$pid]);    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-string"><span class="hljs-string">"Got a error pid=$pid"</span></span>);    } }</code> </pre> <br><br></div></div><br>  Saya memiliki dua inti fisik di laptop saya.  Jalankan kode ini dengan data input yang berbeda untuk mengukur kinerjanya dengan sejumlah proses C paralel yang berbeda. <br><br><div class="spoiler">  <b class="spoiler_title">Hasil pengukuran</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/n5/3z/ev/n53zevyyvda4w4u-2xkjryqlj9m.png"><br></div></div><br>  Kami memplot hasil peluncuran: <br><img src="https://habrastorage.org/webt/xg/iv/rn/xgivrnyyynb418fnr5muqfn0qba.png"><br>  <i>Kinerja skrip tergantung pada jumlah proses paralel</i> <br><br>  Apa yang dapat Anda perhatikan: <br><br><ul><li>  C = 1 dan C = 2 diperkirakan sama untuk HT = on dan HT = off, kinerja berlipat ganda ketika inti fisik ditambahkan; <br></li></ul><br><ul><li>  pada C = 3, keuntungan HT menjadi nyata: untuk HT = aktif, kami bisa mendapatkan kinerja tambahan, sedangkan untuk HT = mati dengan C = 3 dan seterusnya mulai menurun dengan dapat diprediksi secara perlahan; <br></li></ul><br><ul><li>  pada C = 4 kita melihat semua manfaat HT;  kami dapat memeras tambahan 30% produktivitas, tetapi dibandingkan dengan C = 2 saat ini, penggunaan CPU meningkat dari 50% menjadi 100%. <br></li></ul><br>  Total, melihat di atas 50% dari beban CPU, ketika menjalankan skrip ini, kami mendapatkan 8.065 Mhash / detik, dan pada 100% - 10.511 Mhash / detik.  Ini berarti bahwa sekitar 50% dari yang teratas, kita mendapatkan 8.065 / 10.511 ~ 77% dari kinerja sistem maksimum dan pada kenyataannya kita memiliki sekitar 100% yang tersisa di cadangan - 77% = 23%, dan bukan 50%, seperti yang terlihat. <br><br>  Fakta ini harus dipertimbangkan ketika merencanakan. <br><br><img src="https://habrastorage.org/webt/ru/6g/00/ru6g002t0ziv1pkppgqfjber80o.png"><br>  <i>Pemanfaatan CPU untuk demoscript: data teratas dan apa yang sebenarnya terjadi</i> <br><br><h1>  Ketidakkonsistenan lalu lintas </h1><br>  Selain hipertensi, perencanaan juga memperumit ketimpangan lalu lintas tergantung pada waktu, hari dalam seminggu, musim dan frekuensi lainnya.  Bagi kami, misalnya, puncaknya adalah Minggu malam. <br><br><img src="https://habrastorage.org/webt/eh/ks/58/ehks58pfn7sjva3c869i7cwj7fy.png"><br>  <i>Jumlah permintaan per detik, puncak Minggu malam</i> <br><br>  Tidak selalu jumlah permintaan berubah dengan cara yang jelas.  Sebagai contoh, pengguna entah bagaimana dapat berinteraksi dengan pengguna lain: aktivitas beberapa dapat menghasilkan push / email ke orang lain dan dengan demikian melibatkan mereka dalam proses.  Untuk ini ditambahkan kampanye promosi yang meningkatkan lalu lintas dan untuk itu Anda juga harus siap. <br><br>  Semua ini juga penting untuk dipertimbangkan ketika merencanakan: misalnya, untuk membangun tren pada hari-hari puncak dan mengingat kemungkinan non-linearitas pertumbuhan puncak. <br><br><h1>  Alat profil dan pengukuran </h1><br>  Misalkan kita mengetahui bahwa ada masalah kinerja, pahamilah bahwa ini bukan database / layanan / barang, namun kami memutuskan untuk mengoptimalkan kode.  Untuk melakukan ini, pertama-tama, kita memerlukan profiler atau beberapa alat untuk menemukan kemacetan dan kemudian melihat hasil optimasi kami. <br><br>  Sayangnya, untuk PHP saat ini tidak ada alat universal yang bagus. <br><br><h2>  perf </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perf</a> adalah alat pembuatan profil yang dibangun di dalam kernel Linux.  Ini adalah profiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengambilan sampel</a> yang diluncurkan oleh proses yang terpisah, oleh karena itu ia tidak secara langsung menambahkan overhead ke program yang sedang diprofilkan.  Secara tidak langsung menambahkan overhead secara seragam "diolesi", sehingga tidak merusak pengukuran. <br><br>  Untuk semua kelebihannya, perf hanya dapat bekerja dengan kode yang dikompilasi dan dengan JIT dan tidak dapat bekerja dengan kode yang menjalankan "di bawah mesin virtual".  Oleh karena itu, kode PHP itu sendiri tidak dapat diprofilkan di dalamnya, tetapi Anda dapat dengan jelas melihat bagaimana PHP bekerja di dalamnya, termasuk berbagai ekstensi PHP, dan berapa banyak sumber daya yang dihabiskan untuk itu. <br><br>  Misalnya, dengan perf, kami menemukan beberapa kemacetan, termasuk tempat kompresi, yang akan saya bahas di bawah. <br><br>  Contoh: <br><br> <code>perf record --call-graph dwarf,65528 -F 99 -p $(pgrep php-cgi | paste -sd "," -) -- sleep 20 <br> perf report</code> <br> <br>  (jika proses dan perf dieksekusi di bawah pengguna yang berbeda, maka perf perlu dijalankan dari bawah sudo). <br><br><img src="https://habrastorage.org/webt/k9/vu/k6/k9vuk6sf37xhshipgvx2byw3xps.png"><br>  <i>Contoh output laporan Perf untuk PHP-FPM</i> <br><br><h2>  Agregator XHProf dan XHProf </h2><br>  XHProf adalah ekstensi untuk PHP yang menempatkan penghitung waktu di sekitar semua panggilan ke fungsi / metode, dan juga berisi alat untuk memvisualisasikan hasil yang diperoleh.  Tidak seperti perf, ini memungkinkan Anda untuk beroperasi dengan ketentuan kode PHP (pada saat yang sama, apa yang terjadi dalam ekstensi tidak terlihat). <br><br>  Kerugiannya meliputi dua hal: <br><br><ul><li>  semua pengukuran dikumpulkan dalam kerangka permintaan tunggal, oleh karena itu mereka tidak memberikan informasi tentang gambar secara keseluruhan; <br></li><li>  overhead, meskipun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak sebesar</a> , misalnya, ketika menggunakan Xdebug, tetapi itu, dan dalam beberapa kasus hasilnya sangat terdistorsi (semakin sering suatu fungsi dipanggil dan semakin sederhana, semakin besar distorsi). <br></li></ul><br>  Berikut adalah contoh yang menggambarkan poin terakhir: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ child1(); child2(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; $i++) { parent1(); }</code> </pre> <br><img src="https://habrastorage.org/webt/iw/7m/y6/iw7my6irzq5xg7_soy7sfkqpj7m.png"><br>  <i>Output XHProf untuk demo: parent1 adalah urutan besarnya lebih besar dari jumlah child1 dan child2</i> <br><br>  Dapat dilihat bahwa parent1 () dieksekusi ~ 500 kali lebih lama dari child1 () + child2 (), meskipun dalam kenyataannya angka-angka ini harus kira-kira sama, seperti sama dengan main () dan parent1 (). <br><br>  Jika kelemahan terakhir sulit untuk diperjuangkan, maka untuk melawan yang pertama kami membuat add-on lebih dari XHProf, yang mengagregasi profil permintaan yang berbeda dan memvisualisasikan data agregat. <br><br>  Selain XHProf, ada banyak profiler lain yang kurang dikenal bekerja pada prinsip yang sama.  Mereka memiliki kelebihan dan kekurangan yang serupa. <br><br><h2>  Pinba </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pinba</a> memungkinkan Anda untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memantau kinerja dengan</a> skrip (tindakan) dan oleh pengatur waktu yang telah ditentukan.  Semua pengukuran dalam konteks skrip dibuat di luar kotak, untuk ini, tidak ada langkah tambahan yang diperlukan.  Untuk setiap skrip dan penghitung waktu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">getrusage dieksekusi</a> , jadi kami tahu persis berapa banyak waktu prosesor dihabiskan untuk sepotong kode tertentu (tidak seperti sampling profiler, di mana kali ini berubah menjadi jaringan, disk, dll.).  Pinba sangat bagus untuk menyimpan data historis dan mendapatkan gambar baik secara umum maupun dalam jenis pertanyaan tertentu. <br><br><img src="https://habrastorage.org/webt/od/x5/qr/odx5qryl0ufhceiuyjkytjhtm0c.png"><br>  <i>Rusage umum semua skrip yang diperoleh dari Pinba</i> <br><br>  Kerugiannya termasuk fakta bahwa pengatur waktu yang membuat profil bagian tertentu dari kode, dan bukan seluruh skrip, harus diatur terlebih dahulu dalam kode, serta keberadaan overhead yang (seperti dalam XHProf) dapat mengubah data. <br><br><h2>  phpspy </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">phpspy</a> adalah proyek yang relatif baru (komit pertama pada GitHub adalah setengah tahun yang lalu), yang terlihat menjanjikan, jadi kami sedang memonitornya. <br><br>  Dari sudut pandang pengguna, phpspy mirip dengan perf: proses paralel diluncurkan, yang secara berkala menyalin bagian memori dari proses PHP, mem-parsing mereka dan menerima jejak stack dan data lainnya dari sana.  Ini dilakukan dengan cara yang agak spesifik.  Untuk meminimalkan overhead, phpspy tidak menghentikan proses PHP dan menyalin memori secara langsung saat sedang berjalan.  Ini mengarah pada fakta bahwa profiler bisa mendapatkan keadaan yang tidak konsisten, jejak tumpukan dapat dipecahkan.  Tetapi phpspy dapat mendeteksi ini dan membuang data tersebut. <br><br>  Di masa depan, dengan menggunakan alat ini akan dimungkinkan untuk mengumpulkan data pada gambar secara keseluruhan dan profil dari jenis pertanyaan tertentu. <br><br><h2>  Tabel perbandingan </h2><br>  Untuk menyusun perbedaan antara alat, mari kita buat tabel pivot: <br><br><img src="https://habrastorage.org/webt/bg/1a/bt/bg1abtxk-f8i5q83qm5teok3lbs.png"><br>  <i>Perbandingan fitur utama profiler</i> <br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grafik nyala</a></i> <br><br><h1>  Optimalisasi dan pendekatan </h1><br>  Dengan alat ini, kami terus memantau kinerja dan penggunaan sumber daya kami.  Ketika mereka digunakan secara tidak adil atau kita mendekati ambang (untuk CPU kita secara empiris memilih nilai 55% untuk memiliki margin waktu jika terjadi pertumbuhan), seperti yang saya tulis di atas, salah satu solusi untuk masalah ini adalah optimasi. <br><br>  Nah, jika optimasi sudah dilakukan oleh orang lain, seperti halnya dengan PHP 7.0, ketika versi ini ternyata jauh lebih produktif daripada yang sebelumnya.  Kami biasanya mencoba menggunakan teknologi dan alat modern, termasuk pembaruan tepat waktu untuk versi terbaru PHP.  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tolok ukur</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publik</a> , PHP 7.2 lebih cepat 5-12% dari PHP 7.1.  Tetapi transisi ini, sayangnya, memberi kami jauh lebih sedikit. <br><br>  Selama ini kami telah menerapkan sejumlah besar optimisasi.  Sayangnya, kebanyakan dari mereka sangat terkait dengan logika bisnis kami.  Saya akan berbicara tentang hal-hal yang mungkin relevan tidak hanya untuk kita, atau gagasan dan pendekatan yang dapat digunakan di luar kode kita. <br><br><h2>  Kompresi Zlib =&gt; zstd </h2><br>  Kami menggunakan kompresi untuk tombol memkey besar.  Ini memungkinkan kami untuk menghabiskan memori tiga hingga empat kali lebih sedikit untuk penyimpanan karena biaya CPU tambahan untuk kompresi / dekompresi.  Kami menggunakan zlib untuk ini (ekstensi kami untuk bekerja dengan memek berbeda dari yang datang dengan PHP, tetapi yang resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan</a> zlib). <br><br>  Pada dasarnya, produksi adalah seperti ini: <br><br> <code>+    4.03%     0.22% php-cgi  libz.so.1.2.11      [.] inflate <br> +    3.38%     0.00% php-cgi  libz.so.1.2.11      [.] deflate</code> <br> <br>  7-8% dari waktu dihabiskan untuk kompresi / dekompresi. <br><br>  Kami memutuskan untuk menguji berbagai level dan algoritma kompresi.  Ternyata zstd berjalan pada data kami hampir sepuluh kali lebih cepat, kalah di tempat ~ 1,1 kali.  Perubahan algoritma yang cukup sederhana menyelamatkan kami ~ 7.5% CPU (ini, saya ingat, pada volume kami setara dengan ~ 45 server). <br><br>  Penting untuk dipahami bahwa rasio kinerja berbagai algoritma kompresi dapat sangat bervariasi tergantung pada data input.  Ada berbagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbandingan</a> , tetapi yang paling akurat ini hanya dapat diperkirakan dengan menggunakan contoh dunia nyata. <br><br><h2>  IS_ARRAY_IMMUTABLE sebagai repositori data yang jarang dimodifikasi </h2><br>  Ketika bekerja dengan tugas nyata, Anda harus berurusan dengan data yang sering Anda butuhkan dan pada saat yang sama jarang berubah dan memiliki ukuran terbatas.  Kami memiliki banyak data yang serupa, contoh yang baik adalah konfigurasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes split</a> .  Kami memeriksa apakah pengguna berada dalam kondisi pengujian tertentu, dan tergantung pada ini, kami menunjukkan kepadanya fungsionalitas eksperimental atau normal (ini terjadi hampir selama setiap permintaan).  Dalam proyek lain, konfigurasi dan berbagai direktori dapat menjadi contoh: negara, kota, bahasa, kategori, merek, dll. <br><br>  Karena data tersebut sering diminta, tanda terima mereka dapat membuat beban tambahan yang nyata baik pada aplikasi itu sendiri maupun pada layanan di mana data ini disimpan.  Masalah terakhir dapat dipecahkan, misalnya, menggunakan APCu, yang menggunakan memori mesin yang sama yang menjalankan PHP-FPM sebagai penyimpanan.  Namun demikian: <br><br><ul><li>  akan ada biaya serialisasi / deserialisasi; <br></li><li>  Anda perlu entah bagaimana membatalkan data saat mengubah; <br></li><li>  Ada beberapa overhead dibandingkan dengan mengakses hanya variabel di PHP. <br></li></ul><br>  PHP 7.0 memperkenalkan optimasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IS_ARRAY_IMMUTABLE</a> .  Jika Anda mendeklarasikan sebuah array, yang semua elemennya diketahui pada saat kompilasi, maka elemen itu akan diproses dan ditempatkan ke dalam memori OPCache satu kali, pekerja PHP-FPM akan merujuk ke memori bersama ini tanpa menghabiskan waktu mereka sebelum mencoba mengubah.  Ini juga mengikuti bahwa memasukkan array seperti itu akan memakan waktu yang konstan terlepas dari ukuran (biasanya ~ 1 mikrodetik). <br><br>  Sebagai perbandingan: contoh waktu untuk mendapatkan array 10.000 elemen melalui include dan apcu_fetch: <br><br><pre> <code class="php hljs">$t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'test-incl-1.php'</span></span>; $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"include (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); $t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = apcu_fetch(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"apcu_fetch (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//include (10000): 1 microsec //apcu_fetch (10000): 792 microsec</span></span></code> </pre><br>  Memeriksa apakah optimasi ini telah diterapkan bisa sangat sederhana jika Anda melihat opcodes yang dihasilkan: <br><br><pre> <code class="php hljs">$ cat immutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val1'</span></span>, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ cat mutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; \SomeClass::CONST_1, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ php -d opcache.enable=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> immutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">1</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">0</span></span>) ; (after optimizer) ; /home/ubuntu/immutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(...) $ php -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> mutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">5</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">2</span></span>) ; (after optimizer) ; /home/ubuntu/mutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T1 = FETCH_CLASS_CONSTANT string(<span class="hljs-string"><span class="hljs-string">"SomeClass"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"CONST_1"</span></span>) L1 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T0 = INIT_ARRAY <span class="hljs-number"><span class="hljs-number">3</span></span> T1 string(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>) L2 (<span class="hljs-number"><span class="hljs-number">5</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val2"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key2"</span></span>) L3 (<span class="hljs-number"><span class="hljs-number">6</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val3"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key3"</span></span>) L4 (<span class="hljs-number"><span class="hljs-number">6</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> T0</code> </pre><br>  Dalam kasus pertama, jelas bahwa hanya ada satu opcode dalam file - kembalinya array yang sudah jadi.  Dalam kasus kedua, pembentukan elemen-demi-elemennya terjadi setiap kali file ini dieksekusi. <br><br>  Dengan demikian, dimungkinkan untuk menghasilkan struktur dalam bentuk yang tidak memerlukan transformasi lebih lanjut dalam runtime.  Misalnya, alih-alih membongkar nama kelas dengan tanda “_” dan “\” setiap kali untuk autoload, Anda dapat membuat sebelumnya peta korespondensi “Class =&gt; Path”.  Dalam hal ini, fungsi konversi akan direduksi menjadi panggilan tabel hash tunggal.  Komposer melakukan optimasi semacam ini jika Anda mengaktifkan <a href="">opsi optim-autoloader</a> . <br><br>  Untuk pembatalan data seperti itu, Anda tidak perlu melakukan apa pun secara khusus - PHP sendiri akan mengkompilasi ulang file ketika berubah, sama seperti dengan penyebaran kode normal.  Satu-satunya kelemahan yang tidak boleh Anda lupakan: jika file tersebut sangat besar, maka permintaan pertama setelah mengubahnya akan menyebabkan kompilasi ulang, yang bisa memakan waktu nyata. <br><br><h2>  Kinerja meliputi / mengharuskan </h2><br>  Berbeda dengan contoh array statis, melampirkan file dengan deklarasi kelas dan fungsi tidak begitu cepat.  Meskipun ada OPCache, mesin PHP harus menyalinnya ke memori proses, menghubungkan dependensi secara rekursif, yang pada akhirnya dapat mengambil ratusan mikrodetik atau bahkan milidetik per file. <br><br>  Jika Anda membuat proyek kosong baru di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Symfony 4.1</a> dan menempatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">get_included_files () sebagai</a> baris pertama dalam tindakan, Anda dapat melihat bahwa 310 file sudah terhubung.  Dalam proyek nyata, jumlah ini dapat mencapai ribuan per permintaan.  Perlu memperhatikan hal-hal berikut. <br><br>  <b>Kurangnya fitur lading otomatis</b> <br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi Autoloading RFC</a> , tetapi tidak ada pengembangan yang terlihat selama beberapa tahun.  Oleh karena itu, jika ketergantungan dalam Komposer mendefinisikan fungsi di luar kelas dan fungsi-fungsi ini harus dapat diakses oleh pengguna, maka ini dilakukan dengan <a href="">kewajiban menghubungkan</a> file dengan fungsi-fungsi ini ke setiap inisialisasi autoloader. <br><br>  Misalnya, menghapus salah satu dependensi dari composer.json, yang menyatakan banyak fungsi dan mudah diganti dengan seratus baris kode, kami memenangkan beberapa persen dari CPU. <br><br>  <b>Loader otomatis lebih sering dipanggil daripada yang terlihat.</b> <br><br>  Untuk mendemonstrasikan ide tersebut, buat file seperti itu dengan kelas: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">D</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC1 = \E::E1;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC2 = \F::F1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as3 = \G::G1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as4 = \H::H1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a5 = \I::I1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a6 = \J::J1;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\K $k = null)</span></span></span><span class="hljs-function"> </span></span>{}   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\L $l = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\M $m = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\N $n = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\P $p = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br>  <b>Daftarkan pemuat otomatis:</b> <br><br><pre> <code class="php hljs">spl_autoload_register(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Including $name...\n"</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">"$name.php"</span></span>; });</code> </pre> <br>  <b>Dan kami akan membuat beberapa kasus penggunaan untuk kelas ini:</b> <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'A.php'</span></span> Including B... Including D... Including C... \A::AC1 Including A... Including B... Including D... Including C... Including E... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A() Including A... Including B... Including D... Including C... Including E... Including F... Including G... Including H... Including I... Including J...</code> </pre><br>  Anda mungkin memperhatikan bahwa ketika kita entah bagaimana hanya menghubungkan kelas, tetapi tidak membuat turunannya, induk, antarmuka dan sifat akan terhubung.  Ini dilakukan secara rekursif untuk semua file yang terhubung sebagai resolusi. <br><br>  Saat membuat contoh, resolusi semua konstanta dan bidang ditambahkan ke ini, yang mengarah ke koneksi semua file yang diperlukan untuk ini, yang, pada gilirannya, juga akan menyebabkan koneksi berulang sifat, orang tua dan antarmuka kelas yang baru terhubung. <br><br><img src="https://habrastorage.org/webt/8a/qq/2t/8aqq2tf_8j-mixi8p_ydoypo-yo.png"><br>  <i>Menghubungkan kelas terkait untuk proses pembuatan instance dan kasus lainnya</i> <br><br>  Tidak ada solusi universal untuk masalah ini, Anda hanya perlu mengingatnya dan memantau koneksi antar kelas: satu baris dapat menarik koneksi ratusan file. <br><br>  <b>Pengaturan OPCache</b> <br><br>  Jika Anda menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyebaran atom dengan mengubah symlink yang</a> diusulkan oleh Rasmus Lerdorf, pencipta PHP, maka untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyelesaikan</a> masalah "menempelkan" symlink pada versi lama Anda harus menyertakan opcache.revalidate_path, seperti yang disarankan, misalnya, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini tentang OPCache yang diterjemahkan oleh Mail .Ru Group. <br><br>  Masalahnya adalah bahwa opsi ini secara signifikan (rata-rata, satu setengah hingga dua kali) meningkatkan waktu untuk memasukkan setiap file.  Secara total, ini dapat mengkonsumsi sejumlah besar sumber daya (dalam kasus kami, menonaktifkan opsi ini memberi keuntungan 7-9%). <br><br>  Untuk menonaktifkannya, Anda perlu melakukan dua hal: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat</a> server web menyelesaikan symlink; <br></li><li>  berhenti menghubungkan file di dalam skrip PHP di sepanjang jalur yang berisi symlinks, atau paksa mereka melalui readlink () atau realpath (). <br></li></ul><br>  Jika semua file terhubung dengan autoloader Composer, maka item kedua akan dieksekusi secara otomatis setelah yang pertama selesai: omposer menggunakan konstanta __DIR__, yang akan diselesaikan dengan benar. <br><br>  OPCache memiliki beberapa opsi lagi yang dapat memberikan peningkatan kinerja dengan imbalan fleksibilitas.  Anda dapat membaca lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> yang saya sebutkan di atas. <br><br>  Terlepas dari semua optimasi ini, termasuk masih tidak akan gratis.  Untuk mengatasi ini, PHP 7.4 berencana untuk menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preload</a> . <br><br><h2>  Kunci APCu </h2><br>  Meskipun kita tidak berbicara tentang basis data dan layanan di sini, berbagai jenis kunci juga dapat terjadi dalam kode, yang meningkatkan waktu eksekusi skrip. <br><br>  Seiring meningkatnya permintaan, kami melihat adanya penurunan tajam dalam respons di masa puncaknya.  Setelah menemukan alasannya, ternyata meskipun APCu adalah cara tercepat untuk mendapatkan data (dibandingkan dengan Memcache, Redis dan penyimpanan eksternal lainnya), APCu juga dapat bekerja secara lambat dengan seringnya menimpa kunci yang sama. <br><br><img src="https://habrastorage.org/webt/hs/05/gc/hs05gcwvqozrqews1ewwtsskdyo.png"><br>  <i>Jumlah permintaan per detik dan runtime: puncak pada 16 dan 17 Oktober</i> <br><br>  Saat menggunakan APCu sebagai cache, masalah ini tidak begitu relevan, karena caching biasanya melibatkan penulisan yang jarang dan sering membaca.  Tetapi beberapa tugas dan algoritma (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Circuit Breaker</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi dalam PHP</a> )) juga sering melibatkan perekaman, yang menyebabkan kunci. <br><br>  Tidak ada solusi universal untuk masalah ini, tetapi dalam kasus Circuit Breaker dapat diselesaikan, misalnya, dengan meletakkannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layanan terpisah yang</a> diinstal pada mesin dengan PHP. <br><br><h2>  Pemrosesan batch </h2><br>  Bahkan jika Anda tidak memasukkan akun, biasanya semua bagian penting dari waktu eksekusi query dihabiskan untuk inisialisasi: kerangka kerja (misalnya, membangun wadah DI dan menginisialisasi semua dependensinya, routing, mengeksekusi semua pendengar), meningkatkan sesi, Pengguna, dan sebagainya selanjutnya. <br><br>  Jika backend Anda adalah API internal untuk sesuatu, maka untuk beberapa permintaan tertentu pada klien dapat digabungkan dan dikirim sebagai satu permintaan.  Dalam hal ini, inisialisasi akan dilakukan sekali untuk beberapa permintaan. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika ini tidak memungkinkan pada klien, cobalah mencari permintaan yang dapat diproses secara tidak sinkron. </font><font style="vertical-align: inherit;">Mereka dapat diterima dengan beberapa skrip sederhana yang tidak menginisialisasi apa pun dan hanya menempatkan mereka dalam antrian. </font><font style="vertical-align: inherit;">Dan sudah bisa diproses dalam batch.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemanfaatan Sumber Daya Cerdas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Badoo, kami memiliki kelompok berbeda yang disesuaikan dengan kebutuhan yang berbeda. </font><font style="vertical-align: inherit;">Selain cluster dengan PHP-FPM, di mana ratusan server dimuat pada CPU, dan disk tidak digunakan, kami memiliki satu cluster basis data khusus dari beberapa ratus mesin, yang berbanding terbalik dengan yang pertama: dengan disk besar dan banyak dimuat di IO, yang CPU-nya idle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi yang jelas di sini adalah menjalankan PHP-FPM pada cluster kedua - pada kenyataannya, kami mendapat beberapa ratus mesin tambahan di cluster PHP secara gratis.</font></font><br><br>         (CPU, IO),    . , ,       ,  ,    -     ,        .        ,     .   ,  ,      . <br><br><h1>  Kesimpulan </h1><br>        .                    PHP     . <br><br>  : <br><br><ul><li>       ; <br></li><li>     ; <br></li><li>  -  ,  :  ,    ; <br></li><li>   :       (, ,  ); <br></li><li>    :     ; <br></li><li>   , OPCache    PHP,  , ,   ; <br></li><li>    :       (, ,   PHP 7.2   ,   ); <br></li><li>    : ,        . <br></li></ul><br>       ? <br><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430722/">https://habr.com/ru/post/id430722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430710/index.html">Apa yang harus dilakukan jika Black Friday besok dan server Anda belum siap</a></li>
<li><a href="../id430712/index.html">NeurIPS: Cara Menaklukkan Konferensi ML Terbaik</a></li>
<li><a href="../id430714/index.html">VMware membeli Heptio - apa artinya untuk Kubernetes</a></li>
<li><a href="../id430718/index.html">Untuk objek apa layak menggunakan pengawasan video cloud?</a></li>
<li><a href="../id430720/index.html">Intel RealSense D435i: pembaruan kecil dan penyimpangan sejarah singkat</a></li>
<li><a href="../id430724/index.html">DEFCON 21. Konferensi DNS dapat berbahaya bagi kesehatan Anda. Bagian 1</a></li>
<li><a href="../id430728/index.html">Ajari saya untuk memberikan umpan balik</a></li>
<li><a href="../id430730/index.html">Apa yang dilakukan R&D ABBYY: NLP Advanced Research Group</a></li>
<li><a href="../id430732/index.html">Untuk pertanyaan pembagian dan TI</a></li>
<li><a href="../id430734/index.html">Pembaruan pintar vs kontrak pintar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>