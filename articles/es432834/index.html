<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ò #‚É£ ‚úíÔ∏è Enlace interno y externo en C ++ ‚ùóÔ∏è üë®üèº‚ÄçüöÄ ü§ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen dia a todos! 

 Le presentamos la traducci√≥n de un art√≠culo interesante que ha sido preparado para usted como parte del curso "Desarrollador C ++...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enlace interno y externo en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/432834/">  Buen dia a todos! <br><br>  Le presentamos la traducci√≥n de un art√≠culo interesante que ha sido preparado para usted como parte del curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Desarrollador C ++"</a> .  Esperamos que sea √∫til e interesante para usted, as√≠ como para nuestros oyentes. <br><br>  Vamos <br><br>  ¬øAlguna vez ha encontrado los t√©rminos comunicaci√≥n interna y externa?  ¬øQuiere saber para qu√© se usa la palabra clave externa o c√≥mo la declaraci√≥n de algo est√°tico afecta el alcance global?  Entonces este art√≠culo es para ti. <br><br>  <b>En pocas palabras</b> <br><br>  La unidad de traducci√≥n (.c / .cpp) y todos sus archivos de encabezado (.h / .hpp) est√°n incluidos en la unidad de traducci√≥n.  Si un objeto o funci√≥n tiene un enlace interno dentro de una unidad de traducci√≥n, este s√≠mbolo es visible para el enlazador solo dentro de esta unidad de traducci√≥n.  Si el objeto o funci√≥n tiene un enlace externo, el enlazador podr√° verlo cuando procese otras unidades de traducci√≥n.  El uso de la palabra clave est√°tica en el espacio de nombres global proporciona el car√°cter de enlace interno.  La palabra clave externa da enlace externo. <br>  El compilador predeterminado proporciona a los personajes los siguientes enlaces: <br><br><ul><li>  Variables globales no constantes: enlace externo; </li><li>  Const variables globales - enlace interno; </li><li>  Funciones - Enlace externo. </li></ul><br><img src="https://habrastorage.org/webt/m5/bl/8d/m5bl8d7e6yb-7qlgsoqf8duzuku.png"><br><a name="habracut"></a><br>  <b>Los fundamentos</b> <br><br>  Primero, hablemos de dos conceptos simples necesarios para discutir el enlace. <br><br><ul><li>  La diferencia entre una declaraci√≥n y una definici√≥n; </li><li>  Unidades de difusi√≥n. </li></ul><br>  Tambi√©n preste atenci√≥n a los nombres: utilizaremos el concepto de "s√≠mbolo" cuando se trata de cualquier "entidad de c√≥digo" con la que trabaje el enlazador, por ejemplo, con una variable o funci√≥n (o con clases / estructuras, pero no nos centraremos en ellas). <br><br>  <b>Anuncio VS.</b>  <b>Definici√≥n</b> <br><br>  Discutimos brevemente la diferencia entre una declaraci√≥n y una definici√≥n de s√≠mbolo: un anuncio (o declaraci√≥n) le dice al compilador sobre la existencia de un s√≠mbolo espec√≠fico y permite el acceso a este s√≠mbolo en casos que no requieren una direcci√≥n de memoria exacta o almacenamiento de s√≠mbolos.  La definici√≥n le dice al compilador qu√© est√° contenido en el cuerpo de la funci√≥n o cu√°nta memoria necesita asignar la variable. <br><br>  En algunas situaciones, una declaraci√≥n no es suficiente para el compilador, por ejemplo, cuando un elemento de datos de clase tiene una referencia o un tipo de valor (es decir, no una referencia y no un puntero).  Al mismo tiempo, se permite un puntero a un tipo declarado (pero indefinido), ya que necesita una cantidad fija de memoria (por ejemplo, 8 bytes en sistemas de 64 bits), independientemente del tipo al que apunta.  Para obtener el valor de este puntero, se requiere una definici√≥n.  Adem√°s, para declarar una funci√≥n, debe declarar (pero no definir) todos los par√°metros (ya sea que se tomen por valor, referencia o puntero) y el tipo de retorno.  Determinar el tipo de valor de retorno y los par√°metros solo es necesario para definir una funci√≥n. <br><br>  <b>Las funciones</b> <br><br>  La diferencia entre definir y declarar una funci√≥n es muy obvia. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  int f() { return 42; } // </span></span></code> </pre> <br>  <b>Variables</b> <br><br>  Con las variables, es un poco diferente.  La declaraci√≥n y la definici√≥n generalmente no se comparten.  Lo principal es: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x;</code> </pre> <br>  No solo declara <code>x</code> , sino que tambi√©n lo define.  Esto se debe a la llamada al constructor predeterminado int.  (En C ++, a diferencia de Java, el constructor de tipos simples (como int) no inicializa el valor a 0. De forma predeterminada. En el ejemplo anterior, x ser√° igual a cualquier basura que se encuentre en la direcci√≥n de memoria asignada por el compilador). <br><br>  Pero puede separar expl√≠citamente la declaraci√≥n de variable y su definici√≥n utilizando la palabra clave <code>extern</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//  int x = 42; // </span></span></code> </pre> <br>  Sin embargo, al inicializar y agregar <code>extern</code> a la declaraci√≥n, la expresi√≥n se convierte en una definici√≥n y la palabra clave <code>extern</code> vuelve in√∫til. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,   int x = 5;</span></span></code> </pre> <br>  <b>Vista previa del anuncio</b> <br><br>  En C ++, existe el concepto de predeclarar un personaje.  Esto significa que declaramos el tipo y el nombre del s√≠mbolo para su uso en situaciones que no requieren su definici√≥n.  Por lo tanto, no necesitamos incluir la definici√≥n completa de un personaje (generalmente un archivo de encabezado) sin una necesidad obvia.  Por lo tanto, reducimos la dependencia del archivo que contiene la definici√≥n.  La principal ventaja es que al cambiar un archivo con una definici√≥n, el archivo donde declaramos preliminarmente este s√≠mbolo no requiere una nueva compilaci√≥n (lo que significa que todos los dem√°s archivos lo incluyen). <br><br>  <i>Ejemplo</i> <br><br>  Supongamos que tenemos una declaraci√≥n de funci√≥n (llamada prototipo) para f que toma un objeto de tipo <code>Class</code> por valor: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp void f(Class object);</span></span></code> </pre> <br>  Inmediatamente incluya la definici√≥n de <code>Class</code> - ingenua.  Pero como acabamos de declarar <code>f</code> , es suficiente para darle al compilador una declaraci√≥n de <code>Class</code> .  Por lo tanto, el compilador puede reconocer la funci√≥n por su prototipo, y podemos deshacernos de la dependencia de file.hpp en el archivo que contiene la definici√≥n de <code>Class</code> , digamos class.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp class Class; void f(Class object);</span></span></code> </pre> <br>  Digamos que file.hpp est√° contenido en otros 100 archivos.  Y digamos que cambiamos la definici√≥n de Clase en class.hpp.  Si agrega class.hpp a file.hpp, file.hpp y los 100 archivos que lo contengan deber√°n volver a compilarse.  Gracias a la declaraci√≥n preliminar de Clase, los √∫nicos archivos que requieren recompilaci√≥n ser√°n class.hpp y file.hpp (suponiendo que f est√© definido all√≠). <br><br>  <b>Frecuencia de uso</b> <br><br>  Una diferencia importante entre una declaraci√≥n y una definici√≥n es que un s√≠mbolo se puede declarar muchas veces, pero solo se puede definir una vez.  Por lo tanto, puede declarar previamente una funci√≥n o clase tantas veces como desee, pero solo puede haber una definici√≥n.  Esto se llama la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regla de una definici√≥n</a> .  En C ++, lo siguiente funciona: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre> <br>  Y esto no funciona: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>; }</code> </pre><br>  <b>Unidades de difusi√≥n</b> <br><br>  Los programadores suelen trabajar con archivos de encabezado y archivos de implementaci√≥n.  Pero no compiladores: trabajan con unidades de traducci√≥n (unidades de traducci√≥n, para abreviar, TU), que a veces se denominan unidades de compilaci√≥n.  La definici√≥n de tal unidad es bastante simple: cualquier archivo transferido al compilador despu√©s de su procesamiento preliminar.  Para ser precisos, este es un archivo resultante del trabajo de un preprocesador de macro de extensi√≥n que incluye c√≥digo fuente, que depende de las expresiones <code>#ifdef</code> y <code>#ifndef</code> , y copia y pega todos los archivos <code>#include</code> . <br><br>  Los siguientes archivos est√°n disponibles: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HEADER_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VALUE 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> VALUE struct Foo { private: int ryan; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> int strlen(const char* string); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* HEADER_HPP */</span></span></span></span></code> </pre> <br>  program.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> int strlen(const char* string) { int length = 0; while(string[length]) ++length; return length + VALUE; }</span></span></code> </pre> <br>  El preprocesador producir√° la siguiente unidad de traducci√≥n, que luego se pasa al compilador: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[length]) ++length; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length + <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre><br>  <b>Comunicaciones</b> <br><br>  Despu√©s de discutir los conceptos b√°sicos, puede comenzar la relaci√≥n.  En general, la comunicaci√≥n es la visibilidad de los caracteres para el enlazador al procesar archivos.  La comunicaci√≥n puede ser externa o interna. <br><br>  <b>Comunicaci√≥n externa</b> <br><br>  Cuando un s√≠mbolo (variable o funci√≥n) tiene una conexi√≥n externa, se hace visible para los vinculadores de otros archivos, es decir, "globalmente" visible, accesible para todas las unidades de traducci√≥n.  Esto significa que debe definir dicho s√≠mbolo en un lugar espec√≠fico de una unidad de traducci√≥n, generalmente en el archivo de implementaci√≥n (.c / .cpp), de modo que solo tenga una definici√≥n visible.  Si intenta definir simult√°neamente el s√≠mbolo al mismo tiempo que se declara el s√≠mbolo, o si coloca la definici√≥n en un archivo para la declaraci√≥n, corre el riesgo de enojar al vinculador.  Intentar agregar un archivo a m√°s de un archivo de implementaci√≥n lleva a agregar una definici√≥n a m√°s de una unidad de traducci√≥n; su enlazador llorar√°. <br><br>  La palabra clave externa en C y C ++ (expl√≠citamente) declara que un personaje tiene una conexi√≥n externa. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; argument)</span></span></span></span>;</code> </pre><br>  Ambos personajes tienen una conexi√≥n externa.  Se se√±al√≥ anteriormente que las variables globales const tienen enlace interno por defecto, las variables globales sin const tienen enlace externo.  Esto significa que int x;  - igual que extern int x; ¬øverdad?  En realidad no  int x;  en realidad an√°logo a extern int x {};  (usando la sintaxis de inicializaci√≥n universal / de par√©ntesis para evitar el an√°lisis m√°s desagradable (el an√°lisis m√°s irritante)), ya que int x;  no solo declara, sino que tambi√©n define x.  Por lo tanto, no agregue extern a int x;  globalmente es tan malo como definir una variable al declararla externa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//   ,   extern int x{}; //      . extern int x; //      ,  </span></span></code> </pre> <br>  <i>Mal ejemplo</i> <br><br>  Declaremos una funci√≥n <code>f</code> con enlace externo en file.hpp y definamos all√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP extern int f(int x); /* ... */ int f(int) { return x + 1; } /* ... */ #endif /* FILE_HPP */</span></span></code> </pre> <br>  Tenga en cuenta que no necesita agregar extern aqu√≠, ya que todas las funciones son expl√≠citamente externas.  La separaci√≥n de la declaraci√≥n y la definici√≥n tampoco es necesaria.  As√≠ que vamos a reescribirlo as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// file.hpp #ifndef FILE_HPP #define FILE_HPP int f(int) { return x + 1; } #endif /* FILE_HPP */</span></span></code> </pre> <br>  Dicho c√≥digo podr√≠a escribirse antes de leer este art√≠culo, o despu√©s de leerlo bajo la influencia del alcohol o sustancias pesadas (por ejemplo, rollos de canela). <br><br>  Veamos por qu√© esto no vale la pena.  Ahora tenemos dos archivos de implementaci√≥n: a.cpp y b.cpp, ambos incluidos en file.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// a.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// b.cpp #include "file.hpp" /* ... */</span></span></code> </pre> <br>  Ahora deje que el compilador funcione y genere dos unidades de traducci√≥n para los dos archivos de implementaci√≥n anteriores (recuerde que <code>#include</code> literalmente significa copiar / pegar): <br><br><pre> <code class="plaintext hljs">// TU A, from a.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br><pre> <code class="plaintext hljs">// TU B, from b.cpp int f(int) { return x + 1; } /* ... */</code> </pre> <br>  En este punto, el vinculador interviene (la uni√≥n se produce despu√©s de la compilaci√≥n).  El enlazador toma el car√°cter <code>f</code> y busca una definici√≥n.  ¬°Hoy tiene suerte, encuentra hasta dos!  Uno en la unidad de traducci√≥n A, el otro en B. El enlazador se congela de felicidad y te dice algo como esto: <br><br><pre> <code class="cpp hljs">duplicate symbol __Z1fv in: /path/to/ao /path/to/bo</code> </pre> <br>  El enlazador encuentra dos definiciones para un car√°cter <code>f</code> .  Como <code>f</code> tiene un enlace externo, es visible para el enlazador cuando procesa tanto A como B. Obviamente, esto viola la Regla de una definici√≥n y causa un error.  M√°s precisamente, esto causa un error de s√≠mbolo duplicado, que recibir√° no menos que un error de s√≠mbolo indefinido que ocurre cuando declara un s√≠mbolo, pero se olvid√≥ de definirlo. <br><br>  <b>Uso</b> <br><br>  Un ejemplo est√°ndar de declarar variables externas son las variables globales.  Supongamos que est√° trabajando en un pastel de cocci√≥n autom√°tica.  Seguramente hay variables globales asociadas con el pastel que deber√≠an estar disponibles en diferentes partes de su programa.  Digamos la frecuencia de reloj de un circuito comestible dentro de su pastel.  Este valor se requiere naturalmente en diferentes partes para el funcionamiento sincr√≥nico de todos los productos electr√≥nicos de chocolate.  La forma C (malvada) de declarar dicha variable global es como una macro: <br><br><pre> <code class="plaintext hljs">#define CLK 1000000</code> </pre><br>  Un programador de C ++ que est√° disgustado con las macros escribir√° mejor el c√≥digo real.  Por ejemplo, esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// global.hpp namespace Global { extern unsigned int clock_rate; } // global.cpp namespace Global { unsigned int clock_rate = 1000000; }</span></span></code> </pre> <br>  (Un programador moderno de C ++ querr√° usar literales de separaci√≥n: unsigned int clock_rate = 1'000'000;) <br><br>  <b>Intercomunicador</b> <br><br>  Si el s√≠mbolo tiene una conexi√≥n interna, ser√° visible solo dentro de la unidad de traducci√≥n actual.  No confunda visibilidad con derechos de acceso, como privado.  La visibilidad significa que el enlazador podr√° usar este s√≠mbolo solo cuando procese la unidad de traducci√≥n en la que se declar√≥ el s√≠mbolo, y no m√°s tarde (como en el caso de s√≠mbolos con comunicaci√≥n externa).  En la pr√°ctica, esto significa que al declarar un s√≠mbolo con un enlace interno en el archivo de encabezado, cada unidad de transmisi√≥n que incluye este archivo recibir√° una copia √∫nica de este s√≠mbolo.  Como si hubiera predeterminado cada uno de esos s√≠mbolos en cada unidad de traducci√≥n.  Para los objetos, esto significa que el compilador literalmente asignar√° una copia completamente nueva y √∫nica para cada unidad de traducci√≥n, lo que, obviamente, puede generar altos costos de memoria. <br><br>  Para declarar un s√≠mbolo interconectado, la palabra clave est√°tica existe en C y C ++.  Este uso es diferente del uso de static en clases y funciones (o, en general, en cualquier bloque). <br><br>  <i>Ejemplo</i> <br><br>  Aqu√≠ hay un ejemplo: <br><br>  header.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br>  file1.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file2.hpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  file1.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function1() { variable = 10; }</span></span></code> </pre> <br><br>  file2.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> void function2() { variable = 123; }</span></span></code> </pre> <br>  main.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"header.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file1.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"file2.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; auto main() -&gt; int { function1(); function2(); std::cout &lt;&lt; variable &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br>  Cada unidad de traducci√≥n, incluido header.hpp, obtiene una copia √∫nica de la variable, debido a su conexi√≥n interna.  Hay tres unidades de traducci√≥n: <br><br><ol><li>  file1.cpp </li><li>  file2.cpp </li><li>  main.cpp </li></ol><br>  Cuando se llama a function1, una copia de la variable file1.cpp obtiene el valor 10. Cuando se llama a function2, una copia de la variable file2.cpp obtiene el valor 123. Sin embargo, el valor que se devuelve en main.cpp no ‚Äã‚Äãcambia y permanece igual a 42. <br><br>  <b>Espacios de nombres an√≥nimos</b> <br><br>  En C ++, hay otra forma de declarar uno o m√°s caracteres vinculados internamente: espacios de nombres an√≥nimos.  Tal espacio asegura que los caracteres declarados dentro de √©l sean visibles solo en la unidad de traducci√≥n actual.  Esencialmente, esta es solo una forma de declarar m√∫ltiples caracteres est√°ticos.  Durante un tiempo, se abandon√≥ el uso de la palabra clave est√°tica para declarar un car√°cter vinculado internamente a favor de espacios de nombres an√≥nimos.  Sin embargo, nuevamente comenzaron a usarlo debido a la conveniencia de declarar una variable o funci√≥n con comunicaci√≥n interna.  Hay algunas otras diferencias menores en las que no me detendr√©. <br><br>  En cualquier caso, esto es: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Hace (casi) lo mismo que: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> variable = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  <b>Uso</b> <br><br>  Entonces, ¬øen qu√© casos usar conexiones internas?  Usarlos para objetos es una mala idea.  El consumo de memoria de objetos grandes puede ser muy alto debido a la copia para cada unidad de traducci√≥n.  Pero b√°sicamente, solo causa un comportamiento extra√±o e impredecible.  Imagine que tiene un singleton (una clase en la que crea una instancia de solo una instancia) y de repente aparecen varias instancias de su "singleton" (una para cada unidad de traducci√≥n). <br><br>  Sin embargo, la comunicaci√≥n interna se puede utilizar para ocultar la unidad de traducci√≥n del √°rea global de las funciones auxiliares locales.  Supongamos que hay una funci√≥n auxiliar foo en file1.hpp que usa en file1.cpp.  Al mismo tiempo, tiene la funci√≥n foo en file2.hpp utilizada en file2.cpp.  El primer y el segundo foo son diferentes entre s√≠, pero no se te ocurren otros nombres.  Por lo tanto, puede declararlos est√°ticos.  Si no agrega tanto file1.hpp como file2.hpp a la misma unidad de traducci√≥n, esto ocultar√° foo el uno del otro.  Si esto no se hace, entonces impl√≠citamente tendr√°n una conexi√≥n externa y la definici√≥n del primer foo encontrar√° la definici√≥n del segundo, causando que el enlazador viole la regla de una definici√≥n. <br><br>  El fin <br><br>  Siempre puede dejar sus comentarios y / o preguntas aqu√≠ o visitarnos en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">d√≠a abierto.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432834/">https://habr.com/ru/post/es432834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432824/index.html">Acelerando la creaci√≥n de ConcurrentReferenceHashMap</a></li>
<li><a href="../es432826/index.html">Desarrollo moderno de Android en Kotlin. Parte 2</a></li>
<li><a href="../es432828/index.html">Prueba y depuraci√≥n de MapReduce</a></li>
<li><a href="../es432830/index.html">Sistema automatizado para imponer multas por basura abandonada</a></li>
<li><a href="../es432832/index.html">C√≥mo "pegar" un servidor basado en Intel y superar el l√≠mite m√°ximo de escala de 8 procesadores</a></li>
<li><a href="../es432836/index.html">La primera buena bombilla de AliExpress</a></li>
<li><a href="../es432838/index.html">Desarrollo de software a trav√©s del prisma del experimento de Milgram "Sumisi√≥n a la autoridad"</a></li>
<li><a href="../es432840/index.html">C√≥mo aumentar la efectividad de aprender ingl√©s y comenzar a escribir mejor: elija un asistente en l√≠nea</a></li>
<li><a href="../es432842/index.html">Algunas notas sobre el dise√±o de sistemas de informaci√≥n.</a></li>
<li><a href="../es432844/index.html">Encuesta previa al dise√±o en el desarrollo de un sistema de informaci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>