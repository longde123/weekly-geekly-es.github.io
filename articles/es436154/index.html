<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèæ üöÅ üëßüèº La historia de un problema con el veloc√≠metro, o c√≥mo el cromo gestiona la memoria üë©üèº‚Äçü§ù‚Äçüë©üèª ü§¥üèº üõÄüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un navegador moderno es un proyecto extremadamente complejo en el que incluso los cambios inofensivos pueden llevar a sorpresas inesperadas. Por lo ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La historia de un problema con el veloc√≠metro, o c√≥mo el cromo gestiona la memoria</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/436154/"> Un navegador moderno es un proyecto extremadamente complejo en el que incluso los cambios inofensivos pueden llevar a sorpresas inesperadas.  Por lo tanto, hay muchas pruebas internas que deber√≠an detectar dichos cambios antes de su lanzamiento.  Nunca hay demasiadas pruebas, por lo que tambi√©n es √∫til utilizar puntos de referencia p√∫blicos de terceros. <br><br>  Mi nombre es Andrey Logvinov, trabajo en el grupo de desarrollo de motores de renderizado Yandex.Browser en Nizhny Novgorod.  Hoy les contar√© a los lectores de Habr c√≥mo funciona la gesti√≥n de memoria en el proyecto Chromium con el ejemplo de un misterioso problema que condujo a la degradaci√≥n del rendimiento en la prueba del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">veloc√≠metro</a> .  Esta publicaci√≥n se basa en mi informe del evento Yandex.Inside. <br><br><img src="https://habrastorage.org/webt/rf/uv/u2/rfuvu23derqjtojmwivg2t-dhpm.png"><br><br><a name="habracut"></a><br>  Una vez en nuestro panel de rendimiento, vimos un deterioro en la velocidad de la prueba del veloc√≠metro.  Esta prueba mide el rendimiento general del navegador en una aplicaci√≥n que est√° cerca de la realidad: una lista de tareas pendientes, donde la prueba agrega elementos a la lista y luego los tacha.  Los resultados de la prueba se ven afectados tanto por el rendimiento del motor V8 JS como por la velocidad de renderizado de p√°ginas en el motor Blink.  La prueba del veloc√≠metro consta de varias subpruebas, donde la aplicaci√≥n de prueba se escribe utilizando uno de los marcos JS populares, por ejemplo jQuery o ReactJS.  El resultado general de la prueba se define como el promedio de los resultados para todos los marcos, pero la prueba le permite ver el rendimiento de cada marco individualmente.  Vale la pena se√±alar que la prueba no tiene como objetivo evaluar el rendimiento de los marcos, se usan solo para hacer que la prueba sea menos sint√©tica y m√°s cercana a las aplicaciones web reales.  Los detalles por subprueba mostraron que el deterioro se observa solo para la versi√≥n de la aplicaci√≥n de prueba creada con jQuery.  Y esto ya es interesante, de acuerdo. <br><br>  La investigaci√≥n de tales situaciones comienza de manera bastante est√°ndar: determinamos qu√© compromiso particular con el c√≥digo condujo al problema.  Para hacer esto, almacenamos conjuntos de Yandex.Browser para cada (!) Compromiso en los √∫ltimos a√±os (no ser√≠a pr√°ctico volver a armarlo, ya que el montaje lleva varias horas).  Esto ocupa mucho espacio en los servidores, pero generalmente ayuda a encontrar r√°pidamente la fuente del problema.  Pero esta vez r√°pidamente no funcion√≥.  Result√≥ que el deterioro de los resultados de la prueba coincidi√≥ con un compromiso que integra la pr√≥xima versi√≥n de Chromium.  El resultado no es alentador, porque la nueva versi√≥n de Chromium trae una gran cantidad de cambios a la vez. <br><br>  Como no recibimos ninguna informaci√≥n que indique un cambio espec√≠fico, tuve que hacer un estudio sustancial del problema.  Para hacer esto, utilizamos las Herramientas de desarrollo para eliminar los rastros de prueba.  Notamos una caracter√≠stica extra√±a: intervalos "desgarrados" para la ejecuci√≥n de funciones de prueba de Javascript. <br><br><img src="https://habrastorage.org/webt/fx/28/ua/fx28ua2nvcjcjxa6vrkf6xtzfye.png" alt="imagen"><br><br>  Eliminamos un rastro m√°s t√©cnico con about: tracing y vemos que es <b>recolecci√≥n de basura (GC)</b> en Blink. <br><br><img src="https://habrastorage.org/webt/11/hr/h9/11hrh9f2kyuwkbmmpgtpi8ibm5y.png" alt="imagen"><br><br>  La siguiente pista de memoria muestra que estas pausas de GC no solo toman mucho tiempo, sino que tampoco ayudan a detener el crecimiento del consumo de memoria. <br><br><img src="https://habrastorage.org/webt/u9/bw/qz/u9bwqzatofige39dtlpb7qabwjk.png" alt="imagen"><br><br>  Pero si inserta una llamada GC expl√≠cita en la prueba, entonces vemos una imagen completamente diferente: la memoria se mantiene en la regi√≥n cero y no se pierde.  Por lo tanto, no tenemos p√©rdidas de memoria y el problema est√° relacionado con las caracter√≠sticas del recopilador.  Seguimos cavando.  ¬°Iniciamos el depurador y vemos que el recolector de basura ha evitado alrededor de 500 mil objetos!  Tal cantidad de objetos no podr√≠a afectar el rendimiento.  ¬øPero de d√≥nde vinieron? <br><br>  Y aqu√≠ necesitamos un peque√±o flashback sobre el dispositivo recolector de basura en Blink.  Elimina objetos muertos, pero no mueve objetos vivos, lo que permite operar con punteros desnudos en variables locales en c√≥digo C ++.  Este patr√≥n se usa activamente en Blink.  Pero tambi√©n tiene su precio: al recolectar basura, debe <b>escanear la pila de</b> flujo, y si se encuentra algo similar a un puntero a un objeto desde un mont√≥n, considere el objeto y todo lo que se refiere directa o indirectamente a estar vivo.  Esto lleva al hecho de que algunos objetos pr√°cticamente inaccesibles y, por lo tanto, "muertos" se identifican como vivos.  Por lo tanto, esta forma de recolecci√≥n de basura tambi√©n se llama conservadora. <br><br>  Verificamos la conexi√≥n con el escaneo de la pila y la omitimos.  El problema ha desaparecido. <br><br>  ¬øQu√© puede ser as√≠ en una pila que contiene 500 mil objetos?  Ponemos un punto de interrupci√≥n en la funci√≥n de agregar objetos; entre otras cosas, vemos que es sospechoso: <br><br>  parpadeo :: TraceTrait &lt;parpadeo :: HeapHashTableBacking &lt;WTF :: HashTable &lt;parpadeo :: WeakMember ... <br><br>  <b>¬°Una referencia de tabla hash</b> es probablemente un sospechoso!  Probamos la hip√≥tesis omitiendo la adici√≥n de este enlace.  El problema ha desaparecido.  Bueno, estamos un paso m√°s cerca de la respuesta. <br><br>  Recordamos otra caracter√≠stica del recolector de basura en Blink: si ve un puntero al interior de la tabla hash, entonces considera que esto es un signo de iteraci√≥n continua sobre la tabla, lo que significa que considera que todos los enlaces en esta tabla son √∫tiles y contin√∫a omiti√©ndolos.  En nuestro caso, inactivo.  Pero, ¬øqu√© funci√≥n es la fuente de este enlace? <br><br>  Avanzamos unos pocos cuadros de la pila m√°s arriba, tomamos la posici√≥n actual del esc√°ner, miramos el marco de la pila en qu√© funci√≥n se encuentra.  Esta es una funci√≥n llamada <b>ScheduleGCIfNeeded</b> .  Parece que aqu√≠ √©l es el culpable, pero ... miramos el c√≥digo fuente de la funci√≥n y vemos que no hay tablas hash all√≠.  Adem√°s, esto ya es parte del recolector de basura en s√≠, y simplemente no necesita referirse a objetos del mont√≥n de Blink.  ¬øDe d√≥nde vino este enlace "malo"? <br><br>  Establecimos un punto de interrupci√≥n al cambiar la celda de memoria, en el que encontramos un enlace a la tabla hash.  Vemos que una de las funciones internas llamadas V8PerIsolateData :: AddActiveScriptWrappable escribe all√≠.  All√≠, agregan algunos elementos HTML creados de algunos tipos, incluida la entrada, a una √∫nica tabla hash active_script_wrappables_.  Esta tabla es necesaria para evitar la eliminaci√≥n de elementos a los que ya no se hace referencia desde Javascript o el √°rbol DOM, pero que est√°n asociados con cualquier actividad externa que, por ejemplo, pueda generar eventos. <br><br>  El recolector de basura durante el recorrido normal de la mesa tiene en cuenta el estado de los elementos contenidos en √©l y los marca como activos o no los marca, luego se eliminan en la siguiente etapa del ensamblaje.  Sin embargo, en nuestro caso, aparece un puntero al almacenamiento interno de esta tabla cuando se escanea la pila, y todos los elementos de la tabla se marcan como activos. <br><br>  ¬øPero c√≥mo el valor de la pila de una funci√≥n golpe√≥ la pila de otra? <br><br>  Piense en ScheduleGCIfNeeded.  Recuerde que no se encontr√≥ nada √∫til en el c√≥digo fuente de esta funci√≥n, pero esto solo significa que es hora de bajar a un nivel inferior y verificar el <b>compilador</b> .  El pr√≥logo desmontado de la funci√≥n ScheduleGCIfNeeded tiene este aspecto: <br><br><pre><code class="plaintext hljs">0FCDD13A push ebp 0FCDD13B mov ebp,esp 0FCDD13D push edi 0FCDD13E push esi 0FCDD13F and esp,0FFFFFFF8h 0FCDD142 sub esp,0B8h 0FCDD148 mov eax,dword ptr [__security_cookie (13DD3888h)] 0FCDD14D mov esi,ecx 0FCDD14F xor eax,ebp 0FCDD151 mov dword ptr [esp+0B4h],eax</code> </pre> <br>  Se puede ver que la funci√≥n se <b>mueve especialmente a 0B8h</b> , y este lugar no se usa m√°s.  Pero debido a esto, el esc√°ner de pila ve lo que otras funciones registraron previamente.  Y por casualidad, un puntero al interior de la tabla hash dejado por la funci√≥n AddActiveScriptWrappable entra en este "agujero".  Al final result√≥ que, la raz√≥n de la aparici√≥n de un "agujero" en este caso fue la <b>macro de</b> depuraci√≥n <b>VLOG</b> dentro de la funci√≥n, que muestra informaci√≥n adicional en el registro. <br><br>  Pero, ¬øpor qu√© la tabla active_script_wrappable_ ten√≠a cientos de miles de elementos?  ¬øPor qu√© se observa una degradaci√≥n del rendimiento solo en la prueba jQuery?  La respuesta a ambas preguntas es la misma: en esta prueba en particular, para cada cambio (como una marca de verificaci√≥n en la casilla de verificaci√≥n) se recrea completamente la IU completa.  La prueba produce elementos que casi inmediatamente se convierten en basura.  El resto de las pruebas en el veloc√≠metro son m√°s prudentes y no crean elementos innecesarios, por lo tanto, no se observa degradaci√≥n del rendimiento en ellos.  Si est√° desarrollando servicios web, debe tener esto en cuenta para no crear trabajo innecesario para el navegador. <br><br>  Pero, ¬øpor qu√© el problema surgi√≥ solo ahora si la macro VLOG era antes?  No hay una respuesta exacta, pero lo m√°s probable es que, durante la actualizaci√≥n, la posici√≥n relativa de los elementos en la pila haya cambiado, por lo que el puntero a la tabla hash se volvi√≥ accidentalmente accesible para el esc√°ner.  De hecho, ganamos la loter√≠a.  Para cerrar r√°pidamente el "agujero" y restaurar el rendimiento, eliminamos la macro de depuraci√≥n de VLOG.  Para los usuarios, es in√∫til, y para nuestras propias necesidades de diagn√≥stico, siempre podemos volver a encenderlo.  Tambi√©n compartimos nuestras experiencias con otros desarrolladores de Chromium.  La respuesta confirm√≥ nuestros temores: este es un problema fundamental de recolecci√≥n de basura conservadora en Blink, que no tiene una soluci√≥n sist√©mica. <br><br><h3>  Enlaces interesantes </h3><br>  1. Si est√° interesado en aprender sobre otra vida cotidiana inusual de nuestro grupo, entonces recordamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">historia del rect√°ngulo negro</a> , que condujo a la aceleraci√≥n no solo de Yandex.Browser, sino de todo el proyecto Chromium. <br><br>  2. Y tambi√©n los invito a escuchar otros informes en el pr√≥ximo evento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yandex. Dentro del</a> evento el 16 de febrero, la inscripci√≥n est√° abierta, la transmisi√≥n tambi√©n lo estar√°. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436154/">https://habr.com/ru/post/es436154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436140/index.html">"Bajo el cap√≥" del almacenamiento de Huawei: tecnolog√≠as patentadas y lo que otros no tienen</a></li>
<li><a href="../es436144/index.html">Jefes chupadores de sangre en el contexto de una biocenosis: por qu√© un equipo aut√≥nomo se separa si no est√° centralizado</a></li>
<li><a href="../es436148/index.html">La historia de un junior: c√≥mo comenzar a trabajar y no tener miedo de todo</a></li>
<li><a href="../es436150/index.html">Configure la transferencia de datos del dispositivo a AWS IoT Core</a></li>
<li><a href="../es436152/index.html">El error que me ense√±√≥ el dise√±o orientado a los negocios.</a></li>
<li><a href="../es436160/index.html">5 reglas de c√≥digo f√°ciles de leer</a></li>
<li><a href="../es436162/index.html">GoPro Factory se muda para protegerse contra la amenaza de mayores aranceles de importaci√≥n</a></li>
<li><a href="../es436164/index.html">El experimento de signos mostr√≥ que la mensajer√≠a cu√°ntica es m√°s r√°pida que la cl√°sica</a></li>
<li><a href="../es436166/index.html">Tesla Model 3 se ofrece en Pwn2Own a cualquiera que entre en un sistema de protecci√≥n de veh√≠culos el√©ctricos</a></li>
<li><a href="../es436170/index.html">En el biocontenedor en la luna, brotaron las primeras plantas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>