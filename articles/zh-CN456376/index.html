<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚬 🛩️ 🐟 没有一个春季启动：替代方案概述 🥡 👩‍👩‍👦 👆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当前不乏使用Java和Kotlin创建微服务的框架。 本文讨论了以下内容： 
 职称  版本号  首次发行年份  开发者  直升机停机坪  1.1.1  2019年  甲骨文  克托  1.2.1  2018年  捷脑  微航海  1.1.3  2018年  对象运算  春季靴  2.1.5  20...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>没有一个春季启动：替代方案概述</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/456376/"><img src="https://habrastorage.org/webt/al/mw/1g/almw1ghoqrvuf2nbw_awcwqvqe4.png"><br><br> 当前不乏使用Java和Kotlin创建微服务的框架。 本文讨论了以下内容： <br><div class="scrollable-table"><table><tbody><tr><th> 职称 </th><th> 版本号 </th><th> 首次发行年份 </th><th> 开发者 </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">直升机停机坪</a> </td><td>  1.1.1 </td><td>  2019年 </td><td> 甲骨文 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">克托</a> </td><td>  1.2.1 </td><td>  2018年 </td><td> 捷脑 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微航海</a> </td><td>  1.1.3 </td><td>  2018年 </td><td> 对象运算 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">春季靴</a> </td><td>  2.1.5 </td><td>  2014年 </td><td> 关键的 </td></tr></tbody></table></div><a name="habracut"></a><br> 基于它们，已经创建了四个服务，可以使用通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Consul</a>实现的服务发现模式通过HTTP API相互交互。 因此，它们形成了异构的（在框架级别）微服务架构（以下称为ISA）： <br><br><img src="https://habrastorage.org/webt/tv/mv/kp/tvmvkpurtljgpl3yhxhtpmse4_g.png"><br><br> 为每种服务定义一组要求： <br><br><ul><li> 技术栈： <br><ul><li>  JDK 12； </li><li> 科特林 </li><li>  Gradle（Kotlin DSL）； </li><li>  JUnit 5。 </li></ul><br></li><li> 功能（HTTP API）： <br><ul><li><code>GET /application-info{?request-to=some-service-name}</code> <br> 返回有关微服务的一些基本信息（名称，框架，框架的发布年份）； 当在其HTTP API的<code>request-to</code>参数中指定四个微服务之一的名称时，将执行类似的请求，该请求返回基本信息； </li><li> <code>GET /application-info/logo</code> <br> 返回图像。 </li></ul><br></li><li> 实施： <br><ul><li> 使用配置文件进行设置； </li><li> 使用依赖注入 </li><li> 验证HTTP API功能的测试。 </li></ul><br></li><li>  ISA： <br><ul><li> 使用服务发现模式（向Consul注册，使用客户端负载平衡按名称访问另一个微服务的HTTP API）； </li><li>  uber-jar神器形成。 </li></ul><br></li></ul><br> 接下来，我们考虑在每个框架上实现微服务，并比较接收到的应用程序的参数。 <br><br><h1> 直升机停机坪服务 </h1><br> 开发框架是在Oracle上创建的，供内部使用，随后成为开源。 基于此框架的开发模型有两种：标准版（SE）和MicroProfile（MP）。 在这两种情况下，该服务都是常规的Java SE程序。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>页面上了解有关差异的更多信息。 <br><br> 简而言之，Helidon MP是Eclipse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MicroProfile的</a>实现之一，这使得可以使用Java EE开发人员先前已知的许多API（例如JAX-RS，CDI）和较新的API（运行状况检查，指标，容错）等）。 在Helidon SE变体中，开发人员遵循“没有魔术”的原则，尤其是用创建应用程序所需的注释更少或没有注释的原则来表达。 <br><br>  Helidon SE被选择用于微服务开发。 除其他外，它缺少用于实现依赖注入的工具，因此使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Koin</a>来实现依赖。 以下是包含main方法的类。 为了实现依赖注入，该类继承自<i>KoinComponent</i> 。  Koin首先启动，然后初始化所需的依赖关系，并<code>startServer()</code>方法，在该方法中创建<i>WebServer</i>类型的对象，之前将应用程序配置和路由设置传输到该对象； 启动后，该应用程序将在领事馆注册： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> HelidonServiceApplication : KoinComponent { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.currentTimeMillis() startKoin { modules(koinModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoProperties: ApplicationInfoProperties <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceName = applicationInfoProperties.name startServer(applicationInfoService, consulClient, serviceName, startTime) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( applicationInfoService: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicationInfoService</span></span></span></span><span class="hljs-function"><span class="hljs-params">, consulClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Consul</span></span></span></span><span class="hljs-function"><span class="hljs-params">, serviceName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, startTime: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: WebServer { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serverConfig = ServerConfiguration.create(Config.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"webserver"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> server: WebServer = WebServer .builder(createRouting(applicationInfoService)) .config(serverConfig) .build() server.start().thenAccept { ws -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> durationInMillis = System.currentTimeMillis() - startTime log.info(<span class="hljs-string"><span class="hljs-string">"Startup completed in </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$durationInMillis</span></span></span><span class="hljs-string"> ms. Service running at: http://localhost:"</span></span> + ws.port()) <span class="hljs-comment"><span class="hljs-comment">// register in Consul consulClient.agentClient().register(createConsulRegistration(serviceName, ws.port())) } return server }</span></span></code> </pre> <br> 路由配置如下： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRouting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(applicationInfoService: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicationInfoService</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Routing.builder() .register(JacksonSupport.create()) .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/application-info"</span></span>, Handler { req, res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> requestTo: String? = req.queryParams() .first(<span class="hljs-string"><span class="hljs-string">"request-to"</span></span>) .orElse(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) res .status(Http.ResponseStatus.create(<span class="hljs-number"><span class="hljs-number">200</span></span>)) .send(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo)) }) .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/application-info/logo"</span></span>, Handler { req, res -&gt; res.headers().contentType(MediaType.create(<span class="hljs-string"><span class="hljs-string">"image"</span></span>, <span class="hljs-string"><span class="hljs-string">"png"</span></span>)) res .status(Http.ResponseStatus.create(<span class="hljs-number"><span class="hljs-number">200</span></span>)) .send(applicationInfoService.getLogo()) }) .error(Exception::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span></span>{ req, res, ex -&gt; log.error(<span class="hljs-string"><span class="hljs-string">"Exception:"</span></span>, ex) res.status(Http.Status.INTERNAL_SERVER_ERROR_500).send() } .build()</code> </pre> <br> 该应用程序使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>HOCON</u></a>格式的配置： <br><br><pre> <code class="json hljs">webserver { port: <span class="hljs-number"><span class="hljs-number">8081</span></span> } application-info { name: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span> framework { name: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span> release-year: <span class="hljs-number"><span class="hljs-number">2019</span></span> } }</code> </pre> <br> 也可以使用JSON，YAML和属性格式的文件进行配置（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处有</a>更多详细信息）。 <br><br><h1>  Ktor服务 </h1><br> 该框架是用Kotlin编写的。 可以通过几种方式创建一个新项目：使用构建系统， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">start.ktor.io</a>或IntelliJ IDEA插件（更多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息请</a>参见）。 <br><br> 像Helidon SE一样，Ktor也没有开箱即用的DI，因此在启动服务器之前使用Koin实现依赖项： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> koinModule = module { single { ApplicationInfoService(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()) } single { ApplicationInfoProperties() } single { ServiceClient(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()) } single { Consul.builder().withUrl(<span class="hljs-string"><span class="hljs-string">"http://localhost:8500"</span></span>).build() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { startKoin { modules(koinModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> server = embeddedServer(Netty, commandLineEnvironment(args)) server.start(wait = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre> <br> 应用程序所需的模块在配置文件中指定（可以仅使用HOCON格式；有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>配置Ktor服务器的更多信息），其内容如下所示： <br><br><pre> <code class="kotlin hljs">ktor { deployment { host = localhost port = <span class="hljs-number"><span class="hljs-number">8082</span></span> watch = [io.heterogeneousmicroservices.ktorservice] } application { modules = [io.heterogeneousmicroservices.ktorservice.module.KtorServiceApplicationModuleKt.module] } } application-info { name: <span class="hljs-string"><span class="hljs-string">"ktor-service"</span></span> framework { name: <span class="hljs-string"><span class="hljs-string">"Ktor"</span></span> release-year: <span class="hljs-number"><span class="hljs-number">2018</span></span> }</code> </pre> <br>  Ktor和Koin使用术语“模块”，其含义不同。 在Koin中，模块是Spring框架中应用程序上下文的类似物。  Ktor模块是用户定义的函数，它接受类型为<i>Application</i>的对象，并且可以配置管道，设置功能，注册路由，处理 <br> 要求等： <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Application.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isTest()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() registerInConsul(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>).name, consulClient) } install(DefaultHeaders) install(Compression) install(CallLogging) install(ContentNegotiation) { jackson {} } routing { route(<span class="hljs-string"><span class="hljs-string">"application-info"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> requestTo: String? = call.parameters[<span class="hljs-string"><span class="hljs-string">"request-to"</span></span>] call.respond(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo)) } static { resource(<span class="hljs-string"><span class="hljs-string">"/logo"</span></span>, <span class="hljs-string"><span class="hljs-string">"logo.png"</span></span>) } } } }</code> </pre> <br> 在此代码段中，配置了请求的路由，尤其是静态资源<code>logo.png</code> 。 <br><br>  Ktor服务可能包含功能。 功能是嵌入在请求-响应<i>管道中的功能</i> （ <i>DefaultHeaders，Compression</i>和上面的代码示例中的其他功能）。 可以实现自己的功能，例如，下面的代码结合基于轮循算法的客户端负载平衡来实现服务发现模式： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConsulFeature</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consulClient: Consul } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Feature : HttpClientFeature&lt;Config, ConsulFeature&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serviceInstanceIndex: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key = AttributeKey&lt;ConsulFeature&gt;(<span class="hljs-string"><span class="hljs-string">"ConsulFeature"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Config</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = ConsulFeature(Config().apply(block).consulClient) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">install</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(feature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ConsulFeature</span></span></span></span><span class="hljs-function"><span class="hljs-params">, scope: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { scope.requestPipeline.intercept(HttpRequestPipeline.Render) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceName = context.url.host <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceInstances = feature.consulClient.healthClient().getHealthyServiceInstances(serviceName).response <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectedInstance = serviceInstances[serviceInstanceIndex] context.url.apply { host = selectedInstance.service.address port = selectedInstance.service.port } serviceInstanceIndex = (serviceInstanceIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) % serviceInstances.size } } } }</code> </pre> <br> 主要逻辑在于<code>install</code>方法：在<i>Render</i>请求阶段（在<i>Send</i>阶段之前执行）期间，首先确定要调用的服务的名称，然后从<code>consulClient</code>请求此服务的实例列表，然后使用Round-robin算法确定实例。 因此，以下调用变为可能： <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getApplicationInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serviceName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ApplicationInfo = runBlocking { httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;ApplicationInfo&gt;(<span class="hljs-string"><span class="hljs-string">"http://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$serviceName</span></span></span><span class="hljs-string">/application-info"</span></span>) }</code> </pre> <br><br><h1> 微航服务 </h1><br>  Micronaut由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Grails</a>框架的创建者开发，其灵感来自使用Spring，Spring Boot和Grails构建服务的经验。 该框架是一个多语言版本，支持Java，Kotlin和Groovy。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">也许会有</a>对Scala的支持。 依赖注入是在编译阶段执行的，与Spring Boot相比，这导致更少的内存消耗和更快的应用程序启动。 <br><br> 主类具有以下形式： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> MicronautServiceApplication { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { Micronaut.build() .packages(<span class="hljs-string"><span class="hljs-string">"io.heterogeneousmicroservices.micronautservice"</span></span>) .mainClass(MicronautServiceApplication.javaClass) .start() } }</code> </pre> <br> 基于Micronaut的应用程序的某些组件类似于Spring Boot应用程序中的组件，例如，控制器代码如下： <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller( value = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/application-info"</span></span></span><span class="hljs-meta">, consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON] )</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationInfoController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService ) { <span class="hljs-meta"><span class="hljs-meta">@Get</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requestTo: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: ApplicationInfo = applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo) <span class="hljs-meta"><span class="hljs-meta">@Get(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/logo"</span></span></span><span class="hljs-meta">, produces = [MediaType.IMAGE_PNG])</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray = applicationInfoService.getLogo() }</code> </pre> <br>  Micronaut对Kotlin的支持基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kapt</a>编译器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">插件</a> （更多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a> ）。 汇编脚本的配置如下： <br><br><pre> <code class="kotlin hljs">plugins { ... kotlin(<span class="hljs-string"><span class="hljs-string">"kapt"</span></span>) ... } dependencies { kapt(<span class="hljs-string"><span class="hljs-string">"io.micronaut:micronaut-inject-java"</span></span>) ... kaptTest(<span class="hljs-string"><span class="hljs-string">"io.micronaut:micronaut-inject-java"</span></span>) ... }</code> </pre> <br> 以下是配置文件的内容： <br><br><pre> <code class="json hljs">micronaut: application: name: micronaut-service server: port: <span class="hljs-number"><span class="hljs-number">8083</span></span> consul: client: registration: enabled: <span class="hljs-literal"><span class="hljs-literal">true</span></span> application-info: name: ${micronaut.application.name} framework: name: Micronaut release-year: <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre> <br> 还可以使用JSON，属性和Groovy文件格式进行微服务配置（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处有</a>更多详细信息）。 <br><br><h1> 春季启动服务 </h1><br> 创建该框架是为了简化使用Spring Framework生态系统的应用程序开发。 这是通过连接库时的自动配置机制来实现的。 以下是控制器代码： <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping(path = [</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"application-info"</span></span></span><span class="hljs-meta">], produces = [MediaType.APPLICATION_JSON_UTF8_VALUE])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationInfoController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService ) { <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestParam(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"request-to"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> requestTo: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: ApplicationInfo = applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo) <span class="hljs-meta"><span class="hljs-meta">@GetMapping(path = [</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/logo"</span></span></span><span class="hljs-meta">], produces = [MediaType.IMAGE_PNG_VALUE])</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray = applicationInfoService.getLogo() }</code> </pre> <br> 微服务配置了一个YAML文件： <br><br><pre> <code class="json hljs">spring: application: name: spring-boot-service server: port: <span class="hljs-number"><span class="hljs-number">8084</span></span> application-info: name: ${spring.application.name} framework: name: Spring Boot release-year: <span class="hljs-number"><span class="hljs-number">2014</span></span></code> </pre> <br> 也可以使用属性格式文件进行配置（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处有</a>更多详细信息）。 <br><br><h1> 发射 </h1><br> 该项目可在JDK 12上运行，尽管也可能在版本11上运行，您只需要相应地在汇编脚本中更改<code>jvmTarget</code>参数： <br><br><pre> <code class="kotlin hljs">withType&lt;KotlinCompile&gt; { kotlinOptions { jvmTarget = <span class="hljs-string"><span class="hljs-string">"12"</span></span> ... } }</code> </pre> <br> 在启动微服务之前，您需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安装</a> Consul并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启动</a>代理-例如，像这样： <code>consul agent -dev</code> 。 <br><br> 可以从以下位置启动微服务： <br><br><ul><li> 集成开发环境 <br>  IntelliJ IDEA用户可以看到以下内容： <br><img src="https://habrastorage.org/webt/n3/u_/hy/n3u_hy7_z5ut65ryaetvsw2znci.png"><br></li><li> 控制台 <br> 为此，请转到项目文件夹并依次执行： <br><br><pre> <code class="plaintext hljs">java -jar helidon-service/build/libs/helidon-service-all.jar java -jar ktor-service/build/libs/ktor-service-all.jar java -jar micronaut-service/build/libs/micronaut-service-all.jar java -jar spring-boot-service/build/libs/spring-boot-service.jar</code> </pre> <br></li></ul><br> 在<code>http://localhost:8500/ui/dc1/services</code>上启动所有微<code>http://localhost:8500/ui/dc1/services</code>您将看到： <br><br><img src="https://habrastorage.org/webt/qi/lm/bv/qilmbv1op4a6xgy6b31tnsfjpmm.png"><br><br><h1>  API测试 </h1><br> 作为示例，给出了测试Helidon服务API的结果： <br><br><ol><li> <code>GET http://localhost:8081/application-info</code> <br> <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2019</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> </li><li> <code>GET http://localhost:8081/application-info?request-to=ktor-service</code> <br> <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2019</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ktor-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ktor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2018</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> } }</code> </pre> </li><li> <code>GET http://localhost:8081/application-info/logo</code> <br> <br> 返回图像。 </li></ol><br> 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Postman</a> （请求的<a href="">集合</a> ），IntelliJ IDEA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://www.jetbrains.com/help/idea/">HTTP客户端</a> （请求的<a href="https://github.com/rkudryashov/heterogeneous-microservices/blob/master/_misc/api_testing/idea_http_client/http-request.">集合</a> ），浏览器或其他工具来测试任意微服务API。 如果使用前两个客户端，则必须在相应的变量中指定被调用微服务的端口（在Postman中，它在<i>集合菜单-&gt; Edit-&gt; Variables中</i> ，在HTTP Client中，它在<a href="https://github.com/rkudryashov/heterogeneous-microservices/blob/master/_misc/api_testing/idea_http_client/">此</a>文件中指定的环境变量中），并且在测试方法2时） API还需要指定请求的“幕后”微服务的名称。 答案将与上面给出的答案相似。 <br><br><h1> 应用程序设置比较 </h1><br><br><h3> 工件尺寸 </h3><br> 为了保持在汇编脚本中设置和运行应用程序的简便性，未排除任何传递依赖项，因此Spring Boot上的uber-JAR服务的大小大大超过了其他框架上类似物的大小（因为使用启动器时，不仅导入了必需的依赖项;如果需要，可以大大减小尺寸）： <br><div class="scrollable-table"><table><tbody><tr><th> 微服务 </th><th> 工件大小，MB </th></tr><tr><td> 直升机停机坪服务 </td><td align="right">  16.6 </td></tr><tr><td>  Ktor服务 </td><td align="right">  20.9 </td></tr><tr><td> 微航服务 </td><td align="right">  16.5 </td></tr><tr><td> 春季启动服务 </td><td align="right">  42.7 </td></tr></tbody></table></div><br><br><h3> 发射时间 </h3><br> 每个应用程序的启动时间不一致，并落入一些“窗口”中。 下表显示了工件的启动时间，但未指定任何其他参数： <br><div class="scrollable-table"><table><tbody><tr><th> 微服务 </th><th> 开始时间，秒 </th></tr><tr><td> 直升机停机坪服务 </td><td align="right">  2.2 </td></tr><tr><td>  Ktor服务 </td><td align="right">  1.4 </td></tr><tr><td> 微航服务 </td><td align="right">  4.0 </td></tr><tr><td> 春季启动服务 </td><td align="right">  10,2 </td></tr></tbody></table></div><br> 值得注意的是，如果您从不需要的依赖项中“清除”了Spring Boot应用程序，并注意将其配置为启动（例如，仅扫描必要的程序包并使用惰性容器初始化），则可以大大减少启动时间。 <br><br><h3> 负载测试 </h3><br> 为了进行测试，使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">加特林</a>和Scala <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">脚本</a> 。 负载生成器和被测服务在同一台计算机上运行（Windows 10，四核3.2 GHz处理器，24 GB RAM，SSD）。 该服务的端口在Scala脚本中指示。 <br><br> 对于每个微服务，确定： <br><br><ul><li> 运行正常（响应请求）微服务所需的最小堆内存（ <code>-Xmx</code> ） </li><li> 通过负载测试所需的最小堆内存50个用户* 1000个请求 </li><li> 通过负载测试所需的最小堆内存500个用户* 1000个请求 </li></ul><br> 通过负载测试意味着微服务可以随时响应所有请求。 <br><div class="scrollable-table"><table><tbody><tr><th rowspan="2"> 微服务 </th><th colspan="3"> 最小堆内存量，MB </th></tr><tr><th> 启动服务 </th><th> 负载50 * 1000 </th><th> 负载500 * 1000 </th></tr><tr><td> 直升机停机坪服务 </td><td align="right">  9 </td><td align="right">  9 </td><td align="right">  11 </td></tr><tr><td>  Ktor服务 </td><td align="right">  11 </td><td align="right">  11 </td><td align="right">  13 </td></tr><tr><td> 微航服务 </td><td align="right">  13 </td><td align="right">  13 </td><td align="right">  17 </td></tr><tr><td> 春季启动服务 </td><td align="right">  22 </td><td align="right">  23 </td><td align="right">  25 </td></tr></tbody></table></div><br> 值得注意的是，所有微服务都使用Netty HTTP服务器。 <br><br><h1> 结论 </h1><br> 这项任务-使用HTTP API创建简单服务以及在ISA中运行的功能-可以在所有相关框架上完成。 现在是盘点并考虑其优点和缺点的时候了。 <br><br>  <i><b>海利顿</b></i> <br><br>  <font color="#808080">标准版</font> <br><ul><li> 加号 <br><ul><li> 应用程序设置 <br> 在各方面均显示出良好的结果； </li><li>  “没有魔术” <br> 该框架证明了开发人员所陈述的原理：仅需一个注释即可创建应用程序（ <code>@JvmStatic</code>用于Java-Kotlin Interope）。 </li></ul></li><li> 缺点 <br><ul><li> 微框架 <br> 工业发展所需的某些组件是开箱即用的，例如，依赖注入和Service Discovery的实现。 </li></ul></li></ul><br>  <font color="#808080">微轮廓</font> <br> 微服务不是在此框架上实现的，因此，我只想说明几点： <br><br><ul><li> 加号 <br><ul><li>  Eclipse MicroProfile实施 <br> 本质上，MicroProfile是针对ISA优化的Java EE。 因此，首先，您可以访问各种Java EE API，包括专门为ISA设计的Java EE API；其次，您可以将MicroProfile实现更改为任何其他实现（Open Liberty，WildFly Swarm等）。 。 </li></ul></li><li> 另外 <br><ul><li> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MicroProfile Starter上，</a>您可以类似用于其他框架的工具（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring Initializr</a> ）从头开始创建具有必要参数的项目。 在本文发表时，Helidon实现了MicroProfile 1.2，而该规范的最新版本是3.0。 </li></ul></li></ul><br><br>  <i><b>克托</b></i> <br><br><ul><li> 加号 <br><ul><li> 轻盈 <br> 仅允许您连接完成任务直接需要的那些功能； </li><li> 应用程序设置 <br> 在各方面均取得良好结果。 </li></ul></li><li> 缺点 <br><ul><li>  Kotlin领导下的“锐减”，也就是说，有可能（但不是必须）用Java开发； </li><li> 微型框架（请参阅Helidon SE的类似项目）。 </li></ul></li><li> 另外 <br> 一方面，该框架的开发概念未包含在两个最流行的Java开发模型（类似于Spring（Spring Boot / Micronaut）和Java EE / MicroProfile）中，这可能导致： <br><br><ul><li> 寻找专家的问题； </li><li> 与Spring Boot相比，由于需要显式配置所需的功能，因此完成任务所需的时间更长。 </li></ul><br> 另一方面，与“经典” Spring和Java EE的不同之处使您可以更自觉地从另一个角度看待开发过程。 </li></ul><br><br>  <i><b>微航海</b></i> <br><br><ul><li> 加号 <br><ul><li> 奥特 <br> 如前所述，与Spring Boot上的应用程序相比，AOT可以减少应用程序的启动时间和内存消耗。 </li><li> 春季开发模式 <br> 具有在Spring上开发经验的程序员不会花很多时间来掌握这个框架。 </li><li> 应用程序设置 <br> 在各方面均取得良好结果； </li><li> 多种语言 <br> 对Java，Kotlin，Groovy的一流公民支持； 也许会有对Scala的支持。 我认为，这可以对社区发展产生积极影响。 顺便说一句，在2019年6月，Groovy在编程语言的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">流行性</a>排名中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TIOBE</a>从60年前的第60位<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">升至</a>第14位，在JVM语言中名列第二; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Micronaut for Spring</a>项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还</a>允许您将现有Spring Boot应用程序的运行时更改为Micronaut（有限制）。 </li></ul></li></ul><br><br>  <i><b>春季靴</b></i> <br><br><ul><li> 加号 <br><ul><li> 平台成熟度和生态系统 <br>  “每天”的框架。 对于大多数日常任务，Spring编程范例中已经有一种解决方案，即许多程序员都熟悉的一种解决方案。 启动器和自动配置的概念简化了开发过程； </li><li> 劳动力市场中有大量专家，以及重要的知识库（包括文档和Stack Overflow的答案）； </li><li> 观点 <br> 我认为许多人都会同意，在不久的将来，Spring将仍然是领先的开发框架。 </li></ul></li><li> 缺点 <br><ul><li> 应用程序设置 <br> 该框架上的应用程序不在领导者之列，但是，如前所述，某些参数可以独立优化。 还值得回顾的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring Fu</a>项目的存在，该项目正在积极开发中，使用它可以减少这些参数。 </li></ul></li></ul><br> 您还可以突出显示与Spring Boot中缺少的与新框架相关的一般问题： <br><br><ul><li> 欠发达的生态系统； </li><li> 少数具有这些技术经验的专家； </li><li> 完成任务的时间更长； </li><li> 前景不明朗。 </li></ul><br> 所考虑的框架属于不同的权重类别：Helidon SE和Ktor是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微</a>框架，Spring Boot是全栈框架，Micronaut更有可能也是全栈； 另一个类别是MicroProfile（例如Helidon MP）。 在微帧中，功能是有限的，这会减慢任务的执行； 为了阐明在任何开发框架的基础上实现此功能的可能性，我建议您熟悉其文档。 <br><br> 我不敢判断这个框架或那个框架是否会在不久的将来“解决”，因此，我认为，最好使用现有的开发框架来解决工作任务，继续监视事件的发展。 <br><br> 同时，如本文中所示，新框架在接收到的应用程序的参数方面胜过Spring Boot。 如果这些参数中的任何一个对于您的任何微服务都至关重要，那么您可能需要注意对它们显示出最佳结果的框架。 但是，请不要忘记，Spring Boot首先会继续改进，其次，它具有庞大的生态系统，并且许多Java程序员都熟悉它。 本文未涉及其他框架：Javalin，Quarkus等。 <br><br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>查看项目代码。 感谢您的关注！ <br><br>  PS：感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">artglorin</a>对本文的帮助。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456376/">https://habr.com/ru/post/zh-CN456376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456366/index.html">我如何设计LED心形盒</a></li>
<li><a href="../zh-CN456368/index.html">使用Web3在JPMorgan Quorum区块链上执行公共和私人交易</a></li>
<li><a href="../zh-CN456370/index.html">在Qsan Storage中实施QoS</a></li>
<li><a href="../zh-CN456372/index.html">SimbirSoft邀请IT专业人员参加Intensive Summer 2019</a></li>
<li><a href="../zh-CN456374/index.html">等离子现金区块链状态数据结构</a></li>
<li><a href="../zh-CN456380/index.html">网络学编程学院开放日</a></li>
<li><a href="../zh-CN456382/index.html">前端中的协作和自动化。 我们从13所学校学到了什么</a></li>
<li><a href="../zh-CN456384/index.html">诊断能力发展的PVS-Studio图</a></li>
<li><a href="../zh-CN456386/index.html">打开库以可视化音频内容</a></li>
<li><a href="../zh-CN456388/index.html">PVS-Studio中的诊断开发图</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>