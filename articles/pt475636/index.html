<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚≠êÔ∏è üë©üèæ‚Äçü§ù‚Äçüë®üèº üêÆ Elementos do vetor de incremento üå©Ô∏è ‚ùå üö∂üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nesse caso, o incremento dos elementos std :: vector ser√° mais r√°pido - se forem do tipo uint8_t ou uint32_t ? 

 Para n√£o raciocinar de maneira abstr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elementos do vetor de incremento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/475636/">  Nesse caso, o incremento dos elementos <i>std :: vector</i> ser√° mais r√°pido - se forem do tipo <i>uint8_t</i> ou <i>uint32_t</i> ? <br><br>  Para n√£o raciocinar de maneira abstrata, consideramos duas implementa√ß√µes espec√≠ficas: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector32_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <a name="habracut"></a><br><h2>  Vamos tentar adivinhar </h2><br>  √â f√°cil responder a essa pergunta usando o benchmark, e um pouco mais tarde faremos isso, mas primeiro tentaremos adivinhar (isso √© chamado de "racioc√≠nio baseado em princ√≠pios b√°sicos" - parece mais cient√≠fico). <br><br>  Em primeiro lugar, vale a pena fazer uma pergunta: <i>qual √© o tamanho desses vetores</i> ? <br><br>  Bem, vamos escolher um n√∫mero.  Que haja 20.000 elementos em cada um. <br><br>  Al√©m disso, sabe-se que faremos testes no processador Intel Skylake - veremos as caracter√≠sticas dos comandos de adi√ß√£o para operandos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">32 bits</a> com endere√ßamento direto.  Acontece que seus principais indicadores s√£o os mesmos: 1 opera√ß√£o por ciclo e um atraso de 4 ciclos por acesso √† mem√≥ria (1).  Nesse caso, o atraso n√£o importa, pois cada opera√ß√£o de adi√ß√£o √© executada independentemente, de modo que a velocidade calculada √© de 1 elemento por ciclo, desde que todo o restante do trabalho no loop seja executado em paralelo. <br><br>  Voc√™ tamb√©m pode observar que 20.000 itens correspondem a um conjunto de dados de 20 Kbyte para a vers√£o com <i>uint8_t</i> e at√© 80 Kbytes para a vers√£o com <i>uint32_t</i> .  No primeiro caso, eles se encaixam idealmente no cache de n√≠vel L1 dos computadores modernos baseados em x86 e no segundo - n√£o.  Acontece que a vers√£o de 8 bits ter√° um avan√ßo devido ao armazenamento em cache eficiente? <br><br>  Finalmente, notamos que nossa tarefa √© muito semelhante ao caso cl√°ssico de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vetoriza√ß√£o autom√°tica</a> : em um loop com um n√∫mero conhecido de itera√ß√µes, uma opera√ß√£o aritm√©tica √© executada em elementos localizados seq√ºencialmente na mem√≥ria.  Nesse caso, a vers√£o de 8 bits deve ter uma enorme vantagem sobre a vers√£o de 32 bits, uma vez que uma opera√ß√£o vetorial processar√° quatro vezes mais elementos e, em geral, os processadores Intel executam opera√ß√µes vetoriais em elementos de byte √∫nico na mesma velocidade de 32 bits. elementos de bits. <br><br>  Tudo bem, pare de reclamar.  √â hora de voltar para o teste. <br><br><h2>  Refer√™ncia </h2><br>  Eu obtive os seguintes intervalos de tempo para vetores de 20.000 elementos nos <i>compiladores</i> <i>gcc 8</i> e <i>clang 8</i> com diferentes n√≠veis de otimiza√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/6r/k7/l_6rk7tnbeguzjnreatqtggsopg.png"></div><br>  Acontece que, com exce√ß√£o do n√≠vel <i>-O1</i> , a vers√£o com <i>uint32_t √©</i> mais r√°pida que a vers√£o com <i>uint8_t</i> e, em alguns casos, √© significativa: 5,4 vezes no gcc no n√≠vel <i>-O3</i> e exatamente 8 vezes no clang nos dois n√≠veis, <i>-O2</i> e <i>- O3</i>  Sim, o incremento de n√∫meros inteiros de 32 bits no <i>std :: vector</i> √© at√© oito vezes mais r√°pido que o incremento de n√∫meros inteiros de 8 bits no compilador popular com configura√ß√µes de otimiza√ß√£o padr√£o. <br><br>  Como sempre, passemos √† lista de montadores na esperan√ßa de que ela mostre o que est√° acontecendo. <br><br>  Aqui est√° uma lista para o gcc 8 no n√≠vel <i>-O2</i> , onde a vers√£o de 8 bits √© "apenas" 1,5 vezes mais lenta que a vers√£o de 32 bits (2): <br><br>  <b>8 bits:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] mov rdx, QWORD PTR [rdi] inc rax mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] sub rcx, rdx cmp rax, rcx jb .L3</code> </pre> <br>  <b>32 bits:</b> <br><pre> <code class="cpp hljs">.L9: inc DWORD PTR [rax] add rax, <span class="hljs-number"><span class="hljs-number">4</span></span> cmp rax, rdx jne .L9</code> </pre> <br>  A vers√£o de 32 bits se parece exatamente como esper√°vamos de um loop n√£o desenvolvido (3): um incremento (4) com um endere√ßo e tr√™s comandos de controle de loop: <i>add rax</i> , <i>4 - um</i> incremento da vari√°vel indutiva (5) e alguns comandos <i>cmp</i> e <i>jne</i> para verificar as condi√ß√µes de sa√≠da do loop e salto condicional nele.  Tudo parece √≥timo - a implanta√ß√£o compensaria o custo de incrementar o contador e verificar a condi√ß√£o, e nosso c√≥digo quase atingiria a velocidade m√°xima poss√≠vel de 1 elemento por ciclo de clock (6), mas para um aplicativo de c√≥digo aberto ser√° necess√°rio.  E a vers√£o de 8 bits?  Al√©m do comando <i>inc</i> com o endere√ßo, dois comandos adicionais para leitura da mem√≥ria s√£o executados, bem como o <i>subcomando</i> , que √© retirado do nada. <br><br>  Aqui est√° uma lista com coment√°rios: <br><br>  <b>8 bits:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] ;    v[i] mov rdx, QWORD PTR [rdi] ;  v.begin inc rax ; i++ mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  v.end sub rcx, rdx ; end - start (.. <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.size()) cmp rax, rcx ; i &lt; size() jb .L3 ; .   i &lt; size()</code> </pre> <br>  Aqui <i>vector :: begin</i> e <i>vector :: end</i> s√£o os ponteiros internos do <i>std :: vector</i> , usados ‚Äã‚Äãpara indicar o in√≠cio e o final da sequ√™ncia de elementos contidos na √°rea selecionada para ele (7), esses s√£o essencialmente os mesmos valores que s√£o usados ‚Äã‚Äãpara implementar <i>vector :: begin ()</i> e <i>vector :: end ()</i> (embora sejam de um tipo diferente).  Acontece que todos os comandos adicionais s√£o apenas uma consequ√™ncia do c√°lculo de <i>vector.size ()</i> .  Parece nada de anormal?  Mas, afinal, na vers√£o de 32 bits, √© claro, <i>size ()</i> tamb√©m <i>√©</i> calculado, no entanto, esses comandos n√£o estavam nessa lista.  O c√°lculo do <i>tamanho ()</i> aconteceu apenas uma vez - fora do loop. <br><br>  Ent√£o qual √© o problema?  A resposta curta √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alias do ponteiro</a> .  Vou dar uma resposta detalhada abaixo. <br><br><h2>  Resposta detalhada </h2><br>  O vetor <i>v √©</i> passado para a fun√ß√£o por refer√™ncia, que, de fato, √© um ponteiro mascarado.  O compilador deve ir aos membros <i>v :: begin</i> e <i>v :: end do</i> vetor para calcular seu tamanho <i>size ()</i> e, em nosso exemplo, <i>size () √©</i> calculado <i>a</i> cada itera√ß√£o.  Mas o compilador n√£o √© obrigado a obedecer cegamente ao c√≥digo-fonte: pode levar o resultado da chamada da fun√ß√£o <i>size ()</i> fora do loop, mas apenas se souber com certeza que a sem√¢ntica do programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o ser√° alterada</a> .  Desse ponto de vista, o √∫nico lugar problem√°tico no loop √© o incremento <i>v [i] ++</i> .  A grava√ß√£o ocorre em um endere√ßo desconhecido.  Essa opera√ß√£o pode alterar o valor de size ()? <br><br>  Se o registro ocorrer no <i>std :: vector &lt;uint32_t&gt;</i> (ou seja, pelo ponteiro <i>uint32_t *</i> ), ent√£o n√£o, ele n√£o poder√° alterar o valor <i>size ()</i> .  Gravar objetos do tipo <i>uint32_t</i> pode modificar apenas objetos do tipo <i>uint32_t</i> , e os ponteiros envolvidos no c√°lculo do <i>tamanho ()</i> t√™m um tipo diferente (8). <br><br>  No entanto, no caso de <i>uint8_t</i> , pelo menos nos compiladores populares (9), a resposta ser√° a seguinte: sim, teoricamente, o valor de <b><i>size ()</i></b> <b>pode mudar</b> , j√° que <i>uint8_t</i> √© um alias para <i>char n√£o assinado</i> e matrizes do tipo <i>char</i> (e <i>char</i> ) <i>n√£o assinado</i> podem <i>Alias ‚Äã‚Äãcom qualquer outro tipo</i> .  Isso significa que, de acordo com o compilador, escrever para <i>ponteiros uint8_t</i> pode modificar o conte√∫do da mem√≥ria de origem desconhecida em qualquer endere√ßo (10).  Portanto, assume que cada opera√ß√£o de incremento <i>v [i] ++</i> pode alterar o valor <i>size ()</i> e, portanto, √© for√ßado a recalcul√°-lo a cada itera√ß√£o do loop. <br><br>  Todos sabemos que gravar na mem√≥ria apontada por <i>std :: vector</i> nunca mudar√° seu pr√≥prio <i>tamanho ()</i> , porque isso significaria que o pr√≥prio vetor foi de alguma forma alocado dentro de sua pr√≥pria pilha, e isso √© praticamente imposs√≠vel e semelhante ao problema da galinha e dos ovos (11).  Mas infelizmente isso n√£o √© conhecido pelo compilador! <br><br><h2>  E o restante dos resultados? </h2><br>  Bem, descobrimos por que a vers√£o com <i>uint8_ √©</i> um pouco mais lenta que a vers√£o de <i>uint32_t</i> no gcc no n√≠vel <i>-O2</i> .  Mas por que explicar a enorme diferen√ßa - at√© 8 vezes - no clang ou no mesmo gcc no <i>-O3</i> ? <br><br>  Tudo √© simples aqui: no caso de <i>uint32_t, o</i> clang pode executar a auto-vetoriza√ß√£o de loop: <br><br><pre> <code class="cpp hljs">.LBB1_6: ; =&gt;This Inner Loop Header: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>], ymm4 vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>], ymm4 add rdi, <span class="hljs-number"><span class="hljs-number">64</span></span> add rsi, <span class="hljs-number"><span class="hljs-number">2</span></span> jne .LBB1_6</code> </pre> <br>  O ciclo foi implantado 8 vezes, e este √© geralmente o desempenho m√°ximo que voc√™ pode obter: um vetor (8 elementos) por ciclo de clock para o cache L1 (isso n√£o funcionar√° mais devido √† limita√ß√£o de uma opera√ß√£o de grava√ß√£o por ciclo de clock (12)). <br><br>  <i>A vetoriza√ß√£o</i> n√£o <i>√©</i> realizada para <i>uint8_t</i> , porque √© dificultada pela necessidade de calcular <i>size ()</i> para verificar a condi√ß√£o do loop a cada itera√ß√£o.  O motivo do atraso ainda √© o mesmo, mas o atraso em si √© muito maior. <br><br>  Os tempos mais baixos s√£o explicados pela auto-vetoriza√ß√£o: o gcc o aplica apenas no n√≠vel <i>-O3</i> , e o clang se aplica nos n√≠veis <i>-O2</i> e <i>-O3</i> por padr√£o.  O compilador gcc no n√≠vel -cc gera c√≥digo um pouco mais lento que o clang porque n√£o expande o loop autovectorizado. <br><br><h2>  Corrija a situa√ß√£o </h2><br>  Descobrimos qual √© o problema - como podemos corrigi-lo? <br><br>  Primeiro, vamos tentar uma maneira que, no entanto, n√£o funcione, a saber, escreveremos um ciclo mais idiom√°tico com base em um iterador: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(); i != v.end(); ++i) { (*i)++; }</code> </pre> <br>  O c√≥digo que o <i>gcc</i> gera no n√≠vel <i>-O2</i> ser√° um pouco melhor que a op√ß√£o com <i>size ()</i> : <br><br><pre> <code class="cpp hljs">.L17: add BYTE PTR [rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>], rax jne .L17</code> </pre> <br>  Duas opera√ß√µes extras de leitura se transformaram em uma, porque agora comparamos com o ponteiro <i>final</i> do vetor, em vez de recalcular o <i>tamanho ()</i> , subtraindo o ponteiro inicial do vetor do ponteiro final.  Pelo n√∫mero de instru√ß√µes, esse c√≥digo alcan√ßou <i>uint32_t</i> , pois a opera√ß√£o de leitura extra foi mesclada √† opera√ß√£o de compara√ß√£o.  No entanto, o problema n√£o desapareceu e a auto-vetoriza√ß√£o ainda n√£o est√° dispon√≠vel; portanto, o <i>uint8_t</i> ainda est√° significativamente atr√°s do <i>uint32_t</i> - mais de 5 vezes no gcc e no clang nos n√≠veis em que a auto-vetoriza√ß√£o √© fornecida. <br><br>  Vamos tentar outra coisa.  N√£o teremos sucesso novamente, ou melhor, encontraremos <i>outro</i> m√©todo inoperante. <br><br>  Nesta vers√£o, calculamos <i>size ()</i> apenas uma vez antes do loop e colocamos o resultado em uma vari√°vel local: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, s = v.size(); i &lt; s; i++) { v[i]++; }</code> </pre> <br>  Parece estar funcionando?  O problema era <i>size ()</i> , e agora pedimos ao compilador para confirmar o resultado de <i>size ()</i> com a vari√°vel local <i>s</i> no in√≠cio do loop, e as vari√°veis ‚Äã‚Äãlocais, como voc√™ sabe, n√£o se cruzam com outros dados.  Na verdade, fizemos o que o compilador n√£o podia fazer.  E o c√≥digo que ele ir√° gerar ser√° realmente melhor (comparado ao original): <br><br><pre> <code class="cpp hljs">.L9: mov rdx, QWORD PTR [rdi] add BYTE PTR [rdx+rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp rax, rcx jne .L9</code> </pre> <br>  H√° apenas uma opera√ß√£o de leitura extra e nenhum <i>subcomando</i> .  Mas o que esse comando extra ( <i>rdx, QWORD PTR [rdi]</i> ) faz se n√£o estiver envolvido no c√°lculo do tamanho?  Ele l√™ o ponteiro <i>data ()</i> de <i>v</i> ! <br><br>  A express√£o <i>v [i]</i> √© implementada como <i>* (v.data () + i)</i> , e o membro retornado por <i>data ()</i> (e, de fato, um ponteiro de <i>in√≠cio</i> regular) apresenta o mesmo problema que <i>size ()</i> .  √â verdade que eu n√£o notei essa opera√ß√£o na vers√£o original, porque estava "livre", porque ainda precisava ser executada para calcular o tamanho. <br><br>  Tenha um pouco mais, quase encontramos uma solu√ß√£o.  Voc√™ s√≥ precisa remover do nosso loop <i>todas as</i> depend√™ncias do conte√∫do do <i>std :: vector</i> .  A maneira mais f√°cil de fazer isso √© modificar um pouco nosso idioma com um iterador: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(), e = v.end(); i != e; ++i) { (*i)++; }</code> </pre> <br>  Agora tudo mudou drasticamente (aqui comparamos apenas vers√µes com <i>uint8_t</i> - em uma, salvamos o <i>final</i> do iterador em uma vari√°vel local <i>antes do</i> loop, na outra - n√£o): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/pe/xj/lppexj0vgqumpzvblxctc7xkkoa.png"></div><br>  Essa pequena mudan√ßa nos deu um aumento de 20 vezes na velocidade em n√≠veis com auto-vetoriza√ß√£o.  Al√©m disso, o c√≥digo com <i>uint8_t</i> n√£o apenas alcan√ßou o c√≥digo com <i>uint32_t</i> - ele o ultrapassou quase exatamente quatro vezes por gcc <i>-O3</i> e clang <i>-O2</i> e <i>-O3</i> , como esper√°vamos no in√≠cio, contando com vetoriza√ß√£o: no final, exatamente quatro vezes mais elementos podem ser processados ‚Äã‚Äãpor uma opera√ß√£o vetorial e precisamos de quatro vezes menos largura de banda - independentemente do n√≠vel do cache (13). <br><br>  Se voc√™ leu neste lugar, deve ter exclamado para si mesmo o tempo todo: <br><br>  <i>Mas e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>loop for com passagem de banda</i></a> introduzido no C ++ 11?</i> <br><br>  Apresso-me a agradar: funciona!  Na verdade, isso √© a√ß√∫car sint√°tico, por tr√°s do qual nossa vers√£o com um iterador est√° oculta quase na mesma forma, onde fixamos o ponteiro <i>final</i> em uma vari√°vel local antes do in√≠cio do loop.  Ent√£o a velocidade dele √© a mesma. <br><br>  Se de repente decid√≠ssemos voltar aos tempos antigos das cavernas e escrever uma fun√ß√£o do tipo C, esse c√≥digo funcionaria da mesma maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { a[i]++; } }</code> </pre> <br>  Aqui, o ponteiro para a matriz ae a vari√°vel <i>size</i> s√£o passados ‚Äã‚Äãpara a fun√ß√£o por valor, portanto, n√£o podem ser alterados como resultado da grava√ß√£o no ponteiro <i>a</i> (14) - assim como as vari√°veis ‚Äã‚Äãlocais.  O desempenho desse c√≥digo √© o mesmo das op√ß√µes anteriores. <br><br>  Finalmente, nos compiladores em que esta op√ß√£o est√° dispon√≠vel, voc√™ pode declarar um vetor com <i>__restrict</i> (15): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc_restrict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; __restrict v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <br>  A <i>palavra-chave __restrict</i> n√£o faz parte do padr√£o C ++, mas faz parte do padr√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C desde C99</a> (como <i>restrito</i> ).  Se ele for implementado como uma extens√£o C ++ no compilador, provavelmente obedecer√° √† sem√¢ntica de C. √â claro que n√£o h√° links em C; portanto, voc√™ pode substituir mentalmente o link para o vetor por um ponteiro para o vetor. <br><br>  Observe que restringir n√£o possui uma <i>propriedade</i> transitiva: a a√ß√£o do especificador <i>__restrict</i> , com a qual um link para <i>std :: vector √©</i> declarado, aplica-se apenas aos membros do pr√≥prio vetor e n√£o √† regi√£o de heap referenciada por <i>v.data ()</i> .  No nosso caso, n√£o √© necess√°rio mais, porque (como no caso de vari√°veis ‚Äã‚Äãlocais) √© suficiente para convencer o compilador de que os pr√≥prios termos, apontando para o in√≠cio e o fim do vetor, n√£o se cruzam com nada.  A cl√°usula sobre <i>restri√ß√£o</i> , no entanto, ainda √© relevante, pois a grava√ß√£o via <i>v.data ()</i> ainda pode fazer com que outros objetos em sua fun√ß√£o sejam alterados devido ao alias. <br><br><h2>  Decep√ß√£o </h2><br>  Aqui chegamos √† √∫ltima - e muito decepcionante - conclus√£o.  O fato √© que todas as solu√ß√µes mostradas acima s√£o aplic√°veis ‚Äã‚Äãapenas a este caso espec√≠fico, quando o vetor pode teoricamente interferir consigo mesmo.  A solu√ß√£o foi sair do loop ou isolar o resultado da chamada do <i>tamanho ()</i> ou <i>final () do</i> vetor, e <i>n√£o</i> informar ao compilador que a grava√ß√£o nos dados do vetor n√£o afeta outros dados.  √â dif√≠cil escalar esse c√≥digo √† medida que a fun√ß√£o cresce. <br><br>  O problema do aliasing n√£o desapareceu e os comandos de grava√ß√£o ainda podem ir a qualquer lugar - simplesmente n√£o h√° outros dados nessa fun√ß√£o que possam ser afetados ... por enquanto.  Assim que um novo c√≥digo aparecer, tudo ser√° repetido.  Aqui est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo de improviso</a> .  Se voc√™ escrever em matrizes de elementos do tipo <i>uint8_t</i> em pequenos loops, precisar√° lutar com o compilador at√© o final (16). <br><br><h2>  Coment√°rios </h2><br>  Ficarei feliz em qualquer feedback.  Eu ainda n√£o tenho um sistema de coment√°rios (17), portanto, como de costume, discutiremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste t√≥pico no HackerNews</a> . <br><br><ol><li>  Ao acessar a mem√≥ria aqui, entende-se que a cadeia de depend√™ncias passa pela mem√≥ria: comandos de grava√ß√£o no mesmo endere√ßo devem ler o √∫ltimo valor gravado nela, portanto, essas opera√ß√µes s√£o dependentes (na pr√°tica, o redirecionamento para carregamento (STLF) ser√° usado se a grava√ß√£o for suficiente frequentemente).  Depend√™ncias do comando <i>add</i> ao acessar a mem√≥ria podem ocorrer de outras maneiras, por exemplo, calculando o endere√ßo, mas para o nosso caso isso √© irrelevante. </li><li>  Apenas um pequeno ciclo √© mostrado aqui;  O c√≥digo de instala√ß√£o √© simples e funciona r√°pido.  Para ver a lista completa, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">carregue o c√≥digo no godbolt</a> . </li><li>  Talvez deva ser chamado simplesmente de "minimizado"?  Seja como for, o compilador gcc geralmente n√£o circula nem nos n√≠veis <i>-O2</i> e <i>-O3</i> , exceto em casos especiais em que o n√∫mero de itera√ß√µes √© pequeno e √© <i>conhecido no est√°gio de compila√ß√£o</i> .  Por esse motivo, o gcc mostra resultados de teste mais baixos em compara√ß√£o com o clang, mas economiza muito no tamanho do c√≥digo.  Voc√™ pode <i>for√ßar o gcc a desenrolar loops</i> aplicando a otimiza√ß√£o de perfil ou ativando o <i>sinalizador -funroll-loops</i> . </li><li>  Na verdade, o <i>comando inc DWORD PTR [rax]</i> no gcc √© uma otimiza√ß√£o perdida: quase sempre √© melhor usar o comando <i>add [rax], 1</i> , pois consiste em apenas 2 microopera√ß√µes combinadas versus 3 no <i>inc</i> .  Nesse caso, a diferen√ßa √© de apenas cerca de 6%, mas se o ciclo fosse ligeiramente expandido para que apenas a opera√ß√£o de grava√ß√£o fosse repetida, a diferen√ßa seria mais significativa (uma expans√£o adicional n√£o seria mais um papel, j√° que atingir√≠amos o limite de 1 opera√ß√£o de grava√ß√£o por ciclo, que n√£o depende do n√∫mero total de micro-opera√ß√µes). </li><li>  Chamo essa vari√°vel de <i>indutiva</i> , e n√£o apenas de <i>i</i> , como no c√≥digo-fonte, porque o compilador converteu as opera√ß√µes da unidade do incremento <i>i em</i> incrementos de 4 bytes do ponteiro armazenado no registro <i>rax</i> e, portanto, corrigiu a condi√ß√£o do loop.  Em sua forma original, nosso loop aborda os elementos do vetor e, ap√≥s essa convers√£o, incrementa o ponteiro / iterador, que √© uma maneira de <i>reduzir o custo das opera√ß√µes</i> . </li><li>  De fato, se voc√™ habilitar <i>-funroll-loops</i> , no gcc a velocidade ser√° de 1,08 medidas por elemento com um <i>lan√ßamento de 8x</i> .  Mas mesmo com esse sinalizador, ele <i>n√£o</i> expandir√° o loop da vers√£o com elementos de 8 bits, portanto o atraso na velocidade ser√° ainda mais percept√≠vel! </li><li>  Esses membros t√™m um modificador <i>privado</i> e seus nomes dependem da implementa√ß√£o, mas no stdlibc ++ eles n√£o s√£o realmente chamados de <i>in√≠cio</i> e <i>t√©rmino</i> , como no gcc.  Eles s√£o chamados <i>_Vector_base :: _ Vector_impl :: _ M_start</i> e <i>_Vector_base :: _ Vector_impl :: _ M_finish respectivamente</i> , ou seja,  insira a estrutura <i>_Vector_impl</i> , que √© membro de <i>_M_impl</i> (e o √∫nico) da classe <i>_Vector_base</i> e que, por sua vez, √© a classe base para <i>std :: vector</i> .  Bem, bem!  Felizmente, o compilador lida facilmente com essa pilha de abstra√ß√µes. </li><li>  O padr√£o n√£o prescreve quais devem ser os tipos internos dos membros <i>std :: vector</i> , mas na biblioteca libstdc ++ eles s√£o simplesmente definidos como <i>Alloc :: pointer</i> (onde <i>Alloc</i> √© o alocador do vetor) e, para o <i>objeto std :: alocado</i> padr√£o, eles simplesmente ponteiros do tipo <i>T *</i> , ou seja,  ponteiros regulares para um objeto - neste caso, <i>uint32_t *</i> . </li><li>  Estou fazendo esta reserva por um motivo.  Existe uma suspeita de que <i>uint8_t</i> possa ser considerado como um tipo diferente de <i>char</i> , <i>char assinado</i> e <i>char n√£o assinado</i> .  Como o alias funciona com <i>tipos de caracteres</i> , isso n√£o se aplica a <i>uint8_t</i> e deve se comportar como qualquer outro tipo que n√£o seja de caractere.  No entanto, nenhum dos compiladores que conhe√ßo pensam assim: em todos eles, <i>typedef</i> <i>uint8_t</i> √© um alias de <i>char n√£o assinado</i> , para que os compiladores n√£o vejam a diferen√ßa entre eles, mesmo que <i>desejem</i> us√°-lo. </li><li>  Por "origem desconhecida", quero dizer aqui apenas que o compilador n√£o sabe para onde o conte√∫do da mem√≥ria est√° apontando ou como ele apareceu.  Isso inclui ponteiros arbitr√°rios passados ‚Äã‚Äãpara a fun√ß√£o, bem como vari√°veis ‚Äã‚Äãglobais e est√°ticas.  , ,            ,  ,   ,     (    -     ). ,     <i>malloc</i>  <i>new</i> ,   <i></i>    ,      ,   ,        :  ,      ,       . ,       <i>malloc</i>  <i>new</i> . </li><li>  ,   <i>std::vector</i>  - <i></i> ? ,    <i>std::vector&lt;uint8_t&gt; a</i>     <i></i>  <i>a.data()</i>    <i>placement new</i>       <i>b</i> .   <i>std::swap(a, b)</i> ,       ‚Äì ,  <i>b</i>      ?       ,     <i>b</i> .       :          -  (,       ),      ,       . </li><li>        8 , ..  32 .     ,   <i>std::vector</i>      . </li><li> -        4 :     ,        ,   ‚Äì .       : 8-      L1,  32-        ‚Äì   L2    ,      . </li><li>        ,  ‚Äì  :        .      ,      ,    ¬´¬ª. </li><li>        <i>v[i]</i> ,           . </li><li>     . ,   ¬´¬ª ,          <i>uint8_t</i> .      , ,       ,  <i>uint8_t</i> ,          . ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   clang,      gcc</a> ,     ,    <i>uint8_t</i> . -     <i>gcc</i>          ,   .     ,     , -     <i>__restrict</i> . </li><li>  -  ,       ,      (   Disqus),           (        ),    . </li></ol><br> <i>     .  : Travis Downs. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Incrementing vectors</a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt475636/">https://habr.com/ru/post/pt475636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt475618/index.html">Como escrever um contrato Python inteligente na rede Ontology. Parte 2: API de armazenamento</a></li>
<li><a href="../pt475622/index.html">Estendendo o UObject no Unreal Engine 4</a></li>
<li><a href="../pt475624/index.html">PHP-Watcher: uma ferramenta que simplifica o desenvolvimento de aplicativos de longa dura√ß√£o</a></li>
<li><a href="../pt475626/index.html">Os autotestes podem substituir uma pessoa em busca de vulnerabilidades: entrevista com Alexandra Svatikova</a></li>
<li><a href="../pt475630/index.html">Knative - uma plataforma baseada em k8s como um servi√ßo com suporte sem servidor</a></li>
<li><a href="../pt475640/index.html">Se voc√™ estiver criando algo, evite a programa√ß√£o do gerente.</a></li>
<li><a href="../pt475642/index.html">Mecanismo de tuplas somente de heap no PostgreSQL</a></li>
<li><a href="../pt475646/index.html">Yuri Ryabtsev: "A primeira intercep√ß√£o de um m√≠ssil bal√≠stico √© um evento aproximadamente igual ao voo de Gagarin"</a></li>
<li><a href="../pt475652/index.html">Como desenvolvemos um aplicativo m√≥vel no sistema operacional Aurora (Sailfish Mobile OS RUS)</a></li>
<li><a href="../pt475654/index.html">‚ÄúNo primeiro m√™s, tr√™s homens saud√°veis ‚Äã‚Äãtiveram medo de ligar a turbina‚Äù - como Alexei Statsenko constr√≥i um jetpack a partir do zero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>