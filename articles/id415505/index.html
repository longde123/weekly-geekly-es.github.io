<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎓 🌃 ☣️ Cara Kerja JS: Penyimpanan 🏢 🧙🏾 👩🏻‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat merancang aplikasi web, sangat penting untuk memilih alat yang tepat untuk penyimpanan data lokal. Kita berbicara tentang mekanisme yang akan mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara Kerja JS: Penyimpanan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415505/">  Saat merancang aplikasi web, sangat penting untuk memilih alat yang tepat untuk penyimpanan data lokal.  Kita berbicara tentang mekanisme yang akan memungkinkan Anda untuk menyimpan informasi dengan andal, akan membantu mengurangi jumlah data yang ditransfer antara server dan bagian-bagian klien dari aplikasi, dan pada saat yang sama tidak akan memperburuk kecepatan reaksi aplikasi ke paparan pengguna.  Strategi yang dipikirkan dengan matang untuk caching data lokal merupakan pusat pengembangan aplikasi web seluler yang dapat bekerja tanpa koneksi internet.  Pengguna modern semakin mengacu pada peluang seperti itu sebagai sesuatu yang akrab dan diharapkan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/la/n1/in/lan1ins53simdcpwo_lfhyzq_uk.jpeg"></a> <br><br>  Hari ini, dalam terjemahan bagian 16 dari serangkaian materi yang ditujukan untuk segala sesuatu yang berhubungan dengan JavaScript, kita akan berbicara tentang mekanisme penyimpanan sisi klien yang dapat digunakan dalam pengembangan web, dan tentang memilih sistem penyimpanan untuk proyek tertentu. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">[Nasihat membaca] 19 bagian siklus lainnya</b> <div class="spoiler_text"> Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tinjauan umum mesin, mekanisme runtime, panggilan stack</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentang V8 internal dan optimasi kode</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengelola memori, empat jenis memori bocor dan berurusan dengannya</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Event Loop, Async, dan Five Ways untuk Meningkatkan Kode Anda dengan async / menunggu</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebSocket dan HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang harus dipilih?</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fitur dan ruang lingkup WebAssembly</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Web dan Lima Skenario Penggunaan</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Layanan</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemberitahuan push web</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lacak perubahan di DOM dengan MutationObserver</a> <br>  Bagian 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin rendering halaman web dan tip untuk mengoptimalkan kinerja mereka</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Animasi dengan CSS dan JavaScript</a> <br>  Bagian 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Pohon Sintaks Abstrak, Parsing dan Optimalisasi nya</a> <br>  Bagian 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara kerja JS: kelas dan warisan, transpilasi dalam Babel dan TypeScript</a> <br>  Bagian 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Penyimpanan</a> <br>  Bagian 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Shadow DOM Technology dan Komponen Web</a> <br>  Bagian 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Mekanisme Komunikasi WebRTC dan P2P</a> <br>  Bagian 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Elemen Kustom</a> </div></div><br><h2>  <font color="#3AC1EF">Model data</font> </h2><br>  Model data menentukan organisasi internal dari data yang disimpan.  Ini mempengaruhi semua aspek perangkat aplikasi web, itu berisi solusi, sering kompromi, di mana efektivitas aplikasi dan kemampuan sistem penyimpanan untuk menyelesaikan tugasnya tergantung.  Tidak ada pendekatan "terbaik" untuk merancang model data, tidak ada solusi universal yang cocok untuk semua aplikasi.  Pilihan model data didasarkan pada fitur dan kebutuhan aplikasi tertentu.  Pertimbangkan beberapa model penyimpanan data dasar dari mana Anda dapat memilih sesuatu yang cocok untuk proyek tertentu. <br><br><ul><li>  Model penyimpanan data terstruktur.  Saat menggunakan model ini, data disimpan dalam tabel dengan bidang yang telah ditentukan.  Pendekatan ini tipikal untuk sistem manajemen basis data berbasis SQL.  Sistem seperti itu diadaptasi dengan baik untuk bekerja dengannya menggunakan pertanyaan.  Contoh terkenal dari gudang data browser terstruktur adalah IndexedDB (meskipun itu adalah DBMS NoSQL). <br></li><li>  Model penyimpanan kunci / nilai.  Gudang untuk data yang diorganisasikan dalam bentuk pasangan kunci / nilai, dan DBMS NoSQL yang terkait dengannya, memberi pengembang kesempatan untuk menyimpan data yang tidak terstruktur dan mengambilnya dari toko dengan kunci unik mereka.  Penyimpanan seperti ini mirip dengan tabel hash dalam arti bahwa mereka memungkinkan Anda untuk mengatur akses ke data yang diindeks dari jenis buram.  Contoh bagus penyimpanan nilai / kunci nilai adalah API Cache di browser dan DBMS sisi server Apache Cassandra. <br></li><li>  Model untuk menyimpan data dalam urutan byte.  Menggunakan model sederhana ini, data disimpan sebagai urutan byte dengan panjang variabel.  Tugas organisasi internal dari data ini sepenuhnya diselesaikan pada tingkat aplikasi.  Model ini digunakan dalam sistem file dan gudang data yang diatur secara hierarkis seperti sistem penyimpanan cloud. <br></li></ul><br><h2>  <font color="#3AC1EF">Metode penyimpanan data yang persisten tersedia untuk peramban</font> </h2><br>  Metode penyimpanan yang digunakan dalam aplikasi web dapat dianalisis dalam hal waktu penyimpanan yang persisten dari data tersebut. <br><br><ul><li>  Penyimpanan data dalam sesi.  Data kategori ini disimpan hanya selama sesi web tertentu ada atau tab browser aktif.  Contoh mekanisme untuk menyimpan data sesi adalah SessionStorage API. <br></li><li>  Penyimpanan data pada perangkat tanpa mengacu pada masa pakai sesi.  Data ini disimpan pada perangkat tertentu dan di antara sesi, misalnya, ketika Anda menutup tab browser dengan halaman aplikasi web, itu tidak dihapus.  Contoh mekanisme untuk menyimpan data aplikasi web pada perangkat adalah Cache API. <br></li><li>  Penyimpanan data permanen menggunakan penyimpanan global.  Pendekatan ini melibatkan penyimpanan data yang tidak hilang di antara sesi dan tidak terikat ke perangkat tertentu.  Data tersebut dapat dibagi di antara berbagai perangkat oleh pengguna.  Sebagai hasilnya, ini adalah cara yang paling dapat diandalkan dan jangka panjang untuk menyimpan data.  Data tersebut tidak dapat disimpan pada perangkat itu sendiri, yang berarti bahwa beberapa jenis penyimpanan server harus digunakan untuk mengatur skema penyimpanan data tersebut.  Kami tidak akan membahas ini, karena tugas utama kami adalah mempertimbangkan cara menyimpan data aplikasi web pada perangkat. <br></li></ul><br><h2>  <font color="#3AC1EF">Penilaian Penyimpanan Sisi Klien</font> </h2><br>  Saat ini, ada banyak API peramban yang memungkinkan Anda mengatur penyimpanan data.  Kami akan melihat beberapa dari mereka dan membandingkannya untuk memudahkan Anda memilih API yang tepat. <br><br>  Untuk memulainya, bagaimanapun, mari kita membahas beberapa masalah umum yang harus dipertimbangkan sebelum memilih teknologi spesifik untuk menyimpan data.  Tentu saja, pertama-tama, Anda perlu memahami bagaimana aplikasi Anda akan digunakan, bagaimana dukungannya akan diatur, dan bagaimana ia direncanakan untuk mengembangkannya.  Pada saat yang sama, bahkan jika Anda memiliki jawaban yang jelas untuk pertanyaan-pertanyaan ini, Anda akhirnya dapat pergi ke beberapa opsi untuk sistem penyimpanan data, dari mana Anda harus memilih yang paling cocok.  Inilah yang harus Anda perhatikan ketika memilih sistem penyimpanan: <br><br><ul><li>  Dukungan browser.  Harus diingat bahwa yang terbaik adalah memilih API standar yang dikembangkan.  Mereka, pertama, memiliki umur yang agak panjang, dan kedua, mereka didukung oleh banyak browser.  Selain itu, API serupa biasanya memiliki dokumentasi yang baik dan komunitas pengembang yang aktif. <br></li><li>  Dukungan transaksi.  Terkadang penting bahwa ketika bekerja dengan repositori, set operasi terkait akan memiliki sifat atomisitas, yaitu, bahwa eksekusi set operasi akan berhasil jika semua operasi berhasil, atau jika setidaknya salah satu dari mereka gagal, itu akan gagal.  Basis data secara tradisional mendukung fitur ini dengan menggunakan model transaksi yang dapat digunakan untuk mengelompokkan pembaruan data terkait ke dalam blok sewenang-wenang. <br></li><li>  Operasi sinkron atau asinkron.  Beberapa API penyimpanan data bersifat sinkron, dalam arti bahwa operasi menyimpan atau memuat data dari API tersebut memblokir utas aktif hingga permintaan terkait diselesaikan.  Menggunakan API sinkron dapat menyebabkan pemblokiran utas utama, yang dapat mengakibatkan "rem" antarmuka pengguna.  Karena itu, jika mungkin, coba gunakan API asinkron. <br></li></ul><br><h2>  <font color="#3AC1EF">Perbandingan Penyimpanan</font> </h2><br>  Di bagian ini, kita akan melihat beberapa sistem penyimpanan yang ada tersedia untuk pengembang web dan membandingkannya sesuai dengan indikator yang dijelaskan di atas. <br><table><tbody><tr><th width="120">  <sup>API</sup> <sup><br></sup> </th><th width="155">  <sup>Model data</sup> <sup><br></sup> </th><th>  <sup>Metodologi penyimpanan</sup> <sup><br></sup> </th><th>  <sup>Dukungan browser</sup> <sup><br></sup> </th><th>  <sup>Dukungan transaksi</sup> <sup><br></sup> </th><th>  <sup>Sinkron atau asinkron</sup> <sup><br></sup> </th></tr><tr><td>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem file</a></sup> <sup><br></sup> </td><td>  <sup>Urutan byte</sup> <sup><br></sup> </td><td>  <sup>Perangkat</sup> <sup><br></sup> </td><td>  <sup>52%</sup> <sup><br></sup> </td><td>  <sup>Tidak</sup> <sup><br></sup> </td><td>  <sup>Tidak sinkron</sup> <sup><br></sup> </td></tr><tr><td>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyimpanan lokal</a></sup> <sup><br></sup> </td><td>  <sup>Kunci / nilai</sup> <sup><br></sup> </td><td>  <sup>Perangkat</sup> <sup><br></sup> </td><td>  <sup>93%</sup> <sup><br></sup> </td><td>  <sup>Tidak</sup> <sup><br></sup> </td><td>  <sup>Sinkron</sup> <sup><br></sup> </td></tr><tr><td>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyimpanan sesi</a></sup> <sup><br></sup> </td><td>  <sup>Kunci / nilai</sup> <sup><br></sup> </td><td>  <sup>Sesi</sup> <sup><br></sup> </td><td>  <sup>93%</sup> <sup><br></sup> </td><td>  <sup>Tidak</sup> <sup><br></sup> </td><td>  <sup>Sinkron</sup> <sup><br></sup> </td></tr><tr><td>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cookie</a></sup> <sup><br></sup> </td><td>  <sup>Data terstruktur</sup> <sup><br></sup> </td><td>  <sup>Perangkat</sup> <sup><br></sup> </td><td>  <sup>100%</sup> <sup><br></sup> </td><td>  <sup>Tidak</sup> <sup><br></sup> </td><td>  <sup>Sinkron</sup> <sup><br></sup> </td></tr><tr><td>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cache</a></sup> <sup><br></sup> </td><td>  <sup>Kunci / nilai</sup> <sup><br></sup> </td><td>  <sup>Perangkat</sup> <sup><br></sup> </td><td>  <sup>60%</sup> <sup><br></sup> </td><td>  <sup>Tidak</sup> <sup><br></sup> </td><td>  <sup>Tidak sinkron</sup> <sup><br></sup> </td></tr><tr><td>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Indexeddb</a></sup> <sup><br></sup> </td><td>  <sup>Model hibrida</sup> <sup><br></sup> </td><td>  <sup>Perangkat</sup> <sup><br></sup> </td><td>  <sup>83%</sup> <sup><br></sup> </td><td>  <sup>Ya</sup> <sup><br></sup> </td><td>  <sup>Tidak sinkron</sup> <sup><br></sup> </td></tr></tbody></table><br>  Sekarang mari kita bicara lebih banyak tentang metode penyimpanan data ini. <br><br><h2>  <font color="#3AC1EF">Sistem File API</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b11/dcf/dc9/b11dcfdc94781c5a0c66d6e8e72d24e2.png"></div><br>  Melalui penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FileSystem</a> API, aplikasi web dapat bekerja dengan area yang dipilih dari sistem file lokal pengguna.  Aplikasi ini dapat melihat konten penyimpanan, membuat file, melakukan operasi baca dan tulis. <br><br>  API ini terdiri dari bagian-bagian utama berikut: <br><br><ul><li> Mekanisme untuk mengelola file dan membaca file: <code>File/Blob</code> , <code>FileList</code> , <code>FileReader</code> <br></li><li>  Mekanisme untuk membuat file dan menulis data kepada mereka: <code>Blob</code> , <code>FileWriter <br></code> <code>FileWriter <br></code> </li><li>  Mekanisme untuk bekerja dengan direktori dan sistem file: <code>DirectoryReader</code> , <code>FileEntry</code> / <code>DirectoryEntry</code> , <code>LocalFileSystem</code> <br></li></ul><br>  <code>FileSystem</code> API tidak standar, jadi tidak boleh digunakan dalam produksi, karena itu tidak akan berfungsi untuk semua pengguna.  Berbagai implementasi API ini dapat sangat bervariasi, dan sangat mungkin akan berubah di masa mendatang. <br><br>  Antarmuka <code>filesystem</code> API ini digunakan untuk mewakili sistem file.  Akses ke objek terkait dapat diperoleh melalui properti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">filesystem</a> .  Beberapa browser menawarkan API tambahan untuk membuat dan mengelola sistem file. <br><br>  Antarmuka ini tidak memberikan akses halaman web ke sistem file pengguna.  Sebagai gantinya, ini memungkinkan Anda untuk bekerja dengan sesuatu seperti disk virtual, yang terletak di kotak pasir yang dibuat oleh browser.  Jika aplikasi Anda membutuhkan akses ke sistem file pengguna, Anda harus menggunakan mekanisme lain. <br><br>  Aplikasi web dapat meminta akses ke sistem file virtual dengan memanggil <code>window.requestFileSystem()</code> : <br><br><pre> <code class="hljs pgsql">// :    Google Chrome <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.requestFileSystem = <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.requestFileSystem || <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.webkitRequestFileSystem; <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.requestFileSystem(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, size, successCallback, opt_errorCallback)</code> </pre> <br>  Jika Anda memanggil <code>requestFileSystem()</code> untuk pertama kalinya, repositori baru akan dibuat untuk aplikasi Anda.  Penting untuk diingat bahwa ini adalah penyimpanan yang terisolasi, yaitu, satu aplikasi web tidak dapat bekerja dengan penyimpanan yang dibuat oleh aplikasi lain. <br><br>  Setelah Anda mendapatkan akses ke sistem file, Anda dapat melakukan sebagian besar operasi standar dengan file dan direktori. <br><br>  <code>FileSystem</code> API sangat berbeda dari sistem serupa lainnya yang digunakan oleh aplikasi web, karena ditujukan untuk menyelesaikan tugas penyimpanan data pada klien, yang tidak diselesaikan dengan baik oleh alat database.  Secara umum, ini adalah aplikasi yang bekerja dengan fragmen besar data biner, atau bertukar data dengan aplikasi di luar browser. <br><br>  Di antara opsi untuk menggunakan <code>FileSystem</code> API adalah sebagai berikut: <br><br><ul><li>  Sistem unggah data.  Ketika seorang pengguna memilih file atau folder untuk diunggah ke server, data ini disalin ke penyimpanan terisolasi lokal, dan kemudian, di bagian, dikirim ke server. <br></li><li>  Aplikasi yang menangani sejumlah besar data multimedia - permainan, pemutar musik. <br></li><li>  Aplikasi pengeditan suara dan gambar yang bekerja tanpa koneksi internet atau menggunakan cache lokal yang besar untuk mempercepat pekerjaan.  Data yang digunakan oleh aplikasi tersebut adalah urutan byte yang bisa sangat besar.  Penyimpanan untuk data tersebut harus mendukung kemampuan untuk menulis dan membacanya. <br></li><li>  Pemutar video offline.  Program semacam itu perlu mengunduh file besar yang dapat dilihat tanpa koneksi internet.  Ini mungkin diperlukan saat streaming data, dan untuk mengatur sistem yang nyaman untuk bergerak di sekitar file. <br></li><li>  Klien email offline.  Program semacam itu dapat mengunduh file yang dilampirkan ke email dan menyimpannya secara lokal. <br></li></ul><br>  Ini adalah bagaimana browser mendukung API <code>FileSystem</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ea/cce/45a/2eacce45a484e712449a4b01ec412815.png"></div><br>  <i><font color="#999999">Dukungan untuk FileSystem API oleh browser</font></i> <br><br><h2>  <font color="#3AC1EF">API Penyimpanan Lokal</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/565/a4e/8a3565a4e7360dcde7a4e62161559d59.png"></div><br>  API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LocalStorage</a> , atau penyimpanan lokal, memungkinkan Anda untuk bekerja dengan objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyimpanan</a> objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumen</a> , dengan mempertimbangkan prinsip dari sumber yang sama.  Data tidak hilang di antara sesi.  API <code>LocalStorage</code> mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SessionStorage</a> API, penyimpanan sesi, perbedaannya adalah bahwa data dalam penyimpanan sesi dihapus setelah sesi halaman berakhir, dan data dalam penyimpanan lokal disimpan secara permanen. <br><br>  Harap dicatat bahwa data yang berlokasi di lokal atau di penyimpanan sesi terikat ke sumber halaman, yang ditentukan oleh kombinasi protokol, host dan port. <br>  Berikut adalah <code>LocalStorage</code> informasi dukungan <code>LocalStorage</code> browser <code>LocalStorage</code> untuk berbagai browser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/909/6c9/2f6/9096c92f691fdd5283ea394645afaba5.png"></div><br>  <i><font color="#999999">Dukungan untuk LocalStorage API oleh browser</font></i> <br><br><h2>  <font color="#3AC1EF">API SessionStorage</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SessionStorage</a> API memungkinkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda</a> untuk bekerja dengan objek sesi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyimpanan</a> .  <code>SessionStorage</code> API mirip dengan API <code>LocalStorage</code> yang kita bicarakan di atas.  Perbedaan di antara mereka, sebagaimana telah disebutkan, adalah dalam waktu penyimpanan data, yaitu, dalam kasus <code>SessionStorage</code> data disimpan selama sesi berlangsung.  Itu berlangsung sampai browser terbuka, sementara itu tetap setelah halaman dimuat ulang.  Membuka halaman di tab atau jendela baru akan memulai sesi baru, ini berbeda dari perilaku cookie sesi.  Pada saat yang sama, saat bekerja dengan <code>SessionStorage</code> , dan dengan <code>LocalStorage</code> , orang harus ingat bahwa data dalam penyimpanan tersebut terikat ke sumber halaman. <br><br>  Berikut adalah beberapa dukungan browser untuk <code>SessionStorage</code> API: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/909/6c9/2f6/9096c92f691fdd5283ea394645afaba5.png"></div><br>  <i><font color="#999999">Dukungan Browser SessionStorage API</font></i> <br><br><h2>  <font color="#3AC1EF">API Cookie</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/993/e32/f6e/993e32f6ede5ebc9a497f4d88ec04caf.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cookie</a> (cookie, cookie web, cookie browser) adalah informasi kecil yang dikirimkan oleh server ke browser.  Browser dapat menyimpannya dan mengirimkannya ke server, menggunakannya saat membuat permintaan.  Mereka biasanya digunakan untuk mengidentifikasi instance browser tertentu dari mana permintaan sedang dikirim.  Misalnya, agar pengguna, setelah memasuki sistem, tetap di dalamnya.  Cookie adalah sejenis sistem penyimpanan informasi status sesi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol HTTP</a> yang menangani setiap permintaan, bahkan yang berasal dari browser yang sama, sama sekali tidak tergantung pada yang lain. <br><br>  Cookie digunakan untuk menyelesaikan tiga tugas utama: <br><br><ul><li>  Manajemen Sesi.  Penggunaan cookie didasarkan pada mekanisme seperti sistem entri ke aplikasi web, keranjang belanja di toko online, penyimpanan poin yang diperoleh di game browser.  Ini adalah tentang menyimpan segala sesuatu yang perlu diketahui server saat pengguna bekerja dengannya. <br></li><li>  Personalisasi  Cookie digunakan untuk menyimpan data tentang preferensi pengguna, tentang tema yang ia pilih untuk mendesain situs, dan tentang hal-hal serupa lainnya. <br></li><li>  Pemantauan pengguna.  Cookie merekam dan menganalisis perilaku pengguna. <br></li></ul><br>  Pada suatu waktu, cookie digunakan sebagai gudang data tujuan umum.  Meskipun ini adalah cara yang benar-benar normal untuk menggunakan cookie, terutama ketika mereka adalah satu-satunya cara untuk menyimpan data pada klien, tidak disarankan untuk menggunakannya seperti pada zaman kita, lebih memilih API yang lebih modern.  Cookie dikirimkan dengan setiap permintaan, sehingga dapat menurunkan kinerja (terutama pada perangkat seluler). <br><br>  Ada dua jenis cookie: <br><br><ul><li>  Cookie sesi.  Mereka dihapus setelah sesi.  Browser web dapat menggunakan teknik pemulihan sesi, karena sebagian besar cookie sesi disimpan secara permanen, sebagai akibat dari sesi mereka disimpan bahkan setelah menutup dan memulai kembali browser dan membuka halaman yang sesuai. <br></li><li>  Cookie permanen.  Cookies persisten tidak kehilangan relevansi setelah sesi.  Mereka memiliki periode penyimpanan tertentu, yang ditentukan oleh tanggal tertentu (atribut <code>Expires</code> ) atau periode waktu tertentu (atribut <code>Max-Age</code> ). <br></li></ul><br>  Harap perhatikan bahwa informasi rahasia atau penting lainnya tidak boleh disimpan dalam cookie atau dikirim dalam cookie HTTP, karena seluruh mekanisme bekerja dengan cookie secara inheren tidak aman. <br><br>  Jika kami berbicara tentang dukungan cookie, maka, karena Anda mungkin sudah mengerti, semua browser mendukungnya. <br><br><h2>  <font color="#3AC1EF">API Cache</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/4b5/7f5/be64b57f578a10949a619f5450579a72.png"></div><br>  Antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cache</a> menyediakan mekanisme penyimpanan data untuk pasangan objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permintaan</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Respons yang di</a> -cache.  Antarmuka ini didefinisikan dalam spesifikasi yang sama dengan pekerja layanan, tetapi dapat diakses tidak hanya untuk pekerja.  Antarmuka <code>Cache</code> juga tersedia dalam lingkup objek <code>window</code> , tidak perlu menggunakannya hanya dengan pekerja layanan. <br><br>  Sumber tertentu mungkin memiliki beberapa objek <code>Cache</code> bernama.  Pengembang bertanggung jawab untuk mengimplementasikan bagaimana skripnya (misalnya, pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerja layanan</a> ) menjaga cache tetap up to date.  Item yang disimpan dalam cache tidak diperbarui hingga permintaan eksplisit untuk memperbaruinya dibuat, periode penyimpanannya tidak kedaluwarsa, mereka hanya dapat dihapus dari cache.  Untuk membuka objek cache bernama, Anda dapat menggunakan perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CacheStorage.open ()</a> , setelah itu Anda dapat mengakses perintah manajemen cache dengan mengaksesnya. <br><br>  Selain itu, pengembang bertanggung jawab untuk membersihkan cache secara berkala.  Setiap browser memiliki batasan hard-kode pada ukuran cache yang dialokasikan untuk sumber tertentu.  Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StorageEstimate</a> API untuk mengetahui perkiraan kuota cache. <br><br>  Browser melakukan segala daya untuk mempertahankan sejumlah ruang cache yang tersedia, tetapi dapat menghapus cache untuk beberapa sumber.  Biasanya, browser menghapus seluruh cache, atau tidak memedulikannya sama sekali.  Saat menggunakan cache, jangan lupa untuk membedakannya sesuai dengan versi skrip Anda, misalnya, termasuk versi skrip dalam nama cache.  Ini dilakukan untuk memastikan operasi yang aman dari berbagai versi skrip dengan cache.  Detail dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CacheStorage</a> menyediakan penyimpanan untuk objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cache</a> .  Berikut adalah tugas-tugas yang menjadi tanggung jawab antarmuka ini: <br><br><ul><li>  Memberikan daftar semua cache bernama yang dapat digunakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerja layanan</a> , atau jenis pekerja lain.  Anda juga dapat bekerja dengan cache melalui objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jendela</a> . <br></li><li>  Mendukung pemetaan antara nama string dan objek yang sesuai dari tipe <code>Cache</code> . <br></li></ul><br>  Untuk mendapatkan instance dari objek <code>Cache</code> , gunakan perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CacheStorage.open ()</a> . <br><br>  Untuk mengetahui apakah objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permintaan</a> tertentu adalah kunci dari objek <code>Cache</code> dikelola oleh <code>CacheStorage</code> , gunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CacheStorage.match ()</a> . <br><br>  <code>CacheStorage</code> dapat mengakses <code>CacheStorage</code> melalui properti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cache</a> global. <br><br><h2>  <font color="#3AC1EF">API IndexedDB</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/712/126/d96/712126d960e2558228bd6241b67681c6.png"></div><br>  API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IndexedDB</a> adalah DBMS yang memungkinkan Anda menyimpan data menggunakan browser.  Karena ini memungkinkan Anda untuk membuat aplikasi web yang memiliki kemampuan untuk bekerja dengan set data yang kompleks bahkan tanpa koneksi Internet, aplikasi tersebut dapat terasa sama baik dengan dan tanpa koneksi ke server.  IndexedDB digunakan dalam aplikasi yang perlu menyimpan data dalam jumlah besar (misalnya, aplikasi seperti itu mungkin seperti katalog film dari layanan sewa tertentu), dan yang tidak perlu mempertahankan koneksi konstan ke jaringan untuk operasi normal (misalnya, ini adalah klien email , task manager, notebook, dan sebagainya). <br><br>  Di sini kita akan membayar IndexedDB sedikit lebih banyak perhatian daripada teknologi penyimpanan data klien lainnya, karena, di satu sisi, API lain lebih dikenal luas, dan di sisi lain, karena DBed IndexedDB menjadi lebih dan lebih populer karena semakin kompleksnya aplikasi web . <br><br><h3>  <font color="#3AC1EF">▍ Mekanisme internal IndexedDB</font> </h3><br>  API <code>IndexedDB</code> memungkinkan Anda untuk menyimpan data objek menggunakan "kunci" ke dalam basis data dan membacanya.  Semua perubahan yang dilakukan pada basis data terjadi dalam transaksi.  Seperti kebanyakan solusi semacam itu, IndexedDB mengikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebijakan satu sumber</a> .  Akibatnya, aplikasi hanya dapat mengakses data milik domainnya sendiri, tetapi bukan data dari domain lain. <br><br>  <code>IndexedDB</code> adalah API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asinkron</a> yang dapat digunakan di sebagian besar konteks, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerja web</a> .  Sebelumnya, ada versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinkron</a> dari API ini yang ditujukan untuk pekerja web, tetapi dihapus dari spesifikasi karena fakta bahwa itu tidak terlalu menarik bagi pengembang web. <br><br>  <code>IndexedDB</code> memiliki pesaing dalam menghadapi database WebSQL, tetapi pekerjaan pada standar ini dihentikan oleh W3C beberapa tahun yang lalu.  Walaupun IndexedDB dan WebSQL adalah solusi untuk menyimpan data pada klien, fungsinya berbeda.  WebSQL adalah DBMS relasional, dan IndexedDB adalah sistem berdasarkan tabel yang diindeks. <br><br>  Anda seharusnya tidak mulai bekerja dengan IndexedDB, berdasarkan ide yang dipelajari dari pengalaman dengan DBMS lainnya.  Sebagai gantinya, akan bermanfaat untuk membaca dokumentasi untuk database ini dengan cermat dan menggunakan metode yang dirancang untuk bekerja dengannya.  Berikut ini adalah ikhtisar singkat tentang konsep dasar IndexedDB: <br><br><ul><li>  Database IndexedDB menyimpan data dalam format kunci / nilai.  Nilai dapat berupa objek terstruktur yang kompleks, dan kunci dapat menjadi properti dari objek tersebut.  Indeks dapat dibuat berdasarkan properti objek apa pun, yang dapat mempercepat pencarian data dan menyederhanakan penyortirannya.  Kunci juga objek biner. <br></li><li>  IndexedDB DBMS dibangun berdasarkan model transaksional.  Semua operasi yang dilakukan dengan database selalu terjadi dalam konteks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transaksi</a> .  Akibatnya, misalnya, Anda tidak dapat menjalankan perintah atau membuka kursor di luar transaksi.  Selain itu, transaksi dikonfirmasi secara otomatis, mereka tidak dapat dikonfirmasi secara manual. <br></li><li>  API IndexedDB, untuk sebagian besar, tidak sinkron.  API ini tidak menyediakan data yang diminta, hanya mengembalikannya sebagai respons terhadap beberapa perintah.  Sebaliknya, saat meminta data, Anda harus meneruskan fungsi panggilan balik ke metode yang sesuai.  Pendekatan sinkron tidak digunakan untuk menyimpan data ke database atau memuatnya.  Sebagai gantinya, aplikasi membuat kueri basis data yang menjelaskan operasi yang diperlukan.  Setelah operasi selesai, suatu peristiwa terjadi yang memberi tahu aplikasi bahwa operasi itu selesai atau tidak.  Pendekatan ini tidak terlalu berbeda dari API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XMLHttpRequest</a> , atau banyak mekanisme JavaScript lainnya. <br></li><li>  IndexedDB menggunakan banyak pertanyaan.  Permintaan adalah objek yang menerima acara tentang keberhasilan atau kegagalan operasi.  Mereka memiliki properti <code>onsuccess</code> dan <code>onerror</code> yang Anda dapat menetapkan pendengar untuk acara yang sesuai, serta <code>readyState</code> , <code>result</code> , <code>errorCode</code> , yang dapat dianalisis untuk mengetahui status permintaan. <br></li><li>  IndexedDB adalah database berorientasi objek.  Ini bukan DBMS relasional yang tabelnya adalah kumpulan baris dan kolom.  Fitur mendasar ini memengaruhi cara Anda mendesain dan membangun aplikasi menggunakan IndexedDB. <br></li><li>  IndexedDB tidak menggunakan SQL.  DBMS ini menerapkan kueri indeks yang mengembalikan kursor yang digunakan untuk bekerja dengan kumpulan data yang merupakan hasil kueri.  Jika Anda tidak terbiasa dengan sistem NoSQL, lihat materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br></li><li>  Penyimpanan IndexedDB menerapkan kebijakan sumber tunggal.  Sumber adalah kombinasi dari domain, protokol, dan URL port dari dokumen tempat skrip dieksekusi.  Setiap sumber hanya dapat bekerja dengan set databasenya sendiri, sementara masing-masing database memiliki nama unik yang mengidentifikasinya dalam database dari satu sumber. <br></li></ul><br><h3>  <font color="#3AC1EF">▍ Keterbatasan IndexedDB</font> </h3><br>  Sistem IndexedDB dirancang dengan harapan bahwa kemampuannya harus memadai untuk menyelesaikan sebagian besar tugas penyimpanan data di sisi klien.  Jelas bahwa ini bukan sistem universal yang cocok untuk kasus penggunaan apa pun.  Berikut adalah beberapa situasi yang tidak dirancang: <br><br><ul><li>  Menyortir data sesuai dengan karakteristik berbagai bahasa.  Tidak dalam semua bahasa, string diurutkan dengan cara yang sama, dan IndexedDB tidak mendukung pengurutan berdasarkan karakteristik berbagai bahasa.  Pada saat yang sama, meskipun database tidak dapat melakukan penyortiran seperti itu, informasi yang diperoleh dari database dapat disortir oleh aplikasi. <br></li><li>  Sinkronkan  API tidak dirancang dengan mempertimbangkan kemungkinan sinkronisasi database lokal dengan server.  Sinkronisasi seperti itu, tentu saja, dimungkinkan, tetapi pengembang harus menerapkan mekanisme yang sesuai secara mandiri. <br></li><li>  Pencarian teks lengkap.  API IndexedDB tidak mendukung sesuatu seperti pernyataan LIKE dari SQL. <br></li></ul><br>  Selain itu, ketika bekerja dengan IndexedDB, perlu diingat bahwa browser dapat menghapus database dalam kasus berikut: <br><br><ul><li>  Pengguna memberi perintah untuk menghapus data.  Banyak browser memiliki bagian pengaturan, di mana ada alat yang memungkinkan pengguna untuk menghapus semua data yang disimpan untuk situs web, termasuk cookie, bookmark, kata sandi yang disimpan, dan data IndexedDB. <br></li><li>  Browser berfungsi dalam mode anonim.  Mode seperti itu disebut berbeda di browser yang berbeda.  Di Chrome itu adalah "mode penyamaran", di Firefox itu adalah "mode pribadi".  Setelah sesi anonim berakhir, browser akan menghapus database. <br></li><li>  Disk overflow atau mencapai batas yang telah ditentukan. <br></li><li>  Korupsi data. <br></li></ul><br>  Secara umum, dapat dicatat bahwa pengembang browser berusaha untuk tidak menghapus database IndexedDB kecuali benar-benar diperlukan. <br><br>  Berikut adalah informasi tentang dukungan IndexedDB di berbagai browser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16d/a19/deb/16da19deb20c440cb449356cb1f2ae60.png"></div><br>  <i><font color="#999999">Dukungan untuk IndexedDB oleh berbagai browser</font></i> <br><br><h2>  <font color="#3AC1EF">Memilih Sistem Penyimpanan</font> </h2><br>  Seperti yang telah disebutkan, mengingat kebutuhan aplikasi, yang terbaik adalah memilih sistem penyimpanan yang memiliki dukungan browser luas dan bekerja dalam mode asinkron, yang meminimalkan dampaknya pada antarmuka pengguna.  Kriteria ini secara alami mengarah pada teknologi berikut: <br><br><ul><li>  Untuk penyimpanan informasi offline, gunakan API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cache</a> .  Ini tersedia di browser apa pun yang mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerja layanan</a> , yang diperlukan untuk membuat aplikasi web yang dapat bekerja tanpa koneksi internet.  API Cache adalah pilihan ideal untuk menyimpan sumber daya tertentu yang terkait dengan halaman. <br></li><li>  Untuk menyimpan data yang membentuk keadaan aplikasi, atau beberapa informasi yang dibuat oleh pengguna, gunakan IndexedDB.  Teknologi ini, dibandingkan dengan caching, mendukung lebih banyak browser, yang memperluas kemampuan pengguna aplikasi berdasarkan IndexedDB untuk bekerja offline. <br></li></ul><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SessionStack</a>   API   . , ,   -      ,     . ,     ,    ,  -    . <br><br>  <b>Pembaca yang budiman!</b>            -? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415505/">https://habr.com/ru/post/id415505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415489/index.html">Facebook menutup proyek distribusi Internet dengan menggunakan drone pada energi matahari</a></li>
<li><a href="../id415493/index.html">Sebuah perhitungan baru dengan rumus Drake menunjukkan: manusia berada di galaksi dengan probabilitas 53-99,6%</a></li>
<li><a href="../id415495/index.html">Sistem CRM: alat untuk bisnis 80 lvl</a></li>
<li><a href="../id415499/index.html">Bagaimana Berhenti Menjadi Takut pada Proguard dan Mulai Hidup</a></li>
<li><a href="../id415501/index.html">Ruang Virtual The Hermitage - Langkah Pertama Menuju Masa Depan oleh Pelevin</a></li>
<li><a href="../id415509/index.html">Pembelajaran mendalam dalam pemrograman: apa, mengapa dan bagaimana</a></li>
<li><a href="../id415527/index.html">Konferensi DUMP 2018: video semua laporan dan presentasi</a></li>
<li><a href="../id415529/index.html">Juli Acara IT Digest</a></li>
<li><a href="../id415533/index.html">Buku "Pemrograman untuk anak-anak. Program Gores pertama saya »</a></li>
<li><a href="../id415535/index.html">Asterisk + AMI + Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>