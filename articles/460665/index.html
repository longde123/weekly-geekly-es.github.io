<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äç‚öñÔ∏è üßîüèæ üë®üèª‚Äçüé® Preguntas frecuentes preliminares: ¬øPor qu√© los est√°ndares C ++ salen cada tres a√±os? üê¶ üë®üèª‚Äçüç≥ üëò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WG21 tiene un calendario estricto (ver P1000 ) para el lanzamiento est√°ndar cada tres a√±os. Y sin demoras. 

 Durante cada ciclo, recibimos regularmen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Preguntas frecuentes preliminares: ¬øPor qu√© los est√°ndares C ++ salen cada tres a√±os?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/460665/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/9v/zg/u29vzg2wz-7letn3lbp4ulyk9um.jpeg" width="400"></div><br>  WG21 tiene un calendario estricto (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1000</a> ) para el lanzamiento est√°ndar cada tres a√±os.  Y sin demoras. <br><br>  Durante cada ciclo, recibimos regularmente preguntas "¬øPor qu√© es tan estricto?", Especialmente de los nuevos miembros del comit√© que no est√°n familiarizados con su historia y las razones del estado actual de las cosas.  Y durante una teleconferencia preliminar con la administraci√≥n de Colonia, varias personas recomendaron describir por qu√© est√°bamos haciendo esto y c√≥mo se tom√≥ la decisi√≥n de adoptar este horario. <br><br>  Pint√© todo esto en forma de preguntas y respuestas para el pr√≥ximo borrador de P1000, y envi√© una copia a los miembros del comit√© camino a Colonia.  Este material se publicar√° en la pr√≥xima versi√≥n p√∫blica de P1000, lo enviaremos en unas pocas semanas a partir del momento actual. <br><br>  Sin embargo, el borrador de preguntas frecuentes puede ser de inter√©s para el p√∫blico, por lo que le ofrezco una copia.  Espero que en su mayor parte le sea √∫til, iluminarse de alguna manera y tal vez incluso entretener un poco. <br><br><a name="habracut"></a><br><h2>  Hay errores en el est√°ndar, ¬ødeber√≠a posponer C ++ 20? </h2><br>  Por supuesto que si y no. <br><br>  Nos estamos moviendo en una direcci√≥n determinada a una velocidad elegida: las correcciones de errores est√°n planificadas para este √∫ltimo a√±o, por lo que el programa a principios de C ++ "19" (Kona) establece una fecha l√≠mite para detener la adici√≥n de caracter√≠sticas en C ++ "20" para que tuvimos un a√±o para corregir errores, incluido trabajar con comentarios de diferentes pa√≠ses este verano.  Antes del comienzo de 2020 (reuniones en Colonia, Belfast y Praga), debemos dar retroalimentaci√≥n y aplicar cualquier otra soluci√≥n a los problemas, as√≠ como la correcci√≥n de errores. <br><br><h2>  Si tenemos una o dos reuniones m√°s, entonces podr√≠amos agregar un &lt;nombre de la funci√≥n&gt;, que est√° casi listo, ¬ødeber√≠a posponer C ++ 20? </h2><br>  Por supuesto que si y no. <br><br>  Espere a que se celebren un par de reuniones m√°s (despu√©s de Praga), y C ++ 23 estar√° abierto para los negocios, y en primer lugar votaremos para agregar &lt;nombre de la caracter√≠stica&gt; al borrador de trabajo de C ++ 23.  Esto es lo que hicimos con los conceptos: no estaban listos para la transici√≥n de TS directamente a C ++ 17.  Por lo tanto, en la primera reuni√≥n sobre C ++ 20 (en Toronto), votaron para transferir la funcionalidad b√°sica de los conceptos al borrador de C ++ 20, que dio mucho tiempo para mejorar y refinar el resto de la parte contradictoria de la sintaxis TS (no "plantilla"), que se introdujo el a√±o que viene (San Diego).  Ahora toda la funcionalidad est√° lista. <br><br><h2>  Esto parece ser demasiado estricto.  ¬øPor qu√© publicar versiones IS a intervalos fijos (tres a√±os)? </h2><br>  Porque en el caso del lanzamiento de C ++ IS, esta es una de las dos opciones principales para la gesti√≥n de proyectos, y la experiencia muestra que esta opci√≥n es mejor que la segunda. <br><br><h2>  ¬øCu√°les son las dos opciones para la gesti√≥n de proyectos para el lanzamiento de C ++ IS? </h2><br>  Me alegra que hayas preguntado. <br><br>  En el caso de un lanzamiento, hay dos opciones principales: elegir una funci√≥n o una fecha de lanzamiento, y cuando selecciona una, pierde el control sobre la definici√≥n de la otra.  No puedes controlar simult√°neamente ambos.  En resumen: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Si lo controlamos <br></th><th>  Dejaremos de controlarlo <br></th><th>  ¬øPodemos trabajar en caracter√≠sticas "grandes" de varios a√±os? <br></th><th> ¬øCu√°ndo agregamos caracter√≠sticas al borrador IS? <br></th><th>  ¬øQu√© hacemos si encontramos problemas con las funciones adicionales? <br></th></tr><tr><td>  <b>"Qu√©": caracter√≠sticas que enviamos</b> <br></td><td>  "Cu√°ndo": fecha de lanzamiento. <br></td><td>  S√≠, en los documentos con las propuestas y el borrador IS. <br></td><td>  Por lo general, antes para realizar m√°s pruebas de integraci√≥n ‚Üí se reduce la estabilidad promedio del borrador de trabajo. <br></td><td>  Retrasamos el lanzamiento del est√°ndar. <br></td></tr><tr><td>  <b>Cu√°ndo: fecha de lanzamiento</b> <br></td><td>  "Qu√©": caracter√≠sticas que enviamos <br></td><td>  S√≠, en documentos con ofertas y "ramas de caracter√≠sticas" en TS. <br></td><td>  Generalmente m√°s tarde, cuando la caracter√≠stica se resuelve mejor ‚Üí aumenta la estabilidad promedio del borrador de trabajo. <br></td><td>  Eliminamos la funci√≥n, luego podemos agregarla nuevamente si est√° lista para cuando se env√≠e el pr√≥ximo tren IS. <br></td></tr></tbody></table></div><br>  Yo explico: <br><br>  <b>(1) "Qu√©": seleccionamos caracter√≠sticas y enviamos como listas, no es necesario elegir un tiempo de lanzamiento</b> .  Si resulta que necesita m√°s tiempo para finalizar una caracter√≠stica del borrador del est√°ndar, entonces todo el mundo tendr√° que esperar por usted.  Trabaja en grandes funciones que requieren varios a√±os de desarrollo, y luego intenta dejar de trabajar en nuevas funciones mientras estabiliza el lanzamiento. <br><br>  As√≠ fue con C ++ 98 (se esperaba alrededor de 1994, Bj√∂rn dijo que si el lanzamiento no sal√≠a para entonces ser√≠a un fracaso) con C ++ 11 (se llam√≥ 0x porque se esperaba x para 2007 )  Este es un enfoque de "dejar al paciente sin blindaje" durante un per√≠odo indefinido, lo que condujo a un retraso en las pruebas de integraci√≥n y liberaci√≥n.  Y esto, a su vez, condujo a una gran incertidumbre en el mercado con respecto al momento del pr√≥ximo est√°ndar y si se lanzar√° (s√≠, no solo los participantes en el desarrollo, sino incluso algunos miembros del comit√© dudaron seriamente en 1996 y 2009). ¬øhay lanzamientos relevantes)?  Durante varios a√±os, la mayor√≠a de los compiladores no cumplieron con el est√°ndar, porque nadie sab√≠a cu√°ntos cambios incompatibles implementar√≠a el comit√© en la nueva versi√≥n, o cu√°ndo se esperar√≠a.  Esto ha llevado a una gran variedad y fragmentaci√≥n del soporte de C ++ en compiladores disponibles para la comunidad. <br><br>  ¬øPor qu√© hicimos esto, somos idiotas?  En realidad no, simplemente eran inexpertos y ... digamos, "optimistas".  Era un camino pavimentado con las mejores intenciones.  En 1994-1996 y en 2007-2009 realmente cre√≠mos que ahora mover√≠amos otra, dos o tres reuniones, y har√≠amos todo, y cada vez se pospondr√≠an hasta cuatro a√±os.  Y ahora han visto por su propia experiencia que no puede haber transferencia por un a√±o o dos. <br><br>  Afortunadamente, todo ha cambiado gracias a la opci√≥n (2). <br><br>  <b>(2) ‚ÄúCu√°ndo‚Äù: seleccionamos la fecha de lanzamiento y enviamos las funciones que est√°n listas, no necesita seleccionar un conjunto de funciones</b> .  Si resulta que se necesita m√°s tiempo para refinar una caracter√≠stica de un borrador de est√°ndar, la descartamos y enviamos lo que est√° listo.  Puede continuar trabajando en funciones grandes, cuya creaci√≥n lleva tiempo como para varios lanzamientos, pero h√°galo en "sucursales" de terceros, agreg√°ndolas a la rama maestra IS tan pronto como est√© listo.  Y trabajas constantemente en funciones, porque su desarrollo est√° completamente separado de la versi√≥n actual (no hay un gran punto de conexi√≥n). <br><br>  Nos hemos adherido a este enfoque desde 2012 y no queremos abandonarlo.  Este es el enfoque de "parchear regularmente al paciente", que lleva a la expectativa de una mayor calidad debido a integraciones regulares forzadas y la negativa a agregar trabajo al borrador IS hasta que alcance un cierto nivel de estabilidad, generalmente dentro de la rama caracter√≠stica.  Tambi√©n crea un ciclo de lanzamiento predecible en el que el mercado puede confiar.  Con los a√±os, los autores de compiladores comenzaron cada vez m√°s temprano, despu√©s del pr√≥ximo lanzamiento, a lanzar versiones de sus productos que se ajustaban al est√°ndar, lo cual nunca antes hab√≠a sucedido.  Y en 2020, esperamos el lanzamiento de implementaciones totalmente compatibles en un a√±o con el lanzamiento del est√°ndar, que nunca antes hab√≠a sucedido.  Esto es solo para el beneficio de todo el mercado: desarrolladores, usuarios, maestros. <br><br>  Y tambi√©n tenga en cuenta que desde que comenzamos a adherirnos a este enfoque, hemos comenzado a hacer m√°s (si se mide por caracter√≠sticas grandes, medianas y peque√±as) y con mayor calidad (si se mide por una reducci√≥n estricta en el n√∫mero de informes de errores y comentarios sobre borradores de cada est√°ndar).  Aunque enviamos lo que logramos preparar (y si no logramos algo, no lo enviamos). <br><br><h2>  ¬øQu√© tan serio eres sobre el enfoque (2)?  Si, seg√∫n un miembro autorizado del comit√©, alguna caracter√≠stica importante est√° "casi lista", entonces estar√°s tentado a esperar un poco, ¬øverdad? </h2><br>  Muy en serio, y no. <br><br>  Tenemos estad√≠sticas: en 2016 en Jacksonville, cuando finalmente decidimos las caracter√≠sticas de C ++ 17, Bj√∂rn Straustrup habl√≥ en una reuni√≥n plenaria con una propuesta para incluir conceptos en C ++ 17.  Cuando no se lleg√≥ a un consenso, se le pregunt√≥ directamente a Straustrup si quer√≠a retrasar el lanzamiento de C ++ 17 durante un a√±o para incluir conceptos en √©l.  Bj√∂rn respondi√≥ "no" sin dudarlo y evadirlo, y agreg√≥ que C ++ 17 sin conceptos era m√°s importante que C ++ 18 o C ++ 19 con conceptos, aunque Straustrup hab√≠a estado trabajando en ellos durante unos 15 a√±os.  La elecci√≥n fue esta: (2) lanzamos C ++ 17 sin conceptos, y luego C ++ 20 con conceptos (lo que hicimos), o (1) cambiamos el nombre de C ++ 17 a C ++ 20, que es isomorfo (2) con la excepci√≥n de omitir C ++ 17 y negarse a lanzar lo que ya estaba listo para C ++ 17. <br><br><h2>  ¬øQu√© pasa con la compensaci√≥n entre (1) y (2)?  Digamos, generalmente nos adherimos a (2), pero con "poca" flexibilidad en t√©rminos de obtener "un poco" de tiempo extra, si necesita refinar la funci√≥n. </h2><br>  No, porque resulta (1). <br><br>  Fred Brooks en <i>The Mythical Man-Month</i> popularmente explic√≥ "la peque√±a transferencia m√≠tica" y concluy√≥: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No permita ninguna transferencia peque√±a</a> ". <br><br>  Imagina que portamos C ++ 20.  Tendr√≠amos que regresar de (2) a (1), sin importar cu√°nto nos esforcemos por evitarlo, y al mismo tiempo no recibir√≠amos ning√∫n beneficio.  Si decidi√©ramos posponer C ++ 20 para pulirlo, retrasar√≠amos el est√°ndar por al menos dos a√±os.  No existen conceptos tales como la transferencia de una o tres reuniones, porque durante este tiempo otros continuar√°n (de manera justa) para decir: "Bueno, mi funci√≥n solo necesita una reuni√≥n m√°s, todav√≠a la reprogramamos, transfiramos otra".  Y si transferimos al menos dos a√±os, significa que C ++ 20 se convierte en C ++ 22, y muy probablemente C ++ 23 ... ¬°pero ya vamos a enviar C ++ 23!  - Es decir, en cualquier caso, enviaremos C ++ 23, y la √∫nica diferencia es que <b>no</b> transferimos C ++ 20 con una gran cantidad de trabajo realizado, listo para su lanzamiento, y no hacemos que el mundo entero espere otros tres a√±os.  La demora no beneficiar√° estas caracter√≠sticas, la mayor√≠a de ellas o todas juntas. <br><br>  Por lo tanto, la oraci√≥n es equivalente a "convirtamos C ++ 20 en C ++ 22 o C ++ 23", y la respuesta simple es: "s√≠, tendremos C ++ 23, pero adem√°s de C ++ 20, y no en su lugar ".  Un retraso de C ++ 20 significa omitir C ++ 20 en lugar de lanzar un producto terminado bueno y estable, y esto no tendr√° ning√∫n beneficio. <br><br><h2>  ¬°Pero la funci√≥n X est√° rota / lleva m√°s tiempo del que nos queda para corregir errores en C ++ 20! </h2><br>  No hay duda!  Solo podemos cortarlo. <br><br>  En este caso, alguien tendr√° que escribir una carta en EWG o LEWG (dependiendo de la situaci√≥n) con una descripci√≥n de la situaci√≥n, y ofrecer eliminar la funci√≥n del borrador de trabajo IS.  Estos grupos considerar√°n la apelaci√≥n, y si deciden que la funci√≥n est√° rota (y el pleno est√° de acuerdo con ellos), la funci√≥n se pospondr√° hasta la pr√≥xima versi√≥n de C ++.  Ya hicimos esto con los conceptos de C ++ 0x. <br><br>  Pero en el caso de (1), transferiremos no solo esta funci√≥n, sino <b>todo el conjunto de funciones</b> de C ++ 20 a C ++ 23.  Eso ser√≠a ... busto. <br><br><h2>  ¬øEl enfoque (2) significa lanzamientos "mayores / menores"? </h2><br>  No  Al principio dijimos esto hasta que nos dimos cuenta de que (2) solo significa que no es necesario elegir un conjunto de caracter√≠sticas incluso desde el punto de vista de la versi√≥n "principal / secundaria". <br><br>  Enfoque (2) significa solo "enviamos lo que est√° listo".  Se obtienen lanzamientos: <br><br><ul><li>  el mismo tama√±o (es decir, generalmente promedio) para las caracter√≠sticas es "m√°s peque√±o" porque se dedica menos tiempo a su desarrollo (por ejemplo, menos de tres a√±os cada una), y en general obtenemos la misma cantidad de caracter√≠sticas completadas en el lanzamiento; <br></li><li>  y un tama√±o variable (no es necesario una o dos veces) para las funciones "m√°s grandes", que toman m√°s tiempo (por ejemplo, m√°s de tres a√±os cada una), y cada versi√≥n de IS incluye tantas de estas caracter√≠sticas como logran completar para su lanzamiento.  Por lo tanto, en algunos lanzamientos hay m√°s, en otros menos. <br></li></ul><br>  C ++ 14 y C ++ 17 eran relativamente peque√±os, porque se invirti√≥ mucho esfuerzo en la estandarizaci√≥n de las funciones de larga duraci√≥n descritas en las propuestas de implementaci√≥n (por ejemplo, contratos) y "ramas de caracter√≠sticas" en TS (por ejemplo, conceptos). <br><br><h2>  C ++ 20 es un gran lanzamiento ... </h2><br>  Si  C ++ 20 tiene muchas caracter√≠sticas principales.  Tres de los m√°s grandes comienzan con "ko" (conceptos, contratos, corutinas), por lo que podr√≠amos llamarlo co_cpp20.  O codependiente. <br><br><h2>  ... y no se hace demasiado en el ciclo de tres a√±os para C ++ 20? </h2><br>  No, ver arriba "una vez a la vez no es necesario". <br><br>  C ++ 20 es importante no porque hayamos hecho m√°s en tres a√±os, sino porque hay muchos desarrollos largos (incluyendo al menos dos en los que hemos estado trabajando en la forma actual desde 2012 en forma de oraciones P y ramas TS ) llegaron a la fase de preparaci√≥n y decidieron incluirlos en el borrador IS de la misma versi√≥n. <br><br>  Casi siempre, las caracter√≠sticas principales se desarrollan durante muchos a√±os.  La principal diferencia entre el enfoque (1) para C ++ 98 y C ++ 11 y el enfoque (2) es que en C ++ 98 y C ++ 11 el lanzamiento se retras√≥ hasta que todas estas caracter√≠sticas estuvieron listas, y ahora enviamos grandes tan pronto como est√© listo, y junto con ellos lanzaremos mucho m√°s. <br><br>  C ++ 20 pas√≥ por el mismo ciclo de tres a√±os que C ++ 14 y C ++ 17.  No hemos hecho m√°s en los √∫ltimos tres a√±os que en los dos ciclos anteriores, solo agregamos m√°s a las caracter√≠sticas principales.  Si alguno de ellos no estuviera listo, lo habr√≠amos tirado y terminado para C ++ 23.  Si esto sucede, informaremos esto en la propuesta de implementaci√≥n y explicaremos los motivos. <br><br>  C ++ 14 + 17 + 20 conformaron nuestro tercer ciclo de nueve a√±os (2011-2020) despu√©s de C ++ 98 (1989-1998) y C ++ 11 (2002-2011).  Pero como nos adherimos al enfoque (2), <b>tambi√©n</b> lanzamos desarrollos que estaban listos para el final de los ciclos de tres y seis a√±os. <br><br><h2>  ¬øNo es mejor detectar errores cuando un producto est√° en desarrollo y no despu√©s de su lanzamiento? </h2><br>  Por supuesto que es mejor. <br><br>  Pero si hablamos de las razones de la demora en el lanzamiento del est√°ndar C ++, entonces esta pregunta implica dos suposiciones falsas: <br><br><ul><li>  que antes de que se lanzara el est√°ndar, las caracter√≠sticas no aparec√≠an y no se usaban (para muchos, ya existe experiencia en producci√≥n); <br></li><li>  y que todas las funciones se pueden usar juntas hasta que se libere el est√°ndar (no permitido). <br></li></ul><br>  Yo explico: <br><br><ol><li>  La mayor√≠a de las caracter√≠sticas principales de C ++ 20 se implementaron en la forma en que se reflejan en el borrador actual del est√°ndar en al menos un compilador, y en la mayor√≠a de los casos ya se han utilizado en el c√≥digo de producci√≥n (es decir, ya est√°n disponibles para usuarios que est√°n muy satisfechos) .  Por ejemplo, las corutinas (introducidas solo cinco meses antes de este art√≠culo) se usaron durante dos a√±os en producci√≥n en MSVC y un a√±o en Clang, lo que estaba muy satisfecho con los grandes clientes (por ejemplo, Azure y Facebook). </li><li>  No vamos a detectar muchos problemas de interacci√≥n entre las caracter√≠sticas hasta que los usuarios comiencen a usarlas en la producci√≥n, es decir, antes de que se lance el est√°ndar, porque muchos desarrolladores esperar√°n a que se lance para implementar diferentes proyectos.  Y si mostramos incertidumbre sobre el momento del lanzamiento, estas implementaciones tambi√©n se retrasar√°n.  Bueno, todav√≠a implementan algo, pero se detendr√° mucho hasta que los desarrolladores est√©n seguros de que estamos listos para lanzar.  Pregunte a los creadores de &lt;nombre del compilador favorito&gt; qu√© sucedi√≥ cuando implementaron &lt;nombre de la funci√≥n grande&gt; antes de que apareciera en el est√°ndar publicado.  En muchos casos, es necesario implementarlo repetidamente y separar a los consumidores repetidamente.  Por lo tanto, los desarrolladores prefieren esperar a que el comit√© apruebe ciertas caracter√≠sticas. </li></ol><br>  Finalmente, no te olvides del problema de las caracter√≠sticas de interacci√≥n.  No solo los lanzamos cuando estamos listos, despu√©s de eso todav√≠a necesitamos tiempo para buscar problemas de interacci√≥n entre caracter√≠sticas y agregar soporte para tales interacciones, que simplemente no podemos descubrir antes de que las nuevas caracter√≠sticas se utilicen ampliamente.  Y no importa cu√°nto demoremos el lanzamiento del est√°ndar, siempre habr√° interacciones que podremos explorar solo mucho m√°s tarde.  Debe gestionar este riesgo con la ayuda de un dise√±o flexible, asegurando la compatibilidad de las funciones, y no esperar a deshacerse de todos los riesgos. <br><br><h2>  El est√°ndar nunca ser√° perfecto ... ¬øno liberan errores? </h2><br>  Si <br><br>  Si vemos que la funci√≥n no est√° lista, debemos eliminarla de la versi√≥n. <br><br>  Si vemos que una funci√≥n puede ser mejor, y sabemos que el cambio puede ser compatible con versiones anteriores, entonces esta no es una raz√≥n para rechazar su lanzamiento ahora.  Se puede lanzar como una extensi√≥n en el siguiente C ++. <br><br>  Lanzamos intencionalmente funciones que planeamos mejorar en el futuro, mientras confiamos en que podemos mantener la compatibilidad con versiones anteriores. <br><br><h2>  ¬øPero no deber√≠as tratar de minimizar los errores de lanzamiento? </h2><br>  Si  Estamos intentando <br><br>  Pero no intentamos evitar todos los riesgos.  Tambi√©n existe el riesgo y (posible) precio de negarse a liberar lo que nos parece listo.  Y la mayor√≠a de las veces, tenemos raz√≥n. <br><br><h2>  ¬øEst√°s seguro de que ahora la calidad es mejor que usar el enfoque (1)? </h2><br>  Si <br><br>  Seg√∫n las m√©tricas objetivas, el volumen de comentarios de diferentes pa√≠ses y los informes de errores, C ++ 14 y C ++ 17 fueron nuestras versiones m√°s estables, y seg√∫n estas m√©tricas fueron 3-4 veces m√°s altas que C ++ 98 y C ++ 11.  Y la raz√≥n est√° precisamente en la regularidad de los lanzamientos, en colocar las caracter√≠sticas grandes primero en las ramas TS (incluidas las descripciones completas de su integraci√≥n con el est√°ndar principal) y en su posterior infusi√≥n, cuando estamos convencidos de que estamos listos. <br><br>  Desde 2012, el est√°ndar principal <b>siempre se ha</b> mantenido en un estado casi listo para su env√≠o (de modo que incluso los borradores de trabajo son de la misma alta calidad que los lanzamientos de los est√°ndares C ++ 98 y C ++ 11).  Esto nunca ha sucedido antes, cuando mantuvimos al paciente sin seguridad durante mucho tiempo, con largas listas de problemas y √≥rganos repartidos, que vamos a volver a colocar pronto.  Ahora sabemos que podemos mantener un cronograma con un trabajo de alta calidad, porque siempre permanecemos en un estado de preparaci√≥n cercana para el lanzamiento.  Si lo desea, podr√≠a lanzar un CD incluso ahora, sin reunirse en Colonia, y a√∫n as√≠ la calidad ser√≠a mucho m√°s alta que nunca con un CD C ++ 98 o C ++ 11 (en verdad, y sus est√°ndares publicados) .  Y teniendo en cuenta que C ++ 98 y C ++ 11 tuvieron √©xito, la comprensi√≥n de que ahora la calidad es a√∫n mayor significa que estamos en el camino correcto. <br><br><h2>  C ++ 98 y C ++ 11 se desarrollaron durante aproximadamente 9 a√±os y fueron muy buenos productos ... </h2><br>  S√≠: 1989-1998 y 2002-2011. <br><br><h2>  ... y C ++ 14 y C ++ 17 fueron lanzamientos menores.  ¬øEs C ++ 20 una versi√≥n importante? </h2><br>  Repito, creo que es correcto comparar C ++ 14 + 17 + 20 en su conjunto: este es nuestro ciclo de nueve a√±os, pero como nos adherimos al enfoque (2), tambi√©n lanzamos los desarrollos que estaban listos para completar los ciclos de tres y seis a√±os. . <br><br><h2>  ¬øEl enfoque (2) le permite alcanzar objetivos basados ‚Äã‚Äãen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones</a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P0592</a> para el pr√≥ximo C ++? </h2><br>  Por supuesto!  Si bien no contiene palabras como "deber√≠a incluir estas caracter√≠sticas", porque entonces ser√° el enfoque (1). <br><br>  Es normal luchar por un cierto conjunto de caracter√≠sticas y darle prioridad a una de ellas, pero luego es una cuesti√≥n de prioridad.  Hasta ahora, solo tomaremos lo que est√° listo, pero podemos elegir en qu√© trabajar primero para prepararnos lo antes posible. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460665/">https://habr.com/ru/post/460665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460647/index.html">Resolver un trabajo con pwnable.kr 05 - c√≥digo de acceso. Vuelva a escribir la tabla de enlaces del procedimiento a trav√©s de la vulnerabilidad de cadena de formato</a></li>
<li><a href="../460651/index.html">Reuni√≥n de la Society of Anonymous Testers: TMS, monitoreo de monitoreo, evaluaci√≥n de calidad de b√∫squeda y pruebas nativas de iOS</a></li>
<li><a href="../460655/index.html">C√≥mo romp√≠ Telegram</a></li>
<li><a href="../460659/index.html">Usando tuber√≠as para pivotar</a></li>
<li><a href="../460661/index.html">Todo lo que necesitas saber sobre Node.js</a></li>
<li><a href="../460667/index.html">Automatizaci√≥n de pruebas de servicios pagos en iOS</a></li>
<li><a href="../460669/index.html">C√≥mo garantizar la seguridad del desarrollo, ahorrando tiempo y nervios</a></li>
<li><a href="../460671/index.html">Propiedad y endeudamiento en D</a></li>
<li><a href="../460673/index.html">Exponer la magia de DiffUtil</a></li>
<li><a href="../460675/index.html">Extracci√≥n de datos de aprendizaje autom√°tico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>