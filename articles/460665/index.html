<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍⚖️ 🧔🏾 👨🏻‍🎨 Preguntas frecuentes preliminares: ¿Por qué los estándares C ++ salen cada tres años? 🐦 👨🏻‍🍳 👘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WG21 tiene un calendario estricto (ver P1000 ) para el lanzamiento estándar cada tres años. Y sin demoras. 

 Durante cada ciclo, recibimos regularmen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Preguntas frecuentes preliminares: ¿Por qué los estándares C ++ salen cada tres años?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/460665/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/9v/zg/u29vzg2wz-7letn3lbp4ulyk9um.jpeg" width="400"></div><br>  WG21 tiene un calendario estricto (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1000</a> ) para el lanzamiento estándar cada tres años.  Y sin demoras. <br><br>  Durante cada ciclo, recibimos regularmente preguntas "¿Por qué es tan estricto?", Especialmente de los nuevos miembros del comité que no están familiarizados con su historia y las razones del estado actual de las cosas.  Y durante una teleconferencia preliminar con la administración de Colonia, varias personas recomendaron describir por qué estábamos haciendo esto y cómo se tomó la decisión de adoptar este horario. <br><br>  Pinté todo esto en forma de preguntas y respuestas para el próximo borrador de P1000, y envié una copia a los miembros del comité camino a Colonia.  Este material se publicará en la próxima versión pública de P1000, lo enviaremos en unas pocas semanas a partir del momento actual. <br><br>  Sin embargo, el borrador de preguntas frecuentes puede ser de interés para el público, por lo que le ofrezco una copia.  Espero que en su mayor parte le sea útil, iluminarse de alguna manera y tal vez incluso entretener un poco. <br><br><a name="habracut"></a><br><h2>  Hay errores en el estándar, ¿debería posponer C ++ 20? </h2><br>  Por supuesto que si y no. <br><br>  Nos estamos moviendo en una dirección determinada a una velocidad elegida: las correcciones de errores están planificadas para este último año, por lo que el programa a principios de C ++ "19" (Kona) establece una fecha límite para detener la adición de características en C ++ "20" para que tuvimos un año para corregir errores, incluido trabajar con comentarios de diferentes países este verano.  Antes del comienzo de 2020 (reuniones en Colonia, Belfast y Praga), debemos dar retroalimentación y aplicar cualquier otra solución a los problemas, así como la corrección de errores. <br><br><h2>  Si tenemos una o dos reuniones más, entonces podríamos agregar un &lt;nombre de la función&gt;, que está casi listo, ¿debería posponer C ++ 20? </h2><br>  Por supuesto que si y no. <br><br>  Espere a que se celebren un par de reuniones más (después de Praga), y C ++ 23 estará abierto para los negocios, y en primer lugar votaremos para agregar &lt;nombre de la característica&gt; al borrador de trabajo de C ++ 23.  Esto es lo que hicimos con los conceptos: no estaban listos para la transición de TS directamente a C ++ 17.  Por lo tanto, en la primera reunión sobre C ++ 20 (en Toronto), votaron para transferir la funcionalidad básica de los conceptos al borrador de C ++ 20, que dio mucho tiempo para mejorar y refinar el resto de la parte contradictoria de la sintaxis TS (no "plantilla"), que se introdujo el año que viene (San Diego).  Ahora toda la funcionalidad está lista. <br><br><h2>  Esto parece ser demasiado estricto.  ¿Por qué publicar versiones IS a intervalos fijos (tres años)? </h2><br>  Porque en el caso del lanzamiento de C ++ IS, esta es una de las dos opciones principales para la gestión de proyectos, y la experiencia muestra que esta opción es mejor que la segunda. <br><br><h2>  ¿Cuáles son las dos opciones para la gestión de proyectos para el lanzamiento de C ++ IS? </h2><br>  Me alegra que hayas preguntado. <br><br>  En el caso de un lanzamiento, hay dos opciones principales: elegir una función o una fecha de lanzamiento, y cuando selecciona una, pierde el control sobre la definición de la otra.  No puedes controlar simultáneamente ambos.  En resumen: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Si lo controlamos <br></th><th>  Dejaremos de controlarlo <br></th><th>  ¿Podemos trabajar en características "grandes" de varios años? <br></th><th> ¿Cuándo agregamos características al borrador IS? <br></th><th>  ¿Qué hacemos si encontramos problemas con las funciones adicionales? <br></th></tr><tr><td>  <b>"Qué": características que enviamos</b> <br></td><td>  "Cuándo": fecha de lanzamiento. <br></td><td>  Sí, en los documentos con las propuestas y el borrador IS. <br></td><td>  Por lo general, antes para realizar más pruebas de integración → se reduce la estabilidad promedio del borrador de trabajo. <br></td><td>  Retrasamos el lanzamiento del estándar. <br></td></tr><tr><td>  <b>Cuándo: fecha de lanzamiento</b> <br></td><td>  "Qué": características que enviamos <br></td><td>  Sí, en documentos con ofertas y "ramas de características" en TS. <br></td><td>  Generalmente más tarde, cuando la característica se resuelve mejor → aumenta la estabilidad promedio del borrador de trabajo. <br></td><td>  Eliminamos la función, luego podemos agregarla nuevamente si está lista para cuando se envíe el próximo tren IS. <br></td></tr></tbody></table></div><br>  Yo explico: <br><br>  <b>(1) "Qué": seleccionamos características y enviamos como listas, no es necesario elegir un tiempo de lanzamiento</b> .  Si resulta que necesita más tiempo para finalizar una característica del borrador del estándar, entonces todo el mundo tendrá que esperar por usted.  Trabaja en grandes funciones que requieren varios años de desarrollo, y luego intenta dejar de trabajar en nuevas funciones mientras estabiliza el lanzamiento. <br><br>  Así fue con C ++ 98 (se esperaba alrededor de 1994, Björn dijo que si el lanzamiento no salía para entonces sería un fracaso) con C ++ 11 (se llamó 0x porque se esperaba x para 2007 )  Este es un enfoque de "dejar al paciente sin blindaje" durante un período indefinido, lo que condujo a un retraso en las pruebas de integración y liberación.  Y esto, a su vez, condujo a una gran incertidumbre en el mercado con respecto al momento del próximo estándar y si se lanzará (sí, no solo los participantes en el desarrollo, sino incluso algunos miembros del comité dudaron seriamente en 1996 y 2009). ¿hay lanzamientos relevantes)?  Durante varios años, la mayoría de los compiladores no cumplieron con el estándar, porque nadie sabía cuántos cambios incompatibles implementaría el comité en la nueva versión, o cuándo se esperaría.  Esto ha llevado a una gran variedad y fragmentación del soporte de C ++ en compiladores disponibles para la comunidad. <br><br>  ¿Por qué hicimos esto, somos idiotas?  En realidad no, simplemente eran inexpertos y ... digamos, "optimistas".  Era un camino pavimentado con las mejores intenciones.  En 1994-1996 y en 2007-2009 realmente creímos que ahora moveríamos otra, dos o tres reuniones, y haríamos todo, y cada vez se pospondrían hasta cuatro años.  Y ahora han visto por su propia experiencia que no puede haber transferencia por un año o dos. <br><br>  Afortunadamente, todo ha cambiado gracias a la opción (2). <br><br>  <b>(2) “Cuándo”: seleccionamos la fecha de lanzamiento y enviamos las funciones que están listas, no necesita seleccionar un conjunto de funciones</b> .  Si resulta que se necesita más tiempo para refinar una característica de un borrador de estándar, la descartamos y enviamos lo que está listo.  Puede continuar trabajando en funciones grandes, cuya creación lleva tiempo como para varios lanzamientos, pero hágalo en "sucursales" de terceros, agregándolas a la rama maestra IS tan pronto como esté listo.  Y trabajas constantemente en funciones, porque su desarrollo está completamente separado de la versión actual (no hay un gran punto de conexión). <br><br>  Nos hemos adherido a este enfoque desde 2012 y no queremos abandonarlo.  Este es el enfoque de "parchear regularmente al paciente", que lleva a la expectativa de una mayor calidad debido a integraciones regulares forzadas y la negativa a agregar trabajo al borrador IS hasta que alcance un cierto nivel de estabilidad, generalmente dentro de la rama característica.  También crea un ciclo de lanzamiento predecible en el que el mercado puede confiar.  Con los años, los autores de compiladores comenzaron cada vez más temprano, después del próximo lanzamiento, a lanzar versiones de sus productos que se ajustaban al estándar, lo cual nunca antes había sucedido.  Y en 2020, esperamos el lanzamiento de implementaciones totalmente compatibles en un año con el lanzamiento del estándar, que nunca antes había sucedido.  Esto es solo para el beneficio de todo el mercado: desarrolladores, usuarios, maestros. <br><br>  Y también tenga en cuenta que desde que comenzamos a adherirnos a este enfoque, hemos comenzado a hacer más (si se mide por características grandes, medianas y pequeñas) y con mayor calidad (si se mide por una reducción estricta en el número de informes de errores y comentarios sobre borradores de cada estándar).  Aunque enviamos lo que logramos preparar (y si no logramos algo, no lo enviamos). <br><br><h2>  ¿Qué tan serio eres sobre el enfoque (2)?  Si, según un miembro autorizado del comité, alguna característica importante está "casi lista", entonces estarás tentado a esperar un poco, ¿verdad? </h2><br>  Muy en serio, y no. <br><br>  Tenemos estadísticas: en 2016 en Jacksonville, cuando finalmente decidimos las características de C ++ 17, Björn Straustrup habló en una reunión plenaria con una propuesta para incluir conceptos en C ++ 17.  Cuando no se llegó a un consenso, se le preguntó directamente a Straustrup si quería retrasar el lanzamiento de C ++ 17 durante un año para incluir conceptos en él.  Björn respondió "no" sin dudarlo y evadirlo, y agregó que C ++ 17 sin conceptos era más importante que C ++ 18 o C ++ 19 con conceptos, aunque Straustrup había estado trabajando en ellos durante unos 15 años.  La elección fue esta: (2) lanzamos C ++ 17 sin conceptos, y luego C ++ 20 con conceptos (lo que hicimos), o (1) cambiamos el nombre de C ++ 17 a C ++ 20, que es isomorfo (2) con la excepción de omitir C ++ 17 y negarse a lanzar lo que ya estaba listo para C ++ 17. <br><br><h2>  ¿Qué pasa con la compensación entre (1) y (2)?  Digamos, generalmente nos adherimos a (2), pero con "poca" flexibilidad en términos de obtener "un poco" de tiempo extra, si necesita refinar la función. </h2><br>  No, porque resulta (1). <br><br>  Fred Brooks en <i>The Mythical Man-Month</i> popularmente explicó "la pequeña transferencia mítica" y concluyó: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No permita ninguna transferencia pequeña</a> ". <br><br>  Imagina que portamos C ++ 20.  Tendríamos que regresar de (2) a (1), sin importar cuánto nos esforcemos por evitarlo, y al mismo tiempo no recibiríamos ningún beneficio.  Si decidiéramos posponer C ++ 20 para pulirlo, retrasaríamos el estándar por al menos dos años.  No existen conceptos tales como la transferencia de una o tres reuniones, porque durante este tiempo otros continuarán (de manera justa) para decir: "Bueno, mi función solo necesita una reunión más, todavía la reprogramamos, transfiramos otra".  Y si transferimos al menos dos años, significa que C ++ 20 se convierte en C ++ 22, y muy probablemente C ++ 23 ... ¡pero ya vamos a enviar C ++ 23!  - Es decir, en cualquier caso, enviaremos C ++ 23, y la única diferencia es que <b>no</b> transferimos C ++ 20 con una gran cantidad de trabajo realizado, listo para su lanzamiento, y no hacemos que el mundo entero espere otros tres años.  La demora no beneficiará estas características, la mayoría de ellas o todas juntas. <br><br>  Por lo tanto, la oración es equivalente a "convirtamos C ++ 20 en C ++ 22 o C ++ 23", y la respuesta simple es: "sí, tendremos C ++ 23, pero además de C ++ 20, y no en su lugar ".  Un retraso de C ++ 20 significa omitir C ++ 20 en lugar de lanzar un producto terminado bueno y estable, y esto no tendrá ningún beneficio. <br><br><h2>  ¡Pero la función X está rota / lleva más tiempo del que nos queda para corregir errores en C ++ 20! </h2><br>  No hay duda!  Solo podemos cortarlo. <br><br>  En este caso, alguien tendrá que escribir una carta en EWG o LEWG (dependiendo de la situación) con una descripción de la situación, y ofrecer eliminar la función del borrador de trabajo IS.  Estos grupos considerarán la apelación, y si deciden que la función está rota (y el pleno está de acuerdo con ellos), la función se pospondrá hasta la próxima versión de C ++.  Ya hicimos esto con los conceptos de C ++ 0x. <br><br>  Pero en el caso de (1), transferiremos no solo esta función, sino <b>todo el conjunto de funciones</b> de C ++ 20 a C ++ 23.  Eso sería ... busto. <br><br><h2>  ¿El enfoque (2) significa lanzamientos "mayores / menores"? </h2><br>  No  Al principio dijimos esto hasta que nos dimos cuenta de que (2) solo significa que no es necesario elegir un conjunto de características incluso desde el punto de vista de la versión "principal / secundaria". <br><br>  Enfoque (2) significa solo "enviamos lo que está listo".  Se obtienen lanzamientos: <br><br><ul><li>  el mismo tamaño (es decir, generalmente promedio) para las características es "más pequeño" porque se dedica menos tiempo a su desarrollo (por ejemplo, menos de tres años cada una), y en general obtenemos la misma cantidad de características completadas en el lanzamiento; <br></li><li>  y un tamaño variable (no es necesario una o dos veces) para las funciones "más grandes", que toman más tiempo (por ejemplo, más de tres años cada una), y cada versión de IS incluye tantas de estas características como logran completar para su lanzamiento.  Por lo tanto, en algunos lanzamientos hay más, en otros menos. <br></li></ul><br>  C ++ 14 y C ++ 17 eran relativamente pequeños, porque se invirtió mucho esfuerzo en la estandarización de las funciones de larga duración descritas en las propuestas de implementación (por ejemplo, contratos) y "ramas de características" en TS (por ejemplo, conceptos). <br><br><h2>  C ++ 20 es un gran lanzamiento ... </h2><br>  Si  C ++ 20 tiene muchas características principales.  Tres de los más grandes comienzan con "ko" (conceptos, contratos, corutinas), por lo que podríamos llamarlo co_cpp20.  O codependiente. <br><br><h2>  ... y no se hace demasiado en el ciclo de tres años para C ++ 20? </h2><br>  No, ver arriba "una vez a la vez no es necesario". <br><br>  C ++ 20 es importante no porque hayamos hecho más en tres años, sino porque hay muchos desarrollos largos (incluyendo al menos dos en los que hemos estado trabajando en la forma actual desde 2012 en forma de oraciones P y ramas TS ) llegaron a la fase de preparación y decidieron incluirlos en el borrador IS de la misma versión. <br><br>  Casi siempre, las características principales se desarrollan durante muchos años.  La principal diferencia entre el enfoque (1) para C ++ 98 y C ++ 11 y el enfoque (2) es que en C ++ 98 y C ++ 11 el lanzamiento se retrasó hasta que todas estas características estuvieron listas, y ahora enviamos grandes tan pronto como esté listo, y junto con ellos lanzaremos mucho más. <br><br>  C ++ 20 pasó por el mismo ciclo de tres años que C ++ 14 y C ++ 17.  No hemos hecho más en los últimos tres años que en los dos ciclos anteriores, solo agregamos más a las características principales.  Si alguno de ellos no estuviera listo, lo habríamos tirado y terminado para C ++ 23.  Si esto sucede, informaremos esto en la propuesta de implementación y explicaremos los motivos. <br><br>  C ++ 14 + 17 + 20 conformaron nuestro tercer ciclo de nueve años (2011-2020) después de C ++ 98 (1989-1998) y C ++ 11 (2002-2011).  Pero como nos adherimos al enfoque (2), <b>también</b> lanzamos desarrollos que estaban listos para el final de los ciclos de tres y seis años. <br><br><h2>  ¿No es mejor detectar errores cuando un producto está en desarrollo y no después de su lanzamiento? </h2><br>  Por supuesto que es mejor. <br><br>  Pero si hablamos de las razones de la demora en el lanzamiento del estándar C ++, entonces esta pregunta implica dos suposiciones falsas: <br><br><ul><li>  que antes de que se lanzara el estándar, las características no aparecían y no se usaban (para muchos, ya existe experiencia en producción); <br></li><li>  y que todas las funciones se pueden usar juntas hasta que se libere el estándar (no permitido). <br></li></ul><br>  Yo explico: <br><br><ol><li>  La mayoría de las características principales de C ++ 20 se implementaron en la forma en que se reflejan en el borrador actual del estándar en al menos un compilador, y en la mayoría de los casos ya se han utilizado en el código de producción (es decir, ya están disponibles para usuarios que están muy satisfechos) .  Por ejemplo, las corutinas (introducidas solo cinco meses antes de este artículo) se usaron durante dos años en producción en MSVC y un año en Clang, lo que estaba muy satisfecho con los grandes clientes (por ejemplo, Azure y Facebook). </li><li>  No vamos a detectar muchos problemas de interacción entre las características hasta que los usuarios comiencen a usarlas en la producción, es decir, antes de que se lance el estándar, porque muchos desarrolladores esperarán a que se lance para implementar diferentes proyectos.  Y si mostramos incertidumbre sobre el momento del lanzamiento, estas implementaciones también se retrasarán.  Bueno, todavía implementan algo, pero se detendrá mucho hasta que los desarrolladores estén seguros de que estamos listos para lanzar.  Pregunte a los creadores de &lt;nombre del compilador favorito&gt; qué sucedió cuando implementaron &lt;nombre de la función grande&gt; antes de que apareciera en el estándar publicado.  En muchos casos, es necesario implementarlo repetidamente y separar a los consumidores repetidamente.  Por lo tanto, los desarrolladores prefieren esperar a que el comité apruebe ciertas características. </li></ol><br>  Finalmente, no te olvides del problema de las características de interacción.  No solo los lanzamos cuando estamos listos, después de eso todavía necesitamos tiempo para buscar problemas de interacción entre características y agregar soporte para tales interacciones, que simplemente no podemos descubrir antes de que las nuevas características se utilicen ampliamente.  Y no importa cuánto demoremos el lanzamiento del estándar, siempre habrá interacciones que podremos explorar solo mucho más tarde.  Debe gestionar este riesgo con la ayuda de un diseño flexible, asegurando la compatibilidad de las funciones, y no esperar a deshacerse de todos los riesgos. <br><br><h2>  El estándar nunca será perfecto ... ¿no liberan errores? </h2><br>  Si <br><br>  Si vemos que la función no está lista, debemos eliminarla de la versión. <br><br>  Si vemos que una función puede ser mejor, y sabemos que el cambio puede ser compatible con versiones anteriores, entonces esta no es una razón para rechazar su lanzamiento ahora.  Se puede lanzar como una extensión en el siguiente C ++. <br><br>  Lanzamos intencionalmente funciones que planeamos mejorar en el futuro, mientras confiamos en que podemos mantener la compatibilidad con versiones anteriores. <br><br><h2>  ¿Pero no deberías tratar de minimizar los errores de lanzamiento? </h2><br>  Si  Estamos intentando <br><br>  Pero no intentamos evitar todos los riesgos.  También existe el riesgo y (posible) precio de negarse a liberar lo que nos parece listo.  Y la mayoría de las veces, tenemos razón. <br><br><h2>  ¿Estás seguro de que ahora la calidad es mejor que usar el enfoque (1)? </h2><br>  Si <br><br>  Según las métricas objetivas, el volumen de comentarios de diferentes países y los informes de errores, C ++ 14 y C ++ 17 fueron nuestras versiones más estables, y según estas métricas fueron 3-4 veces más altas que C ++ 98 y C ++ 11.  Y la razón está precisamente en la regularidad de los lanzamientos, en colocar las características grandes primero en las ramas TS (incluidas las descripciones completas de su integración con el estándar principal) y en su posterior infusión, cuando estamos convencidos de que estamos listos. <br><br>  Desde 2012, el estándar principal <b>siempre se ha</b> mantenido en un estado casi listo para su envío (de modo que incluso los borradores de trabajo son de la misma alta calidad que los lanzamientos de los estándares C ++ 98 y C ++ 11).  Esto nunca ha sucedido antes, cuando mantuvimos al paciente sin seguridad durante mucho tiempo, con largas listas de problemas y órganos repartidos, que vamos a volver a colocar pronto.  Ahora sabemos que podemos mantener un cronograma con un trabajo de alta calidad, porque siempre permanecemos en un estado de preparación cercana para el lanzamiento.  Si lo desea, podría lanzar un CD incluso ahora, sin reunirse en Colonia, y aún así la calidad sería mucho más alta que nunca con un CD C ++ 98 o C ++ 11 (en verdad, y sus estándares publicados) .  Y teniendo en cuenta que C ++ 98 y C ++ 11 tuvieron éxito, la comprensión de que ahora la calidad es aún mayor significa que estamos en el camino correcto. <br><br><h2>  C ++ 98 y C ++ 11 se desarrollaron durante aproximadamente 9 años y fueron muy buenos productos ... </h2><br>  Sí: 1989-1998 y 2002-2011. <br><br><h2>  ... y C ++ 14 y C ++ 17 fueron lanzamientos menores.  ¿Es C ++ 20 una versión importante? </h2><br>  Repito, creo que es correcto comparar C ++ 14 + 17 + 20 en su conjunto: este es nuestro ciclo de nueve años, pero como nos adherimos al enfoque (2), también lanzamos los desarrollos que estaban listos para completar los ciclos de tres y seis años. . <br><br><h2>  ¿El enfoque (2) le permite alcanzar objetivos basados ​​en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones</a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P0592</a> para el próximo C ++? </h2><br>  Por supuesto!  Si bien no contiene palabras como "debería incluir estas características", porque entonces será el enfoque (1). <br><br>  Es normal luchar por un cierto conjunto de características y darle prioridad a una de ellas, pero luego es una cuestión de prioridad.  Hasta ahora, solo tomaremos lo que está listo, pero podemos elegir en qué trabajar primero para prepararnos lo antes posible. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460665/">https://habr.com/ru/post/460665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460647/index.html">Resolver un trabajo con pwnable.kr 05 - código de acceso. Vuelva a escribir la tabla de enlaces del procedimiento a través de la vulnerabilidad de cadena de formato</a></li>
<li><a href="../460651/index.html">Reunión de la Society of Anonymous Testers: TMS, monitoreo de monitoreo, evaluación de calidad de búsqueda y pruebas nativas de iOS</a></li>
<li><a href="../460655/index.html">Cómo rompí Telegram</a></li>
<li><a href="../460659/index.html">Usando tuberías para pivotar</a></li>
<li><a href="../460661/index.html">Todo lo que necesitas saber sobre Node.js</a></li>
<li><a href="../460667/index.html">Automatización de pruebas de servicios pagos en iOS</a></li>
<li><a href="../460669/index.html">Cómo garantizar la seguridad del desarrollo, ahorrando tiempo y nervios</a></li>
<li><a href="../460671/index.html">Propiedad y endeudamiento en D</a></li>
<li><a href="../460673/index.html">Exponer la magia de DiffUtil</a></li>
<li><a href="../460675/index.html">Extracción de datos de aprendizaje automático</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>