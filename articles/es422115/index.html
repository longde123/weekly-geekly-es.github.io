<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¢ üìé üéê Pensamiento funcional Parte 3 ‚ùï ‚öìÔ∏è üë®üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La tercera parte de una serie de art√≠culos sobre programaci√≥n funcional se ha detenido. Hoy hablaremos sobre todos los tipos de este paradigma y mostr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamiento funcional Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/422115/"><p>  La tercera parte de una serie de art√≠culos sobre programaci√≥n funcional se ha detenido.  Hoy hablaremos sobre todos los tipos de este paradigma y mostraremos ejemplos de su uso.  ¬°M√°s informaci√≥n sobre tipos primitivos, tipos generalizados y mucho m√°s debajo del corte! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"><a name="habracut"></a></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Segunda parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tercera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cuarta parte</a></strong> </li></ul><br><p>  Ahora que conocemos las funciones, veremos c√≥mo los tipos interact√∫an con funciones como dominio y rango.  Este art√≠culo es solo una revisi√≥n.  Para una inmersi√≥n m√°s profunda en los tipos hay una serie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"comprensi√≥n de los tipos F #"</a> . </p><br><p> Para comenzar, necesitamos una mejor comprensi√≥n de la notaci√≥n de tipos.  Vimos la notaci√≥n de flecha " <code>-&gt;</code> " separando dominio y rango.  Entonces la firma de la funci√≥n siempre se ve as√≠: </p><br><pre> <code class="plaintext hljs">val functionName : domain -&gt; range</code> </pre> <br><p>  Algunos ejemplos m√°s de funciones: </p><br><pre> <code class="plaintext hljs">let intToString x = sprintf "x is %i" x //  int  string let stringToInt x = System.Int32.Parse(x)</code> </pre> <br><p>  Si ejecuta este c√≥digo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una ventana interactiva</a> , puede ver las siguientes firmas: </p><br><pre> <code class="plaintext hljs">val intToString : int -&gt; string val stringToInt : string -&gt; int</code> </pre> <br><p>  Significan: </p><br><ul><li>  <code>intToString</code> tiene un dominio de tipo <code>int</code> , que se asigna al rango de tipo <code>string</code> . </li><li>  <code>stringToInt</code> tiene un dominio de tipo <code>string</code> , que se asigna a un rango de tipo <code>int</code> . </li></ul><br><h2>  Tipos primitivos </h2><br><p>  Hay tipos primitivos esperados: string, int, float, bool, char, byte, etc., as√≠ como muchos otros derivados del sistema de tipos .NET. </p><br><p>  Un par de ejemplos m√°s de funciones con tipos primitivos: </p><br><pre> <code class="plaintext hljs">let intToFloat x = float x // "float" -  int  float let intToBool x = (x = 2) // true  x  2 let stringToString x = x + " world"</code> </pre> <br><p>  y sus firmas: </p><br><pre> <code class="plaintext hljs">val intToFloat : int -&gt; float val intToBool : int -&gt; bool val stringToString : string -&gt; string</code> </pre> <br><h2>  Anotaci√≥n de tipo </h2><br><p>  En ejemplos anteriores, el compilador de F # defini√≥ correctamente los tipos de par√°metros y resultados.  Pero esto no siempre sucede.  Si intenta ejecutar el siguiente c√≥digo, recibir√° un error de compilaci√≥n: </p><br><pre> <code class="plaintext hljs">let stringLength x = x.Length =&gt; error FS0072: Lookup on object of indeterminate type</code> </pre> <br><p>  El compilador no conoce el tipo de argumento "x", y debido a esto, no sabe si la "Longitud" es un m√©todo v√°lido.  En la mayor√≠a de los casos, esto se puede solucionar pasando la "anotaci√≥n de tipo" al compilador de F #.  Entonces √©l sabr√° qu√© tipo usar.  En la versi√≥n fija, indicamos que el tipo "x" es una cadena. </p><br><pre> <code class="plaintext hljs">let stringLength (x:string) = x.Length</code> </pre> <br><p>  Las llaves alrededor del par√°metro <code>x:string</code> son importantes.  Si se omiten, ¬°el compilador decidir√° que la cadena es el valor de retorno!  Es decir, se utilizan dos puntos para indicar el tipo de valor de retorno, como se muestra en el siguiente ejemplo. </p><br><pre> <code class="plaintext hljs">let stringLengthAsInt (x:string) :int = x.Length</code> </pre> <br><p>  Indicamos que el par√°metro <code>x</code> es una cadena, y el valor de retorno es un entero. </p><br><h2>  Tipos de funciones como par√°metros </h2><br><p>  Una funci√≥n que toma otras funciones como par√°metros o devuelve una funci√≥n se denomina <strong>funci√≥n de orden superior</strong> (la <strong>funci√≥n de orden superior a</strong> veces se acorta a HOF).  Se utilizan como abstracci√≥n para establecer un comportamiento lo m√°s general posible.  Este tipo de funci√≥n es muy com√∫n en F #, la mayor√≠a de las bibliotecas est√°ndar las usan. </p><br><p>  Considere la funci√≥n <code>evalWith5ThenAdd2</code> , que toma una funci√≥n como par√°metro y luego calcula esta funci√≥n a partir de 5 y agrega 2 al resultado: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 + 2 //   ,   fn(5) + 2</code> </pre> <br><p>  La firma de esta funci√≥n se ve as√≠: </p><br><pre> <code class="plaintext hljs">val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  Puede ver que el dominio es <code>(int-&gt;int)</code> y el rango es <code>int</code> .  ¬øQu√© significa esto?  Esto significa que el par√°metro de entrada no es un valor simple, sino una funci√≥n de muchas funciones de <code>int</code> a <code>int</code> .  El valor de salida no es una funci√≥n, sino solo un <code>int</code> . </p><br><p>  Probemos </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 //  -  (int -&gt; int) evalWith5ThenAdd2 add1 //  </code> </pre> <br><p>  y obtener: </p><br><pre> <code class="plaintext hljs">val add1 : int -&gt; int val it : int = 8</code> </pre> <br><p>  " <code>add1</code> " es una funci√≥n que asigna <code>int</code> a <code>int</code> , como vemos en la firma.  Es un par√°metro v√°lido para <code>evalWith5ThenAdd2</code> , y su resultado es 8. </p><br><p>  Por cierto, la palabra especial " <code>it</code> " se usa para denotar el √∫ltimo valor calculado, en este caso es el resultado que est√°bamos esperando.  Esta no es una palabra clave, es solo una convenci√≥n de nomenclatura. </p><br><p>  Otro caso: </p><br><pre> <code class="plaintext hljs">let times3 x = x * 3 // -  (int -&gt; int) evalWith5ThenAdd2 times3 //  </code> </pre> <br><p>  da: </p><br><pre> <code class="plaintext hljs">val times3 : int -&gt; int val it : int = 17</code> </pre> <br><p>  " <code>times3</code> " tambi√©n es una funci√≥n que asigna <code>int</code> a <code>int</code> , como se puede ver en la firma.  Tambi√©n es un par√°metro v√°lido para <code>evalWith5ThenAdd2</code> .  El resultado de los c√°lculos es 17. </p><br><p>  Tenga en cuenta que los datos de entrada son sensibles al tipo.  Si la funci√≥n pasada utiliza un <code>float</code> , no un <code>int</code> , entonces nada funcionar√°.  Por ejemplo, si tenemos: </p><br><pre> <code class="plaintext hljs">let times3float x = x * 3.0 // -  (float-&gt;float) evalWith5ThenAdd2 times3float</code> </pre> <br><p>  El compilador, cuando intenta compilar, devolver√° un error: </p><br><pre> <code class="plaintext hljs">error FS0001: Type mismatch. Expecting a int -&gt; int but given a float -&gt; float</code> </pre> <br><p>  informando que la funci√≥n de entrada debe ser una funci√≥n de tipo <code>int-&gt;int</code> . </p><br><h3>  Funciones como salida </h3><br><p>  Las funciones de valor tambi√©n pueden ser el resultado de funciones.  Por ejemplo, la siguiente funci√≥n generar√° una funci√≥n de "sumador" que agregar√° un valor de entrada. </p><br><pre> <code class="plaintext hljs">let adderGenerator numberToAdd = (+) numberToAdd</code> </pre> <br><p>  Su firma: </p><br><pre> <code class="plaintext hljs">val adderGenerator : int -&gt; (int -&gt; int)</code> </pre> <br><p>  significa que el generador toma un <code>int</code> y crea una funci√≥n ("sumador") que asigna <code>ints</code> a <code>ints</code> .  Veamos c√≥mo funciona: </p><br><pre> <code class="plaintext hljs">let add1 = adderGenerator 1 let add2 = adderGenerator 2</code> </pre> <br><p>  Se crean dos funciones sumadoras.  El primero crea una funci√≥n que agrega 1 a la entrada, el segundo agrega 2. Tenga en cuenta que las firmas son exactamente lo que esper√°bamos. </p><br><pre> <code class="plaintext hljs">val add1 : (int -&gt; int) val add2 : (int -&gt; int)</code> </pre> <br><p>  Ahora puede usar las funciones generadas como de costumbre, no son diferentes de las funciones definidas expl√≠citamente: </p><br><pre> <code class="plaintext hljs">add1 5 // val it : int = 6 add2 5 // val it : int = 7</code> </pre> <br><h3>  Usar anotaciones de tipo para restringir los tipos de funci√≥n </h3><br><p>  En el primer ejemplo, observamos una funci√≥n: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 +2 &gt; val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  En este ejemplo, F # puede concluir que " <code>fn</code> " convierte <code>int</code> en <code>int</code> , por lo que su firma ser√° <code>int-&gt;int</code> . </p><br><p>  Pero, ¬øcu√°l es la firma de "fn" en el siguiente caso? </p><br><pre> <code class="plaintext hljs">let evalWith5 fn = fn 5</code> </pre> <br><p>  Est√° claro que " <code>fn</code> " es un tipo de funci√≥n que requiere un <code>int</code> , pero ¬øqu√© devuelve?  El compilador no puede responder esta pregunta.  En tales casos, si es necesario indicar el tipo de funci√≥n, puede agregar un tipo de anotaci√≥n para los par√°metros de la funci√≥n, as√≠ como para los tipos primitivos. </p><br><pre> <code class="plaintext hljs">let evalWith5AsInt (fn:int-&gt;int) = fn 5 let evalWith5AsFloat (fn:int-&gt;float) = fn 5</code> </pre> <br><p>  Adem√°s, puede determinar el tipo de retorno. </p><br><pre> <code class="plaintext hljs">let evalWith5AsString fn :string = fn 5</code> </pre> <br><p>  Porque  la funci√≥n principal devuelve una <code>string</code> , la funci√≥n " <code>fn</code> " tambi√©n se ve obligada a devolver una <code>string</code> .  Por lo tanto, no es necesario especificar expl√≠citamente el tipo " <code>fn</code> ". </p><br><h2>  Escriba "unidad" </h2><br><p>  En el proceso de programaci√≥n, a veces queremos que una funci√≥n haga algo sin devolver nada.  Considere la funci√≥n " <code>printInt</code> ".  La funci√≥n realmente no devuelve nada.  Simplemente imprime la cadena en la consola como un efecto secundario de la ejecuci√≥n. </p><br><pre> <code class="plaintext hljs">let printInt x = printf "x is %i" x //   </code> </pre> <br><p>  ¬øCu√°l es su firma? </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  ¬øQu√© es una " <code>unit</code> "? </p><br><p>  Incluso si la funci√≥n no devuelve valores, a√∫n necesita rango.  No hay funciones "nulas" en el mundo de las matem√°ticas.  ¬°Cada funci√≥n debe devolver algo, porque la funci√≥n es una asignaci√≥n, y la asignaci√≥n debe mostrar algo! </p><br><p><img src="https://habrastorage.org/webt/3_/vt/vz/3_vtvz11kud3aikskqhciwc_q1a.png"></p><br><p>  Entonces, en F #, funciones como esta devuelven un tipo especial de resultado llamado " <code>unit</code> ".  Contiene solo un valor, denotado por " <code>()</code> ".  Puede pensar que <code>unit</code> y <code>()</code> son algo as√≠ como "void" y "null" de C #, respectivamente.  Pero a diferencia de ellos, la <code>unit</code> es el tipo real y <code>()</code> valor real.  Para verificar esto, solo haz: </p><br><pre> <code class="plaintext hljs">let whatIsThis = ()</code> </pre> <br><p>  Se recibir√° la siguiente firma: </p><br><pre> <code class="plaintext hljs">val whatIsThis : unit = ()</code> </pre> <br><p>  Lo que indica que la etiqueta " <code>whatIsThis</code> " es de tipo <code>unit</code> y est√° asociada con un valor <code>()</code> . </p><br><p>  Ahora, volviendo a la firma " <code>printInt</code> ", podemos entender el significado de esta entrada: </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  Esta firma dice que <code>printInt</code> tiene un dominio de <code>int</code> , que se traduce en algo que no nos interesa. </p><br><h3>  Funciones sin par√°metros. </h3><br><p>  Ahora que entendemos la <code>unit</code> , ¬øpodemos predecir su apariencia en un contexto diferente?  Por ejemplo, intente crear una funci√≥n reutilizable "hello world".  Como no hay entrada ni salida, podemos esperar la <code>unit -&gt; unit</code> firma <code>unit -&gt; unit</code> .  A ver: </p><br><pre> <code class="plaintext hljs">let printHello = printf "hello world" //   </code> </pre> <br><p>  Resultado: </p><br><pre> <code class="plaintext hljs">hello world val printHello : unit = ()</code> </pre> <br><p>  <em>No es exactamente</em> lo que esper√°bamos.  "Hello world" sali√≥ inmediatamente, y el resultado no fue una funci√≥n, sino un simple valor de tipo unit.  Podemos decir que este es un valor simple, porque, como vimos anteriormente, tiene una firma del formulario: </p><br><pre> <code class="plaintext hljs">val aName: type = constant</code> </pre> <br><p>  En este ejemplo, vemos que <code>printHello</code> realmente un <em>valor simple</em> <code>()</code> .  Esta no es una funci√≥n que podamos llamar m√°s adelante. </p><br><p>  ¬øCu√°l es la diferencia entre <code>printInt</code> y <code>printHello</code> ?  En el caso de <code>printInt</code> valor no puede determinarse hasta que sepamos el valor del par√°metro <code>x</code> , por lo que la definici√≥n fue una funci√≥n.  En el caso de <code>printHello</code> no hay par√°metros, por lo que el lado derecho se puede definir en su lugar.  Y fue igual a <code>()</code> con un efecto secundario en forma de salida a la consola. </p><br><p>  Puede crear una verdadera funci√≥n reutilizable sin par√°metros, lo que obliga a la definici√≥n a tener un argumento <code>unit</code> : </p><br><pre> <code class="plaintext hljs">let printHelloFn () = printf "hello world" //   </code> </pre> <br><p>  Ahora su firma es igual a: </p><br><pre> <code class="plaintext hljs">val printHelloFn : unit -&gt; unit</code> </pre> <br><p>  y para llamarlo, debemos pasar <code>()</code> como par√°metro: </p><br><pre> <code class="plaintext hljs">printHelloFn ()</code> </pre> <br><h3>  Fortalecimiento de tipos de unidades con la funci√≥n ignorar </h3><br><p>  En algunos casos, el compilador requiere un tipo de <code>unit</code> y se queja.  Por ejemplo, los dos casos siguientes causar√°n un error del compilador: </p><br><pre> <code class="plaintext hljs">do 1+1 // =&gt; FS0020: This expression should have type 'unit' let something = 2+2 // =&gt; FS0020: This expression should have type 'unit' "hello"</code> </pre> <br><p>  Para ayudar en estas situaciones, hay una funci√≥n especial de <code>ignore</code> que toma cualquier cosa y devuelve la <code>unit</code> .  La versi√≥n correcta de este c√≥digo podr√≠a ser esta: </p><br><pre> <code class="plaintext hljs">do (1+1 |&gt; ignore) // ok let something = 2+2 |&gt; ignore // ok "hello"</code> </pre> <br><h2>  Tipos gen√©ricos </h2><br><p>  En la mayor√≠a de los casos, si el tipo de un par√°metro de funci√≥n puede ser de cualquier tipo, necesitamos decir algo al respecto.  F # usa gen√©ricos .NET para tales situaciones. </p><br><p>  Por ejemplo, la siguiente funci√≥n convierte un par√°metro en una cadena al agregar texto: </p><br><pre> <code class="plaintext hljs">let onAStick x = x.ToString() + " on a stick"</code> </pre> <br><p>  No importa qu√© tipo de par√°metro, todos los objetos pueden hacer en <code>ToString()</code> . </p><br><p>  Firma: </p><br><pre> <code class="plaintext hljs">val onAStick : 'a -&gt; string</code> </pre> <br><p>  ¬øQu√© tipo <code>'a</code> ?  En F #, es una forma de indicar un tipo gen√©rico que es desconocido en tiempo de compilaci√≥n.  Un ap√≥strofe antes de "a" significa que el tipo es gen√©rico.  Equivalente a esta firma en C #: </p><br><pre> <code class="plaintext hljs">string onAStick&lt;a&gt;(); //   string OnAStick&lt;TObject&gt;(); // F#-   'a    // C#'-   "TObject"  </code> </pre> <br><p>  Debe entenderse que esta funci√≥n F # todav√≠a tiene una tipificaci√≥n fuerte incluso con tipos gen√©ricos.  No acepta un par√°metro de tipo <code>Object</code> .  La escritura fuerte es buena porque le permite mantener la seguridad de su tipo al componer funciones. </p><br><p>  La misma funci√≥n se usa para <code>int</code> , <code>float</code> y <code>string</code> . </p><br><pre> <code class="plaintext hljs">onAStick 22 onAStick 3.14159 onAStick "hello"</code> </pre> <br><p>  Si hay dos par√°metros generalizados, entonces el compilador les dar√° dos nombres diferentes: <code>'a</code> para el primero, <code>'b</code> para el segundo, etc.  Por ejemplo: </p><br><pre> <code class="plaintext hljs">let concatString xy = x.ToString() + y.ToString()</code> </pre> <br><p>  Habr√° dos tipos gen√©ricos en esta firma: <code>'a</code> y <code>'b</code> : </p><br><pre> <code class="plaintext hljs">val concatString : 'a -&gt; 'b -&gt; string</code> </pre> <br><p>  Por otro lado, el compilador reconoce cuando solo se requiere un tipo gen√©rico.  En el siguiente ejemplo, <code>x</code> e <code>y</code> deben ser del mismo tipo: </p><br><pre> <code class="plaintext hljs">let isEqual xy = (x=y)</code> </pre> <br><p>  Entonces, una firma de funci√≥n tiene el mismo tipo gen√©rico para ambos par√°metros: </p><br><pre> <code class="plaintext hljs">val isEqual : 'a -&gt; 'a -&gt; bool</code> </pre> <br><p>  Los par√°metros generalizados tambi√©n son muy importantes cuando se trata de listas y otras estructuras abstractas, y veremos muchas de ellas en los siguientes ejemplos. </p><br><h2>  Otros tipos </h2><br><p>  Hasta ahora, solo se han discutido los tipos b√°sicos.  Estos tipos se pueden combinar de varias maneras en tipos m√°s complejos.  Su an√°lisis completo ser√° m√°s adelante en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otra serie</a> , pero mientras tanto, y aqu√≠ los analizaremos brevemente, para que pueda reconocerlos en las firmas de funciones. </p><br><ul><li>  <strong>Tuplas</strong>  Este es un par, un triple, etc., compuesto de otros tipos.  Por ejemplo, <code>("hello", 1)</code> es una tupla basada en <code>string</code> e <code>int</code> .  Una coma es un sello distintivo de las tuplas; si una coma se ve en alg√∫n lugar de F #, es casi seguro que sea parte de la tupla. <br>  En las firmas de funciones, las tuplas se escriben como "productos" de los dos tipos involucrados.  En este caso, la tupla ser√° del tipo: </li></ul><br><pre> <code class="plaintext hljs">string * int // ("hello", 1)</code> </pre> <br><ul><li>  <strong>Colecciones</strong>  Los m√°s comunes son list (list), seq (secuencia) y array.  Las listas y las matrices tienen un tama√±o fijo, mientras que las secuencias son potencialmente infinitas (detr√°s de escena, las secuencias son las mismas <code>IEnumrable</code> ).  En las firmas de funciones, tienen sus propias palabras clave: " <code>list</code> ", " <code>seq</code> " y " <code>[]</code> " para matrices. </li></ul><br><pre> <code class="plaintext hljs">int list // List type  [1;2;3] string list // List type  ["a";"b";"c"] seq&lt;int&gt; // Seq type  seq{1..10} int [] // Array type  [|1;2;3|]</code> </pre> <br><ul><li>  <strong>Opci√≥n (tipo opcional)</strong> .  Este es un contenedor simple sobre objetos que pueden faltar.  Hay dos opciones: <code>Some</code> (cuando el valor existe) y <code>None</code> (cuando el valor no existe).  En las firmas de funciones, tienen su propia palabra clave " <code>option</code> ": </li></ul><br><pre> <code class="plaintext hljs">int option // Some 1</code> </pre> <br><ul><li>  <strong>La marcada asociaci√≥n (uni√≥n discriminada)</strong> .  Se construyen a partir de muchas variaciones de otros tipos.  Vimos algunos ejemplos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"¬øpor qu√© usar F #?"</a>  .  En las firmas de funciones, se hace referencia a ellas por nombre de tipo; no tienen una palabra clave especial. </li><li>  <strong>Tipo de registro (registros)</strong> .  Tipos como estructuras de bases de datos o filas, un conjunto de valores con nombre.  Tambi√©n vimos algunos ejemplos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"¬øpor qu√© usar F #?"</a>  .  En las firmas de funciones, se llaman por nombre de tipo y tampoco tienen su propia palabra clave. </li></ul><br><h2>  Pon a prueba tu comprensi√≥n de los tipos </h2><br><p>  Aqu√≠ hay algunas expresiones para evaluar su comprensi√≥n de las firmas de funciones.  Para verificar, simplemente ejec√∫telos en una ventana interactiva. </p><br><pre> <code class="plaintext hljs">let testA = float 2 let testB x = float 2 let testC x = float 2 + x let testD x = x.ToString().Length let testE (x:float) = x.ToString().Length let testF x = printfn "%s" x let testG x = printfn "%f" x let testH = 2 * 2 |&gt; ignore let testI x = 2 * 2 |&gt; ignore let testJ (x:int) = 2 * 2 |&gt; ignore let testK = "hello" let testL() = "hello" let testM x = x=x let testN x = x 1 // :     x? let testO x:string = x 1 // :    :string ?</code> </pre> <br><h1>  Recursos Adicionales </h1><br><p>  Hay muchos tutoriales para F #, incluidos los materiales para aquellos que vienen con experiencia en C # o Java.  Los siguientes enlaces pueden ser √∫tiles a medida que profundiza en F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # por diversi√≥n y ganancias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprenda X en minutos Y: F #</a> </li></ul><br><p>  Tambi√©n se describen varias otras formas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de comenzar a aprender F #</a> . </p><br><p>  Finalmente, la comunidad F # es muy amigable para principiantes.  Hay un chat muy activo en Slack, respaldado por la F # Software Foundation, con salas para principiantes a las que puedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">unirte libremente</a> .  ¬°Recomendamos encarecidamente que haga esto! </p><br><p>  ¬°No te olvides de visitar el sitio de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de habla rusa F #</a> !  Si tiene alguna pregunta sobre el aprendizaje de un idioma, estaremos encantados de discutirlo en las salas de chat: </p><br><ul><li>  room <code>#ru_general</code> en el <code>#ru_general</code> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en gitter</a> </li></ul><br><h2>  Sobre autores de traducci√≥n </h2><br><p>  Traducido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  La traducci√≥n y los cambios editoriales fueron realizados por los esfuerzos de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de desarrolladores de F # de habla rusa</a> .  Tambi√©n agradecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@schvepsss</em></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@shwars</em></a> por preparar este art√≠culo para su publicaci√≥n. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422115/">https://habr.com/ru/post/es422115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422099/index.html">Los grandes operadores ganar√°n con la "Ley de Primavera" al proporcionar servicios de alojamiento a peque√±os operadores</a></li>
<li><a href="../es422103/index.html">¬øPor qu√© un programador deber√≠a poder escribir bien?</a></li>
<li><a href="../es422107/index.html">Ampliar el desarrollo: desde el inicio hasta cientos de ingenieros</a></li>
<li><a href="../es422109/index.html">Firefox bloquear√° el seguimiento de usuarios por defecto</a></li>
<li><a href="../es422113/index.html">Fintech Digest: el Banco Central har√° un seguimiento de las v√≠ctimas de los piratas inform√°ticos, los rusos recibir√°n una calificaci√≥n crediticia, Yahoo Finance y cripto trading</a></li>
<li><a href="../es422119/index.html">Kit de herramientas para desarrolladores de juegos independientes</a></li>
<li><a href="../es422121/index.html">C√≥mo irme a Alemania para estudiar y trabajar en el ejemplo de mi emigraci√≥n.</a></li>
<li><a href="../es422123/index.html">C√≥mo dejar de fallar y comenzar a realizar flashbacks normales</a></li>
<li><a href="../es422125/index.html">Diagn√≥stico SENS. Biomarcadores agregados de prote√≠nas</a></li>
<li><a href="../es422127/index.html">Al diablo con la raz√≥n. A veces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>