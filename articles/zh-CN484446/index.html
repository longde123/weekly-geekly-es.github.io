<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💚 🈵 💆🏼 Python 3.5使用asyncio实现并发 ⛵️ 🔱 🏈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第13章并发的翻译 
 摘自《 Expert Python Programming》一书， 
 第二版 
 MichałJaworski和TarekZiadé，2016年 
 
 异步编程 
 近年来，异步编程获得了极大的欢迎。 Python 3.5终于有了一些语法功能，这些功能加强了异步解决方案的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python 3.5使用asyncio实现并发</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484446/">  <i>第13章并发的翻译</i> <i><br></i>  <i>摘自《 Expert Python Programming》一书，</i> <i><br></i>  <i>第二版</i> <i><br></i>  <i>MichałJaworski和TarekZiadé，2016年</i> <i><br></i> <br><h4> 异步编程 </h4><br> 近年来，异步编程获得了极大的欢迎。  Python 3.5终于有了一些语法功能，这些功能加强了异步解决方案的概念。 但这并不意味着仅从Python 3.5开始就可以进行异步编程。 许多库和框架是在更早的时候提供的，并且大多数起源于旧版本的Python2。甚至还有一种称为Stackless的Python替代实现（请参见第1章，“ Python的当前状态”），该实现着眼于这种单一编程方法。 对于某些解决方案（例如<b>Twisted，Tornado</b>或<b>Eventlet）</b> ，活跃的社区仍然存在，并且确实值得了解。 无论如何，从Python 3.5开始，异步编程变得比以往任何时候都容易。 因此，可以预期它的内置异步功能将替代大多数旧工具，或者外部项目将逐渐变成一种基于内置Python的高级框架。 <br><a name="habracut"></a><br> 当试图解释什么是异步编程时，最容易将此方法视为类似于线程的方法，但没有系统调度程序。 这意味着异步程序可以同时处理任务，但是其上下文是在内部而不是由系统调度程序切换的。 <br><br> 但是，当然，我们不使用线程对异步程序中的任务进行并行处理。 大多数解决方案使用不同的概念，并且根据实现的不同，它们的名称也不同。 用于描述此类并行程序对象的一些名称示例包括： <br><br><ul><li>  <b>绿色线程</b> -绿色线程（greenlet，gevent或eventlet项目） </li><li> 协程-协程（Python 3.5中的纯异步编程） </li><li>  <b>Tasklets（无堆栈Python）</b>这些基本上是相同的概念，但是通常以略有不同的方式实现。 </li></ul><br> 出于明显的原因，在本节中，我们将仅关注Python从3.5版开始最初支持的协程。 <br><br><h4> 协作多任务和异步I / O </h4><br> 协作式多任务处理是异步编程的核心。 从这个意义上讲，不需要操作系统中的多任务来启动上下文切换（切换到另一个进程或线程），而是每个进程在处于待机模式时都自动释放控制权，以确保同时执行多个程序。 这就是为什么它被称为协作。 所有进程必须一起工作以确保多任务成功。 <br><br> 多任务模型有时在操作系统中使用，但是现在几乎找不到它作为系统级解决方案。 这是因为存在一项服务设计不当会轻易破坏整个系统稳定性的风险。 当前，使用直接由操作系统控制的上下文切换来调度线程和进程是在系统级别进行并发的主要方法。 但是协作多任务处理在应用程序级别仍然是一个很好的并发工具。 <br><br> 说到应用程序级别的联合多任务，我们不处理需要释放控制权的线程或进程，因为所有执行都包含在一个进程和线程中。 取而代之的是，我们有几个任务（协程，tasklet和绿色线程）将控制权转移到控制任务协调的单个函数中。 此函数通常是一种事件循环。 <br><br> 为了避免混淆（由于Python术语），我们现在将此类并行任务称为协程。 协作多任务处理中最重要的问题是何时转移控制权。 在大多数异步应用程序中，控制在I / O操作期间传递给调度程序或事件循环。 无论程序是从文件系统中读取数据还是通过套接字进行通信，当进程变为非活动状态时，此类I / O操作始终与一定的等待时间相关联。 等待时间取决于外部资源，因此这是释放控制权的好机会，以便其他协程可以执行其工作，直到它们还必须等待这种行为与在Python中实现多线程的行为有点相似为止。 我们知道GIL可以序列化Python线程，但是每个I / O操作都可以释放它。 主要区别在于Python中的线程是作为系统级线程实现的，因此操作系统可以随时卸载当前正在运行的线程并将控制权转移给另一个线程。 <br><br> 在异步编程中，任务永远不会被主事件循环中断。 这就是为什么这种多任务处理样式也称为非优先级多任务处理的原因。 <br><br> 当然，每个Python应用程序都在一个操作系统上运行，在该操作系统上还有其他进程争用资源。 这意味着操作系统始终有权卸载整个过程并将控制权转移给另一个。 但是，当异步应用程序重新启动时，它将从系统调度程序介入时暂停的位置继续。 这就是为什么协程在这种情况下不拥挤的原因。 <br><br><h4>  Python异步和等待关键字 </h4><br> 关键字<i>async</i>和<i>await</i>是异步Python编程中的主要构建块。 <br><br> 在<i>def</i>语句之前使用的<i>async关键字</i>定义了新的协程。 协程函数可以在严格定义的情况下暂停和恢复。 它的语法和行为与生成器非常相似（请参见类级别下的第2章，“语法建议”）。 实际上，应在旧版本的Python中使用生成器来实现协程。 这是使用<i>async关键字</i>的函数的示例声明： <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"hello, world!"</span></span>)</code> </pre> <br> 使用<i>async关键字</i>定义的功能很特殊。 调用它们时，它们不在内部执行代码，而是返回一个协程对象： <br><br><pre> <b><code class="plaintext hljs">&gt;&gt;&gt;&gt; async def async_hello(): ... print("hello, world!") ... &gt;&gt;&gt; async_hello() &lt;coroutine object async_hello at 0x1014129e8&gt;</code></b> </pre><br> 协程对象不会执行任何操作，直到在事件循环中安排了它的执行为止。  asyncio模块可用于提供事件循环的基本实现，以及许多其他异步实用程序： <br><br><pre> <b><code class="plaintext hljs">&gt;&gt;&gt; import asyncio &gt;&gt;&gt; async def async_hello(): ... print("hello, world!") ... &gt;&gt;&gt; loop = asyncio.get_event_loop() &gt;&gt;&gt; loop.run_until_complete(async_hello()) hello, world! &gt;&gt;&gt; loop.close()</code></b> </pre><br> 自然，仅创建一个简单的协程，在我们的程序中我们不实现并行性。 为了看到真正平行的东西，我们需要创建更多由事件循环执行的任务。 <br><br> 可以通过调用<i>loop.create_task（）</i>方法或通过提供另一个对象来等待使用<i>asyncio.wait（）</i>函数来将新任务添加到循环中。 我们将使用后一种方法，并尝试异步打印使用<i>range（）</i>函数生成的数字序列： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_number</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> print(number) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: loop = asyncio.get_event_loop() loop.run_until_complete( asyncio.wait([ print_number(number) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>) ]) ) loop.close()</code> </pre><br>  <i>asyncio.wait（）</i>函数接受协程对象列表并立即返回。 结果是生成器，该生成器生成表示将来结果（未来）的对象。 顾名思义，它用于等待所有提供的协程完成。 它返回生成器而不是协程对象的原因是因为它与Python的早期版本向后兼容，这将在后面解释。 执行此脚本的结果可能如下： <br><br><pre> <b><code class="plaintext hljs">$ python asyncprint.py 0 7 8 3 9 4 1 5 2 6</code></b> </pre><br> 如我们所见，数字不是按照创建协程的顺序打印的。 但这正是我们想要实现的目标。 <br><br>  Python 3.5中添加的第二个重要关键字是<i>await</i> 。 它用于等待协程或将来事件的结果（稍后说明），并在事件循环中释放对执行的控制。 为了更好地理解它是如何工作的，我们需要考虑一个更复杂的代码示例。 <br><br> 假设我们要创建两个协程，它们将在循环中执行一些简单的任务： <br><br><ul><li> 等待随机的秒数 </li><li> 打印一些作为参数提供的文本，以及等待所花费的时间。 让我们从一个简单的实现开始，该实现存在一些并发性问题，稍后我们将尝试通过额外使用await来改善这些并发性问题： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>): time_to_sleep = random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) / <span class="hljs-number"><span class="hljs-number">4</span></span> time.sleep(time_to_sleep) print( <span class="hljs-string"><span class="hljs-string">"{} waited {} seconds"</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.format(name, time_to_sleep) ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([waiter(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>), waiter(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: loop = asyncio.get_event_loop() loop.run_until_complete(main()) loop.close()</code> </pre></li></ul><br> 在终端中执行时（使用time命令测量时间），您可以看到： <br><br><pre> <b><code class="plaintext hljs">$ time python corowait.py bar waited 0.25 seconds bar waited 0.25 seconds bar waited 0.5 seconds bar waited 0.5 seconds foo waited 0.75 seconds foo waited 0.75 seconds foo waited 0.25 seconds foo waited 0.25 seconds real 0m3.734s user 0m0.153s sys 0m0.028s</code></b> </pre><br><br> 如我们所见，这两个协程都完成了执行，但不是异步完成的。 原因是它们都使用<i>time.sleep（）</i>函数，该函数锁定但不释放事件循环中的控件。 这在多线程安装中会更好，但是我们现在不希望使用线程。 那么我们该如何解决呢？ <br><br> 答案是使用<i>asyncio.sleep（）</i> ，它是<i>time.sleep（）</i>的异步版本，并使用<i>await</i>关键字期望结果。 我们已经在<i>main（）</i>的第一个版本中使用了此语句，但这只是为了提高代码的清晰度。 显然，这并没有使我们的实现更加并行。 让我们看一下使用await asyncio.sleep（）的<i>侍者（）</i>协程的改进版本： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>): time_to_sleep = random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) / <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(time_to_sleep) print( <span class="hljs-string"><span class="hljs-string">"{} waited {} seconds"</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.format(name, time_to_sleep) )</code> </pre><br><br> 运行更新的脚本，我们将看到两个函数的输出如何相互交替： <br><br><pre> <b><code class="plaintext hljs">$ time python corowait_improved.py bar waited 0.25 seconds foo waited 0.25 seconds bar waited 0.25 seconds foo waited 0.5 seconds foo waited 0.25 seconds bar waited 0.75 seconds foo waited 0.25 seconds bar waited 0.5 seconds real 0m1.953s user 0m0.149s sys 0m0.026s</code></b> </pre><br><br> 这种简单改进的另一个好处是代码运行速度更快。 总执行时间少于所有睡眠时间的总和，因为协程可以一一控制。 <br><br><h4> 先前版本的Python中的Asyncio </h4><br>  asyncio模块出现在Python 3.4中。 因此，这是唯一一个在Python 3.5之前就严重支持异步编程的Python版本。 不幸的是，这两个后续版本似乎足以引起兼容性问题。 <br><br> 无论如何，Python中的异步编程核心是在支持此模板的语法元素之前引入的。 迟来总比没有好，但是这造成了使用协同程序使用两种语法的情况。 <br><br> 从Python 3.5开始，您可以使用<i>async</i>和<i>await</i> ： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><br> 但是，在Python 3.4中，您将必须另外应用asyncio.coroutine装饰器并在coroutine文本中产生： <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@asyncio.couroutine def main(): yield from asyncio.sleep(0)</span></span></code> </pre><br><br> 另一个有用的事实是，Python 3.3中引入了<i>yield from语句</i> ，并且PyPI具有异步反向端口。 这意味着您还可以在Python 3.3中使用这种协作式多任务处理的实现。 <br><br><h4> 异步编程的实际示例 </h4><br> 如本章多次提到的那样，异步编程是处理I / O的绝佳工具。 现在是时候创建一些比打印序列或异步等待更实用的东西了。 <br><br> 为了确保一致性，我们将尝试解决在多线程和多处理帮助下解决的相同问题。 因此，我们将尝试通过网络连接从外部资源异步提取一些数据。 如果我们可以使用与前面几节相同的<i>python-gmaps</i>包，那将是很好的。 不幸的是，我们不能。 <br><br>  <i>python-gmaps</i>的创建者有点懒，只取了名字。 为了简化开发，他选择了请求包作为他的HTTP客户端库。 不幸的是，请求不支持带有<i>async</i>和<i>await的</i>异步I / O。 还有其他一些项目旨在为查询项目提供一些并行性，但它们要么依赖于<i>Gevent</i> （ <i>grequests</i> ，请参见<i>https://github.com/ kennethreitz / grequests</i> ），要么运行线程/进程池（query-futures）请参阅<i><a href="https://github.com/ross/requests-futures" rel="nofollow">github.com/ross/requests-futures</a></i> ）。 它们都不能解决我们的问题。 <br><br><blockquote>  <i>在责备自己责骂无辜的开源开发人员之前，请冷静下来。</i>  <i><i>python-gmaps</i>软件包背后的人是我。</i>  <i>依赖项选择不当是该项目的问题之一。</i>  <i>我只想不时公开批评自己。</i>  <i>这对我来说是一个痛苦的教训，因为最新版本的<i>python-gmaps</i> （在撰写本书时为0.3.1）无法轻松地与Python的异步I / O集成。</i>  <i>无论如何，这种情况将来可能会改变，因此不会丢失任何内容。</i> <br></blockquote> 了解了库的局限性（在前面的示例中是如此易于使用），我们需要创建一些东西来填补这一空白。  Google MapsAPI确实非常易于使用，因此我们将介绍一个异步实用程序，仅供说明。  Python 3.5的标准库仍然缺少可以像调用<i>urllib.urlopen（）</i>一样轻松地执行异步HTTP请求的库。 我们绝对不想从头开始创建完整的协议支持，因此我们将使用PyPI中提供的<i>aiohttp</i>包中的一些帮助。 这是一个非常有前途的库，它为异步HTTP添加了客户端和服务器实现。 这是在<i>aiohttp</i>之上构建的一个小模块，它创建一个<i>geocode（）</i>帮助器函数，该函数执行对Google Maps API服务的地理编码请求： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp session = aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geocode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(place)</span></span></span><span class="hljs-function">:</span></span> params = { <span class="hljs-string"><span class="hljs-string">'sensor'</span></span>: <span class="hljs-string"><span class="hljs-string">'false'</span></span>, <span class="hljs-string"><span class="hljs-string">'address'</span></span>: place } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get( <span class="hljs-string"><span class="hljs-string">'https://maps.googleapis.com/maps/api/geocode/json'</span></span>, params=params ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response: result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'results'</span></span>]</code> </pre><br><br> 假设此代码存储在名为<i>asyncgmaps</i>的模块中，我们将在以后使用。 现在，我们准备重写在多线程和多处理讨论中使用的示例。 以前，我们曾经将整个操作分为两个单独的阶段： <br><br><ol><li> 使用<i>fetch_place（）</i>函数并行执行对外部服务的所有请求。 </li><li> 使用<i>present_result（）</i>函数循环显示所有结果。 </li></ol><br> 但是，由于协作式多任务处理与使用多个进程或线程完全不同，因此我们可以略微更改方法。 每个项目使用单个线程中提出的大多数问题不再是我们关注的问题。 <br> 协程不是抢先的，因此我们可以在收到HTTP响应后立即轻松显示结果。 这将简化我们的代码并使之更易于理解： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-comment"><span class="hljs-comment"># note: local module introduced earlier from asyncgmaps import geocode, session PLACES = ( 'Reykjavik', 'Vien', 'Zadar', 'Venice', 'Wrocław', 'Bolognia', 'Berlin', 'Słubice', 'New York', 'Dehli', ) async def fetch_place(place): return (await geocode(place))[0] async def present_result(result): geocoded = await result print("{:&gt;25s}, {:6.2f}, {:6.2f}".format( geocoded['formatted_address'], geocoded['geometry']['location']['lat'], geocoded['geometry']['location']['lng'], )) async def main(): await asyncio.wait([ present_result(fetch_place(place)) for place in PLACES ]) if __name__ == "__main__": loop = asyncio.get_event_loop() loop.run_until_complete(main()) # aiohttp will raise issue about unclosed # ClientSession so we perform cleanup manually loop.run_until_complete(session.close()) loop.close()</span></span></code> </pre><br><br> 异步编程非常适合对构建可伸缩应用程序感兴趣的后端开发人员。 实际上，这是用于创建竞争激烈的服务器的最重要工具之一。 <br><br> 但是现实是可悲的。 许多处理I / O问题的流行软件包都不打算与异步代码一起使用。 造成这种情况的主要原因是： <br><br><ul><li>  Python 3的实施仍很低，并具有一些高级功能 </li><li> 初学者对Python的各种并发概念了解不足 </li></ul><br> 这意味着，由于架构限制，现有同步多线程应用程序和程序包的迁移常常是不可能的，或者迁移成本太高。 许多项目可以从异步多任务样式的实现中受益匪浅，但最终只有少数项目会这样做。 这意味着现在从一开始就尝试创建异步应用程序将遇到很多困难。 在大多数情况下，这将与“异步编程的实际示例”部分中提到的问题类似-接口不兼容和I / O操作的非同步阻塞。 当然，有时您会在遇到这种不兼容性时放弃等待，而只是同步获取必要的资源。 但这会在等待结果时互相阻止协程执行其代码。 从技术上讲，这行得通，但同时也破坏了异步编程的所有好处。 因此，最终，将异步I / O与同步I / O结合起来不是一个选择。 这是一个全有或全无的游戏。 <br><br> 另一个问题是冗长的处理器绑定操作。 当执行I / O操作时，从协程释放控制没有问题。 从文件系统或套接字进行写入/读取时，您最终将等待，因此使用await进行的调用是您最好的方法。 但是，如果您需要计算一些东西，并且知道需要一些时间，该怎么办？ 当然，您可以将问题分为几部分，并在每次稍加推进时取消控制。 但是很快您会发现这不是一个很好的模型。 这样的事情会使代码混乱，也不能保证良好的结果。 <br><br> 时间绑定应由解释器或操作系统负责。 <br><br><h4> 将异步代码与异步期货相结合 </h4><br> 因此，如果您具有执行长时间同步I / O的代码而无法执行或不想重写该怎么办。 还是必须在主要为异步I / O设计的应用程序中执行一些繁重的处理器操作时怎么办？ 好吧...您需要找到解决方法。 我所说的是多线程或多处理。 <br><br> 这听起来可能不太好，但是有时最好的解决方案可能是我们试图摆脱的解决方案。 由于采用了多重处理，因此在Python中对资源密集型任务的并行处理始终可以更好地执行。 多线程可以异步地处理I / O操作（迅速且没有大量资源），就像异步处理一样，并且如果配置正确且谨慎处理，则可以等待。 <br><br> 因此，有时候，当某些东西不适合您的异步应用程序时，您不知道该怎么做时，请使用一段代码将其放在单独的线程或进程中。 您可以假装它是协程，释放事件循环的控制权，并在准备好结果时最终对其进行处理。 <br><br> 对我们来说幸运的是，Python标准库提供了<i>current.futures</i>模块，该模块也与<i>asyncio</i>模块集成在一起。 这两个模块一起使您可以计划在线程或其他进程中运行的阻塞函数，就好像它们是异步非阻塞协程。 <br><br><h4> 执行人和期货 </h4><br> 在看到如何在异步事件循环中嵌入线程或进程之前，我们将仔细研究<i>并发</i>模块。将来，该模块将成为我们所谓的解决方法的主要组成部分。 <br><br>  <i>parallel.futures</i>模块中最重要的类是<i>Executor</i>和<i>Future</i> 。 <br><br>  <i>执行程序</i>是可以并行处理工作项的资源池。 它的目的似乎与多处理器模块中的类<i>Pool</i>和<i>dummy.Pool</i>十分相似，但是它具有完全不同的接口和语义。 这是不打算实现的基类，具有两个特定的实现： <br><br><ul><li>  <i>ThreadPoolExecutor</i> ：代表线程池 </li><li>  <i>ProcessPoolExecutor</i> ：代表进程池 </li></ul><br> 每个<i>执行者</i>提出三种方法： <br><br><ul><li>  <i>Submit（fn，* args，** kwargs）</i> ：调度fn函数在资源池中执行，并返回一个Future对象，该对象代表被调用对象的执行 </li><li>  <i>map（func，* iterables，timeout = None，chunksize = 1）</i> ： <i>func</i>函数在迭代上执行，类似于多处理。  <i>Pool.map（）</i>方法 </li><li>  <i>shutdown（wait = True）</i> ：这将关闭<i>执行器</i>并释放其所有资源。 </li></ul><br> 最有趣的方法是<i>Submit（），</i>因为它返回了Future对象。 它表示被调用的异步执行，并且仅间接表示其结果。 若要获取调度的被调用对象的实际返回值，必须调用<i>Future.result（）</i>方法。 如果被调用的对象已经完成，则<i>result（）</i>方法将不会阻塞该对象，而只会返回该函数的输出。 如果不是，他将阻止它，直到结果准备好为止。 将其视为对结果的承诺（实际上与JavaScript中的承诺是同一概念）。 您不需要在收到它后立即解压缩它（使用<i>result（）</i>方法），但是如果您尝试这样做，则可以保证最终返回一些信息： <br><br><pre> <b><code class="plaintext hljs">&gt;&gt;&gt; def loudy_return(): ... print("processing") ... return 42 ... &gt;&gt;&gt; from concurrent.futures import ThreadPoolExecutor &gt;&gt;&gt; with ThreadPoolExecutor(1) as executor: ... future = executor.submit(loudy_return) ... processing &gt;&gt;&gt; future &lt;Future at 0x33cbf98 state=finished returned int&gt; &gt;&gt;&gt; future.result() 42</code></b> </pre><br><br> 如果要使用<i>Executor.map（）</i>方法，则其<i>用法</i>与多处理器模块的<i>Pool</i>类的<i>Pool.map（）</i>方法没有什么不同： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ThreadPoolExecutor(POOL_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pool: results = pool.map(fetch_place, PLACES) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results: present_result(result)</code> </pre><br><br><h4> 在事件<i>循环中</i>使用<i>执行器</i> </h4><br> 从概念上讲， <i>Executor.submit（）</i>方法返回的Future类的实例与异步编程中使用的协程非常接近。 这就是为什么我们可以使用美工来创建协作多任务与多处理或多线程之间的混合体的原因。 <br><br> 此解决方法的核心是<i>事件</i>循环类的<i>BaseEventLoop.run_in_executor（执行程序，func，* args）</i>方法。 这使您可以计划在executor参数表示的进程或线程池中执行func函数。 此方法最重要的是，它返回新的期望对象（可以使用await运算符期望的对象）。 因此，由于这个原因，您可以执行与协程完全不同的协程而不是协程，并且无论完成多长时间，它都不会阻塞。 它将仅停止期望从此类调用获得结果的函数，但整个事件周期将继续。 <br><br> 一个有用的事实是，您甚至不需要创建自己的执行者实例。 如果将<i>None</i>作为参数传递给<i>executor</i> ，则<i>ThreadPoolExecutor</i>类将与默认线程数一起使用（对于Python 3.5，这是处理器数乘以5）。 <br><br> 因此，让我们假设我们不想重写python-gmaps包中引起我们头痛的问题部分。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop.run_in_executor（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轻松地将阻塞调用推迟到单独的线程</font><font style="vertical-align: inherit;">，同时将fetch_place（）函数保留为预期的协程：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_place</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(place)</span></span></span><span class="hljs-function">:</span></span> coro = loop.run_in_executor(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, api.geocode, place) result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> coro <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样的解决方案比拥有一个完全异步的库来完成这项工作更糟糕，但是您知道至少有些事情总比没有好。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在解释了真正的并发性之后，我们采取了行动并使用多线程分析了典型的并行问题之一。在确定了代码的主要缺陷并纠正了这些缺陷之后，我们转向多处理，以了解在我们的案例中它如何工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之后，我们发现使用多处理器模块，使用多个进程比使用多线程的基本线程容易得多。但是只有在那之后，我们才意识到可以通过</font><i><font style="vertical-align: inherit;">multiprocessing.dummy</font></i><font style="vertical-align: inherit;">将相同的API与线程一起使用</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，现在在多处理和多线程之间进行选择仅取决于最适合该问题的解决方案，而不取决于哪个接口具有最佳的解决方案。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说到解决问题，我们最终尝试了异步编程，该编程应该是I / O相关应用程序的最佳解决方案，只是要了解我们不能完全忘记线程和进程。因此，我们绕了一圈，回到了起点！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这使我们得出本章的最终结论。</font><font style="vertical-align: inherit;">没有适合所有人的解决方案。</font><font style="vertical-align: inherit;">您可能会喜欢或喜欢几种方法。</font><font style="vertical-align: inherit;">有一些方法更适合解决此类问题，但是您需要了解所有方法才能成功。</font><font style="vertical-align: inherit;">在现实的情况下，您可以在一个应用程序中使用全部工具和并行样式，这并不罕见。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一个结论是对下一章第14章“有用的设计模式”的主题的出色介绍。</font><font style="vertical-align: inherit;">由于没有单一的模板可以解决您的所有问题。</font><font style="vertical-align: inherit;">您应该尽可能多地了解，因为最终您将每天使用它们。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484446/">https://habr.com/ru/post/zh-CN484446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484436/index.html">不感恩的开源：最快的Web服务器的开发人员已删除其存储库-重要更新</a></li>
<li><a href="../zh-CN484438/index.html">著名的流体方程泄漏</a></li>
<li><a href="../zh-CN484440/index.html">使用标准Windows工具进行完全备份</a></li>
<li><a href="../zh-CN484442/index.html">SNMPv3示例</a></li>
<li><a href="../zh-CN484444/index.html">工作条件如何影响电池或奇迹般的复活</a></li>
<li><a href="../zh-CN484448/index.html">DEFCON会议27.砍警察。 第一部分</a></li>
<li><a href="../zh-CN484454/index.html">哈布拉侦探：你的照片丢了</a></li>
<li><a href="../zh-CN484456/index.html">ReactJS，服务器端渲染和处理页面元标记的一些技巧</a></li>
<li><a href="../zh-CN484458/index.html">这个自由职业者坏了-下一个给我</a></li>
<li><a href="../zh-CN484462/index.html">抄袭Github：搜索要开发的“秘密”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>