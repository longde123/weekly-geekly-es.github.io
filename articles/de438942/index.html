<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéß üë©üèø‚Äçü§ù‚Äçüë®üèæ üîù 2D-Schatten auf signierten Distanzfeldern üî∑ ü¶â üó∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jetzt, da wir die Grundlagen der Kombination von vorzeichenbehafteten Distanzfunktionen kennen, k√∂nnen Sie sie verwenden, um coole Dinge zu erstellen....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>2D-Schatten auf signierten Distanzfeldern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438942/"> Jetzt, da wir die Grundlagen der Kombination von vorzeichenbehafteten Distanzfunktionen kennen, k√∂nnen Sie sie verwenden, um coole Dinge zu erstellen.  In diesem Tutorial werden wir sie verwenden, um weiche zweidimensionale Schatten zu rendern.  Wenn Sie meine vorherigen Tutorials zu signierten Distanzfeldern (SDF) nicht gelesen haben, empfehle ich Ihnen dringend, sie zu studieren, beginnend mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial zum Erstellen einfacher Formen</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/el/eh/ylelehlfeymk9yzxs5eezpyzyfq.gif"></div><br>  [GIF erzeugte w√§hrend der Rekomprimierung zus√§tzliche Artefakte.] <br><a name="habracut"></a><br><h2>  Grundkonfiguration </h2><br>  Ich habe eine einfache Konfiguration mit einem Raum erstellt, die die in fr√ºheren Tutorials beschriebenen Techniken verwendet.  Zuvor habe ich nicht erw√§hnt, dass ich die <code>abs</code> Funktion f√ºr vector2 verwendet habe, um die Position relativ zur x- und y-Achse zu spiegeln, und dass ich den Abstand der Figur umgekehrt habe, um den inneren und den √§u√üeren Teil zu vertauschen. <br><br>  Wir werden die Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2D_SDF.cginc</a> aus dem vorherigen Tutorial in einen Ordner mit dem Shader kopieren, den wir in diesem Tutorial schreiben werden. <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/037_2D_SDF_Shadows"</span></span>{ Properties{ } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float bounds = -rectangle(position, 2); float2 quarterPos = abs(position); float corner = rectangle(translate(quarterPos, 1), 0.5); corner = subtract(corner, rectangle(position, 1.2)); float diamond = rectangle(rotate(position, 0.125), .5); float world = merge(bounds, corner); world = merge(world, diamond); return world; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); return dist; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  Wenn wir immer noch die Visualisierungstechnik aus dem vorherigen Tutorial verwenden w√ºrden, w√ºrde die Abbildung folgenderma√üen aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ff/2cc/aee/5ff2ccaee5f12c0f87a1b7ae455bc044.png"></div><br><h2>  Einfache Schatten </h2><br>  Um scharfe Schatten zu erzeugen, gehen wir um den Raum von der Position der Probe zur Position der Lichtquelle.  Wenn wir unterwegs ein Objekt finden, entscheiden wir, dass das Pixel schattiert werden soll, und wenn wir ungehindert zur Quelle gelangen, sagen wir, dass es nicht schattiert ist. <br><br>  Wir beginnen mit der Berechnung der Grundparameter des Strahls.  Wir haben bereits einen Startpunkt (die Position des Pixels, das wir rendern) und einen Zielpunkt (die Position der Lichtquelle) f√ºr den Strahl.  Wir brauchen eine L√§nge und eine normalisierte Richtung.  Die Richtung kann erhalten werden, indem der Anfang vom Ende subtrahiert und das Ergebnis normalisiert wird.  Die L√§nge kann erhalten werden, indem die Positionen subtrahiert und der Wert an die <code>length</code> wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> direction = normalise(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = length(lightPosition - position); }</code> </pre> <br>  Dann gehen wir iterativ um den Strahl in der Schleife herum.  Wir werden Iterationen der Schleife in der define-Deklaration festlegen. Auf diese Weise k√∂nnen wir die maximale Anzahl von Iterationen sp√§ter konfigurieren und dem Compiler erm√∂glichen, den Shader durch Erweitern der Schleife ein wenig zu optimieren. <br><br>  In der Schleife ben√∂tigen wir die Position, an der wir uns gerade befinden, also deklarieren wir sie au√üerhalb der Schleife mit dem Anfangswert 0. In der Schleife k√∂nnen wir die Position der Probe berechnen, indem wir den Strahlvorschub multipliziert mit der Richtung des Strahls mit der Basisposition addieren.  Dann probieren wir die vorzeichenbehaftete Distanzfunktion an der gerade berechneten Position aus. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// outside of function #define SAMPLES 32 // in shadow function float rayDistance = 0; for(int i=0 ;i&lt;SAMPLES; i++){ float sceneDist = scene(pos + direction * rayDistance); //do other stuff and move the ray further }</span></span></code> </pre> <br>  Dann pr√ºfen wir, ob wir bereits an dem Punkt sind, an dem wir den Zyklus stoppen k√∂nnen.  Wenn der Abstand der Szene der Entfernungsfunktion mit dem Vorzeichen nahe 1 liegt, k√∂nnen wir annehmen, dass der Strahl durch eine Zahl blockiert ist und 0 zur√ºckgibt. Wenn sich der Strahl weiter als der Abstand zur Lichtquelle ausbreitet, k√∂nnen wir annehmen, dass wir die Quelle ohne Kollisionen erreicht haben und den Wert zur√ºckgeben 1. <br><br>  Wenn die R√ºckgabe nicht erfolgreich ist, m√ºssen Sie die n√§chste Position der Probe berechnen.  Dies erfolgt durch Hinzuf√ºgen eines Abstands in der Strahlvorschubszene.  Der Grund daf√ºr ist, dass die Entfernung in der Szene die Entfernung zur n√§chsten Figur angibt. Wenn wir also diesen Wert zum Strahl hinzuf√ºgen, k√∂nnen wir den Strahl wahrscheinlich nicht weiter als bis zur n√§chsten Figur oder sogar dar√ºber hinaus emittieren, was zum Schattenfluss f√ºhrt. <br><br>  F√ºr den Fall, dass wir zum Zeitpunkt der Fertigstellung des Probenbestands (Ende des Zyklus) auf nichts gesto√üen sind und die Lichtquelle nicht erreicht haben, m√ºssen wir auch den Wert zur√ºckgeben.  Da dies haupts√§chlich neben den Formen geschieht, kurz bevor das Pixel noch als schattiert betrachtet wird, verwenden wir hier den R√ºckgabewert 0. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAMPLES 32 float traceShadows(float2 position, float2 lightPosition){ float2 direction = normalize(lightPosition - position); float lightDistance = length(lightPosition - position); float rayProgress = 0; for(int i=0 ;i</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SAMPLES; i++){ float sceneDist = scene(position + direction * rayProgress); if(sceneDist &lt;= 0){ return 0; } if(rayProgress &gt; lightDistance){ return 1; } rayProgress = rayProgress + sceneDist; } return 0; }</span></span></span></span></code> </pre> <br>  Um diese Funktion zu verwenden, rufen wir sie in einer Fragmentfunktion mit der Position des Pixels und der Position der Lichtquelle auf.  Dann multiplizieren wir das Ergebnis mit einer beliebigen Farbe, um es mit der Farbe der Lichtquellen zu mischen. <br><br>  Ich habe auch die im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Tutorial</a> beschriebene Technik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber Distanzfelder mit einem Zeichen verwendet</a> , um die Geometrie zu visualisieren.  Dann habe ich nur gefaltet und Geometrie hinzugef√ºgt.  Hier k√∂nnen wir einfach die Additionsoperation verwenden und keine lineare Interpolation oder √§hnliche Aktionen ausf√ºhren, da die Form √ºberall dort schwarz ist, wo die Form nicht ist, und der Schatten √ºberall dort schwarz ist, wo die Form ist. <br><br> <code>fixed4 frag(v2f i) : SV_TARGET{ float2 position = i.worldPos.xz;</code> <br> <br><pre> <code class="cpp hljs">float2 lightPos; sincos(_Time.y, lightPos.x <span class="hljs-comment"><span class="hljs-comment">/*sine of time*/</span></span>, lightPos.y <span class="hljs-comment"><span class="hljs-comment">/*cosine of time*/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadows = traceShadows(position, lightPos); float3 light = shadows * float3(<span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = scene(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(sceneDistance) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> binaryScene = smoothstep(distanceChange, -distanceChange, sceneDistance); float3 geometry = binaryScene * float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); float3 col = geometry + light; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(col, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/29f/0cc/3e529f0cc0c90767d42bf4c14916f377.gif"></div><br><h2>  Weiche Schatten </h2><br>  Es ist einfach genug, von diesen harten Schatten zu weicheren und realistischeren zu gelangen.  In diesem Fall wird der Shader nicht viel rechenintensiver. <br><br>  Zuerst ermitteln wir einfach die Entfernung zum n√§chsten Szenenobjekt f√ºr jedes Sample, das wir umgehen, und w√§hlen das n√§chstgelegene aus.  Wenn wir dann 1 zur√ºckgegeben haben, ist es m√∂glich, die Entfernung zur n√§chsten Zahl zur√ºckzugeben.  Damit die Helligkeit des Schattens nicht zu hoch ist und nicht zur Erzeugung seltsamer Farben f√ºhrt, werden wir ihn durch die <code>saturate</code> , die ihn auf ein Intervall von 0 bis 1 begrenzt. Nachdem wir √ºberpr√ºft haben, ob der Strahl der Lichtquelle bereits die Verteilung erreicht hat, erhalten wir ein Minimum zwischen der aktuellsten und der n√§chsten Zahl Andernfalls k√∂nnen wir Proben nehmen, die √ºber die Lichtquelle hinausgehen und seltsame Artefakte erhalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition)</span></span></span></span>{ float2 direction = normalize(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightDistance = length(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rayProgress = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nearest = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ;i&lt;SAMPLES; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDist = scene(position + direction * rayProgress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sceneDist &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rayProgress &gt; lightDistance){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(nearest); } nearest = min(nearest, sceneDist); rayProgress = rayProgress + sceneDist; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/953/680/6af9536801d8eba4596b10e55aba7c3b.png"></div><br>  Das erste, was wir danach bemerken, sind die seltsamen "Z√§hne" im Schatten.  Sie entstehen, weil der Abstand von der Szene zur Lichtquelle weniger als 1 betr√§gt. Ich habe versucht, dem auf verschiedene Weise entgegenzuwirken, konnte aber keine L√∂sung finden.  Stattdessen k√∂nnen wir die Sch√§rfe des Schattens implementieren.  Die Sch√§rfe ist ein weiterer Parameter in der Schattenfunktion.  In der Schleife multiplizieren wir den Abstand in der Szene mit der Sch√§rfe, und mit einer Sch√§rfe von 2 wird der weiche, graue Teil des Schattens halb so gro√ü.  Bei Verwendung der Sch√§rfe kann die Lichtquelle in einem Abstand von mindestens 1 geteilt durch die Sch√§rfe von der Figur entfernt sein, da sonst Artefakte auftreten.  Wenn Sie daher eine Sch√§rfe von 20 verwenden, sollte der Abstand mindestens 0,05 Einheiten betragen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hardness)</span></span></span></span>{ float2 direction = normalize(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightDistance = length(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rayProgress = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nearest = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ;i&lt;SAMPLES; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDist = scene(position + direction * rayProgress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sceneDist &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rayProgress &gt; lightDistance){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(nearest); } nearest = min(nearest, hardness * sceneDist); rayProgress = rayProgress + sceneDist; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in fragment function float shadows = traceShadows(position, lightPos, 20);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/610/70b/5a4/61070b5a42c96ac0d121b8aa7f2130ae.png"></div><br>  Durch die Minimierung dieses Problems stellen wir Folgendes fest: Selbst in Bereichen, die nicht beschattet werden sollten, ist in der N√§he der W√§nde noch eine Schw√§chung sichtbar.  Dar√ºber hinaus scheint die Weichheit des Schattens f√ºr den gesamten Schatten gleich zu sein und neben der Figur nicht scharf und weicher zu sein, wenn Sie sich von dem Objekt entfernen, das den Schatten aussendet. <br><br>  Wir werden dies beheben, indem wir den Abstand in der Szene durch die Strahlausbreitung teilen.  Dank dessen teilen wir den Abstand am Anfang des Strahls in sehr kleine Zahlen, dh wir erhalten immer noch hohe Werte und einen sch√∂nen klaren Schatten.  Wenn wir den Punkt finden, der dem Strahl am n√§chsten liegt, wird der n√§chste Punkt durch eine gr√∂√üere Zahl geteilt, wodurch der Schatten weicher wird.  Da dies nicht vollst√§ndig mit der k√ºrzesten Entfernung zusammenh√§ngt, werden wir die Variable in <code>shadow</code> umbenennen. <br><br>  Wir werden noch eine kleine √Ñnderung vornehmen: Da wir durch rayProgress teilen, sollten Sie nicht mit 0 beginnen (das Teilen durch Null ist fast immer eine schlechte Idee des Teilens).  Zu Beginn k√∂nnen Sie eine sehr kleine Zahl ausw√§hlen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hardness)</span></span></span></span>{ float2 direction = normalize(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightDistance = length(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rayProgress = <span class="hljs-number"><span class="hljs-number">0.0001</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadow = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ;i&lt;SAMPLES; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDist = scene(position + direction * rayProgress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sceneDist &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rayProgress &gt; lightDistance){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(shadow); } shadow = min(shadow, hardness * sceneDist / rayProgress); rayProgress = rayProgress + sceneDist; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/715/305/e46715305ef51c3016c4d56b34f47a8d.png"></div><br><h2>  Mehrere Lichtquellen </h2><br>  In dieser einfachen Single-Core-Implementierung besteht der einfachste Weg, mehrere Lichtquellen zu erhalten, darin, sie einzeln zu berechnen und die Ergebnisse hinzuzuf√ºgen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ float2 position = i.worldPos.xz; float2 lightPos1 = float2(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y), <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadows1 = traceShadows(position, lightPos1, <span class="hljs-number"><span class="hljs-number">20</span></span>); float3 light1 = shadows1 * float3(<span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); float2 lightPos2 = float2(-<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y) * <span class="hljs-number"><span class="hljs-number">1.75</span></span>, <span class="hljs-number"><span class="hljs-number">1.75</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadows2 = traceShadows(position, lightPos2, <span class="hljs-number"><span class="hljs-number">10</span></span>); float3 light2 = shadows2 * float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = scene(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(sceneDistance) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> binaryScene = smoothstep(distanceChange, -distanceChange, sceneDistance); float3 geometry = binaryScene * float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); float3 col = geometry + light1 + light2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(col, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3b/b70/6ce/a3bb706cec13c16a54d8d740b0d91589.gif"></div><br><h2>  Quellcode </h2><br><h3>  Zweidimensionale SDF-Bibliothek (hat sich nicht ge√§ndert, wird aber hier verwendet) </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/037_SDF_2D_Shadows/2D_SDF.cginc</a> </li></ul><br><h3>  Zweidimensionale weiche Schatten </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/037_SDF_2D_Shadows/2D_SDF_Shadows.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/037_2D_SDF_Shadows"</span></span>{ Properties{ } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float bounds = -rectangle(position, 2); float2 quarterPos = abs(position); float corner = rectangle(translate(quarterPos, 1), 0.5); corner = subtract(corner, rectangle(position, 1.2)); float diamond = rectangle(rotate(position, 0.125), .5); float world = merge(bounds, corner); world = merge(world, diamond); return world; } #define STARTDISTANCE 0.00001 #define MINSTEPDIST 0.02 #define SAMPLES 32 float traceShadows(float2 position, float2 lightPosition, float hardness){ float2 direction = normalize(lightPosition - position); float lightDistance = length(lightPosition - position); float lightSceneDistance = scene(lightPosition) * 0.8; float rayProgress = 0.0001; float shadow = 9999; for(int i=0 ;i&lt;SAMPLES; i++){ float sceneDist = scene(position + direction * rayProgress); if(sceneDist &lt;= 0){ return 0; } if(rayProgress &gt; lightDistance){ return saturate(shadow); } shadow = min(shadow, hardness * sceneDist / rayProgress); rayProgress = rayProgress + max(sceneDist, 0.02); } return 0; } fixed4 frag(v2f i) : SV_TARGET{ float2 position = i.worldPos.xz; float2 lightPos1 = float2(sin(_Time.y), -1); float shadows1 = traceShadows(position, lightPos1, 20); float3 light1 = shadows1 * float3(.6, .6, 1); float2 lightPos2 = float2(-sin(_Time.y) * 1.75, 1.75); float shadows2 = traceShadows(position, lightPos2, 10); float3 light2 = shadows2 * float3(1, .6, .6); float sceneDistance = scene(position); float distanceChange = fwidth(sceneDistance) * 0.5; float binaryScene = smoothstep(distanceChange, -distanceChange, sceneDistance); float3 geometry = binaryScene * float3(0, 0.3, 0.1); float3 col = geometry + light1 + light2; return float4(col, 1); } ENDCG } } FallBack "Standard" }</span></span></code> </pre> <br>  Dies ist nur eines von vielen Beispielen f√ºr die Verwendung von vorzeichenbehafteten Entfernungsfeldern.  Bisher sind sie ziemlich umst√§ndlich, da alle Formen im Shader registriert oder durch die Eigenschaften des Shaders geleitet werden m√ºssen, aber ich habe einige Ideen, wie sie f√ºr zuk√ºnftige Tutorials bequemer gestaltet werden k√∂nnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438942/">https://habr.com/ru/post/de438942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438930/index.html">Die Beh√∂rden √§ndern die Strategie der Internetkontrolle grundlegend</a></li>
<li><a href="../de438932/index.html">Mustererkennung in der Aidetic Artificial Intelligence</a></li>
<li><a href="../de438934/index.html">Erstellen und konfigurieren Sie den portablen Build von Jupyter Notebook and Lab unter Windows. Teil 1</a></li>
<li><a href="../de438936/index.html">BotMan Bekanntschaft</a></li>
<li><a href="../de438940/index.html">Offener Kurs ‚ÄûDeep Learning an den Fingern‚Äú</a></li>
<li><a href="../de438946/index.html">DateTimeOffset (streng)</a></li>
<li><a href="../de438948/index.html">Warum brauchen wir eine Optimierung auf niedriger Ebene f√ºr Elbrus oder wie k√∂nnen wir das Erkennungssystem eineinhalb Mal beschleunigen?</a></li>
<li><a href="../de438950/index.html">Die Zentralbank startete einen Roboter, um im Internet nach Verdienstm√∂glichkeiten zu suchen</a></li>
<li><a href="../de438952/index.html">Was Sie lernen k√∂nnen, wenn Sie einen Audio-Player f√ºr verschiedene Browser entwickeln</a></li>
<li><a href="../de438954/index.html">Vorzeichenbehaftete Distanzfelder in 2D kombinieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>