<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò£ üêÑ üåö Versuch Preload (PHP 7.4) und RoadRunner üóúÔ∏è ‚òÄÔ∏è ü•¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 

 Wir schreiben und sprechen oft √ºber die PHP-Leistung: wie wir im Allgemeinen damit umgehen , wie wir beim Wechsel zu PHP 7.0 1 Million U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Versuch Preload (PHP 7.4) und RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/472528/"><img src="https://habrastorage.org/webt/mu/-7/aw/mu-7awhkx6dstts3atuaodnhsm4.jpeg"><br><br>  Hallo habr <br><br>  Wir schreiben und sprechen oft √ºber die PHP-Leistung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie wir</a> im Allgemeinen damit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgehen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie wir</a> beim Wechsel zu PHP 7.0 1 Million US-Dollar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingespart</a> haben und auch verschiedene Materialien zu diesem Thema √ºbersetzen.  Dies liegt an der Tatsache, dass das Publikum unserer Produkte w√§chst und die Skalierung des PHP-Backends mit Eisen sehr teuer ist - wir haben 600 Server mit PHP-FPM.  Daher ist es f√ºr uns von Vorteil, Zeit in die Optimierung zu investieren. <br><br>  Vorher haben wir haupts√§chlich √ºber die √ºblichen und bereits etablierten Arbeitsweisen mit Produktivit√§t gesprochen.  Aber die PHP-Community ist in Alarmbereitschaft!  JIT wird in PHP 8 erscheinen, Preload wird in PHP 7.4 erscheinen und Frameworks au√üerhalb des Kerns der PHP-Entwicklung werden entwickelt, die davon ausgehen, dass PHP als Daemon funktioniert.  Es ist Zeit, mit etwas Neuem zu experimentieren und zu sehen, was uns dies geben kann. <br><br>  Da die Ver√∂ffentlichung von PHP 8 noch weit entfernt ist und asynchrone Frameworks f√ºr unsere Aufgaben schlecht geeignet sind (warum - ich werde es weiter unten erl√§utern), konzentrieren wir uns heute auf das Preload, das in PHP 7.4 erscheinen wird, und das Framework zur D√§monisierung von PHP, RoadRunner. <br><br>  Dies ist die Textversion meines Berichts mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo PHP Meetup # 3</a> .  Video aller Reden, die wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Beitrag gesammelt haben</a> . <a name="habracut"></a><br><br>  PHP-FPM, Apache mod_php und √§hnliche Methoden zum Ausf√ºhren von PHP-Skripten und -Prozessanforderungen (die von der √ºberwiegenden Mehrheit der Websites und Dienste ausgef√ºhrt werden; der Einfachheit halber werde ich sie als ‚Äûklassisches‚Äú PHP bezeichnen) arbeiten auf der Grundlage von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shared-Nothing</a> im weiteren Sinne des Wortes: <br><br><ul><li>  Staat wird nicht zwischen PHP-Arbeitern durchsucht; <br></li><li>  Der Staat wird nicht zwischen verschiedenen Anfragen durchsucht. <br></li></ul><br>  Betrachten Sie dies anhand eines Beispiels f√ºr ein einfaches Skript: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); //   $name = $storage-&gt;getById($_COOKIE['city_id']); echo " : {$name}";</span></span></code> </pre> <br>  F√ºr jede Anforderung wird das Skript von der ersten bis zur letzten Zeile ausgef√ºhrt: Obwohl sich die Initialisierung h√∂chstwahrscheinlich nicht von der Anforderung zur Anforderung unterscheidet und m√∂glicherweise einmal ausgef√ºhrt werden kann (Ressourcen sparen), m√ºssen Sie sie dennoch f√ºr jede Anforderung wiederholen.  Aufgrund der Besonderheiten der Funktionsweise des ‚Äûklassischen‚Äú PHP k√∂nnen wir nicht einfach Variablen (z. B. <code>$app</code> ) zwischen Anforderungen aufnehmen und speichern. <br><br>  Wie w√ºrde es aussehen, wenn wir √ºber den Rahmen von "klassischem" PHP hinausgehen w√ºrden?  Zum Beispiel k√∂nnte unser Skript unabh√§ngig von der Anforderung ausgef√ºhrt werden, initialisiert werden und eine Abfrageschleife enthalten, in der er auf die n√§chste warten, sie verarbeiten und die Schleife wiederholen w√ºrde, ohne die Umgebung zu bereinigen (im Folgenden werde ich diese L√∂sung ‚ÄûPHP als Daemon‚Äú nennen "). <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); $cities = $storage-&gt;getAll(); //    while ($req = getNextRequest()) {    $name = $cities[$req-&gt;getCookie('city_id')];    echo " : {$name}"; }</span></span></code> </pre> <br>  Wir konnten nicht nur die f√ºr jede Anforderung wiederholte Initialisierung entfernen, sondern auch die Liste der St√§dte einmal in der Variablen " <code>$cities</code> speichern und aus verschiedenen Anforderungen verwenden, ohne auf irgendwo anders als auf den Speicher zuzugreifen (dies ist der schnellste Weg, um Daten abzurufen). <br><br>  Die Leistung einer solchen L√∂sung ist m√∂glicherweise erheblich h√∂her als die des "klassischen" PHP.  Aber normalerweise ist die Steigerung der Produktivit√§t nicht kostenlos - Sie m√ºssen einen Preis daf√ºr bezahlen.  Mal sehen, was es in unserem Fall sein kann. <br><br>  Lassen Sie uns dazu unser Skript etwas komplizieren und anstatt die Variable <code>$name</code> anzuzeigen, f√ºllen wir das Array: <br><br><pre> <code class="php hljs">-  $name = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)]; +  $names[] = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)];</code> </pre><br>  Bei ‚Äûklassischem‚Äú PHP treten keine Probleme auf - am Ende der Abfrage wird die Variable <code>$name</code> zerst√∂rt und jede nachfolgende Anforderung funktioniert wie erwartet.  Wenn Sie PHP als Daemon starten, f√ºgt jede Anforderung dieser Variablen eine weitere Stadt hinzu, was zu einem unkontrollierten Wachstum des Arrays f√ºhrt, bis der Speicher auf dem Computer leer ist. <br><br>  Im Allgemeinen kann nicht nur der Speicher enden - es k√∂nnen auch andere Fehler auftreten, die zum Tod des Prozesses f√ºhren.  Bei solchen Problemen wird "klassisches" PHP automatisch behandelt.  Wenn Sie PHP als Daemon starten, m√ºssen Sie diesen Daemon irgendwie √ºberwachen und neu starten, wenn er abst√ºrzt. <br><br>  Fehler dieser Art sind unangenehm, aber es gibt wirksame L√∂sungen f√ºr sie.  Es ist viel schlimmer, wenn das Skript aufgrund eines Fehlers nicht herunterf√§llt, sondern die Werte einiger Variablen unvorhersehbar √§ndert (z. B. wird das Array <code>$cities</code> gel√∂scht).  In diesem Fall funktionieren alle nachfolgenden Anforderungen mit falschen Daten. <br><br><blockquote>  Zusammenfassend ist es einfacher, Code f√ºr ‚Äûklassisches‚Äú PHP (PHP-FPM, Apache mod_php und dergleichen) zu schreiben - es befreit uns von einer Reihe von Problemen und Fehlern.  Daf√ºr zahlen wir aber mit Leistung. </blockquote><br>  Aus den obigen Beispielen geht hervor, dass PHP in einigen Teilen des Codes Ressourcen ausgibt, die nicht f√ºr die Verarbeitung jeder Anforderung des ‚Äûklassischen‚Äú Codes aufgewendet (oder einmal verschwendet) werden konnten.  Dies sind die folgenden Bereiche: <br><br><ul><li>  Dateiverbindung (einschlie√üen, erfordern usw.); <br></li><li>  Initialisierung (Framework, Bibliotheken, DI-Container usw.); <br></li><li>  Daten vom externen Speicher anfordern (anstatt im Speicher zu speichern). <br></li></ul><br>  PHP gibt es schon seit vielen Jahren und es k√∂nnte dank dieses Arbeitsmodells sogar popul√§r geworden sein.  In dieser Zeit wurden viele Methoden mit unterschiedlichem Erfolg entwickelt, um das beschriebene Problem zu l√∂sen.  Ich habe einige davon in meinem vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel erw√§hnt</a> .  Heute werden wir uns mit zwei ziemlich neuen L√∂sungen f√ºr die Community befassen: Preload und RoadRunner. <br><br><h2>  Vorladen </h2><br>  Von den drei oben aufgef√ºhrten Punkten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Preload darauf</a> ausgelegt, den ersten Overhead beim Verbinden von Dateien zu bew√§ltigen.  Auf den ersten Blick mag dies seltsam und bedeutungslos erscheinen, da PHP bereits √ºber OPcache verf√ºgt, der nur f√ºr diesen Zweck erstellt wurde.  Um die Essenz zu verstehen, lassen Sie uns mit Hilfe von <code>perf</code> , √ºber das OPcache aktiviert ist, ein reales Profil mit einer Trefferquote von 100% erstellen. <br><br><img src="https://habrastorage.org/webt/rb/y-/jo/rby-jo2hcsjsu3ncjnjxjmbggny.png"><br><br>  Trotz OPcache sehen wir, dass <code>persistent_compile_file</code> 5,84% der Ausf√ºhrungszeit der Abfrage ben√∂tigt. <br><br>  Um zu verstehen, warum dies geschieht, k√∂nnen wir uns die Quellen von <a href="">zend_accel_load_script ansehen</a> .  Aus ihnen ist ersichtlich, dass trotz des Vorhandenseins von OPcache bei jedem Aufruf zum Einschlie√üen <code>include/require</code> Signaturen von Klassen und Funktionen aus dem gemeinsam genutzten Speicher in den Speicher des Arbeitsprozesses kopiert werden und verschiedene Hilfsarbeiten ausgef√ºhrt werden.  Und diese Arbeit sollte f√ºr jede Anforderung ausgef√ºhrt werden, da am Ende der Speicher des Arbeitsprozesses gel√∂scht wird. <br><br><img src="https://habrastorage.org/webt/6j/nj/zl/6jnjzlelhihw5j5fsgo5bmlluxw.png"><br><br>  Hinzu kommt die gro√üe Anzahl von Include / Require-Anrufen, die wir normalerweise in einer einzigen Anfrage t√§tigen.  Beispielsweise enth√§lt Symfony 4 ungef√§hr 310 Dateien, bevor die erste n√ºtzliche Codezeile ausgef√ºhrt wird.  Manchmal geschieht dies implizit: Um eine unten gezeigte Instanz der Klasse A zu erstellen, l√§dt PHP alle anderen Klassen (B, C, D, E, F, G) automatisch.  Insbesondere in dieser Hinsicht fallen die Abh√§ngigkeiten von Composer auf, die Funktionen deklarieren: Um sicherzustellen, dass diese Funktionen w√§hrend der Ausf√ºhrung von Benutzercode verf√ºgbar sind, muss Composer sie unabh√§ngig von der Verwendung immer verbinden, da PHP keine Autoload-Funktionen hat und dies auch nicht sein kann zum Zeitpunkt des Anrufs geladen. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1; }</code> </pre> <br><br><h3>  Wie das Vorspannen funktioniert </h3><br>  Preload hat eine einzige Haupteinstellung, opcache.preload, an die der Pfad zum PHP-Skript √ºbergeben wird.  Dieses Skript wird beim Starten von PHP-FPM / Apache / usw. einmal ausgef√ºhrt, und alle Signaturen von Klassen, Methoden und Funktionen, die in dieser Datei deklariert werden, stehen allen Skripten zur Verf√ºgung, die Anforderungen ab der ersten Zeile ihrer Ausf√ºhrung verarbeiten (wichtig) Hinweis: Dies gilt nicht f√ºr Variablen und globale Konstanten. Ihre Werte werden nach dem Ende der Vorladephase auf Null zur√ºckgesetzt.  Sie m√ºssen keine Include- / Require-Aufrufe mehr vornehmen und Funktions- / Klassensignaturen aus dem gemeinsam genutzten Speicher in den Prozessspeicher kopieren: Sie werden alle als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unver√§nderlich</a> deklariert, und aus diesem Grund k√∂nnen alle Prozesse auf denselben Speicherort verweisen, der sie enth√§lt. <br><br>  Normalerweise befinden sich die ben√∂tigten Klassen und Funktionen in verschiedenen Dateien, und es ist unpraktisch, sie in einem Preload-Skript zu kombinieren.  Dies muss jedoch nicht durchgef√ºhrt werden: Da das Preload ein regul√§res PHP-Skript ist, k√∂nnen wir einfach include / require oder opcache_compile_file () aus dem Preload-Skript f√ºr alle ben√∂tigten Dateien verwenden.  Da alle diese Dateien einmal geladen werden, kann PHP au√üerdem zus√§tzliche Optimierungen vornehmen, die nicht durchgef√ºhrt werden konnten, w√§hrend wir diese Dateien zum Zeitpunkt der Abfrage separat verbunden haben.  PHP nimmt Optimierungen nur im Rahmen jeder einzelnen Datei vor, im Falle des Vorladens jedoch f√ºr den gesamten Code, der in der Vorladephase geladen wird. <br><br><h3>  Benchmarks Vorspannung </h3><br>  Um die Vorteile des Preloads in der Praxis zu demonstrieren, habe ich einen CPU-gebundenen Endpunkt Badoo verwendet.  Unser Backend ist im Allgemeinen durch eine CPU-gebundene Last gekennzeichnet.  Diese Tatsache ist die Antwort auf die Frage, warum wir asynchrone Frameworks nicht ber√ºcksichtigt haben: Sie bieten keinen Vorteil bei CPU-gebundener Auslastung und komplizieren gleichzeitig den Code noch mehr (er muss anders geschrieben werden) sowie f√ºr die Arbeit mit einem Netzwerk, einer Festplatte usw. Spezielle asynchrone Treiber sind erforderlich. <br><br>  Um die Vorteile des Vorladens voll auszusch√∂pfen, habe ich f√ºr das Experiment alle Dateien heruntergeladen, die f√ºr das getestete Skript bei der Arbeit erforderlich sind, und es mit einem Anschein einer normalen Produktionslast mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wrk2 geladen</a> - einem fortgeschritteneren Analogon von Apache Benchmark, aber genauso einfach . <br><br>  Um das Vorladen zu versuchen, m√ºssen Sie zuerst auf PHP 7.4 aktualisieren (wir haben jetzt PHP 7.2).  Ich habe die Leistung von PHP 7.2, PHP 7.4 ohne Vorspannung und PHP 7.4 mit Vorspannung gemessen.  Das Ergebnis ist ein solches Bild: <br><br><img src="https://habrastorage.org/webt/sm/ea/5_/smea5_e3kck5zwyk44afzp8ut9u.png"><br><br>  Somit ergibt der √úbergang von PHP 7.2 zu PHP 7.4 + 10% f√ºr die Leistung an unserem Endpunkt, und die Vorlast ergibt weitere 10% von oben. <br><br>  Beim Vorladen h√§ngen die Ergebnisse stark von der Anzahl der verbundenen Dateien und der Komplexit√§t der ausf√ºhrbaren Logik ab: Wenn viele Dateien verbunden sind und die Logik einfach ist, liefert das Vorladen mehr als wenn nur wenige Dateien vorhanden sind und die Logik komplex ist. <br><br><h3>  Die Nuancen der Vorspannung </h3><br>  Was die Produktivit√§t erh√∂ht, hat normalerweise einen Nachteil.  Preload hat viele Nuancen, die ich unten geben werde.  Alle m√ºssen ber√ºcksichtigt werden, aber nur eine (erste) kann von grundlegender Bedeutung sein. <br><br><h4>  √Ñndern - neu starten </h4><br>  Da alle Preload-Dateien nur beim Start kompiliert, als unver√§nderlich markiert und in Zukunft nicht neu kompiliert werden, besteht die einzige M√∂glichkeit, √Ñnderungen an diesen Dateien zu √ºbernehmen, darin, PHP-FPM / Apache / usw. neu zu starten (neu zu laden oder neu zu starten). <br><br>  Beim Neuladen versucht PHP, so genau wie m√∂glich neu zu starten: Benutzeranforderungen werden nicht unterbrochen, aber w√§hrend der Vorladephase warten alle neuen Anforderungen auf den Abschluss.  Wenn sich beim Vorladen nicht viel Code befindet, kann dies keine Probleme verursachen. Wenn Sie jedoch versuchen, die gesamte Anwendung herunterzuladen, erh√∂ht sich die Antwortzeit w√§hrend eines Neustarts erheblich. <br><br>  Auch ein Neustart (unabh√§ngig davon, ob er neu geladen oder neu gestartet wird) hat eine wichtige Funktion - als Ergebnis dieser Aktion wird OPcache gel√∂scht.  Das hei√üt, alle Anfragen danach funktionieren mit einem kalten Opcode-Cache, was die Antwortzeit noch weiter verl√§ngern kann. <br><br><h4>  Undefinierte Zeichen </h4><br>  Damit eine Klasse vor dem Laden geladen werden kann, muss bis zu diesem Punkt alles definiert werden, von dem sie abh√§ngt.  F√ºr die folgende Klasse bedeutet dies, dass alle anderen Klassen (B, C, D, E, F, G), die Variable <code>$someGlobalVar</code> und die Konstante SOME_CONST verf√ºgbar sein m√ºssen, bevor diese Klasse kompiliert wird.  Da das Preload-Skript nur regul√§rer PHP-Code ist, k√∂nnen wir einen Autoloader definieren.  In diesem Fall wird alles, was mit anderen Klassen verbunden ist, automatisch von ihr geladen.  Dies funktioniert jedoch nicht mit Variablen und Konstanten: Wir m√ºssen selbst sicherstellen, dass sie zum Zeitpunkt der Deklaration dieser Klasse definiert sind. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $varLink = $someGlobalVar;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $constLink = SOME_CONST; }</code> </pre> <br>  Gl√ºcklicherweise enth√§lt das Preload gen√ºgend Tools, um zu verstehen, ob Sie etwas aus dem Weg r√§umen oder nicht.  Erstens sind dies Warnmeldungen mit Informationen dar√ºber, was nicht geladen werden konnte und warum: <br><br><pre> <code class="plaintext hljs">PHP Warning: Can't preload class MyTestClass with unresolved initializer for constant RAND in /local/preload-internal.php on line 6 PHP Warning: Can't preload unlinked class MyTestClass: Unknown parent AnotherClass in /local/preload-internal.php on line 5</code> </pre> <br>  Zweitens f√ºgt das Preload dem Ergebnis der Funktion opcache_get_status () einen separaten Abschnitt hinzu, der zeigt, was in der Preload-Phase erfolgreich geladen wurde: <br><br><img src="https://habrastorage.org/webt/j7/fh/6u/j7fh6u0ww7plxxrx_x8fguxcazu.png"><br><br><h4>  Klassenfeld / konstante Optimierung </h4><br>  Wie ich oben geschrieben habe, l√∂st Preload die Werte der Felder / Konstanten der Klasse auf und speichert sie.  Auf diese Weise k√∂nnen Sie den Code optimieren: W√§hrend der Verarbeitung der Anforderung sind die Daten bereit und m√ºssen nicht aus anderen Daten abgeleitet werden.  Dies kann jedoch zu nicht offensichtlichen Ergebnissen f√ºhren, die das folgende Beispiel zeigt: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span>.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">'MYTESTCONST'</span></span>, mt_rand(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre> <br><pre> <code class="php hljs">preload.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestClass</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RAND = MYTESTCONST; }</code> </pre> <br><pre> <code class="php hljs">script.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> MYTESTCONST, <span class="hljs-string"><span class="hljs-string">', '</span></span>, MyTestClass::RAND; <span class="hljs-comment"><span class="hljs-comment">// 32, 154</span></span></code> </pre> <br>  Das Ergebnis ist eine kontraintuitive Situation: Es scheint, dass die Konstanten gleich sein sollten, da einer von ihnen der Wert des anderen zugewiesen wurde, aber in Wirklichkeit ist dies nicht so.  Dies liegt an der Tatsache, dass globale Konstanten im Gegensatz zu Klassenkonstanten / -feldern nach Ende der Vorladephase zwangsweise gel√∂scht werden, w√§hrend Klassenkonstanten / -felder aufgel√∂st und gespeichert werden.  Dies f√ºhrt dazu, dass wir w√§hrend der Ausf√ºhrung der Anfrage die globale Konstante erneut definieren m√ºssen, wodurch sie einen anderen Wert erhalten kann. <br><br><h4>  SomeFunc () kann nicht neu deklariert werden </h4><br>  Bei Klassen ist die Situation einfach: Normalerweise verbinden wir sie nicht explizit, sondern verwenden einen Autoloader.  Dies bedeutet, dass wenn eine Klasse in der Preload-Phase definiert ist, der Autoloader w√§hrend der Anforderung einfach nicht ausgef√ºhrt wird und wir nicht versuchen werden, diese Klasse ein zweites Mal zu verbinden. <br><br>  Bei Funktionen ist die Situation anders: Wir m√ºssen sie explizit verbinden.  Dies kann dazu f√ºhren, dass wir im Preload-Skript alle erforderlichen Dateien mit Funktionen verbinden und dies w√§hrend der Anforderung erneut versuchen (ein typisches Beispiel ist der Composer-Bootloader: Er versucht immer, alle Dateien mit Funktionen zu verbinden).  In diesem Fall erhalten wir eine Fehlermeldung: Die Funktion wurde bereits definiert und kann nicht neu definiert werden. <br><br>  Dieses Problem kann auf verschiedene Arten gel√∂st werden.  Im Fall von Composer k√∂nnen Sie beispielsweise alles in der Vorladephase verbinden und bei Anforderungen nichts mit Composer zu tun haben.  Eine andere L√∂sung besteht nicht darin, Dateien direkt mit Funktionen zu verbinden, sondern dies √ºber eine Proxy-Datei mit der Suche nach function_exists () zu tun, wie dies beispielsweise bei Guzzle HTTP der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fall ist</a> . <br><br><img src="https://habrastorage.org/webt/8h/4f/bd/8h4fbddjiu5zbd3xycfnwrdxrmi.png"><br><br><h4>  PHP 7.4 wurde (noch) nicht offiziell ver√∂ffentlicht </h4><br>  Diese Nuance wird nach einiger Zeit irrelevant, aber bis die PHP-Version 7.4 noch nicht offiziell ver√∂ffentlicht wurde und das PHP-Team ausdr√ºcklich in den Versionshinweisen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schreibt</a> : "Bitte verwenden Sie diese Version NICHT in der Produktion, es ist eine fr√ºhe Testversion."  W√§hrend unserer Experimente mit Vorspannung sind wir auf mehrere Fehler gesto√üen, haben sie selbst behoben und sogar etwas an den Upstream <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesendet</a> .  Um √úberraschungen zu vermeiden, ist es besser, auf die offizielle Ver√∂ffentlichung zu warten. <br><br><h2>  Roadrunner </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RoadRunner</a> ist ein in Go geschriebener Daemon, der einerseits PHP-Worker erstellt und √ºberwacht (bei Bedarf startet / endet / neu startet), andererseits Anforderungen akzeptiert und an diese Worker weiterleitet.  In diesem Sinne unterscheidet sich seine Arbeit nicht von der Arbeit von PHP-FPM (wo es auch einen Master-Prozess gibt, der die Arbeiter √ºberwacht).  Aber es gibt immer noch Unterschiede.  Der Schl√ºssel ist, dass RoadRunner den Status des Skripts nach Abschluss der Abfrage nicht zur√ºcksetzt. <br><br>  Wenn wir uns also an unsere Liste erinnern, welche Ressourcen im Fall von ‚Äûklassischem‚Äú PHP verbraucht werden, k√∂nnen Sie mit RoadRunner alle Punkte behandeln (das Vorladen erfolgt, wie wir uns erinnern, nur mit dem ersten): <br><br><ul><li>  Dateiverbindung (einschlie√üen, erfordern usw.); <br></li><li>  Initialisierung (Framework, Bibliotheken, DI-Container usw.); <br></li><li>  Daten vom externen Speicher anfordern (anstatt im Speicher zu speichern). <br></li></ul><br>  Das Hello World RoadRunner-Beispiel sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="php hljs">$relay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\Goridge\StreamRelay(STDIN, STDOUT); $psr7 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\PSR7Client(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\Worker($relay)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {        $resp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);        $psr7-&gt;respond($resp); }</code> </pre> <br>  Wir werden versuchen, unseren aktuellen Endpunkt, den wir mit Vorspannung getestet haben, ohne √Ñnderungen auf RoadRunner auszuf√ºhren, ihn zu laden und die Leistung zu messen.  Keine √Ñnderungen - sonst ist der Benchmark nicht ganz ehrlich. <br><br>  Versuchen wir, das Hello World-Beispiel daf√ºr anzupassen. <br><br>  Erstens m√∂chten wir, wie ich oben geschrieben habe, nicht, dass der Arbeiter im Fehlerfall f√§llt.  Dazu m√ºssen wir alles in einen globalen Versuch einschlie√üen.  Zweitens, da unser Skript nichts √ºber Zend Diactoros wei√ü, m√ºssen wir f√ºr die Antwort seine Ergebnisse konvertieren.  Daf√ºr verwenden wir ob_-Funktionen.  Drittens wei√ü unser Skript nichts √ºber die Art der PSR-7-Anforderung.  Die L√∂sung besteht darin, die Standard-PHP-Umgebung aus diesen Entit√§ten zu f√ºllen.  Und viertens erwartet unser Skript, dass die Anfrage stirbt und der gesamte Status gel√∂scht wird.  Daher m√ºssen wir diese Reinigung mit RoadRunner selbst durchf√ºhren. <br><br>  So wird die urspr√ºngliche Hello World-Version ungef√§hr so: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {        $uri = $req-&gt;getUri();        $_COOKIE = $req-&gt;getCookieParams();        $_POST = $req-&gt;getParsedBody();        $_SERVER = [            <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; $req-&gt;getMethod(),            <span class="hljs-string"><span class="hljs-string">'HTTP_HOST'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'DOCUMENT_URI'</span></span> =&gt; $uri-&gt;getPath(),            <span class="hljs-string"><span class="hljs-string">'SERVER_NAME'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'QUERY_STRING'</span></span> =&gt; $uri-&gt;getQuery(),            <span class="hljs-comment"><span class="hljs-comment">// ...        ];        ob_start();        // our logic here        $output = ob_get_contents();        ob_clean();               $resp = new \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write($output, 200);        $psr7-&gt;respond($resp);    } catch (\Throwable $Throwable) {        // some error handling logic here    }    \UDS\Event::flush();    \PinbaClient::sendAll();    \PinbaClient::flushAll();    \HTTP::clear();    \ViewFactory::clear();    \Logger::clearCaches();       // ... }</span></span></code> </pre> <br><br><h3>  Benchmarks RoadRunner </h3><br>  Nun, es ist Zeit, Benchmarks zu starten. <br><br><img src="https://habrastorage.org/webt/qs/6b/89/qs6b89wrabygtu6ea6d-8i9rk4m.png"><br><br>  Die Ergebnisse entsprechen nicht den Erwartungen: Mit RoadRunner k√∂nnen Sie mehr Faktoren ausgleichen, die zu Leistungsverlusten f√ºhren als die Vorspannung. Die Ergebnisse sind jedoch schlechter.  Lassen Sie uns herausfinden, warum dies wie immer geschieht, indem wir perf daf√ºr ausf√ºhren. <br><br><img src="https://habrastorage.org/webt/1w/v9/ft/1wv9ftxnmcdxiu48rrkftw1phic.png"><br><br>  In den Perf-Ergebnissen sehen wir phar_compile_file.  Dies liegt daran, dass wir w√§hrend der Ausf√ºhrung des Skripts einige Dateien einschlie√üen. Da OPcache nicht aktiviert ist (RoadRunner f√ºhrt Skripte als CLI aus, wobei OPcache standardm√§√üig deaktiviert ist), werden diese Dateien bei jeder Anforderung erneut kompiliert. <br><br>  Bearbeiten Sie die RoadRunner-Konfiguration - aktivieren Sie OPcache: <br><br><img src="https://habrastorage.org/webt/-d/zq/wn/-dzqwnysszz3zcpek82a2wtr9wy.png"><br><br><img src="https://habrastorage.org/webt/zt/tp/1w/zttp1w-bl-5xkho85gi1-7d5pek.png"><br><br>  Diese Ergebnisse entsprechen bereits eher unseren Erwartungen: RoadRunner zeigte mehr Leistung als Vorspannung.  Aber vielleicht k√∂nnen wir noch mehr bekommen! <br><br>  Perf scheint nichts Ungew√∂hnlicheres zu sein - schauen wir uns den PHP-Code an.  Der einfachste Weg, es zu profilieren, ist die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">phpspy</a> : Es ist keine √Ñnderung des PHP-Codes erforderlich - Sie m√ºssen ihn nur in der Konsole ausf√ºhren.  Lassen Sie uns dies tun und ein Flammendiagramm erstellen: <br><br><img src="https://habrastorage.org/webt/60/2k/yk/602kykwmxdw1nxaudop0omr98bi.png"><br><br>  Da wir vereinbart haben, die Logik unserer Anwendung f√ºr die Reinheit des Experiments nicht zu √§ndern, interessieren wir uns f√ºr den Stapelzweig, der mit der Arbeit von RoadRunner verbunden ist: <br><br><img src="https://habrastorage.org/webt/ta/ag/yz/taagyz-8en1khhrka80i_al2dry.png"><br><br>  Der Hauptteil davon besteht darin, fread () aufzurufen. Damit kann kaum etwas getan werden.  Wir sehen jedoch einige andere Zweige in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">\ Spiral \ RoadRunner \ PSR7Client :: acceptRequest ()</a> , au√üer fread selbst.  Sie k√∂nnen ihre Bedeutung anhand des Quellcodes verstehen: <br><br><pre> <code class="php hljs">   <span class="hljs-comment"><span class="hljs-comment">/**     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ServerRequestInterface|null     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">    </span></span>{        $rawRequest = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;httpClient-&gt;acceptRequest();        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rawRequest === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;        }        $_SERVER = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;configureServer($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>]);        $request = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;requestFactory-&gt;createServerRequest(            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'method'</span></span>],            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uri'</span></span>],            $_SERVER        );        parse_str($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'rawQuery'</span></span>], $query);        $request = $request            -&gt;withProtocolVersion(<span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::fetchProtocolVersion($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'protocol'</span></span>]))            -&gt;withCookieParams($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'cookies'</span></span>])            -&gt;withQueryParams($query)            -&gt;withUploadedFiles(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;wrapUploads($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uploads'</span></span>]));</code> </pre> <br>  Es wird deutlich, dass RoadRunner versucht, ein PSR-7-kompatibles Anforderungsobjekt mithilfe eines serialisierten Arrays zu erstellen.  Wenn Ihr Framework direkt mit PSR-7-Abfrageobjekten arbeitet (z. B. Symfony <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert nicht</a> ), ist dies vollst√§ndig gerechtfertigt.  In anderen F√§llen wird der PSR-7 zu einem zus√§tzlichen Link, bevor die Anforderung in das konvertiert wird, mit dem Ihre Anwendung arbeiten kann.  Entfernen wir diesen Zwischenlink und sehen uns die Ergebnisse noch einmal an: <br><br><img src="https://habrastorage.org/webt/jv/mr/p5/jvmrp567zwsjhft2ocuimx8jk1q.png"><br><br>  Das Testskript war recht einfach, so dass ich einen signifikanten Teil der Leistung herausholen konnte - + 17% im Vergleich zu reinem PHP (ich erinnere mich, dass das Preload + 10% f√ºr dasselbe Skript ergibt). <br><br><h3>  Nuancen von RoadRunner </h3><br>  Im Allgemeinen ist die Verwendung von RoadRunner eine schwerwiegendere √Ñnderung als nur die Einbeziehung der Vorspannung, sodass die Nuancen hier noch bedeutender sind. <br><br> -, RoadRunner,  ,  PHP-   ,   ,     ,       :    ,   ,      . <br><br> -,      RoadRunner ,     ¬´¬ª    ‚Äî      .         /   RoadRunner  ; ,      ,        ,            ,  -   . <br><br> -,        endpoint', , ,       RoadRunner.       . <br><br><h2>  Fazit </h2><br> ,    ¬´¬ª PHP,   ,     preload       RoadRunner. <br><br> PHP  ¬´¬ª   (PHP-FPM, Apache mod_php  )       .       -    ,       .  ,         ,     preload    JIT. <br><br>   ,    , ,       RoadRunner,         . <br><br>    ,      (:           ): <br><br><ul><li> PHP 7.2 ‚Äî 845 RPS; <br></li><li> PHP 7.4 ‚Äî 931 RPS; <br></li><li> RoadRunner   ‚Äî 987 RPS; <br></li><li> PHP 7.4 + preload ‚Äî 1030 RPS; <br></li><li> RoadRunner   ‚Äî 1089 RPS. <br></li></ul><br>   Badoo      PHP 7.4       ,         (    ). <br><br> RoadRunner      ,   ,         ,      ,   . <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472528/">https://habr.com/ru/post/de472528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472516/index.html">Yandex.Translator f√ºr Linux unter Python + GTK3</a></li>
<li><a href="../de472520/index.html">Trainingskits aus dem Video - schnell und effizient</a></li>
<li><a href="../de472522/index.html">Das Buch "Kontinuierliche Weiterentwicklung der API. Die richtigen Entscheidungen in einer sich ver√§ndernden technologischen Landschaft ‚Äú</a></li>
<li><a href="../de472524/index.html">Platz, Gitter und Layouts</a></li>
<li><a href="../de472526/index.html">3D steigt in die H√∂he: Es wurde ein neuer Verbundwerkstoff f√ºr die Luft- und Raumfahrt entwickelt, der die Masse der Teile um 20% reduziert hat</a></li>
<li><a href="../de472530/index.html">Video√ºberwachung in Moskau: aktuelle Realit√§ten und Perspektiven</a></li>
<li><a href="../de472532/index.html">N√ºtzlicher Hilfelink f√ºr Vermarkter</a></li>
<li><a href="../de472534/index.html">Sie wachen auf! (N.-F. Roman, Teil 1 von 2)</a></li>
<li><a href="../de472536/index.html">Smart IdReader SDK - Einbettungserkennung in Projekte in Python und PHP einbetten</a></li>
<li><a href="../de472540/index.html">Sie wachen auf! (n.-f. Geschichte, Teil 2 und die letzte)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>