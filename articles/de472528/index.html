<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😣 🐄 🌚 Versuch Preload (PHP 7.4) und RoadRunner 🗜️ ☀️ 🥢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 

 Wir schreiben und sprechen oft über die PHP-Leistung: wie wir im Allgemeinen damit umgehen , wie wir beim Wechsel zu PHP 7.0 1 Million U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Versuch Preload (PHP 7.4) und RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/472528/"><img src="https://habrastorage.org/webt/mu/-7/aw/mu-7awhkx6dstts3atuaodnhsm4.jpeg"><br><br>  Hallo habr <br><br>  Wir schreiben und sprechen oft über die PHP-Leistung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie wir</a> im Allgemeinen damit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgehen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie wir</a> beim Wechsel zu PHP 7.0 1 Million US-Dollar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingespart</a> haben und auch verschiedene Materialien zu diesem Thema übersetzen.  Dies liegt an der Tatsache, dass das Publikum unserer Produkte wächst und die Skalierung des PHP-Backends mit Eisen sehr teuer ist - wir haben 600 Server mit PHP-FPM.  Daher ist es für uns von Vorteil, Zeit in die Optimierung zu investieren. <br><br>  Vorher haben wir hauptsächlich über die üblichen und bereits etablierten Arbeitsweisen mit Produktivität gesprochen.  Aber die PHP-Community ist in Alarmbereitschaft!  JIT wird in PHP 8 erscheinen, Preload wird in PHP 7.4 erscheinen und Frameworks außerhalb des Kerns der PHP-Entwicklung werden entwickelt, die davon ausgehen, dass PHP als Daemon funktioniert.  Es ist Zeit, mit etwas Neuem zu experimentieren und zu sehen, was uns dies geben kann. <br><br>  Da die Veröffentlichung von PHP 8 noch weit entfernt ist und asynchrone Frameworks für unsere Aufgaben schlecht geeignet sind (warum - ich werde es weiter unten erläutern), konzentrieren wir uns heute auf das Preload, das in PHP 7.4 erscheinen wird, und das Framework zur Dämonisierung von PHP, RoadRunner. <br><br>  Dies ist die Textversion meines Berichts mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo PHP Meetup # 3</a> .  Video aller Reden, die wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Beitrag gesammelt haben</a> . <a name="habracut"></a><br><br>  PHP-FPM, Apache mod_php und ähnliche Methoden zum Ausführen von PHP-Skripten und -Prozessanforderungen (die von der überwiegenden Mehrheit der Websites und Dienste ausgeführt werden; der Einfachheit halber werde ich sie als „klassisches“ PHP bezeichnen) arbeiten auf der Grundlage von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shared-Nothing</a> im weiteren Sinne des Wortes: <br><br><ul><li>  Staat wird nicht zwischen PHP-Arbeitern durchsucht; <br></li><li>  Der Staat wird nicht zwischen verschiedenen Anfragen durchsucht. <br></li></ul><br>  Betrachten Sie dies anhand eines Beispiels für ein einfaches Skript: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); //   $name = $storage-&gt;getById($_COOKIE['city_id']); echo " : {$name}";</span></span></code> </pre> <br>  Für jede Anforderung wird das Skript von der ersten bis zur letzten Zeile ausgeführt: Obwohl sich die Initialisierung höchstwahrscheinlich nicht von der Anforderung zur Anforderung unterscheidet und möglicherweise einmal ausgeführt werden kann (Ressourcen sparen), müssen Sie sie dennoch für jede Anforderung wiederholen.  Aufgrund der Besonderheiten der Funktionsweise des „klassischen“ PHP können wir nicht einfach Variablen (z. B. <code>$app</code> ) zwischen Anforderungen aufnehmen und speichern. <br><br>  Wie würde es aussehen, wenn wir über den Rahmen von "klassischem" PHP hinausgehen würden?  Zum Beispiel könnte unser Skript unabhängig von der Anforderung ausgeführt werden, initialisiert werden und eine Abfrageschleife enthalten, in der er auf die nächste warten, sie verarbeiten und die Schleife wiederholen würde, ohne die Umgebung zu bereinigen (im Folgenden werde ich diese Lösung „PHP als Daemon“ nennen "). <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); $cities = $storage-&gt;getAll(); //    while ($req = getNextRequest()) {    $name = $cities[$req-&gt;getCookie('city_id')];    echo " : {$name}"; }</span></span></code> </pre> <br>  Wir konnten nicht nur die für jede Anforderung wiederholte Initialisierung entfernen, sondern auch die Liste der Städte einmal in der Variablen " <code>$cities</code> speichern und aus verschiedenen Anforderungen verwenden, ohne auf irgendwo anders als auf den Speicher zuzugreifen (dies ist der schnellste Weg, um Daten abzurufen). <br><br>  Die Leistung einer solchen Lösung ist möglicherweise erheblich höher als die des "klassischen" PHP.  Aber normalerweise ist die Steigerung der Produktivität nicht kostenlos - Sie müssen einen Preis dafür bezahlen.  Mal sehen, was es in unserem Fall sein kann. <br><br>  Lassen Sie uns dazu unser Skript etwas komplizieren und anstatt die Variable <code>$name</code> anzuzeigen, füllen wir das Array: <br><br><pre> <code class="php hljs">-  $name = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)]; +  $names[] = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)];</code> </pre><br>  Bei „klassischem“ PHP treten keine Probleme auf - am Ende der Abfrage wird die Variable <code>$name</code> zerstört und jede nachfolgende Anforderung funktioniert wie erwartet.  Wenn Sie PHP als Daemon starten, fügt jede Anforderung dieser Variablen eine weitere Stadt hinzu, was zu einem unkontrollierten Wachstum des Arrays führt, bis der Speicher auf dem Computer leer ist. <br><br>  Im Allgemeinen kann nicht nur der Speicher enden - es können auch andere Fehler auftreten, die zum Tod des Prozesses führen.  Bei solchen Problemen wird "klassisches" PHP automatisch behandelt.  Wenn Sie PHP als Daemon starten, müssen Sie diesen Daemon irgendwie überwachen und neu starten, wenn er abstürzt. <br><br>  Fehler dieser Art sind unangenehm, aber es gibt wirksame Lösungen für sie.  Es ist viel schlimmer, wenn das Skript aufgrund eines Fehlers nicht herunterfällt, sondern die Werte einiger Variablen unvorhersehbar ändert (z. B. wird das Array <code>$cities</code> gelöscht).  In diesem Fall funktionieren alle nachfolgenden Anforderungen mit falschen Daten. <br><br><blockquote>  Zusammenfassend ist es einfacher, Code für „klassisches“ PHP (PHP-FPM, Apache mod_php und dergleichen) zu schreiben - es befreit uns von einer Reihe von Problemen und Fehlern.  Dafür zahlen wir aber mit Leistung. </blockquote><br>  Aus den obigen Beispielen geht hervor, dass PHP in einigen Teilen des Codes Ressourcen ausgibt, die nicht für die Verarbeitung jeder Anforderung des „klassischen“ Codes aufgewendet (oder einmal verschwendet) werden konnten.  Dies sind die folgenden Bereiche: <br><br><ul><li>  Dateiverbindung (einschließen, erfordern usw.); <br></li><li>  Initialisierung (Framework, Bibliotheken, DI-Container usw.); <br></li><li>  Daten vom externen Speicher anfordern (anstatt im Speicher zu speichern). <br></li></ul><br>  PHP gibt es schon seit vielen Jahren und es könnte dank dieses Arbeitsmodells sogar populär geworden sein.  In dieser Zeit wurden viele Methoden mit unterschiedlichem Erfolg entwickelt, um das beschriebene Problem zu lösen.  Ich habe einige davon in meinem vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel erwähnt</a> .  Heute werden wir uns mit zwei ziemlich neuen Lösungen für die Community befassen: Preload und RoadRunner. <br><br><h2>  Vorladen </h2><br>  Von den drei oben aufgeführten Punkten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Preload darauf</a> ausgelegt, den ersten Overhead beim Verbinden von Dateien zu bewältigen.  Auf den ersten Blick mag dies seltsam und bedeutungslos erscheinen, da PHP bereits über OPcache verfügt, der nur für diesen Zweck erstellt wurde.  Um die Essenz zu verstehen, lassen Sie uns mit Hilfe von <code>perf</code> , über das OPcache aktiviert ist, ein reales Profil mit einer Trefferquote von 100% erstellen. <br><br><img src="https://habrastorage.org/webt/rb/y-/jo/rby-jo2hcsjsu3ncjnjxjmbggny.png"><br><br>  Trotz OPcache sehen wir, dass <code>persistent_compile_file</code> 5,84% der Ausführungszeit der Abfrage benötigt. <br><br>  Um zu verstehen, warum dies geschieht, können wir uns die Quellen von <a href="">zend_accel_load_script ansehen</a> .  Aus ihnen ist ersichtlich, dass trotz des Vorhandenseins von OPcache bei jedem Aufruf zum Einschließen <code>include/require</code> Signaturen von Klassen und Funktionen aus dem gemeinsam genutzten Speicher in den Speicher des Arbeitsprozesses kopiert werden und verschiedene Hilfsarbeiten ausgeführt werden.  Und diese Arbeit sollte für jede Anforderung ausgeführt werden, da am Ende der Speicher des Arbeitsprozesses gelöscht wird. <br><br><img src="https://habrastorage.org/webt/6j/nj/zl/6jnjzlelhihw5j5fsgo5bmlluxw.png"><br><br>  Hinzu kommt die große Anzahl von Include / Require-Anrufen, die wir normalerweise in einer einzigen Anfrage tätigen.  Beispielsweise enthält Symfony 4 ungefähr 310 Dateien, bevor die erste nützliche Codezeile ausgeführt wird.  Manchmal geschieht dies implizit: Um eine unten gezeigte Instanz der Klasse A zu erstellen, lädt PHP alle anderen Klassen (B, C, D, E, F, G) automatisch.  Insbesondere in dieser Hinsicht fallen die Abhängigkeiten von Composer auf, die Funktionen deklarieren: Um sicherzustellen, dass diese Funktionen während der Ausführung von Benutzercode verfügbar sind, muss Composer sie unabhängig von der Verwendung immer verbinden, da PHP keine Autoload-Funktionen hat und dies auch nicht sein kann zum Zeitpunkt des Anrufs geladen. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1; }</code> </pre> <br><br><h3>  Wie das Vorspannen funktioniert </h3><br>  Preload hat eine einzige Haupteinstellung, opcache.preload, an die der Pfad zum PHP-Skript übergeben wird.  Dieses Skript wird beim Starten von PHP-FPM / Apache / usw. einmal ausgeführt, und alle Signaturen von Klassen, Methoden und Funktionen, die in dieser Datei deklariert werden, stehen allen Skripten zur Verfügung, die Anforderungen ab der ersten Zeile ihrer Ausführung verarbeiten (wichtig) Hinweis: Dies gilt nicht für Variablen und globale Konstanten. Ihre Werte werden nach dem Ende der Vorladephase auf Null zurückgesetzt.  Sie müssen keine Include- / Require-Aufrufe mehr vornehmen und Funktions- / Klassensignaturen aus dem gemeinsam genutzten Speicher in den Prozessspeicher kopieren: Sie werden alle als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unveränderlich</a> deklariert, und aus diesem Grund können alle Prozesse auf denselben Speicherort verweisen, der sie enthält. <br><br>  Normalerweise befinden sich die benötigten Klassen und Funktionen in verschiedenen Dateien, und es ist unpraktisch, sie in einem Preload-Skript zu kombinieren.  Dies muss jedoch nicht durchgeführt werden: Da das Preload ein reguläres PHP-Skript ist, können wir einfach include / require oder opcache_compile_file () aus dem Preload-Skript für alle benötigten Dateien verwenden.  Da alle diese Dateien einmal geladen werden, kann PHP außerdem zusätzliche Optimierungen vornehmen, die nicht durchgeführt werden konnten, während wir diese Dateien zum Zeitpunkt der Abfrage separat verbunden haben.  PHP nimmt Optimierungen nur im Rahmen jeder einzelnen Datei vor, im Falle des Vorladens jedoch für den gesamten Code, der in der Vorladephase geladen wird. <br><br><h3>  Benchmarks Vorspannung </h3><br>  Um die Vorteile des Preloads in der Praxis zu demonstrieren, habe ich einen CPU-gebundenen Endpunkt Badoo verwendet.  Unser Backend ist im Allgemeinen durch eine CPU-gebundene Last gekennzeichnet.  Diese Tatsache ist die Antwort auf die Frage, warum wir asynchrone Frameworks nicht berücksichtigt haben: Sie bieten keinen Vorteil bei CPU-gebundener Auslastung und komplizieren gleichzeitig den Code noch mehr (er muss anders geschrieben werden) sowie für die Arbeit mit einem Netzwerk, einer Festplatte usw. Spezielle asynchrone Treiber sind erforderlich. <br><br>  Um die Vorteile des Vorladens voll auszuschöpfen, habe ich für das Experiment alle Dateien heruntergeladen, die für das getestete Skript bei der Arbeit erforderlich sind, und es mit einem Anschein einer normalen Produktionslast mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wrk2 geladen</a> - einem fortgeschritteneren Analogon von Apache Benchmark, aber genauso einfach . <br><br>  Um das Vorladen zu versuchen, müssen Sie zuerst auf PHP 7.4 aktualisieren (wir haben jetzt PHP 7.2).  Ich habe die Leistung von PHP 7.2, PHP 7.4 ohne Vorspannung und PHP 7.4 mit Vorspannung gemessen.  Das Ergebnis ist ein solches Bild: <br><br><img src="https://habrastorage.org/webt/sm/ea/5_/smea5_e3kck5zwyk44afzp8ut9u.png"><br><br>  Somit ergibt der Übergang von PHP 7.2 zu PHP 7.4 + 10% für die Leistung an unserem Endpunkt, und die Vorlast ergibt weitere 10% von oben. <br><br>  Beim Vorladen hängen die Ergebnisse stark von der Anzahl der verbundenen Dateien und der Komplexität der ausführbaren Logik ab: Wenn viele Dateien verbunden sind und die Logik einfach ist, liefert das Vorladen mehr als wenn nur wenige Dateien vorhanden sind und die Logik komplex ist. <br><br><h3>  Die Nuancen der Vorspannung </h3><br>  Was die Produktivität erhöht, hat normalerweise einen Nachteil.  Preload hat viele Nuancen, die ich unten geben werde.  Alle müssen berücksichtigt werden, aber nur eine (erste) kann von grundlegender Bedeutung sein. <br><br><h4>  Ändern - neu starten </h4><br>  Da alle Preload-Dateien nur beim Start kompiliert, als unveränderlich markiert und in Zukunft nicht neu kompiliert werden, besteht die einzige Möglichkeit, Änderungen an diesen Dateien zu übernehmen, darin, PHP-FPM / Apache / usw. neu zu starten (neu zu laden oder neu zu starten). <br><br>  Beim Neuladen versucht PHP, so genau wie möglich neu zu starten: Benutzeranforderungen werden nicht unterbrochen, aber während der Vorladephase warten alle neuen Anforderungen auf den Abschluss.  Wenn sich beim Vorladen nicht viel Code befindet, kann dies keine Probleme verursachen. Wenn Sie jedoch versuchen, die gesamte Anwendung herunterzuladen, erhöht sich die Antwortzeit während eines Neustarts erheblich. <br><br>  Auch ein Neustart (unabhängig davon, ob er neu geladen oder neu gestartet wird) hat eine wichtige Funktion - als Ergebnis dieser Aktion wird OPcache gelöscht.  Das heißt, alle Anfragen danach funktionieren mit einem kalten Opcode-Cache, was die Antwortzeit noch weiter verlängern kann. <br><br><h4>  Undefinierte Zeichen </h4><br>  Damit eine Klasse vor dem Laden geladen werden kann, muss bis zu diesem Punkt alles definiert werden, von dem sie abhängt.  Für die folgende Klasse bedeutet dies, dass alle anderen Klassen (B, C, D, E, F, G), die Variable <code>$someGlobalVar</code> und die Konstante SOME_CONST verfügbar sein müssen, bevor diese Klasse kompiliert wird.  Da das Preload-Skript nur regulärer PHP-Code ist, können wir einen Autoloader definieren.  In diesem Fall wird alles, was mit anderen Klassen verbunden ist, automatisch von ihr geladen.  Dies funktioniert jedoch nicht mit Variablen und Konstanten: Wir müssen selbst sicherstellen, dass sie zum Zeitpunkt der Deklaration dieser Klasse definiert sind. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $varLink = $someGlobalVar;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $constLink = SOME_CONST; }</code> </pre> <br>  Glücklicherweise enthält das Preload genügend Tools, um zu verstehen, ob Sie etwas aus dem Weg räumen oder nicht.  Erstens sind dies Warnmeldungen mit Informationen darüber, was nicht geladen werden konnte und warum: <br><br><pre> <code class="plaintext hljs">PHP Warning: Can't preload class MyTestClass with unresolved initializer for constant RAND in /local/preload-internal.php on line 6 PHP Warning: Can't preload unlinked class MyTestClass: Unknown parent AnotherClass in /local/preload-internal.php on line 5</code> </pre> <br>  Zweitens fügt das Preload dem Ergebnis der Funktion opcache_get_status () einen separaten Abschnitt hinzu, der zeigt, was in der Preload-Phase erfolgreich geladen wurde: <br><br><img src="https://habrastorage.org/webt/j7/fh/6u/j7fh6u0ww7plxxrx_x8fguxcazu.png"><br><br><h4>  Klassenfeld / konstante Optimierung </h4><br>  Wie ich oben geschrieben habe, löst Preload die Werte der Felder / Konstanten der Klasse auf und speichert sie.  Auf diese Weise können Sie den Code optimieren: Während der Verarbeitung der Anforderung sind die Daten bereit und müssen nicht aus anderen Daten abgeleitet werden.  Dies kann jedoch zu nicht offensichtlichen Ergebnissen führen, die das folgende Beispiel zeigt: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span>.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">'MYTESTCONST'</span></span>, mt_rand(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre> <br><pre> <code class="php hljs">preload.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestClass</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RAND = MYTESTCONST; }</code> </pre> <br><pre> <code class="php hljs">script.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> MYTESTCONST, <span class="hljs-string"><span class="hljs-string">', '</span></span>, MyTestClass::RAND; <span class="hljs-comment"><span class="hljs-comment">// 32, 154</span></span></code> </pre> <br>  Das Ergebnis ist eine kontraintuitive Situation: Es scheint, dass die Konstanten gleich sein sollten, da einer von ihnen der Wert des anderen zugewiesen wurde, aber in Wirklichkeit ist dies nicht so.  Dies liegt an der Tatsache, dass globale Konstanten im Gegensatz zu Klassenkonstanten / -feldern nach Ende der Vorladephase zwangsweise gelöscht werden, während Klassenkonstanten / -felder aufgelöst und gespeichert werden.  Dies führt dazu, dass wir während der Ausführung der Anfrage die globale Konstante erneut definieren müssen, wodurch sie einen anderen Wert erhalten kann. <br><br><h4>  SomeFunc () kann nicht neu deklariert werden </h4><br>  Bei Klassen ist die Situation einfach: Normalerweise verbinden wir sie nicht explizit, sondern verwenden einen Autoloader.  Dies bedeutet, dass wenn eine Klasse in der Preload-Phase definiert ist, der Autoloader während der Anforderung einfach nicht ausgeführt wird und wir nicht versuchen werden, diese Klasse ein zweites Mal zu verbinden. <br><br>  Bei Funktionen ist die Situation anders: Wir müssen sie explizit verbinden.  Dies kann dazu führen, dass wir im Preload-Skript alle erforderlichen Dateien mit Funktionen verbinden und dies während der Anforderung erneut versuchen (ein typisches Beispiel ist der Composer-Bootloader: Er versucht immer, alle Dateien mit Funktionen zu verbinden).  In diesem Fall erhalten wir eine Fehlermeldung: Die Funktion wurde bereits definiert und kann nicht neu definiert werden. <br><br>  Dieses Problem kann auf verschiedene Arten gelöst werden.  Im Fall von Composer können Sie beispielsweise alles in der Vorladephase verbinden und bei Anforderungen nichts mit Composer zu tun haben.  Eine andere Lösung besteht nicht darin, Dateien direkt mit Funktionen zu verbinden, sondern dies über eine Proxy-Datei mit der Suche nach function_exists () zu tun, wie dies beispielsweise bei Guzzle HTTP der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fall ist</a> . <br><br><img src="https://habrastorage.org/webt/8h/4f/bd/8h4fbddjiu5zbd3xycfnwrdxrmi.png"><br><br><h4>  PHP 7.4 wurde (noch) nicht offiziell veröffentlicht </h4><br>  Diese Nuance wird nach einiger Zeit irrelevant, aber bis die PHP-Version 7.4 noch nicht offiziell veröffentlicht wurde und das PHP-Team ausdrücklich in den Versionshinweisen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schreibt</a> : "Bitte verwenden Sie diese Version NICHT in der Produktion, es ist eine frühe Testversion."  Während unserer Experimente mit Vorspannung sind wir auf mehrere Fehler gestoßen, haben sie selbst behoben und sogar etwas an den Upstream <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesendet</a> .  Um Überraschungen zu vermeiden, ist es besser, auf die offizielle Veröffentlichung zu warten. <br><br><h2>  Roadrunner </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RoadRunner</a> ist ein in Go geschriebener Daemon, der einerseits PHP-Worker erstellt und überwacht (bei Bedarf startet / endet / neu startet), andererseits Anforderungen akzeptiert und an diese Worker weiterleitet.  In diesem Sinne unterscheidet sich seine Arbeit nicht von der Arbeit von PHP-FPM (wo es auch einen Master-Prozess gibt, der die Arbeiter überwacht).  Aber es gibt immer noch Unterschiede.  Der Schlüssel ist, dass RoadRunner den Status des Skripts nach Abschluss der Abfrage nicht zurücksetzt. <br><br>  Wenn wir uns also an unsere Liste erinnern, welche Ressourcen im Fall von „klassischem“ PHP verbraucht werden, können Sie mit RoadRunner alle Punkte behandeln (das Vorladen erfolgt, wie wir uns erinnern, nur mit dem ersten): <br><br><ul><li>  Dateiverbindung (einschließen, erfordern usw.); <br></li><li>  Initialisierung (Framework, Bibliotheken, DI-Container usw.); <br></li><li>  Daten vom externen Speicher anfordern (anstatt im Speicher zu speichern). <br></li></ul><br>  Das Hello World RoadRunner-Beispiel sieht ungefähr so ​​aus: <br><br><pre> <code class="php hljs">$relay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\Goridge\StreamRelay(STDIN, STDOUT); $psr7 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\PSR7Client(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\Worker($relay)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {        $resp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);        $psr7-&gt;respond($resp); }</code> </pre> <br>  Wir werden versuchen, unseren aktuellen Endpunkt, den wir mit Vorspannung getestet haben, ohne Änderungen auf RoadRunner auszuführen, ihn zu laden und die Leistung zu messen.  Keine Änderungen - sonst ist der Benchmark nicht ganz ehrlich. <br><br>  Versuchen wir, das Hello World-Beispiel dafür anzupassen. <br><br>  Erstens möchten wir, wie ich oben geschrieben habe, nicht, dass der Arbeiter im Fehlerfall fällt.  Dazu müssen wir alles in einen globalen Versuch einschließen.  Zweitens, da unser Skript nichts über Zend Diactoros weiß, müssen wir für die Antwort seine Ergebnisse konvertieren.  Dafür verwenden wir ob_-Funktionen.  Drittens weiß unser Skript nichts über die Art der PSR-7-Anforderung.  Die Lösung besteht darin, die Standard-PHP-Umgebung aus diesen Entitäten zu füllen.  Und viertens erwartet unser Skript, dass die Anfrage stirbt und der gesamte Status gelöscht wird.  Daher müssen wir diese Reinigung mit RoadRunner selbst durchführen. <br><br>  So wird die ursprüngliche Hello World-Version ungefähr so: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {        $uri = $req-&gt;getUri();        $_COOKIE = $req-&gt;getCookieParams();        $_POST = $req-&gt;getParsedBody();        $_SERVER = [            <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; $req-&gt;getMethod(),            <span class="hljs-string"><span class="hljs-string">'HTTP_HOST'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'DOCUMENT_URI'</span></span> =&gt; $uri-&gt;getPath(),            <span class="hljs-string"><span class="hljs-string">'SERVER_NAME'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'QUERY_STRING'</span></span> =&gt; $uri-&gt;getQuery(),            <span class="hljs-comment"><span class="hljs-comment">// ...        ];        ob_start();        // our logic here        $output = ob_get_contents();        ob_clean();               $resp = new \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write($output, 200);        $psr7-&gt;respond($resp);    } catch (\Throwable $Throwable) {        // some error handling logic here    }    \UDS\Event::flush();    \PinbaClient::sendAll();    \PinbaClient::flushAll();    \HTTP::clear();    \ViewFactory::clear();    \Logger::clearCaches();       // ... }</span></span></code> </pre> <br><br><h3>  Benchmarks RoadRunner </h3><br>  Nun, es ist Zeit, Benchmarks zu starten. <br><br><img src="https://habrastorage.org/webt/qs/6b/89/qs6b89wrabygtu6ea6d-8i9rk4m.png"><br><br>  Die Ergebnisse entsprechen nicht den Erwartungen: Mit RoadRunner können Sie mehr Faktoren ausgleichen, die zu Leistungsverlusten führen als die Vorspannung. Die Ergebnisse sind jedoch schlechter.  Lassen Sie uns herausfinden, warum dies wie immer geschieht, indem wir perf dafür ausführen. <br><br><img src="https://habrastorage.org/webt/1w/v9/ft/1wv9ftxnmcdxiu48rrkftw1phic.png"><br><br>  In den Perf-Ergebnissen sehen wir phar_compile_file.  Dies liegt daran, dass wir während der Ausführung des Skripts einige Dateien einschließen. Da OPcache nicht aktiviert ist (RoadRunner führt Skripte als CLI aus, wobei OPcache standardmäßig deaktiviert ist), werden diese Dateien bei jeder Anforderung erneut kompiliert. <br><br>  Bearbeiten Sie die RoadRunner-Konfiguration - aktivieren Sie OPcache: <br><br><img src="https://habrastorage.org/webt/-d/zq/wn/-dzqwnysszz3zcpek82a2wtr9wy.png"><br><br><img src="https://habrastorage.org/webt/zt/tp/1w/zttp1w-bl-5xkho85gi1-7d5pek.png"><br><br>  Diese Ergebnisse entsprechen bereits eher unseren Erwartungen: RoadRunner zeigte mehr Leistung als Vorspannung.  Aber vielleicht können wir noch mehr bekommen! <br><br>  Perf scheint nichts Ungewöhnlicheres zu sein - schauen wir uns den PHP-Code an.  Der einfachste Weg, es zu profilieren, ist die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">phpspy</a> : Es ist keine Änderung des PHP-Codes erforderlich - Sie müssen ihn nur in der Konsole ausführen.  Lassen Sie uns dies tun und ein Flammendiagramm erstellen: <br><br><img src="https://habrastorage.org/webt/60/2k/yk/602kykwmxdw1nxaudop0omr98bi.png"><br><br>  Da wir vereinbart haben, die Logik unserer Anwendung für die Reinheit des Experiments nicht zu ändern, interessieren wir uns für den Stapelzweig, der mit der Arbeit von RoadRunner verbunden ist: <br><br><img src="https://habrastorage.org/webt/ta/ag/yz/taagyz-8en1khhrka80i_al2dry.png"><br><br>  Der Hauptteil davon besteht darin, fread () aufzurufen. Damit kann kaum etwas getan werden.  Wir sehen jedoch einige andere Zweige in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">\ Spiral \ RoadRunner \ PSR7Client :: acceptRequest ()</a> , außer fread selbst.  Sie können ihre Bedeutung anhand des Quellcodes verstehen: <br><br><pre> <code class="php hljs">   <span class="hljs-comment"><span class="hljs-comment">/**     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ServerRequestInterface|null     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">    </span></span>{        $rawRequest = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;httpClient-&gt;acceptRequest();        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rawRequest === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;        }        $_SERVER = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;configureServer($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>]);        $request = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;requestFactory-&gt;createServerRequest(            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'method'</span></span>],            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uri'</span></span>],            $_SERVER        );        parse_str($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'rawQuery'</span></span>], $query);        $request = $request            -&gt;withProtocolVersion(<span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::fetchProtocolVersion($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'protocol'</span></span>]))            -&gt;withCookieParams($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'cookies'</span></span>])            -&gt;withQueryParams($query)            -&gt;withUploadedFiles(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;wrapUploads($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uploads'</span></span>]));</code> </pre> <br>  Es wird deutlich, dass RoadRunner versucht, ein PSR-7-kompatibles Anforderungsobjekt mithilfe eines serialisierten Arrays zu erstellen.  Wenn Ihr Framework direkt mit PSR-7-Abfrageobjekten arbeitet (z. B. Symfony <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert nicht</a> ), ist dies vollständig gerechtfertigt.  In anderen Fällen wird der PSR-7 zu einem zusätzlichen Link, bevor die Anforderung in das konvertiert wird, mit dem Ihre Anwendung arbeiten kann.  Entfernen wir diesen Zwischenlink und sehen uns die Ergebnisse noch einmal an: <br><br><img src="https://habrastorage.org/webt/jv/mr/p5/jvmrp567zwsjhft2ocuimx8jk1q.png"><br><br>  Das Testskript war recht einfach, so dass ich einen signifikanten Teil der Leistung herausholen konnte - + 17% im Vergleich zu reinem PHP (ich erinnere mich, dass das Preload + 10% für dasselbe Skript ergibt). <br><br><h3>  Nuancen von RoadRunner </h3><br>  Im Allgemeinen ist die Verwendung von RoadRunner eine schwerwiegendere Änderung als nur die Einbeziehung der Vorspannung, sodass die Nuancen hier noch bedeutender sind. <br><br> -, RoadRunner,  ,  PHP-   ,   ,     ,       :    ,   ,      . <br><br> -,      RoadRunner ,     «»    —      .         /   RoadRunner  ; ,      ,        ,            ,  -   . <br><br> -,        endpoint', , ,       RoadRunner.       . <br><br><h2>  Fazit </h2><br> ,    «» PHP,   ,     preload       RoadRunner. <br><br> PHP  «»   (PHP-FPM, Apache mod_php  )       .       -    ,       .  ,         ,     preload    JIT. <br><br>   ,    , ,       RoadRunner,         . <br><br>    ,      (:           ): <br><br><ul><li> PHP 7.2 — 845 RPS; <br></li><li> PHP 7.4 — 931 RPS; <br></li><li> RoadRunner   — 987 RPS; <br></li><li> PHP 7.4 + preload — 1030 RPS; <br></li><li> RoadRunner   — 1089 RPS. <br></li></ul><br>   Badoo      PHP 7.4       ,         (    ). <br><br> RoadRunner      ,   ,         ,      ,   . <br><br>  Vielen Dank für Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472528/">https://habr.com/ru/post/de472528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472516/index.html">Yandex.Translator für Linux unter Python + GTK3</a></li>
<li><a href="../de472520/index.html">Trainingskits aus dem Video - schnell und effizient</a></li>
<li><a href="../de472522/index.html">Das Buch "Kontinuierliche Weiterentwicklung der API. Die richtigen Entscheidungen in einer sich verändernden technologischen Landschaft “</a></li>
<li><a href="../de472524/index.html">Platz, Gitter und Layouts</a></li>
<li><a href="../de472526/index.html">3D steigt in die Höhe: Es wurde ein neuer Verbundwerkstoff für die Luft- und Raumfahrt entwickelt, der die Masse der Teile um 20% reduziert hat</a></li>
<li><a href="../de472530/index.html">Videoüberwachung in Moskau: aktuelle Realitäten und Perspektiven</a></li>
<li><a href="../de472532/index.html">Nützlicher Hilfelink für Vermarkter</a></li>
<li><a href="../de472534/index.html">Sie wachen auf! (N.-F. Roman, Teil 1 von 2)</a></li>
<li><a href="../de472536/index.html">Smart IdReader SDK - Einbettungserkennung in Projekte in Python und PHP einbetten</a></li>
<li><a href="../de472540/index.html">Sie wachen auf! (n.-f. Geschichte, Teil 2 und die letzte)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>