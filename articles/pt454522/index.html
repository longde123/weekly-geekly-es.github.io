<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôç üë∂üèº üëß Node.js: gerenciando a mem√≥ria dispon√≠vel para aplicativos em execu√ß√£o em cont√™ineres üë©üèª‚Äçü§ù‚Äçüë®üèæ üë®üèæ‚Äçü§ù‚Äçüë®üèª üë∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao executar aplicativos Node.js em cont√™ineres do Docker, as configura√ß√µes tradicionais de mem√≥ria nem sempre funcionam conforme o esperado. O materia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js: gerenciando a mem√≥ria dispon√≠vel para aplicativos em execu√ß√£o em cont√™ineres</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454522/">  Ao executar aplicativos Node.js em cont√™ineres do Docker, as configura√ß√µes tradicionais de mem√≥ria nem sempre funcionam conforme o esperado.  O material, cuja tradu√ß√£o publicamos hoje, √© dedicado a encontrar a resposta para a pergunta de por que isso acontece.  Ele tamb√©m fornecer√° recomenda√ß√µes pr√°ticas para gerenciar a mem√≥ria dispon√≠vel para aplicativos Node.js. executados em cont√™ineres. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/9_/rp/-s/9_rp-s7libv7ncp6mubs2h_qjzu.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Revis√£o de recomenda√ß√µes</font> </h2><br>  Suponha que um aplicativo Node.js seja executado em um cont√™iner com um limite de mem√≥ria definido.  Se estamos falando sobre o Docker, a op√ß√£o <code>--memory</code> pode ser usada para definir esse limite.  Algo semelhante √© poss√≠vel ao trabalhar com sistemas de orquestra√ß√£o de cont√™ineres.  Nesse caso, √© recomend√°vel que, ao iniciar o aplicativo <code>--max-old-space-size</code> , use a op√ß√£o <code>--max-old-space-size</code> .  Isso permite que voc√™ informe a plataforma sobre quanta mem√≥ria est√° dispon√≠vel e tamb√©m leve em considera√ß√£o o fato de que essa quantidade deve ser menor que o limite definido no n√≠vel do cont√™iner. <br><br>  Quando o aplicativo Node.js for executado dentro do cont√™iner, configure a capacidade da mem√≥ria dispon√≠vel para ele, de acordo com o valor m√°ximo do uso de mem√≥ria ativa pelo aplicativo.  Isso √© feito se os limites de mem√≥ria do cont√™iner puderem ser configurados. <br><br>  Agora vamos falar sobre o problema do uso de mem√≥ria em cont√™ineres em mais detalhes. <br><br><h2>  <font color="#3AC1EF">Limite de mem√≥ria do Docker</font> </h2><br>  Por padr√£o, os cont√™ineres n√£o t√™m limites de recursos e podem usar a quantidade de mem√≥ria que o sistema operacional permitir.  O comando <code>docker run</code> possui op√ß√µes de linha de comando que permitem definir limites em rela√ß√£o ao uso de mem√≥ria ou recursos do processador. <br><br>  O comando de inicializa√ß√£o do cont√™iner pode ficar assim: <br><br><pre> <code class="javascript hljs">docker run --memory &lt;x&gt;&lt;y&gt; --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Observe o seguinte: <br><br><ul><li>  <code>x</code> √© o limite da quantidade de mem√≥ria dispon√≠vel para o cont√™iner, expressa em unidades de <code>y</code> . </li><li>  <code>y</code> pode levar o valor <code>b</code> (bytes), <code>k</code> (kilobytes), <code>m</code> (megabytes), <code>g</code> (gigabytes). </li></ul><br>  Aqui est√° um exemplo de um comando de inicializa√ß√£o de cont√™iner: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1000000</span></span>b --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Aqui, o limite de mem√≥ria √© definido para <code>1000000</code> bytes. <br><br>  Para verificar o limite de mem√≥ria definido no n√≠vel do cont√™iner, voc√™ pode, no cont√™iner, executar o seguinte comando: <br><br><pre> <code class="javascript hljs">cat /sys/fs/cgroup/memory/memory.limit_in_bytes</code> </pre> <br>  Vamos falar sobre o comportamento do sistema ao especificar o limite de mem√≥ria do aplicativo <code>--max-old-space-size</code> usando a chave <code>--max-old-space-size</code> .  Nesse caso, esse limite de mem√≥ria corresponder√° ao limite definido no n√≠vel do cont√™iner. <br><br>  O que √© chamado de "espa√ßo antigo" no nome da chave √© um dos fragmentos do heap controlado pelo V8 (o local em que os objetos JavaScript "antigos" s√£o colocados).  Essa tecla, se voc√™ n√£o entrar nos detalhes que tocamos abaixo, controla o tamanho m√°ximo da pilha.  Detalhes sobre op√ß√µes de linha de comando do Node.js. podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Em geral, quando um aplicativo tenta usar mais mem√≥ria do que o dispon√≠vel no cont√™iner, sua opera√ß√£o √© encerrada. <br><br>  No exemplo a seguir (o arquivo do aplicativo √© chamado <code>test-fatal-error.js</code> ), os objetos <code>MyRecord</code> s√£o colocados na matriz da <code>list</code> , com um intervalo de 10 milissegundos.  Isso leva ao crescimento descontrolado de heap, simulando um vazamento de mem√≥ria. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = []; setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyRecord(); list.push(record); },<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRecord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x=<span class="hljs-string"><span class="hljs-string">'hii'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.account = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); } setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(process.memoryUsage()) },<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Observe que todos os exemplos de programas que discutiremos aqui s√£o colocados na imagem do Docker, que pode ser baixada no Docker Hub: <br><br><pre> <code class="javascript hljs">docker pull ravali1906/dockermemory</code> </pre> <br>  Voc√™ pode usar esta imagem para experimentos independentes. <br><br>  Al√©m disso, voc√™ pode empacotar o aplicativo em um cont√™iner do Docker, coletar a imagem e execut√°-la com o limite de mem√≥ria: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">512</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Aqui <code>ravali1906/dockermemory</code> √© o nome da imagem. <br><br>  Agora voc√™ pode iniciar o aplicativo especificando um limite de mem√≥ria que exceda o limite do cont√™iner: <br><br><pre> <code class="javascript hljs">$ node --max_old_space_size=<span class="hljs-number"><span class="hljs-number">1024</span></span> test-fatal-error.js { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">550498304</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">1090719744</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">1030627104</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">8272</span></span> } Killed</code> </pre> <br>  Aqui, a <code>--max_old_space_size</code> representa o limite de mem√≥ria indicado em megabytes.  O m√©todo <code>process.memoryUsage()</code> fornece informa√ß√µes sobre o uso da mem√≥ria.  Os valores s√£o expressos em bytes. <br><br>  O aplicativo em algum momento √© for√ßado a terminar.  Isso acontece quando a quantidade de mem√≥ria usada por ele atravessa uma determinada borda.  O que √© essa fronteira?  De que limita√ß√µes podemos falar sobre a quantidade de mem√≥ria? <br><br><h2>  <font color="#3AC1EF">O comportamento esperado de um aplicativo em execu√ß√£o com a chave √© - max-old-space-size</font> </h2><br>  Por padr√£o, o tamanho m√°ximo de heap no Node.js (at√© a vers√£o 11.x) √© de 700 MB em plataformas de 32 bits e 1400 MB em plataformas de 64 bits.  Voc√™ pode ler sobre como definir esses valores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Em teoria, se voc√™ usar a chave <code>--max-old-space-size</code> para <code>--max-old-space-size</code> limite de mem√≥ria que exceda o limite de mem√≥ria do cont√™iner, poder√° esperar que o aplicativo seja finalizado pelo mecanismo de seguran√ßa do kernel do Linux OOM Killer. <br><br>  Na realidade, isso pode n√£o acontecer. <br><br><h2>  <font color="#3AC1EF">O comportamento real do aplicativo em execu√ß√£o com a chave √© max-old-space-size</font> </h2><br>  O aplicativo, imediatamente ap√≥s o lan√ßamento, n√£o aloca toda a mem√≥ria cujo limite √© especificado usando <code>--max-old-space-size</code> .  O tamanho da pilha do JavaScript depende das necessidades do aplicativo.  Voc√™ pode avaliar quanta mem√≥ria o aplicativo usa com base no valor do campo <code>heapUsed</code> do objeto retornado pelo m√©todo <code>process.memoryUsage()</code> .  De fato, estamos falando sobre a mem√≥ria alocada no heap para objetos. <br><br>  Como resultado, conclu√≠mos que o aplicativo ser√° encerrado √† for√ßa se o tamanho do heap for maior que o limite definido pela chave <code>--memory</code> quando o cont√™iner for iniciado. <br><br>  Mas, na realidade, isso tamb√©m n√£o pode acontecer. <br><br>  Ao criar um perfil de aplicativos Node.js intensivos em recursos que s√£o executados em cont√™ineres com um determinado limite de mem√≥ria, os seguintes padr√µes podem ser observados: <br><br><ol><li>  OOM Killer √© acionado muito depois do momento em que os <code>heapUsed</code> e <code>heapUsed</code> s√£o significativamente maiores que os limites de mem√≥ria. </li><li>  OOM Killer n√£o responde a limites excedentes. </li></ol><br><h2>  <font color="#3AC1EF">Uma explica√ß√£o do comportamento dos aplicativos Node.js. nos cont√™ineres</font> </h2><br>  Um cont√™iner supervisiona um indicador importante dos aplicativos executados nele.  Este √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RSS</a> (tamanho do conjunto residente).  Este indicador representa uma certa parte da mem√≥ria virtual do aplicativo. <br><br>  Al√©m disso, √© um peda√ßo de mem√≥ria que √© alocado para o aplicativo. <br><br>  Mas isso n√£o √© tudo.  O RSS faz parte da mem√≥ria ativa alocada para o aplicativo. <br><br>  Nem toda a mem√≥ria alocada para um aplicativo pode estar ativa.  O fato √© que a ‚Äúmem√≥ria alocada‚Äù n√£o √© necessariamente alocada fisicamente at√© que o processo comece a realmente us√°-la.  Al√©m disso, em resposta a solicita√ß√µes de aloca√ß√£o de mem√≥ria de outros processos, o sistema operacional pode despejar partes inativas da mem√≥ria do aplicativo no arquivo de pagina√ß√£o e transferir o espa√ßo livre para outros processos.  E quando o aplicativo precisar novamente desses peda√ßos de mem√≥ria, eles ser√£o retirados do arquivo de troca e retornados √† mem√≥ria f√≠sica. <br><br>  A m√©trica RSS indica a quantidade de mem√≥ria ativa e dispon√≠vel para o aplicativo em seu espa√ßo de endere√ßo.  √â ele quem influencia a decis√£o sobre o encerramento for√ßado do aplicativo. <br><br><h2>  <font color="#3AC1EF">Evid√™ncia</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç Exemplo n¬∫ 1.</font>  <font color="#3AC1EF">Um aplicativo que aloca mem√≥ria para um buffer</font> </h3><br>  O exemplo a seguir, <code>buffer_example.js</code> , mostra um programa que aloca mem√≥ria para um buffer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Para que a quantidade de mem√≥ria alocada pelo programa exceda o limite definido quando o cont√™iner foi iniciado, primeiro execute o cont√™iner com o seguinte comando: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Depois disso, execute o programa: <br><br><pre> <code class="javascript hljs">$ node buffer_example <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  Como voc√™ pode ver, o sistema n√£o concluiu o programa, embora a mem√≥ria alocada pelo programa exceda o limite do cont√™iner.  Isso aconteceu devido ao fato de o programa n√£o funcionar com toda a mem√≥ria alocada.  O RSS √© muito pequeno, n√£o excede o limite de mem√≥ria do cont√™iner. <br><br><h3>  <font color="#3AC1EF">‚ñç Exemplo No. 2.</font>  <font color="#3AC1EF">Aplicativo preenchendo o buffer com dados</font> </h3><br>  No exemplo a seguir, <code>buffer_example_fill.js</code> , a mem√≥ria n√£o √© apenas alocada, mas tamb√©m preenchida com dados: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Execute o cont√™iner: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Depois disso, execute o aplicativo: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">984</span></span></code> </pre> <br>  Aparentemente, mesmo agora o aplicativo n√£o termina!  Porque  O fato √© que, quando a quantidade de mem√≥ria ativa atinge o limite definido quando o cont√™iner foi iniciado e h√° espa√ßo no arquivo de pagina√ß√£o, algumas das p√°ginas antigas na mem√≥ria do processo s√£o movidas para o arquivo de pagina√ß√£o.  A mem√≥ria liberada √© disponibilizada para o mesmo processo.  Por padr√£o, o Docker aloca espa√ßo para o arquivo de troca igual ao limite de mem√≥ria definido usando o sinalizador <code>--memory</code> .  Diante disso, podemos dizer que o processo possui 2 GB de mem√≥ria - 1 GB na mem√≥ria ativa e 1 GB no arquivo de pagina√ß√£o.  Ou seja, devido ao fato de o aplicativo poder usar sua pr√≥pria mem√≥ria, cujo conte√∫do √© movido temporariamente para o arquivo de pagina√ß√£o, o tamanho do √≠ndice RSS est√° dentro do limite do cont√™iner.  Como resultado, o aplicativo continua funcionando. <br><br><h3>  <font color="#3AC1EF">‚ñç Exemplo No. 3.</font>  <font color="#3AC1EF">Um aplicativo que preenche um buffer com dados em execu√ß√£o em um cont√™iner que n√£o usa um arquivo de pagina√ß√£o</font> </h3><br>  Aqui est√° o c√≥digo com o qual experimentaremos aqui (este √© o mesmo arquivo <code>buffer_example_fill.js</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Desta vez, execute o cont√™iner, configurando explicitamente os recursos de trabalho com o arquivo de permuta: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swap=<span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swappiness=<span class="hljs-number"><span class="hljs-number">0</span></span> --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Inicie o aplicativo: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> Killed</code> </pre> <br>  Veja a mensagem <code>Killed</code> ?  Quando o valor da chave <code>--memory-swap</code> √© igual ao <code>--memory</code> chave <code>--memory</code> , isso informa ao cont√™iner que ele n√£o deve usar o arquivo de <code>--memory</code> .  Al√©m disso, por padr√£o, o kernel do sistema operacional no qual o cont√™iner √© executado pode despejar uma certa quantidade de p√°ginas de mem√≥ria an√¥nima usadas pelo cont√™iner no arquivo de pagina√ß√£o.  <code>--memory-swappiness</code> como <code>0</code> , desativamos esse recurso.  Como resultado, o arquivo de pagina√ß√£o n√£o √© usado dentro do cont√™iner.  O processo termina quando a m√©trica RSS excede o limite de mem√≥ria do cont√™iner. <br><br><h2>  <font color="#3AC1EF">Recomenda√ß√µes gerais</font> </h2><br>  Quando os aplicativos Node.js s√£o iniciados com a chave <code>--max-old-space-size</code> , cujo valor excede o limite de mem√≥ria definido quando o cont√™iner foi iniciado, pode parecer que o Node.js "n√£o est√° prestando aten√ß√£o" ao limite do cont√™iner.  Mas, como pode ser visto nos exemplos anteriores, a raz√£o √≥bvia para esse comportamento √© o fato de o aplicativo simplesmente n√£o usar todo o volume de heap especificado com o <code>--max-old-space-size</code> . <br><br>  Lembre-se de que o aplicativo nem sempre se comportar√° da mesma maneira se usar mais mem√≥ria do que a dispon√≠vel no cont√™iner.  Porque  O fato √© que a mem√≥ria ativa do processo (RSS) √© influenciada por muitos fatores externos que o pr√≥prio aplicativo n√£o pode influenciar.  Eles dependem da carga no sistema e nas caracter√≠sticas do ambiente.  Por exemplo, esses s√£o recursos do pr√≥prio aplicativo, o n√≠vel de paralelismo no sistema, recursos do planejador do sistema operacional, recursos do coletor de lixo e assim por diante.  Al√©m disso, esses fatores, de um lan√ßamento para outro, podem mudar. <br><br><h2>  <font color="#3AC1EF">Recomenda√ß√µes sobre como definir o tamanho do heap do Node.js para os casos em que voc√™ pode controlar esta op√ß√£o, mas n√£o com restri√ß√µes de mem√≥ria no n√≠vel do cont√™iner</font> </h2><br><ul><li>  Execute o aplicativo Node.js m√≠nimo no cont√™iner e me√ßa o tamanho est√°tico do RSS (no meu caso, para o Node.js.x, isso √© cerca de 20 Mb). </li><li>  O heap do Node.js cont√©m n√£o apenas o old_space, mas tamb√©m outros (como new_space, code_space e assim por diante).  Portanto, se voc√™ levar em considera√ß√£o a configura√ß√£o padr√£o da plataforma, deve confiar no fato de que o programa precisar√° de cerca de 20 MB a mais de mem√≥ria.  Se as configura√ß√µes padr√£o foram alteradas, essas altera√ß√µes tamb√©m devem ser levadas em considera√ß√£o. </li><li>  Agora precisamos subtrair o valor obtido (suponha que seja 40 MB) da quantidade de mem√≥ria dispon√≠vel no cont√™iner.  O que resta √© um valor que, sem medo de que a <code>--max-old-space-size</code> do programa fique sem mem√≥ria, possa ser especificado como o valor da chave - <code>--max-old-space-size</code> . </li></ul><br><h2>  <font color="#3AC1EF">Recomenda√ß√µes para definir limites de mem√≥ria do cont√™iner para casos em que esse par√¢metro pode ser controlado, mas os par√¢metros do aplicativo Node.js.</font> </h2><br><ul><li>  Execute o aplicativo nos modos que permitem descobrir os valores de pico da mem√≥ria consumida por ele. </li><li>  Analise a pontua√ß√£o do RSS.  Em particular, aqui, junto com o m√©todo <code>process.memoryUsage()</code> , o comando <code>top</code> do Linux pode ser √∫til. </li><li>  Desde que no cont√™iner no qual est√° planejado executar o aplicativo, nada al√©m de n√£o ser executado, o valor obtido possa ser usado como limite de mem√≥ria do cont√™iner.  Para ser seguro, √© recomend√°vel aument√°-lo em pelo menos 10%. </li></ul><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  No Node.j 12.x, alguns dos problemas discutidos aqui s√£o resolvidos ajustando adaptativamente o tamanho do heap, que √© executado de acordo com a quantidade de RAM dispon√≠vel.  Esse mecanismo tamb√©m funciona ao executar aplicativos Node.js. em cont√™ineres.  Mas as configura√ß√µes podem diferir das configura√ß√µes padr√£o.  Isso, por exemplo, acontece quando a chave <code>--max_old_space_size</code> foi usada ao iniciar o aplicativo.  Para esses casos, todos os itens acima permanecem relevantes.  Isso sugere que qualquer pessoa que execute aplicativos Node.js. em cont√™ineres seja cuidadosa e respons√°vel com as configura√ß√µes de mem√≥ria.  Al√©m disso, o conhecimento dos limites padr√£o de uso de mem√≥ria, que √© bastante conservador, pode melhorar o desempenho do aplicativo alterando deliberadamente esses limites. <br><br>  <b>Caros leitores!</b>  Voc√™ ficou com problemas de mem√≥ria ao executar aplicativos Node.js. nos cont√™ineres do Docker? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454522/">https://habr.com/ru/post/pt454522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454512/index.html">Relat√≥rio do caf√© da manh√£ com Charles Weatherly, autor do livro de culto Etudes for Programmers</a></li>
<li><a href="../pt454514/index.html">Desenvolvimento de um sintetizador de m√∫sica simples no ATMEGA8</a></li>
<li><a href="../pt454516/index.html">Como obter um bom texto por 200 rublos</a></li>
<li><a href="../pt454518/index.html">Wasmer: a biblioteca Go mais r√°pida para executar o c√≥digo do WebAssembly</a></li>
<li><a href="../pt454520/index.html">Diretrizes para escrever c√≥digo JavaScript limpo</a></li>
<li><a href="../pt454524/index.html">Repara√ß√£o de fita para a cabe√ßa Samsung Level On Pro</a></li>
<li><a href="../pt454530/index.html">A DJI criou um octoc√≥ptero que pode fazer filmes</a></li>
<li><a href="../pt454532/index.html">Vou dizer uma palavra sobre a abordagem de engenharia</a></li>
<li><a href="../pt454534/index.html">N√£o cient√≠fico sobre m√¥nadas</a></li>
<li><a href="../pt454536/index.html">Amplificador para o cl√°ssico sensor de frequ√™ncia card√≠aca</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>