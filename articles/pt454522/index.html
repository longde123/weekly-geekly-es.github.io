<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍 👶🏼 👧 Node.js: gerenciando a memória disponível para aplicativos em execução em contêineres 👩🏻‍🤝‍👨🏾 👨🏾‍🤝‍👨🏻 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao executar aplicativos Node.js em contêineres do Docker, as configurações tradicionais de memória nem sempre funcionam conforme o esperado. O materia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js: gerenciando a memória disponível para aplicativos em execução em contêineres</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454522/">  Ao executar aplicativos Node.js em contêineres do Docker, as configurações tradicionais de memória nem sempre funcionam conforme o esperado.  O material, cuja tradução publicamos hoje, é dedicado a encontrar a resposta para a pergunta de por que isso acontece.  Ele também fornecerá recomendações práticas para gerenciar a memória disponível para aplicativos Node.js. executados em contêineres. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/9_/rp/-s/9_rp-s7libv7ncp6mubs2h_qjzu.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Revisão de recomendações</font> </h2><br>  Suponha que um aplicativo Node.js seja executado em um contêiner com um limite de memória definido.  Se estamos falando sobre o Docker, a opção <code>--memory</code> pode ser usada para definir esse limite.  Algo semelhante é possível ao trabalhar com sistemas de orquestração de contêineres.  Nesse caso, é recomendável que, ao iniciar o aplicativo <code>--max-old-space-size</code> , use a opção <code>--max-old-space-size</code> .  Isso permite que você informe a plataforma sobre quanta memória está disponível e também leve em consideração o fato de que essa quantidade deve ser menor que o limite definido no nível do contêiner. <br><br>  Quando o aplicativo Node.js for executado dentro do contêiner, configure a capacidade da memória disponível para ele, de acordo com o valor máximo do uso de memória ativa pelo aplicativo.  Isso é feito se os limites de memória do contêiner puderem ser configurados. <br><br>  Agora vamos falar sobre o problema do uso de memória em contêineres em mais detalhes. <br><br><h2>  <font color="#3AC1EF">Limite de memória do Docker</font> </h2><br>  Por padrão, os contêineres não têm limites de recursos e podem usar a quantidade de memória que o sistema operacional permitir.  O comando <code>docker run</code> possui opções de linha de comando que permitem definir limites em relação ao uso de memória ou recursos do processador. <br><br>  O comando de inicialização do contêiner pode ficar assim: <br><br><pre> <code class="javascript hljs">docker run --memory &lt;x&gt;&lt;y&gt; --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Observe o seguinte: <br><br><ul><li>  <code>x</code> é o limite da quantidade de memória disponível para o contêiner, expressa em unidades de <code>y</code> . </li><li>  <code>y</code> pode levar o valor <code>b</code> (bytes), <code>k</code> (kilobytes), <code>m</code> (megabytes), <code>g</code> (gigabytes). </li></ul><br>  Aqui está um exemplo de um comando de inicialização de contêiner: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1000000</span></span>b --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Aqui, o limite de memória é definido para <code>1000000</code> bytes. <br><br>  Para verificar o limite de memória definido no nível do contêiner, você pode, no contêiner, executar o seguinte comando: <br><br><pre> <code class="javascript hljs">cat /sys/fs/cgroup/memory/memory.limit_in_bytes</code> </pre> <br>  Vamos falar sobre o comportamento do sistema ao especificar o limite de memória do aplicativo <code>--max-old-space-size</code> usando a chave <code>--max-old-space-size</code> .  Nesse caso, esse limite de memória corresponderá ao limite definido no nível do contêiner. <br><br>  O que é chamado de "espaço antigo" no nome da chave é um dos fragmentos do heap controlado pelo V8 (o local em que os objetos JavaScript "antigos" são colocados).  Essa tecla, se você não entrar nos detalhes que tocamos abaixo, controla o tamanho máximo da pilha.  Detalhes sobre opções de linha de comando do Node.js. podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Em geral, quando um aplicativo tenta usar mais memória do que o disponível no contêiner, sua operação é encerrada. <br><br>  No exemplo a seguir (o arquivo do aplicativo é chamado <code>test-fatal-error.js</code> ), os objetos <code>MyRecord</code> são colocados na matriz da <code>list</code> , com um intervalo de 10 milissegundos.  Isso leva ao crescimento descontrolado de heap, simulando um vazamento de memória. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = []; setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyRecord(); list.push(record); },<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRecord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x=<span class="hljs-string"><span class="hljs-string">'hii'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.account = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); } setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(process.memoryUsage()) },<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Observe que todos os exemplos de programas que discutiremos aqui são colocados na imagem do Docker, que pode ser baixada no Docker Hub: <br><br><pre> <code class="javascript hljs">docker pull ravali1906/dockermemory</code> </pre> <br>  Você pode usar esta imagem para experimentos independentes. <br><br>  Além disso, você pode empacotar o aplicativo em um contêiner do Docker, coletar a imagem e executá-la com o limite de memória: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">512</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Aqui <code>ravali1906/dockermemory</code> é o nome da imagem. <br><br>  Agora você pode iniciar o aplicativo especificando um limite de memória que exceda o limite do contêiner: <br><br><pre> <code class="javascript hljs">$ node --max_old_space_size=<span class="hljs-number"><span class="hljs-number">1024</span></span> test-fatal-error.js { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">550498304</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">1090719744</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">1030627104</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">8272</span></span> } Killed</code> </pre> <br>  Aqui, a <code>--max_old_space_size</code> representa o limite de memória indicado em megabytes.  O método <code>process.memoryUsage()</code> fornece informações sobre o uso da memória.  Os valores são expressos em bytes. <br><br>  O aplicativo em algum momento é forçado a terminar.  Isso acontece quando a quantidade de memória usada por ele atravessa uma determinada borda.  O que é essa fronteira?  De que limitações podemos falar sobre a quantidade de memória? <br><br><h2>  <font color="#3AC1EF">O comportamento esperado de um aplicativo em execução com a chave é - max-old-space-size</font> </h2><br>  Por padrão, o tamanho máximo de heap no Node.js (até a versão 11.x) é de 700 MB em plataformas de 32 bits e 1400 MB em plataformas de 64 bits.  Você pode ler sobre como definir esses valores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Em teoria, se você usar a chave <code>--max-old-space-size</code> para <code>--max-old-space-size</code> limite de memória que exceda o limite de memória do contêiner, poderá esperar que o aplicativo seja finalizado pelo mecanismo de segurança do kernel do Linux OOM Killer. <br><br>  Na realidade, isso pode não acontecer. <br><br><h2>  <font color="#3AC1EF">O comportamento real do aplicativo em execução com a chave é max-old-space-size</font> </h2><br>  O aplicativo, imediatamente após o lançamento, não aloca toda a memória cujo limite é especificado usando <code>--max-old-space-size</code> .  O tamanho da pilha do JavaScript depende das necessidades do aplicativo.  Você pode avaliar quanta memória o aplicativo usa com base no valor do campo <code>heapUsed</code> do objeto retornado pelo método <code>process.memoryUsage()</code> .  De fato, estamos falando sobre a memória alocada no heap para objetos. <br><br>  Como resultado, concluímos que o aplicativo será encerrado à força se o tamanho do heap for maior que o limite definido pela chave <code>--memory</code> quando o contêiner for iniciado. <br><br>  Mas, na realidade, isso também não pode acontecer. <br><br>  Ao criar um perfil de aplicativos Node.js intensivos em recursos que são executados em contêineres com um determinado limite de memória, os seguintes padrões podem ser observados: <br><br><ol><li>  OOM Killer é acionado muito depois do momento em que os <code>heapUsed</code> e <code>heapUsed</code> são significativamente maiores que os limites de memória. </li><li>  OOM Killer não responde a limites excedentes. </li></ol><br><h2>  <font color="#3AC1EF">Uma explicação do comportamento dos aplicativos Node.js. nos contêineres</font> </h2><br>  Um contêiner supervisiona um indicador importante dos aplicativos executados nele.  Este é o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RSS</a> (tamanho do conjunto residente).  Este indicador representa uma certa parte da memória virtual do aplicativo. <br><br>  Além disso, é um pedaço de memória que é alocado para o aplicativo. <br><br>  Mas isso não é tudo.  O RSS faz parte da memória ativa alocada para o aplicativo. <br><br>  Nem toda a memória alocada para um aplicativo pode estar ativa.  O fato é que a “memória alocada” não é necessariamente alocada fisicamente até que o processo comece a realmente usá-la.  Além disso, em resposta a solicitações de alocação de memória de outros processos, o sistema operacional pode despejar partes inativas da memória do aplicativo no arquivo de paginação e transferir o espaço livre para outros processos.  E quando o aplicativo precisar novamente desses pedaços de memória, eles serão retirados do arquivo de troca e retornados à memória física. <br><br>  A métrica RSS indica a quantidade de memória ativa e disponível para o aplicativo em seu espaço de endereço.  É ele quem influencia a decisão sobre o encerramento forçado do aplicativo. <br><br><h2>  <font color="#3AC1EF">Evidência</font> </h2><br><h3>  <font color="#3AC1EF">▍ Exemplo nº 1.</font>  <font color="#3AC1EF">Um aplicativo que aloca memória para um buffer</font> </h3><br>  O exemplo a seguir, <code>buffer_example.js</code> , mostra um programa que aloca memória para um buffer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Para que a quantidade de memória alocada pelo programa exceda o limite definido quando o contêiner foi iniciado, primeiro execute o contêiner com o seguinte comando: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Depois disso, execute o programa: <br><br><pre> <code class="javascript hljs">$ node buffer_example <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  Como você pode ver, o sistema não concluiu o programa, embora a memória alocada pelo programa exceda o limite do contêiner.  Isso aconteceu devido ao fato de o programa não funcionar com toda a memória alocada.  O RSS é muito pequeno, não excede o limite de memória do contêiner. <br><br><h3>  <font color="#3AC1EF">▍ Exemplo No. 2.</font>  <font color="#3AC1EF">Aplicativo preenchendo o buffer com dados</font> </h3><br>  No exemplo a seguir, <code>buffer_example_fill.js</code> , a memória não é apenas alocada, mas também preenchida com dados: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Execute o contêiner: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Depois disso, execute o aplicativo: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">984</span></span></code> </pre> <br>  Aparentemente, mesmo agora o aplicativo não termina!  Porque  O fato é que, quando a quantidade de memória ativa atinge o limite definido quando o contêiner foi iniciado e há espaço no arquivo de paginação, algumas das páginas antigas na memória do processo são movidas para o arquivo de paginação.  A memória liberada é disponibilizada para o mesmo processo.  Por padrão, o Docker aloca espaço para o arquivo de troca igual ao limite de memória definido usando o sinalizador <code>--memory</code> .  Diante disso, podemos dizer que o processo possui 2 GB de memória - 1 GB na memória ativa e 1 GB no arquivo de paginação.  Ou seja, devido ao fato de o aplicativo poder usar sua própria memória, cujo conteúdo é movido temporariamente para o arquivo de paginação, o tamanho do índice RSS está dentro do limite do contêiner.  Como resultado, o aplicativo continua funcionando. <br><br><h3>  <font color="#3AC1EF">▍ Exemplo No. 3.</font>  <font color="#3AC1EF">Um aplicativo que preenche um buffer com dados em execução em um contêiner que não usa um arquivo de paginação</font> </h3><br>  Aqui está o código com o qual experimentaremos aqui (este é o mesmo arquivo <code>buffer_example_fill.js</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Desta vez, execute o contêiner, configurando explicitamente os recursos de trabalho com o arquivo de permuta: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swap=<span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swappiness=<span class="hljs-number"><span class="hljs-number">0</span></span> --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Inicie o aplicativo: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> Killed</code> </pre> <br>  Veja a mensagem <code>Killed</code> ?  Quando o valor da chave <code>--memory-swap</code> é igual ao <code>--memory</code> chave <code>--memory</code> , isso informa ao contêiner que ele não deve usar o arquivo de <code>--memory</code> .  Além disso, por padrão, o kernel do sistema operacional no qual o contêiner é executado pode despejar uma certa quantidade de páginas de memória anônima usadas pelo contêiner no arquivo de paginação.  <code>--memory-swappiness</code> como <code>0</code> , desativamos esse recurso.  Como resultado, o arquivo de paginação não é usado dentro do contêiner.  O processo termina quando a métrica RSS excede o limite de memória do contêiner. <br><br><h2>  <font color="#3AC1EF">Recomendações gerais</font> </h2><br>  Quando os aplicativos Node.js são iniciados com a chave <code>--max-old-space-size</code> , cujo valor excede o limite de memória definido quando o contêiner foi iniciado, pode parecer que o Node.js "não está prestando atenção" ao limite do contêiner.  Mas, como pode ser visto nos exemplos anteriores, a razão óbvia para esse comportamento é o fato de o aplicativo simplesmente não usar todo o volume de heap especificado com o <code>--max-old-space-size</code> . <br><br>  Lembre-se de que o aplicativo nem sempre se comportará da mesma maneira se usar mais memória do que a disponível no contêiner.  Porque  O fato é que a memória ativa do processo (RSS) é influenciada por muitos fatores externos que o próprio aplicativo não pode influenciar.  Eles dependem da carga no sistema e nas características do ambiente.  Por exemplo, esses são recursos do próprio aplicativo, o nível de paralelismo no sistema, recursos do planejador do sistema operacional, recursos do coletor de lixo e assim por diante.  Além disso, esses fatores, de um lançamento para outro, podem mudar. <br><br><h2>  <font color="#3AC1EF">Recomendações sobre como definir o tamanho do heap do Node.js para os casos em que você pode controlar esta opção, mas não com restrições de memória no nível do contêiner</font> </h2><br><ul><li>  Execute o aplicativo Node.js mínimo no contêiner e meça o tamanho estático do RSS (no meu caso, para o Node.js.x, isso é cerca de 20 Mb). </li><li>  O heap do Node.js contém não apenas o old_space, mas também outros (como new_space, code_space e assim por diante).  Portanto, se você levar em consideração a configuração padrão da plataforma, deve confiar no fato de que o programa precisará de cerca de 20 MB a mais de memória.  Se as configurações padrão foram alteradas, essas alterações também devem ser levadas em consideração. </li><li>  Agora precisamos subtrair o valor obtido (suponha que seja 40 MB) da quantidade de memória disponível no contêiner.  O que resta é um valor que, sem medo de que a <code>--max-old-space-size</code> do programa fique sem memória, possa ser especificado como o valor da chave - <code>--max-old-space-size</code> . </li></ul><br><h2>  <font color="#3AC1EF">Recomendações para definir limites de memória do contêiner para casos em que esse parâmetro pode ser controlado, mas os parâmetros do aplicativo Node.js.</font> </h2><br><ul><li>  Execute o aplicativo nos modos que permitem descobrir os valores de pico da memória consumida por ele. </li><li>  Analise a pontuação do RSS.  Em particular, aqui, junto com o método <code>process.memoryUsage()</code> , o comando <code>top</code> do Linux pode ser útil. </li><li>  Desde que no contêiner no qual está planejado executar o aplicativo, nada além de não ser executado, o valor obtido possa ser usado como limite de memória do contêiner.  Para ser seguro, é recomendável aumentá-lo em pelo menos 10%. </li></ul><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  No Node.j 12.x, alguns dos problemas discutidos aqui são resolvidos ajustando adaptativamente o tamanho do heap, que é executado de acordo com a quantidade de RAM disponível.  Esse mecanismo também funciona ao executar aplicativos Node.js. em contêineres.  Mas as configurações podem diferir das configurações padrão.  Isso, por exemplo, acontece quando a chave <code>--max_old_space_size</code> foi usada ao iniciar o aplicativo.  Para esses casos, todos os itens acima permanecem relevantes.  Isso sugere que qualquer pessoa que execute aplicativos Node.js. em contêineres seja cuidadosa e responsável com as configurações de memória.  Além disso, o conhecimento dos limites padrão de uso de memória, que é bastante conservador, pode melhorar o desempenho do aplicativo alterando deliberadamente esses limites. <br><br>  <b>Caros leitores!</b>  Você ficou com problemas de memória ao executar aplicativos Node.js. nos contêineres do Docker? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454522/">https://habr.com/ru/post/pt454522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454512/index.html">Relatório do café da manhã com Charles Weatherly, autor do livro de culto Etudes for Programmers</a></li>
<li><a href="../pt454514/index.html">Desenvolvimento de um sintetizador de música simples no ATMEGA8</a></li>
<li><a href="../pt454516/index.html">Como obter um bom texto por 200 rublos</a></li>
<li><a href="../pt454518/index.html">Wasmer: a biblioteca Go mais rápida para executar o código do WebAssembly</a></li>
<li><a href="../pt454520/index.html">Diretrizes para escrever código JavaScript limpo</a></li>
<li><a href="../pt454524/index.html">Reparação de fita para a cabeça Samsung Level On Pro</a></li>
<li><a href="../pt454530/index.html">A DJI criou um octocóptero que pode fazer filmes</a></li>
<li><a href="../pt454532/index.html">Vou dizer uma palavra sobre a abordagem de engenharia</a></li>
<li><a href="../pt454534/index.html">Não científico sobre mônadas</a></li>
<li><a href="../pt454536/index.html">Amplificador para o clássico sensor de frequência cardíaca</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>