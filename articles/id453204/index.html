<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛰️ 😽 🐔 Kontainer, Layanan Mikro, dan Jerat Layanan 🌬️ ✊ 🕧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak artikel di jala layanan di Internet, dan ini artikel lain. Hore! Tapi mengapa? Lalu, apa yang ingin saya sampaikan pendapat saya adalah bah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kontainer, Layanan Mikro, dan Jerat Layanan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453204/"> Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di</a> jala layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di</a> Internet, dan ini artikel lain.  Hore!  Tapi mengapa?  Lalu, apa yang ingin saya sampaikan pendapat saya adalah bahwa akan lebih baik untuk memiliki jerat layanan muncul 10 tahun yang lalu, sebelum munculnya platform wadah seperti Docker dan Kubernetes.  Saya tidak mengklaim bahwa sudut pandang saya lebih baik atau lebih buruk daripada yang lain, tetapi karena jerat layanan adalah hewan yang cukup kompleks, banyaknya sudut pandang akan membantu untuk lebih memahami mereka. <br><br>  Saya akan berbicara tentang platform dotCloud, yang dibangun di lebih dari seratus layanan microser dan mendukung ribuan aplikasi dalam wadah.  Saya akan menjelaskan masalah yang kami temui selama pengembangan dan peluncurannya, dan bagaimana jerat layanan dapat membantu (atau tidak bisa). <br><a name="habracut"></a><br><h1>  Sejarah dotCloud </h1><br>  Saya sudah menulis tentang sejarah dotCloud dan pilihan arsitektur untuk platform ini, tetapi berbicara sedikit tentang tingkat jaringan.  Jika Anda tidak ingin membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> tentang dotCloud, berikut ringkasan singkatnya: ini adalah platform PaaS-as-a-service yang memungkinkan klien untuk meluncurkan berbagai aplikasi (Java, PHP, Python ...), dengan dukungan untuk berbagai layanan data (MongoDB, MySQL, Redis ...) dan alur kerja seperti Heroku: Anda mengunggah kode Anda ke platform, itu membangun gambar kontainer dan menyebarkannya. <br><br>  Saya akan memberi tahu Anda bagaimana lalu lintas diarahkan ke platform dotCloud.  Bukan karena itu sangat keren (walaupun sistem bekerja dengan baik pada masanya!), Tetapi terutama karena dengan bantuan alat modern, desain seperti itu dapat dengan mudah diimplementasikan dalam waktu singkat oleh tim sederhana jika mereka membutuhkan cara untuk mengarahkan lalu lintas antara sekelompok layanan mikro atau banyak aplikasi.  Dengan demikian, Anda dapat membandingkan opsi: apa yang terjadi jika Anda mengembangkan semuanya sendiri atau menggunakan layanan mesh yang ada.  Pilihan standar: lakukan sendiri atau beli. <br><br><h1>  Perutean lalu lintas untuk aplikasi yang dihosting </h1><br>  Aplikasi DotCloud dapat menyediakan HTTP dan titik akhir TCP. <br><br>  <b>Titik akhir HTTP</b> ditambahkan secara dinamis ke konfigurasi kluster penyeimbang beban <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hipache</a> .  Ini mirip dengan apa yang dilakukan sumber daya Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ingress</a> dan penyeimbang beban seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dilakukan Traefik saat ini</a> . <br><br>  Klien terhubung ke titik akhir HTTP melalui masing-masing domain, asalkan nama domain menunjuk ke dotCloud memuat penyeimbang.  Tidak ada yang istimewa. <br><br>  <b>Titik akhir TCP</b> dikaitkan dengan nomor port, yang kemudian diteruskan ke semua wadah tumpukan ini melalui variabel lingkungan. <br><br>  Klien dapat terhubung ke titik akhir TCP menggunakan nama host yang sesuai (sesuatu seperti gateway-X.dotcloud.com) dan nomor port. <br><br>  Nama host ini diselesaikan ke kluster server "nats" (tidak terkait dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NATS</a> ), yang akan merutekan koneksi TCP yang masuk ke wadah yang benar (atau, dalam hal layanan yang seimbang beban, ke wadah yang benar). <br><br>  Jika Anda terbiasa dengan Kubernetes, ini mungkin akan mengingatkan Anda pada layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NodePort</a> . <br><br>  Tidak ada yang setara dengan layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ClusterIP</a> pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">platform dotCloud</a> : untuk kesederhanaan, akses ke layanan itu sama baik dari dalam maupun luar platform. <br><br>  Semuanya diatur dengan cukup sederhana: implementasi awal jaringan HTTP dan TCP routing, mungkin hanya beberapa ratus baris Python.  Algoritma sederhana (saya akan mengatakan, naif) yang diselesaikan dengan pertumbuhan platform dan munculnya persyaratan tambahan. <br><br>  Refactoring ekstensif dari kode yang ada tidak diperlukan.  Secara khusus, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi 12 faktor</a> dapat langsung menggunakan alamat yang diperoleh melalui variabel lingkungan. <br><br><h1>  Apa bedanya dengan mesh layanan modern? </h1><br>  <b>Visibilitas</b> terbatas.  Kami umumnya tidak memiliki metrik untuk kisi perutean TCP.  Adapun perutean HTTP, versi yang lebih baru memiliki metrik HTTP terperinci dengan kode kesalahan dan waktu respons, tetapi jerat layanan modern bahkan melangkah lebih jauh, menyediakan integrasi dengan sistem pengumpulan metrik seperti Prometheus, misalnya. <br><br>  Visibilitas penting tidak hanya dari sudut pandang operasional (untuk membantu memecahkan masalah), tetapi juga ketika fitur baru dirilis.  Ini tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyebaran biru-hijau yang</a> aman dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyebaran kenari</a> . <br><br>  <b>Efisiensi perutean</b> juga terbatas.  Di grid routing dotCloud, semua lalu lintas harus melalui sekelompok node routing khusus.  Ini berarti potensi melintasi beberapa perbatasan AZ (zona aksesibilitas) dan peningkatan penundaan yang signifikan.  Saya ingat bagaimana saya memperbaiki masalah dengan kode yang membuat lebih dari seratus permintaan SQL per halaman dan untuk setiap permintaan membuka koneksi baru ke server SQL.  Ketika diluncurkan secara lokal, halaman dimuat secara instan, tetapi dalam dotCloud, memuat membutuhkan beberapa detik, karena dibutuhkan puluhan milidetik untuk setiap koneksi TCP (dan kueri SQL berikutnya).  Dalam kasus khusus ini, koneksi persisten memecahkan masalah. <br><br>  Sambungan layanan modern lebih baik dengan masalah seperti itu.  Pertama-tama, mereka memverifikasi bahwa koneksi diarahkan <i>pada sumbernya</i> .  Alur logisnya sama: <code> →  → </code> , tetapi sekarang mesh bekerja secara lokal dan bukan pada node yang jauh, sehingga koneksi <code> → </code> bersifat lokal dan sangat cepat (mikrodetik, bukan milidetik). <br><br>  Sambungan layanan modern juga menerapkan algoritma load balancing yang lebih cerdas.  Dengan mengontrol kinerja backend, mereka dapat mengirim lebih banyak lalu lintas ke backend yang lebih cepat, yang mengarah pada peningkatan kinerja secara keseluruhan. <br><br>  <b>Keamanan</b> juga lebih baik.  Grid routing dotCloud bekerja sepenuhnya pada EC2 Classic dan tidak mengenkripsi lalu lintas (dengan asumsi bahwa jika seseorang berhasil menempatkan sniffer pada lalu lintas jaringan EC2, Anda sudah memiliki masalah besar).  Sambungan layanan modern secara transparan melindungi semua lalu lintas kami, misalnya, dengan otentikasi TLS bersama dan enkripsi selanjutnya. <br><br><h1>  Routing Traffic untuk Layanan Platform </h1><br>  Oke, kami membahas lalu lintas antar aplikasi, tetapi bagaimana dengan platform dotCloud itu sendiri? <br><br>  Platform itu sendiri terdiri dari sekitar seratus layanan microser yang bertanggung jawab untuk berbagai fungsi.  Beberapa menerima permintaan dari yang lain, dan beberapa adalah pekerja latar belakang yang terhubung ke layanan lain tetapi tidak menerima koneksi.  Dalam setiap kasus, setiap layanan harus mengetahui titik akhir dari alamat yang ingin Anda sambungkan. <br><br>  Banyak layanan tingkat tinggi dapat menggunakan grid routing yang dijelaskan di atas.  Bahkan, banyak dari lebih dari ratusan microservices dotCloud telah digunakan sebagai aplikasi reguler pada platform dotCloud itu sendiri.  Tetapi sejumlah kecil layanan tingkat rendah (khususnya, yang menerapkan kisi-kisi perutean ini) membutuhkan sesuatu yang lebih sederhana, dengan lebih sedikit ketergantungan (karena mereka tidak dapat bergantung pada diri sendiri untuk bekerja - masalah ayam dan telur tua yang baik). <br><br>  Layanan tingkat rendah dan penting ini dikerahkan dengan menjalankan kontainer secara langsung pada beberapa node utama.  Pada saat yang sama, layanan platform standar tidak terlibat: penghubung, penjadwal, dan pelari.  Jika Anda ingin membandingkan dengan platform kontainer modern, itu seperti meluncurkan pesawat kontrol dengan <code>docker run</code> langsung di node, alih-alih mendelegasikan tugas Kubernetes.  Ini sangat mirip dengan konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul statis (perapian)</a> yang digunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubeadm</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bootkube</a> saat memuat cluster mandiri. <br><br>  Layanan ini diekspos dengan cara yang sederhana dan kasar: nama dan alamat mereka tercantum dalam file YAML;  dan setiap klien harus mengambil salinan file YAML ini untuk ditempatkan. <br><br>  Di satu sisi, ini sangat dapat diandalkan karena tidak memerlukan dukungan dari toko kunci / nilai eksternal seperti Zookeeper (jangan lupa, pada saat itu dlld atau Konsul belum ada).  Di sisi lain, ini membuatnya sulit untuk memindahkan layanan.  Setiap kali ketika bergerak, semua klien harus menerima file YAML yang diperbarui (dan berpotensi reboot).  Sangat tidak nyaman! <br><br>  Selanjutnya, kami mulai memperkenalkan skema baru, di mana setiap klien terhubung ke server proxy lokal.  Alih-alih alamat dan port, cukup baginya untuk hanya mengetahui nomor port layanan, dan terhubung melalui <code>localhost</code> .  Server proxy lokal memproses koneksi ini dan merutekannya ke server yang sebenarnya.  Sekarang, ketika memindahkan backend ke mesin lain atau scaling alih-alih memperbarui semua klien, Anda hanya perlu memperbarui semua proxy lokal ini;  dan reboot tidak lagi diperlukan. <br><br>  (Itu juga direncanakan untuk merangkum lalu lintas dalam koneksi TLS dan menempatkan server proxy lain di sisi penerima, serta memeriksa sertifikat TLS tanpa partisipasi dari layanan penerima, yang dikonfigurasi untuk menerima koneksi hanya di <code>localhost</code> . Lebih lanjut tentang ini nanti). <br><br>  Ini sangat mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SmartStack</a> Airbnb, tetapi perbedaan yang signifikan adalah bahwa SmartStack diimplementasikan dan digunakan dalam produksi, sementara sistem perutean internal dotCloud dimasukkan ke dalam kotak ketika dotCloud berubah menjadi Docker. <br><br>  Saya pribadi menganggap SmartStack sebagai salah satu pendahulu sistem seperti Istio, Linkerd dan Consul Connect, karena mereka semua mengikuti pola yang sama: <br><br><ul><li>  Menjalankan proxy pada setiap node. <br></li><li>  Klien terhubung ke proxy. <br></li><li>  Bidang manajemen memperbarui konfigurasi proksi ketika mengubah backend. <br></li><li>  ... Untung! </li></ul><br><h1>  Implementasi modern dari service mesh </h1><br>  Jika kita perlu menerapkan kisi yang sama hari ini, kita dapat menggunakan prinsip yang sama.  Misalnya, konfigurasikan zona DNS internal dengan memetakan nama layanan ke alamat di <code>127.0.0.0/8</code> .  Kemudian jalankan HAProxy pada setiap node cluster, menerima koneksi ke setiap alamat layanan ( <code>127.0.0.0/8</code> di subnet ini) dan mengarahkan / menyeimbangkan beban ke backends yang sesuai.  Konfigurasi HAProxy dapat dikontrol oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">confd</a> , memungkinkan Anda untuk menyimpan informasi backend di etcd atau Consul dan secara otomatis mendorong konfigurasi yang diperbarui ke HAProxy bila perlu. <br><br>  Beginilah cara Istio bekerja!  Tetapi dengan beberapa perbedaan: <br><br><ul><li>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proxy Utusan</a> bukan HAProxy. <br></li><li>  Menyimpan konfigurasi backend melalui API Kubernetes daripada etcd atau Consul. <br></li><li>  Layanan dialokasikan alamat pada subnet internal (alamat Kubernetes ClusterIP) bukan 127.0.0.0/8. <br></li><li>  Ini memiliki komponen opsional (Benteng) untuk menambahkan otentikasi TLS bersama antara klien dan server. <br></li><li>  Mendukung fitur-fitur baru seperti pemutusan sirkuit, pelacakan terdistribusi, penyebaran kenari, dll. </li></ul><br>  Mari kita lihat beberapa perbedaan. <br><br><h3>  Utusan proxy </h3><br>  Proxy Enftoy ditulis oleh Lyft.  trans.].  Ini sangat mirip dengan proksi lain dalam banyak hal (misalnya, HAProxy, Nginx, Traefik ...), tetapi Lyft menulis sendiri karena mereka memerlukan fungsi yang tidak ada di proksi lain, dan tampaknya lebih masuk akal untuk membuat yang baru daripada memperluas yang sudah ada. <br><br>  Utusan dapat digunakan sendiri.  Jika saya memiliki layanan khusus yang harus terhubung ke layanan lain, saya dapat mengkonfigurasinya untuk terhubung ke Utusan, dan kemudian secara dinamis mengkonfigurasi dan mengkonfigurasi ulang Utusan dengan lokasi layanan lain, sambil menerima banyak fitur tambahan yang sangat baik, misalnya, visibilitas.  Alih-alih perpustakaan klien khusus atau menanamkan pelacakan panggilan dalam kode, kami mengarahkan lalu lintas ke Utusan, dan mengumpulkan metrik untuk kami. <br><br>  Tetapi Utusan juga dapat bekerja sebagai pesawat data untuk layanan mesh.  Ini berarti bahwa untuk layanan mesh ini, Utusan sekarang dikonfigurasi <i>oleh bidang</i> kontrol. <br><br><h3>  Kontrol pesawat </h3><br>  Dalam bidang manajemen, Istio mengandalkan API Kubernetes.  <i>Ini tidak jauh berbeda dari menggunakan confd</i> , yang bergantung pada etcd atau Consul untuk melihat sekumpulan kunci dalam data warehouse.  Istio, melalui API Kubernetes, melihat kumpulan sumber daya Kubernetes. <br><br>  <i>Antara kasus</i> : Saya pribadi menemukan <a href="">deskripsi API Kubernetes</a> ini <a href="">berguna</a> , yang berbunyi: <br><br><blockquote>  Server API Kubernetes adalah "server bisu" yang menawarkan penyimpanan, versi, validasi, pembaruan, dan semantik sumber daya API. </blockquote><br>  Istio dirancang untuk bekerja dengan Kubernetes;  dan jika Anda ingin menggunakannya di luar Kubernetes, maka Anda perlu menjalankan sebuah instance dari server API Kubernetes (dan layanan tambahan dlld). <br><br><h3>  Alamat Layanan </h3><br>  Istio mengandalkan alamat ClusterIP yang dialokasikan Kubernetes, sehingga layanan Istio mendapatkan alamat internal (tidak dalam kisaran <code>127.0.0.0/8</code> ). <br><br>  Lalu lintas ke alamat ClusterIP untuk layanan tertentu di kluster Kubernetes tanpa Istio dicegat oleh kube-proxy dan dikirim ke bagian server dari proxy ini.  Jika Anda tertarik pada detail teknis, maka kube-proxy menetapkan aturan iptables (atau penyeimbang beban IPVS, bergantung pada cara Anda mengonfigurasinya) untuk menulis ulang alamat IP tujuan dari koneksi yang menuju ke alamat ClusterIP. <br><br>  Setelah menginstal Istio di kluster Kubernetes, tidak ada yang berubah sampai secara eksplisit dihidupkan untuk konsumen yang diberikan atau bahkan seluruh namespace dengan memperkenalkan wadah <code>sidecar</code> ke perapian kustom.  Kontainer ini akan memulai instance dari Utusan dan menetapkan serangkaian aturan iptables untuk mencegat lalu lintas ke layanan lain dan mengarahkan lalu lintas itu ke Utusan. <br><br>  Ketika terintegrasi dengan Kubernetes DNS, ini berarti bahwa kode kami dapat terhubung dengan nama layanan, dan semuanya "hanya berfungsi."  Dengan kata lain, kode kami mengeluarkan permintaan seperti <code>http://api/v1/users/4242</code> , lalu <code>api</code> menyelesaikan permintaan ke <code>10.97.105.48</code> , aturan iptables mencegat koneksi dari 10.97.105.48 dan mengarahkan mereka ke proxy Utusan lokal, dan proksi lokal ini akan mengarahkan meminta API backend yang sebenarnya.  Fuh! <br><br><h3>  Benda kecil ekstra </h3><br>  Istio juga menyediakan enkripsi dan otentikasi ujung-ke-ujung melalui mTLS (mutual TLS).  Komponen yang disebut <i>Citadel</i> bertanggung jawab untuk ini. <br><br>  Ada juga komponen <i>Mixer</i> yang Utusan dapat meminta untuk <i>setiap</i> permintaan untuk membuat keputusan khusus tentang permintaan ini, tergantung pada berbagai faktor, seperti header, backend loading, dll ... (jangan khawatir: ada banyak cara untuk memastikan bahwa Mixer bekerja, dan bahkan jika crash, Utusan akan terus bekerja secara normal sebagai proxy). <br><br>  Dan, tentu saja, kami menyebutkan visibilitas: Utusan mengumpulkan sejumlah besar metrik, sambil menyediakan penelusuran terdistribusi.  Dalam arsitektur layanan microser, jika satu permintaan API harus melalui layanan microser A, B, C, dan D, maka ketika Anda masuk ke sistem, jejak yang didistribusikan akan menambahkan pengidentifikasi unik ke permintaan dan menyimpan pengidentifikasi ini melalui subqueries ke semua layanan Microsoft ini, memungkinkan Anda untuk merekam semua panggilan terkait, mereka keterlambatan dll. <br><br><h1>  Kembangkan atau beli </h1><br>  Istio memiliki reputasi sebagai sistem yang kompleks.  Sebaliknya, membangun kisi perutean, yang saya jelaskan di awal tulisan ini, relatif sederhana menggunakan alat yang ada.  Jadi, apakah masuk akal untuk membuat jala layanan Anda sendiri? <br><br>  Jika kami memiliki kebutuhan sederhana (Anda tidak perlu visibilitas, pemutus sirkuit, dan kehalusan lainnya), maka muncul pemikiran untuk mengembangkan alat Anda sendiri.  Tetapi jika kita menggunakan Kubernetes, itu mungkin bahkan tidak perlu, karena Kubernetes sudah menyediakan alat dasar untuk penemuan layanan dan penyeimbangan muatan. <br><br>  Tetapi jika kita memiliki persyaratan tingkat lanjut, maka “membeli” layanan tampaknya menjadi pilihan yang jauh lebih baik.  (Ini tidak selalu merupakan “pembelian”, karena Istio datang dengan kode sumber terbuka, tetapi kita masih perlu menginvestasikan waktu teknik untuk memahami pekerjaannya, untuk menggunakan dan mengelolanya). <br><br><h1>  Apa yang harus dipilih: Istio, Linkerd atau Consul Connect? </h1><br>  Sejauh ini kami hanya berbicara tentang Istio, tetapi ini bukan satu-satunya service mesh.  Alternatif yang populer adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Linkerd</a> , dan ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Consul Connect</a> . <br><br>  Apa yang harus dipilih? <br><br>  Sejujurnya, saya tidak tahu.  Saat ini, saya tidak menganggap diri saya cukup kompeten untuk menjawab pertanyaan ini.  Ada beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menarik yang</a> membandingkan alat-alat ini dan bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tolok ukur</a> . <br><br>  Salah satu pendekatan yang menjanjikan adalah dengan menggunakan alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SuperGloo</a> .  Ini mengimplementasikan lapisan abstraksi untuk menyederhanakan dan menyatukan API yang disediakan oleh layanan mesh.  Alih-alih mempelajari API spesifik (dan, menurut saya, relatif kompleks) dari berbagai layanan, kita dapat menggunakan konstruksi SuperGloo yang lebih sederhana - dan dengan mudah beralih dari satu ke yang lain, seolah-olah kita memiliki format konfigurasi menengah yang menggambarkan antarmuka HTTP dan backends mampu menghasilkan konfigurasi aktual untuk Nginx, HAProxy, Traefik, Apache ... <br><br>  Saya sedikit memanjakan diri dengan Istio dan SuperGloo, dan di artikel berikutnya saya ingin menunjukkan bagaimana cara menambahkan Istio atau Linkerd ke cluster yang ada menggunakan SuperGloo, dan seberapa banyak yang terakhir akan mengatasi pekerjaannya, yaitu, memungkinkan Anda untuk beralih dari satu service mesh ke yang lain tanpa menulis ulang konfigurasi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453204/">https://habr.com/ru/post/id453204/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453190/index.html">ANPR menggunakan RoR & React Native</a></li>
<li><a href="../id453192/index.html">Sinkronisasi dan asinkron proses</a></li>
<li><a href="../id453194/index.html">Kami memecahkan masalah Reverser Terbaik dengan PHDays 9</a></li>
<li><a href="../id453196/index.html">Forrester Research: Perbandingan Sepuluh Vendor Analisis Komposisi Perangkat Lunak Teratas</a></li>
<li><a href="../id453200/index.html">Diskusi: proyek OpenROAD bermaksud untuk menyelesaikan tugas mengotomatisasi desain prosesor</a></li>
<li><a href="../id453206/index.html">Wawancara dengan Kelsey Moody: Cara Membangun Perusahaan dan Patologi Terkait Usia Akhir</a></li>
<li><a href="../id453212/index.html">Consumer Reports: Autopilot terbaru Tesla masih jauh dari sempurna</a></li>
<li><a href="../id453214/index.html">Bagaimana dan mengapa tetap fit jika Anda adalah orang IT di situs jarak jauh</a></li>
<li><a href="../id453216/index.html">Sistem pemantauan lalu lintas di jaringan VoIP. Bagian Dua - Prinsip Organisasi</a></li>
<li><a href="../id453218/index.html">Hal utama dengan YaC 2019: seratus drone di jalan, Yandex.Module, makanan, rumah pintar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>