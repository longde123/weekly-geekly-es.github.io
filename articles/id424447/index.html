<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋 🧖🏿 👩🏼‍🚀 Lisp dibumbui dengan Pascal atau bahasa pemrograman 8501 👲 😆 🔇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa waktu yang lalu (sekitar tiga tahun) saya memutuskan untuk membaca buku teks tentang Lisp. Tanpa tujuan khusus, hanya demi perkembangan umum ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lisp dibumbui dengan Pascal atau bahasa pemrograman 8501</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424447/">  Beberapa waktu yang lalu (sekitar tiga tahun) saya memutuskan untuk membaca buku teks tentang Lisp.  Tanpa tujuan khusus, hanya demi perkembangan umum dan kemampuan untuk mengejutkan lawan bicara dengan eksotis (begitu tampaknya, itu bahkan berhasil). <br><br>  Tetapi setelah diperiksa lebih dekat, Lisp ternyata sangat kuat, fleksibel dan, anehnya, berguna dalam kehidupan sehari-hari.  Semua tugas otomatisasi kecil dengan cepat dimigrasikan ke skrip di Lisp, dan ada juga peluang untuk otomatisasi yang lebih kompleks. <br><br>  Perlu dicatat di sini bahwa dengan "kemampuan otomatisasi" yang saya maksudkan adalah situasi di mana total waktu untuk menulis dan men-debug suatu program kurang dari waktu yang dihabiskan secara manual untuk menyelesaikan tugas yang sama. <br><br>  Paul Graham telah menulis lebih dari satu artikel dan bahkan sebuah buku tentang manfaat Lisp.  Pada saat penulisan ini, Lisp berada di peringkat ke-33 di peringkat TOIBE (Delphi tiga kali mati daripada mati).  Muncul pertanyaan: mengapa bahasanya sangat kecil jika nyaman?  Sekitar dua tahun penggunaan memberi beberapa petunjuk alasannya. <br><a name="habracut"></a><br><h3>  Kekurangan </h3><br>  <i>1. Struktur data bersama</i> <br>  Sebuah konsep yang memungkinkan Anda untuk mengoptimalkan program-program fungsional, tetapi penuh dengan kesalahan-kesalahan halus secara imperatif.  Kemungkinan kerusakan yang tidak disengaja pada struktur data asing ketika suatu variabel dimodifikasi yang tidak memiliki koneksi yang terlihat dengan struktur mengharuskan programmer untuk terus memantau apa yang terjadi di belakang layar dan untuk mengetahui implementasi internal dari setiap fungsi yang digunakan (baik sistem dan pengguna).  Hal yang paling menakjubkan adalah kemampuan untuk merusak tubuh dari suatu fungsi dengan memodifikasi nilai baliknya. <br><br>  <i>2. Kurangnya enkapsulasi</i> <br>  Meskipun konsep paket ada, itu tidak ada hubungannya dengan <b>paket</b> di Ada atau <b>unit</b> di Delphi.  Kode apa pun dapat menambahkan apa pun ke paket apa pun (kecuali yang sistem).  Kode apa pun dapat mengekstraksi apa pun dari paket apa pun menggunakan operator <b>::</b> . <br><br>  <i>3. Singkatan serampangan</i> <br>  Apa perbedaan antara MAPCAN dan MAPCON?  Mengapa di SETQ, huruf terakhir Q?  Mengingat usia bahasanya, Anda dapat memahami alasan dari keadaan ini, tetapi saya ingin sedikit bahasa yang lebih bersih. <br><br>  <i>4. Multithreading</i> <br>  Kelemahan ini secara tidak langsung terkait dengan Lisp dan terutama menyangkut implementasi yang saya gunakan - SteelBank Common Lisp.  Lisp umum tidak mendukung multithreading.  Upaya untuk menggunakan implementasi yang disediakan oleh SBCL gagal. <br><br>  Sangat disayangkan untuk menolak alat yang nyaman seperti itu, tetapi ketidakpuasan secara bertahap menumpuk. <br><br><h3>  Cari solusinya </h3><br>  Pertama, Anda bisa pergi ke Wikipedia pada halaman Lisp.  Periksa bagian "Dialek".  Baca pengantar singkat untuk masing-masing.  Dan sadari bahwa rasa dan warna semua marker berbeda. <br><blockquote>  Jika Anda ingin melakukan sesuatu, Anda harus melakukannya sendiri <br>  - Jean Baptiste Emmanuel Sorg </blockquote>  Mari kita coba membuat Lisp kita sendiri dengan menambahkan Ada, banyak Delphi dan setetes Oberon ke sana.  Kami menyebutnya campuran yang dihasilkan Fox. <br><br><h3>  Konsep dasar </h3><br>  <i>1. Tidak ada petunjuk</i> <br>  Dalam perang melawan MASALAH-1, semua operasi harus dilakukan dengan menyalin nilai-nilai.  Berdasarkan jenis struktur data dalam kode atau saat mencetak, semua propertinya, koneksi eksternal dan internal harus sepenuhnya terlihat. <br><br>  <i>2. Tambahkan modul</i> <br>  Sebagai bagian dari perjuangan melawan masalah-2, kami mengimpor <b>paket</b> , <b>dengan</b> dan <b>menggunakan</b> pernyataan dari Ada.  Dalam prosesnya, kami membuang skema impor / bayangan yang terlalu rumit untuk simbol Lisp. <br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">package</span></span> - (  ) () ())</code> </pre> <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">with</span></span> -) <span class="hljs-comment"><span class="hljs-comment">;  «-.lisya»   </span></span></code> </pre> <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">use</span></span> -) <span class="hljs-comment"><span class="hljs-comment">;,      </span></span></code> </pre> <br><br>  <i>3. Kurang singkatan</i> <br>  Karakter yang paling umum dan umum masih akan disingkat, tetapi sebagian besar yang paling jelas: <b>const</b> , <b>var</b> .  Fungsi output yang diformat - FMT membutuhkan reduksi, karena sering ditemukan di dalam ekspresi.  <b>Elt</b> - mengambil elemen - bocor dari Common Lisp dan mengambil root, meskipun tidak perlu menguranginya. <br><br>  <i>4. pengidentifikasi kasus-sensitif</i> <br>  Saya percaya bahwa bahasa (dan sistem file) yang benar {$ HOLYWAR +} harus case-insensitive {$ HOLYWAR-} agar tidak memutar otaknya sekali lagi. <br><br>  <i>5. Kemudahan penggunaan dengan tata letak keyboard Rusia</i> <br>  Sintaksis Lisi dengan segala cara yang mungkin menghindari penggunaan karakter yang tidak tersedia di salah satu tata letak.  Tidak ada kawat gigi bujur sangkar atau keriting.  Tidak #, ~, &amp;, &lt;,&gt;, |.  Saat membaca literal angka, koma dan titik dianggap sebagai pemisah desimal. <br><br>  <i>6. Alfabet yang diperluas</i> <br>  Salah satu hal baik tentang SBCL adalah kode UTF-8.  Kemampuan untuk mendeklarasikan konstanta BEAR, VODKA dan BALALAYKA sangat menyederhanakan penulisan kode aplikasi.  Kemampuan untuk memasukkan Ω, Ψ, dan Σ membuat rumus dalam kode lebih visual.  Meskipun secara teori ada kemungkinan menggunakan karakter Unicode, sulit untuk menjamin kebenaran bekerja dengan mereka (agak malas daripada sulit).  Kami membatasi diri pada bahasa Sirilik, Latin, dan Yunani. <br><br>  <i>7. Numerik literal</i> <br>  Ini adalah ekstensi bahasa yang paling berguna bagi saya. <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">10</span></span>_000 <span class="hljs-comment"><span class="hljs-comment">;    10k ;       10 ;       10° 10pi 10deg 10 ;   10π ; pi     10+i10 ;   10+10 ;    1010deg ;         </span></span></code> </pre> <br>  Pilihan yang terakhir bagi saya tampaknya yang paling tidak estetika, tetapi itu yang paling populer. <br><br>  <i>8. Siklus</i> <br>  Siklus di Lisp adalah non-standar dan sangat berantakan.  Sederhanakan ke set standar minimum. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">for</span></span> i <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">;   i = 0..4 ) (for i 1..6 ;   i = 1..5 ) (for i  ;     ;      ) (for i (subseq  2) ;           )</span></span></code> </pre> <br>  Variabel loop tidak terlihat di luar. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">while</span></span>  )</code> </pre> <br>  <i>9. GOTO</i> <br>  Bukan operator yang sangat diperlukan, tetapi tanpanya sulit untuk menunjukkan pengabaian aturan pemrograman struktural. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">block</span></span> : (<span class="hljs-name"><span class="hljs-name">goto</span></span> :)) <span class="hljs-comment"><span class="hljs-comment">;    </span></span></code> </pre> <br>  <i>10. Penyatuan ruang lingkup</i> <br>  Ada dua jenis ruang lingkup di Lisp: TOPLEVEL dan lokal.  Dengan demikian, ada dua cara berbeda untuk mendeklarasikan variabel. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defvar</span></span> A <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) …)</code> </pre> <br>  Di Fox hanya ada satu metode yang digunakan baik di tingkat atas skrip dan di area lokal, termasuk paket. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">var</span></span> A <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Jika Anda ingin membatasi ruang lingkup, gunakan operator <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">block</span></span> (<span class="hljs-name"><span class="hljs-name">var</span></span> A <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">set</span></span> A <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">fmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> A))</code> </pre> <br>  Tubuh loop terkandung dalam pernyataan BLOCK implisit (seperti tubuh fungsi / prosedur).  Semua variabel yang dideklarasikan dalam loop dihancurkan pada akhir iterasi. <br><br>  <i>11. Karakter slot tunggal</i> <br>  Dalam Lisp, fungsi adalah objek khusus dan disimpan dalam slot simbol khusus.  Satu karakter dapat secara bersamaan menyimpan variabel, fungsi, dan daftar properti.  Dalam rubah, setiap karakter dikaitkan hanya dengan satu makna. <br><br>  <i>12. ELT yang nyaman</i> <br>  Akses khas ke elemen struktur kompleks di Lisp terlihat seperti ini <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">elt</span></span> (<span class="hljs-name"><span class="hljs-name">slot-value</span></span> (<span class="hljs-name"><span class="hljs-name">elt</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span>) '<span class="hljs-number"><span class="hljs-number">-2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Fox mengimplementasikan operator ELT terpadu yang menyediakan akses ke elemen tipe komposit apa pun (daftar, string, catatan, array byte, tabel hash). <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">elt</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> \<span class="hljs-number"><span class="hljs-number">-2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Fungsi identik juga dapat diperoleh dengan makro di Lisp <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> field (<span class="hljs-name"><span class="hljs-name">object</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;rest</span></span> f) <span class="hljs-string"><span class="hljs-string">"       . (field *object* 0 :keyword symbol \"string\")       .        plist.   ( )    .        ."</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> f (<span class="hljs-name"><span class="hljs-name">symbol-macrolet</span></span> ((<span class="hljs-name"><span class="hljs-name">f0</span></span> (<span class="hljs-name"><span class="hljs-name">elt</span></span> f <span class="hljs-number"><span class="hljs-number">0</span></span>))(<span class="hljs-name"><span class="hljs-name">rest</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> f <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">numberp</span></span> f0) `(field (elt ,object ,f0) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">keywordp</span></span> f0) `(field (getf ,object ,f0) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">stringp</span></span> f0) `(field (cdr (assoc ,f0 ,object :test 'equal)) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">listp</span></span> f0) (<span class="hljs-name"><span class="hljs-name">=</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-name"><span class="hljs-name">length</span></span> f0))) `(field (,(car f0) ,(cadr f0) ,object) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">symbolp</span></span> f0) `(field (,f0 ,object) ,@rest)) (<span class="hljs-name"><span class="hljs-name">t</span></span> `(error <span class="hljs-string"><span class="hljs-string">"   "</span></span>)))) object))</code> </pre> <br>  <i>13. Pembatasan mode transfer parameter subrutin</i> <br>  Setidaknya ada lima mode transfer parameter di Lisp: wajib, <i>&amp; opsional</i> , <i>&amp; sisanya</i> , <i>&amp; kunci</i> , <i>&amp; keseluruhan</i> dan kombinasi sewenang-wenang mereka diizinkan.  Bahkan, sebagian besar kombinasi memberikan efek aneh. <br>  Di Fox, hanya diperbolehkan menggunakan kombinasi parameter yang diperlukan dan salah satu mode berikut untuk dipilih <i>: kunci</i> <i>,: opsional ,:</i> <i>bendera</i> <i>,:</i> <i>istirahat</i> . <br><br>  <i>14. Multithreading</i> <br>  Untuk menyederhanakan penulisan program multithreaded sepenuhnya, konsep pemisahan memori diadopsi.  Ketika sebuah utas muncul, semua variabel yang tersedia untuk utas baru disalin.  Semua referensi untuk variabel-variabel ini digantikan oleh referensi untuk salinan.  Transfer informasi antar aliran hanya dimungkinkan melalui objek yang dilindungi atau melalui hasil yang dikembalikan oleh aliran setelah selesai. <br><br>  Benda-benda yang dilindungi selalu mengandung bagian-bagian penting untuk memastikan operasi atom.  Masuk ke bagian kritis adalah otomatis - tidak ada operator terpisah untuk ini dalam bahasa.  Objek yang dilindungi meliputi: antrian pesan, konsol, dan deskriptor file. <br><br>  Membuat utas dimungkinkan dengan fungsi tampilan multi-utas <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">map-th</span></span> (<span class="hljs-name"><span class="hljs-name">function</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) …) --)</code> </pre> <br>  Map-th secara otomatis memulai jumlah utas sama dengan jumlah prosesor dalam sistem (atau dua kali lebih banyak jika Anda memiliki Intel di dalam).  Dalam panggilan rekursif, panggilan peta-th berikutnya bekerja dalam satu utas. <br><br>  Selain itu, ada fungsi utas bawaan yang menjalankan prosedur / fungsi pada utas terpisah. <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;   (var  (thread --1)) (+ (--2) (wait ))</span></span></code> </pre> <br>  <i>15. Kebersihan fungsional dalam kode imperatif</i> <br>  Fox memiliki fungsi untuk pemrograman fungsional dan prosedur prosedural.  Rutinitas yang dinyatakan menggunakan kata kunci fungsi tunduk pada persyaratan tidak adanya efek samping dan independensi hasil dari faktor eksternal. <br><br><h3>  Belum direalisasi </h3><br>  Beberapa fitur menarik dari Lisp tetap tidak terpenuhi karena prioritas rendah. <br><br>  <i>1. Metode umum</i> <br>  Kemampuan untuk membebani fungsi dengan defgeneric / defmethod. <br><br>  <i>2. Warisan</i> <br><br>  <i>3. debugger bawaan</i> <br>  Ketika pengecualian terjadi, interpreter Lisp beralih ke mode debug. <br><br>  <i>4. UFFI</i> <br>  Antarmuka untuk menghubungkan modul yang ditulis dalam bahasa lain. <br><br>  <i>5. BIGNUM</i> <br>  Dukungan kedalaman bit sewenang-wenang <br><br>  <b>Dibuang</b> <br><br>  Beberapa fitur Lisp telah dianggap dan dianggap tidak berguna / berbahaya. <br><br>  <i>1. Kombinasi metode yang dipandu</i> <br>  Ketika suatu metode dipanggil untuk suatu kelas, kombinasi dari metode induk dilakukan dan dimungkinkan untuk mengubah aturan kombinasi.  Perilaku akhir dari metode ini tampaknya tidak dapat diprediksi. <br><br>  <i>2. Mulai ulang</i> <br>  Penangan pengecualian dapat membuat perubahan pada status program dan mengirim perintah restart ke kode yang menghasilkan pengecualian.  Efek dari aplikasi ini mirip dengan menggunakan operator GOTO untuk beralih dari fungsi ke fungsi. <br><br>  <i>3. Kisah Romawi</i> <br>  Lisp mendukung sistem angka, yang sudah ketinggalan zaman sebelum kemunculannya. <br><br><h3>  Gunakan </h3><br>  Berikut adalah beberapa contoh kode sederhana. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">function</span></span> crc8 (<span class="hljs-name"><span class="hljs-name">data</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:optional</span></span> seed) (<span class="hljs-name"><span class="hljs-name">var</span></span> result (<span class="hljs-name"><span class="hljs-name">if-nil</span></span> seed <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">var</span></span> s_data data) (<span class="hljs-name"><span class="hljs-name">for</span></span> bit <span class="hljs-number"><span class="hljs-number">8</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">bit-and</span></span> (<span class="hljs-name"><span class="hljs-name">bit-xor</span></span> result s_data) $<span class="hljs-number"><span class="hljs-number">01</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">shift</span></span> result <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>)) (<span class="hljs-name"><span class="hljs-name">else</span></span> (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">bit-xor</span></span> result $<span class="hljs-number"><span class="hljs-number">18</span></span>)) (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">shift</span></span> result <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>)) (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">bit-or</span></span> result $<span class="hljs-number"><span class="hljs-number">80</span></span>)))) (<span class="hljs-name"><span class="hljs-name">set</span></span> s_data (<span class="hljs-name"><span class="hljs-name">shift</span></span> s_data <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>))) result)</code> </pre> <br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;     (map (function (x) (** x 2)) \(1 2 3))</span></span></code> </pre> <br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;   ,   qwe      (filter (function (x) (regexp:match x «^qwe...»)) -) ;   ,   ,    (filter-th (function (x) (regexp:match x «^qwe...»)) -)</span></span></code> </pre> <br><h3>  Implementasi </h3><br>  Penerjemah ditulis dalam Delphi (FreePascal dalam mode kompatibilitas).  Itu dibangun di Lazarus 1.6.2 dan lebih tinggi, di bawah Windows dan Linux 32 dan 64 bit.  Dari dependensi eksternal, memerlukan libmysql.dll.  Berisi sekitar 15_2000..20_000 baris.  Ada sekitar 200 fungsi bawaan untuk berbagai keperluan (beberapa kelebihan beban delapan kali). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Disimpan di sini</a> <br><br>  Dukungan untuk pengetikan dinamis dilakukan dengan cara sepele - semua tipe data yang diproses diwakili oleh ahli waris dari kelas TValue yang sama. <br><br>  Jenis yang paling penting untuk Lisp - daftarnya adalah, seperti kebiasaan di Delphi, kelas yang berisi array dinamis objek tipe TValue.  Untuk jenis ini, mekanisme CopyOnWrite diimplementasikan. <br><br>  Manajemen memori otomatis berdasarkan penghitungan referensi.  Untuk struktur rekursif, semua tautan dalam struktur dihitung secara bersamaan.  Pelepasan memori dimulai segera ketika variabel keluar dari lingkup.  Tidak ada mekanisme untuk menunda awal pengumpul sampah. <br><br>  Penanganan pengecualian bekerja pada mekanisme yang dibangun ke dalam Delphi.  Dengan demikian, kesalahan yang terjadi pada kode interpreter dapat diproses oleh kode yang dapat dieksekusi pada Fox. <br><br>  Setiap operator atau fungsi Lisi bawaan diimplementasikan sebagai metode atau fungsi dalam kode juru bahasa.  Script dieksekusi oleh panggilan implementasi yang saling rekursif.  Kode juru bahasa dan skrip memiliki tumpukan panggilan umum. <br><br>  Variabel skrip disimpan dalam memori dinamis secara independen.  Setiap fungsi yang ditentukan pengguna memiliki tumpukan sendiri untuk menyimpan referensi variabel, terlepas dari tumpukan tingkat atas atau tumpukan fungsi induk. <br><br>  Kesulitan khusus adalah implementasi operator penugasan (set) untuk elemen struktural.  Menghitung langsung pointer ke elemen yang diperlukan mengarah pada risiko menggantung tautan, karena sintaksis Lisi tidak melarang memodifikasi struktur selama perhitungan elemen yang diperlukan.  Sebagai solusi kompromi, "penunjuk rantai" diimplementasikan - objek yang berisi referensi ke variabel dan array indeks numerik untuk menunjukkan jalur di dalam struktur.  Pointer seperti itu juga rentan terhadap masalah tautan yang menggantung, tetapi jika terjadi kegagalan, ia menghasilkan pesan kesalahan yang bermakna. <br><br><h3>  Alat pengembangan </h3><br>  <i>1. Konsol</i> <br><br>  <i>2. Editor teks</i> <br>  Dilengkapi dengan penyorotan sintaks dan kemampuan untuk menjalankan skrip yang dapat diedit di F9. <br><img src="https://habrastorage.org/webt/1c/q9/yo/1cq9yo4edbezhjgav_mjby393rs.png"><br><br><h3>  Kesimpulan </h3><br>  Dalam kondisi saat ini, proyek menyelesaikan masalah yang dikandungnya, dan tidak memerlukan pengembangan aktif lebih lanjut.  Banyak ketidaksempurnaan yang ada tidak mempengaruhi pekerjaan secara signifikan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424447/">https://habr.com/ru/post/id424447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424435/index.html">Kebun binatang pengeboran minyak: menertibkan</a></li>
<li><a href="../id424437/index.html">Elm Nyaman dan canggung. Json.Encoder dan Json.Decoder</a></li>
<li><a href="../id424441/index.html">Apa yang Baru di CTP Pertama SQL Server 2019</a></li>
<li><a href="../id424443/index.html">Vivaldi 2.0 mendukung kami</a></li>
<li><a href="../id424445/index.html">Neil Ford menerjemahkan Microservices sebagai Arsitektur Evolusi</a></li>
<li><a href="../id424453/index.html">Pelajari OpenGL. Pelajaran 6.2 - Rendering Berbasis Fisik. Sumber Cahaya Analitik</a></li>
<li><a href="../id424455/index.html">Intel Optane - Sekarang 1,5 Terabytes</a></li>
<li><a href="../id424457/index.html">Meningkatkan IDA Pro. Belajar menulis bootloader dengan Python</a></li>
<li><a href="../id424459/index.html">Kisah Sukses, atau DEV + DEVOPS + OPS</a></li>
<li><a href="../id424461/index.html">Mengapa belajar bahasa yang tidak populer. Contoh Komunitas F #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>