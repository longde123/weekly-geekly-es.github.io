<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùì ü§∞üèª üôçüèø Param√©trage incertain comme m√©thode universelle pour construire l'architecture d'application en C ++ et Java pour un minimum. le prix üëÜüèº ‚è™ ‚õ∏Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ est un langage d√©routant, et son principal inconv√©nient est la difficult√© de cr√©er des blocs de code isol√©s. Dans un projet typique, tout d√©pend ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Param√©trage incertain comme m√©thode universelle pour construire l'architecture d'application en C ++ et Java pour un minimum. le prix</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475268/">  C ++ est un langage d√©routant, et son principal inconv√©nient est la difficult√© de cr√©er des blocs de code isol√©s.  Dans un projet typique, tout d√©pend de tout.  Cet article montre comment √©crire du code hautement isol√© qui d√©pend au minimum de biblioth√®ques sp√©cifiques (y compris standard), d'impl√©mentations, r√©duisant la d√©pendance de tout morceau de code √† un ensemble d'interfaces.  De plus, des solutions architecturales pour le param√©trage du code seront propos√©es, qui pourraient int√©resser non seulement les programmeurs C ++, mais aussi les programmeurs Java.  Et ce qui est important, la solution propos√©e est tr√®s √©conomique en termes de temps de d√©veloppement. <br><a name="habracut"></a><br>  <i><b>Avertissement</b></i> : Dans cet article, j'ai rassembl√© mes id√©es sur l'architecture id√©ale.  Certaines id√©es ne sont pas les miennes (mais je ne me souviens pas √† qui), certaines id√©es sont courantes et connues de tous - ce n'est pas important, car je n'offre pas mes id√©es sur une bonne architecture, mais un code sp√©cifique qui permettra d'approcher cette architecture √† un prix minimum. <br><br>  <i><b>Clause de non-responsabilit√© N2</b></i> : Je serai heureux des commentaires constructifs exprim√©s en mots.  Si vous comprenez pire que moi et que vous me grondez, cela signifie que quelque part je n'ai pas suffisamment expliqu√©, et il est logique de retravailler le texte.  Si vous comprenez mieux que moi, cela signifie que je vais acqu√©rir une exp√©rience pr√©cieuse.  Merci d'avance. <br><br>  <i><b>Avertissement N3</b></i> : J'ai √©crit de grandes applications √† partir de z√©ro, mais je n'ai pas √©crit d'applications d'entreprise serveur et client.  Tout y est diff√©rent et, probablement, mon exp√©rience semblera √©trange aux sp√©cialistes de ce domaine.  Et l'article ne traite pas de cela, les m√™mes probl√®mes d'√©volutivit√© ne sont pas du tout pris en compte ici. <br>  <i><b>Clause de non-responsabilit√© N4</b></i> (mise √† jour bas√©e sur les commentaires): Certains commentateurs ont sugg√©r√© que je r√©invente Fowler et propose des mod√®les de conception connus depuis longtemps.  Ce n'est certainement pas le cas.  Je propose un tout petit outil de param√©trage qui vous permet d'impl√©menter ces patterns avec un minimum de gribouillis.  Y compris l'injection de d√©pendances et le localisateur de services de Fowler, mais pas seulement - en utilisant la classe TypedSet, vous pouvez √©galement impl√©menter un ensemble de strat√©gies de mani√®re √©conomique.  Dans ce cas, Fowler a acc√©d√© via des lignes, ce qui est cher - mon outil √† co√ªt nul, √† co√ªt nul (si absolument strictement, alors log (N) au lieu de 2M * log (N), o√π M est la longueur de la cha√Æne de param√®tres pour le localisateur de service. apr√®s l'apparition de constexpr typeid en c ++ 20, le prix devrait devenir compl√®tement nul).  Par cons√©quent, je vous demande de ne pas √©tendre la signification de l'article aux mod√®les de conception.  Ici, vous ne trouverez qu'une <b><i>m√©thode pour la</i></b> mise en ≈ìuvre bon march√© de ces mod√®les. <br><br>  Les exemples seront en C ++, mais tout ce qui pr√©c√®de est assez impl√©mentable en Java.  Peut-√™tre, au fil du temps, je donnerai du code de travail pour Java si la demande en est dans les commentaires de votre part. <br><br><h2>  Partie 1. Architecture sph√©rique dans le vide </h2><br>  Avant de r√©soudre brillamment toutes les difficult√©s, vous devez les cr√©er correctement.  Cr√©er magistralement des difficult√©s pour vous-m√™me au bon endroit, vous pouvez grandement faciliter leur solution.  Pour cela, nous formulons un objectif pour la solution duquel nous proposerons des m√©thodes - les principes minimaux d'une bonne architecture. <br><br>  En fait, la magie d'une bonne architecture n'est que deux principes, et ce qui est √©crit ci-dessous n'est qu'un d√©codage.  Le premier principe est la testabilit√© du code.  La testabilit√© est comme le fil d'Ariane qui vous m√®ne √† une bonne architecture.  Si vous ne savez pas comment √©crire un test de fonctionnalit√©, vous avez ruin√© l'architecture.  Si vous ne savez pas comment cr√©er une bonne architecture, pensez √† ce que sera le test pour les fonctionnalit√©s que vous avez pr√©vues - et vous cr√©erez automatiquement une barre de qualit√© architecturale pour vous-m√™me, et assez √©lev√©e.  Les r√©flexions sur les tests augmentent automatiquement la modularit√©, r√©duisent la connectivit√© et rendent l'architecture plus logique. <br><br>  Et je ne parle pas de TDD.  Une maladie typique de nombreux programmeurs est le culte religieux des technologies lues quelque part sans comprendre les limites de leur efficacit√©.  TDD est bon lorsque plusieurs programmeurs travaillent sur le code, lorsqu'il y a un service de test et que les autorit√©s comprennent pourquoi de bonnes pratiques de codage sont n√©cessaires et qu'elle est pr√™te √† payer non seulement pour un code qui r√©sout le probl√®me, mais aussi pour sa fiabilit√©.  Si vos sup√©rieurs ne sont pas pr√™ts √† payer, vous devrez travailler plus √©conomiquement.  N√©anmoins, vous devez toujours tester le code - √† moins, bien s√ªr, que vous ayez un sentiment d'auto-pr√©servation. <br><br>  Le deuxi√®me principe est la modularit√©.  Plus pr√©cis√©ment, une modularit√© hautement isol√©e sans l'utilisation de biblioth√®ques / codes durs qui ne sont pas li√©s au module lui-m√™me.  D√©sormais, lors de la conception d'architectures de serveurs, il est √† la mode de diviser un monolithe en microservices.  Je vais vous dire un terrible secret - chaque module du monolithe devrait √™tre comme un microservice.  Dans le sens o√π il devrait facilement se d√©marquer du code g√©n√©ral avec un minimum d'en-t√™tes connect√©s dans l'environnement de test.  Ce n'est pas encore clair, mais je vais vous expliquer avec un exemple: Avez-vous d√©j√† essay√© d'allouer shared_ptr √† partir d'un boost?  Si en m√™me temps vous parvenez √† tirer non seulement tout le coup de pouce, mais seulement la moiti√© de ses mati√®res premi√®res, cela signifie que vous avez tu√© trois √† cinq jours pour √©liminer les d√©pendances inutiles !!!  En m√™me temps, vous faites glisser le fait que shared_ptr n'a d√©finitivement rien √† voir !!! <br><br>  Et c'est pire qu'une erreur - c'est un crime architectural. <br><br>  Avec une bonne architecture, vous devriez √™tre en mesure d'arracher shared_ptr, en rempla√ßant sans douleur et rapidement tout ce qui n'est pas li√© √† shared_ptr par des versions de test.  Par exemple, une version de test de l'allocateur.  Ou oubliez le coup de pouce.  Disons que vous √©crivez un analyseur xml / html.  Vous devez travailler avec des cha√Ænes et travailler avec des fichiers pour l'analyseur.  Et si nous parlons d'une architecture id√©ale qui n'est pas li√©e aux besoins d'une soci√©t√© de production / logiciel particuli√®re, alors pour un analyseur avec une architecture id√©ale, nous n'avons pas le droit d'utiliser std :: istream, std :: file_system, std :: string et des op√©rations de recherche de code dur avec des cha√Ænes dans l'analyseur.  Nous devons fournir une interface de flux, une interface pour les op√©rations sur les fichiers (peut-√™tre divis√©e en sous-interfaces, mais l'acc√®s aux sous-interfaces devra toujours se faire via l'interface du module d'op√©rations sur les fichiers), une interface pour travailler avec des cha√Ænes, une interface d'allocateur, et id√©alement aussi une interface pour la ligne elle-m√™me.  En cons√©quence, nous pouvons remplacer sans peine tout ce qui n'est pas li√© √† l'analyse avec des blancs de test, ou ins√©rer une version de test de l'allocateur / travailler avec des fichiers / rechercher des cha√Ænes avec des v√©rifications suppl√©mentaires.  Et la polyvalence de la solution augmentera - demain, sous l'interface du flux, il n'y aura pas un fichier, mais un site quelque part sur Internet, et personne ne le remarquera.  Vous pouvez remplacer la biblioth√®que standard par Qt, puis basculer vers Visual C ++, puis commencer √† utiliser uniquement des choses Linux - et les modifications seront minimes.  En tant que spoiler, je dirai qu'avec cette approche, la question du prix se pose en pleine croissance - couvrir tout avec des interfaces, y compris des √©l√©ments de la biblioth√®que standard, co√ªte cher, mais ce n'est pas un objectif, mais une solution. <br><br>  En g√©n√©ral, le principe radical module-as-microservice proclam√© dans cet article est un point sensible en C ++ et g√©n√©ralement un code plus typique.  Si vous cr√©ez des fichiers de d√©claration et des interfaces distinctes s√©par√©ment des impl√©mentations, vous pouvez toujours cr√©er l'ind√©pendance / l'isolement des fichiers cpp les uns des autres, puis, relatifs, et non √† 100%, les en-t√™tes sont g√©n√©ralement tiss√©s dans un monolithe solide, √† partir duquel rien ne peut √™tre d√©chir√© sans viande.  Et bien que cela ait un effet terrible sur le temps de compilation, √ßa l'est.  De plus, m√™me si l'ind√©pendance des rubriques est atteinte, cela signifie automatiquement l'impossibilit√© de regrouper les classes.  En fait, la seule fa√ßon d'obtenir l'ind√©pendance des fichiers .cpp et des en-t√™tes en c ++ est de d√©clarer les classes pr√©-utilis√©es (sans les d√©finir), puis d'utiliser uniquement des pointeurs vers elles.  d√®s que vous utilisez la classe elle-m√™me au lieu du pointeur de classe dans le fichier d'en-t√™te (c'est-√†-dire l'agr√©ger), vous allez cr√©er un tas de tous les .cpp-shniks qui incluent cet en-t√™te, et ce .cpp-shnik qui contient la d√©finition de classe.  Il y a toujours fastpimpl, mais il est juste garanti de cr√©er des d√©pendances au niveau cpp. <br><br>  Ainsi, pour une bonne architecture, l'isolement des modules est important - la possibilit√© de retirer un module avec le premier en-t√™te connectant les macros et les principaux types de biblioth√®que, avec un deuxi√®me en-t√™te pour les d√©clarations et plusieurs inclusions reliant un ensemble d'interfaces.  Et seulement ce qui se rapporte √† cette fonctionnalit√©, et tout le reste doit √™tre stock√© dans d'autres modules et accessible uniquement via des interfaces. <br><br>  Nous exposons les principales caract√©ristiques d'une bonne architecture, y compris les points indiqu√©s ci-dessus, point par point. <br><br>  D√©finissons le terme ¬´module¬ª.  Un module est la somme des fonctionnalit√©s logiquement li√©es.  Par exemple, travaillez avec des flux ou des fichiers, ou avec un analyseur html. <br><br>  Le module ¬´File Work¬ª peut combiner de nombreuses fonctionnalit√©s - ouvrir un fichier, fermer, positionner, lire les propri√©t√©s, lire la taille du fichier.  Dans le m√™me temps, le scanner de dossiers peut √™tre con√ßu dans le cadre de l'interface ¬´File Work¬ª, ou en tant que module s√©par√©, et le travail avec les flux peut √™tre plac√© dans un module s√©par√© √† coup s√ªr.  Ce qui, cependant, n'interf√®re pas avec l'organisation indirecte de l'acc√®s √† tous les autres modules aux flux et au scanner de dossiers, via le "File Work".  Ce n'est pas n√©cessaire, mais tout √† fait logique. <br><br><ol><li>  Modularit√©.  "Module-comme-microservice" imp√©ratif. </li><li>  Allocation de 20% du code ex√©cut√© 80% du temps dans une biblioth√®que s√©par√©e - le c≈ìur du programme </li><li>  Testabilit√© de chaque fonctionnalit√© de chaque module </li><li>  Interface, c'est le manque de hardcode.  Vous pouvez uniquement appeler le code physique directement li√© aux fonctionnalit√©s du module, et vous devez effectuer les autres appels directs de biblioth√®que vers un module distinct et y acc√©der via l'interface. </li><li>  Isolation compl√®te du module par des interfaces de l'environnement externe.  L'interdiction de ¬´clouer¬ª les impl√©mentations qui ne sont pas li√©es √† la fonctionnalit√© de la classe.  Et plus radicalement, isoler les biblioth√®ques (y compris les biblioth√®ques standard) avec des interfaces / adaptateurs / d√©corateurs </li><li>  L'agr√©gation d'une classe ou la cr√©ation d'une variable de classe ou de fastpimpl n'est utilis√©e que lorsqu'elle est essentielle aux performances. </li></ol><br>  Bien s√ªr, nous trouverons comment r√©aliser tout cela rapidement pour un prix inf√©rieur, mais je voudrais attirer l'attention sur un autre probl√®me, dont la solution sera un bonus pour nous - le transfert de param√®tres d√©pendants de la plate-forme.  Par exemple, si vous devez cr√©er du code qui fonctionne √©galement sur Android et Windows, il sera logique d'allouer des algorithmes d√©pendants de la plate-forme dans des modules s√©par√©s.  Dans ce cas, probablement, l'impl√©mentation pour l'andro√Øde peut n√©cessiter une r√©f√©rence √† l'environnement Java (jni), JNIEnv *, et √©ventuellement √† quelques objets Java.  Et la mise en ≈ìuvre sur Windows peut n√©cessiter un dossier de travail du programme (qui sur Android peut √™tre demand√© au syst√®me, ayant JNIEnv *).  L'astuce est que le m√™me JNIEnv * n'existe pas dans le contexte Windows, donc m√™me une union typ√©e ou son alternative c ++ √† std :: variant est impossible.  Vous pouvez bien s√ªr utiliser le vecteur void * ou le vecteur std :: any comme param√®tre, mais honn√™tement, il s'agit d'une b√©quille atypique.  Atypique - car il rejette le principal avantage du c ++, le typage fort.  Et c'est plus dangereux que le SRAS. <br><br>  De plus, nous analyserons comment r√©soudre ce probl√®me de mani√®re strictement typ√©e. <br><br><h2>  Partie 2. Les balles magiques et leur prix </h2><br>  Supposons donc que nous ayons une grande quantit√© de code qui doit √™tre √©crit √† partir de z√©ro, et le r√©sultat sera un tr√®s grand projet. <br><br>  Comment l'assembler selon les principes que nous avons d√©termin√©s? <br><br>  La m√©thode classique, approuv√©e par tous les manuels, consiste √† tout diviser en interfaces et strat√©gies.  √Ä l'aide d'interfaces et de strat√©gies, s'il y en a beaucoup, n'importe quelle sous-t√¢che de notre projet peut √™tre isol√©e √† tel point que le principe ¬´module-comme-microservice¬ª commence √† travailler dessus.  Mais mon exp√©rience personnelle est que si vous divisez le projet en 20 √† 30 parties, qui seront isol√©es au niveau du "module en tant que microservice", vous r√©ussirez.  Mais la principale caract√©ristique d'une bonne architecture est la possibilit√© de tester n'importe quelle classe en dehors du contexte du projet.  Et si vous isolez d√©j√† chaque classe, il y a d√©j√† plus de 500 modules, et d'apr√®s mon exp√©rience, cela augmente le temps de d√©veloppement de 3 √† 5 fois, ce qui signifie que dans les "conditions de combat" vous ne le ferez pas et vous compromettrez entre prix et qualit√©. <br><br>  Quelqu'un peut douter et sera de son propre chef.  Faisons une estimation approximative.  Laissez la classe moyenne avoir 3-5 membres et 20 fonctions et 3 constructeurs.  Plus 6-10 getters et setters (mutateurs) pour l'acc√®s √† nos membres.  Total d'environ 40 unit√©s dans la classe.  Dans un projet typique, chaque classe ¬´centrale¬ª doit avoir acc√®s √† une moyenne de cinq fonctionnalit√©s, pas un centre √† 3. Par exemple, de tr√®s nombreuses classes ont besoin d'un allocateur, d'un syst√®me de fichiers, de travailler avec des cha√Ænes, de travailler avec des flux et d'acc√©der √† des bases de donn√©es. <br><br>  Chaque strat√©gie / interface requiert un membre de type <code>std::shared_ptr&lt;CreateStreamStrategy&gt; m_create_stream;</code>  .  Deux mutateurs, plus l'initialisation dans chacun des trois constructeurs.  plus quelque part dans l'initialisation de notre classe, vous devrez appeler quelque chose comme <code>myclass-&gt;SetCreateStreamStrategy( my_create_stream_strategy )</code> plusieurs fois, pour un total de 8 unit√©s par interface / strat√©gie, et puisque nous en avons environ cinq, il y aura 40 unit√©s.  Autrement dit, nous avons rendu la classe source deux fois plus lourde.  Et la perte de simplicit√© affectera in√©vitablement la lisibilit√©, et ailleurs dans le processus de d√©bogage, et demi fois, malgr√© le fait que rien ne semble avoir fondamentalement chang√©. <br><br>  La question est donc.  Comment faire de m√™me, mais √† un prix minimum?  La premi√®re chose qui me vient √† l'esprit est le param√©trage statique sur les mod√®les, dans le style d'Alexandrescu et de la biblioth√®que Loki. <br><br>  Nous √©crivons une classe avec style <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Traits</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMainTaskFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... MyStream stream = Traits::streamwork::Open( stream_name ); ... } };</code> </pre> <br>  Cette d√©cision pr√©sente tous les avantages architecturaux que nous avons identifi√©s dans la premi√®re partie.  Mais il y a aussi beaucoup d'inconv√©nients. <br><br>  Moi-m√™me, j'adore me brouiller, mais je regrette pour moi-m√™me, j'avoue: les mod√®les dans le code ordinaire ne sont aim√©s que par les magiciens des mod√®les.  Une masse importante de programmeurs avec le mot ¬´mod√®le¬ª fronce l√©g√®rement les sourcils.  De plus, dans l'industrie, la grande majorit√© des avantages ne sont en fait pas des avantages, mais sont l√©g√®rement recycl√©s chez les syshniks c ++ qui n'ont pas une connaissance approfondie des avantages, mais tombent sous le mot ¬´mod√®le¬ª et font semblant d'√™tre morts. <br><br>  Si nous traduisons cela dans un langage de production, alors maintenir le code sur le param√©trage statique est plus cher et plus compliqu√©. <br><br>  Dans le m√™me temps, si nous voulons, pour une meilleure lisibilit√©, supprimer soigneusement le corps de la fonction en dehors de la classe, nous obtenons beaucoup de gribouillages avec les noms des mod√®les et des param√®tres de mod√®le.  Et en cas d'erreur de compilation, nous obtenons de longues √©tag√®res lisibles par l'homme des causes et des probl√®mes avec un tas de mod√®les imbriqu√©s complexes. <br><br>  Mais, il existe une solution simple.  En tant que magicien de mod√®les, je d√©clare que presque tout ce qui peut √™tre fait en utilisant le param√©trage statique / le polymorphisme statique peut √™tre transf√©r√© au polymorphisme dynamique.  Non, bien s√ªr, nous n'√©radiquerons pas le mod√®le √† la fin - mais nous ne le disperserons pas avec une main g√©n√©reuse pour le param√©trage dans chaque classe, mais nous le limiterons √† quelques classes instrumentales. <br><br><h2>  Troisi√®me partie.  La solution propos√©e et le code encod√© pour cette solution </h2><br>  Alors l√† !!!  Rencontrez la classe de mod√®les TypedSet.  Il associe un pointeur intelligent de ce type √† un seul type.  De plus, pour le type sp√©cifi√©, il peut avoir un objet, mais il ne peut pas.  Je n'aime pas le nom - je serai donc reconnaissant si dans les commentaires me dire une option plus r√©ussie. <br><br>  Un type - un objet.  Mais le nombre de types n'est pas limit√©!  Par cons√©quent, vous pouvez passer une telle classe en tant que param√©triseur. <br><br>  Je veux attirer votre attention sur un point.  Il peut sembler qu'√† un moment donn√©, vous ayez besoin de deux objets sous une seule interface.  En fait, si un tel besoin se fait sentir, alors (√† mon avis) cela signifie une erreur architecturale.  Autrement dit, si vous avez deux objets sous une interface, ce ne sont plus des interfaces d'acc√®s fonctionnelles: ce sont soit des variables d'entr√©e pour la fonction, soit vous n'avez pas une mais deux fonctionnalit√©s auxquelles vous devez acc√©der, alors il vaut mieux diviser l'interface en deux . <br><br>  Nous ferons trois fonctions de base: Cr√©er, Obtenir et A.  En cons√©quence, la cr√©ation, la r√©ception et la v√©rification de la pr√©sence d'un √©l√©ment. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// @brief    .      ,    ///           /// class TypedSet { public: template &lt;class TypedElement&gt; void Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ); template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; Get() const; template &lt;class TypedElement&gt; bool Has() const; size_t GetSize() const { return storage_.size(); } protected: typedef std::map&lt; size_t, std::shared_ptr&lt;void&gt; &gt; Storage; Storage const &amp; storage() const { return storage_; } Storage &amp; get_storage() { return storage_; } private: Storage storage_; }; template &lt;class TypedElement&gt; void TypedSet::Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ) { size_t hash = typeid(TypedElement).hash_code(); if ( storage().count( hash ) &gt; 0 ) { LogError( "Access Violation" ); return; } std::shared_ptr&lt;void&gt; to_add ( value ); get_storage().insert( std::pair( typeid(TypedElement).hash_code(), to_add ) ); } template &lt;class TypedElement&gt; bool TypedSet::Has() const { size_t hash = typeid(TypedElement).hash_code(); return storage().count( hash ) &gt; 0; } template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; TypedSet::Get() const { size_t hash = typeid(TypedElement).hash_code(); if ( storage().count( hash ) &gt; 0 ) { std::shared_ptr&lt;void&gt; ret( storage().at(hash) ); return std::static_pointer_cast&lt;TypedElement&gt;( ret ); } else { LogError( "Access Violation" ); return std::shared_ptr&lt;TypedElement&gt; (); } }</span></span></code> </pre> <br>  Au fait, j'ai vu une solution alternative de coll√®gues √©crivant en Qt.  L√†, l'acc√®s √† l'interface souhait√©e a √©t√© effectu√© via un singleton, qui a ¬´mapp√©¬ª l'interface souhait√©e, compress√©e dans Varaint, via une ligne de texte (!!!), et apr√®s avoir cast√© cette option, le r√©sultat a pu √™tre utilis√©. <br><br><pre> <code class="cpp hljs">GlobalConfigurator()[<span class="hljs-string"><span class="hljs-string">"FileSystem"</span></span>].Get().As&lt;FileSystem&gt;()</code> </pre> <br>  Cela fonctionne certainement, mais le surco√ªt de compter la longueur et de hacher davantage la cha√Æne est quelque peu effrayant pour mon √¢me optimiste.  Ici, la surcharge est nulle, car  le choix de l'interface souhait√©e est effectu√© au moment de la compilation. <br><br>  Sur la base de TypedSet, nous pouvons cr√©er la classe StrategiesSet, qui est d√©j√† plus avanc√©e.  Nous y stockons non seulement un objet par interface d'acc√®s pour chaque fonctionnalit√©, mais √©galement pour chaque interface (ci-apr√®s d√©nomm√©e la strat√©gie) un TypedSet suppl√©mentaire avec des param√®tres pour cette strat√©gie.  Je pr√©cise: les param√®tres, contrairement aux variables de fonction, sont ceux qui sont d√©finis une fois lors de l'initialisation du programme ou une fois pour une ex√©cution de programme volumineuse.  Les param√®tres vous permettent de rendre le code v√©ritablement multiplateforme.  C'est en eux que nous conduisons toute la cuisine d√©pendante de la plateforme. <br><br>  Ici, nous aurons des fonctions plus basiques: Create, Get, CreateParamsSet et GetParamsSet.  N'a pas √©t√© pos√©, car il est redondant sur le plan architectural: si votre code fait r√©f√©rence √† la fonctionnalit√© de travailler avec le syst√®me de fichiers, mais que le code appelant ne l'a pas fourni, vous pouvez uniquement lever une exception ou affirmer, ou <s>faire en sorte que le programme sebukka</s> appelle la fonction abort (). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Create</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; &amp; value ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; Get(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateParamsSet</span></span></span><span class="hljs-class">();</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; GetParamsSet(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateParam</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; &amp; value ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; GetParam(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-function">TypedSet </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strategies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strategies_; } <span class="hljs-function"><span class="hljs-function">TypedSet &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_strategies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strategies_; } <span class="hljs-function"><span class="hljs-function">TypedSet </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params_; } <span class="hljs-function"><span class="hljs-function">TypedSet &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params_; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamHolder</span></span></span><span class="hljs-class"> {</span></span> ParamHolder( ) : param_ptr( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;TypedSet&gt;() ) {} <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; param_ptr; }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TypedSet strategies_; TypedSet params_; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class">:</span></span>:Create( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; &amp; value ) { get_strategies().Create&lt;Strategy&gt;( value ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; StrategiesSet::Get() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_strategies().Get&lt;Strategy&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class">:</span></span>:CreateParamsSet( ) { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; Holder &gt; ptr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; Holder &gt;( ); ptr-&gt;param_ptr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; TypedSet &gt;(); get_params().Create&lt; Holder &gt;( ptr ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; StrategiesSet::GetParamsSet() { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( get_params().Has&lt; Holder &gt;() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_params().Get&lt; Holder &gt;()-&gt;param_ptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LogError(<span class="hljs-string"><span class="hljs-string">"StrategiesSet::GetParamsSet : get unexisting!!!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt;(); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class">:</span></span>:CreateParam( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; &amp; value ) { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !params().Has&lt;Holder&gt;() ) CreateParamsSet&lt;Strategy&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( params().Has&lt;Holder&gt;() ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; params_set = GetParamsSet&lt;Strategy&gt;(); params_set-&gt;Create&lt;ParamType&gt;( value ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LogError( <span class="hljs-string"><span class="hljs-string">"Param creating error: Access Violation"</span></span> ); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; StrategiesSet::GetParam() { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( params().Has&lt;Holder&gt;() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetParamsSet&lt;Strategy&gt;()-&gt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Get&lt;ParamType&gt;(); <span class="hljs-comment"><span class="hljs-comment">//   template          .    . } else { LogError( "Access Violation" ); return std::shared_ptr&lt;ParamType&gt; (); } }</span></span></code> </pre> <br>  Un autre avantage suppl√©mentaire est qu'au stade du prototypage, vous pouvez cr√©er une classe de typage tr√®s grande, y cr√©er un acc√®s √† tous les modules et le passer √† tous les modules en tant que param√®tre, devenir rapidement petit, puis le diviser en morceaux qui sont minimalement n√©cessaires pour chaque module. <br><br>  Eh bien, et un cas d'utilisation petit et (encore) trop simplifi√©.  J'esp√®re que vous me sugg√©rerez dans les commentaires ce que vous aimeriez voir comme un exemple simple, et je ferai de l'article une petite mise √† jour.  Comme le dit la sagesse de la programmation populaire, ¬´lancez le plus t√¥t possible et am√©liorez l'utilisation des commentaires apr√®s la sortie¬ª. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\niface1\n"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface1() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\niface2\n"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface2() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\niface3\n"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface3() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Implementation1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Interface1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nimpl1\n"</span></span>);} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Implementation2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Interface2 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nimpl2\n"</span></span>);} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintParams</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~PrintParams() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintParamsUbuntu</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PrintParams { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Ubuntu"</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintParamsWindows</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PrintParams { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Windows"</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintStrategy</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~PrintStrategy() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TypedSet&amp; params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; str )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintWithOsStrategy</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PrintStrategy { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TypedSet&amp; params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; str )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> os = params.Get&lt; PrintParams &gt;()-&gt;GetOs(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" Printing: %s (OS=%s)"</span></span>, str.c_str(), os.c_str() ); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestTypedSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; TypedSet a; a.Create&lt;Interface1&gt;( make_shared&lt;Implementation1&gt;() ); a.Create&lt;Interface2&gt;( make_shared&lt;Implementation2&gt;() ); a.Get&lt;Interface1&gt;()-&gt;Fun(); a.Get&lt;Interface2&gt;()-&gt;Fun(); Log(<span class="hljs-string"><span class="hljs-string">"Double creation:"</span></span>); a.Create&lt;Interface1&gt;( make_shared&lt;Implementation1&gt;() ); Log(<span class="hljs-string"><span class="hljs-string">"Get unexisting:"</span></span>); a.Get&lt;Interface3&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategiesSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; StrategiesSet printing; printing.Create&lt; PrintStrategy &gt;( make_shared&lt;PrintWithOsStrategy&gt;() ); printing.CreateParam&lt; PrintStrategy, PrintParams &gt;( make_shared&lt;PrintParamsWindows&gt;() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> print_strategy_ptr = printing.Get&lt; PrintStrategy &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; print_strategy = *print_strategy_ptr; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; print_params = *printing.GetParamsSet&lt; PrintStrategy &gt;(); print_strategy( print_params, <span class="hljs-string"><span class="hljs-string">"Done!"</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TestTypedSet(); TestStrategiesSet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  R√©sum√© </h2><br>  Ainsi, nous avons r√©solu un probl√®me important: nous n'avons laiss√© dans la classe que l'interface directement li√©e aux fonctionnalit√©s de la classe.  Le reste a √©t√© ¬´pouss√©¬ª dans le StrategiesSet, tout en √©vitant d'encombrer la classe avec des √©l√©ments inutiles et de ¬´clouer¬ª certains algorithmes de la fonctionnalit√© requise aux algorithmes.  Cela nous permettra non seulement d'√©crire du code hautement isol√©, sans aucune d√©pendance vis-√†-vis des impl√©mentations et des biblioth√®ques, mais √©galement de gagner un temps consid√©rable. <br><br>  Le code de l'exemple et des classes d'outils peut √™tre trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> <br><br>  <b>Upd.</b>  <b>√† partir du 13/11/2019</b> <br>  En fait, le code pr√©sent√© ici n'est qu'un exemple simplifi√© de lisibilit√©.  Le fait est que typeid (). Hash_code est impl√©ment√© dans les compilateurs modernes lentement et de mani√®re inefficace.  Son utilisation tue une grande partie du sens.  De plus, comme le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">sugg√®re</a> le respect√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">0xd34df00d</a> , la norme ne garantit pas la possibilit√© de distinguer les types par hashcode (en pratique, cette approche fonctionne cependant).  Mais l'exemple est bien lu.  J'ai r√©√©crit TypedSet sans typeid (). De plus, Hash_code () a remplac√© map par array (mais avec la possibilit√© de passer rapidement de map √† array et vice versa en changeant un chiffre dans #if).  Cela s'est av√©r√© plus difficile, mais plus int√©ressant pour une utilisation pratique. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√† coliru</a> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> metatype { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetAndIncrease() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter_++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> counter_ = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashGetterBody</span></span></span><span class="hljs-class"> {</span></span> HashGetterBody() : hash_( counter_.GetAndIncrease() ) { } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetHash() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash_; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Counter counter_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> hash_; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashGetter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetHash() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasher_.GetHash(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> HashGetterBody&lt;Type&gt; hasher_; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace metatype template &lt;typename Type&gt; size_t GetTypeHash() { return metatype::HashGetter&lt;Type&gt;().GetHash(); } namespace details { #if 1 //   ,        () class TypedSetStorage { public: static inline const constexpr size_t kMaxTypes = 100; typedef std::array&lt; std::shared_ptr&lt;void&gt;, kMaxTypes &gt; Storage; void Set( size_t hash_index, const std::shared_ptr&lt;void&gt; &amp; value ) { ++size_; assert( hash_index &lt; kMaxTypes ); // too many types data_[hash_index] = value; } std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) { assert( hash_index &lt; kMaxTypes ); return data_[hash_index]; } const std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) const { if ( hash_index &gt;= kMaxTypes ) return empty_ptr_; return data_[hash_index]; } bool Has( size_t hash_index ) const { if ( hash_index &gt;= kMaxTypes ) return 0; return (bool)data_[hash_index]; } size_t GetSize() const { return size_; } private: Storage data_; size_t size_ = 0; static const inline std::shared_ptr&lt;void&gt; empty_ptr_; }; #else //    ,        (std::map) class TypedSetStorage { public: typedef std::map&lt; size_t, std::shared_ptr&lt;void&gt; &gt; Storage; void Set( size_t hash_index, const std::shared_ptr&lt;void&gt; &amp; value ) { data_[hash_index] = value; } std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) { return data_[hash_index]; } const std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) const { return data_.at(hash_index); } bool Has( size_t hash_index ) const { return data_.count(hash_index) &gt; 0; } size_t GetSize() const { return data_.size(); } private: Storage data_; }; #endif } // namespace details /// @brief    .      ,    ///           /// class TypedSet { public: template &lt;class TypedElement&gt; void Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ); template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; Get() const; template &lt;class TypedElement&gt; bool Has() const; size_t GetSize() const { return storage_.GetSize(); } protected: typedef details::TypedSetStorage Storage; Storage const &amp; storage() const { return storage_; } Storage &amp; get_storage() { return storage_; } private: Storage storage_; }; template &lt;class TypedElement&gt; void TypedSet::Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ) { size_t hash = GetTypeHash&lt;TypedElement&gt;(); if ( storage().Has( hash ) ) { LogError( "Access Violation" ); return; } std::shared_ptr&lt;void&gt; to_add ( value ); get_storage().Set( hash, to_add ); } template &lt;class TypedElement&gt; bool TypedSet::Has() const { size_t hash = GetTypeHash&lt;TypedElement&gt;(); return storage().Has( hash ); } template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; TypedSet::Get() const { size_t hash = GetTypeHash&lt;TypedElement&gt;(); if ( storage().Has( hash ) ) { std::shared_ptr&lt;void&gt; ret( storage().Get( hash ) ); return std::static_pointer_cast&lt;TypedElement&gt;( ret ); } else { LogError( "Access Violation" ); return std::shared_ptr&lt;TypedElement&gt; (); } }</span></span></code> </pre><br>  Ici, l'acc√®s est effectu√© en temps lin√©aire, les hachages de type sont compt√©s avant le lancement de main (), les pertes sont uniquement pour les contr√¥les de validation, qui peuvent √™tre supprim√©s si vous le souhaitez. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475268/">https://habr.com/ru/post/fr475268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475258/index.html">Une repr√©sentation visuelle des √©lections √† Saint-P√©tersbourg - la magie de l'habillage vocal</a></li>
<li><a href="../fr475260/index.html">La diff√©rence entre une fonction asynchrone et une fonction qui renvoie une promesse</a></li>
<li><a href="../fr475262/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 388 (4-10 novembre 2019)</a></li>
<li><a href="../fr475264/index.html">Des renifleurs qui pourraient: comment la famille FakeSecurity a infect√© les boutiques en ligne</a></li>
<li><a href="../fr475266/index.html">Nous inversons les mobiles 1 sous Android. Comment ajouter un peu de fonctionnalit√© et abandonner quelques soir√©es</a></li>
<li><a href="../fr475270/index.html">SwiftUI: cr√©ation de sections extensibles / r√©ductibles en mode liste</a></li>
<li><a href="../fr475272/index.html">Migration vers une infrastructure d'attente asynchrone √† Rust</a></li>
<li><a href="../fr475276/index.html">Comment √©crire assert correctement</a></li>
<li><a href="../fr475280/index.html">Mots de passe Cisco, migration de zone DNS, z√©ro requ√™te LDAP, nous collectons des paquets Ethernet. R√©solution de probl√®mes sur un r√©seau avec r0ot-mi. 2e partie</a></li>
<li><a href="../fr475284/index.html">Gestionnaire et singes d'une minute, recueil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>