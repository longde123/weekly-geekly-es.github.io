<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîè üçº üí¶ 15 wenig bekannte Eigenschaften und Methoden von DOM-Objekten üë∑ üöÄ üîú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Entwicklung moderner Websites werden h√§ufig JavaScript-Funktionen f√ºr die Arbeit mit DOM verwendet. Mithilfe von Skripten k√∂nnen Sie die Eleme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>15 wenig bekannte Eigenschaften und Methoden von DOM-Objekten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416539/">  Bei der Entwicklung moderner Websites werden h√§ufig JavaScript-Funktionen f√ºr die Arbeit mit DOM verwendet.  Mithilfe von Skripten k√∂nnen Sie die Elemente anzeigen und ausblenden, aus denen die Seiten erstellt wurden, und die Eigenschaften dieser Elemente konfigurieren.  DOM-Objekte, mit denen aus Programmen interagiert wird, verf√ºgen √ºber Eigenschaften und Methoden.  Praktisch alle Webprogrammierer kennen einige von ihnen, so der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen.  Aber einige, √ºber die er hier sprechen m√∂chte, sind weit weniger ber√ºhmt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/lw/k4/ct/lwk4ctoknigawiym3hgeyacp5nu.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">HTML und DOM</font> </h2><br>  Lassen Sie uns zun√§chst √ºber den Unterschied zwischen HTML und DOM sprechen.  Beispielsweise ist ein regul√§res <code>&lt;table&lt;</code> -Element offensichtlich HTML-Code.  Dieses Element kann in HTML-Dateien verwendet werden. Es verf√ºgt √ºber eine Reihe von Attributen, die das Erscheinungsbild und das Verhalten der mit seiner Hilfe erstellten Tabelle bestimmen.  Genau genommen hat das <code>&lt;table&gt;</code> -Tag selbst nichts mit JavaScript zu tun.  Die Beziehung zwischen den im Dokument vorhandenen HTML-Elementen und dem JavaScript-Code wird vom DOM (Document Object Model) bereitgestellt.  Das DOM erm√∂glicht die Interaktion mit HTML-Elementen aus JavaScript-Code, als w√§ren sie Objekte. <br><br>  Alle HTML-Elemente haben ihre eigenen ‚ÄûDOM-Schnittstellen‚Äú, die Eigenschaften (sie sind normalerweise Attributen von HTML-Elementen zugeordnet) und Methoden definieren.  Das <code>&lt;table&gt;</code> -Element verf√ºgt beispielsweise √ºber eine Schnittstelle namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTMLTableElement</a> . <br><br>  Sie k√∂nnen einen Link zu einem Element erhalten, indem Sie beispielsweise die folgende Konstruktion verwenden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchBox = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'search-box'</span></span>);</code> </pre> <br>  Nachdem die Verkn√ºpfung zum Element empfangen wurde, hat der Programmierer Zugriff auf die Eigenschaften und Methoden dieser Elemente.  Sie k√∂nnen beispielsweise mit der <code>value</code> Eigenschaft eines bestimmten Textfelds arbeiten, <code>searchBox</code> , der Link dazu wird in der <code>searchBox</code> Variablen mithilfe einer Struktur des Formulars <code>searchBox.value</code> .  Sie k√∂nnen den Cursor in dieses Textfeld setzen, indem Sie die <code>searchBox.focus()</code> -Methode aufrufen. <br><br>  Vielleicht k√∂nnen wir hier unseren ‚Äûkurzen Kurs √ºber das DOM‚Äú abschlie√üen und tats√§chlich zu den wenig bekannten Eigenschaften und Methoden der DOM-Schnittstellen von HTML-Elementen gehen. <br><br>  Wenn Sie sofort lesen und experimentieren m√∂chten, √∂ffnen Sie die Browser-Entwicklertools.  Um einen Link zu einem bestimmten Seitenelement zu erhalten, k√∂nnen Sie ihn im Elementbaum ausw√§hlen und dann das Konstrukt <code>$0</code> in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konsole verwenden</a> .  Geben Sie <code>dir($0)</code> in die Konsole ein, um ein Element als Objekt anzuzeigen.  √úbrigens, wenn Sie auf etwas Neues sto√üen, versuchen Sie es mit der Konsole zu erkunden. <br><br><h2>  <font color="#3AC1EF">Nr. 1: Tabellenmethoden</font> </h2><br>  Das bescheidene <code>&lt;table&gt;</code> -Element (das immer noch den ersten Platz unter den bei der Entwicklung von Webseitenlayouts verwendeten Technologien einnimmt) verf√ºgt √ºber eine ganze Reihe sehr guter Methoden, die den Prozess der Erstellung von Tabellen erheblich vereinfachen. <br><br>  Hier sind einige davon. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tableEl = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'table'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerRow = tableEl.createTHead().insertRow(); headerRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Make'</span></span>; headerRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Model'</span></span>; headerRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Color'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newRow = tableEl.insertRow(); newRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Yes'</span></span>; newRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'No'</span></span>; newRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Thank you'</span></span>;</code> </pre> <br>  Wie Sie sehen k√∂nnen, verwenden wir hier keine Befehle wie <code>document.createElement()</code> .  Und die <code>.insertRow()</code> -Methode bietet, wenn Sie sie direkt in der Tabelle aufrufen, sogar die Hinzuf√ºgung von <code>&lt;tbody&gt;</code> .  Ist es nicht wunderbar? <br><br><h2>  <font color="#3AC1EF"># 2: scrollIntoView () Methode</font> </h2><br>  Sie wissen wahrscheinlich, dass der Browser nach dem Laden der Seite automatisch zu dem Element mit der entsprechenden <code>ID</code> <code>#something</code> , wenn der Link eine Konstruktion wie <code>#something</code> hat.  Die Methode ist praktisch, aber wenn das f√ºr uns interessante Element nach dem Laden der Seite gerendert wird, funktioniert es nicht.  So erstellen Sie dieses Verhaltensmuster selbst: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.querySelector</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.location</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.hash</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.scrollIntoView</span></span>();</code> </pre> <br><h2>  <font color="#3AC1EF">Nr. 3: verstecktes Eigentum</font> </h2><br>  Hier betrachten wir eine Eigenschaft, jedoch wird beim Zugriff auf diese Eigenschaft h√∂chstwahrscheinlich ein bestimmter Setter aufgerufen, bei dem es sich um eine Methode handelt.  Denken Sie auf jeden Fall daran, dass Sie jemals das unten gezeigte Design verwendet haben, um ein Element auszublenden? <br><br><pre> <code class="hljs swift">myElement.style.display = '<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>'</code> </pre> <br>  Wenn Sie es verwenden, sollten Sie es nicht mehr tun.  Um ein Element auszublenden, schreiben Sie einfach <code>true</code> in seine <code>hidden</code> Eigenschaft: <br><br><pre> <code class="hljs objectivec">myElement.hidden = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF"># 4: toggle () Methode</font> </h2><br>  Tats√§chlich ist dies keine Methode eines Elements.  Dies ist eine Elementeigenschaftsmethode.  Mit dieser Methode k√∂nnen Sie insbesondere einem Element Klassen hinzuf√ºgen und diese mithilfe der folgenden Konstruktion entfernen: <br><br><pre> <code class="hljs scala">myElement.classList.toggle(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">')</span></span></code> </pre> <br>  √úbrigens, wenn Sie jemals Klassen mit dem <code>if</code> Konstrukt hinzugef√ºgt haben, beachten Sie, dass Sie dies nicht mehr tun m√ºssen, und vergessen Sie dieses Konstrukt.  Der gleiche Mechanismus wird mit dem zweiten Parameter der <code>toggle()</code> -Methode implementiert.  Wenn dies ein Ausdruck ist, der als <code>true</code> ausgewertet wird, wird die an <code>toggle()</code> Klasse dem Element hinzugef√ºgt. <br><br><pre> <code class="hljs scala">el.classList.toggle(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-orange-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">', </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">theme</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">===</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">orange</span></span></span><span class="hljs-class">')</span></span>;</code> </pre> <br>  Wahrscheinlich haben Sie hier Zweifel an der Angemessenheit dieses Designs.  Schlie√ülich enth√§lt der Name der Methode ‚ÄûUmschalten‚Äú, die angesichts der Tatsache, dass das Wesen der von ihr ausgef√ºhrten Aktion darin verborgen ist, als ‚ÄûUmschalten‚Äú √ºbersetzt werden kann, keine Erw√§hnung, dass ‚ÄûUmschalten‚Äú die Erf√ºllung einer bestimmten Bedingung impliziert.  Das oben beschriebene Design existiert jedoch in dieser Form, obwohl die Entwickler von Internet Explorer es wahrscheinlich auch f√ºr seltsam halten.  Bei der Implementierung von <code>toggle()</code> zweite Parameter nicht bereitgestellt.  Obwohl oben gesagt wurde, dass diejenigen, die sich mit <code>toggle()</code> auskennen, das <code>if</code> Konstrukt vergessen k√∂nnen, vergessen Sie es dennoch nicht. <br><br><h2>  <font color="#3AC1EF"># 5: querySelector () -Methode</font> </h2><br>  Sie wissen definitiv bereits √ºber die Existenz dieser Methode Bescheid, aber es besteht der Verdacht, dass genau 17% von Ihnen nicht wissen, dass sie f√ºr die Anwendung auf ein Element verwendet werden kann. <br><br>  Beispielsweise w√§hlt die Konstruktion <code>myElement.querySelector('.my-class')</code> nur die Elemente aus, die die Klasse <code>my-class</code> und gleichzeitig Nachkommen des <code>myElement</code> Elements sind. <br><br><h2>  <font color="#3AC1EF"># 6: n√§chstgelegene () Methode</font> </h2><br>  Alle Elemente, die die Suche nach √ºbergeordneten Elementen unterst√ºtzen, verf√ºgen √ºber diese Methode.  Dies ist so etwas wie die Umkehrung von <code>querySelector()</code> .  Mit dieser Methode k√∂nnen Sie beispielsweise den Titel f√ºr den aktuellen Abschnitt abrufen: <br><br><pre> <code class="hljs cs">myElement.closest(<span class="hljs-string"><span class="hljs-string">'article'</span></span>).querySelector(<span class="hljs-string"><span class="hljs-string">'h1'</span></span>);</code> </pre> <br>  Hier wird w√§hrend der Suche zuerst das erste √ºbergeordnete Element <code>&lt;article&gt;</code> und dann das erste Element <code>&lt;h1&gt;</code> erkannt, das in das Element eintritt. <br><br><h2>  <font color="#3AC1EF"># 7: Methode getBoundingClientRect ()</font> </h2><br>  Die Methode <code>getBoundingClientRect()</code> gibt ein h√ºbsch dekoriertes kleines Objekt zur√ºck, das Informationen √ºber die Gr√∂√üe des Elements enth√§lt, f√ºr das diese Methode aufgerufen wurde. <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">x</span></span>: <span class="hljs-number"><span class="hljs-number">604.875</span></span>, y: <span class="hljs-number"><span class="hljs-number">1312</span></span>, width: <span class="hljs-number"><span class="hljs-number">701.625</span></span>, height: <span class="hljs-number"><span class="hljs-number">31</span></span>, top: <span class="hljs-number"><span class="hljs-number">1312</span></span>, right: <span class="hljs-number"><span class="hljs-number">1306.5</span></span>, bottom: <span class="hljs-number"><span class="hljs-number">1343</span></span>, left: <span class="hljs-number"><span class="hljs-number">604.875</span></span> }</code> </pre> <br>  Bei dieser Methode ist jedoch besonders auf zwei Punkte zu achten: <br><br><ul><li>  Das Aufrufen dieser Methode f√ºhrt zu einem erneuten Zeichnen der Seite.  Abh√§ngig vom Ger√§t, auf dem die Seite angezeigt wird, und von der Komplexit√§t der Seite kann dieser Vorgang mehrere Millisekunden dauern.  Ber√ºcksichtigen Sie dies, wenn Sie diese Methode in bestimmten sich wiederholenden Codefragmenten aufrufen m√∂chten, z. B. beim Ausf√ºhren von Animationen. </li><li>  Nicht alle Browser unterst√ºtzen diese Methode. </li></ul><br><h2>  <font color="#3AC1EF"># 8: match () Methode</font> </h2><br>  Angenommen, wir m√ºssen √ºberpr√ºfen, ob ein bestimmtes Element eine bestimmte Klasse hat. <br><br>  So l√∂sen Sie dieses Problem anscheinend auf schwierigste Weise: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myElement.className.indexOf(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">') </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">-1</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br>  Hier ist eine andere Option, es ist besser, aber auch alles andere als ideal: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myElement.className.includes(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">')) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br>  Und hier ist der beste Weg, um dieses Problem zu l√∂sen: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myElement.matches('.some-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">')) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF"># 9: insertAdjacentElement () -Methode</font> </h2><br>  Diese Methode √§hnelt <code>appendChild()</code> , bietet jedoch etwas mehr Leistung dar√ºber, wo genau das <code>appendChild()</code> Element hinzugef√ºgt wird. <br><br>  Der Befehl <code>parentEl.insertAdjacentElement('beforeend', newEl)</code> √§hnelt dem Befehl <code>parentEl.appendChild(newEl)</code> . Mit der Methode <code>insertAdjacentElement()</code> k√∂nnen Sie jedoch zus√§tzlich zum Argument <code>afterend</code> , die den Ort angeben, an dem Sie ben√∂tigt werden Element hinzuf√ºgen. <br><br><h2>  <font color="#3AC1EF">Nr. 10: enth√§lt () Methode</font> </h2><br>  Wollten Sie schon immer wissen, ob sich ein Element in einem anderen befindet?  Ich brauche es die ganze Zeit.  Wenn Sie beispielsweise w√§hrend der Verarbeitung eines Mausklickereignisses herausfinden m√ºssen, ob es innerhalb oder au√üerhalb des Modalfensters aufgetreten ist (was bedeutet, dass es geschlossen werden kann), k√∂nnen Sie die folgende Konstruktion verwenden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!modalEl.contains(e.target)) modalEl.hidden = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; };</code> </pre> <br>  Hier ist <code>modalEl</code> ein Link zu einem modalen Fenster, und <code>e.target</code> ist jedes Element, auf das geklickt wird.  Interessanterweise kann ich bei dieser Technik nie gleich beim ersten Mal alles richtig schreiben, selbst wenn ich mich daran erinnere, dass ich mich st√§ndig irre und versuche, m√∂gliche Fehler im Voraus zu beheben. <br><br><h2>  <font color="#3AC1EF"># 11: Methode getAttribute ()</font> </h2><br>  Vielleicht kann diese Methode als die nutzloseste bezeichnet werden, aber es gibt eine Situation, in der sie definitiv n√ºtzlich sein kann. <br><br>  Denken Sie daran, wir haben bereits gesagt, dass Eigenschaften von DOM-Objekten normalerweise mit Attributen von HTML-Elementen verkn√ºpft sind. <br><br>  Einer der F√§lle, in denen dies nicht der Fall ist, wird beispielsweise durch das <code>href</code> Attribut dargestellt, z. B. hier: <code>&lt;a href="/animals/cat"&gt;Cat&lt;/a&gt;</code> . <br><br>  Das <code>el.href</code> Konstrukt <code>el.href</code> nicht wie erwartet <code>/animals/cat</code> .  Dies liegt daran, dass das <code>&lt;a&gt;</code> -Element die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTMLHyperlinkElementUtils-</a> Schnittstelle implementiert, die viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfseigenschaften</a> wie <code>protocol</code> und <code>hash</code> , mit denen Sie die Details der Links herausfinden k√∂nnen. <br>  Eine dieser Hilfseigenschaften ist die Eigenschaft <code>href</code> , die eine vollst√§ndige URL angibt, die alles enth√§lt, was die relative URL nicht im Attribut enth√§lt. <br><br>  Um genau das zu erhalten, was im <code>href</code> Attribut geschrieben ist, m√ºssen Sie daher das <code>el.getAttribute('href')</code> verwenden. <br><br><h2>  <font color="#3AC1EF">Nr. 12: drei Methoden des &lt;dialog&gt; -Elements</font> </h2><br>  Das relativ neue <code>&lt;dialog&gt;</code> -Element verf√ºgt √ºber zwei n√ºtzliche, aber recht gew√∂hnliche Methoden und eine Methode, die einfach als wunderbar bezeichnet werden kann.  Die Methoden <code>show()</code> und <code>close()</code> machen also genau das, was Sie von ihnen erwarten k√∂nnen, indem sie das Fenster ein- und ausblenden.  Wir nennen sie n√ºtzlich, aber gew√∂hnlich.  Die Methode <code>showModal()</code> zeigt jedoch das Element <code>&lt;dialog&gt;</code> √ºber allem anderen an und zeigt es in der Mitte des Fensters an.  Tats√§chlich wird genau ein solches Verhalten normalerweise von modalen Fenstern erwartet.  Wenn Sie mit solchen Elementen arbeiten, m√ºssen Sie nicht √ºber die <code>z-index</code> Eigenschaft nachdenken, manuell einen verschwommenen Hintergrund hinzuf√ºgen oder das Ereignis des Dr√ºckens der <code>Escape</code> Taste abh√∂ren, um das entsprechende Fenster zu schlie√üen.  Der Browser wei√ü, wie modale Fenster funktionieren sollen und stellt sicher, dass alles so funktioniert, wie es sollte. <br><br><h2>  <font color="#3AC1EF"># 13: forEach () -Methode</font> </h2><br>  Wenn Sie einen Link zu einer Liste von Elementen erhalten, k√∂nnen Sie diese Elemente manchmal mit der <code>forEach()</code> -Methode <code>forEach()</code> .  Die <code>for()</code> Schleifen sind gestern.  Angenommen, wir m√ºssen alle <code>&lt;a&gt;</code> -Elemente von der Seite im Protokoll auflisten.  Wenn wir dies wie unten gezeigt tun, wird eine Fehlermeldung angezeigt: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'a'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el.href); });</code> </pre> <br>  Um dieses Problem zu l√∂sen, k√∂nnen Sie die folgende Konstruktion verwenden: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el.href); });</code> </pre> <br>  Der Punkt hier ist, dass Methoden wie <code>getElementsByTagName()</code> ein Objekt vom Typ <code>HTMLCollection</code> und <code>querySelectorAll</code> Objekt <code>querySelectorAll</code> .  Es ist die Schnittstelle des <code>NodeList</code> Objekts <code>NodeList</code> die wir auf die Methode <code>forEach()</code> (und auch auf die Methoden <code>keys()</code> , <code>values()</code> und <code>entries()</code> ) zugreifen k√∂nnen. <br><br>  In der Tat w√§re es viel besser, wenn solche Methoden einfach normale Arrays zur√ºckgeben w√ºrden und uns nicht etwas anbieten w√ºrden, das eine Art scheinbar n√ºtzlicher Methoden enth√§lt, die nicht ganz wie Arrays sind.  <code>Array.from()</code> Sie jedoch nicht ver√§rgert, denn intelligente Leute von ECMA haben uns eine gro√üartige Methode gegeben - <code>Array.from()</code> , mit der wir alles, was wie Arrays aussieht, in Arrays verwandeln k√∂nnen. <br><br>  Infolgedessen k√∂nnen Sie Folgendes schreiben: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el.href); });</code> </pre> <br>  Und hier ist eine nette kleine Sache.  Durch die Umwandlung in ein Array, wie es fr√ºher war, erhalten wir die M√∂glichkeit, viele Array-Methoden wie <code>map()</code> , <code>filter()</code> und <code>reduce()</code> .  Hier zum Beispiel, wie man ein Array von externen Links auf der Seite bildet: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.origin) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">origin</span></span></span><span class="hljs-function"> =&gt;</span></span> origin !== <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.origin) .filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>);</code> </pre> <br>  √úbrigens mag ich das <code>.filter(Boolean)</code> denn wenn ich es irgendwann in dem Code treffe, den ich vor langer Zeit geschrieben habe, kann ich seine Bedeutung kaum sofort verstehen. <br><br><h2>  <font color="#3AC1EF">Nr. 14: Arbeit mit Formularen</font> </h2><br>  Es ist sehr wahrscheinlich, dass Sie wissen, dass das <code>&lt;form&gt;</code> -Element eine <code>submit()</code> -Methode hat.  Es ist jedoch weniger wahrscheinlich, dass Sie wissen, dass die Formulare eine <code>reset()</code> -Methode haben und dass sie eine <code>reportValidity()</code> -Methode haben, die anwendbar ist, wenn die Validierung des Ausf√ºllens von Formularelementen verwendet wird. <br><br>  Wenn Sie mit Formularen arbeiten, k√∂nnen Sie au√üerdem deren <code>elements</code> Eigenschaft verwenden, mit der Sie √ºber einen Punkt √ºber ihre Namensattribute auf Formularelemente zugreifen k√∂nnen.  Beispielsweise gibt das Konstrukt <code>myFormEl.elements.email</code> das <code>myFormEl.elements.email</code> <code>&lt;input name="email" /&gt;</code> , das zum Formular geh√∂rt ("Zugeh√∂rigkeit" bedeutet nicht unbedingt "Nachkomme sein"). <br><br>  Hierbei ist zu beachten, dass die Eigenschaft <code>elements</code> selbst keine Liste gew√∂hnlicher Elemente zur√ºckgibt.  Es gibt eine Liste von Steuerelementen zur√ºck (und diese Liste ist nat√ºrlich kein Array). <br><br>  Hier ist ein Beispiel.  Wenn das Formular drei Optionsfelder enth√§lt und alle denselben Namen ( <code>animal</code> ) haben, gibt das Konstrukt <code>formEl.elements.animal</code> einen Link zu einer Reihe von Optionsfeldern (1 Steuerelement, 3 HTML-Elemente).  Wenn Sie das Design <code>formEl.elements.animal.value</code> , wird der Wert des vom Benutzer ausgew√§hlten <code>formEl.elements.animal.value</code> . <br><br>  Wenn Sie dar√ºber nachdenken, sieht alles ziemlich seltsam aus. Wenden wir uns also dem vorherigen Beispiel zu: <br><br><ul><li>  <code>formEl</code> ist ein Element. </li><li>  <code>elements</code> ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTMLFormControlsCollection-</a> Objekt, das einem Array √§hnelt, dies jedoch nicht ist.  Seine Elemente sind nicht unbedingt HTML-Elemente. </li><li>  <code>animal</code> ist ein Satz von mehreren Optionsfeldern, die als Satz dargestellt werden, da sie alle dasselbe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namensattribut</a> haben (es gibt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RadioNodeList-</a> Schnittstelle, die speziell f√ºr die Arbeit mit Optionsfeldern entwickelt wurde). </li><li>  <code>value</code> auf das <code>value</code> Attribut des aktiven Optionsfelds in der Auflistung zugegriffen. </li></ul><br><h2>  <font color="#3AC1EF"># 15: select () Methode</font> </h2><br>  Vielleicht ist es am Ende des Materials besser, √ºber eine absolut erstaunliche Methode zu sprechen, obwohl diese Methode vielleicht eine Offenbarung f√ºr jemanden ist.  Mit der Methode <code>.select()</code> k√∂nnen Sie also Text in den Eingabefeldern ausw√§hlen, f√ºr die er aufgerufen wird. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir √ºber wenig bekannte Methoden und Eigenschaften gesprochen, mit denen mit dem Inhalt von Webseiten gearbeitet werden kann.  Wir hoffen, dass Sie hier etwas Neues f√ºr sich gefunden haben, und vielleicht nicht nur neu, sondern auch n√ºtzlich. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie programmatische Interaktionen mit den Inhalten von Webseiten, die nicht allgemein bekannt sind? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416539/">https://habr.com/ru/post/de416539/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416527/index.html">Virgin Galactic hat zugestimmt, den italienischen Raumhafen zu nutzen</a></li>
<li><a href="../de416531/index.html">Nachhaltigkeits-GAN-Training</a></li>
<li><a href="../de416533/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 322 (2. - 8. Juli 2018)</a></li>
<li><a href="../de416535/index.html">Digitale Veranstaltungen in Moskau vom 9. bis 15. Juli</a></li>
<li><a href="../de416537/index.html">Workshops bei Wireshark</a></li>
<li><a href="../de416541/index.html">H√§ufig gestellte Fragen zu erneuerbaren Energien, Teil 2</a></li>
<li><a href="../de416543/index.html">PHP Digest Nr. 134 (24. Juni - 8. Juli 2018)</a></li>
<li><a href="../de416545/index.html">Ein St√ºck pers√∂nliche Erfahrung: Entwicklung, Pull-Anfragen, Commits, Software-Kenntnisse</a></li>
<li><a href="../de416547/index.html">Rostec verl√§sst Yota Devices, ein Smartphone mit zwei Bildschirmen wird Abonnenten der Nachrichtenagentur Xinhua angeboten</a></li>
<li><a href="../de416549/index.html">Das Rettungs-U-Boot wird getestet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>