<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèª‚Äçü§ù‚Äçüßëüèª üìï üë©üèæ‚Äçüè´ 3D Game Shader f√ºr Anf√§nger: Effekte üëäüèª üë©üèº‚Äçü§ù‚Äçüë®üèø üíÜüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Der erste Teil ] 

 Nachdem wir uns mit den Grundlagen befasst haben, implementieren wir in diesem Teil des Artikels Effekte wie Objektkonturen, Blo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3D Game Shader f√ºr Anf√§nger: Effekte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453692/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Teil</a> ] <br><br>  Nachdem wir uns mit den Grundlagen befasst haben, implementieren wir in diesem Teil des Artikels Effekte wie Objektkonturen, Bloom, SSAO, Unsch√§rfe, Sch√§rfentiefe, Pixelung und andere. <br><br><h2>  Umrisse </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/96f/9b2/3b896f9b246e1695fa908b4bdc145480.gif"></div><br>  Das Erstellen von Konturen um die Geometrie der Szene verleiht dem Spiel ein einzigartiges Aussehen, das Comics oder Cartoons √§hnelt. <br><br><h3>  Diffuses Material </h3><br>  Der Contour Shader ben√∂tigt eine Eingabetextur, um die Kanten zu erkennen und zu f√§rben.  Kandidaten f√ºr eine solche eingehende Textur k√∂nnen eine diffuse Farbe aus Materialien, Farben aus diffusen Texturen, Scheitelpunktnormalen oder sogar Farben aus normalen Karten sein. <br><br><pre><code class="cpp hljs">uniform <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> vec4 diffuse ; } p3d_Material; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 diffuseColor = p3d_Material.diffuse.rgb; fragColor = vec4(diffuseColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Dies ist ein kleiner Fragment-Shader, der die diffuse Farbe eines Geometriematerials in eine Rahmenpuffertextur umwandelt.  Diese diffuse Farbtextur aus dem Bildspeicher ist die Eingabetextur f√ºr den Pfad-Shader. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/abd/05c/f0babd05caf7104156c15929995c9279.gif"></div><br>  Dies ist die Textur der diffusen Farbe des Materials aus dem Rahmenpuffer, der die Farben anzeigt, die wir in Blender festgelegt haben.  Der Kontur-Shader erkennt die Kanten in der Szene und f√§rbt sie. <br><br>  Es ist zu beachten, dass die diffuse Farbe von Materialien nicht funktioniert, wenn bestimmte Teile der Szene keine eigene diffuse Farbe des Materials haben. <br><br><h3>  Kanten erstellen </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/a0d/57a/33aa0d57aeba90366ddd95865ea0d6c6.gif"></div><br>  Das Erstellen von Kanten √§hnelt der Verwendung von Kantenerkennungsfiltern in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GIMP</a> . <br><br>  Alle Berechnungen f√ºr diese Schattierungstechnik werden in einem Fragment-Shader durchgef√ºhrt.  Um Konturen f√ºr den Scheitelpunkt-Shader zu erstellen, m√ºssen vier Scheitelpunkte des rechteckigen Netzes an die Ausgabe √ºbergeben werden, damit sie zum Bildschirm passen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D materialDiffuseTexture; // ... vec2 texSize = textureSize(materialDiffuseTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy; // ...</span></span></code> </pre> <br>  Bevor Sie beginnen, die Kanten zu erkennen, m√ºssen Sie die eingehende Textur vorbereiten, mit der wir arbeiten werden.  Da die Textur eine Bildschirmgr√∂√üe hat, k√∂nnen wir die UV-Koordinaten berechnen, wobei wir die Koordinaten des Fragments und die Gr√∂√üe der eingehenden Textur kennen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int separation = 1; // ...</span></span></code> </pre> <br>  <code>separation</code> kann nach Ihrem Geschmack angepasst werden.  Je gr√∂√üer der Abstand ist, desto dicker sind die Kanten oder Linien. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... vec4 mx = vec4(0); vec4 mn = vec4(1); int x = -1; int y = -1; for (int i = 0; i &lt; 9; ++i) { vec4 color = texture ( materialDiffuseTexture , (texCoord + (vec2(x, y) * separation)) / texSize ); mx = max(color, mx); mn = min(color, mn); x += 1; if (x &gt;= 2) { x = -1; y += 1; } } float alpha = ((mx.r + mx.g + mx.b) / 3) - ((mn.r + mn.g + mn.b) / 3); if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/d24/e56/42fd24e5682700e1e7cd5186bebc33af.gif"></div><br>  Die Kantenerkennungstechnik findet √Ñnderungen in den Farben der eingehenden Textur.  Wenn Sie sich auf das aktuelle Fragment konzentrieren, werden im Fenster 3x3-Fragmente die hellsten und dunkelsten Farben der neun Samples ermittelt.  Dann subtrahiert sie von der Helligkeit einer Farbe die Helligkeit einer anderen und erh√§lt ihren Unterschied. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lineRgb = vec3(0.012, 0.014, 0.022); // ... vec4 lineColor = vec4(lineRgb, alpha); // ... fragColor = lineColor; // ...</span></span></code> </pre> <br>  Dieser Unterschied wird im Alphakanal der Ausgabefarbe verwendet.  Wenn es keinen Unterschied gibt, wird die Kante oder Linie nicht gezeichnet.  Wenn es einen Unterschied gibt, wird die Kante gezeichnet. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br>  Versuchen Sie, mit dem Schwellenwert zu experimentieren.  Jetzt ist es Null.  Jeder Wert ungleich Null wird zu einer Flanke. Dieser Schwellenwert kann ge√§ndert werden.  Dies ist besonders n√ºtzlich f√ºr lautere eingehende Texturen mit kleinen Unterschieden.  Bei einer verrauschten eingehenden Textur m√ºssen Sie normalerweise nur f√ºr gro√üe Unterschiede Konturen erstellen. <br><br><h3>  Quellcode </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">material-diffuse.frag</a> </li><li>  <a href="">Outline.frag</a> </li></ul><br><h2>  Nebel </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/02c/e52/5af02ce52f813b27461f79e5dca5fe20.gif"></div><br>  Nebel (oder Nebel, wie er in Blender genannt wird) f√ºgt der Szene atmosph√§rischen Dunst hinzu und erzeugt mysteri√∂se, erweichte, hervorstehende Teile.  Die hervorstehenden Teile erscheinen, wenn eine gewisse Geometrie pl√∂tzlich in die Pyramide der Kamerasichtbarkeit f√§llt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_FogParameters { vec4 color ; float start ; float end ; } p3d_Fog; // ...</span></span></code> </pre> <br>  Panda3D verf√ºgt √ºber eine praktische Datenstruktur, die alle Nebelparameter enth√§lt. Sie k√∂nnen sie jedoch manuell auf Ihren Shader √ºbertragen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float fogIntensity = clamp ( ( p3d_Fog.end - vertexPosition.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; // ...</span></span></code> </pre> <br>  Im Codebeispiel wird ein lineares Modell verwendet, um die Helligkeit des Nebels zu berechnen, wenn Sie sich von der Kamera entfernen.  Stattdessen k√∂nnen Sie das Exponentialmodell verwenden.  Die Helligkeit des Nebels ist vor oder zu Beginn des Nebels Null.  Wenn sich die Scheitelpunktposition dem Ende des Nebels <code>fogIntensity</code> n√§hert sich <code>fogIntensity</code> Einheit.  F√ºr alle Eckpunkte nach dem Ende des Nebels ist die <code>fogIntensity</code> von oben auf 1 begrenzt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = mix ( outputColor , p3d_Fog.color , fogIntensity ); // ...</span></span></code> </pre> <br>  Basierend auf der Helligkeit des Nebels mischen wir die Farbe des Nebels mit der Ausgabefarbe.  Wenn sich <code>fogIntensity</code> Einheit n√§hert, wird es immer weniger <code>outputColor</code> und immer mehr <code>outputColor</code> .  Wenn <code>fogIntensity</code> die Einheit erreicht, bleibt nur die Farbe des Nebels √ºbrig. <br><br><h3>  Nebel auf den Konturen </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/ee8/d49/e1fee8d490abe10ecb798df618f183f7.gif"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D positionTexture; // ... vec4 position = texture(positionTexture, texCoord / texSize); float fogIntensity = clamp ( ( p3d_Fog.end - position.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; vec4 lineWithFogColor = mix ( lineColor , p3d_Fog.color , fogIntensity ); fragColor = vec4(lineWithFogColor.rgb, alpha); // ...</span></span></code> </pre> <br>  Der Path Shader bringt Nebel auf die Farben der Kanten, um ein ganzheitlicheres Bild zu erhalten.  Wenn er dies nicht tun w√ºrde, w√ºrde die Geometrie der Konturen durch Nebel verdeckt, was seltsam aussehen w√ºrde.  Er erzeugt jedoch immer noch Konturen an den √§u√üersten Kanten der Geometrie der B√ºhne mit der M√ºhle, da die Kanten √ºber die Geometrie hinausgehen - bis dahin, wo es keine Scheitelpunktpositionen gibt. <br><br>  <code>positionTexture</code> ist eine Bildpuffertextur, die die Positionen der Scheitelpunkte des Ansichtsbereichs enth√§lt.  Sie werden dies erfahren, wenn wir den SSAO-Shader implementieren. <br><br><h3>  Quellcode </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">base.frag</a> </li><li>  <a href="">Outline.frag</a> </li></ul><br><h2>  Bl√ºte </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/744/f35/31d744f35168ac87f609474998802b12.gif"></div><br>  Das Hinzuf√ºgen von Bl√ºte zur Szene kann eine √ºberzeugende Illusion des Beleuchtungsmodells erzeugen.  Licht emittierende Objekte werden √ºberzeugender und Lichtreflexionen erhalten eine zus√§tzliche Strahlung. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//... float separation = 3; int samples = 15; float threshold = 0.5; float amount = 1; // ...</span></span></code> </pre> <br>  Sie k√∂nnen diese Einstellungen nach Ihren W√ºnschen anpassen.  Die Trennung vergr√∂√üert die Unsch√§rfe.  Proben bestimmen die St√§rke der Unsch√§rfe.  Der Schwellenwert bestimmt, was von diesem Effekt betroffen ist und was nicht.  Menge steuert die Menge der Bl√ºtenausgabe. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int size = samples; int size2 = size * size; int x = 0; int y = 0; // ... float value = 0; vec4 result = vec4(0); vec4 color = vec4(0); // ... for (int i = 0; i &lt; size2; ++i) { // ... } // ...</span></span></code> </pre> <br>  Diese Technik beginnt mit dem √úbergeben von <code>samples</code> Fenstergr√∂√üe an <code>samples</code> die relativ zum aktuellen Fragment zentriert sind.  Es sieht aus wie ein Fenster zum Erstellen von Pfaden. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... color = texture ( bloomTexture , ( gl_FragCoord.xy + vec2(x * separation, y * separation) ) / texSize ); value = ((0.3 * color.r) + (0.59 * color.g) + (0.11 * color.b)); if (value &lt; threshold) { color = vec4(0); } result += color; // ...</span></span></code> </pre> <br>  Dieser Code ermittelt die Farbe aus der eingehenden Textur und wandelt die Werte f√ºr Rot, Gr√ºn und Blau in einen Graustufenwert um.  Wenn der Wert in Graustufen unter dem Schwellenwert liegt, wird diese Farbe verworfen und schwarz. <br><br>  Beim Durchlaufen aller Proben im Fenster werden alle ihre Werte im <code>result</code> akkumuliert. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... result = result / size2; // ...</span></span></code> </pre> <br>  Nachdem er die Probensammlung abgeschlossen hat, dividiert er die Summe der Farbmuster durch die Anzahl der entnommenen Proben.  Das Ergebnis ist die mittlere Farbe des Fragments selbst und seiner Nachbarn.  Auf diese Weise erhalten wir f√ºr jedes Fragment ein verschwommenes Bild.  Diese Art von Unsch√§rfe wird als Box-Unsch√§rfe bezeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/16f/ea4/f9016fea492bc7b136ef6437a683c937.gif"></div><br>  Hier sehen Sie den Prozess der Ausf√ºhrung des Bloom-Algorithmus. <br><br><h3>  Quellcode </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">bloom.frag</a> </li></ul><br><h2>  Screen Space Ambient Occlusion (SSAO) </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/5ab/5bf/f935ab5bf4794caae3be90b611ad771c.gif"></div><br>  SSAO ist einer der Effekte, von denen Sie nicht wissen, dass sie existieren, aber sobald Sie wissen, dass Sie ohne sie nicht mehr leben k√∂nnen.  Er kann eine mittelm√§√üige Szene in eine erstaunliche verwandeln!  In statischen Szenen kann Umgebungsokklusion in die Textur eingebrannt werden, aber f√ºr dynamischere Szenen ben√∂tigen wir einen Shader.  SSAO ist eine der ausgefeilteren Schattierungstechniken, aber sobald Sie es herausgefunden haben, werden Sie ein Master-Shader. <br><br>  Beachten Sie, dass der Begriff ‚ÄûBildschirmbereich‚Äú im Titel nicht ganz korrekt ist, da nicht alle Berechnungen im Bildschirmbereich ausgef√ºhrt werden. <br><br><h3>  Eingehende Daten </h3><br>  Der SSAO-Shader ben√∂tigt die folgende Eingabe. <br><br><ul><li>  Vektoren von Scheitelpunktpositionen im Betrachtungsraum. </li><li>  Normale Vektoren zu den Eckpunkten im Betrachtungsraum. </li><li>  Abtastvektoren im Tangentenraum. </li><li>  Rauschvektoren im Tangentenraum. </li><li>  Die Projektionsmatrix auf dem Kameraobjektiv. </li></ul><br><h3>  Position </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/f36/d42/2d2f36d425c2596288d8982158687354.png"></div><br>  Es ist nicht erforderlich, Scheitelpunktpositionen in der Bildpuffertextur zu speichern.  Wir k√∂nnen sie aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">dem Kameratiefenpuffer</a> neu erstellen.  Ich schreibe einen Leitfaden f√ºr Anf√§nger, daher werden wir diese Optimierung nicht verwenden und sofort zur Sache kommen.  In Ihrer Implementierung k√∂nnen Sie den Tiefenpuffer problemlos verwenden. <br><br><pre> <code class="cpp hljs">PT(Texture) depthTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(<span class="hljs-string"><span class="hljs-string">"depthTexture"</span></span>); depthTexture-&gt;set_format(Texture::Format::F_depth_component32); PT(GraphicsOutput) depthBuffer = graphicsOutput-&gt;make_texture_buffer(<span class="hljs-string"><span class="hljs-string">"depthBuffer"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, depthTexture); depthBuffer-&gt;set_clear_color(LVecBase4f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); NodePath depthCameraNP = window-&gt;make_camera(); DCAST(Camera, depthCameraNP.node())-&gt;set_lens(window-&gt;get_camera(<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;get_lens()); PT(DisplayRegion) depthBufferRegion = depthBuffer-&gt;make_display_region(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); depthBufferRegion-&gt;set_camera(depthCameraNP);</code> </pre> <br>  Wenn Sie sich f√ºr die Verwendung des Tiefenpuffers entscheiden, k√∂nnen Sie ihn wie folgt in Panda3D konfigurieren. <br><br><pre> <code class="cpp hljs">in vec4 vertexPosition; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fragColor = vertexPosition; }</code> </pre> <br>  Hier ist ein einfacher Shader zum Rendern von Scheitelpunktpositionen im Anzeigebereich in eine Bildpuffertextur.  Eine schwierigere Aufgabe besteht darin, die Textur des Bildpuffers so einzustellen, dass die von ihm erhaltenen Komponenten des Fragmentvektors nicht auf das Intervall <code>[0, 1]</code> sind und dass jedes eine ausreichend hohe Genauigkeit (eine ausreichend gro√üe Anzahl von Bits) aufweist.  Wenn beispielsweise eine interpolierte Scheitelpunktposition <code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code> , k√∂nnen Sie sie nicht als <code>&lt;0.0, 0.0, 1.0&gt;</code> in der Textur speichern. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... FrameBufferProperties fbp = FrameBufferProperties::get_default(); // ... fbp.set_rgba_bits(32, 32, 32, 32); fbp.set_rgb_color(true); fbp.set_float_color(true); // ...</span></span></code> </pre> <br>  Hier ist ein Beispielcode, der eine Bildpuffertextur zum Speichern von Scheitelpunktpositionen vorbereitet.  Er ben√∂tigt 32 Bit f√ºr Rot, Gr√ºn, Blau und Alpha, daher deaktiviert er die Einschr√§nkung von Werten um das Intervall <code>[0, 1]</code> .  Der Aufruf von <code>set_rgba_bits(32, 32, 32, 32)</code> legt das <code>set_rgba_bits(32, 32, 32, 32)</code> und deaktiviert die Einschr√§nkung. <br><br><pre> <code class="cpp hljs"> glTexImage2D ( GL_TEXTURE_2D , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB32F , <span class="hljs-number"><span class="hljs-number">1200</span></span> , <span class="hljs-number"><span class="hljs-number">900</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB , GL_FLOAT , <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> );</code> </pre> <br>  Hier ist ein √§hnlicher Aufruf von OpenGL.  <code>GL_RGB32F</code> setzt die Bits und deaktiviert die Einschr√§nkung. <br><br><blockquote>  Wenn der Farbpuffer ein festes Komma hat, sind die Komponenten der Anfangs- und Endwerte sowie der Mischungsindizes vor der Berechnung der Mischungsgleichung f√ºr die vorzeichenlosen normalisierten und vorzeichenbehafteten normalisierten Farbpuffer auf [0, 1] bzw. [‚Äì1, 1] begrenzt.  Wenn der Farbpuffer einen Gleitkomma hat, ist die Einschr√§nkung nicht erf√ºllt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Quelle</a> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17b/2d0/2ad/17b2d02ad53c411dc251d90fdc16fdf3.png"></div><br>  Hier sehen Sie die Positionen der Eckpunkte;  Die y-Achse ist oben. <br><br>  Denken Sie daran, dass Panda3D die z-Achse als nach oben zeigenden Vektor definiert, w√§hrend in OpenGL die y-Achse nach oben zeigt.  Der Positions-Shader zeigt die Positionen von Scheitelpunkten mit einem z nach oben an, da in Panda3D <br>  Der <code>gl-coordinate-system default</code> ist konfiguriert. <br><br><h3>  Normal </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/064/9c5/0c40649c525edd7bcf3c829d6e948789.gif"></div><br>  F√ºr die korrekte Ausrichtung der im SSAO-Shader erhaltenen Samples ben√∂tigen wir die Normalen zu den Eckpunkten.  Der Beispielcode generiert mehrere √ºber die Hemisph√§re verteilte Abtastvektoren. Sie k√∂nnen jedoch die Kugel verwenden und das Problem der Notwendigkeit von Normalen vollst√§ndig l√∂sen. <br><br><pre> <code class="cpp hljs">in vec3 vertexNormal; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 normal = normalize(vertexNormal); fragColor = vec4(normal, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Wie der Positions-Shader ist der normale Shader sehr einfach.  Denken Sie daran, die Normalen auf die Eckpunkte zu normalisieren, und denken Sie daran, dass sie sich im Betrachtungsraum befinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/a82/f00/57ba82f003b0ab9c2aafa7c9affa28bb.gif"></div><br>  Die Normalen zu den Eckpunkten werden hier gezeigt;  Die y-Achse ist oben. <br><br>  Denken Sie daran, dass Panda3D die z-Achse als Aufw√§rtsvektor und OpenGL als y-Achse betrachtet.  Der normale Shader zeigt Scheitelpunktpositionen mit der z-Achse nach oben an, da in Panda3D die <code>gl-coordinate-system default</code> konfiguriert ist. <br><br><h3>  Proben </h3><br>  Um den Umgebungsokklusionswert f√ºr ein einzelnes Fragment zu bestimmen, m√ºssen wir die Umgebung abtasten. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; numberOfSamples; ++i) { LVecBase3f sample = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) ).normalized(); float rand = randomFloats(generator); sample[0] *= rand; sample[1] *= rand; sample[2] *= rand; float scale = (float) i / (float) numberOfSamples; scale = lerp(0.1, 1.0, scale * scale); sample[0] *= scale; sample[1] *= scale; sample[2] *= scale; ssaoSamples.push_back(sample); } // ...</span></span></code> </pre> <br>  Der Beispielcode generiert 64 Zufallsstichproben, die auf einer Halbkugel verteilt sind.  Diese <code>ssaoSamples</code> werden an den SSAO-Shader √ºbergeben. <br><br><pre> <code class="cpp hljs"> LVecBase3f sample = LVecBase3f ( randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> ).normalized();</code> </pre> <br>  Wenn Sie Ihre Stichproben auf eine Kugel verteilen m√∂chten, √§ndern Sie das Intervall der Zufallskomponente z so, dass es sich von minus eins zu eins √§ndert. <br><br><h3>  Der L√§rm </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; 16; ++i) { LVecBase3f noise = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , 0.0 ); ssaoNoise.push_back(noise); } // ...</span></span></code> </pre> <br>  Um den abgetasteten Bereich gut abzudecken, m√ºssen wir Rauschvektoren erzeugen.  Diese Rauschvektoren k√∂nnen Proben um die Oberseite der Oberfl√§che drehen. <br><br><h3>  Umgebungsokklusion </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c1d/bb4/d35c1dbb4e0e9dfeedc3bd4285f26004.gif"></div><br>  SSAO erf√ºllt seine Aufgabe, indem es den Betrachtungsraum um das Fragment herum abtastet.  Je mehr Proben sich unter der Oberfl√§che befinden, desto dunkler ist die Farbe des Fragments.  Diese Proben befinden sich im Fragment und zeigen in der allgemeinen Richtung der Normalen zum Scheitelpunkt an.  Jedes Sample wird verwendet, um nach einer Position in der Textur der Bildpufferposition zu suchen.  Die zur√ºckgegebene Position wird mit der Probe verglichen.  Wenn die Probe weiter von der Kamera entfernt ist als die Position, wird die Probe in Richtung des Fragments verschlossen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/b9a/f1d/cb7b9af1d4dc613f337da5a253ef5a8c.gif"></div><br>  Hier sehen Sie einen Raum √ºber der Oberfl√§che, der zur Okklusion abgetastet wurde. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float radius = 1.1; float bias = 0.026; float lowerRange = -2; float upperRange = 2; // ...</span></span></code> </pre> <br>  Wie einige andere Techniken verf√ºgt der SSAO-Shader √ºber mehrere Steuerparameter, die ge√§ndert werden k√∂nnen, um das gew√ºnschte Erscheinungsbild zu erzielen.  Die Vorspannung wird zum Abstand von der Probe zur Kamera addiert.  Dieser Parameter kann zur Bek√§mpfung von Flecken verwendet werden.  Der Radius vergr√∂√üert oder verkleinert den Abdeckungsbereich des Probenraums.  LowerRange und UpperRange √§ndern den Standardbereich der Faktormetrik von <code>[0, 1]</code> auf einen beliebigen Wert, den Sie ausw√§hlen.  Durch Erh√∂hen der Reichweite k√∂nnen Sie den Kontrast erh√∂hen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); vec3 normal = texture(normalTexture, texCoord).xyz; int noiseX = int(gl_FragCoord.x - 0.5) % 4; int noiseY = int(gl_FragCoord.y - 0.5) % 4; vec3 random = noise[noiseX + (noiseY * 4)]; // ...</span></span></code> </pre> <br>  Wir erhalten den Positions-, Normal- und Zufallsvektor zur weiteren Verwendung.  Denken Sie daran, dass im Codebeispiel 16 Zufallsvektoren erstellt wurden.  Ein zuf√§lliger Vektor wird basierend auf der Bildschirmposition der aktuellen Fragmente ausgew√§hlt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 tangent = normalize(random - normal * dot(random, normal)); vec3 binormal = cross(normal, tangent); mat3 tbn = mat3(tangent, binormal, normal); // ...</span></span></code> </pre> <br>  Unter Verwendung eines Zufallsvektors und eines Normalenvektors sammeln wir die Matrix aus Tangens, Binormalem und Normalem.  Wir ben√∂tigen diese Matrix, um die Probenvektoren vom Tangentenraum in den Vermessungsraum zu transformieren. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float occlusion = NUM_SAMPLES; for (int i = 0; i &lt; NUM_SAMPLES; ++i) { // ... } // ...</span></span></code> </pre> <br>  Mit einer Matrix kann der Shader alle Samples in der Schleife durchlaufen und die Anzahl der unge√∂ffneten abziehen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 sample = tbn * samples[i]; sample = position.xyz + sample * radius; // ...</span></span></code> </pre> <br>  Platzieren Sie die Probe mithilfe der Matrix neben der Scheitelpunkt- / Fragmentposition und skalieren Sie sie um den Radius. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offset = vec4(sample, 1.0); offset = lensProjection * offset; offset.xyz /= offset.w; offset.xyz = offset.xyz * 0.5 + 0.5; // ...</span></span></code> </pre> <br>  Anhand der Position der Probe im Betrachtungsraum transformieren wir sie vom Betrachtungsraum in den Beschneidungsraum und dann in den UV-Raum. <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">-1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Vergessen Sie nicht, dass die Komponenten des Beschneidungsraums im Bereich von minus eins bis eins liegen und die UV-Koordinaten im Bereich von null bis eins liegen.  Um die Koordinaten des Beschneidungsraums in UV-Koordinaten umzuwandeln, multiplizieren Sie sie mit einer Sekunde und addieren Sie eine Sekunde. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offsetPosition = texture(positionTexture, offset.xy); float occluded = 0; if (sample.y + bias &lt;= offsetPosition.y) { occluded = 0; } else { occluded = 1; } // ...</span></span></code> </pre> <br>  Unter Verwendung der UV-Versatzkoordinaten, die durch Projizieren der 3D-Probe auf die 2D-Positionstextur erhalten wurden, finden wir den entsprechenden Positionsvektor.  Dies f√ºhrt uns vom Betrachtungsraum zum Beschneidungsraum zum UV-Raum und dann zur√ºck zum Betrachtungsraum.  Der Shader f√ºhrt diese Schleife aus, um festzustellen, ob sich hinter der Probe, an der Probenposition oder vor der Probe eine Geometrie befindet.  Befindet sich die Probe vor oder in einer Geometrie, wird diese Probe in Bezug auf das √ºberlappende Fragment einfach nicht ber√ºcksichtigt.  Befindet sich die Probe hinter einer Geometrie, wird diese Probe relativ zum √ºberlappenden Fragment ber√ºcksichtigt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float intensity = smoothstep ( 0.0 , 1.0 , radius / abs(position.y - offsetPosition.y) ); occluded *= intensity; occlusion -= occluded; // ...</span></span></code> </pre> <br>  F√ºgen Sie dieser abgetasteten Position nun Gewicht hinzu, basierend darauf, wie weit sie innerhalb oder au√üerhalb des Radius liegt.  Subtrahieren Sie dann diese Probe von der Okklusionsmetrik, da davon ausgegangen wird, dass sich alle Proben vor der Schleife √ºberlappten. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... occlusion /= NUM_SAMPLES; // ... fragColor = vec4(vec3(occlusion), position.a); // ...</span></span></code> </pre> <br>  Teilen Sie die Anzahl der √ºberlappenden durch die Anzahl der Proben, um den Okklusionsindikator vom Intervall <code>[0, NUM_SAMPLES]</code> in das Intervall <code>[0, 1]</code> <code>[0, NUM_SAMPLES]</code> .  Null bedeutet vollst√§ndige Okklusion, Einheiten bedeuten keine Okklusion.  Weisen Sie nun der Fragmentfarbe die Okklusionsmetrik zu, und fertig. <br><br>  Bitte beachten Sie, dass dem Beispielkanal im Beispielcode der Alpha-Wert der Positionstextur aus dem Bildpuffer zugewiesen wird, um √ºberlappende Hintergr√ºnde zu vermeiden. <br><br><h3>  Unsch√§rfe </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/566/2a7/5b15662a7c46db6b8102fe9eabae17c9.gif"></div><br>  Die Textur des SSAO-Bildpuffers ist etwas verrauscht, daher sollten Sie ihn zum Gl√§tten verwischen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( ssaoTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ).rgb; xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  Der SSAO-Unsch√§rfeshader ist eine normale Box-Unsch√§rfe.  Wie der Bloom-Shader zeichnet er ein Fenster √ºber die eingehende Textur und mittelt jedes Fragment mit den Werten seiner Nachbarn. <br><br>  Beachten Sie, dass <code>parameters.x</code> ein Trennungsparameter ist. <br><br><h3>  Umgebungsfarbe </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 ssaoBlurTexSize = textureSize(ssaoBlurTexture, 0).xy; vec2 ssaoBlurTexCoord = gl_FragCoord.xy / ssaoBlurTexSize; float ssao = texture(ssaoBlurTexture, ssaoBlurTexCoord).r; vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex * ssao; // ...</span></span></code> </pre> <br>  Die letzte Herausforderung f√ºr SSAO liegt erneut in den Beleuchtungsberechnungen.  Hier sehen wir, wie die Okklusion im Textur-SSAO-Texturpuffer gefunden und in die Berechnung des Umgebungslichts einbezogen wird. <br><br><h3>  Quellcode </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">position.frag</a> </li><li>  <a href="">normal.frag</a> </li><li>  <a href="">ssao.frag</a> </li><li>  <a href="">blur.frag</a> </li></ul><br><h2>  Sch√§rfentiefe </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/eb0/10f/6efeb010f4623ff49b928d72550f7985.gif"></div><br>  Die Sch√§rfentiefe ist auch ein solcher Effekt, da man gelernt hat, ohne was man nicht leben kann.  Aus k√ºnstlerischer Sicht k√∂nnen Sie damit die Aufmerksamkeit des Betrachters auf ein bestimmtes Objekt lenken.  Im allgemeinen Fall tr√§gt die Sch√§rfentiefe auf Kosten eines kleinen Aufwands zu einem gro√üen Teil des Realismus bei. <br><br><h3>  Im Fokus </h3><br>  Der erste Schritt besteht darin, die Szene vollst√§ndig scharf zu stellen.  Rendern Sie es in die Frame Buffer-Textur.  Dies ist einer der Eingabewerte f√ºr den Tiefensch√§rfepuffer. <br><br><h3>  Unscharf </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 result = vec4(0); for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( blurTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ); xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  Der zweite Schritt besteht darin, die Szene so zu verwischen, als w√§re sie v√∂llig unscharf.  Wie bei Bloom und SSAO k√∂nnen Sie Box Blur verwenden.  Rendern Sie diese defokussierte Szene in die Bildpuffertextur.  Dies ist ein weiterer Eingabewert f√ºr die Tiefensch√§rfe. <br><br>  Beachten Sie, dass <code>parameters.x</code> ein Trennungsparameter ist. <br><br><h3>  Verwirrung </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d68/067/83a/d6806783a567c4708d8f13dcb0763f7c.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float focalLengthSharpness = 100; float blurRate = 6; // ...</span></span></code> </pre> <br>  Sie k√∂nnen diese Optionen nach Ihrem Geschmack anpassen.  <code>focalLengthSharpness</code> beeinflusst, wie defokussiert die Szene auf Brennweite ist.  Je kleiner die <code>focalLengthSharpness</code> , desto defokussierter ist die Szene auf die Brennweite.  <code>blurRate</code> beeinflusst die Geschwindigkeit der Unsch√§rfe der Szene, wenn Sie sich von der Brennweite entfernen.  Je kleiner die <code>blurRate</code> , <code>blurRate</code> weniger unscharf wird die Szene, wenn Sie sich vom Fokuspunkt entfernen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 focusColor = texture(focusTexture, texCoord); vec4 outOfFocusColor = texture(outOfFocusTexture, texCoord); // ...</span></span></code> </pre> <br>  Wir brauchen Farben im Fokus und in einem defokussierten Bild. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); // ...</span></span></code> </pre> <br>  M√∂glicherweise ben√∂tigen wir auch die Position des Scheitelpunkts im Betrachtungsraum.  Sie k√∂nnen die Positionstextur aus dem f√ºr SSAO verwendeten Bildpuffer erneut anwenden. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float blur = clamp ( pow ( blurRate , abs(position.y - focalLength.x) ) / focalLengthSharpness , 0 , 1 ); // ... fragColor = mix(focusColor, outOfFocusColor, blur); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und hier findet die Verwirrung statt. </font><font style="vertical-align: inherit;">Je n√§her </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an einem, desto mehr wird es verwenden </font></font><code>outOfFocusColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ein Wert von Null </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass dieses Fragment vollst√§ndig fokussiert ist. </font><font style="vertical-align: inherit;">Mit </font></font><code>blur &gt;= 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Fragment wird vollst√§ndig defokussiert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur.frag</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sch√§rfentiefe.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posterisierung </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/078/84d/f1807884d79c5c73915ce9adf6ead5cb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Posterisierung oder Farbabtastung wird die Anzahl der eindeutigen Farben in einem Bild reduziert. </font><font style="vertical-align: inherit;">Mit diesem Shader k√∂nnen Sie dem Spiel einen Comic- oder Retro-Look verleihen. </font><font style="vertical-align: inherit;">Wenn Sie es mit einem Umriss kombinieren, erhalten Sie einen echten Cartoon-Stil.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float levels = 8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen mit diesem Parameter experimentieren. </font><font style="vertical-align: inherit;">Je gr√∂√üer es ist, desto mehr Blumen bleiben √ºbrig.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 texColor = texture(posterizeTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir brauchen die eingehende Farbe. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 grey = vec3((texColor.r + texColor.g + texColor.b) / 3.0); vec3 grey1 = grey; grey = floor(grey * levels) / levels; texColor.rgb += (grey - grey1); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe eine solche Methode der Posterisierung nicht gesehen. </font><font style="vertical-align: inherit;">Nachdem ich es √ºberpr√ºft hatte, stellte ich fest, dass es im Vergleich zu herk√∂mmlichen Methoden sch√∂nere Ergebnisse liefert. </font><font style="vertical-align: inherit;">Um die Farbpalette zu verkleinern, konvertieren Sie zuerst die Farbe in einen Graustufenwert. </font><font style="vertical-align: inherit;">Wir diskretisieren die Farbe, indem wir sie an eine der Ebenen binden. </font><font style="vertical-align: inherit;">Wir berechnen die Differenz zwischen dem diskretisierten Wert in Graustufen und dem nicht diskretisierten Wert in Graustufen. </font><font style="vertical-align: inherit;">F√ºgen Sie diesen Unterschied zur Eingabefarbe hinzu. </font><font style="vertical-align: inherit;">Dieser Unterschied ist der Betrag, um den die Farbe zunehmen / abnehmen muss, um einen diskretisierten Wert in Graustufen zu erreichen.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texColor; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergessen Sie nicht, den Wert der Eingabefarbe der Farbe des Fragments zuzuweisen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cel Schattierung </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/f9c/133/2d1f9c1333960c0299388fc51323a8b3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Posterisierung kann einem Bild das Aussehen einer Cel-Schattierung verleihen, da bei der Cel-Schattierung diffuse und diffuse Farben in diskrete Schattierungen diskretisiert werden. </font><font style="vertical-align: inherit;">Wir m√∂chten nur feste, diffuse Farben ohne feine Details der normalen Karte und einen kleinen Wert verwenden </font></font><code>levels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posterize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixelisierung </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/0b9/9bc/3960b99bc2f1fa900c40a1c9f32169bc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Pixelisierung eines 3D-Spiels kann ihm ein interessantes Aussehen verleihen oder Zeit sparen, die f√ºr die manuelle Erstellung der gesamten Pixelgrafik aufgewendet worden w√§re. </font><font style="vertical-align: inherit;">Kombinieren Sie es mit Posterisierung, um einen echten Retro-Look zu kreieren.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int pixelSize = 5; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen die Pixelgr√∂√üe selbst anpassen. </font><font style="vertical-align: inherit;">Je gr√∂√üer es ist, desto rauer wird das Bild.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/818/aee/413818aee5509763cc383f800b837cfb.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float x = int(gl_FragCoord.x) % pixelSize; float y = int(gl_FragCoord.y) % pixelSize; x = floor(pixelSize / 2.0) - x; y = floor(pixelSize / 2.0) - y; x = gl_FragCoord.x + x; y = gl_FragCoord.y + y; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Technik bringt jedes Fragment in der Mitte seines n√§chsten nicht √ºberlappenden Fensters in Pixelgr√∂√üe an. </font><font style="vertical-align: inherit;">Diese Fenster werden √ºber der eingehenden Textur ausgerichtet. </font><font style="vertical-align: inherit;">Fragmente in der Mitte des Fensters bestimmen die Farbe anderer Fragmente in ihrem Fenster.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texture(pixelizeTexture, vec2(x, y) / texSize); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir die Koordinate des gew√ºnschten Fragments bestimmt haben, nehmen Sie seine Farbe aus der eingehenden Textur und weisen Sie sie der Fragmentfarbe zu. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixelize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sch√§rfen </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/674/617/b52674617a0733ee1fe0d525b0053750.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Sch√§rfeeffekt (Sch√§rfen) erh√∂ht den Kontrast an den Bildr√§ndern. </font><font style="vertical-align: inherit;">Es ist praktisch, wenn sich die Grafik als zu weich herausstellt.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch √Ñndern des Werts k√∂nnen wir die Gr√∂√üe der Sch√§rfe des Ergebnisses steuern. </font><font style="vertical-align: inherit;">Wenn der Wert Null ist, √§ndert sich das Bild nicht. </font><font style="vertical-align: inherit;">Bei negativen Werten sieht das Bild merkw√ºrdig aus.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float neighbor = amount * -1; float center = amount * 4 + 1; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benachbarte Fragmente werden mit multipliziert </font></font><code>amount * -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das aktuelle Fragment wird mit multipliziert </font></font><code>amount * 4 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 color = texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 1) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x - 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 0) / texSize).rgb * center + texture(sharpenTexture, vec2(gl_FragCoord.x + 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y - 1) / texSize).rgb * neighbor ; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benachbarte Fragmente befinden sich oben, unten, links und rechts. </font><font style="vertical-align: inherit;">Nach dem Multiplizieren der Nachbarn und des aktuellen Fragments mit ihren Werten wird das Ergebnis addiert.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = vec4(color, texture(sharpenTexture, texCoord).a); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Menge ist die endg√ºltige Farbe des Fragments. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sharpen.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filmkorn </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/16e/232/2f316e232598d07fa8114f8db32c12a7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Filmkorn (in kleinen Dosen und nicht wie im Beispiel) kann Realismus hinzuf√ºgen, der unsichtbar ist, bis dieser Effekt beseitigt ist. </font><font style="vertical-align: inherit;">Normalerweise sind dies die Unvollkommenheiten, die das digital erzeugte Bild √ºberzeugender machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass die Filmk√∂rnung normalerweise der letzte Effekt ist, der auf das Bild angewendet wird, bevor es angezeigt wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.1; // ...</span></span></code> </pre> <br> <code>amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steuert die Sichtbarkeit der Filmk√∂rnung. </font><font style="vertical-align: inherit;">Je h√∂her der Wert, desto mehr ‚ÄûSchnee‚Äú im Bild.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zuf√§llige Helligkeit </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform float osg_FrameTime; //... float toRadians = 3.14 / 180; //... float randomIntensity = fract ( 10000 * sin ( ( gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime ) * toRadians ) ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Code berechnet die zuf√§llige Helligkeit, die zum Anpassen des Werts erforderlich ist. </font></font><br><br><pre> <code class="cpp hljs">Time Since F1 = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> Frame Number = F1 F3 F4 F5 F6 osg_FrameTime = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert </font></font><code>osg_FrameTime</code> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panda3D zur Verf√ºgung gestellt. </font><font style="vertical-align: inherit;">Eine Frame-Zeit ist ein Zeitstempel mit Informationen dar√ºber, wie viele Sekunden seit dem ersten Frame vergangen sind. </font><font style="vertical-align: inherit;">Der Beispielcode verwendet es, um die K√∂rnung des Films zu animieren, die </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in jedem Bild unterschiedlich ist.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... ( gl_FragCoord.x + gl_FragCoord.y * 8009 // Large number here. // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr statische K√∂rnung m√ºssen die Filme durch eine </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gro√üe Anzahl ersetzt werden. </font><font style="vertical-align: inherit;">Um zu vermeiden, dass Muster angezeigt werden, k√∂nnen Sie verschiedene Zahlen ausprobieren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/2bd/6d2/3582bd6d2d67eb5ac1fdcdf8d52800e6.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... * sin ( ( gl_FragCoord.x + gl_FragCoord.y * someNumber // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Punkte oder Flecken von Filmk√∂rnung zu erzeugen, werden beide Koordinaten sowie x und y verwendet. </font><font style="vertical-align: inherit;">Wenn Sie x verwenden, werden nur vertikale Linien angezeigt. Wenn Sie y verwenden, werden nur horizontale Linien angezeigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Code wird eine Koordinate mit einer anderen multipliziert, um die diagonale Symmetrie zu zerst√∂ren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/ad6/d5a/4c0ad6d5ada5d533b6dc31bbfa7aa0fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich k√∂nnen Sie den Koordinatenmultiplikator entfernen und einen v√∂llig akzeptablen Regeneffekt erzielen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass Sie die Ausgabe </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit </font><font style="vertical-align: inherit;">multiplizieren m√ºssen, um den Regeneffekt zu animieren </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experimentieren Sie mit den x- und y-Koordinaten, um die Richtung des Regens zu √§ndern. </font><font style="vertical-align: inherit;">Lassen Sie f√ºr eine Dusche nach unten nur die x-Koordinate.</font></font><br><br><pre> <code class="cpp hljs">input = (gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime) * toRadians frame(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) =</code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird als Hash-Funktion verwendet. </font><font style="vertical-align: inherit;">Fragmentkoordinaten werden mit Ausgabewerten gehasht </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dank dessen erscheint eine praktische Eigenschaft - unabh√§ngig von den Eingabedaten (gro√ü oder klein) liegt das Ausgabeintervall im Bereich von minus eins bis eins.</font></font><br><br><pre> <code class="cpp hljs">fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) = fract(<span class="hljs-number"><span class="hljs-number">6400.723818964882</span></span>) = <span class="hljs-number"><span class="hljs-number">0.723818964882</span></span></code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Kombination mit </font></font><code>fract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch als Pseudozufallszahlengenerator verwendet.</font></font><br><br><pre> <code class="cpp hljs">&gt;&gt;&gt; [<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(fract(<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x * toRadians)) * <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 0, 1, 2, 2, 3, 4, 4, 5, 6] &gt;&gt;&gt; [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fract(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10000</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(x * toRadians)) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 4, 8, 0, 2, 1, 7, 0, 0, 5]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich zuerst die erste Zahlenreihe und dann die zweite an. </font><font style="vertical-align: inherit;">Jede Zeile ist deterministisch, aber das Muster ist in der zweiten weniger auff√§llig als in der zweiten. </font><font style="vertical-align: inherit;">Daher wird </font></font><code>fract(10000 * sin(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Muster </font><font style="vertical-align: inherit;">trotz der Tatsache, dass die Ausgabe </font><font style="vertical-align: inherit;">deterministisch ist, viel schw√§cher erkannt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/6e7/f0f/b886e7f0feda6760c5fc87df6680680f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sehen wir, wie der Faktor </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuerst 1, dann 10, dann 100 und dann 1000 ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Multiplikator der Ausgabewerte zunimmt, wird das </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muster weniger wahrnehmbar. </font><font style="vertical-align: inherit;">Aus diesem Grund wird der Code </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit 10.000 multipliziert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmentfarbe </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 texSize = textureSize(filmGrainTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; vec4 color = texture(filmGrainTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertieren Sie die Koordinaten des Fragments in UV-Koordinaten. </font><font style="vertical-align: inherit;">Mit diesen UV-Koordinaten suchen wir nach der Texturfarbe f√ºr das aktuelle Fragment.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... amount *= randomIntensity; color.rgb += amount; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñndern Sie den Wert in eine zuf√§llige Helligkeit und f√ºgen Sie ihn der Farbe hinzu. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = color; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie die Farbe des Fragments ein und fertig. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">film-corn.frag</font></font></a> </li></ul><br><h2>  Danksagung </h2><br><ul><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Kiwi Soda Font</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453692/">https://habr.com/ru/post/de453692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453676/index.html">Verbindung zu Windows √ºber SSH wie unter Linux</a></li>
<li><a href="../de453678/index.html">So sehen Sie Nachhall oder Video√ºbertragung durch Ton durch Wasser - 2</a></li>
<li><a href="../de453682/index.html">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs. Teil 2. Programmcode</a></li>
<li><a href="../de453686/index.html">Sicherheitswoche 22: Bedrohungsstatistiken, Bankentrojaner und beliebte Exploits</a></li>
<li><a href="../de453688/index.html">Java ist nicht nur ein blutiges Unternehmen, sondern auch schnell latenzempfindliche Anwendungen</a></li>
<li><a href="../de453694/index.html">Stellen Sie wie unter Linux eine Verbindung zu Windows √ºber SSH her</a></li>
<li><a href="../de453696/index.html">Winkel-Zwei-Wege-Bindung, etwas verst√§ndnisvoller</a></li>
<li><a href="../de453698/index.html">Quanteninformation im Quantenbewusstsein</a></li>
<li><a href="../de453700/index.html">Lektionen zu SDL 2: Lektion 1 - Hallo, SDL 2</a></li>
<li><a href="../de453706/index.html">Wie ich die Zertifizierungspr√ºfung f√ºr Google Cloud Professional Data Engineer bestanden habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>