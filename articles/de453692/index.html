<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏻‍🤝‍🧑🏻 📕 👩🏾‍🏫 3D Game Shader für Anfänger: Effekte 👊🏻 👩🏼‍🤝‍👨🏿 💆🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Der erste Teil ] 

 Nachdem wir uns mit den Grundlagen befasst haben, implementieren wir in diesem Teil des Artikels Effekte wie Objektkonturen, Blo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3D Game Shader für Anfänger: Effekte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453692/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Teil</a> ] <br><br>  Nachdem wir uns mit den Grundlagen befasst haben, implementieren wir in diesem Teil des Artikels Effekte wie Objektkonturen, Bloom, SSAO, Unschärfe, Schärfentiefe, Pixelung und andere. <br><br><h2>  Umrisse </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/96f/9b2/3b896f9b246e1695fa908b4bdc145480.gif"></div><br>  Das Erstellen von Konturen um die Geometrie der Szene verleiht dem Spiel ein einzigartiges Aussehen, das Comics oder Cartoons ähnelt. <br><br><h3>  Diffuses Material </h3><br>  Der Contour Shader benötigt eine Eingabetextur, um die Kanten zu erkennen und zu färben.  Kandidaten für eine solche eingehende Textur können eine diffuse Farbe aus Materialien, Farben aus diffusen Texturen, Scheitelpunktnormalen oder sogar Farben aus normalen Karten sein. <br><br><pre><code class="cpp hljs">uniform <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> vec4 diffuse ; } p3d_Material; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 diffuseColor = p3d_Material.diffuse.rgb; fragColor = vec4(diffuseColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Dies ist ein kleiner Fragment-Shader, der die diffuse Farbe eines Geometriematerials in eine Rahmenpuffertextur umwandelt.  Diese diffuse Farbtextur aus dem Bildspeicher ist die Eingabetextur für den Pfad-Shader. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/abd/05c/f0babd05caf7104156c15929995c9279.gif"></div><br>  Dies ist die Textur der diffusen Farbe des Materials aus dem Rahmenpuffer, der die Farben anzeigt, die wir in Blender festgelegt haben.  Der Kontur-Shader erkennt die Kanten in der Szene und färbt sie. <br><br>  Es ist zu beachten, dass die diffuse Farbe von Materialien nicht funktioniert, wenn bestimmte Teile der Szene keine eigene diffuse Farbe des Materials haben. <br><br><h3>  Kanten erstellen </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/a0d/57a/33aa0d57aeba90366ddd95865ea0d6c6.gif"></div><br>  Das Erstellen von Kanten ähnelt der Verwendung von Kantenerkennungsfiltern in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GIMP</a> . <br><br>  Alle Berechnungen für diese Schattierungstechnik werden in einem Fragment-Shader durchgeführt.  Um Konturen für den Scheitelpunkt-Shader zu erstellen, müssen vier Scheitelpunkte des rechteckigen Netzes an die Ausgabe übergeben werden, damit sie zum Bildschirm passen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D materialDiffuseTexture; // ... vec2 texSize = textureSize(materialDiffuseTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy; // ...</span></span></code> </pre> <br>  Bevor Sie beginnen, die Kanten zu erkennen, müssen Sie die eingehende Textur vorbereiten, mit der wir arbeiten werden.  Da die Textur eine Bildschirmgröße hat, können wir die UV-Koordinaten berechnen, wobei wir die Koordinaten des Fragments und die Größe der eingehenden Textur kennen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int separation = 1; // ...</span></span></code> </pre> <br>  <code>separation</code> kann nach Ihrem Geschmack angepasst werden.  Je größer der Abstand ist, desto dicker sind die Kanten oder Linien. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... vec4 mx = vec4(0); vec4 mn = vec4(1); int x = -1; int y = -1; for (int i = 0; i &lt; 9; ++i) { vec4 color = texture ( materialDiffuseTexture , (texCoord + (vec2(x, y) * separation)) / texSize ); mx = max(color, mx); mn = min(color, mn); x += 1; if (x &gt;= 2) { x = -1; y += 1; } } float alpha = ((mx.r + mx.g + mx.b) / 3) - ((mn.r + mn.g + mn.b) / 3); if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/d24/e56/42fd24e5682700e1e7cd5186bebc33af.gif"></div><br>  Die Kantenerkennungstechnik findet Änderungen in den Farben der eingehenden Textur.  Wenn Sie sich auf das aktuelle Fragment konzentrieren, werden im Fenster 3x3-Fragmente die hellsten und dunkelsten Farben der neun Samples ermittelt.  Dann subtrahiert sie von der Helligkeit einer Farbe die Helligkeit einer anderen und erhält ihren Unterschied. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lineRgb = vec3(0.012, 0.014, 0.022); // ... vec4 lineColor = vec4(lineRgb, alpha); // ... fragColor = lineColor; // ...</span></span></code> </pre> <br>  Dieser Unterschied wird im Alphakanal der Ausgabefarbe verwendet.  Wenn es keinen Unterschied gibt, wird die Kante oder Linie nicht gezeichnet.  Wenn es einen Unterschied gibt, wird die Kante gezeichnet. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br>  Versuchen Sie, mit dem Schwellenwert zu experimentieren.  Jetzt ist es Null.  Jeder Wert ungleich Null wird zu einer Flanke. Dieser Schwellenwert kann geändert werden.  Dies ist besonders nützlich für lautere eingehende Texturen mit kleinen Unterschieden.  Bei einer verrauschten eingehenden Textur müssen Sie normalerweise nur für große Unterschiede Konturen erstellen. <br><br><h3>  Quellcode </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">material-diffuse.frag</a> </li><li>  <a href="">Outline.frag</a> </li></ul><br><h2>  Nebel </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/02c/e52/5af02ce52f813b27461f79e5dca5fe20.gif"></div><br>  Nebel (oder Nebel, wie er in Blender genannt wird) fügt der Szene atmosphärischen Dunst hinzu und erzeugt mysteriöse, erweichte, hervorstehende Teile.  Die hervorstehenden Teile erscheinen, wenn eine gewisse Geometrie plötzlich in die Pyramide der Kamerasichtbarkeit fällt. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_FogParameters { vec4 color ; float start ; float end ; } p3d_Fog; // ...</span></span></code> </pre> <br>  Panda3D verfügt über eine praktische Datenstruktur, die alle Nebelparameter enthält. Sie können sie jedoch manuell auf Ihren Shader übertragen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float fogIntensity = clamp ( ( p3d_Fog.end - vertexPosition.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; // ...</span></span></code> </pre> <br>  Im Codebeispiel wird ein lineares Modell verwendet, um die Helligkeit des Nebels zu berechnen, wenn Sie sich von der Kamera entfernen.  Stattdessen können Sie das Exponentialmodell verwenden.  Die Helligkeit des Nebels ist vor oder zu Beginn des Nebels Null.  Wenn sich die Scheitelpunktposition dem Ende des Nebels <code>fogIntensity</code> nähert sich <code>fogIntensity</code> Einheit.  Für alle Eckpunkte nach dem Ende des Nebels ist die <code>fogIntensity</code> von oben auf 1 begrenzt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = mix ( outputColor , p3d_Fog.color , fogIntensity ); // ...</span></span></code> </pre> <br>  Basierend auf der Helligkeit des Nebels mischen wir die Farbe des Nebels mit der Ausgabefarbe.  Wenn sich <code>fogIntensity</code> Einheit nähert, wird es immer weniger <code>outputColor</code> und immer mehr <code>outputColor</code> .  Wenn <code>fogIntensity</code> die Einheit erreicht, bleibt nur die Farbe des Nebels übrig. <br><br><h3>  Nebel auf den Konturen </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/ee8/d49/e1fee8d490abe10ecb798df618f183f7.gif"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D positionTexture; // ... vec4 position = texture(positionTexture, texCoord / texSize); float fogIntensity = clamp ( ( p3d_Fog.end - position.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; vec4 lineWithFogColor = mix ( lineColor , p3d_Fog.color , fogIntensity ); fragColor = vec4(lineWithFogColor.rgb, alpha); // ...</span></span></code> </pre> <br>  Der Path Shader bringt Nebel auf die Farben der Kanten, um ein ganzheitlicheres Bild zu erhalten.  Wenn er dies nicht tun würde, würde die Geometrie der Konturen durch Nebel verdeckt, was seltsam aussehen würde.  Er erzeugt jedoch immer noch Konturen an den äußersten Kanten der Geometrie der Bühne mit der Mühle, da die Kanten über die Geometrie hinausgehen - bis dahin, wo es keine Scheitelpunktpositionen gibt. <br><br>  <code>positionTexture</code> ist eine Bildpuffertextur, die die Positionen der Scheitelpunkte des Ansichtsbereichs enthält.  Sie werden dies erfahren, wenn wir den SSAO-Shader implementieren. <br><br><h3>  Quellcode </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">base.frag</a> </li><li>  <a href="">Outline.frag</a> </li></ul><br><h2>  Blüte </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/744/f35/31d744f35168ac87f609474998802b12.gif"></div><br>  Das Hinzufügen von Blüte zur Szene kann eine überzeugende Illusion des Beleuchtungsmodells erzeugen.  Licht emittierende Objekte werden überzeugender und Lichtreflexionen erhalten eine zusätzliche Strahlung. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//... float separation = 3; int samples = 15; float threshold = 0.5; float amount = 1; // ...</span></span></code> </pre> <br>  Sie können diese Einstellungen nach Ihren Wünschen anpassen.  Die Trennung vergrößert die Unschärfe.  Proben bestimmen die Stärke der Unschärfe.  Der Schwellenwert bestimmt, was von diesem Effekt betroffen ist und was nicht.  Menge steuert die Menge der Blütenausgabe. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int size = samples; int size2 = size * size; int x = 0; int y = 0; // ... float value = 0; vec4 result = vec4(0); vec4 color = vec4(0); // ... for (int i = 0; i &lt; size2; ++i) { // ... } // ...</span></span></code> </pre> <br>  Diese Technik beginnt mit dem Übergeben von <code>samples</code> Fenstergröße an <code>samples</code> die relativ zum aktuellen Fragment zentriert sind.  Es sieht aus wie ein Fenster zum Erstellen von Pfaden. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... color = texture ( bloomTexture , ( gl_FragCoord.xy + vec2(x * separation, y * separation) ) / texSize ); value = ((0.3 * color.r) + (0.59 * color.g) + (0.11 * color.b)); if (value &lt; threshold) { color = vec4(0); } result += color; // ...</span></span></code> </pre> <br>  Dieser Code ermittelt die Farbe aus der eingehenden Textur und wandelt die Werte für Rot, Grün und Blau in einen Graustufenwert um.  Wenn der Wert in Graustufen unter dem Schwellenwert liegt, wird diese Farbe verworfen und schwarz. <br><br>  Beim Durchlaufen aller Proben im Fenster werden alle ihre Werte im <code>result</code> akkumuliert. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... result = result / size2; // ...</span></span></code> </pre> <br>  Nachdem er die Probensammlung abgeschlossen hat, dividiert er die Summe der Farbmuster durch die Anzahl der entnommenen Proben.  Das Ergebnis ist die mittlere Farbe des Fragments selbst und seiner Nachbarn.  Auf diese Weise erhalten wir für jedes Fragment ein verschwommenes Bild.  Diese Art von Unschärfe wird als Box-Unschärfe bezeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/16f/ea4/f9016fea492bc7b136ef6437a683c937.gif"></div><br>  Hier sehen Sie den Prozess der Ausführung des Bloom-Algorithmus. <br><br><h3>  Quellcode </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">bloom.frag</a> </li></ul><br><h2>  Screen Space Ambient Occlusion (SSAO) </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/5ab/5bf/f935ab5bf4794caae3be90b611ad771c.gif"></div><br>  SSAO ist einer der Effekte, von denen Sie nicht wissen, dass sie existieren, aber sobald Sie wissen, dass Sie ohne sie nicht mehr leben können.  Er kann eine mittelmäßige Szene in eine erstaunliche verwandeln!  In statischen Szenen kann Umgebungsokklusion in die Textur eingebrannt werden, aber für dynamischere Szenen benötigen wir einen Shader.  SSAO ist eine der ausgefeilteren Schattierungstechniken, aber sobald Sie es herausgefunden haben, werden Sie ein Master-Shader. <br><br>  Beachten Sie, dass der Begriff „Bildschirmbereich“ im Titel nicht ganz korrekt ist, da nicht alle Berechnungen im Bildschirmbereich ausgeführt werden. <br><br><h3>  Eingehende Daten </h3><br>  Der SSAO-Shader benötigt die folgende Eingabe. <br><br><ul><li>  Vektoren von Scheitelpunktpositionen im Betrachtungsraum. </li><li>  Normale Vektoren zu den Eckpunkten im Betrachtungsraum. </li><li>  Abtastvektoren im Tangentenraum. </li><li>  Rauschvektoren im Tangentenraum. </li><li>  Die Projektionsmatrix auf dem Kameraobjektiv. </li></ul><br><h3>  Position </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/f36/d42/2d2f36d425c2596288d8982158687354.png"></div><br>  Es ist nicht erforderlich, Scheitelpunktpositionen in der Bildpuffertextur zu speichern.  Wir können sie aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">dem Kameratiefenpuffer</a> neu erstellen.  Ich schreibe einen Leitfaden für Anfänger, daher werden wir diese Optimierung nicht verwenden und sofort zur Sache kommen.  In Ihrer Implementierung können Sie den Tiefenpuffer problemlos verwenden. <br><br><pre> <code class="cpp hljs">PT(Texture) depthTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(<span class="hljs-string"><span class="hljs-string">"depthTexture"</span></span>); depthTexture-&gt;set_format(Texture::Format::F_depth_component32); PT(GraphicsOutput) depthBuffer = graphicsOutput-&gt;make_texture_buffer(<span class="hljs-string"><span class="hljs-string">"depthBuffer"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, depthTexture); depthBuffer-&gt;set_clear_color(LVecBase4f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); NodePath depthCameraNP = window-&gt;make_camera(); DCAST(Camera, depthCameraNP.node())-&gt;set_lens(window-&gt;get_camera(<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;get_lens()); PT(DisplayRegion) depthBufferRegion = depthBuffer-&gt;make_display_region(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); depthBufferRegion-&gt;set_camera(depthCameraNP);</code> </pre> <br>  Wenn Sie sich für die Verwendung des Tiefenpuffers entscheiden, können Sie ihn wie folgt in Panda3D konfigurieren. <br><br><pre> <code class="cpp hljs">in vec4 vertexPosition; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fragColor = vertexPosition; }</code> </pre> <br>  Hier ist ein einfacher Shader zum Rendern von Scheitelpunktpositionen im Anzeigebereich in eine Bildpuffertextur.  Eine schwierigere Aufgabe besteht darin, die Textur des Bildpuffers so einzustellen, dass die von ihm erhaltenen Komponenten des Fragmentvektors nicht auf das Intervall <code>[0, 1]</code> sind und dass jedes eine ausreichend hohe Genauigkeit (eine ausreichend große Anzahl von Bits) aufweist.  Wenn beispielsweise eine interpolierte Scheitelpunktposition <code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code> , können Sie sie nicht als <code>&lt;0.0, 0.0, 1.0&gt;</code> in der Textur speichern. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... FrameBufferProperties fbp = FrameBufferProperties::get_default(); // ... fbp.set_rgba_bits(32, 32, 32, 32); fbp.set_rgb_color(true); fbp.set_float_color(true); // ...</span></span></code> </pre> <br>  Hier ist ein Beispielcode, der eine Bildpuffertextur zum Speichern von Scheitelpunktpositionen vorbereitet.  Er benötigt 32 Bit für Rot, Grün, Blau und Alpha, daher deaktiviert er die Einschränkung von Werten um das Intervall <code>[0, 1]</code> .  Der Aufruf von <code>set_rgba_bits(32, 32, 32, 32)</code> legt das <code>set_rgba_bits(32, 32, 32, 32)</code> und deaktiviert die Einschränkung. <br><br><pre> <code class="cpp hljs"> glTexImage2D ( GL_TEXTURE_2D , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB32F , <span class="hljs-number"><span class="hljs-number">1200</span></span> , <span class="hljs-number"><span class="hljs-number">900</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB , GL_FLOAT , <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> );</code> </pre> <br>  Hier ist ein ähnlicher Aufruf von OpenGL.  <code>GL_RGB32F</code> setzt die Bits und deaktiviert die Einschränkung. <br><br><blockquote>  Wenn der Farbpuffer ein festes Komma hat, sind die Komponenten der Anfangs- und Endwerte sowie der Mischungsindizes vor der Berechnung der Mischungsgleichung für die vorzeichenlosen normalisierten und vorzeichenbehafteten normalisierten Farbpuffer auf [0, 1] bzw. [–1, 1] begrenzt.  Wenn der Farbpuffer einen Gleitkomma hat, ist die Einschränkung nicht erfüllt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Quelle</a> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17b/2d0/2ad/17b2d02ad53c411dc251d90fdc16fdf3.png"></div><br>  Hier sehen Sie die Positionen der Eckpunkte;  Die y-Achse ist oben. <br><br>  Denken Sie daran, dass Panda3D die z-Achse als nach oben zeigenden Vektor definiert, während in OpenGL die y-Achse nach oben zeigt.  Der Positions-Shader zeigt die Positionen von Scheitelpunkten mit einem z nach oben an, da in Panda3D <br>  Der <code>gl-coordinate-system default</code> ist konfiguriert. <br><br><h3>  Normal </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/064/9c5/0c40649c525edd7bcf3c829d6e948789.gif"></div><br>  Für die korrekte Ausrichtung der im SSAO-Shader erhaltenen Samples benötigen wir die Normalen zu den Eckpunkten.  Der Beispielcode generiert mehrere über die Hemisphäre verteilte Abtastvektoren. Sie können jedoch die Kugel verwenden und das Problem der Notwendigkeit von Normalen vollständig lösen. <br><br><pre> <code class="cpp hljs">in vec3 vertexNormal; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 normal = normalize(vertexNormal); fragColor = vec4(normal, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Wie der Positions-Shader ist der normale Shader sehr einfach.  Denken Sie daran, die Normalen auf die Eckpunkte zu normalisieren, und denken Sie daran, dass sie sich im Betrachtungsraum befinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/a82/f00/57ba82f003b0ab9c2aafa7c9affa28bb.gif"></div><br>  Die Normalen zu den Eckpunkten werden hier gezeigt;  Die y-Achse ist oben. <br><br>  Denken Sie daran, dass Panda3D die z-Achse als Aufwärtsvektor und OpenGL als y-Achse betrachtet.  Der normale Shader zeigt Scheitelpunktpositionen mit der z-Achse nach oben an, da in Panda3D die <code>gl-coordinate-system default</code> konfiguriert ist. <br><br><h3>  Proben </h3><br>  Um den Umgebungsokklusionswert für ein einzelnes Fragment zu bestimmen, müssen wir die Umgebung abtasten. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; numberOfSamples; ++i) { LVecBase3f sample = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) ).normalized(); float rand = randomFloats(generator); sample[0] *= rand; sample[1] *= rand; sample[2] *= rand; float scale = (float) i / (float) numberOfSamples; scale = lerp(0.1, 1.0, scale * scale); sample[0] *= scale; sample[1] *= scale; sample[2] *= scale; ssaoSamples.push_back(sample); } // ...</span></span></code> </pre> <br>  Der Beispielcode generiert 64 Zufallsstichproben, die auf einer Halbkugel verteilt sind.  Diese <code>ssaoSamples</code> werden an den SSAO-Shader übergeben. <br><br><pre> <code class="cpp hljs"> LVecBase3f sample = LVecBase3f ( randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> ).normalized();</code> </pre> <br>  Wenn Sie Ihre Stichproben auf eine Kugel verteilen möchten, ändern Sie das Intervall der Zufallskomponente z so, dass es sich von minus eins zu eins ändert. <br><br><h3>  Der Lärm </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; 16; ++i) { LVecBase3f noise = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , 0.0 ); ssaoNoise.push_back(noise); } // ...</span></span></code> </pre> <br>  Um den abgetasteten Bereich gut abzudecken, müssen wir Rauschvektoren erzeugen.  Diese Rauschvektoren können Proben um die Oberseite der Oberfläche drehen. <br><br><h3>  Umgebungsokklusion </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c1d/bb4/d35c1dbb4e0e9dfeedc3bd4285f26004.gif"></div><br>  SSAO erfüllt seine Aufgabe, indem es den Betrachtungsraum um das Fragment herum abtastet.  Je mehr Proben sich unter der Oberfläche befinden, desto dunkler ist die Farbe des Fragments.  Diese Proben befinden sich im Fragment und zeigen in der allgemeinen Richtung der Normalen zum Scheitelpunkt an.  Jedes Sample wird verwendet, um nach einer Position in der Textur der Bildpufferposition zu suchen.  Die zurückgegebene Position wird mit der Probe verglichen.  Wenn die Probe weiter von der Kamera entfernt ist als die Position, wird die Probe in Richtung des Fragments verschlossen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/b9a/f1d/cb7b9af1d4dc613f337da5a253ef5a8c.gif"></div><br>  Hier sehen Sie einen Raum über der Oberfläche, der zur Okklusion abgetastet wurde. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float radius = 1.1; float bias = 0.026; float lowerRange = -2; float upperRange = 2; // ...</span></span></code> </pre> <br>  Wie einige andere Techniken verfügt der SSAO-Shader über mehrere Steuerparameter, die geändert werden können, um das gewünschte Erscheinungsbild zu erzielen.  Die Vorspannung wird zum Abstand von der Probe zur Kamera addiert.  Dieser Parameter kann zur Bekämpfung von Flecken verwendet werden.  Der Radius vergrößert oder verkleinert den Abdeckungsbereich des Probenraums.  LowerRange und UpperRange ändern den Standardbereich der Faktormetrik von <code>[0, 1]</code> auf einen beliebigen Wert, den Sie auswählen.  Durch Erhöhen der Reichweite können Sie den Kontrast erhöhen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); vec3 normal = texture(normalTexture, texCoord).xyz; int noiseX = int(gl_FragCoord.x - 0.5) % 4; int noiseY = int(gl_FragCoord.y - 0.5) % 4; vec3 random = noise[noiseX + (noiseY * 4)]; // ...</span></span></code> </pre> <br>  Wir erhalten den Positions-, Normal- und Zufallsvektor zur weiteren Verwendung.  Denken Sie daran, dass im Codebeispiel 16 Zufallsvektoren erstellt wurden.  Ein zufälliger Vektor wird basierend auf der Bildschirmposition der aktuellen Fragmente ausgewählt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 tangent = normalize(random - normal * dot(random, normal)); vec3 binormal = cross(normal, tangent); mat3 tbn = mat3(tangent, binormal, normal); // ...</span></span></code> </pre> <br>  Unter Verwendung eines Zufallsvektors und eines Normalenvektors sammeln wir die Matrix aus Tangens, Binormalem und Normalem.  Wir benötigen diese Matrix, um die Probenvektoren vom Tangentenraum in den Vermessungsraum zu transformieren. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float occlusion = NUM_SAMPLES; for (int i = 0; i &lt; NUM_SAMPLES; ++i) { // ... } // ...</span></span></code> </pre> <br>  Mit einer Matrix kann der Shader alle Samples in der Schleife durchlaufen und die Anzahl der ungeöffneten abziehen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 sample = tbn * samples[i]; sample = position.xyz + sample * radius; // ...</span></span></code> </pre> <br>  Platzieren Sie die Probe mithilfe der Matrix neben der Scheitelpunkt- / Fragmentposition und skalieren Sie sie um den Radius. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offset = vec4(sample, 1.0); offset = lensProjection * offset; offset.xyz /= offset.w; offset.xyz = offset.xyz * 0.5 + 0.5; // ...</span></span></code> </pre> <br>  Anhand der Position der Probe im Betrachtungsraum transformieren wir sie vom Betrachtungsraum in den Beschneidungsraum und dann in den UV-Raum. <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">-1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Vergessen Sie nicht, dass die Komponenten des Beschneidungsraums im Bereich von minus eins bis eins liegen und die UV-Koordinaten im Bereich von null bis eins liegen.  Um die Koordinaten des Beschneidungsraums in UV-Koordinaten umzuwandeln, multiplizieren Sie sie mit einer Sekunde und addieren Sie eine Sekunde. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offsetPosition = texture(positionTexture, offset.xy); float occluded = 0; if (sample.y + bias &lt;= offsetPosition.y) { occluded = 0; } else { occluded = 1; } // ...</span></span></code> </pre> <br>  Unter Verwendung der UV-Versatzkoordinaten, die durch Projizieren der 3D-Probe auf die 2D-Positionstextur erhalten wurden, finden wir den entsprechenden Positionsvektor.  Dies führt uns vom Betrachtungsraum zum Beschneidungsraum zum UV-Raum und dann zurück zum Betrachtungsraum.  Der Shader führt diese Schleife aus, um festzustellen, ob sich hinter der Probe, an der Probenposition oder vor der Probe eine Geometrie befindet.  Befindet sich die Probe vor oder in einer Geometrie, wird diese Probe in Bezug auf das überlappende Fragment einfach nicht berücksichtigt.  Befindet sich die Probe hinter einer Geometrie, wird diese Probe relativ zum überlappenden Fragment berücksichtigt. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float intensity = smoothstep ( 0.0 , 1.0 , radius / abs(position.y - offsetPosition.y) ); occluded *= intensity; occlusion -= occluded; // ...</span></span></code> </pre> <br>  Fügen Sie dieser abgetasteten Position nun Gewicht hinzu, basierend darauf, wie weit sie innerhalb oder außerhalb des Radius liegt.  Subtrahieren Sie dann diese Probe von der Okklusionsmetrik, da davon ausgegangen wird, dass sich alle Proben vor der Schleife überlappten. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... occlusion /= NUM_SAMPLES; // ... fragColor = vec4(vec3(occlusion), position.a); // ...</span></span></code> </pre> <br>  Teilen Sie die Anzahl der überlappenden durch die Anzahl der Proben, um den Okklusionsindikator vom Intervall <code>[0, NUM_SAMPLES]</code> in das Intervall <code>[0, 1]</code> <code>[0, NUM_SAMPLES]</code> .  Null bedeutet vollständige Okklusion, Einheiten bedeuten keine Okklusion.  Weisen Sie nun der Fragmentfarbe die Okklusionsmetrik zu, und fertig. <br><br>  Bitte beachten Sie, dass dem Beispielkanal im Beispielcode der Alpha-Wert der Positionstextur aus dem Bildpuffer zugewiesen wird, um überlappende Hintergründe zu vermeiden. <br><br><h3>  Unschärfe </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/566/2a7/5b15662a7c46db6b8102fe9eabae17c9.gif"></div><br>  Die Textur des SSAO-Bildpuffers ist etwas verrauscht, daher sollten Sie ihn zum Glätten verwischen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( ssaoTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ).rgb; xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  Der SSAO-Unschärfeshader ist eine normale Box-Unschärfe.  Wie der Bloom-Shader zeichnet er ein Fenster über die eingehende Textur und mittelt jedes Fragment mit den Werten seiner Nachbarn. <br><br>  Beachten Sie, dass <code>parameters.x</code> ein Trennungsparameter ist. <br><br><h3>  Umgebungsfarbe </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 ssaoBlurTexSize = textureSize(ssaoBlurTexture, 0).xy; vec2 ssaoBlurTexCoord = gl_FragCoord.xy / ssaoBlurTexSize; float ssao = texture(ssaoBlurTexture, ssaoBlurTexCoord).r; vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex * ssao; // ...</span></span></code> </pre> <br>  Die letzte Herausforderung für SSAO liegt erneut in den Beleuchtungsberechnungen.  Hier sehen wir, wie die Okklusion im Textur-SSAO-Texturpuffer gefunden und in die Berechnung des Umgebungslichts einbezogen wird. <br><br><h3>  Quellcode </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">position.frag</a> </li><li>  <a href="">normal.frag</a> </li><li>  <a href="">ssao.frag</a> </li><li>  <a href="">blur.frag</a> </li></ul><br><h2>  Schärfentiefe </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/eb0/10f/6efeb010f4623ff49b928d72550f7985.gif"></div><br>  Die Schärfentiefe ist auch ein solcher Effekt, da man gelernt hat, ohne was man nicht leben kann.  Aus künstlerischer Sicht können Sie damit die Aufmerksamkeit des Betrachters auf ein bestimmtes Objekt lenken.  Im allgemeinen Fall trägt die Schärfentiefe auf Kosten eines kleinen Aufwands zu einem großen Teil des Realismus bei. <br><br><h3>  Im Fokus </h3><br>  Der erste Schritt besteht darin, die Szene vollständig scharf zu stellen.  Rendern Sie es in die Frame Buffer-Textur.  Dies ist einer der Eingabewerte für den Tiefenschärfepuffer. <br><br><h3>  Unscharf </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 result = vec4(0); for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( blurTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ); xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  Der zweite Schritt besteht darin, die Szene so zu verwischen, als wäre sie völlig unscharf.  Wie bei Bloom und SSAO können Sie Box Blur verwenden.  Rendern Sie diese defokussierte Szene in die Bildpuffertextur.  Dies ist ein weiterer Eingabewert für die Tiefenschärfe. <br><br>  Beachten Sie, dass <code>parameters.x</code> ein Trennungsparameter ist. <br><br><h3>  Verwirrung </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d68/067/83a/d6806783a567c4708d8f13dcb0763f7c.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float focalLengthSharpness = 100; float blurRate = 6; // ...</span></span></code> </pre> <br>  Sie können diese Optionen nach Ihrem Geschmack anpassen.  <code>focalLengthSharpness</code> beeinflusst, wie defokussiert die Szene auf Brennweite ist.  Je kleiner die <code>focalLengthSharpness</code> , desto defokussierter ist die Szene auf die Brennweite.  <code>blurRate</code> beeinflusst die Geschwindigkeit der Unschärfe der Szene, wenn Sie sich von der Brennweite entfernen.  Je kleiner die <code>blurRate</code> , <code>blurRate</code> weniger unscharf wird die Szene, wenn Sie sich vom Fokuspunkt entfernen. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 focusColor = texture(focusTexture, texCoord); vec4 outOfFocusColor = texture(outOfFocusTexture, texCoord); // ...</span></span></code> </pre> <br>  Wir brauchen Farben im Fokus und in einem defokussierten Bild. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); // ...</span></span></code> </pre> <br>  Möglicherweise benötigen wir auch die Position des Scheitelpunkts im Betrachtungsraum.  Sie können die Positionstextur aus dem für SSAO verwendeten Bildpuffer erneut anwenden. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float blur = clamp ( pow ( blurRate , abs(position.y - focalLength.x) ) / focalLengthSharpness , 0 , 1 ); // ... fragColor = mix(focusColor, outOfFocusColor, blur); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und hier findet die Verwirrung statt. </font><font style="vertical-align: inherit;">Je näher </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an einem, desto mehr wird es verwenden </font></font><code>outOfFocusColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ein Wert von Null </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass dieses Fragment vollständig fokussiert ist. </font><font style="vertical-align: inherit;">Mit </font></font><code>blur &gt;= 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Fragment wird vollständig defokussiert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur.frag</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schärfentiefe.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posterisierung </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/078/84d/f1807884d79c5c73915ce9adf6ead5cb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Posterisierung oder Farbabtastung wird die Anzahl der eindeutigen Farben in einem Bild reduziert. </font><font style="vertical-align: inherit;">Mit diesem Shader können Sie dem Spiel einen Comic- oder Retro-Look verleihen. </font><font style="vertical-align: inherit;">Wenn Sie es mit einem Umriss kombinieren, erhalten Sie einen echten Cartoon-Stil.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float levels = 8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können mit diesem Parameter experimentieren. </font><font style="vertical-align: inherit;">Je größer es ist, desto mehr Blumen bleiben übrig.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 texColor = texture(posterizeTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir brauchen die eingehende Farbe. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 grey = vec3((texColor.r + texColor.g + texColor.b) / 3.0); vec3 grey1 = grey; grey = floor(grey * levels) / levels; texColor.rgb += (grey - grey1); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe eine solche Methode der Posterisierung nicht gesehen. </font><font style="vertical-align: inherit;">Nachdem ich es überprüft hatte, stellte ich fest, dass es im Vergleich zu herkömmlichen Methoden schönere Ergebnisse liefert. </font><font style="vertical-align: inherit;">Um die Farbpalette zu verkleinern, konvertieren Sie zuerst die Farbe in einen Graustufenwert. </font><font style="vertical-align: inherit;">Wir diskretisieren die Farbe, indem wir sie an eine der Ebenen binden. </font><font style="vertical-align: inherit;">Wir berechnen die Differenz zwischen dem diskretisierten Wert in Graustufen und dem nicht diskretisierten Wert in Graustufen. </font><font style="vertical-align: inherit;">Fügen Sie diesen Unterschied zur Eingabefarbe hinzu. </font><font style="vertical-align: inherit;">Dieser Unterschied ist der Betrag, um den die Farbe zunehmen / abnehmen muss, um einen diskretisierten Wert in Graustufen zu erreichen.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texColor; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergessen Sie nicht, den Wert der Eingabefarbe der Farbe des Fragments zuzuweisen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cel Schattierung </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/f9c/133/2d1f9c1333960c0299388fc51323a8b3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Posterisierung kann einem Bild das Aussehen einer Cel-Schattierung verleihen, da bei der Cel-Schattierung diffuse und diffuse Farben in diskrete Schattierungen diskretisiert werden. </font><font style="vertical-align: inherit;">Wir möchten nur feste, diffuse Farben ohne feine Details der normalen Karte und einen kleinen Wert verwenden </font></font><code>levels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posterize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixelisierung </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/0b9/9bc/3960b99bc2f1fa900c40a1c9f32169bc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Pixelisierung eines 3D-Spiels kann ihm ein interessantes Aussehen verleihen oder Zeit sparen, die für die manuelle Erstellung der gesamten Pixelgrafik aufgewendet worden wäre. </font><font style="vertical-align: inherit;">Kombinieren Sie es mit Posterisierung, um einen echten Retro-Look zu kreieren.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int pixelSize = 5; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können die Pixelgröße selbst anpassen. </font><font style="vertical-align: inherit;">Je größer es ist, desto rauer wird das Bild.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/818/aee/413818aee5509763cc383f800b837cfb.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float x = int(gl_FragCoord.x) % pixelSize; float y = int(gl_FragCoord.y) % pixelSize; x = floor(pixelSize / 2.0) - x; y = floor(pixelSize / 2.0) - y; x = gl_FragCoord.x + x; y = gl_FragCoord.y + y; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Technik bringt jedes Fragment in der Mitte seines nächsten nicht überlappenden Fensters in Pixelgröße an. </font><font style="vertical-align: inherit;">Diese Fenster werden über der eingehenden Textur ausgerichtet. </font><font style="vertical-align: inherit;">Fragmente in der Mitte des Fensters bestimmen die Farbe anderer Fragmente in ihrem Fenster.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texture(pixelizeTexture, vec2(x, y) / texSize); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir die Koordinate des gewünschten Fragments bestimmt haben, nehmen Sie seine Farbe aus der eingehenden Textur und weisen Sie sie der Fragmentfarbe zu. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixelize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schärfen </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/674/617/b52674617a0733ee1fe0d525b0053750.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schärfeeffekt (Schärfen) erhöht den Kontrast an den Bildrändern. </font><font style="vertical-align: inherit;">Es ist praktisch, wenn sich die Grafik als zu weich herausstellt.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Ändern des Werts können wir die Größe der Schärfe des Ergebnisses steuern. </font><font style="vertical-align: inherit;">Wenn der Wert Null ist, ändert sich das Bild nicht. </font><font style="vertical-align: inherit;">Bei negativen Werten sieht das Bild merkwürdig aus.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float neighbor = amount * -1; float center = amount * 4 + 1; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benachbarte Fragmente werden mit multipliziert </font></font><code>amount * -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das aktuelle Fragment wird mit multipliziert </font></font><code>amount * 4 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 color = texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 1) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x - 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 0) / texSize).rgb * center + texture(sharpenTexture, vec2(gl_FragCoord.x + 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y - 1) / texSize).rgb * neighbor ; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benachbarte Fragmente befinden sich oben, unten, links und rechts. </font><font style="vertical-align: inherit;">Nach dem Multiplizieren der Nachbarn und des aktuellen Fragments mit ihren Werten wird das Ergebnis addiert.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = vec4(color, texture(sharpenTexture, texCoord).a); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Menge ist die endgültige Farbe des Fragments. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sharpen.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filmkorn </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/16e/232/2f316e232598d07fa8114f8db32c12a7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Filmkorn (in kleinen Dosen und nicht wie im Beispiel) kann Realismus hinzufügen, der unsichtbar ist, bis dieser Effekt beseitigt ist. </font><font style="vertical-align: inherit;">Normalerweise sind dies die Unvollkommenheiten, die das digital erzeugte Bild überzeugender machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass die Filmkörnung normalerweise der letzte Effekt ist, der auf das Bild angewendet wird, bevor es angezeigt wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.1; // ...</span></span></code> </pre> <br> <code>amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steuert die Sichtbarkeit der Filmkörnung. </font><font style="vertical-align: inherit;">Je höher der Wert, desto mehr „Schnee“ im Bild.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zufällige Helligkeit </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform float osg_FrameTime; //... float toRadians = 3.14 / 180; //... float randomIntensity = fract ( 10000 * sin ( ( gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime ) * toRadians ) ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Code berechnet die zufällige Helligkeit, die zum Anpassen des Werts erforderlich ist. </font></font><br><br><pre> <code class="cpp hljs">Time Since F1 = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> Frame Number = F1 F3 F4 F5 F6 osg_FrameTime = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert </font></font><code>osg_FrameTime</code> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panda3D zur Verfügung gestellt. </font><font style="vertical-align: inherit;">Eine Frame-Zeit ist ein Zeitstempel mit Informationen darüber, wie viele Sekunden seit dem ersten Frame vergangen sind. </font><font style="vertical-align: inherit;">Der Beispielcode verwendet es, um die Körnung des Films zu animieren, die </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in jedem Bild unterschiedlich ist.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... ( gl_FragCoord.x + gl_FragCoord.y * 8009 // Large number here. // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für statische Körnung müssen die Filme durch eine </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">große Anzahl ersetzt werden. </font><font style="vertical-align: inherit;">Um zu vermeiden, dass Muster angezeigt werden, können Sie verschiedene Zahlen ausprobieren.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/2bd/6d2/3582bd6d2d67eb5ac1fdcdf8d52800e6.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... * sin ( ( gl_FragCoord.x + gl_FragCoord.y * someNumber // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Punkte oder Flecken von Filmkörnung zu erzeugen, werden beide Koordinaten sowie x und y verwendet. </font><font style="vertical-align: inherit;">Wenn Sie x verwenden, werden nur vertikale Linien angezeigt. Wenn Sie y verwenden, werden nur horizontale Linien angezeigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Code wird eine Koordinate mit einer anderen multipliziert, um die diagonale Symmetrie zu zerstören.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/ad6/d5a/4c0ad6d5ada5d533b6dc31bbfa7aa0fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich können Sie den Koordinatenmultiplikator entfernen und einen völlig akzeptablen Regeneffekt erzielen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass Sie die Ausgabe </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit </font><font style="vertical-align: inherit;">multiplizieren müssen, um den Regeneffekt zu animieren </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experimentieren Sie mit den x- und y-Koordinaten, um die Richtung des Regens zu ändern. </font><font style="vertical-align: inherit;">Lassen Sie für eine Dusche nach unten nur die x-Koordinate.</font></font><br><br><pre> <code class="cpp hljs">input = (gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime) * toRadians frame(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) =</code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird als Hash-Funktion verwendet. </font><font style="vertical-align: inherit;">Fragmentkoordinaten werden mit Ausgabewerten gehasht </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dank dessen erscheint eine praktische Eigenschaft - unabhängig von den Eingabedaten (groß oder klein) liegt das Ausgabeintervall im Bereich von minus eins bis eins.</font></font><br><br><pre> <code class="cpp hljs">fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) = fract(<span class="hljs-number"><span class="hljs-number">6400.723818964882</span></span>) = <span class="hljs-number"><span class="hljs-number">0.723818964882</span></span></code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Kombination mit </font></font><code>fract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch als Pseudozufallszahlengenerator verwendet.</font></font><br><br><pre> <code class="cpp hljs">&gt;&gt;&gt; [<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(fract(<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x * toRadians)) * <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 0, 1, 2, 2, 3, 4, 4, 5, 6] &gt;&gt;&gt; [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fract(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10000</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(x * toRadians)) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 4, 8, 0, 2, 1, 7, 0, 0, 5]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich zuerst die erste Zahlenreihe und dann die zweite an. </font><font style="vertical-align: inherit;">Jede Zeile ist deterministisch, aber das Muster ist in der zweiten weniger auffällig als in der zweiten. </font><font style="vertical-align: inherit;">Daher wird </font></font><code>fract(10000 * sin(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Muster </font><font style="vertical-align: inherit;">trotz der Tatsache, dass die Ausgabe </font><font style="vertical-align: inherit;">deterministisch ist, viel schwächer erkannt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/6e7/f0f/b886e7f0feda6760c5fc87df6680680f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sehen wir, wie der Faktor </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuerst 1, dann 10, dann 100 und dann 1000 ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Multiplikator der Ausgabewerte zunimmt, wird das </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muster weniger wahrnehmbar. </font><font style="vertical-align: inherit;">Aus diesem Grund wird der Code </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit 10.000 multipliziert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmentfarbe </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 texSize = textureSize(filmGrainTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; vec4 color = texture(filmGrainTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertieren Sie die Koordinaten des Fragments in UV-Koordinaten. </font><font style="vertical-align: inherit;">Mit diesen UV-Koordinaten suchen wir nach der Texturfarbe für das aktuelle Fragment.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... amount *= randomIntensity; color.rgb += amount; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ändern Sie den Wert in eine zufällige Helligkeit und fügen Sie ihn der Farbe hinzu. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = color; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie die Farbe des Fragments ein und fertig. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">film-corn.frag</font></font></a> </li></ul><br><h2>  Danksagung </h2><br><ul><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Kiwi Soda Font</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453692/">https://habr.com/ru/post/de453692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453676/index.html">Verbindung zu Windows über SSH wie unter Linux</a></li>
<li><a href="../de453678/index.html">So sehen Sie Nachhall oder Videoübertragung durch Ton durch Wasser - 2</a></li>
<li><a href="../de453682/index.html">Entwicklung der einfachsten „Firmware“ für in Redd installierte FPGAs. Teil 2. Programmcode</a></li>
<li><a href="../de453686/index.html">Sicherheitswoche 22: Bedrohungsstatistiken, Bankentrojaner und beliebte Exploits</a></li>
<li><a href="../de453688/index.html">Java ist nicht nur ein blutiges Unternehmen, sondern auch schnell latenzempfindliche Anwendungen</a></li>
<li><a href="../de453694/index.html">Stellen Sie wie unter Linux eine Verbindung zu Windows über SSH her</a></li>
<li><a href="../de453696/index.html">Winkel-Zwei-Wege-Bindung, etwas verständnisvoller</a></li>
<li><a href="../de453698/index.html">Quanteninformation im Quantenbewusstsein</a></li>
<li><a href="../de453700/index.html">Lektionen zu SDL 2: Lektion 1 - Hallo, SDL 2</a></li>
<li><a href="../de453706/index.html">Wie ich die Zertifizierungsprüfung für Google Cloud Professional Data Engineer bestanden habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>