<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏿 🎥 🤹🏼 Reaktive Binärkompatibilität: wie wir sie anbieten 🔀 👼🏾 🛌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Mein Name ist Yuri Vlad, ich bin Android-Entwickler bei Badoo und arbeite an der Erstellung der Reaktiven Bibliothek - Reactive Extensions auf ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reaktive Binärkompatibilität: wie wir sie anbieten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/484712/"><p>  Hallo!  Mein Name ist Yuri Vlad, ich bin Android-Entwickler bei Badoo und <a href="https://github.com/badoo/Reaktive">arbeite</a> an der Erstellung der <a href="https://github.com/badoo/Reaktive">Reaktiven</a> Bibliothek - Reactive Extensions auf pure Kotlin mit. </p><br><p>  Jede Bibliothek sollte nach Möglichkeit die Binärkompatibilität beachten.  Wenn verschiedene Versionen der Bibliothek in den Abhängigkeiten nicht kompatibel sind, stürzt das Ergebnis zur Laufzeit ab.  Ein solches Problem kann beispielsweise auftreten, wenn Sie MVICore mit reaktiver Unterstützung <a href="https://github.com/badoo/MVICore">versehen</a> . </p><br><p><img src="https://habrastorage.org/webt/6w/hx/mc/6whxmcr9swxn5rtbxjeo46igkv8.jpeg"></p><br><p>  In diesem Artikel werde ich Ihnen kurz erläutern, was Binärkompatibilität ist und welche Funktionen Kotlin bietet und wie es in JetBrains und jetzt in Badoo unterstützt wird. </p><a name="habracut"></a><br><h2 id="problema-binarnoy-sovmestimosti-v-kotlin">  Kotlin-Binärkompatibilitätsproblem </h2><br><p> Angenommen, wir haben eine wunderbare Bibliothek <code>com.sample:lib:1.0</code> mit dieser Klasse: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>)</code> </pre> <br><p>  Darauf basierend haben wir eine zweite Bibliothek <code>com.sample:lib-extensions:1.0</code> .  Zu seinen Abhängigkeiten gehört <code>com.sample:lib:1.0</code> .  Beispielsweise enthält es eine Factory-Methode für Klasse <code>A</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: A = A(a)</code> </pre> <br><p>  Jetzt veröffentlichen wir die neue Version unserer Bibliothek <code>com.sample:lib:2.0</code> mit der folgenden Änderung: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre> <br><p>  Kotlins voll kompatibles Wechselgeld, nicht wahr?  Mit dem Standardparameter können wir weiterhin das Konstrukt <code>val a = A(a)</code> , jedoch nur, wenn alle Abhängigkeiten vollständig neu kompiliert wurden.  Die Standardparameter sind nicht Teil der JVM und werden vom speziellen synthetischen Konstruktor <code>A</code> implementiert, der alle Felder der Klasse in den Parametern enthält.  Wenn Abhängigkeiten aus dem Maven-Repository empfangen werden, werden sie bereits zusammengestellt und können nicht erneut kompiliert werden. </p><br><p>  Eine neue Version von <code>com.sample:lib</code> und wir verbinden sie sofort mit unserem Projekt.  Wir wollen auf dem Laufenden sein!  Neue Funktionen, neue Korrekturen, <del>  neue Bugs </del>  ! </p><br><pre> <code class="plaintext hljs">dependencies { implementation 'com.sample:lib:2.0' implementation 'com.sample:lib-extensions:1.0' }</code> </pre> <br><p>  In diesem Fall kommt es zur Laufzeit zum Absturz.  <code>createA</code> Funktion <code>createA</code> im Bytecode versucht, den Konstruktor der Klasse <code></code> mit einem Parameter aufzurufen, und im Bytecode ist bereits kein solcher vorhanden.  Von allen Abhängigkeiten mit derselben Gruppe und demselben Namen wählt Gradle die mit der neuesten Version aus und nimmt sie in die Assembly auf. </p><br><p>  Höchstwahrscheinlich sind Sie in Ihren Projekten bereits auf binäre Inkompatibilität gestoßen.  Persönlich bin ich auf dieses Problem gestoßen, als ich unsere Anwendungen auf AndroidX migriert habe. </p><br><p>  Weitere <a href="https://habr.com/ru/users/gvsmirnov/" class="user_link">Informationen</a> zur Binärkompatibilität finden Sie in den Artikeln <a href="https://habr.com/ru/post/133907/">"Binärkompatibilität in Beispielen und nicht nur"</a> von <a href="https://habr.com/ru/users/gvsmirnov/" class="user_link">gvsmirnov-</a> Benutzern, <a href="https://wiki.eclipse.org/Evolving_Java-based_APIs_2">"Entwickeln von Java-basierten APIs 2"</a> von Eclipse- <a href="https://wiki.eclipse.org/Evolving_Java-based_APIs_2">Entwicklern</a> und im kürzlich veröffentlichten Artikel <a href="https://jakewharton.com/public-api-challenges-in-kotlin/">"Öffentliche API-Herausforderungen in Kotlin" von</a> Jake Wharton. </p><br><h2 id="sposoby-obespecheniya-binarnoy-sovmestimosti">  Möglichkeiten zur Gewährleistung der Binärkompatibilität </h2><br><p>  Es scheint, dass Sie nur versuchen müssen, kompatible Änderungen vorzunehmen.  Fügen Sie beispielsweise Konstruktoren mit einem Standardwert hinzu, wenn Sie neue Felder hinzufügen, fügen Sie neue Parameter zu Funktionen hinzu, indem Sie eine Methode mit einem neuen Parameter überschreiben usw. Es ist jedoch immer leicht, einen Fehler zu machen.  Aus diesem Grund wurden verschiedene Tools zur Überprüfung der Binärkompatibilität von zwei verschiedenen Versionen derselben Bibliothek erstellt, z. </p><br><ol><li>  Java API Compliance Checker </li><li>  Clirr </li><li>  Revapi </li><li>  Japicmp </li><li>  Japitools </li><li>  Jour </li><li>  Japi-Checker </li><li>  Sigtest </li></ol><br><p>  Sie nehmen zwei JAR-Dateien und geben das Ergebnis an: wie kompatibel sie sind. </p><br><p>  Wir entwickeln jedoch die Kotlin-Bibliothek, deren Verwendung bisher nur von Kotlin aus sinnvoll ist.  Dies bedeutet, dass wir zum Beispiel für <code>internal</code> Klassen nicht immer eine 100% ige Kompatibilität benötigen.  Obwohl sie im Bytecode öffentlich sind, ist ihre Verwendung außerhalb des Kotlin-Codes unwahrscheinlich.  Zur Aufrechterhaltung der Binärkompatibilität verwendet kotlin-stdlib JetBrains daher einen <a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">Binärkompatibilitätsprüfer</a> .  Das Grundprinzip lautet: Aus der JAR-Datei wird ein Dump der gesamten öffentlichen API erstellt und in die Datei geschrieben.  Diese Datei ist eine Referenz für alle weiteren Überprüfungen und sieht folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">public final class kotlin/coroutines/ContinuationKt { public static final fun createCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun createCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; public static final fun startCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)V public static final fun startCoroutine (Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)V }</code> </pre> <br><p>  Nachdem Sie Änderungen am Quellcode vorgenommen haben, wird die Baseline-Bibliothek im Vergleich zur aktuellen neu generiert, und die Überprüfung schlägt fehl, wenn Änderungen an der Baseline angezeigt werden.  Diese Änderungen können überschrieben werden, indem <code>-Doverwrite.output=true</code> .  Ein Fehler tritt auch dann auf, wenn binärkompatible Änderungen vorgenommen wurden.  Dies ist erforderlich, um die Baseline rechtzeitig zu aktualisieren und ihre Änderungen direkt in der Pull-Anforderung anzuzeigen. </p><br><h2 id="binary-compatibility-validator">  Binärkompatibilitätsprüfer </h2><br><p>  Mal sehen, wie dieses Tool funktioniert.  Die Binärkompatibilität wird auf JVM-Ebene (Bytecode) bereitgestellt und ist sprachunabhängig.  Es ist möglich, die Java-Klassenimplementierung durch Kotlin zu ersetzen, ohne die Binärkompatibilität zu beeinträchtigen (und umgekehrt). <br>  Zuerst müssen Sie verstehen, welche Klassen sich in der Bibliothek befinden.  Wir erinnern uns, dass auch für globale Funktionen und Konstanten eine Klasse mit dem Dateinamen und dem Suffix <code>Kt</code> , zum Beispiel <code>ContinuationKt</code> .  Um alle Klassen <code>JarFile</code> , verwenden wir die <code>JarFile</code> Klasse aus dem JDK, <code>JarFile</code> Zeiger auf jede Klasse ab und übergeben sie an <code>org.objectweb.asm.tree.ClassNode</code> .  Diese Klasse informiert uns über die Sichtbarkeit der Klasse, ihre Methoden, Felder und Anmerkungen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jar = JarFile(<span class="hljs-string"><span class="hljs-string">"/path/to/lib.jar"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classStreams = jar.classEntries().map { entry -&gt; jar.getInputStream(entry) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNodes = classStreams.map { it.use { stream -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classNode = ClassNode() ClassReader(stream).accept(classNode, ClassReader.SKIP_CODE) classNode } }</code> </pre> <br><p>  Kotlin fügt beim Kompilieren jeder Klasse die Laufzeitanmerkung <code>@Metadata</code> hinzu, damit <code>kotlin-reflect</code> das Aussehen der Kotlin-Klasse wiederherstellen kann, bevor sie in Bytecode konvertiert wird.  Es sieht so aus: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Metadata</span></span>( mv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>}, bv = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, k = <span class="hljs-number"><span class="hljs-number">1</span></span>, d1 = {<span class="hljs-string"><span class="hljs-string">"\u0000 \n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\b\n\u0002\b\u0006\n\u0002\u0010\u000b\n\u0002\b\u0003\n\u0002\u0010\u000e\n\u0000\b\u0086\b\u0018\u00002\u00020\u0001B\r\u0012\u0006\u0010\u0002\u001a\u00020\u0003¢\u0006\u0002\u0010\u0004J\t\u0010\u0007\u001a\u00020\u0003HÆ\u0003J\u0013\u0010\b\u001a\u00020\u00002\b\b\u0002\u0010\u0002\u001a\u00020\u0003HÆ\u0001J\u0013\u0010\t\u001a\u00020\n2\b\u0010\u000b\u001a\u0004\u0018\u00010\u0001HÖ\u0003J\t\u0010\f\u001a\u00020\u0003HÖ\u0001J\t\u0010\r\u001a\u00020\u000eHÖ\u0001R\u0011\u0010\u0002\u001a\u00020\u0003¢\u0006\b\n\u0000\u001a\u0004\b\u0005\u0010\u0006¨\u0006\u000f"</span></span>}, d2 = {<span class="hljs-string"><span class="hljs-string">"Lcom/sample/A;"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"(I)V"</span></span>, <span class="hljs-string"><span class="hljs-string">"getA"</span></span>, <span class="hljs-string"><span class="hljs-string">"()I"</span></span>, <span class="hljs-string"><span class="hljs-string">"component1"</span></span>, <span class="hljs-string"><span class="hljs-string">"copy"</span></span>, <span class="hljs-string"><span class="hljs-string">"equals"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"other"</span></span>, <span class="hljs-string"><span class="hljs-string">"hashCode"</span></span>, <span class="hljs-string"><span class="hljs-string">"toString"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"app_release"</span></span>} )</code> </pre> <br><p>  <code>ClassNode</code> können die <code>@Metadata</code> Annotation von <code>@Metadata</code> und in <code>KotlinClassHeader</code> .  Sie müssen dies manuell tun, da <code>kotlin-reflect</code> nicht weiß, wie man mit ObjectWeb ASM arbeitet. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ClassNode.kotlinMetadata: KotlinClassMetadata? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/Metadata"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> header = with(metadata) { KotlinClassHeader( kind = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"k"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?, metadataVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"mv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), bytecodeVersion = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"bv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;?)?.toIntArray(), data1 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), data2 = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;String&gt;?)?.toTypedArray(), extraString = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, packageName = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"pn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> String?, extraInt = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"xi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? ) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> KotlinClassMetadata.read(header) }</code> </pre> <br><p>  kotlin.Metadata wird benötigt, um <code>internal</code> korrekt zu behandeln, da es im Bytecode nicht vorhanden ist.  Änderungen an <code>internal</code> Klassen und Funktionen können sich nicht auf Bibliotheksbenutzer auswirken, obwohl sie im Hinblick auf den Bytecode eine öffentliche API sind. </p><br><p>  In kotlin.Metadata können Sie sich über <code>companion object</code> informieren.  Auch wenn Sie es als privat deklarieren, wird es weiterhin im öffentlichen statischen Feld <code>Companion</code> gespeichert, was bedeutet, dass dieses Feld unter die Anforderung der Binärkompatibilität fällt. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeException</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { } }</code> </pre> <br><pre> <code class="plaintext hljs">public final static Lcom/badoo/reaktive/base/exceptions/CompositeException$Companion; Companion @Ljava/lang/Deprecated;()</code> </pre> <br><p>  Von den erforderlichen Anmerkungen sollte <code>@PublishedApi</code> für Klassen und Methoden angegeben werden, die in öffentlichen <code>inline</code> Funktionen verwendet werden.  Der Hauptteil solcher Funktionen verbleibt an den Stellen ihres Aufrufs, was bedeutet, dass die Klassen und Methoden in ihnen binärkompatibel sein müssen.  Wenn Sie versuchen, nicht öffentliche Klassen und Methoden in solchen Funktionen zu verwenden, gibt der Kotlin-Compiler <code>@PublishedApi</code> Fehler aus und bietet an, sie mit der Annotation <code>@PublishedApi</code> zu kennzeichnen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ClassNode.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPublishedApi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = findAnnotation(<span class="hljs-string"><span class="hljs-string">"kotlin/PublishedApi"</span></span>, includeInvisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) != <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  Der Baum der Klassenvererbung und die Implementierung von Schnittstellen sind wichtig, um die Binärkompatibilität zu unterstützen.  Wir können zum Beispiel nicht einfach irgendeine Schnittstelle aus der Klasse entfernen.  Und die Elternklasse und die implementierbaren Schnittstellen zu bekommen ist ziemlich einfach. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(classNode.superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + classNode.interfaces.sorted()</code> </pre> <br><p>  <code>Object</code> aus der Liste entfernt, da die Verfolgung keinen Sinn ergibt. </p><br><p>  Innerhalb des Validators gibt es eine Vielzahl zusätzlicher Kotlin-spezifischer Überprüfungen: Überprüfen der Standardmethoden in Interfaces über <code>Interface$DefaultImpls</code> , Ignorieren der <code>$WhenMappings</code> Klassen, damit der <code>when</code> Operator funktioniert, und andere. </p><br><p>  Als Nächstes müssen Sie alle <code>ClassNode</code> und deren <code>MethodNode</code> und <code>FieldNode</code> .  Aus der Signatur der Klassen, ihrer Felder und Methoden erhalten wir <code>ClassBinarySignature</code> , <code>FieldBinarySignature</code> und <code>MethodBinarySignature</code> , die lokal im Projekt deklariert werden.  Alle implementieren die <code>MemberBinarySignature</code> Schnittstelle, können ihre öffentliche Sichtbarkeit mithilfe der <code>isEffectivelyPublic</code> Methode <code>isEffectivelyPublic</code> und ihre Signatur in einem lesbaren Format anzeigen. </p><br><pre> <code class="kotlin hljs">classNodes.map { with(it) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> metadata = kotlinMetadata <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mVisibility = visibilityMapNew[name] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classAccess = AccessFlags(effectiveAccess and Opcodes.ACC_STATIC.inv()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> supertypes = listOf(superName) - <span class="hljs-string"><span class="hljs-string">"java/lang/Object"</span></span> + interfaces.sorted() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> memberSignatures = ( fields.map { with(it) { FieldBinarySignature(JvmFieldSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } + methods.map { with(it) { MethodBinarySignature(JvmMethodSignature(name, desc), isPublishedApi(), AccessFlags(access)) } } ).filter { it.isEffectivelyPublic(classAccess, mVisibility) } ClassBinarySignature(name, superName, outerClassName, supertypes, memberSignatures, classAccess, isEffectivelyPublic(mVisibility), metadata.isFileOrMultipartFacade() || isDefaultImpls(metadata) } }</code> </pre> <br><p>  Nachdem Sie die <code>ClassBinarySignature</code> Liste erhalten haben, können Sie sie mit der <code>dump(to: Appendable)</code> in eine Datei oder einen Speicher schreiben und mit der Baseline vergleichen. <code>RuntimePublicAPITest</code> geschieht im <code>RuntimePublicAPITest</code> Test: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimePublicAPITest</span></span></span><span class="hljs-class"> </span></span>{ @[Rule JvmField] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testName = TestName() <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kotlinStdlibRuntimeMerged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../stdlib/jvm/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"kotlin-stdlib"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshotAPIAndCompare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( basePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, jarPattern: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, publicPackages: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; = emptyList()</span></span></span></span>, nonPublicPackages: List&lt;String&gt; = emptyList() ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> base = File(basePath).absoluteFile.normalize() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jarFile = getJarPath(base, jarPattern, System.getProperty(<span class="hljs-string"><span class="hljs-string">"kotlinVersion"</span></span>)) println(<span class="hljs-string"><span class="hljs-string">"Reading binary API from </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$jarFile</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api = getBinaryAPI(JarFile(jarFile)).filterOutNonPublic(nonPublicPackages) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target = File(<span class="hljs-string"><span class="hljs-string">"reference-public-api"</span></span>) .resolve(testName.methodName.replaceCamelCaseWithDashedLowerCase() + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>) api.dumpAndCompareWith(target) }</code> </pre> <br><p>  Durch das Festschreiben einer neuen Baseline erhalten wir die Änderungen in einem lesbaren Format, wie zum Beispiel in diesem <a href="https://github.com/badoo/Reaktive/pull/312/commits/c8985c15d24346ecfe89cb2ac84fbe7cf6cbeb3e">Festschreiben</a> : </p><br><pre> <code class="diff hljs"> public static final fun flattenObservable (Lcom/badoo/reaktive/single/Single;)Lcom/badoo/reaktive/observable/Observable; } + public final class com/badoo/reaktive/single/MapIterableKt { + public static final fun mapIterable (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + public static final fun mapIterableTo (Lcom/badoo/reaktive/single/Single;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)Lcom/badoo/reaktive/single/Single; + } public final class com/badoo/reaktive/single/MapKt {</code> </pre> <br><h2 id="ispolzovanie-validatora-v-svoyom-proekte">  Verwendung eines Validators in Ihrem Projekt </h2><br><p>  Die Bedienung ist denkbar einfach.  Kopieren Sie den <code>binary-compatibility-validator</code> in Ihr Projekt und ändern Sie dessen <code>build.gradle</code> und <code>RuntimePublicAPITest</code> : </p><br><pre> <code class="kotlin hljs">plugins { id(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlin.jvm"</span></span>) } dependencies { implementation(Deps.asm) implementation(Deps.asm.tree) implementation(Deps.kotlinx.metadata.jvm) testImplementation(Deps.kotlin.test.junit) } tasks.named(<span class="hljs-string"><span class="hljs-string">"test"</span></span>, Test::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,   -     Gradle       : dependsOn( ":coroutines-interop:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive:jvmJar", ":reaktive-annotations:jvmJar", ":reaktive-testing:jvmJar", ":rxjava2-interop:jar", ":rxjava3-interop:jar", ":utils:jvmJar" ) //    ,          baseline-: outputs.upToDateWhen { false } //    systemProperty("overwrite.output", findProperty("binary-compatibility-override") ?: "true") systemProperty("kotlinVersion", findProperty("reaktive_version").toString()) systemProperty("testCasesClassesDirs", sourceSets.test.get().output.classesDirs.asPath) jvmArgs("-ea") }</span></span></code> </pre> <br><p>  In unserem Fall sieht eine der Testfunktionen der <code>RuntimePublicAPITest</code> Datei folgendermaßen aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reaktive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { snapshotAPIAndCompare(<span class="hljs-string"><span class="hljs-string">"../../reaktive/build/libs"</span></span>, <span class="hljs-string"><span class="hljs-string">"reaktive-jvm"</span></span>) }</code> </pre> <br><p>  Führen <code>./gradlew :tools:binary-compatibility:test -Pbinary-compatibility-override=false</code> nun für jede Pull-Anforderung <code>./gradlew :tools:binary-compatibility:test -Pbinary-compatibility-override=false</code> und zwingen Sie die Entwickler, die Baseline-Dateien rechtzeitig zu aktualisieren. </p><br><h2 id="lozhka-dyogtya">  Fliege in der Salbe </h2><br><p>  Dieser Ansatz hat jedoch einige Nachteile. </p><br><p>  Zunächst müssen wir die Änderungen an den Basisdateien unabhängig analysieren.  Nicht immer führen ihre Änderungen zu binärer Inkompatibilität.  Wenn Sie zum Beispiel eine neue Schnittstelle implementieren, erhalten Sie einen solchen Unterschied in der Baseline: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- public final class com/test/A { + public final class com/test/A : Comparable {</span></span></code> </pre> <br><p>  Zweitens werden Werkzeuge verwendet, die nicht dafür vorgesehen sind.  Tests sollten keine Nebeneffekte in Form des Schreibens einer Datei auf die Festplatte haben, die anschließend vom selben Test verwendet wird, und noch mehr, indem Parameter über Umgebungsvariablen an ihn übergeben werden.  Es wäre großartig, dieses Tool in einem Gradle-Plugin zu verwenden und mithilfe einer Aufgabe eine Baseline zu erstellen.  Aber ich möchte im Validator wirklich nichts alleine ändern, so dass es später einfach ist, alle Änderungen aus dem Kotlin-Repository abzurufen, da in Zukunft möglicherweise neue Konstrukte in der Sprache erscheinen, die unterstützt werden muss. </p><br><p>  Drittens wird nur JVM unterstützt. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Mit der <a href="https://github.com/jetBrains/kotlin/tree/master/libraries/tools/binary-compatibility-validator">Binärkompatibilitätsprüfung können</a> Sie eine Binärkompatibilität erreichen und rechtzeitig auf eine Änderung des Status reagieren.  Um es im Projekt zu verwenden, mussten nur zwei Dateien geändert und die Tests mit unserem CI verbunden werden.  Diese Lösung hat einige Nachteile, ist aber dennoch recht bequem zu bedienen.  Jetzt wird Reaktive versuchen, die Binärkompatibilität für die JVM auf dieselbe Weise aufrechtzuerhalten wie JetBrains für die Kotlin-Standardbibliothek. </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484712/">https://habr.com/ru/post/de484712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484700/index.html">Java 14: Datensatzvorschau</a></li>
<li><a href="../de484702/index.html">Prestashop-Alternativen im Jahr 2020: Top-E-Commerce-Plattformen</a></li>
<li><a href="../de484706/index.html">Üben Sie in der Arbeit mit Custom-Reifen des Redd-Komplexes</a></li>
<li><a href="../de484708/index.html">Richard Hamming "Nicht existierendes Kapitel": Woher wissen wir, was wir wissen (Vollversion)</a></li>
<li><a href="../de484710/index.html">Verstoß gegen die Regeln der Unity Garbage Collection</a></li>
<li><a href="../de484716/index.html">Hör auf, alles KI zu nennen</a></li>
<li><a href="../de484718/index.html">Moderne HP Drucker arbeiten nicht ohne Tintenabonnement</a></li>
<li><a href="../de484720/index.html">Konzert für eine Stadt mit Orchester: Wer und warum zeichnet die Klänge des Alltags auf?</a></li>
<li><a href="../de484722/index.html">Welche Ruby on Rails-Entwicklungstools passen zu Ihrem Projekt: Top Ruby on Rails Gems für 2020</a></li>
<li><a href="../de484724/index.html">Neuigkeiten aus der Welt von OpenStreetMap Nr. 494 (21.12.2019-06.01.2020)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>