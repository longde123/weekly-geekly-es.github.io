<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏽 👨‍👦 🖖🏼 Kode kereta python: 10 kesalahan paling umum yang dilakukan pengembang 👨🏿‍🎨 🗣️ 🔯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tentang Python 
 Python adalah bahasa pemrograman tingkat tinggi yang ditafsirkan, berorientasi objek, dengan semantik dinamis. Struktur data tingkat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kode kereta python: 10 kesalahan paling umum yang dilakukan pengembang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466441/"><h3>  Tentang Python </h3><br>  Python adalah bahasa pemrograman tingkat tinggi yang ditafsirkan, berorientasi objek, dengan semantik dinamis.  Struktur data tingkat tinggi bawaan dikombinasikan dengan pengetikan dinamis dan pengikatan dinamis membuatnya sangat menarik untuk BRPS (pengembangan alat aplikasi yang cepat), serta untuk digunakan sebagai skrip dan bahasa penghubung untuk menghubungkan komponen atau layanan yang ada.  Python mendukung modul dan paket, sehingga mendorong modularitas program dan penggunaan kembali kode. <br><br><h3>  Tentang artikel ini </h3><br>  Kesederhanaan dan kemudahan menguasai bahasa ini dapat membingungkan bagi pengembang (terutama mereka yang baru mulai mempelajari Python), sehingga Anda dapat kehilangan pandangan tentang beberapa seluk-beluk penting dan meremehkan kekuatan dari berbagai solusi yang mungkin menggunakan Python. <br><br>  Dengan mengingat hal ini, artikel ini memperkenalkan "10 besar" kesalahan yang sulit ditemukan yang bahkan dapat dibuat oleh pengembang Python tingkat lanjut. <br><a name="habracut"></a><br>
<h3>  Kesalahan # 1: ekspresi penyalahgunaan sebagai nilai default untuk argumen fungsi </h3><br>  Python memungkinkan Anda untuk menunjukkan bahwa suatu fungsi dapat memiliki argumen opsional dengan menetapkan nilai default untuk mereka.  Ini, tentu saja, adalah fitur bahasa yang sangat nyaman, tetapi dapat menyebabkan konsekuensi yang tidak menyenangkan jika jenis nilai ini bisa berubah.  Sebagai contoh, pertimbangkan definisi fungsi berikut: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=[])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># bar -    #      . ... bar.append("baz") #     ... ... return bar</span></span></code> </pre> <br>  Kesalahan umum dalam kasus ini adalah berpikir bahwa nilai argumen opsional akan ditetapkan ke nilai default setiap kali fungsi dipanggil tanpa nilai untuk argumen ini.  Dalam kode di atas, misalnya, kita dapat mengasumsikan bahwa dengan berulang kali memanggil fungsi foo () (yaitu, tanpa menentukan nilai untuk argumen bar), ia akan selalu mengembalikan "baz", karena diasumsikan bahwa setiap kali foo () dipanggil (tanpa menentukan bilah argumen), bilah diatur ke [] (yaitu, daftar kosong baru). <br><br>  Tapi mari kita lihat apa yang akan terjadi: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>]</code> </pre> <br>  Hah?  Mengapa fungsi terus menambahkan nilai default "baz" ke daftar yang ada setiap kali foo () dipanggil, alih-alih membuat daftar baru setiap kali? <br><br>  Jawaban untuk pertanyaan ini akan menjadi pemahaman yang lebih dalam tentang apa yang terjadi dengan Python "di bawah tenda".  Yaitu: nilai default untuk fungsi diinisialisasi hanya sekali, selama definisi fungsi.  Dengan demikian, argumen bilah diinisialisasi secara default (mis., Daftar kosong) hanya ketika foo () didefinisikan untuk pertama kalinya, tetapi panggilan berikutnya ke foo () (mis., Tanpa menentukan argumen bilah) akan terus menggunakan daftar yang sama dengan yang sebelumnya dibuat untuk bilah argumen pada saat definisi pertama dari fungsi. <br><br>  Untuk referensi, "solusi" umum untuk kesalahan ini adalah definisi berikut: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=None)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># or if not bar: ... bar = [] ... bar.append("baz") ... return bar ... &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"]</span></span></code> </pre> <br><h3>  Kesalahan # 2: penyalahgunaan variabel kelas </h3><br>  Perhatikan contoh berikut: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... x = <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Segalanya tampak teratur. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Bx = <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Ya, semuanya seperti yang diharapkan. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Ax = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Apa-apaan ini ?!  Kami baru saja mengganti Ax, mengapa Cx juga berubah? <br><br>  Dalam Python, variabel kelas diperlakukan seperti kamus dan mengikuti apa yang sering disebut Method Resolution Order (MRO).  Jadi, dalam kode di atas, karena atribut x tidak ditemukan di kelas C, itu akan ditemukan di kelas dasarnya (hanya A dalam contoh di atas, meskipun Python mendukung multiple inheritance).  Dengan kata lain, C tidak memiliki properti sendiri x independen dari A. Dengan demikian, referensi ke Cx sebenarnya referensi ke Axe. Ini akan menyebabkan masalah jika kasus ini tidak ditangani dengan benar.  Jadi ketika belajar Python, berikan perhatian khusus pada atribut kelas dan bekerja dengannya. <br><br><h3>  Kesalahan No. 3: Parameter salah untuk blok pengecualian </h3><br>  Misalkan Anda memiliki potongan kode berikut: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError, IndexError: <span class="hljs-comment"><span class="hljs-comment"># To catch both exceptions, right? ... pass ... Traceback (most recent call last): File "&lt;stdin&gt;", line 3, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  Masalahnya di sini adalah bahwa ekspresi pengecualian tidak menerima daftar pengecualian yang ditentukan dengan cara ini.  Sebaliknya, dalam Python 2.x, ungkapan "kecuali Pengecualian, e" digunakan untuk mengikat pengecualian ke parameter opsional kedua yang diberikan kedua (dalam hal ini, e) untuk membuatnya tersedia untuk pemeriksaan lebih lanjut.  Akibatnya, dalam kode di atas, pengecualian IndexError tidak ditangkap oleh pernyataan kecuali;  melainkan, pengecualian berakhir dengan mengikat ke parameter bernama IndexError sebagai gantinya. <br><br>  Cara yang benar untuk menangkap beberapa pengecualian dengan ekspresi pengecualian adalah dengan menentukan parameter pertama sebagai tuple yang berisi semua pengecualian yang ingin Anda tangkap.  Juga, untuk kompatibilitas maksimum, gunakan kata kunci as, karena sintaks ini didukung dalam Python 2 dan Python 3: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> (ValueError, IndexError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt;</code> </pre> <br><h3>  Kesalahan # 4: kesalahpahaman aturan lingkup Python </h3><br>  Cakupan dalam Python didasarkan pada apa yang disebut aturan LEGB, yang merupakan singkatan dari Lokal (nama yang ditetapkan dengan cara apa pun di dalam suatu fungsi (def atau lambda), dan tidak dideklarasikan global dalam fungsi ini), Melampirkan (nama dalam lingkup lokal dari semua fungsi yang termasuk secara statis) ( def atau lambda), dari internal ke eksternal), Global (nama yang ditetapkan di tingkat atas file modul, atau dengan menjalankan instruksi global di def di dalam file), Built-in (nama yang sebelumnya ditetapkan dalam modul nama built-in: open, range, Sintaksisor, ...).  Tampaknya cukup sederhana, bukan?  Sebenarnya ada beberapa seluk-beluk bagaimana ini bekerja di Python, yang membawa kita ke masalah pemrograman Python yang lebih kompleks secara umum di bawah ini.  Perhatikan contoh berikut: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... x += <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x ... &gt;&gt;&gt; foo() Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> foo UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'x'</span></span> referenced before assignment</code> </pre> <br>  Apa masalahnya? <br><br>  Kesalahan di atas terjadi karena ketika Anda menetapkan variabel dalam cakupan, Python secara otomatis menganggapnya lokal untuk cakupan itu dan menyembunyikan variabel apa pun dengan nama yang sama di lingkup orangtua mana pun. <br><br>  Dengan demikian, banyak yang terkejut ketika mereka menerima UnboundLocalError dalam kode yang sedang berjalan, ketika dimodifikasi dengan menambahkan operator penugasan di suatu tempat di badan fungsi. <br><br>  Fitur ini sangat membingungkan bagi pengembang saat menggunakan daftar.  Perhatikan contoh berikut: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>lst = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... lst.append(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   ... ... &gt;&gt;&gt; foo1() &gt;&gt;&gt; lst [1, 2, 3, 5] &gt;&gt;&gt; lst = [1, 2, 3] &gt;&gt;&gt; def foo2(): ... lst += [5] # ...    ! ... &gt;&gt;&gt; foo2() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in foo UnboundLocalError: local variable 'lst' referenced before assignment</span></span></code> </pre> <br>  Hah?  Mengapa foo2 mogok saat foo1 berfungsi dengan baik? <br><br>  Jawabannya sama seperti pada contoh sebelumnya, tetapi, menurut kepercayaan populer, situasi di sini lebih halus.  foo1 tidak menerapkan operator penugasan ke pertama, sedangkan foo2 tidak.  Mengingat bahwa lst + = [5] sebenarnya hanya sebuah singkatan untuk lst = lst + [5], kita melihat bahwa kita mencoba untuk menetapkan nilai lst (jadi Python menganggapnya dalam lingkup lokal).  Namun, nilai yang ingin kami tetapkan didasarkan pada lst itu sendiri (sekali lagi, sekarang diasumsikan dalam lingkup lokal), yang belum ditentukan.  Dan kami mendapatkan kesalahan. <br><br><h3>  Kesalahan # 5: mengubah daftar selama iterasi di atasnya </h3><br>  Masalah dalam potongan kode berikut harus cukup jelas: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(numbers)): ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> odd(numbers[i]): ... <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> numbers[i] <span class="hljs-comment"><span class="hljs-comment"># BAD: Deleting item from a list while iterating over it ... Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  Menghapus item dari daftar atau array selama iterasi di atasnya adalah masalah Python yang diketahui oleh setiap pengembang perangkat lunak yang berpengalaman.  Tetapi, meskipun contoh di atas mungkin cukup jelas, bahkan pengembang berpengalaman dapat memulai menyapu ini dalam kode yang jauh lebih kompleks. <br><br>  Untungnya, Python menyertakan sejumlah paradigma pemrograman elegan yang, jika digunakan dengan benar, dapat mengarah pada penyederhanaan dan optimalisasi kode yang signifikan.  Konsekuensi tambahan yang menyenangkan dari hal ini adalah bahwa dalam kode yang lebih sederhana, kemungkinan jatuh ke dalam kesalahan secara tidak sengaja menghapus item daftar selama iterasi lebih kecil.  Salah satu paradigma tersebut adalah generator daftar.  Selain itu, memahami operasi generator daftar sangat membantu dalam menghindari masalah khusus ini, seperti yang ditunjukkan dalam penerapan alternatif kode di atas, yang berfungsi dengan baik: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; numbers[:] = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> odd(n)] <span class="hljs-comment"><span class="hljs-comment"># ahh, the beauty of it all &gt;&gt;&gt; numbers [0, 2, 4, 6, 8]</span></span></code> </pre> <br><h3>  Kesalahan # 6: kesalahpahaman bagaimana Python mengikat variabel dalam penutupan </h3><br>  Perhatikan contoh berikut: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ...</code> </pre> <br>  Anda dapat mengharapkan output berikut: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Tetapi sebenarnya Anda mendapatkan ini: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  Kejutan! <br><br>  Hal ini disebabkan oleh keterlambatan pengikatan dengan Python, yang berarti bahwa nilai-nilai variabel yang digunakan dalam penutupan dicari selama panggilan ke fungsi internal.  Dengan demikian, dalam kode di atas, setiap kali salah satu fungsi yang dikembalikan dipanggil, nilai i dicari dalam lingkup sekitarnya selama panggilannya (dan pada saat itu siklus sudah selesai, jadi saya sudah ditugaskan hasil akhir - nilai 4) . <br><br>  Solusi untuk masalah Python umum ini adalah: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, i=i : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ... <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Voila!  Kami menggunakan argumen default di sini untuk menghasilkan fungsi anonim untuk mencapai perilaku yang diinginkan.  Beberapa akan menyebut solusi ini elegan.  Ada beberapa <br>  kurus.  Beberapa orang membenci hal-hal ini.  Tetapi jika Anda seorang pengembang Python, penting untuk dipahami. <br><br><h3>  Kesalahan # 7: membuat dependensi modul siklik </h3><br>  Misalkan Anda memiliki dua file, a.py dan b.py, masing-masing mengimpor yang lain, sebagai berikut: <br><br>  Di a.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f()</code> </pre> <br>  Di b.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> af()</code> </pre> <br>  Pertama, coba impor a.py: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Itu bekerja dengan baik.  Ini mungkin mengejutkan Anda.  Bagaimanapun, modul saling mengimpor secara siklis dan ini mungkin akan menjadi masalah, bukan? <br><br>  Jawabannya adalah bahwa hanya memiliki impor siklik modul tidak dengan sendirinya masalah dengan Python.  Jika modul sudah diimpor, Python cukup pintar untuk tidak mencoba mengimpornya kembali.  Namun, tergantung pada titik di mana setiap modul mencoba mengakses fungsi atau variabel yang ditentukan di yang lain, Anda mungkin benar-benar mengalami masalah. <br><br>  Jadi, kembali ke contoh kita, ketika kita mengimpor a.py, tidak ada masalah mengimpor b.py, karena b.py tidak mengharuskan a.py didefinisikan selama impornya.  Satu-satunya referensi dalam b.py ke a adalah panggilan ke af ().  Tapi panggilan ini di g () dan tidak ada di a.py atau b.py tidak memanggil g ().  Jadi semuanya bekerja dengan baik. <br><br>  Tetapi apa yang terjadi jika kita mencoba mengimpor b.py (tanpa mengimpor a.py, yaitu): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"b.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f() File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx AttributeError: <span class="hljs-string"><span class="hljs-string">'module'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'x'</span></span></code> </pre> <br>  Oh, oh  Ini tidak baik!  Masalahnya di sini adalah bahwa selama proses impor b.py ia mencoba mengimpor a.py, yang pada gilirannya memanggil f (), yang mencoba mengakses bx Tetapi bx belum didefinisikan.  Oleh karena itu pengecualian AttributeError. <br><br>  Setidaknya satu solusi untuk masalah ini cukup sepele.  Cukup modifikasi b.py untuk mengimpor a.py ke g (): <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-comment"><span class="hljs-comment"># This will be evaluated only when g() is called print af()</span></span></code> </pre> <br>  Sekarang ketika kita mengimpornya, semuanya baik-baik saja: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b &gt;&gt;&gt; bg() <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># Printed a first time since module 'a' calls 'print f()' at the end 1 # Printed a second time, this one is our call to 'g'</span></span></code> </pre><br><h3>  Kesalahan # 8: memotong nama dengan nama modul di pustaka standar Python </h3><br>  Salah satu daya tarik Python adalah banyak modulnya yang keluar dari kotak.  Tetapi sebagai hasilnya, jika Anda tidak secara sadar mengikuti ini, Anda mungkin menemukan bahwa nama modul Anda mungkin dengan nama yang sama dengan modul di perpustakaan standar yang datang dengan Python (misalnya, dalam kode Anda mungkin ada modul dengan nama email.py, yang akan bertentangan dengan modul perpustakaan standar dengan nama yang sama). <br><br>  Ini dapat menyebabkan masalah serius.  Misalnya, jika ada modul yang mencoba mengimpor versi modul dari pustaka standar Python, dan Anda memiliki modul dengan nama yang sama dalam proyek, yang akan salah diimpor daripada modul dari pustaka standar. <br><br>  Oleh karena itu, harus berhati-hati untuk tidak menggunakan nama yang sama seperti pada modul pustaka standar Python.  Jauh lebih mudah untuk mengubah nama modul di proyek Anda daripada mengajukan permintaan untuk mengubah nama modul di perpustakaan standar dan mendapatkan persetujuan untuk itu. <br><br><h3>  Kesalahan # 9: Gagal memperhitungkan perbedaan antara Python 2 dan Python 3 </h3><br>  Pertimbangkan file foo.py berikut: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(e) bad()</code> </pre> <br>  Pada Python 2, ini akan berfungsi dengan baik: <br><br><pre> <code class="python hljs">$ python foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Tapi sekarang mari kita lihat bagaimana cara kerjanya di Python 3: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; bad() File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bad print(e) UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'e'</span></span> referenced before assignment</code> </pre> <br>  Apa yang terjadi di sini?  "Masalahnya" adalah bahwa dalam Python 3, objek di blok pengecualian tidak tersedia di luarnya.  (Alasan untuk ini adalah bahwa jika tidak objek di blok ini akan disimpan dalam memori sampai pengumpul sampah mulai dan menghapus referensi untuk mereka dari sana). <br><br>  Salah satu cara untuk menghindari masalah ini adalah untuk menjaga referensi ke objek blok pengecualian di luar blok ini sehingga tetap tersedia.  Berikut adalah versi contoh sebelumnya yang menggunakan teknik ini, sehingga mendapatkan kode yang cocok untuk Python 2 dan Python 3: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(exception) good()</code> </pre> <br>  Jalankan dengan Python 3: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python3 foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Hore! <br><br><h3>  Kesalahan # 10: penggunaan metode __del__ secara tidak benar </h3><br>  Katakanlah Anda memiliki file mod.py seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(self.myhandle)</code> </pre> <br>  Dan Anda mencoba melakukan ini dari another_mod.py lain: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mod mybar = mod.Bar()</code> </pre> <br>  Dan dapatkan AttributeError yang mengerikan. <br><br>  Mengapa  Karena, seperti yang dilaporkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , ketika penerjemah dimatikan, variabel global modul semua memiliki nilai None.  Akibatnya, dalam contoh di atas, ketika __del__ dipanggil, nama foo sudah disetel ke None. <br><br>  Solusi untuk "tugas dengan tanda bintang" ini adalah dengan menggunakan atexit.register ().  Dengan demikian, ketika program Anda menyelesaikan eksekusi (yaitu, ketika keluar secara normal), pegangan Anda dihapus sebelum penerjemah menyelesaikan pekerjaannya. <br><br>  Dengan mengingat hal ini, perbaikan untuk kode mod.py di atas mungkin terlihat seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> atexit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handle)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(handle) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... atexit.register(cleanup, self.myhandle)</code> </pre> <br>  Implementasi seperti itu menyediakan cara yang sederhana dan dapat diandalkan untuk memanggil pembersihan yang diperlukan setelah penghentian program normal.  Jelas, keputusan tentang bagaimana berurusan dengan objek yang berhubungan dengan diri. Nama saya ditangani foo.cleanup, tapi saya pikir Anda mengerti idenya. <br><br><h3>  Kesimpulan </h3><br>  Python adalah bahasa yang kuat dan fleksibel dengan banyak mekanisme dan paradigma yang dapat secara signifikan meningkatkan kinerja.  Namun, seperti halnya perangkat atau bahasa perangkat lunak apa pun, dengan pemahaman atau evaluasi terbatas atas kemampuannya, masalah yang tidak terduga dapat muncul selama pengembangan. <br><br>  Pengantar nuansa Python tercakup dalam artikel ini akan membantu mengoptimalkan penggunaan bahasa Anda, sambil menghindari beberapa kesalahan umum. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466441/">https://habr.com/ru/post/id466441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466431/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 40. Standar 802.1X dan Keluarga Protokol AAA</a></li>
<li><a href="../id466433/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 41. DHCP Mengintai dan Nondefault NLAN VLAN</a></li>
<li><a href="../id466435/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 42. Routing Antar-VLAN dan SVI</a></li>
<li><a href="../id466437/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 43. Protokol Routing Distance Vector dan Link State</a></li>
<li><a href="../id466439/index.html">Periksa diri Anda: berapa banyak pertanyaan yang dapat Anda jawab ChGK?</a></li>
<li><a href="../id466443/index.html">ShIoTiny dan dunia: sensor analog atau ADC untuk yang terkecil</a></li>
<li><a href="../id466445/index.html">Serangan antara trust di antara domain</a></li>
<li><a href="../id466447/index.html">Untuk apa kita membangun CDN?</a></li>
<li><a href="../id466449/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 44. Pengantar OSPF</a></li>
<li><a href="../id466451/index.html">Baca_Anda tidak bisa_menghapus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>