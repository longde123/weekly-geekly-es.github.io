<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌈 ♏️ 🐇 Mengikuti jejak kalkulator: Hitung Ulang 🙍🏽 😑 👩🏾‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebelumnya kami melakukan review kode dari paket matematika besar, misalnya, Scilab dan Oktaf, dan kalkulator tetap sebagai utilitas kecil di mana sul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengikuti jejak kalkulator: Hitung Ulang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/443654/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8-/gy/xn/8-gyxngfcuknt6ufomhpg4kpjry.png"></div><br>  Sebelumnya kami melakukan review kode dari paket matematika besar, misalnya, Scilab dan Oktaf, dan kalkulator tetap sebagai utilitas kecil di mana sulit untuk membuat kesalahan karena ukuran kode yang kecil.  Kami keliru karena tidak memperhatikan mereka.  Kasus dengan penerbitan kode sumber kalkulator Windows menunjukkan bahwa semua orang tertarik untuk membahas kesalahan apa yang disembunyikan di sana, dan ada lebih dari cukup kesalahan di sana untuk menulis artikel tentang itu.  Saya dan kolega saya memutuskan untuk memeriksa kode sejumlah kalkulator populer, dan ternyata kode kalkulator Windows tidak terlalu buruk (spoiler). <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hitung Ulang!</a>  - Kalkulator lintas platform universal.  Mudah digunakan, tetapi memberikan kekuatan dan keserbagunaan yang biasanya ditemukan dalam paket matematika yang kompleks, serta alat yang berguna untuk kebutuhan sehari-hari (seperti konversi mata uang dan perhitungan bunga).  Proyek ini terdiri dari dua komponen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libqalculate</a> (library dan CLI) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qalculate-gtk</a> (GTK + UI).  Hanya kode libqalculate yang terlibat dalam penelitian ini. <br><br>  Untuk lebih mudah membandingkan proyek dengan kalkulator Windows yang sama dengan yang baru-baru ini kami teliti, saya memberikan output dari utilitas Cloc untuk libqalculate: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/214/1f7/e35/2141f7e35bc5af14579e61f9bf4d907a.png" alt="Gambar 4"></div><br>  Secara subyektif, ada lebih banyak kesalahan, dan lebih kritis daripada dalam kode kalkulator Windows.  Tapi saya sarankan Anda menarik kesimpulan sendiri dengan membaca ulasan kode ini. <br><br>  Omong-omong, berikut ini tautan ke artikel tentang memeriksa kalkulator dari Microsoft: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghitung bug di kalkulator Windows.</a> " <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> digunakan sebagai alat analisis statis.  Ini adalah serangkaian solusi untuk kontrol kualitas kode, mencari kesalahan dan kerentanan potensial.  Bahasa yang didukung meliputi: C, C ++, C #, dan Java.  Alat analisis dapat diluncurkan pada Windows, Linux dan macOS. <br><br><h2>  Salin-tempel dan salah ketik lagi! </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V523</a> Pernyataan 'lalu' sama dengan pernyataan 'lain'.  Number.cc 4018 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::square() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mpfr_cmpabs(i_value-&gt;internalLowerFloat(), i_value-&gt;internalUpperFloat()) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } .... }</code> </pre> <br>  Kode dalam pernyataan <i>if</i> dan <i>else</i> persis sama.  Fragmen kode tetangga sangat mirip dengan ini, tetapi mereka menggunakan fungsi yang berbeda: <i>internalLowerFloat ()</i> dan <i>internalUpperFloat ()</i> .  Aman untuk berasumsi bahwa di sini programmer menyalin kode dan lupa untuk memperbaiki nama fungsinya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V501</a> Ada sub-ekspresi identik '! Mtr2.number (). IsReal ()' di kiri dan di kanan '||'  operator.  BuiltinFunctions.cc 6274 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IntegrateFunction::calculate(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mtr2.isNumber() || !mtr2.number().isReal() || !mtr.isNumber() || !mtr2.number().isReal()) b_unknown_precision = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  Di sini ekspresi rangkap muncul karena di satu tempat bukan nama <i>mtr mereka</i> menulis <i>mtr2</i> .  Jadi, dalam kondisi tidak ada panggilan ke fungsi <i>mtr.number (). IsReal ()</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V501</a> Ada sub-ekspresi identik 'muatan [1] .representsNonPositive ()' ke kiri dan ke kanan '||'  operator.  BuiltinFunctions.cc 5785 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9fe/18d/e5c/9fe18de5c88498e1cc8e56e2c91ddcd7.png" alt="Gambar 6"></p><br><br>  Menemukan anomali dalam kode ini secara manual tidak nyata!  Tetapi mereka.  Selain itu, dalam file asli, fragmen-fragmen ini ditulis dalam satu baris.  Penganalisa mendeteksi duplikat ekspresi <i>muatan [1]. Merepresentasikan NonPositive ()</i> , yang dapat mengindikasikan kesalahan ketik dan, oleh karena itu, kesalahan potensial. <br><br>  Berikut adalah seluruh daftar tempat mencurigakan yang sulit Anda ketahui: <br><br><ul><li>  V501 Ada sub-ekspresi identik 'muatan [1] .representsNonPositive ()' ke kiri dan ke kanan '||'  operator.  BuiltinFunctions.cc 5788 </li><li>  V501 Ada sub-ekspresi identik 'tambahkan' ke kiri dan ke kanan operator '&amp;&amp;'.  MathStructure.cc 1780 </li><li>  V501 Ada sub-ekspresi identik 'tambahkan' ke kiri dan ke kanan operator '&amp;&amp;'.  MathStructure.cc 2043 </li><li>  V501 Ada sub-ekspresi yang identik '(* v_subs [v_order [1]]). Merupakan Representatif (benar)' di sebelah kiri dan di sebelah kanan operator '&amp;&amp;'.  MathStructure.cc 5569 </li></ul><br><h2>  Loop Tidak Valid </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V534</a> Kemungkinan variabel yang salah sedang dibandingkan di dalam operator 'untuk'.  Pertimbangkan untuk meninjau 'i'.  MathStructure.cc 28741 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> MathStructure::isolate_x_sub(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar-&gt;size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar)[i].contains(x_var)) { mvar2 = &amp;(*mvar)[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mvar-&gt;isMultiplication()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar2-&gt;size(); i2++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar2)[i2].contains(x_var)) {mvar2 = &amp;(*mvar2)[i2]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Dalam loop internal, penghitung adalah variabel <i>i2</i> , tetapi karena kesalahan ketik, kesalahan dibuat - dalam kondisi loop berhenti, variabel <i>i</i> dari loop eksternal digunakan. <br><br><h2>  Redundansi atau kesalahan? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V590</a> Pertimbangkan untuk memeriksa ungkapan ini.  Ekspresi berlebihan atau mengandung kesalahan cetak.  Number.cc 6564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::add(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Number &amp;o, MathOperation op) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i1 &gt;= COMPARISON_RESULT_UNKNOWN &amp;&amp; (i2 == COMPARISON_RESULT_UNKNOWN || i2 != COMPARISON_RESULT_LESS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... }</code> </pre> <br>  Setelah melihat kode seperti itu, 3 tahun yang lalu saya menulis catatan untuk membantu diri saya sendiri dan programmer lain: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ekspresi logis dalam C / C ++. Betapa profesionalnya salah</a> ."  Setelah menemukan kode seperti itu, saya yakin bahwa catatan itu menjadi kurang relevan sama sekali.  Anda dapat melihat di artikel, menemukan pola kesalahan yang sesuai dengan kode, dan mencari tahu semua nuansanya. <br><br>  Dalam kasus contoh ini, buka bagian "Ekspresi == ||  ! = ”Dan kita belajar bahwa ungkapan <i>i2 == COMPARISON_RESULT_UNKNOWN</i> tidak memengaruhi apa pun. <br><br><h2>  Merujuk referensi yang tidak diverifikasi </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595 Pointer</a> 'o_data' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 1108, 1112. DataSet.cc 1108 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DataObjectArgument::subprintlong() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = _(<span class="hljs-string"><span class="hljs-string">"an object from"</span></span>); str += <span class="hljs-string"><span class="hljs-string">" \""</span></span>; str += o_data-&gt;title(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= str += "\""; DataPropertyIter it; DataProperty *o = NULL; if(o_data) { // &lt;= o = o_data-&gt;getFirstProperty(&amp;it); } .... }</span></span></code> </pre> <br>  Pointer <i>o_data</i> dalam satu fungsi dereferenced tanpa memeriksa dan dengan memeriksa.  Ini mungkin kode yang berlebihan, atau kesalahan potensial.  Saya cenderung ke opsi terakhir. <br><br>  Ada dua tempat serupa: <br><br><ul><li>  V595 Pointer 'o_assumption' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 229, 230. Variable.cc 229 </li><li>  V595 Pointer 'i_value' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 3412, 3427. Number.cc 3412 </li></ul><br><h2>  gratis () atau hapus []? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V611</a> Memori dialokasikan menggunakan operator 'baru' tetapi dirilis menggunakan fungsi 'bebas'.  Pertimbangkan untuk memeriksa logika operasi di belakang variabel 'remcopy'.  Number.cc 8123 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Number::print(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!exact &amp;&amp; precision2 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(try_infinite_series) { remcopy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mpz_t</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= mpz_init_set(*remcopy, remainder); } mpz_mul_si(remainder, remainder, base); mpz_tdiv_qr(remainder, remainder2, remainder, d); exact = (mpz_sgn(remainder2) == 0); if(!started) { started = (mpz_sgn(remainder) != 0); } if(started) { mpz_mul_si(num, num, base); mpz_add(num, num, remainder); } if(try_infinite_series) { if(started &amp;&amp; first_rem_check == 0) { remainders.push_back(remcopy); } else { if(started) first_rem_check--; mpz_clear(*remcopy); free(remcopy); // &lt;= } } .... } .... }</span></span></code> </pre> <br>  Memori untuk array <i>salinan</i> dialokasikan dan dibebaskan dalam berbagai cara, yang merupakan kesalahan serius. <br><br><h2>  Perubahan yang hilang </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expand_partial_fractions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MathStructure &amp;m, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(b_poly &amp;&amp; !mquo.isZero()) { MathStructure m = mquo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mrem.isZero()) { m += mrem; m.last() *= mtest[i]; m.childrenUpdated(); } expand_partial_fractions(m, eo, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  Variabel <i>m</i> diterima dalam fungsi dengan referensi, yang menyiratkan modifikasinya.  Tetapi penganalisa menemukan bahwa kode tersebut berisi variabel lokal dengan nama yang sama, yang tumpang tindih lingkup parameter fungsi, yang memungkinkan hilangnya perubahan. <br><br><h2>  Pointer aneh </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V774 Penunjuk</a> 'cu' digunakan setelah memori dilepaskan.  Calculator.cc 3595 <br><br><pre> <code class="cpp hljs">MathStructure Calculator::convertToBestUnit(....) { .... CompositeUnit *cu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeUnit(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"...."</span></span>); cu-&gt;add(....); Unit *u = getBestUnit(cu, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, eo.local_currency_conversion); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(u == cu) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> cu; <span class="hljs-comment"><span class="hljs-comment">// &lt;= return mstruct_new; } delete cu; // &lt;= if(eo.approximation == APPROXIMATION_EXACT &amp;&amp; cu-&gt;hasApproximateRelationTo(u, true)) { // &lt;= if(!u-&gt;isRegistered()) delete u; return mstruct_new; } .... }</span></span></code> </pre> <br>  Penganalisa memperingatkan bahwa kode berisi panggilan ke metode objek <i>cu</i> setelah membebaskan memori.  Tetapi jika Anda mencoba memahami kode tersebut, maka itu akan menjadi lebih aneh.  Pertama, panggilan untuk <i>menghapus cu</i> selalu terjadi - dalam kondisi dan setelah.  Kedua, kode setelah kondisi mengasumsikan bahwa pointer <i>u</i> dan <i>cu</i> tidak sama, jadi setelah membersihkan objek <i>cu</i> , adalah logis untuk menggunakan objek <i>u</i> .  Kemungkinan besar, kesalahan ketik dibuat dalam kode dan direncanakan hanya menggunakan variabel <i>u</i> . <br><br><h2>  Menggunakan fungsi find </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V797</a> Fungsi 'find' digunakan seolah-olah mengembalikan tipe bool.  Nilai pengembalian fungsi mungkin harus dibandingkan dengan std :: string :: npos.  Unit.cc 404 <br><br><pre> <code class="cpp hljs">MathStructure &amp;AliasUnit::convertFromFirstBaseUnit(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i_exp != <span class="hljs-number"><span class="hljs-number">1</span></span>) mexp /= i_exp; ParseOptions po; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isApproximate() &amp;&amp; suncertainty.empty() &amp;&amp; precision() == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sinverse.find(DOT) || svalue.find(DOT)) po.read_precision = READ_PRECISION_WHEN_DECIMALS; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> po.read_precision = ALWAYS_READ_PRECISION; } .... }</code> </pre> <br>  Meskipun kode berhasil dikompilasi, itu terlihat mencurigakan karena fungsi <i>find</i> mengembalikan sejumlah tipe <i>std :: string :: size_type</i> .  Kondisi akan benar jika titik ditemukan di mana saja di telepon, kecuali jika titik di awal.  Ini adalah tes yang aneh.  Saya tidak yakin, tapi mungkin kodenya harus ditulis ulang sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sinverse.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos || svalue.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { po.read_precision = READ_PRECISION_WHEN_DECIMALS; }</code> </pre> <br><h2>  Potensi kebocoran memori </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V701</a> realloc () kemungkinan kebocoran: ketika realloc () gagal mengalokasikan memori, 'buffer' pointer asli hilang.  Pertimbangkan untuk menetapkan realloc () ke pointer sementara.  util.cc 703 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">utf8_strdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_ICU .... outlength = length + 4; buffer = (char*) realloc(buffer, outlength * sizeof(char)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= .... #else return NULL; #endif }</span></span></span></span></code> </pre> <br>  Ketika bekerja dengan fungsi <i>realloc ()</i> , disarankan untuk menggunakan buffer perantara, karena jika tidak mungkin mengalokasikan memori, pointer ke memori lama akan hilang. <br><br><h2>  Kesimpulan </h2><br>  Proyek perhitungan ulang!  berada di puncak daftar kalkulator gratis terbaik, sementara itu berisi banyak kesalahan serius.  Tapi kita belum melihat kompetitornya.  Kami akan mencoba menelusuri semua kalkulator populer. <br><br>  Sedangkan untuk perbandingannya dengan kualitas kalkulator dari dunia Windows, sedangkan utilitas dari Microsoft terlihat lebih andal dan berkualitas tinggi. <br><br>  Periksa "Kalkulator" Anda dengan mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> dan mencobanya di proyek Anda.  :-) <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Svyatoslav Razmyslov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengikuti Jejak Kalkulator: Hitung Ulang!</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443654/">https://habr.com/ru/post/id443654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443642/index.html">Administrator NASA menganggap mungkin mengirim Orion pada pelayaran pertama keliling bulan dengan roket komersial</a></li>
<li><a href="../id443644/index.html">Gulung telur dengan Unity</a></li>
<li><a href="../id443648/index.html">Dokumentasi pengguna: apa yang membuatnya buruk dan bagaimana cara memperbaikinya</a></li>
<li><a href="../id443650/index.html">Begitu-begitu-begitu dan tidak ada tic. Apa perbedaan antara prosesor Intel Core dari generasi yang berbeda berdasarkan satu arsitektur</a></li>
<li><a href="../id443652/index.html">Setiap hari di Outlook saya baru saja ...</a></li>
<li><a href="../id443656/index.html">Mengikuti Jejak Kalkulator: Hitung Ulang</a></li>
<li><a href="../id443658/index.html">Mengkonfigurasi kluster HA Kubernetes pada logam telanjang, pemantauan, log, dan contoh penggunaan. Bagian 3/3</a></li>
<li><a href="../id443660/index.html">Para ahli: "Pemindai 3D biayanya 10 kali lebih murah daripada kesalahan dengan kontrol kualitas tradisional"</a></li>
<li><a href="../id443662/index.html">Memahami Kode Bersih di Android</a></li>
<li><a href="../id443664/index.html">Stasiun Cuaca Arduino</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>