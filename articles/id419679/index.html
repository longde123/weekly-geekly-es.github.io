<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•§ üç° üßñüèº Menerapkan Spring Framework API dari awal. Panduan untuk pemula. Bagian 1 üëâüèª ‚ÄºÔ∏è üèöÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kerangka Kerja Musim Semi adalah salah satu kerangka kerja yang paling rumit untuk memahami dan belajar. Kebanyakan pengembang mempelajarinya secara p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menerapkan Spring Framework API dari awal. Panduan untuk pemula. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419679/"><img src="https://habrastorage.org/webt/iw/mz/82/iwmz824_ptetkxwvc6sqtwjmbjw.png"><br><br>  Kerangka Kerja Musim Semi adalah salah satu kerangka kerja yang paling rumit untuk memahami dan belajar.  Kebanyakan pengembang mempelajarinya secara perlahan, melalui tugas-tugas praktis dan google.  Pendekatan ini tidak efektif, karena tidak memberikan gambaran yang lengkap dan pada saat yang sama mahal. <br><br>  Saya ingin menawarkan kepada Anda pendekatan baru yang fundamental untuk studi Spring.  Ini terdiri dari kenyataan bahwa seseorang melewati serangkaian tutorial yang disiapkan secara khusus dan secara mandiri mengimplementasikan fungsionalitas pegas.  Keunikan dari pendekatan ini adalah bahwa, selain pemahaman 100% dari aspek yang dipelajari dari Spring, itu juga memberikan peningkatan besar pada Java Core (Annotations, Reflection, Files, Generics). <br><br>  Artikel ini akan memberi Anda pengalaman yang tak terlupakan dan membuat Anda merasa seperti pengembang penting.  Langkah demi langkah, Anda akan membuat kacang kelas Anda dan mengatur siklus hidup mereka (sama seperti di musim semi yang nyata).  Kelas yang akan Anda terapkan adalah <b>BeanFactory</b> , <b>Komponen</b> , <b>Layanan</b> , <b>BeanPostProcessor</b> , <b>BeanNameAware</b> , <b>BeanFactoryAware</b> , <b>InisialisasiBean</b> , <b>PostConstruct</b> , <b>PreDestroy</b> , <b>DisposableBean</b> , <b>ApplicationContext</b> , <b>ApplicationListener</b> , <b>ContextClosedEvent</b> . <br><a name="habracut"></a><br><h2>  Sedikit tentang dirimu </h2><br>  Nama saya Yaroslav dan saya seorang Pengembang Java dengan pengalaman 4 tahun.  Saat ini saya bekerja untuk Sistem EPAM (SPB), dan saya mempelajari secara mendalam teknologi yang kami gunakan.  Cukup sering saya harus berurusan dengan musim semi, dan saya melihat di dalamnya beberapa jalan tengah di mana Anda dapat tumbuh (Jawa semua orang tahu dengan baik, dan alat dan teknologi yang terlalu spesifik dapat datang dan pergi). <br><br>  Beberapa bulan yang lalu, saya lulus sertifikasi Spring Professional v5.0 (tanpa mengambil kursus).  Setelah itu, saya berpikir tentang cara mengajar orang lain meloncat.  Sayangnya, saat ini tidak ada metodologi pengajaran yang efektif.  Sebagian besar pengembang memiliki ide kerangka kerja yang sangat dangkal dan fitur-fiturnya.  Debug sumber mata air terlalu sulit dan sama sekali tidak efektif dari sudut pandang pelatihan (entah bagaimana saya suka ini).  Apakah 10 proyek?  Ya, di suatu tempat Anda dapat memperdalam pengetahuan Anda dan mendapatkan banyak pengalaman praktis, tetapi banyak dari apa yang "tersembunyi" tidak akan pernah terbuka sebelum Anda.  Baca Spring in Action?  Keren, tetapi usaha yang mahal.  Saya sudah bekerja 40% (selama persiapan sertifikasi), tapi itu tidak mudah. <br><br>  Satu-satunya cara untuk memahami sesuatu sampai akhir adalah mengembangkannya sendiri.  Baru-baru ini, saya memiliki gagasan bahwa Anda dapat memimpin seseorang melalui tutorial menarik yang akan mengawasi pengembangan kerangka DI-nya.  Fitur utamanya adalah bahwa API akan bertepatan dengan API yang sedang dipelajari.  Kedahsyatan pendekatan ini adalah bahwa selain pemahaman mendalam (tanpa spasi) tentang pegas, seseorang akan mendapatkan sejumlah besar pengalaman di Java Core.  Terus terang, saya sendiri belajar banyak hal baru selama persiapan artikel, baik di Spring dan di Java Core.  Ayo mulai berkembang! <br><br><h2>  Proyeksikan dari awal </h2><br>  Jadi, hal pertama yang harus dilakukan adalah membuka IDE favorit Anda dan membuat proyek dari awal.  Kami tidak akan menghubungkan Maven atau perpustakaan pihak ketiga mana pun.  Kami bahkan tidak akan menghubungkan dependensi Spring.  Tujuan kami adalah mengembangkan API yang paling mirip dengan Spring API, dan mengimplementasikannya sendiri. <br><br>  Dalam proyek bersih, buat 2 paket utama.  Paket pertama adalah aplikasi Anda ( <code>com.kciray</code> ), dan kelas <code>Main.java</code> di dalamnya.  Paket kedua adalah org.springframework.  Ya, kami akan menduplikasi struktur paket pegas asli, nama kelasnya dan metode mereka.  Ada efek yang menarik - ketika Anda membuat sesuatu milik Anda sendiri, efek Anda sendiri mulai tampak sederhana dan dapat dimengerti.  Kemudian, ketika Anda bekerja di proyek-proyek besar, akan tampak bagi Anda bahwa semuanya dibuat di sana berdasarkan benda kerja Anda.  Pendekatan ini dapat memiliki efek yang sangat positif pada pemahaman sistem secara keseluruhan, memperbaikinya, memperbaiki bug, menyelesaikan masalah, dan sebagainya. <br><br>  Jika Anda memiliki masalah, Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengambil</a> proyek yang berfungsi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Buat wadah </h2><br>  Untuk memulai, atur tugas.  Misalkan kita memiliki 2 kelas - <code>ProductFacade</code> dan <code>PromotionService</code> .  Sekarang bayangkan Anda ingin menghubungkan kelas-kelas ini satu sama lain, tetapi agar kelas-kelas itu sendiri tidak saling mengenal (Pattern DI).  Kami membutuhkan kelas terpisah yang akan mengelola semua kelas ini dan menentukan dependensi di antara mereka.  Sebut saja wadah.  Mari kita buat kelas <code>Container</code> ... Meskipun tidak, tunggu!  Musim semi tidak memiliki kelas wadah tunggal.  Kami memiliki banyak implementasi kontainer, dan semua implementasi ini dapat dibagi menjadi 2 jenis - pabrik dan konteks bin.  Pabrik bin membuat kacang dan menautkannya bersama-sama (injeksi ketergantungan, DI), dan konteksnya hampir sama, ditambah lagi menambahkan beberapa fitur tambahan (misalnya, pesan internasionalisasi).  Tetapi kita tidak memerlukan fungsi tambahan ini sekarang, jadi kita akan bekerja dengan pabrik bin. <br><br>  Buat kelas <code>BeanFactory</code> baru dan masukkan ke dalam paket <code>org.springframework.beans.factory</code> .  Biarkan <code>Map&lt;String, Object&gt; singletons</code> disimpan di dalam kelas ini, di mana <code>id</code> nampan dipetakan ke nampan itu sendiri.  Tambahkan padanya metode <code>Object getBean(String beanName)</code> , yang menarik biji dengan pengidentifikasi. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Object&gt; singletons = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String beanName)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singletons.get(beanName); } }</code> </pre> <br>  Harap dicatat bahwa <code>BeanFactory</code> dan <code>FactoryBean</code> adalah dua hal yang berbeda.  Yang pertama adalah pabrik bin (wadah), dan yang kedua adalah pabrik bin, yang duduk di dalam wadah dan juga menghasilkan sampah.  Pabrik di dalam pabrik.  Jika Anda bingung antara definisi ini, Anda mungkin ingat bahwa dalam bahasa Inggris kata benda kedua adalah yang pertama, dan yang pertama adalah sesuatu seperti kata sifat.  Di Bean <b>Factory,</b> kata utama adalah factory, dan di Factory <b>Bean</b> , bean. <br><br>  Sekarang, buat kelas <code>ProductService</code> dan <code>PromotionsService</code> .  <code>ProductService</code> akan mengembalikan produk dari basis data, tetapi sebelum itu Anda perlu memeriksa apakah ada diskon (Promosi) yang berlaku untuk produk ini.  Dalam e-commerce, pekerjaan yang didiskon seringkali dialokasikan ke kelas layanan yang terpisah (dan terkadang ke layanan web pihak ketiga). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PromotionsService promotionsService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PromotionsService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promotionsService; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PromotionsService promotionsService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.promotionsService = promotionsService; } }</code> </pre><br>  Sekarang kita perlu membuat wadah kita ( <code>BeanFactory</code> ) mendeteksi kelas kita, membuatnya untuk kita dan menyuntikkan satu ke yang lain.  Operasi seperti <code>new ProductService()</code> harus ditempatkan di dalam wadah dan dilakukan untuk pengembang.  Mari kita gunakan pendekatan paling modern (pemindaian kelas dan anotasi).  Untuk melakukan ini, kita perlu membuat anotasi <code>@Component</code> dengan <code>@Component</code> ( <code> org.springframework.beans.factory.stereotype</code> ). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Component { }</code> </pre><br>  Secara default, anotasi tidak dimuat ke dalam memori saat program sedang berjalan ( <code>RetentionPolicy.CLASS</code> ).  Kami mengubah perilaku ini melalui kebijakan penyimpanan baru ( <code>RetentionPolicy.RUNTIME</code> ). <br><br>  Sekarang tambahkan <code>@Component</code> sebelum kelas <code>ProductService</code> dan sebelum <code>PromotionService</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } @Component public class PromotionService { //... }</span></span></code> </pre> <br><br>  Kami membutuhkan <code>BeanFactory</code> memindai paket kami ( <code>com.kciray</code> ) dan menemukan kelas di dalamnya yang dianotasi oleh <code>@Component</code> .  Tugas ini jauh dari sepele.  Tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada solusi siap pakai</a> di Java Core, dan kita harus membuat sendiri tongkat penyangga.  Ribuan aplikasi pegas menggunakan pemindaian komponen melalui kruk ini.  Anda telah mempelajari kebenaran yang mengerikan.  Anda harus mengekstrak nama <code>ClassLoader</code> dari <code>ClassLoader</code> dan memeriksa <code>ClassLoader</code> mereka diakhiri dengan ".class" atau tidak, dan kemudian membangun nama lengkap mereka dan mengeluarkan objek kelas dari sana! <br><br>  Saya ingin segera memperingatkan Anda bahwa akan ada banyak pengecualian yang diperiksa, jadi bersiaplah untuk membungkusnya.  Tapi pertama-tama, mari kita putuskan apa yang kita inginkan.  Kami ingin menambahkan metode khusus ke <code>BeanFactory</code> dan menyebutnya di <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java public class BeanFactory{ public void instantiate(String basePackage) { } } //Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray");</span></span></code> </pre><br>  Selanjutnya, kita perlu mendapatkan <code>ClassLoader</code> .  Ini bertanggung jawab untuk memuat kelas, dan itu diekstraksi cukup sederhana: <br><br><pre> <code class="java hljs">ClassLoader classLoader = ClassLoader.getSystemClassLoader();</code> </pre> <br>  Anda mungkin sudah memperhatikan bahwa paket dipisahkan oleh titik, dan file oleh garis miring.  Kita perlu mengonversi jalur kumpulan ke jalur folder, dan mendapatkan sesuatu seperti <code>List&lt;URL&gt;</code> (jalur di sistem file Anda tempat Anda dapat mencari file kelas). <br><br><pre> <code class="java hljs">String path = basePackage.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//"com.kciray" -&gt; "com/kciray" Enumeration&lt;URL&gt; resources = classLoader.getResources(path);</span></span></code> </pre> <br>  Jadi tunggu sebentar!  <code>Enumeration&lt;URL&gt;</code> bukan <code>List&lt;URL&gt;</code> .  Tentang apa semua ini?  Oh, ngeri, ini leluhur leluhur <code>Iterator</code> , tersedia sejak Java 1.0.  Ini adalah warisan yang harus kita tangani.  Jika dimungkinkan untuk berjalan menggunakan <code>Iterable</code> menggunakan untuk (semua koleksi mengimplementasikannya), maka dalam kasus <code>Enumeration</code> Anda harus melakukan bypass pegangan, through <code>while(resources.hasMoreElements())</code> dan <code>nextElement()</code> .  Namun tidak ada cara untuk menghapus item dari koleksi.  Baru tahun 1996, hanya hardcore.  Oh ya, di Java 9 mereka menambahkan metode <code>Enumeration.asIterator()</code> , jadi Anda bisa mengatasinya. <br><br>  Mari kita melangkah lebih jauh.  Kita perlu mengekstrak folder dan bekerja melalui konten masing-masing.  Konversikan URL menjadi file, lalu dapatkan namanya.  Perlu dicatat di sini bahwa kami tidak akan memindai paket bersarang sehingga tidak menyulitkan kode.  Anda dapat memperumit tugas Anda dan melakukan rekursi jika Anda mau. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (resources.hasMoreElements()) { URL resource = resources.nextElement(); File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(resource.toURI()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(File classFile : file.listFiles()){ String fileName = classFile.getName();<span class="hljs-comment"><span class="hljs-comment">//ProductService.class } }</span></span></code> </pre><br>  Selanjutnya, kita perlu mendapatkan nama file tanpa ekstensi.  Di halaman pada tahun 2018, Java telah mengembangkan File I / O (NIO 2) selama bertahun-tahun, tetapi masih tidak dapat memisahkan ekstensi dari nama file.  Saya harus membuat sepeda sendiri, karena  kami memutuskan untuk tidak menggunakan perpustakaan pihak ketiga seperti Apache Commons.  Mari kita gunakan cara kakek lama <code>lastIndexOf(".")</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fileName.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>)){ String className = fileName.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"."</span></span>)); }</code> </pre> <br>  Selanjutnya, kita bisa mendapatkan objek kelas menggunakan nama lengkap kelas (untuk ini kita sebut kelas kelas <code>Class</code> ): <br><br><pre> <code class="java hljs">Class classObject = Class.forName(basePackage + <span class="hljs-string"><span class="hljs-string">"."</span></span> + className);</code> </pre> <br>  Oke, sekarang kelas kita ada di tangan kita.  Lebih jauh, itu hanya untuk menyoroti di antara mereka yang memiliki anotasi <code>@Component</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(classObject.isAnnotationPresent(Component.class)){ System.out.println(<span class="hljs-string"><span class="hljs-string">"Component: "</span></span> + classObject); }</code> </pre> <br>  Jalankan dan periksa.  Konsol harus seperti ini: <br><br><pre> <code class="bash hljs">Component: class com.kciray.ProductService Component: class com.kciray.PromotionsService</code> </pre> <br>  Sekarang kita perlu membuat kacang kita.  Anda perlu melakukan sesuatu seperti <code>new ProductService()</code> , tetapi untuk setiap kacang kami memiliki kelas kami sendiri.  Refleksi di Jawa memberi kami solusi universal (konstruktor default disebut): <br><br><pre> <code class="java hljs">Object instance = classObject.newInstance();<span class="hljs-comment"><span class="hljs-comment">//=new CustomClass()</span></span></code> </pre> <br>  Selanjutnya, kita perlu meletakkan kacang ini di <code>Map&lt;String, Object&gt; singletons</code> .  Untuk melakukan ini, pilih nama kacang (id-nya).  Di Jawa, kami memanggil variabel seperti kelas (hanya huruf pertama yang menggunakan huruf kecil).  Pendekatan ini juga dapat diterapkan pada kacang, karena Spring adalah kerangka kerja Java!  Konversikan nama nampan sehingga huruf pertama kecil, dan tambahkan ke peta: <br><br><pre> <code class="java hljs">String beanName = className.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toLowerCase() + className.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); singletons.put(beanName, instance);</code> </pre> <br>  Sekarang pastikan semuanya berfungsi.  Wadah harus membuat kacang, dan harus diambil dengan nama.  Harap perhatikan bahwa nama metode <code>instantiate()</code> dan nama metode <code>classObject.newInstance();</code>  memiliki akar yang sama.  Selain itu, <code>instantiate()</code> adalah bagian dari siklus hidup kacang.  Di Jawa, semuanya saling berhubungan! <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray"); ProductService productService = (ProductService) beanFactory.getBean("productService"); System.out.println(productService);//ProductService@612</span></span></code> </pre> <br><br>  Coba juga <code>org.springframework.beans.factory.stereotype.Service</code> anotasi <code>org.springframework.beans.factory.stereotype.Service</code> .  Ia melakukan fungsi yang persis sama dengan <code>@Component</code> , tetapi disebut berbeda.  Intinya adalah dalam nama - Anda menunjukkan bahwa kelas adalah layanan, bukan hanya komponen.  Ini adalah sesuatu seperti mengetik konseptual.  Dalam sertifikasi musim semi ada pertanyaan "Apa penjelasan yang distereotipkan?"  (dari yang terdaftar). "  Jadi, penjelasan stereotip adalah yang ada dalam paket <code>stereotype</code> . <br><br><h2>  Isi propertinya </h2><br>  Lihat diagram di bawah, ini menunjukkan awal dari siklus hidup kacang.  Apa yang kami lakukan sebelum ini adalah Instantiate (membuat kacang melalui <code>newInstance()</code> ).  Langkah selanjutnya adalah injeksi silang kacang (injeksi ketergantungan, itu juga inversi kontrol (IOC)).  Anda harus memeriksa sifat-sifat kacang dan memahami sifat-sifat mana yang perlu disuntikkan.  Jika Anda memanggil <code>productService.getPromotionsService()</code> , Anda akan mendapatkan <code>null</code> , karena  ketergantungan belum ditambahkan. <br><br><img src="https://habrastorage.org/webt/2i/4v/4c/2i4v4cbsb-bdpdrgb0grh_swclu.png"><br><br>  Pertama, buat paket <code>org.springframework.beans.factory.annotation</code> dan tambahkan anotasi <code>@Autowired</code> .  Idenya adalah untuk menandai bidang yang dependensi dengan anotasi ini. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Autowired { }</code> </pre> <br>  Selanjutnya, tambahkan ke properti: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> PromotionsService promotionsService; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Sekarang kita perlu mengajari <code>BeanFactory</code> kita <code>BeanFactory</code> menemukan anotasi ini dan menyuntikkan dependensi padanya.  Tambahkan metode terpisah untuk ini, dan panggil dari <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... public void populateProperties(){ System.out.println("==populateProperties=="); } }</span></span></code> </pre> <br>  Selanjutnya, kita hanya perlu melalui semua kacang kita di peta <code>singletons</code> , dan untuk setiap kacang, melalui semua bidangnya ( <code>object.getClass().getDeclaredFields()</code> mengembalikan semua bidang, termasuk yang pribadi).  Dan periksa apakah bidang tersebut memiliki anotasi <code>@Autowired</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Field field : object.getClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.isAnnotationPresent(Autowired.class)) { } } }</code> </pre> <br>  Selanjutnya, kita perlu memeriksa semua tempat sampah sekali lagi dan melihat tipenya - tiba-tiba ini adalah tipe yang ingin diambil oleh bin kita sendiri.  Ya, kami mendapatkan siklus tiga dimensi! <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object dependency : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependency.getClass().equals(field.getType())) { } }</code> </pre> <br>  Selanjutnya, ketika kami menemukan kecanduan, kami harus menyuntikkannya.  Hal pertama yang Anda mungkin pikirkan adalah menulis <code>promotionsService</code> menggunakan refleksi secara langsung.  Tetapi musim semi tidak bekerja seperti itu.  Lagi pula, jika bidang tersebut memiliki pengubah <code>private</code> , maka pertama-tama kita harus mengaturnya sebagai <code>public</code> , kemudian menulis nilai kami, kemudian mengaturnya ke <code>private</code> lagi (untuk menjaga integritas).  Kedengarannya seperti tongkat penyangga besar.  Alih-alih kruk besar, mari kita membuat kruk kecil (kami akan membentuk nama setter dan menyebutnya): <br><br><pre> <code class="java hljs">String setterName = <span class="hljs-string"><span class="hljs-string">"set"</span></span> + field.getName().substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + field.getName().substring(<span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">//setPromotionsService System.out.println("Setter name = " + setterName); Method setter = object.getClass().getMethod(setterName, dependency.getClass()); setter.invoke(object, dependency);</span></span></code> </pre> <br>  Sekarang jalankan proyek Anda dan pastikan bahwa saat memanggil <code>productService.getPromotionsService()</code> alih-alih <code>null</code> , kacang kami dikembalikan. <br><br>  Apa yang kami terapkan adalah injeksi menurut jenis.  Ada juga suntikan dengan nama ( <code>javax.annotation.Resource</code> ).  Ini berbeda karena bukan tipe bidang, namanya akan diekstraksi, dan menurutnya - ketergantungan dari peta.  Semuanya serupa di sini, bahkan dalam sesuatu yang lebih sederhana.  Saya merekomendasikan Anda untuk bereksperimen dan membuat kacang Anda sendiri, lalu menyuntikkannya dengan <code>@Resource</code> dan memperpanjang metode <code>populateProperties()</code> . <br><br><h2>  Kami mendukung kacang yang tahu tentang nama mereka </h2><br><img src="https://habrastorage.org/webt/ds/ge/nn/dsgennl2rvz-spa6h51l_yox81o.png"><br><br>  Ada kalanya Anda perlu memasukkan namanya ke tempat sampah.  Kebutuhan seperti itu tidak sering muncul, karena  sampah, pada dasarnya, tidak boleh saling mengenal dan bahwa mereka adalah sampah.  Dalam versi pertama musim semi, diasumsikan bahwa bean adalah POJO (Plain Old Java Objec, objek Java lama yang baik), dan seluruh konfigurasi diberikan dalam file XML dan dipisahkan dari implementasinya.  Tapi kami menerapkan fungsi ini, karena injeksi nama adalah bagian dari siklus hidup bin. <br><br>  Bagaimana kita tahu kacang mana yang ingin tahu siapa namanya dan apa yang tidak dia inginkan?  Hal pertama yang terlintas dalam pikiran adalah membuat anotasi baru dari tipe <code>@InjectName</code> dan memahatnya menjadi bidang tipe String.  Tetapi solusi ini akan terlalu umum dan memungkinkan Anda menembak diri sendiri berkali-kali (letakkan anotasi ini pada bidang yang jenisnya tidak sesuai (bukan String), atau coba menyuntikkan nama ke beberapa bidang dalam kelas yang sama).  Ada solusi lain, lebih akurat - untuk membuat antarmuka khusus dengan satu metode setter.  Semua tempat sampah yang menerapkannya mendapatkan namanya.  Buat kelas <code>BeanNameAware</code> di paket <code>org.springframework.beans.factory</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span></span>; }</code> </pre> <br>  Selanjutnya, biarkan Layanan <code>PromotionsService</code> kami menerapkannya: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String beanName; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ beanName = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beanName; } }</code> </pre> <br>  Dan akhirnya, tambahkan metode baru ke pabrik kacang.  Semuanya sederhana di sini - kita melihat bin-singleton kita, memeriksa apakah bin mengimplementasikan antarmuka kita, dan memanggil setter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectBeanNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BeanNameAware){ ((BeanNameAware) bean).setBeanName(name); } } }</code> </pre> <br>  Jalankan dan pastikan semuanya berfungsi: <br><br><pre> <code class="java hljs">BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); beanFactory.instantiate(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); beanFactory.populateProperties(); beanFactory.injectBeanNames(); <span class="hljs-comment"><span class="hljs-comment">//... System.out.println("Bean name = " + promotionsService.getBeanName());</span></span></code> </pre><br>  Perlu dicatat bahwa pada musim semi ada antarmuka serupa lainnya.  Saya sarankan Anda menerapkan antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BeanFactoryAware sendiri</a> , yang memungkinkan kacang menerima tautan ke pabrik kacang.  Ini diimplementasikan dengan cara yang serupa. <br><br><h2>  Inisialisasi Kacang </h2><br><img src="https://habrastorage.org/webt/yq/0w/5t/yq0w5t8x0kqrgqwllfuxsi77xug.png"><br><br>  Bayangkan Anda memiliki situasi di mana Anda perlu menjalankan beberapa kode setelah dependensi telah disuntikkan (properti bin diatur).  Secara sederhana, kita perlu memberi bin kemampuan untuk menginisialisasi sendiri.  Atau, kita bisa membuat antarmuka <code>InitializingBean</code> , dan memasukkan tanda tangan metode <code>void afterPropertiesSet()</code> di dalamnya.  Implementasi mekanisme ini persis sama dengan yang disajikan untuk antarmuka <code>BeanNameAware</code> , sehingga solusinya ada di bawah spoiler.  Berlatih dan lakukan sendiri dalam satu menit: <br><br><div class="spoiler">  <b class="spoiler_title">Solusi Inisialisasi Bean</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//InitializingBean.java package org.springframework.beans.factory; public interface InitializingBean { void afterPropertiesSet(); } //BeanFactory.java public void initializeBeans(){ for (Object bean : singletons.values()) { if(bean instanceof InitializingBean){ ((InitializingBean) bean).afterPropertiesSet(); } } } //Main.java beanFactory.initializeBeans();</span></span></code> </pre> <br></div></div><br><br><h2>  Menambahkan Prosesor Posting </h2><br>  Bayangkan diri Anda di tempat pengembang musim semi pertama.  Kerangka kerja Anda berkembang dan sangat populer di kalangan pengembang, surat dikirim ke surat setiap hari dengan permintaan untuk menambahkan satu atau fitur bermanfaat lainnya.  Jika untuk setiap fitur tersebut Anda menambahkan antarmuka Anda sendiri dan memeriksanya dalam siklus hidup bean, maka itu (siklus hidup) akan menjadi tersumbat dengan informasi yang tidak perlu.  Sebagai gantinya, kami dapat membuat satu antarmuka universal yang memungkinkan Anda untuk menambahkan beberapa logika (benar-benar ada, apakah itu memeriksa anotasi, mengganti nampan dengan nampan lain, mengatur beberapa properti khusus, dan sebagainya). <br><br>  Mari kita pikirkan untuk apa antarmuka ini.  Perlu melakukan beberapa pemrosesan pasca kacang, maka itu dapat disebut BeanPostProcessor.  Tetapi kita dihadapkan dengan pertanyaan yang sulit - kapan logika harus diikuti?  Bagaimanapun, kita dapat menjalankannya sebelum inisialisasi, tetapi kita dapat mengeksekusinya setelah itu.  Untuk beberapa tugas, opsi pertama lebih baik, untuk yang lain - yang kedua ... Bagaimana menjadi? <br><br>  Kami dapat mengaktifkan kedua opsi sekaligus.  Biarkan satu post-prosesor membawa dua logika, dua metode.  Satu dieksekusi sebelum inisialisasi (sebelum metode <code>afterPropertiesSet()</code> ), dan yang lainnya setelah.  Sekarang mari kita berpikir tentang metode itu sendiri - parameter apa yang harus mereka miliki?  Jelas, <code>Object bean</code> itu sendiri ( <code>Object bean</code> ) harus ada di sana.  Untuk kenyamanan, selain kacang, Anda bisa memberikan nama kacang ini.  Anda ingat bahwa nampan itu sendiri tidak tahu tentang namanya.  Dan kami tidak ingin memaksa semua kacang untuk mengimplementasikan antarmuka BeanNameAware.  Tetapi, pada tingkat pasca-prosesor, nama kacang bisa sangat berguna.  Karena itu, kami menambahkannya sebagai parameter kedua. <br><br>  Dan apa yang harus metode kembali ketika memposting pengolahan kacang?  Mari kita membuatnya mengembalikan nampan itu sendiri.  Ini memberi kami fleksibilitas super, karena alih-alih tempat sampah, Anda dapat memasukkan objek proxy yang membungkus panggilannya (dan menambah keamanan).  Atau Anda dapat sepenuhnya mengembalikan objek lain dengan membuat ulang tempat sampah lagi.  Pengembang diberi kebebasan bertindak yang sangat besar.  Di bawah ini adalah versi final dari antarmuka yang dirancang: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.beans.factory.config; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; }</code> </pre> <br>  Selanjutnya, kita perlu menambahkan daftar prosesor sederhana ke pabrik kacang kita dan kemampuan untuk menambahkan yang baru.  Ya, ini adalah ArrayList biasa. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java private List&lt;BeanPostProcessor&gt; postProcessors = new ArrayList&lt;&gt;(); public void addPostProcessor(BeanPostProcessor postProcessor){ postProcessors.add(postProcessor); }</span></span></code> </pre> <br>  Sekarang ubah metode <code>initializeBeans</code> sehingga memperhitungkan post-prosesor akun: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeBeans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeforeInitialization(bean, name); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> InitializingBean) { ((InitializingBean) bean).afterPropertiesSet(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessAfterInitialization(bean, name); } } }</code> </pre> <br>  Mari kita buat prosesor pos kecil yang hanya melacak panggilan ke konsol dan menambahkannya ke pabrik kacang kami: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor Before "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor After "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.addPostProcessor(new CustomPostProcessor());</span></span></code> </pre> <br><br>  Sekarang jalankan dan pastikan semuanya berfungsi.  Sebagai tugas pelatihan, buat prosesor pos yang akan memberikan anotasi <code>@PostConstruct (javax.annotation.PostConstruct)</code> .  Ini memberikan cara alternatif untuk menginisialisasi (berakar di Jawa, bukan di musim semi).  Esensinya adalah bahwa Anda menempatkan anotasi pada beberapa metode, dan metode ini akan disebut SEBELUM inisialisasi pegas standar (InitializingBean). <br><br>  Pastikan untuk membuat semua anotasi dan paket (bahkan javax.annotation) secara manual, jangan hubungkan dependensi!  Ini akan membantu Anda untuk melihat perbedaan antara inti pegas dan ekstensi (dukungan javax), dan mengingatnya.  Ini akan mempertahankan satu gaya di masa depan. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda akan tertarik pada fakta bahwa pada musim semi nyata anotasi </font></font><code>@PostConstruct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diimplementasikan dengan cara ini, melalui post-processor CommonAnnotationBeanPostProcessor. </font><font style="vertical-align: inherit;">Tapi jangan mengintip ke sana, tulis implementasi Anda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terakhir, saya sarankan Anda menambahkan metode </font></font><code>void close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke kelas </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan bekerja dua mekanisme lagi. </font><font style="vertical-align: inherit;">Yang pertama adalah penjelasan </font></font><code>@PreDestroy (javax.annotation.PreDestroy)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dimaksudkan untuk metode yang harus dipanggil ketika wadah ditutup. </font><font style="vertical-align: inherit;">Yang kedua adalah antarmuka </font></font><code>org.springframework.beans.factory.DisposableBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang berisi metode </font></font><code>void destroy()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Semua nampan yang menjalankan antarmuka ini akan memiliki kemampuan untuk menghancurkan diri mereka sendiri (membebaskan sumber daya, misalnya).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@PreDestroy + DisposableBean</font></font></b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//DisposableBean.java package org.springframework.beans.factory; public interface DisposableBean { void destroy(); } //PreDestroy.java package javax.annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) public @interface PreDestroy { } //DisposableBean.java public void close() { for (Object bean : singletons.values()) { for (Method method : bean.getClass().getMethods()) { if (method.isAnnotationPresent(PreDestroy.class)) { try { method.invoke(bean); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } if (bean instanceof DisposableBean) { ((DisposableBean) bean).destroy(); } } }</span></span></code> </pre> <br></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Siklus Hidup Kacang Penuh </font></font></h2><img src="https://habrastorage.org/webt/ns/uh/lk/nsuhlk9ko9d9gxtzmcytopfruim.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kami telah menerapkan siklus hidup penuh tempat sampah, dalam bentuk modernnya. </font><font style="vertical-align: inherit;">Saya harap pendekatan ini membantu Anda mengingatnya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konteks favorit kami </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrogram sangat sering menggunakan istilah konteks, tetapi tidak semua orang mengerti apa artinya sebenarnya. </font><font style="vertical-align: inherit;">Sekarang kita akan mengatur semuanya. </font><font style="vertical-align: inherit;">Seperti yang saya catat di awal artikel, konteks adalah implementasi dari wadah, juga </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tapi, selain fungsi dasar (DI), masih menambah beberapa fitur keren. </font><font style="vertical-align: inherit;">Salah satu fitur ini adalah mengirim dan memproses acara antar nampan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel itu ternyata terlalu besar dan isinya mulai terpotong, jadi saya menaruh informasi konteks di bawah spoiler.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyadari konteksnya</font></font></b> <div class="spoiler_text">    .   <code>org.springframework.context</code> ,   <code>ApplicationContext</code>  .        <code>BeanFactory</code> .      ,      <code>close()</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String basePackage)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException</span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"******Context is under construction******"</span></span>); beanFactory.instantiate(basePackage); beanFactory.populateProperties(); beanFactory.injectBeanNames(); beanFactory.initializeBeans(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); } }</code> </pre> <br><br>     <code>Main</code> ,   ,   : <br><br><pre> <code class="java hljs">ApplicationContext applicationContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationContext(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); applicationContext.close();</code> </pre> <br>   ,   .       <code>close()</code> ,     ¬´ ¬ª     - .   ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context.event; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>      <code>ApplicationListener</code> ,      .        ,          ( <code>ApplicationListener&lt;E&gt;</code> ). ,    Java-,         . ,      ,    : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E event)</span></span></span></span>; }</code> </pre> <br>     <code>ApplicationContext</code> .     <code>close()</code>     ,  ,      .    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     <code>onApplicationEvent(ContextClosedEvent)</code> .    ,   ? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Object bean : beanFactory.getSingletons().values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ApplicationListener) { } } }</code> </pre> <br>  Tapi tidak.   .       <code>bean instanceof ApplicationListener&lt;ContextClosedEvent&gt;</code> .      Java.      <i>  (type erasure)</i> ,    &lt;T&gt;   &lt;Object&gt;.   ,   ?    ,    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     ? <br><br>   ,       ,       .  ,      ,    ,     ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Type type: bean.getClass().getGenericInterfaces()){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ParameterizedType){ ParameterizedType parameterizedType = (ParameterizedType) type; } }</code> </pre> <br> ,       ,  ,   ‚Äî   .   ,         : <br><br><pre> <code class="java hljs">Type firstParameter = parameterizedType.getActualTypeArguments()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstParameter.equals(ContextClosedEvent.class)){ Method method = bean.getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"onApplicationEvent"</span></span>, ContextClosedEvent.class); method.invoke(bean, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContextClosedEvent()); }</code> </pre> <br>        ApplicationListener: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @Override public void onApplicationEvent(ContextClosedEvent event) { System.out.println("&gt;&gt; ContextClosed EVENT"); } }</span></span></code> </pre> <br> ,     Main  ,    ,   : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java void testContext() throws ReflectiveOperationException{ ApplicationContext applicationContext = new ApplicationContext("com.kciray"); applicationContext.close(); }</span></span></code> </pre> <br></div></div><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, saya merencanakan artikel ini untuk Baeldung dalam bahasa Inggris, tetapi kemudian saya berpikir bahwa audiens Habr√© dapat secara positif mengevaluasi pendekatan pelatihan ini. </font><font style="vertical-align: inherit;">Jika Anda menyukai ide saya, pastikan untuk mendukung artikel tersebut. </font><font style="vertical-align: inherit;">Jika dia mendapat peringkat lebih dari 30, maka saya berjanji untuk melanjutkan. </font><font style="vertical-align: inherit;">Saat menulis artikel, saya mencoba untuk menunjukkan pengetahuan Spring Core, yang paling sering digunakan, dan juga berdasarkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panduan Studi Sertifikasi Core Spring 5.0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Di masa depan, dengan bantuan tutorial seperti itu, Anda dapat mencakup seluruh sertifikasi dan membuat pegas lebih mudah diakses oleh pengembang Java.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perbarui 05/10/2018 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surat terus-menerus datang kepada saya dengan pertanyaan "dan ketika kelanjutan, kami sedang menunggunya." </font><font style="vertical-align: inherit;">Tetapi tidak ada waktu sama sekali, dan proyek pribadi lainnya adalah prioritas. </font><font style="vertical-align: inherit;">Namun, jika salah satu dari Anda benar-benar menyukai gagasan itu, Anda dapat mempelajari bagian sempit musim semi dan menulis artikel lanjutan. </font><font style="vertical-align: inherit;">Jika Anda tidak memiliki akun habr, maka saya dapat menerbitkan artikel dari akun saya atau membantu Anda mendapatkan undangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distribusi topik: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wadah Musim Semi - [nama pengguna] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Musim Semi AOP - [nama pengguna] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Musim Semi - [nama pengguna] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Cloud - [nama pengguna]</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419679/">https://habr.com/ru/post/id419679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419669/index.html">Sepuluh mouse gaming terbaik untuk dompet apa pun</a></li>
<li><a href="../id419671/index.html">Keterbatasan itu perlu dilanggar atau bagaimana kami mempercepat tes fungsional tiga kali</a></li>
<li><a href="../id419673/index.html">Alam semesta awal 6. Dinamika alam semesta yang mengembang secara homogen, bagian 2</a></li>
<li><a href="../id419675/index.html">Ulasan sewa per menit skuter listrik di Moskow, musim panas 2018</a></li>
<li><a href="../id419677/index.html">Cara mengendus lalu lintas HTTPS dari perangkat iOS</a></li>
<li><a href="../id419683/index.html">Apa arti metrik untuk tim tangkas?</a></li>
<li><a href="../id419685/index.html">Struktur Data Yang Paling Penting Yang Harus Anda Ketahui Tentang Wawancara Pemrograman Anda</a></li>
<li><a href="../id419687/index.html">Keyboard Rahasia Level 3 atau cara mencetak tanda hubung panjang</a></li>
<li><a href="../id419689/index.html">I. Disadaptation. II ADHD atau orang bodoh yang malas?</a></li>
<li><a href="../id419693/index.html">Mikrotik: reset, backup dan DualBoot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>