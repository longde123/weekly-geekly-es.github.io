<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèæ üòø üìâ C ++: une session d'arch√©ologie spontan√©e et pourquoi vous ne devriez pas utiliser des fonctions variables dans le style de C üìÜ üêÆ ‚ÜóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout a commenc√©, comme d'habitude, avec une erreur. C'est la premi√®re fois que je travaille avec Java Native Interface et dans la partie C ++, j'ai en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++: une session d'arch√©ologie spontan√©e et pourquoi vous ne devriez pas utiliser des fonctions variables dans le style de C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430064/"> Tout a commenc√©, comme d'habitude, avec une erreur.  C'est la premi√®re fois que je travaille avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Native Interface</a> et dans la partie C ++, j'ai encapsul√© une fonction qui cr√©e un objet Java.  Cette fonction - <code>CallVoidMethod</code> - est variable, c'est-√†-dire  en plus d'un pointeur sur l'environnement <abbr title="Interface native Java">JNI</abbr> , un pointeur sur le type d'objet √† cr√©er et un identifiant pour la m√©thode appel√©e (dans ce cas, le constructeur), il prend un nombre arbitraire d'autres arguments.  Ce qui est logique, car  ces autres arguments sont pass√©s √† la m√©thode appel√©e du c√¥t√© Java, et les m√©thodes peuvent √™tre diff√©rentes, avec un nombre diff√©rent d'arguments de n'importe quel type. <br><br>  En cons√©quence, j'ai √©galement cr√©√© ma variable wrapper.  Pour passer un nombre arbitraire d'arguments √† <code>CallVoidMethod</code> utilis√© <code>va_list</code> , car c'est diff√©rent dans ce cas.  Oui, c'est ce que <code>va_list</code> envoy√© √† <code>CallVoidMethod</code> .  Et abandonn√© la faille de segmentation banale de la JVM. <br><br>  En 2 heures, j'ai r√©ussi √† essayer plusieurs versions de la JVM, du 8 au 11, car: premi√®rement, c'est ma premi√®re exp√©rience avec la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Machine virtuelle Java">JVM</a> , et dans ce domaine j'ai fait plus confiance √† StackOverflow qu'√† moi, et deuxi√®mement, quelqu'un puis sur StackOverflow j'ai conseill√© dans ce cas d'utiliser non OpenJDK, mais OracleJDK, et non 8, mais 10. Et seulement alors j'ai finalement remarqu√© qu'en plus de la variable <code>CallVoidMethod</code> il y a <code>CallVoidMethodV</code> , qui prend un nombre arbitraire d'arguments via <code>va_list</code> . <br><br>  Ce que je n'ai pas aim√© le plus dans cette histoire, c'est que je n'ai pas imm√©diatement remarqu√© la diff√©rence entre les points de suspension (ellipses) et <code>va_list</code> .  Et apr√®s avoir remarqu√©, je ne pouvais pas m'expliquer quelle √©tait la diff√©rence fondamentale.  Donc, nous devons traiter les points de suspension, et <code>va_list</code> , et (puisque nous parlons toujours de C ++) avec des mod√®les de variables. <br><a name="habracut"></a><br><h3>  Qu'en est-il des points de suspension et de la va_list dans la norme </h3><br>  La norme C ++ d√©crit uniquement les diff√©rences entre ses exigences et celles de la norme C. Les diff√©rences elles-m√™mes seront discut√©es plus tard, mais pour l'instant j'expliquerai bri√®vement ce que dit la norme C (en commen√ßant par C89). <br><br><ul><li>  Vous pouvez d√©clarer une fonction qui prend un nombre arbitraire d'arguments.  C'est-√†-dire  une fonction peut avoir plus d'arguments que de param√®tres.  Pour ce faire, la liste de ses param√®tres doit se terminer par des points de suspension, mais au moins un param√®tre fixe <i>[C11 6.9.1 / 8]</i> doit √©galement √™tre pr√©sent: <br><br><pre> <code class="plaintext hljs">void foo(int parm1, int parm2, ...);</code> </pre> </li><li>  Les informations sur le nombre et les types d'arguments correspondant aux points de suspension ne sont pas transmises √† la fonction elle-m√™me.  C'est-√†-dire  apr√®s le dernier param√®tre nomm√© ( <code>parm2</code> dans l'exemple ci-dessus) <i>[C11 6.7.6.3/9]</i> . <br></li><li>  Pour acc√©der √† ces arguments, vous devez utiliser le type <code>va_list</code> d√©clar√© dans l'en-t√™te <code>&lt;stdarg.h&gt;</code> et 4 macros (3 avant la norme C11): <code>va_start</code> , <code>va_arg</code> , <code>va_end</code> et <code>va_copy</code> (commen√ßant par C11) <i>[C11 7.16]</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Par exemple</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int add(int count, ...) { int result = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; ++i) { result += va_arg(args, int); } va_end(args); return result; }</code> </pre> <br>  Oui, la fonction ne sait pas combien d'arguments elle poss√®de.  Elle doit en quelque sorte transmettre ce num√©ro.  Dans ce cas, via un seul argument nomm√© (une autre option courante consiste √† passer <code>NULL</code> comme dernier argument, comme dans <code>execl</code> ou 0). </div></div></li><li>  Le dernier argument nomm√© ne peut pas avoir de classe de stockage de <code>register</code> ; il ne peut pas √™tre une fonction ou un tableau.  Sinon, comportement ind√©fini <i>[C11 7.16.1.4/4]</i> . </li><li>  De plus, au dernier argument nomm√© et √† tous ceux sans nom, la ¬´ <i>promotion d'argument par d√©faut</i> ¬ª est appliqu√©e ( <i>promotion d'argument par d√©faut</i> ; s'il y a une bonne traduction de ce concept en russe, je l'utilise volontiers).  Cela signifie que si l'argument a le type <code>char</code> , <code>short</code> (avec ou sans signe) ou <code>float</code> , alors les param√®tres correspondants doivent √™tre accessibles comme <code>int</code> , <code>int</code> (avec ou sans signe) ou <code>double</code> .  Sinon, comportement ind√©fini <i>[C11 7.16.1.1/2]</i> . </li><li>  Concernant le type <code>va_list</code> on dit seulement qu'il est d√©clar√© dans <code>&lt;stdarg.h&gt;</code> et qu'il est complet (c'est-√†-dire que la taille d'un objet de ce type est connue) <i>[C11 7.16 / 3]</i> . </li></ul><br><h3>  Pourquoi?  Mais parce que! </h3><br>  Il n'y a pas beaucoup de types en C.  Pourquoi <code>va_list</code> est- <code>va_list</code> d√©clar√© dans la norme, mais rien n'est dit sur sa structure interne? <br><br>  Pourquoi avons-nous besoin d'une ellipse si un nombre arbitraire d'arguments √† une fonction peut √™tre pass√© via <code>va_list</code> ?  On pourrait dire maintenant: "comme sucre syntaxique", mais il y a 40 ans, j'en suis s√ªr, il n'y avait pas de temps pour le sucre. <br><br>  Philip James Plauger <i>Phillip James Plauger</i> dans le livre <i>The Standard C library</i> - 1992 - dit qu'initialement C a √©t√© cr√©√© exclusivement pour les ordinateurs PDP-11.  Et l√†, il √©tait possible de trier tous les arguments de la fonction en utilisant une arithm√©tique de pointeur simple.  Le probl√®me est apparu avec la popularit√© de C et le transfert du compilateur vers d'autres architectures.  La premi√®re √©dition du <i>langage de programmation C de</i> <i>Brian Kernighan</i> et Dennis Ritchie - 1978 - d√©clare explicitement: <blockquote>  Soit dit en passant, il n'existe aucun moyen acceptable d'√©crire une fonction portable d'un nombre arbitraire d'arguments, car  Il n'existe aucun moyen portable pour la fonction appel√©e de savoir combien d'arguments lui ont √©t√© transmis lors de son appel.  ... <code>printf</code> , la fonction en langage C la plus typique d'un nombre arbitraire d'arguments, ... n'est pas portable et doit √™tre impl√©ment√©e pour chaque syst√®me. </blockquote>  Ce livre d√©crit <code>printf</code> , mais n'a pas encore <code>vprintf</code> , et ne mentionne pas le type et les macros <code>va_*</code> .  Ils apparaissent dans la deuxi√®me √©dition du langage de programmation C (1988), et c'est le m√©rite du comit√© pour le d√©veloppement de la premi√®re norme C (C89, alias ANSI C).  Le comit√© a ajout√© le titre <code>&lt;stdarg.h&gt;</code> √† la norme, en prenant comme base <code>&lt;varargs.h&gt;</code> , cr√©√© par Andrew Koenig dans le but d'augmenter la portabilit√© du syst√®me d'exploitation UNIX.  <code>va_*</code> √©t√© d√©cid√© de laisser les macros <code>va_*</code> tant que macros afin qu'il soit plus facile pour les compilateurs existants de prendre en charge la nouvelle norme. <br><br>  Maintenant, avec l'av√®nement de C89 et de la famille <code>va_*</code> , il est devenu possible de cr√©er des fonctions variables portables.  Et bien que la structure interne de cette famille ne soit encore d√©crite d'aucune fa√ßon, et qu'il n'y ait aucune exigence √† cet √©gard, il est d√©j√† clair pourquoi. <br><br>  Par pure curiosit√©, vous pouvez trouver des exemples de mise en ≈ìuvre de <code>&lt;stdarg.h&gt;</code> .  Par exemple, la m√™me ¬´biblioth√®que standard C¬ª fournit un exemple pour <b>Borland Turbo C ++</b> : <br><br><div class="spoiler">  <b class="spoiler_title">&lt;stdarg.h&gt; de Borland Turbo C ++</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#ifndef _STADARG #define _STADARG #define _AUPBND 1 #define _ADNBND 1 typedef char* va_list #define va_arg(ap, T) \ (*(T*)(((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND))) #define va_end(ap) \ (void)0 #define va_start(ap, A) \ (void)((ap) = (char*)&amp;(A) + _Bnd(A, _AUPBND)) #define _Bnd(X, bnd) \ (sizeof(X) + (bnd) &amp; ~(bnd)) #endif</code> </pre> <br></div></div><br>  L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ABI SystemV</a> beaucoup plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©cent pour AMD64</a> utilise ce type pour <code>va_list</code> : <br><br><div class="spoiler">  <b class="spoiler_title">va_list de SystemV ABI AMD64</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">typedef struct { unsigned int gp_offset; unsigned int fp_offset; void *overflow_arg_area; void *reg_save_area; } va_list[1];</code> </pre> <br></div></div><br>  En g√©n√©ral, nous pouvons dire que le type et les macros <code>va_*</code> fournissent une interface standard pour parcourir les arguments d'une fonction variable, et leur impl√©mentation pour des raisons historiques d√©pend du compilateur, des plates-formes cibles et de l'architecture.  De plus, une ellipse (c'est-√†-dire les fonctions variables en g√©n√©ral) est apparue en C plus t√¥t que <code>va_list</code> (c'est-√†-dire l'en-t√™te <code>&lt;stdarg.h&gt;</code> ).  Et <code>va_list</code> n'a pas √©t√© cr√©√© pour remplacer les points de suspension, mais pour permettre aux d√©veloppeurs d'√©crire leurs fonctions variables portables. <br><br>  C ++ maintient largement la compatibilit√© descendante avec C, donc tout ce qui pr√©c√®de s'applique √† lui.  Mais il y a aussi des fonctionnalit√©s. <br><br><h3>  Fonctions variables en C ++ </h3><br>  Le groupe de travail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WG21</a> a √©t√© impliqu√© dans le d√©veloppement de la norme C ++.  En 1989, la nouvelle norme C89 a √©t√© prise comme base, qui a progressivement chang√© pour d√©crire le C ++ lui-m√™me.  En 1995, la proposition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">N0695 a √©t√© re√ßue</a> de <i>John Micco</i> , dans laquelle l'auteur a sugg√©r√© de changer les restrictions pour les macros <code>va_*</code> : <br><br><ul><li>  Parce que  C ++, contrairement √† C, vous permet d'obtenir l'adresse de <code>register</code> des variables, puis le dernier argument nomm√© d'une fonction variable peut avoir cette classe de stockage. <br></li><li>  Parce que  les liens apparus en C ++ violent la r√®gle non √©crite des fonctions variables C - la taille du param√®tre doit correspondre √† la taille de son type d√©clar√© - alors le dernier argument nomm√© ne peut pas √™tre un lien.  Sinon, comportement vague. <br></li><li>  Parce que  en C ++ il n'y a pas de concept de " <i>rehaussement du type de l'argument par d√©faut</i> ", alors la phrase <br><blockquote>  Si le param√®tre <code>parmN</code> est d√©clar√© avec ... un type qui n'est pas compatible avec le type qui en r√©sulte apr√®s application des promotions d'argument par d√©faut, le comportement n'est pas d√©fini </blockquote>  doit √™tre remplac√© par <blockquote>  Si le param√®tre <code>parmN</code> est d√©clar√© avec ... un type qui n'est pas compatible avec le type qui en r√©sulte lors du passage d'un argument pour lequel il n'y a pas de param√®tre, le comportement n'est pas d√©fini </blockquote></li></ul>  Je n'ai m√™me pas traduit le dernier point afin de partager ma douleur.  Premi√®rement, l' <i>escalade du type d'argument par d√©faut</i> dans C ++ Standard reste <i>[C ++ 17 8.2.2 / 9]</i> .  Et deuxi√®mement, je me suis longtemps interrog√© sur le sens de cette phrase, par rapport √† la norme C, o√π tout est clair.  Ce n'est qu'apr√®s avoir lu N0695 que j'ai finalement compris: je veux dire la m√™me chose. <br><br>  Cependant, les 3 modifications ont √©t√© adopt√©es <i>[C ++ 98 18.7 / 3]</i> .  De retour en C ++, l'exigence d'une fonction variable d'avoir au moins un param√®tre nomm√© (dans ce cas, vous ne pouvez pas acc√©der aux autres, mais plus sur cela plus tard) a disparu, et la liste des types valides d'arguments sans nom a √©t√© compl√©t√©e par des pointeurs vers les membres de la classe et les types <abbr title="Donn√©es anciennes simples">POD</abbr> . <br><br>  La norme C ++ 03 n'a apport√© aucun changement aux fonctions variationnelles.  C ++ 11 a commenc√© √† convertir un argument sans nom de type <code>std::nullptr_t</code> en <code>void*</code> et a permis aux compilateurs, √† leur discr√©tion, de prendre en charge des types avec des constructeurs et des destructeurs non triviaux <i>[C ++ 11 5.2.2 / 7]</i> .  C ++ 14 autorisait l'utilisation de fonctions et de tableaux comme dernier param√®tre nomm√© <i>[C ++ 14 18.10 / 3]</i> , et C ++ 17 interdisait l'utilisation de <i>packs d'extension</i> et de variables captur√©s par le lambda <i>[C ++ 17 21.10.1 / 1]</i> . <br><br>  En cons√©quence, C ++ a ajout√© des fonctions vari√©es √† ses pi√®ges.  Seul le support de type non sp√©cifi√© avec des constructeurs / destructeurs non triviaux en vaut la peine.  Ci-dessous, je vais essayer de r√©duire toutes les fonctionnalit√©s non √©videntes des fonctions variables en une seule liste et de la compl√©ter avec des exemples sp√©cifiques. <br><br><h3>  Comment utiliser les fonctions variables facilement et incorrectement </h3><br><ol><li>  Il est incorrect de d√©clarer le dernier argument nomm√© avec un type promu, c'est-√†-dire  <code>char</code> , caract√®re <code>signed char</code> , caract√®re <code>unsigned char</code> , <code>singed short</code> <code>unsigned short</code> ou <code>float</code> .  Le r√©sultat selon la norme sera un comportement ind√©fini. <br><br><div class="spoiler">  <b class="spoiler_title">Code invalide</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(float n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> <br></div></div><br>  De tous les compilateurs que j'avais sous la main (gcc, clang, MSVC), seul <b>clang a</b> √©mis un avertissement. <br><br><div class="spoiler">  <b class="spoiler_title">Avertissement Clang</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object that undergoes default argument promotion to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  Et bien que dans tous les cas le code compil√© se soit comport√© correctement, vous ne devez pas compter dessus. <br><br><div class="spoiler">  <b class="spoiler_title">Ce sera juste</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(double n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Il est incorrect de d√©clarer le dernier argument nomm√© comme r√©f√©rence.  Tout lien.  La norme dans ce cas promet √©galement un comportement ind√©fini. <br><br><div class="spoiler">  <b class="spoiler_title">Code invalide</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int&amp; n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br>  <b>gcc 7.3.0 a</b> compil√© ce code sans un seul commentaire.  <b>lang 6.0.0 a</b> √©mis un avertissement, mais l'a quand m√™me compil√©. <br><br><div class="spoiler">  <b class="spoiler_title">Avertissement Clang</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object of reference type to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  Dans les deux cas, le programme a fonctionn√© correctement (heureusement, vous ne pouvez pas vous y fier).  Mais <b>MSVC 19.15.26730</b> s'est distingu√© - il a refus√© de compiler le code, car  <code>va_start</code> argument <code>va_start</code> ne <code>va_start</code> pas √™tre une r√©f√©rence. <br><br><div class="spoiler">  <b class="spoiler_title">Erreur de MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vadefs.h(151): error C2338: va_start argument must not have reference type and must not be parenthesized</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Eh bien, l'option correcte ressemble, par exemple, √† ceci</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int* n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Il est faux de demander √† <code>va_arg</code> augmenter le type - <code>char</code> , <code>short</code> ou <code>float</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Code invalide</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); } int main() { foo(0, 1, 2.0f, 3); return 0; }</code> </pre> </div></div><br>  C'est plus int√©ressant ici.  <b>gcc</b> lors de la compilation donne un avertissement qu'il est n√©cessaire d'utiliser <code>double</code> au lieu de <code>float</code> , et si ce code est toujours ex√©cut√©, le programme se terminera avec une erreur. <br><br><div class="spoiler">  <b class="spoiler_title">Avertissement GCC</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:15: warning: 'float' is promoted to 'double' when passed through '...' std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~~ ./test.cpp:9:15: note: (so you should pass 'double' not 'float' to 'va_arg') ./test.cpp:9:15: note: if this code is reached, the program will abort</code> </pre> </div></div><br>  En effet, le programme plante avec une plainte concernant une instruction invalide. <br>  Une analyse de vidage montre que le programme a re√ßu un signal SIGILL.  Et il montre √©galement la structure de <code>va_list</code> .  Pour 32 bits, c'est <br><br><pre> <code class="diff hljs">va = 0xfffc6918 ""</code> </pre> <br>  c'est-√†-dire  <code>va_list</code> est juste <code>char*</code> .  Pour 64 bits: <br><br><pre> <code class="diff hljs">va = {{gp_offset = 16, fp_offset = 48, overflow_arg_area = 0x7ffef147e7e0, reg_save_area = 0x7ffef147e720}}</code> </pre> <br>  c'est-√†-dire  exactement ce qui est d√©crit dans SystemV ABI AMD64. <br><br>  <b>clang</b> lors de la compilation met en garde contre un comportement ind√©fini et sugg√®re √©galement de remplacer <code>float</code> par <code>double</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Avertissement Clang</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:26: warning: second argument to 'va_arg' is of promotable type 'float'; this va_arg has undefined behavior because arguments will be promoted to 'double' [-Wvarargs] std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~</code> </pre> </div></div><br>  Mais le programme ne plante plus, la version 32 bits produit: <br><br><pre> <code class="diff hljs">1 0 1073741824</code> </pre> <br>  64 bits: <br><br><pre> <code class="diff hljs">1 0 3</code> </pre> <br>  <b>MSVC</b> produit exactement les m√™mes r√©sultats, uniquement sans avertissement, m√™me avec <code>/Wall</code> . <br><br>  Ici, on pourrait supposer que la diff√©rence entre 32 et 64 bits est due au fait que dans le premier cas, l'ABI transmet tous les arguments via la pile √† la fonction appel√©e, et dans le second, les quatre premiers (Windows) ou six (Linux) arguments via les registres du processeur, le reste via pile [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki</a> ].  Mais non, si vous appelez <code>foo</code> non pas avec 4 arguments, mais avec 19, et les sortez de la m√™me mani√®re, le r√©sultat sera le m√™me: un g√¢chis complet dans la version 32 bits, et des z√©ros pour tous les <code>float</code> dans le 64 bits.  C'est-√†-dire  le point est bien s√ªr dans ABI, mais pas dans l'utilisation de registres pour passer des arguments. <br><br><div class="spoiler">  <b class="spoiler_title">Eh bien, bien s√ªr, c'est juste de le faire</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, double) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Il est incorrect de passer une instance d'une classe avec un constructeur ou destructeur non trivial comme argument sans nom.  √Ä moins, bien s√ªr, que le sort de ce code ne vous excite au moins un peu plus que ¬´compiler et ex√©cuter ici et maintenant¬ª. <br><br><div class="spoiler">  <b class="spoiler_title">Code invalide</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; struct Bar { Bar() { std::cout &lt;&lt; "Bar default ctor" &lt;&lt; std::endl; } Bar(const Bar&amp;) { std::cout &lt;&lt; "Bar copy ctor" &lt;&lt; std::endl; } ~Bar() { std::cout &lt;&lt; "Bar dtor" &lt;&lt; std::endl; } }; struct Cafe { Cafe() { std::cout &lt;&lt; "Cafe default ctor" &lt;&lt; std::endl; } Cafe(const Cafe&amp;) { std::cout &lt;&lt; "Cafe copy ctor" &lt;&lt; std::endl; } ~Cafe() { std::cout &lt;&lt; "Cafe dtor" &lt;&lt; std::endl; } }; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto b = va_arg(va, Bar); va_end(va); } int main() { Bar b; Cafe c; foo(1, b, c); return 0; }</code> </pre> </div></div><br>  Clang est le plus strict de tous.  Il refuse simplement de compiler ce code car le deuxi√®me argument, <code>va_arg</code> pas un type POD, et avertit que le programme va <code>va_arg</code> au d√©marrage. <br><br><div class="spoiler">  <b class="spoiler_title">Avertissement Clang</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:23:31: error: second argument to 'va_arg' is of non-POD type 'Bar' [-Wnon-pod-varargs] const auto b = va_arg(va, Bar); ^~~ ./test.cpp:31:12: error: cannot pass object of non-trivial type 'Bar' through variadic function; call will abort at runtime [-Wnon-pod-varargs] foo(1, b, c); ^</code> </pre> </div></div><br>  Il en sera ainsi si vous compilez toujours avec l' <code>-Wno-non-pod-varargs</code> . <br><br>  <b>MSVC</b> avertit que l'utilisation de types avec des constructeurs non triviaux dans ce cas n'est pas portable. <br><br><div class="spoiler">  <b class="spoiler_title">Avertissement de MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">d:\my documents\visual studio 2017\projects\test\test\main.cpp(31): warning C4840:    "Bar"         </code> </pre> </div></div><br>  Mais le code se compile et s'ex√©cute correctement.  Les √©l√©ments suivants sont obtenus dans la console: <br><br><div class="spoiler">  <b class="spoiler_title">R√©sultat de lancement</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  C'est-√†-dire  une copie n'est cr√©√©e qu'au moment de l'appel de <code>va_arg</code> , et l'argument, il s'av√®re, est pass√© par r√©f√©rence.  Ce n'est pas √©vident, mais la norme le permet. <br><br>  <b>gcc 6.3.0</b> compile sans un seul commentaire.  La sortie est la m√™me: <br><br><div class="spoiler">  <b class="spoiler_title">R√©sultat de lancement</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  <b>gcc 7.3.0</b> ne pr√©vient √©galement de rien, mais le comportement change: <br><br><div class="spoiler">  <b class="spoiler_title">R√©sultat de lancement</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Cafe copy ctor Bar copy ctor Before va_arg Bar copy ctor Bar dtor Bar dtor Cafe dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  C'est-√†-dire  cette version du compilateur transmet les arguments par valeur, et lorsqu'elle est appel√©e, <code>va_arg</code> fait une autre copie.  Il serait amusant de rechercher cette diff√©rence lors du passage de la 6e √† la 7e version de gcc si les constructeurs / destructeurs ont des effets secondaires. <br><br>  Au fait, si vous passez explicitement et demandez une r√©f√©rence √† la classe: <br><br><div class="spoiler">  <b class="spoiler_title">Un autre mauvais code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto&amp; b = va_arg(va, Bar&amp;); va_end(va); } int main() { Bar b; Cafe c; foo(1, std::ref(b), c); return 0; }</code> </pre> </div></div><br>  alors tous les compilateurs l√®veront une erreur.  Tel que requis par la norme. <br><br>  En g√©n√©ral, si vous le voulez vraiment, il est pr√©f√©rable de passer des arguments par pointeur. <br><br><div class="spoiler">  <b class="spoiler_title">Comme √ßa</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto* b = va_arg(va, Bar*); va_end(va); } int main() { Bar b; Cafe c; foo(1, &amp;b, &amp;c); return 0; }</code> </pre> </div></div><br></li></ol><br><h3>  R√©solution de surcharge et fonctions variables </h3><br>  D'une part, tout est simple: la correspondance avec des points de suspension est pire que la correspondance avec un argument nomm√© r√©gulier, m√™me dans le cas d'une conversion de type standard ou d√©finie par l'utilisateur. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de surcharge</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } int main() { foo(1); foo(1ul); foo(); return 0; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">R√©sultat de lancement</b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function C variadic function</code> </pre> </div></div><br>  Mais cela ne fonctionne que jusqu'√† ce que l'appel √† <code>foo</code> sans arguments doive √™tre consid√©r√© s√©par√©ment. <br><br><div class="spoiler">  <b class="spoiler_title">Appelez foo sans arguments</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie du compilateur</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:16:9: error: call of overloaded 'foo()' is ambiguous foo(); ^ ./test.cpp:3:6: note: candidate: void foo(...) void foo(...) ^~~ ./test.cpp:8:6: note: candidate: void foo() void foo() ^~~</code> </pre> </div></div><br>  Tout est conforme √† la norme: il n'y a pas d'arguments - il n'y a pas de comparaison avec les points de suspension, et lorsque la surcharge est r√©solue, la fonction variative ne devient pas pire que l'habituelle. <br><br><h3>  Quand vaut-il quand m√™me la peine d'utiliser des fonctions variables </h3><br>  Eh bien, les fonctions vari√©es ne se comportent parfois pas de mani√®re tr√®s √©vidente et dans le contexte du C ++ peuvent facilement se r√©v√©ler mal portables.  Il existe de nombreux conseils sur Internet comme ¬´Ne pas cr√©er ou utiliser de fonctions C variables¬ª, mais ils ne supprimeront pas leur prise en charge de la norme C ++.  Il y a donc des avantages √† ces fonctionnalit√©s?  Et bien l√†. <br><br><ul><li>  Le cas le plus courant et le plus √©vident est la compatibilit√© descendante.  Ici, j'inclurai √† la fois l'utilisation de biblioth√®ques C tierces (mon cas avec JNI) et la fourniture de l'API C √† l'impl√©mentation C ++. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="L'√©chec de substitution n'est pas une erreur">SFINAE</a> .  Ici, il est tr√®s utile qu‚Äôen C ++ une fonction variable ne doive pas avoir d‚Äôarguments nomm√©s et que lors de la r√©solution de fonctions surcharg√©es, une fonction variable soit consid√©r√©e en dernier (s‚Äôil existe au moins un argument).  Et comme toute autre fonction, une fonction variable ne peut √™tre d√©clar√©e, mais jamais appel√©e. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static void detect(const U&amp;); static int detect(...); public: static constexpr bool value = std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value; };</code> </pre> </div></div><br>  Bien qu'en C ++ 14, vous pouvez faire un peu diff√©remment. <br><br><div class="spoiler">  <b class="spoiler_title">Un autre exemple</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static constexpr bool detect(const U*) { return true; } template &lt;class U&gt; static constexpr bool detect(...) { return false; } public: static constexpr bool value = detect&lt;T&gt;(nullptr); };</code> </pre> </div></div><br>  Et dans ce cas, il est d√©j√† n√©cessaire de regarder avec quels arguments <code>detect(...)</code> peut √™tre appel√©.  Je pr√©f√©rerais changer quelques lignes et utiliser une alternative moderne aux fonctions variables, d√©pourvue de tous leurs d√©fauts. <br></li></ul><br><h3>  Mod√®les de variantes ou comment cr√©er des fonctions √† partir d'un nombre arbitraire d'arguments en C ++ moderne </h3><br>  L'id√©e de mod√®les variables a √©t√© propos√©e par Douglas Gregor, Jaakko J√§rvi et Gary Powell en 2004, c'est-√†-dire  7 ans avant l'adoption de la norme C ++ 11, dans laquelle ces mod√®les de variables √©taient officiellement pris en charge.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La norme comprenait une troisi√®me r√©vision de leur proposition, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√®s le d√©but, des mod√®les de variables ont √©t√© cr√©√©s afin que les programmeurs aient la possibilit√© de cr√©er des fonctions de type s√©curis√© (et portables!) √Ä partir d'un nombre arbitraire d'arguments. </font><font style="vertical-align: inherit;">Un autre objectif est de simplifier la prise en charge des mod√®les de classe avec un nombre variable de param√®tres, mais maintenant nous ne parlons que des fonctions variables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les mod√®les de variables ont apport√© trois nouveaux concepts au </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ [C ++ 17 17.5.3]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ensemble de param√®tres de mod√®le ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pack de param√®tre de mod√®le</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - est un mod√®le de param√®tre, au </font><font style="vertical-align: inherit;">lieu de laquelle il est possible de transf√©rer tout (y compris 0) nombre d'argument de mod√®le;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un ensemble de param√®tres de fonction ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pack de param√®tres de fonction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - en cons√©quence, il s'agit d'un param√®tre de fonction qui prend n'importe quel nombre (y compris 0) d'arguments de fonction;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et l'expansion du package ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extension du pack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) est la seule chose qui peut √™tre faite avec le package de param√®tres.</font></font><br></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { printf(format.c_str(), args...); }</code> </pre> <br>  <code>class ... Args</code> ‚Äî   , <code>Args ... args</code> ‚Äî   ,  <code>args...</code> ‚Äî    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une liste compl√®te o√π et comment les packages de param√®tres peuvent √™tre d√©velopp√©s est donn√©e dans la norme elle-m√™me </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 17.5.3 / 4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et dans le cadre de la discussion des fonctions variables, il suffit de dire que:</font></font><br><br><ul><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le package de param√®tres de fonction peut √™tre d√©velopp√© dans la liste d'arguments d'une autre fonction</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void bar(const std::string&amp; format, Args ... args) { foo&lt;Args...&gt;(format.c_str(), args...); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou √† la liste d'initialisation</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { const auto list = {args...}; }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou √† la liste de capture lambda</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { auto lambda = [&amp;format, args...] () { printf(format.c_str(), args...); }; lambda(); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un autre ensemble de param√®tres de fonction peut √™tre d√©velopp√© dans une expression de convolution</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; int foo(Args ... args) { return (0 + ... + args); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les convolutions sont apparues en C ++ 14 et peuvent √™tre unaires et binaires, droite et gauche. </font><font style="vertical-align: inherit;">La description la plus compl√®te, comme toujours, se trouve dans la norme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 8.1.6]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les deux types de packages de param√®tres peuvent √™tre √©tendus en op√©rateur sizeof ...</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(Args ... args) { const auto size1 = sizeof...(Args); const auto size2 = sizeof...(args); }</code> </pre> </div></div><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En divulguant le paquet explicite de points de </font><font style="vertical-align: inherit;">suspension est n√©cessaire pour soutenir les diff√©rents mod√®les ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mod√®les</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et la </font><font style="vertical-align: inherit;">communication pour √©viter cette ambigu√Øt√©.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Par exemple</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo() { using OneTuple = std::tuple&lt;std::tuple&lt;Args&gt;...&gt;; using NestTuple = std::tuple&lt;std::tuple&lt;Args...&gt;&gt;; }</code> </pre> <br> <code>OneTuple</code> ‚Äî      ( <code>std:tuple&lt;std::tuple&lt;int&gt;&gt;, std::tuple&lt;double&gt;&gt;</code> ),  <code>NestTuple</code> ‚Äî ,     ‚Äî   ( <code>std::tuple&lt;std::tuple&lt;int, double&gt;&gt;</code> ). </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exemple d'impl√©mentation de printf √† l'aide de mod√®les de variables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme je l'ai d√©j√† mentionn√©, des mod√®les de variables ont √©galement √©t√© cr√©√©s en remplacement direct des fonctions variables de C. Les auteurs de ces mod√®les ont eux-m√™mes propos√© leur version tr√®s simple mais s√©curis√©e </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- l'une des premi√®res fonctions variables en C.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf sur les mod√®les</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void printf(const char* s) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') throw std::runtime_error("invalid format string: missing arguments"); std::cout &lt;&lt; *s++; } } template &lt;typename T, typename ... Args&gt; void printf(const char* s, T value, Args ... args) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') { std::cout &lt;&lt; value; return printf(++s, args...); } std::cout &lt;&lt; *s++; } throw std::runtime_error("extra arguments provided to printf"); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je soup√ßonne que ce sch√©ma d'√©num√©ration d'arguments variables est apparu - √† travers un appel r√©cursif de fonctions surcharg√©es. </font><font style="vertical-align: inherit;">Mais je pr√©f√®re toujours l'option sans r√©cursivit√©.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf sur des mod√®les et sans r√©cursivit√©</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;typename ... Args&gt; void printf(const std::string&amp; fmt, const Args&amp; ... args) { size_t fmtIndex = 0; size_t placeHolders = 0; auto printFmt = [&amp;fmt, &amp;fmtIndex, &amp;placeHolders]() { for (; fmtIndex &lt; fmt.size(); ++fmtIndex) { if (fmt[fmtIndex] != '%') std::cout &lt;&lt; fmt[fmtIndex]; else if (++fmtIndex &lt; fmt.size()) { if (fmt[fmtIndex] == '%') std::cout &lt;&lt; '%'; else { ++fmtIndex; ++placeHolders; break; } } } }; ((printFmt(), std::cout &lt;&lt; args), ..., (printFmt())); if (placeHolders &lt; sizeof...(args)) throw std::runtime_error("extra arguments provided to printf"); if (placeHolders &gt; sizeof...(args)) throw std::runtime_error("invalid format string: missing arguments"); }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©solution de surcharge et fonctions de mod√®le variables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la r√©solution, ces fonctions variables sont consid√©r√©es, apr√®s d'autres, comme √©tant standard et les moins sp√©cialis√©es. </font><font style="vertical-align: inherit;">Mais il n'y a pas de probl√®me dans le cas d'un appel sans argument.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de surcharge</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } template &lt;class T&gt; void foo(T) { std::cout &lt;&lt; "Template function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); foo(2.0); foo(1, 2); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultat de lancement</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function without arguments Template function Template variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque la surcharge est r√©solue, une fonction de mod√®le variable ne peut contourner qu'une fonction C variable (bien que pourquoi les m√©langer?). </font><font style="vertical-align: inherit;">Sauf - bien s√ªr! </font><font style="vertical-align: inherit;">- appel sans arguments.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appel sans arguments</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©sultat de lancement</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Template variadic function C variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il y a une comparaison avec des points de suspension - la fonction correspondante perd, il n'y a pas de comparaison avec des points de suspension - et la fonction mod√®le est inf√©rieure √† la fonction non mod√®le. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une note rapide sur la vitesse des fonctions de mod√®les variables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En 2008, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo√Øc Joly a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> soumis sa proposition </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2772</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au Comit√© de normalisation C ++ </font><font style="vertical-align: inherit;">, dans lequel il a montr√© dans la pratique que les fonctions de mod√®le variable fonctionnent plus lentement que les fonctions similaires, dont l'argument est la liste d'initialisation ( </font></font><code>std::initializer_list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Et bien que cela contredit les justifications th√©oriques de l'auteur lui-m√™me, Joli a propos√© de le mettre en ≈ìuvre </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√©cis√©ment √† l'aide de listes d'initialisation, et non avec des mod√®les variables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais d√©j√† en 2009, une r√©futation est apparue. </font><font style="vertical-align: inherit;">Lors des tests de Joli, une ¬´grave erreur¬ª a √©t√© d√©couverte (semble-t-il, m√™me pour lui-m√™me). </font><font style="vertical-align: inherit;">Nouveaux tests (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ont montr√© que les fonctions de mod√®le variables sont encore plus rapides, et parfois significatives. </font><font style="vertical-align: inherit;">Ce qui n'est pas surprenant puisque </font><font style="vertical-align: inherit;">la liste d'initialisation fait des copies de ses √©l√©ments, et pour les mod√®les de variables, vous pouvez compter beaucoup au stade de la compilation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√©anmoins, en C ++ 11 et les normes suivantes </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont des fonctions de mod√®le ordinaires, un nombre arbitraire d'arguments √† qui sont pass√©s √† travers la liste d'initialisation.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bref r√©sum√© et conclusion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ainsi, les fonctions variables de style C: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ils ne connaissent ni le nombre de leurs arguments ni leurs types. </font><font style="vertical-align: inherit;">Le d√©veloppeur doit utiliser une partie des arguments de la fonction afin de transmettre des informations sur le reste.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Augmentez implicitement les types d'arguments sans nom (et le dernier nomm√©). </font><font style="vertical-align: inherit;">Si vous l'oubliez, vous obtenez un comportement vague.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ils conservent une compatibilit√© descendante avec le C pur et ne prennent donc pas en charge le passage d'arguments par r√©f√©rence. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant C ++ 11, les arguments non de </font><font style="vertical-align: inherit;">type </font></font><abbr title="Donn√©es anciennes simples"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'√©taient </font><font style="vertical-align: inherit;">pas pris en charge </font><font style="vertical-align: inherit;">, et depuis C ++ 11, la prise en charge des types non triviaux √©tait laiss√©e √† la discr√©tion du compilateur.</font></font> C'est-√†-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le comportement du code d√©pend du compilateur et de sa version. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La seule utilisation autoris√©e des fonctions variables est d'interagir avec l'API C en code C ++. </font><font style="vertical-align: inherit;">Pour tout le reste, y compris </font></font><abbr title="L'√©chec de substitution n'est pas une erreur"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il existe des fonctions de mod√®le variables qui:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conna√Ætre le nombre et les types de tous leurs arguments. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tapez s√ªr, ne changez pas les types de leurs arguments. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ils prennent en charge le passage d'arguments sous n'importe quelle forme - par valeur, par pointeur, par r√©f√©rence, par lien universel. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme toute autre fonction C ++, il n'y a aucune restriction sur les types d'arguments. </font></font><br></li><li>        (   C ),   . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fonctions de mod√®le variables peuvent √™tre plus verbeuses par rapport √† leurs homologues de style C et n√©cessitent parfois m√™me leur propre version non mod√®le surcharg√©e (travers√©e d'arguments r√©cursifs). </font><font style="vertical-align: inherit;">Ils sont plus difficiles √† lire et √† √©crire. </font><font style="vertical-align: inherit;">Mais tout cela est plus que pay√© par l'absence des lacunes √©num√©r√©es et la pr√©sence des avantages √©num√©r√©s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, la conclusion est simple: les fonctions vari√©es dans le style C restent en C ++ uniquement en raison de la compatibilit√© descendante, et elles offrent un large √©ventail d'options pour tirer sur votre jambe. </font><font style="vertical-align: inherit;">En C ++ moderne, il est fortement conseill√© de ne pas en √©crire de nouvelles et, si possible, de ne pas utiliser les fonctions C variables existantes. </font><font style="vertical-align: inherit;">Les fonctions de mod√®les variables appartiennent au monde du C ++ moderne et sont beaucoup plus s√©curis√©es. </font><font style="vertical-align: inherit;">Utilisez-les.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Litt√©rature et sources </font></font></h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PJ Plauger, la biblioth√®que Standard C</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan et Dennis M. Ritchie, The C Programming Language, 1re √©dition</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan et Dennis M. Ritchie, The C Programming Language, 2e √©dition</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norme C11, projet N1570</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norme C ++ 98</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norme C ++ 03</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norme C ++ 11, projet N3337</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norme C ++ 14, projet N4296</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norme C ++ 17, projet N4659</font></font></a> <br></li></ul><br><h3>  PS </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est facile de trouver et de t√©l√©charger des versions √©lectroniques des livres mentionn√©s sur le net. </font><font style="vertical-align: inherit;">Mais je ne suis pas s√ªr que ce sera l√©gal, donc je ne donne pas de liens.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430064/">https://habr.com/ru/post/fr430064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430052/index.html">Pourquoi est-il important pour les d√©veloppeurs de mat√©riel de r√©aliser des cusdev de qualit√©</a></li>
<li><a href="../fr430054/index.html">HolyJS 2018 Moscou: diffusion en ligne gratuite, f√™te et rap scientifique et technologique</a></li>
<li><a href="../fr430058/index.html">Processus houlomoteurs dans les conduites hydrauliques. Les bases</a></li>
<li><a href="../fr430060/index.html">Hackspace, Denis Perevalov, Anastasia Krokhaleva - la magie de la programmation</a></li>
<li><a href="../fr430062/index.html">Microservices. Mod√®les de d√©veloppement et de refactoring avec des exemples Java</a></li>
<li><a href="../fr430068/index.html">Ordre de la chrysalide</a></li>
<li><a href="../fr430070/index.html">La pile et la file d'attente sont deux mauvais paradigmes et ce qui peut √™tre fait √† ce sujet</a></li>
<li><a href="../fr430072/index.html">Swift c√¥t√© serveur sous-estim√©: entretien avec Paul Hudson</a></li>
<li><a href="../fr430074/index.html">Comment j'ai failli attraper un virus en essayant de vendre des bottes</a></li>
<li><a href="../fr430076/index.html">Diffusion gratuite de DotNext 2018 Moscou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>