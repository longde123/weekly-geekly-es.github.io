<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💚 🚕 ❗️ Noch einmal über ImmutableList in Java 🍶 👉🏿 🧦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem vorherigen Artikel „ Umhüllen von ImmutableList in Java “ habe ich eine Lösung für das Problem des Fehlens unveränderlicher Listen in Java v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Noch einmal über ImmutableList in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471344/"><p>  In meinem vorherigen Artikel „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umhüllen von ImmutableList in Java</a> “ habe ich eine Lösung für das Problem des Fehlens unveränderlicher Listen in Java vorgeschlagen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weder jetzt noch jemals</a> in Java behoben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> . </p><br><p>  Die Lösung wurde dann nur auf der Ebene „Es gibt eine solche Idee“ ausgearbeitet, und die Implementierung im Code war schief, daher wurde alles etwas skeptisch wahrgenommen.  In diesem Artikel schlage ich eine modifizierte Lösung vor.  Die Verwendungslogik und die API werden auf ein akzeptables Niveau gebracht.  Die Implementierung in Code erfolgt bis zur Beta-Stufe. </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Erklärung des Problems </h2><br><p> Wir werden die Definitionen aus dem Originalartikel verwenden.  Dies bedeutet insbesondere, dass <code>ImmutableList</code> eine unveränderliche Liste von Verweisen auf einige Objekte ist.  Wenn sich herausstellt, dass diese Objekte nicht unveränderlich sind, ist die Liste trotz des Namens auch kein unveränderliches Objekt.  In der Praxis ist es unwahrscheinlich, dass dies jemanden verletzt, aber um ungerechtfertigte Erwartungen zu vermeiden, muss dies erwähnt werden. </p><br><p>  Es ist auch klar, dass die Unveränderlichkeit der Liste durch Reflexionen oder durch Erstellen eigener Klassen im selben Paket "gehackt" werden kann, gefolgt vom Klettern in die geschützten Felder der Liste oder ähnliches. </p><br><p>  Im Gegensatz zum Originalartikel werden wir uns nicht an das Prinzip „alles oder nichts“ halten: Der Autor dort scheint zu glauben, dass nichts getan werden sollte, wenn das Problem auf JDK-Ebene nicht gelöst werden kann.  (Eigentlich eine andere Frage: "Kann nicht gelöst werden" oder "Die Java-Autoren hatten keine Lust, sie zu lösen." Es scheint mir, dass es immer noch möglich wäre, zusätzliche Schnittstellen, Klassen und Methoden hinzuzufügen, um vorhandene Sammlungen näher zu bringen gewünschtes Aussehen, obwohl weniger schön, als wenn Sie sofort darüber nachgedacht hätten, aber jetzt geht es nicht darum.) </p><br><p>  Wir werden eine Bibliothek erstellen, die erfolgreich mit vorhandenen Sammlungen in Java koexistieren kann. </p><br><p>  Die Hauptideen der Bibliothek: </p><br><ul><li>  Es gibt <code>ImmutableList</code> und <code>MutableList</code> .  Durch das Gießen von Typen ist es unmöglich, einen vom anderen zu bekommen. </li><li>  In unserem Projekt, das wir mithilfe der Bibliothek verbessern möchten, ersetzen wir alle <code>List</code> durch eine dieser beiden Schnittstellen.  Wenn Sie irgendwann nicht mehr auf die <code>List</code> , konvertieren wir die <code>List</code> bei der ersten Gelegenheit von / in eine der beiden Schnittstellen.  Gleiches gilt für die Momente des Empfangens / Sendens von Daten an Bibliotheken von Drittanbietern mithilfe von <code>List</code> . </li><li>  Gegenseitige Konvertierungen zwischen <code>ImmutableList</code> , <code>MutableList</code> , <code>List</code> sollten so schnell wie möglich durchgeführt werden ( <code>MutableList</code> wenn möglich ohne Kopieren von Listen).  Ohne „billige“ Roundtrip-Konvertierungen sieht die ganze Idee zweifelhaft aus. </li></ul><br><p>  Es ist zu beachten, dass nur Listen berücksichtigt werden, da derzeit nur diese in der Bibliothek implementiert sind.  Nichts hindert die Bibliothek jedoch daran, mit <code>Set</code> und <code>Map</code> s zu ergänzen. </p><br><h2 id="api">  API </h2><br><h3 id="immutablelist">  Unveränderliche Liste </h3><br><p>  <code>ImmutableList</code> ist der Nachfolger von <code>ReadOnlyList</code> (das wie im vorherigen Artikel eine kopierte <code>List</code> , von der alle Mutationsmethoden ausgelöst werden).  Methoden hinzugefügt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  Die <code>toList</code> Methode bietet die Möglichkeit, eine <code>ImmutableList</code> an Codeteile zu übergeben, die auf eine <code>List</code> warten.  Es wird ein Wrapper zurückgegeben, in dem alle Änderungsmethoden eine <code>UnsupportedOperationException</code> und die verbleibenden Methoden in die ursprüngliche <code>ImmutableList</code> umgeleitet werden. </p><br><p>  Die <code>mutable</code> Methode konvertiert eine <code>ImmutableList</code> in eine <code>MutableList</code> .  Es wird ein Wrapper zurückgegeben, in dem alle Methoden bis zur ersten Änderung zur ursprünglichen <code>ImmutableList</code> umgeleitet werden.  Vor der Änderung wird der Wrapper von der ursprünglichen <code>ImmutableList</code> und sein Inhalt in die interne <code>ArrayList</code> kopiert, in die dann alle Vorgänge umgeleitet werden. </p><br><p>  Die <code>contentEquals</code> Methode soll den Inhalt der Liste mit dem Inhalt einer beliebigen übergebenen <code>Iterable</code> (diese Operation ist natürlich nur für <code>Iterable</code> Implementierungen von Bedeutung, die eine bestimmte Reihenfolge von Elementen aufweisen). </p><br><p>  Beachten Sie, dass in unserer Implementierung von <code>listIterator</code> die <code>iterator</code> und <code>listIterator</code> Standard <code>java.util.Iterator</code> / <code>java.util.ListIterator</code> .  Diese Iteratoren enthalten Änderungsmethoden, die durch Auslösen einer <code>UnsupportedOperationException</code> unterdrückt werden müssen.  Es wäre vorzuziehen, unseren <code>ReadOnlyIterator</code> erstellen, aber in diesem Fall konnten wir nicht <code>for (Object item : immutableList)</code> schreiben, was sofort die Freude an der Nutzung der Bibliothek <code>for (Object item : immutableList)</code> würde. </p><br><h3 id="mutablelist">  MutableList </h3><br><p>  <code>MutableList</code> ist der Nachkomme der regulären <code>List</code> .  Methoden hinzugefügt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">releaseSnapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  Die <code>snapshot</code> Methode wurde entwickelt, um einen "Snapshot" des aktuellen Status von <code>MutableList</code> als <code>ImmutableList</code> <code>MutableList</code> .  Der „Snapshot“ wird in der <code>MutableList</code> . Wenn sich der Status zum Zeitpunkt des nächsten Methodenaufrufs nicht geändert hat, wird dieselbe Instanz von <code>ImmutableList</code> .  Der darin gespeicherte „Snapshot“ wird beim ersten <code>releaseSnapshot</code> einer Änderungsmethode oder beim <code>releaseSnapshot</code> .  Die <code>releaseSnapshot</code> Methode kann verwendet werden, um Speicherplatz zu sparen, wenn Sie sicher sind, dass niemand einen „Snapshot“ benötigt, aber Änderungsmethoden nicht bald aufgerufen werden. </p><br><h3 id="mutabor">  Mutabor </h3><br><p>  Die <code>Mutabor</code> Klasse bietet eine Reihe statischer Methoden, die die „Einstiegspunkte“ für die Bibliothek darstellen. </p><br><p>  Ja, das Projekt heißt jetzt "mutabor" (es steht im Einklang mit "veränderlich" und bedeutet in der Übersetzung "Ich werde transformieren", was gut mit der Idee übereinstimmt, einige Arten von Sammlungen schnell in andere zu "transformieren"). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E[] original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;E&gt; original)</span></span></span></span>;</code> </pre> <br><p>  <code>copyTo*</code> -Methoden <code>copyTo*</code> zum Erstellen geeigneter Sammlungen durch Kopieren der bereitgestellten Daten.  Die <code>convertTo*</code> -Methoden <code>convertTo*</code> eine schnelle Konvertierung der übertragenen Sammlung in den gewünschten Typ. Wenn eine schnelle Konvertierung nicht möglich war, führen sie ein langsames Kopieren durch.  Wenn die schnelle Konvertierung erfolgreich war, wird die ursprüngliche Sammlung gelöscht, und es wird davon ausgegangen, dass sie in Zukunft nicht mehr verwendet wird (obwohl dies möglich ist, dies jedoch kaum Sinn macht). </p><br><p>  Die Aufrufe der Konstruktoren der Implementierungsobjekte <code>ImmutableList</code> / <code>MutableList</code> ausgeblendet.  Es wird angenommen, dass der Benutzer sich nur mit Schnittstellen befasst, solche Objekte nicht erstellt und die oben beschriebenen Methoden verwendet, um Sammlungen zu transformieren. </p><br><h2 id="detali-realizacii">  Implementierungsdetails </h2><br><h3 id="immutablelistimpl">  ImmutableListImpl </h3><br><p>  Verkapselt ein Array von Objekten.  Die Implementierung entspricht in etwa der <code>ArrayList</code> Implementierung, aus der alle Änderungsmethoden und Überprüfungen auf gleichzeitige Änderung abgeleitet werden. </p><br><p>  Die Implementierung der <code>contentEquals</code> <code>toList</code> und <code>contentEquals</code> ebenfalls recht trivial.  Die <code>toList</code> Methode gibt einen Wrapper zurück, der Aufrufe an eine bestimmte <code>ImmutableList</code> umleitet. Ein langsames Kopieren von Daten findet nicht statt. </p><br><p>  Die <code>MutableListImpl</code> Methode gibt eine <code>MutableListImpl</code> die basierend auf dieser <code>ImmutableList</code> .  Das Kopieren von Daten erfolgt erst, wenn eine Änderungsmethode für die empfangene <code>MutableList</code> . </p><br><h3 id="mutablelistimpl">  MutableListImpl </h3><br><p>  Verkapselt Links zu <code>ImmutableList</code> und <code>List</code> .  Beim Erstellen eines Objekts wird immer nur einer dieser beiden Links gefüllt, der andere bleibt <code>null</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ImmutableList&lt;E&gt; immutable; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> List&lt;E&gt; list;</code> </pre> <br><p>  Unveränderliche Methoden leiten Aufrufe an <code>ImmutableList</code> wenn sie nicht <code>null</code> , und andernfalls an <code>List</code> . </p><br><p>  Durch Ändern von Methoden werden Aufrufe nach der Initialisierung an <code>List</code> umgeleitet: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(immutable.toList()); } immutable = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><p>  Die <code>snapshot</code> Methode sieht folgendermaßen aus: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> immutable; } immutable = InternalUtils.convertToImmutableList(list); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    //   ,  . //     immutable     . list = null; return immutable; } immutable = InternalUtils.copyToImmutableList(list); return immutable; }</span></span></code> </pre> <br><p>  Die Implementierung der <code>contentEquals</code> <code>releaseSnapshot</code> und <code>contentEquals</code> trivial. </p><br><p>  Mit diesem Ansatz können Sie die Anzahl der Kopien von Daten während der "normalen" Verwendung minimieren und Kopien durch schnelle Konvertierungen ersetzen. </p><br><h3 id="bystroe-preobrazovanie-spiskov">  Schnelle Listenkonvertierung </h3><br><p>  Schnelle Konvertierungen sind für die Klassen <code>ArrayList</code> oder <code>Arrays$ArrayList</code> (das Ergebnis der Methode <code>Arrays.asList()</code> ).  In der Praxis sind in den allermeisten Fällen genau diese Klassen anzutreffen. </p><br><p>  In diesen Klassen befindet sich ein Array von Elementen.  Das Wesentliche einer schnellen Konvertierung besteht darin, durch Reflexionen einen Verweis auf dieses Array zu erhalten (dies ist ein privates Feld) und durch einen Verweis auf ein leeres Array zu ersetzen.  Dadurch wird sichergestellt, dass der einzige Verweis auf das Array bei unserem Objekt verbleibt und das Array unverändert bleibt. </p><br><p>  In der vorherigen Version der Bibliothek wurden schnelle Konvertierungen von Sammlungstypen durch Aufrufen des Konstruktors durchgeführt.  Gleichzeitig verschlechterte sich das ursprüngliche Sammlungsobjekt (es wurde für die weitere Verwendung ungeeignet), was Sie vom Designer unbewusst nicht erwarten.  Jetzt wird eine spezielle statische Methode für die Konvertierung verwendet, und die ursprüngliche Sammlung wird nicht beschädigt, sondern einfach gelöscht.  So wurde erschreckendes ungewöhnliches Verhalten beseitigt. </p><br><h3 id="problemy-s-equals--hashcode">  Probleme mit equals / hashCode </h3><br><p>  Java-Sammlungen verwenden einen sehr seltsamen Ansatz, um <code>equals</code> und <code>hashCode</code> Methoden zu implementieren. </p><br><p>  Der Vergleich erfolgt nach dem Inhalt, was logisch erscheint, aber die Klasse der Liste selbst wird nicht berücksichtigt.  Daher sind beispielsweise <code>ArrayList</code> und <code>LinkedList</code> mit demselben Inhalt <code>equals</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Hier ist die equals / hashCode-Implementierung von AbstractList (von der ArrayList geerbt wird).</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator e2 = ((List) o).listIterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (e1.hasNext() &amp;&amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o1==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? o2==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : o1.equals(o2))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(e1.hasNext() || e2.hasNext()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashCode = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) hashCode = <span class="hljs-number"><span class="hljs-number">31</span></span>*hashCode + (e==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : e.hashCode()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashCode; }</code> </pre> </div></div><br><p>  Daher müssen jetzt absolut alle <code>List</code> Implementierungen eine ähnliche <code>equals</code> Implementierung haben (und als Ergebnis <code>hashCode</code> ).  Andernfalls können Situationen auftreten, in denen <code>a.equals(b) &amp;&amp; !b.equals(a)</code> , was nicht gut ist.  Eine ähnliche Situation ist bei <code>Set</code> und <code>Map</code> . </p><br><p>  In der Anwendung auf die Bibliothek bedeutet dies, dass die Implementierung von <code>equals</code> und <code>hashCode</code> für <code>MutableList</code> vordefiniert ist und in einer solchen Implementierung <code>ImmutableList</code> und <code>MutableList</code> mit demselben Inhalt nicht <code>equals</code> (da <code>ImmutableList</code> keine <code>List</code> ).  Daher wurden <code>contentEquals</code> Methoden hinzugefügt, um Inhalte zu vergleichen. </p><br><p>  Die Implementierung der Methoden <code>equals</code> und <code>hashCode</code> für <code>ImmutableList</code> vollständig der Version von <code>AbstractList</code> , ersetzt jedoch <code>List</code> durch <code>ReadOnlyList</code> . </p><br><h2 id="itogo">  Insgesamt </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Bibliotheksquellen und -tests werden als Referenz</a> in Form eines Maven-Projekts veröffentlicht. </p><br><p>  Für den Fall, dass jemand die Bibliothek nutzen möchte, hat er eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontaktgruppe</a> für „Feedback“ erstellt. </p><br><p>  Die Verwendung der Bibliothek ist ziemlich offensichtlich. Hier ein kurzes Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myBusinessProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Entity&gt; tempFromDb = queryEntitiesFromDatabase(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM my_table"</span></span>); ImmutableList&lt;Entity&gt; fromDb = Mutabor.convertToImmutableList(tempFromDb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromDb.isEmpty() || !someChecksPassed(fromDb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//... MutableList&lt;Entity&gt; list = fromDb.mutable(); //time to change list.remove(1); ImmutableList&lt;Entity&gt; processed = list.snapshot(); //time to change ended //... if (!callSideLibraryExpectsListParameter(processed.toList())) { return false; } for (Entity entity : processed) { outputToUI(entity); } return true; }</span></span></code> </pre> <br><p>  Viel Glück an alle!  Fehlerberichte senden! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471344/">https://habr.com/ru/post/de471344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471332/index.html">Geschichten vom Mondcomputer. Teil 3</a></li>
<li><a href="../de471334/index.html">Auswendig lernen, aber nicht vollstopfen - „mit Karten lernen“</a></li>
<li><a href="../de471336/index.html">Holivar. Geschichte von Runet. Teil 6. Schlösser: Lurk, Tape, 282. und chinesischer Pfad</a></li>
<li><a href="../de471340/index.html">Drimsim gegen Mate 20 Pro Round! Aber für wen?</a></li>
<li><a href="../de471342/index.html">Stilvolle Avalonia</a></li>
<li><a href="../de471346/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 384 (7. - 13. Oktober 2019)</a></li>
<li><a href="../de471348/index.html">Full-Stack-TypeScript-Apps</a></li>
<li><a href="../de471350/index.html">Reverse Engineering von rauscharmen Operationsverstärkern von einem analogen Computer im Jahr 1969</a></li>
<li><a href="../de471352/index.html">Präsentationen in LaTeX schreiben</a></li>
<li><a href="../de471358/index.html">Wie schreibe ich einen intelligenten Vertrag mit Python über Ontologie? Teil 4: Native API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>