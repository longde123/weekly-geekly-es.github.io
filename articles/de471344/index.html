<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíö üöï ‚ùóÔ∏è Noch einmal √ºber ImmutableList in Java üç∂ üëâüèø üß¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem vorherigen Artikel ‚Äû Umh√ºllen von ImmutableList in Java ‚Äú habe ich eine L√∂sung f√ºr das Problem des Fehlens unver√§nderlicher Listen in Java v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Noch einmal √ºber ImmutableList in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471344/"><p>  In meinem vorherigen Artikel ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umh√ºllen von ImmutableList in Java</a> ‚Äú habe ich eine L√∂sung f√ºr das Problem des Fehlens unver√§nderlicher Listen in Java vorgeschlagen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weder jetzt noch jemals</a> in Java behoben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> . </p><br><p>  Die L√∂sung wurde dann nur auf der Ebene ‚ÄûEs gibt eine solche Idee‚Äú ausgearbeitet, und die Implementierung im Code war schief, daher wurde alles etwas skeptisch wahrgenommen.  In diesem Artikel schlage ich eine modifizierte L√∂sung vor.  Die Verwendungslogik und die API werden auf ein akzeptables Niveau gebracht.  Die Implementierung in Code erfolgt bis zur Beta-Stufe. </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Erkl√§rung des Problems </h2><br><p> Wir werden die Definitionen aus dem Originalartikel verwenden.  Dies bedeutet insbesondere, dass <code>ImmutableList</code> eine unver√§nderliche Liste von Verweisen auf einige Objekte ist.  Wenn sich herausstellt, dass diese Objekte nicht unver√§nderlich sind, ist die Liste trotz des Namens auch kein unver√§nderliches Objekt.  In der Praxis ist es unwahrscheinlich, dass dies jemanden verletzt, aber um ungerechtfertigte Erwartungen zu vermeiden, muss dies erw√§hnt werden. </p><br><p>  Es ist auch klar, dass die Unver√§nderlichkeit der Liste durch Reflexionen oder durch Erstellen eigener Klassen im selben Paket "gehackt" werden kann, gefolgt vom Klettern in die gesch√ºtzten Felder der Liste oder √§hnliches. </p><br><p>  Im Gegensatz zum Originalartikel werden wir uns nicht an das Prinzip ‚Äûalles oder nichts‚Äú halten: Der Autor dort scheint zu glauben, dass nichts getan werden sollte, wenn das Problem auf JDK-Ebene nicht gel√∂st werden kann.  (Eigentlich eine andere Frage: "Kann nicht gel√∂st werden" oder "Die Java-Autoren hatten keine Lust, sie zu l√∂sen." Es scheint mir, dass es immer noch m√∂glich w√§re, zus√§tzliche Schnittstellen, Klassen und Methoden hinzuzuf√ºgen, um vorhandene Sammlungen n√§her zu bringen gew√ºnschtes Aussehen, obwohl weniger sch√∂n, als wenn Sie sofort dar√ºber nachgedacht h√§tten, aber jetzt geht es nicht darum.) </p><br><p>  Wir werden eine Bibliothek erstellen, die erfolgreich mit vorhandenen Sammlungen in Java koexistieren kann. </p><br><p>  Die Hauptideen der Bibliothek: </p><br><ul><li>  Es gibt <code>ImmutableList</code> und <code>MutableList</code> .  Durch das Gie√üen von Typen ist es unm√∂glich, einen vom anderen zu bekommen. </li><li>  In unserem Projekt, das wir mithilfe der Bibliothek verbessern m√∂chten, ersetzen wir alle <code>List</code> durch eine dieser beiden Schnittstellen.  Wenn Sie irgendwann nicht mehr auf die <code>List</code> , konvertieren wir die <code>List</code> bei der ersten Gelegenheit von / in eine der beiden Schnittstellen.  Gleiches gilt f√ºr die Momente des Empfangens / Sendens von Daten an Bibliotheken von Drittanbietern mithilfe von <code>List</code> . </li><li>  Gegenseitige Konvertierungen zwischen <code>ImmutableList</code> , <code>MutableList</code> , <code>List</code> sollten so schnell wie m√∂glich durchgef√ºhrt werden ( <code>MutableList</code> wenn m√∂glich ohne Kopieren von Listen).  Ohne ‚Äûbillige‚Äú Roundtrip-Konvertierungen sieht die ganze Idee zweifelhaft aus. </li></ul><br><p>  Es ist zu beachten, dass nur Listen ber√ºcksichtigt werden, da derzeit nur diese in der Bibliothek implementiert sind.  Nichts hindert die Bibliothek jedoch daran, mit <code>Set</code> und <code>Map</code> s zu erg√§nzen. </p><br><h2 id="api">  API </h2><br><h3 id="immutablelist">  Unver√§nderliche Liste </h3><br><p>  <code>ImmutableList</code> ist der Nachfolger von <code>ReadOnlyList</code> (das wie im vorherigen Artikel eine kopierte <code>List</code> , von der alle Mutationsmethoden ausgel√∂st werden).  Methoden hinzugef√ºgt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  Die <code>toList</code> Methode bietet die M√∂glichkeit, eine <code>ImmutableList</code> an Codeteile zu √ºbergeben, die auf eine <code>List</code> warten.  Es wird ein Wrapper zur√ºckgegeben, in dem alle √Ñnderungsmethoden eine <code>UnsupportedOperationException</code> und die verbleibenden Methoden in die urspr√ºngliche <code>ImmutableList</code> umgeleitet werden. </p><br><p>  Die <code>mutable</code> Methode konvertiert eine <code>ImmutableList</code> in eine <code>MutableList</code> .  Es wird ein Wrapper zur√ºckgegeben, in dem alle Methoden bis zur ersten √Ñnderung zur urspr√ºnglichen <code>ImmutableList</code> umgeleitet werden.  Vor der √Ñnderung wird der Wrapper von der urspr√ºnglichen <code>ImmutableList</code> und sein Inhalt in die interne <code>ArrayList</code> kopiert, in die dann alle Vorg√§nge umgeleitet werden. </p><br><p>  Die <code>contentEquals</code> Methode soll den Inhalt der Liste mit dem Inhalt einer beliebigen √ºbergebenen <code>Iterable</code> (diese Operation ist nat√ºrlich nur f√ºr <code>Iterable</code> Implementierungen von Bedeutung, die eine bestimmte Reihenfolge von Elementen aufweisen). </p><br><p>  Beachten Sie, dass in unserer Implementierung von <code>listIterator</code> die <code>iterator</code> und <code>listIterator</code> Standard <code>java.util.Iterator</code> / <code>java.util.ListIterator</code> .  Diese Iteratoren enthalten √Ñnderungsmethoden, die durch Ausl√∂sen einer <code>UnsupportedOperationException</code> unterdr√ºckt werden m√ºssen.  Es w√§re vorzuziehen, unseren <code>ReadOnlyIterator</code> erstellen, aber in diesem Fall konnten wir nicht <code>for (Object item : immutableList)</code> schreiben, was sofort die Freude an der Nutzung der Bibliothek <code>for (Object item : immutableList)</code> w√ºrde. </p><br><h3 id="mutablelist">  MutableList </h3><br><p>  <code>MutableList</code> ist der Nachkomme der regul√§ren <code>List</code> .  Methoden hinzugef√ºgt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">releaseSnapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  Die <code>snapshot</code> Methode wurde entwickelt, um einen "Snapshot" des aktuellen Status von <code>MutableList</code> als <code>ImmutableList</code> <code>MutableList</code> .  Der ‚ÄûSnapshot‚Äú wird in der <code>MutableList</code> . Wenn sich der Status zum Zeitpunkt des n√§chsten Methodenaufrufs nicht ge√§ndert hat, wird dieselbe Instanz von <code>ImmutableList</code> .  Der darin gespeicherte ‚ÄûSnapshot‚Äú wird beim ersten <code>releaseSnapshot</code> einer √Ñnderungsmethode oder beim <code>releaseSnapshot</code> .  Die <code>releaseSnapshot</code> Methode kann verwendet werden, um Speicherplatz zu sparen, wenn Sie sicher sind, dass niemand einen ‚ÄûSnapshot‚Äú ben√∂tigt, aber √Ñnderungsmethoden nicht bald aufgerufen werden. </p><br><h3 id="mutabor">  Mutabor </h3><br><p>  Die <code>Mutabor</code> Klasse bietet eine Reihe statischer Methoden, die die ‚ÄûEinstiegspunkte‚Äú f√ºr die Bibliothek darstellen. </p><br><p>  Ja, das Projekt hei√üt jetzt "mutabor" (es steht im Einklang mit "ver√§nderlich" und bedeutet in der √úbersetzung "Ich werde transformieren", was gut mit der Idee √ºbereinstimmt, einige Arten von Sammlungen schnell in andere zu "transformieren"). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E[] original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;E&gt; original)</span></span></span></span>;</code> </pre> <br><p>  <code>copyTo*</code> -Methoden <code>copyTo*</code> zum Erstellen geeigneter Sammlungen durch Kopieren der bereitgestellten Daten.  Die <code>convertTo*</code> -Methoden <code>convertTo*</code> eine schnelle Konvertierung der √ºbertragenen Sammlung in den gew√ºnschten Typ. Wenn eine schnelle Konvertierung nicht m√∂glich war, f√ºhren sie ein langsames Kopieren durch.  Wenn die schnelle Konvertierung erfolgreich war, wird die urspr√ºngliche Sammlung gel√∂scht, und es wird davon ausgegangen, dass sie in Zukunft nicht mehr verwendet wird (obwohl dies m√∂glich ist, dies jedoch kaum Sinn macht). </p><br><p>  Die Aufrufe der Konstruktoren der Implementierungsobjekte <code>ImmutableList</code> / <code>MutableList</code> ausgeblendet.  Es wird angenommen, dass der Benutzer sich nur mit Schnittstellen befasst, solche Objekte nicht erstellt und die oben beschriebenen Methoden verwendet, um Sammlungen zu transformieren. </p><br><h2 id="detali-realizacii">  Implementierungsdetails </h2><br><h3 id="immutablelistimpl">  ImmutableListImpl </h3><br><p>  Verkapselt ein Array von Objekten.  Die Implementierung entspricht in etwa der <code>ArrayList</code> Implementierung, aus der alle √Ñnderungsmethoden und √úberpr√ºfungen auf gleichzeitige √Ñnderung abgeleitet werden. </p><br><p>  Die Implementierung der <code>contentEquals</code> <code>toList</code> und <code>contentEquals</code> ebenfalls recht trivial.  Die <code>toList</code> Methode gibt einen Wrapper zur√ºck, der Aufrufe an eine bestimmte <code>ImmutableList</code> umleitet. Ein langsames Kopieren von Daten findet nicht statt. </p><br><p>  Die <code>MutableListImpl</code> Methode gibt eine <code>MutableListImpl</code> die basierend auf dieser <code>ImmutableList</code> .  Das Kopieren von Daten erfolgt erst, wenn eine √Ñnderungsmethode f√ºr die empfangene <code>MutableList</code> . </p><br><h3 id="mutablelistimpl">  MutableListImpl </h3><br><p>  Verkapselt Links zu <code>ImmutableList</code> und <code>List</code> .  Beim Erstellen eines Objekts wird immer nur einer dieser beiden Links gef√ºllt, der andere bleibt <code>null</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ImmutableList&lt;E&gt; immutable; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> List&lt;E&gt; list;</code> </pre> <br><p>  Unver√§nderliche Methoden leiten Aufrufe an <code>ImmutableList</code> wenn sie nicht <code>null</code> , und andernfalls an <code>List</code> . </p><br><p>  Durch √Ñndern von Methoden werden Aufrufe nach der Initialisierung an <code>List</code> umgeleitet: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(immutable.toList()); } immutable = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><p>  Die <code>snapshot</code> Methode sieht folgenderma√üen aus: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> immutable; } immutable = InternalUtils.convertToImmutableList(list); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    //   ,  . //     immutable     . list = null; return immutable; } immutable = InternalUtils.copyToImmutableList(list); return immutable; }</span></span></code> </pre> <br><p>  Die Implementierung der <code>contentEquals</code> <code>releaseSnapshot</code> und <code>contentEquals</code> trivial. </p><br><p>  Mit diesem Ansatz k√∂nnen Sie die Anzahl der Kopien von Daten w√§hrend der "normalen" Verwendung minimieren und Kopien durch schnelle Konvertierungen ersetzen. </p><br><h3 id="bystroe-preobrazovanie-spiskov">  Schnelle Listenkonvertierung </h3><br><p>  Schnelle Konvertierungen sind f√ºr die Klassen <code>ArrayList</code> oder <code>Arrays$ArrayList</code> (das Ergebnis der Methode <code>Arrays.asList()</code> ).  In der Praxis sind in den allermeisten F√§llen genau diese Klassen anzutreffen. </p><br><p>  In diesen Klassen befindet sich ein Array von Elementen.  Das Wesentliche einer schnellen Konvertierung besteht darin, durch Reflexionen einen Verweis auf dieses Array zu erhalten (dies ist ein privates Feld) und durch einen Verweis auf ein leeres Array zu ersetzen.  Dadurch wird sichergestellt, dass der einzige Verweis auf das Array bei unserem Objekt verbleibt und das Array unver√§ndert bleibt. </p><br><p>  In der vorherigen Version der Bibliothek wurden schnelle Konvertierungen von Sammlungstypen durch Aufrufen des Konstruktors durchgef√ºhrt.  Gleichzeitig verschlechterte sich das urspr√ºngliche Sammlungsobjekt (es wurde f√ºr die weitere Verwendung ungeeignet), was Sie vom Designer unbewusst nicht erwarten.  Jetzt wird eine spezielle statische Methode f√ºr die Konvertierung verwendet, und die urspr√ºngliche Sammlung wird nicht besch√§digt, sondern einfach gel√∂scht.  So wurde erschreckendes ungew√∂hnliches Verhalten beseitigt. </p><br><h3 id="problemy-s-equals--hashcode">  Probleme mit equals / hashCode </h3><br><p>  Java-Sammlungen verwenden einen sehr seltsamen Ansatz, um <code>equals</code> und <code>hashCode</code> Methoden zu implementieren. </p><br><p>  Der Vergleich erfolgt nach dem Inhalt, was logisch erscheint, aber die Klasse der Liste selbst wird nicht ber√ºcksichtigt.  Daher sind beispielsweise <code>ArrayList</code> und <code>LinkedList</code> mit demselben Inhalt <code>equals</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Hier ist die equals / hashCode-Implementierung von AbstractList (von der ArrayList geerbt wird).</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator e2 = ((List) o).listIterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (e1.hasNext() &amp;&amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o1==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? o2==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : o1.equals(o2))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(e1.hasNext() || e2.hasNext()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashCode = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) hashCode = <span class="hljs-number"><span class="hljs-number">31</span></span>*hashCode + (e==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : e.hashCode()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashCode; }</code> </pre> </div></div><br><p>  Daher m√ºssen jetzt absolut alle <code>List</code> Implementierungen eine √§hnliche <code>equals</code> Implementierung haben (und als Ergebnis <code>hashCode</code> ).  Andernfalls k√∂nnen Situationen auftreten, in denen <code>a.equals(b) &amp;&amp; !b.equals(a)</code> , was nicht gut ist.  Eine √§hnliche Situation ist bei <code>Set</code> und <code>Map</code> . </p><br><p>  In der Anwendung auf die Bibliothek bedeutet dies, dass die Implementierung von <code>equals</code> und <code>hashCode</code> f√ºr <code>MutableList</code> vordefiniert ist und in einer solchen Implementierung <code>ImmutableList</code> und <code>MutableList</code> mit demselben Inhalt nicht <code>equals</code> (da <code>ImmutableList</code> keine <code>List</code> ).  Daher wurden <code>contentEquals</code> Methoden hinzugef√ºgt, um Inhalte zu vergleichen. </p><br><p>  Die Implementierung der Methoden <code>equals</code> und <code>hashCode</code> f√ºr <code>ImmutableList</code> vollst√§ndig der Version von <code>AbstractList</code> , ersetzt jedoch <code>List</code> durch <code>ReadOnlyList</code> . </p><br><h2 id="itogo">  Insgesamt </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Bibliotheksquellen und -tests werden als Referenz</a> in Form eines Maven-Projekts ver√∂ffentlicht. </p><br><p>  F√ºr den Fall, dass jemand die Bibliothek nutzen m√∂chte, hat er eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontaktgruppe</a> f√ºr ‚ÄûFeedback‚Äú erstellt. </p><br><p>  Die Verwendung der Bibliothek ist ziemlich offensichtlich. Hier ein kurzes Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myBusinessProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Entity&gt; tempFromDb = queryEntitiesFromDatabase(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM my_table"</span></span>); ImmutableList&lt;Entity&gt; fromDb = Mutabor.convertToImmutableList(tempFromDb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromDb.isEmpty() || !someChecksPassed(fromDb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//... MutableList&lt;Entity&gt; list = fromDb.mutable(); //time to change list.remove(1); ImmutableList&lt;Entity&gt; processed = list.snapshot(); //time to change ended //... if (!callSideLibraryExpectsListParameter(processed.toList())) { return false; } for (Entity entity : processed) { outputToUI(entity); } return true; }</span></span></code> </pre> <br><p>  Viel Gl√ºck an alle!  Fehlerberichte senden! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471344/">https://habr.com/ru/post/de471344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471332/index.html">Geschichten vom Mondcomputer. Teil 3</a></li>
<li><a href="../de471334/index.html">Auswendig lernen, aber nicht vollstopfen - ‚Äûmit Karten lernen‚Äú</a></li>
<li><a href="../de471336/index.html">Holivar. Geschichte von Runet. Teil 6. Schl√∂sser: Lurk, Tape, 282. und chinesischer Pfad</a></li>
<li><a href="../de471340/index.html">Drimsim gegen Mate 20 Pro Round! Aber f√ºr wen?</a></li>
<li><a href="../de471342/index.html">Stilvolle Avalonia</a></li>
<li><a href="../de471346/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 384 (7. - 13. Oktober 2019)</a></li>
<li><a href="../de471348/index.html">Full-Stack-TypeScript-Apps</a></li>
<li><a href="../de471350/index.html">Reverse Engineering von rauscharmen Operationsverst√§rkern von einem analogen Computer im Jahr 1969</a></li>
<li><a href="../de471352/index.html">Pr√§sentationen in LaTeX schreiben</a></li>
<li><a href="../de471358/index.html">Wie schreibe ich einen intelligenten Vertrag mit Python √ºber Ontologie? Teil 4: Native API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>