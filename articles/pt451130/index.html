<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏽 👩🏿‍🤝‍👩🏼 🧛🏼 Swift: ARC e gerenciamento de memória 🌮 🗒️ 😾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sendo uma linguagem moderna de alto nível, o Swift basicamente cuida do gerenciamento de memória em seus aplicativos, alocando e liberando memória. Is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift: ARC e gerenciamento de memória</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451130/">  Sendo uma linguagem moderna de alto nível, o <b>Swift</b> basicamente cuida do gerenciamento de memória em seus aplicativos, alocando e liberando memória.  Isso ocorre devido a um mecanismo chamado <b>contagem automática de referência</b> , ou <b>ARC, para</b> abreviar.  Neste guia, você aprenderá como o ARC funciona e como gerenciar adequadamente a memória no Swift.  Noções básicas sobre esse mecanismo, você pode influenciar a vida útil dos objetos localizados na pilha ( <b>pilha</b> ). <br><br>  Neste guia, você desenvolverá seu conhecimento sobre Swift e ARC aprendendo o seguinte: <br><br><ul><li>  como o ARC funciona </li><li>  o que são <b>ciclos de referência</b> e como corrigi-los corretamente </li><li>  como criar um loop de link de exemplo </li><li>  Como encontrar loops de link usando as ferramentas visuais oferecidas pelo Xcode </li><li>  como lidar com tipos de referência e tipos de valor </li></ul><a name="habracut"></a><br><h2>  Introdução </h2><br>  Faça o download dos <a href="" rel="nofollow">materiais de origem.</a>  Abra o projeto na pasta <b>Cycles / Starter</b> .  Na primeira parte do nosso guia, entendendo os principais conceitos, trataremos exclusivamente do arquivo <b>MainViewController.swif</b> t. <br><br>  Adicione esta classe na parte inferior do MainViewController.swift: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"User \(name) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating user named: \(name)"</span></span>) } }</code> </pre> <br>  A classe <b>User</b> é definida aqui, a qual, com a ajuda das instruções <b>print</b> , nos sinaliza sobre a inicialização e o lançamento da instância da classe. <br><br>  Agora crie uma instância da classe User na parte superior do MainViewController. <br><br>  Coloque esse código antes do método <b>viewDidLoad ()</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>)</code> </pre> <br>  Inicie o aplicativo.  Torne o console do Xcode visível com <b>Command-Shift-Y</b> para ver a saída das instruções de impressão. <br><br>  Observe que o <b>usuário John foi inicializado</b> apareceu no console, mas a instrução print dentro do <b>deinit</b> não <b>foi</b> executada.  Isso significa que esse objeto não foi lançado, pois não saiu do <b>escopo</b> . <br><br>  Em outras palavras, até que o controlador de exibição que contém este objeto fique fora do escopo, o objeto nunca será liberado. <br><br><h2>  Ele está no escopo? </h2><br>  Ao envolver uma instância da classe User em um método, permitiremos que ela fique fora do escopo, permitindo que o ARC a liberte. <br><br>  Vamos criar o método <b>runScenario ()</b> dentro da classe MainViewController e mover a inicialização da instância da classe User dentro dela. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runScenario</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-type"><span class="hljs-type">User</span></span>(name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>) }</code> </pre><br>  runScenario () define o escopo da instância do usuário.  Ao sair desta zona, o <b>usuário</b> deve ser liberado. <br><br>  Agora chame runScenario () adicionando isso no final de viewDidLoad (): <br><br><pre> <code class="swift hljs">runScenario()</code> </pre> <br>  Inicie o aplicativo.  A saída do console agora fica assim: <br><br>  O usuário John foi inicializado <br>  Desalocando usuário chamado: John <br><br>  Isso significa que você liberou um objeto que saiu do campo de visão. <br><br><h2>  Duração do objeto </h2><br><br>  A existência do objeto é dividida em cinco estágios: <br><br><ul><li>  alocação de memória: da pilha ou da pilha </li><li>  inicialização: o código é executado dentro do init </li><li>  uso de </li><li>  desinicialização: o código é executado dentro do deinit </li><li>  memória livre: a memória alocada é retornada à pilha ou pilha </li></ul><br>  Não existe uma maneira direta de rastrear as etapas de alocação e liberação de memória, mas você pode usar o código dentro de init e deinit. <br><br>  <b>As contagens de referência</b> , também conhecidas como <b>contagens de uso</b> , determinam quando um objeto não é mais necessário.  Este contador mostra o número daqueles que "usam" este objeto.  Um objeto se torna desnecessário quando o contador de uso é zero.  Em seguida, o objeto é dessinicializado e liberado. <br><br><img src="https://habrastorage.org/webt/b5/oo/78/b5oo78ealf173ey0ayz7rngnszk.png"><br><br>  Quando o objeto Usuário é inicializado, sua contagem de referência é 1, porque a constante do <b>usuário</b> se refere a esse objeto. <br><br>  No final de runScenario (), o usuário fica fora do escopo e a contagem de referência é reduzida para 0. Como resultado, o usuário é não inicializado e liberado. <br><br><h2>  Ciclos de referência </h2><br>  Na maioria dos casos, o ARC funciona como deveria.  O desenvolvedor geralmente não precisa se preocupar com vazamentos de memória quando objetos não utilizados permanecem não alocados indefinidamente. <br><br>  Mas nem sempre!  Possíveis vazamentos de memória. <br><br>  Como isso pode acontecer?  Imagine uma situação em que dois objetos não sejam mais usados, mas cada um deles se refira ao outro.  Como cada contagem de referência não é 0, nenhum deles será liberado. <br><br><img src="https://habrastorage.org/webt/hd/zp/ff/hdzpffk1eh3rug0fgmgnlghnb3q.png"><br><br>  Este é um <b>forte ciclo de referência</b> .  Essa situação confunde o ARC e não permite que ele limpe a memória. <br><br>  Como você pode ver, a contagem de referência no final não é 0 e, embora nenhum objeto seja mais necessário, o objeto1 e o objeto2 não serão liberados. <br><br><h2>  Confira nossos links </h2><br>  Para testar tudo isso em ação, adicione esse código após a classe User em MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phone</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> model: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(model: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model = model <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Phone \(model) was initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating phone named: \(model)"</span></span>) } }</code> </pre> <br>  Esse código adiciona uma nova classe <b>Phone</b> com duas propriedades, uma para o modelo e outra para o proprietário, além dos métodos init e deinit.  A propriedade do proprietário é opcional, pois o telefone pode não ter um proprietário. <br><br>  Agora adicione esta linha ao runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iPhone = <span class="hljs-type"><span class="hljs-type">Phone</span></span>(model: <span class="hljs-string"><span class="hljs-string">"iPhone Xs"</span></span>)</code> </pre><br>  Isso criará uma instância da classe Phone. <br><br><h2>  Segure o celular </h2><br>  Agora adicione esse código à classe User, imediatamente após a propriedade name: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phones: [<span class="hljs-type"><span class="hljs-type">Phone</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(phone: Phone)</span></span></span></span> { phones.append(phone) phone.owner = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }</code> </pre><br>  Adicione uma variedade de telefones pertencentes ao usuário.  O setter está marcado como privado, portanto, adicione (telefone :) deve ser usado. <br><br>  Inicie o aplicativo.  Como você pode ver, as instâncias das classes de objetos Telefone e Usuário são liberadas conforme necessário. <br><br>  O usuário John foi inicializado <br>  O telefone iPhone XS foi inicializado <br>  Desalocando o telefone com o nome: iPhone Xs <br>  Desalocando usuário chamado: John <br><br>  Agora adicione isso no final do runScenario (): <br><pre> <code class="swift hljs">user.add(phone: iPhone)</code> </pre> <br><br>  Aqui, adicionamos nosso iPhone à lista de telefones pertencentes ao <b>usuário</b> e também definimos a propriedade do <b>proprietário</b> do telefone como ' <b>usuário</b> '. <br><br>  Execute o aplicativo novamente.  Você verá que os objetos de usuário e iPhone não são liberados.  O ciclo de fortes vínculos entre eles impede o ARC de liberá-los. <br><br><img src="https://habrastorage.org/webt/lo/az/mu/loazmuamyoww2ttr7wnwcd8_n4w.png"><br><br><h2>  Links Fracos </h2><br>  Para interromper o ciclo de vínculos fortes, você pode designar o relacionamento entre objetos como fraco. <br><br>  Por padrão, todos os links são fortes e a atribuição leva a um aumento na contagem de referência.  Ao usar referências fracas, a contagem de referências não aumenta. <br><br>  Em outras palavras, <b>os elos fracos não afetam o gerenciamento da vida de um objeto</b> .  Links fracos são sempre declarados <b>opcionais</b> .  Dessa forma, quando a contagem de links se tornar 0, o link poderá ser definido como nulo. <br><br><img src="https://habrastorage.org/webt/ti/qd/kc/tiqdkcyfstrndd8xswpf8zfebfo.png"><br><br>  Nesta ilustração, linhas tracejadas indicam links fracos.  Observe que a contagem de referência do objeto1 é 1, pois a variável1 se refere a ele.  A contagem de referência do objeto2 é 2, porque é referenciada pela variável2 e pelo objeto1. <br><br>  O objeto2 também faz referência ao objeto1, mas <b>WEAK</b> , o que significa que ele não afeta a contagem de referências do objeto1. <br><br>  Quando a variável1 e a variável2 são liberadas, o objeto1 tem uma contagem de referência 0, que a libera.  Isso, por sua vez, libera uma forte referência ao objeto2, que já leva ao seu lançamento. <br><br>  Na classe Phone, altere a declaração de propriedade do proprietário da seguinte maneira: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner: <span class="hljs-type"><span class="hljs-type">User?</span></span></code> </pre> <br>  Ao declarar a referência da propriedade do proprietário como 'fraca', interrompemos o ciclo de vínculos fortes entre as classes User e Phone. <br><br><img src="https://habrastorage.org/webt/ym/ax/_m/ymax_mv9cvlpi8xqwnxmb14vr2g.png"><br><br>  Inicie o aplicativo.  Agora, usuário e telefone foram liberados corretamente. <br><br><h2>  Links não proprietários </h2><br>  Há também outro modificador de link que não aumenta a contagem de referência: <b>sem dono</b> . <br><br>  Qual a diferença entre <b>não dono</b> e <b>fraco</b> ?  Uma referência fraca é sempre opcional e se torna automaticamente nula quando o objeto referenciado é liberado. <br><br>  É por isso que devemos declarar propriedades fracas como uma variável opcional do tipo: essa propriedade deve mudar. <br><br>  Os links não proprietários, por outro lado, nunca são opcionais.  Se você tentar acessar uma propriedade não proprietária que se refere a um objeto liberado, receberá um erro que se parece com um desembrulhamento forçado contendo uma variável nula (forçar desembrulhamento). <br><br><img src="https://habrastorage.org/webt/i9/hf/bc/i9hfbcizzk2eg38s_hidjq3evju.png"><br><br>  Vamos tentar aplicar <b>sem dono</b> . <br><br>  Adicione uma nova classe <b>CarrierSubscription</b> no final do MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarrierSubscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>, countryCode: <span class="hljs-type"><span class="hljs-type">String</span></span>, number: <span class="hljs-type"><span class="hljs-type">String</span></span>, user: <span class="hljs-type"><span class="hljs-type">User</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode = countryCode <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number = number <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.user = user <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"CarrierSubscription \(name) is initialized"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Deallocating CarrierSubscription named: \(name)"</span></span>) } }</code> </pre> <br>  CarrierSubscription possui quatro propriedades: <br><br>  Nome: nome do provedor. <br>  CountryCode: código do país. <br>  Número: número de telefone. <br>  Usuário: link para o usuário. <br><br><h2>  Quem é o seu provedor? </h2><br>  Agora adicione isso à classe User após a propriedade name: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscriptions: [<span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>] = []</code> </pre> <br>  Aqui mantemos uma variedade de provedores de usuários. <br><br>  Agora adicione isso à classe Phone, após a propriedade do proprietário: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> carrierSubscription: <span class="hljs-type"><span class="hljs-type">CarrierSubscription?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(carrierSubscription: CarrierSubscription)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.carrierSubscription = carrierSubscription } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decommission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { carrierSubscription = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Isso adiciona a propriedade opcional CarrierSubscription e dois métodos para registrar e cancelar o registro do telefone com o provedor. <br><br>  Agora adicione a classe CarrierSubscription dentro do método init, logo antes da instrução print: <br><br><pre> <code class="swift hljs">user.subscriptions.append(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br>  Adicionamos CarrierSubscription à matriz de provedores de usuários. <br><br>  Por fim, adicione isso no final do método runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscription = <span class="hljs-type"><span class="hljs-type">CarrierSubscription</span></span>( name: <span class="hljs-string"><span class="hljs-string">"TelBel"</span></span>, countryCode: <span class="hljs-string"><span class="hljs-string">"0032"</span></span>, number: <span class="hljs-string"><span class="hljs-string">"31415926"</span></span>, user: user) iPhone.provision(carrierSubscription: subscription)</code> </pre> <br>  Criamos uma assinatura do provedor para o usuário e conectamos o telefone a ele. <br><br>  Inicie o aplicativo.  No console, você verá: <br><br>  O usuário John foi inicializado <br>  Telefone iPhone Xs foi inicializado <br>  CarrierSubscription TelBel é inicializado <br><br>  E novamente um ciclo de links!  usuário, iPhone e assinatura não foram liberados no final. <br><br>  Você consegue encontrar um problema? <br><br><img src="https://habrastorage.org/webt/uu/fg/eq/uufgeqkvqa31jwwlsnlikc-iob8.png"><br><br><h2>  Quebrando a corrente </h2><br>  O link do usuário para a assinatura ou o link da assinatura para o usuário deve ser não proprietário para interromper o ciclo.  A questão é qual opção escolher.  Vamos olhar para as estruturas. <br><br>  Um usuário possui uma assinatura de um provedor, mas vice-versa - não, uma assinatura de um provedor não possui um usuário. <br><br>  Além disso, não faz sentido a existência de CarrierSubscription sem referência ao usuário que o possui. <br><br>  Portanto, o link do usuário deve ser sem dono. <br><br>  Altere a declaração do usuário em CarrierSubscription: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span></code> </pre><br>  Agora, o usuário não é proprietário, o que quebra o ciclo dos links e permite liberar todos os objetos. <br><br><img src="https://habrastorage.org/webt/en/vx/cu/envxcuihbevfcfqv1cyg-kc3lo4.png"><br><br><h2>  Loop de links em fechamentos </h2><br>  Os ciclos de link para objetos ocorrem quando os objetos têm propriedades que se referem um ao outro.  Como objetos, os fechamentos são um tipo de referência e podem levar a loops de referência.  Os fechamentos capturam objetos que eles usam. <br><br>  Por exemplo, se você atribuir um fechamento a uma propriedade de uma classe, e esse fechamento usar propriedades da mesma classe, obteremos um loop de links.  Em outras palavras, o objeto mantém um link para o fechamento através da propriedade  O fechamento contém uma referência ao objeto através do valor capturado de si mesmo. <br><br><img src="https://habrastorage.org/webt/z-/lh/ow/z-lhowlkfyvy4ycusafxhygjisw.png"><br><br>  Adicione este código ao CarrierSubscription imediatamente após a propriedade do usuário: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre><br>  Esse fechamento calcula e retorna o número de telefone completo.  A propriedade é declarada <b>preguiçosa</b> , será atribuída no primeiro uso. <br><br>  Isso é necessário porque ele usa self.countryCode e self.number, que não estarão disponíveis até que o código do inicializador seja executado. <br><br>  Adicione runScenario () ao final: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(subscription.completePhoneNumber())</code> </pre> <br>  A chamada completePhoneNumber () executará o fechamento. <br><br>  Inicie o aplicativo e você verá que o usuário e o iPhone foram liberados, mas CarrierSubscription não é, devido a um ciclo de fortes vínculos entre o objeto e o fechamento. <br><br><img src="https://habrastorage.org/webt/7t/rb/ax/7trbaxtrrhtadtm29-dvqwehzo4.png"><br><br><h2>  Listas de captura </h2><br>  O Swift fornece uma maneira simples e elegante de quebrar o ciclo de vínculos fortes nos fechamentos.  Você declara uma lista de captura na qual define o relacionamento entre o fechamento e os objetos que ele captura. <br><br>  Para demonstrar a lista de captura, considere o seguinte código: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> someClosure = { [x] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(x), \(y)"</span></span>) } x = <span class="hljs-number"><span class="hljs-number">6</span></span> y = <span class="hljs-number"><span class="hljs-number">6</span></span> someClosure() <span class="hljs-comment"><span class="hljs-comment">// Prints 5, 6 print("\(x), \(y)") // Prints 6, 6</span></span></code> </pre> <br>  x está na lista de captura de fechamento, portanto, o valor de x é copiado para a definição de fechamento.  É capturado pelo valor. <br><br>  y não está na lista de capturas, é capturado por referência.  Isso significa que o valor de y será o que era no momento em que o circuito foi chamado. <br><br>  As listas de bloqueio ajudam a identificar interações fracas ou não proprietárias com relação aos objetos capturados dentro do loop.  No nosso caso, a escolha apropriada não é possuída, pois um fechamento não pode existir se a instância CarrierSubscription for liberada. <br><br><h2>  Aproveite-se </h2><br>  Substitua a definição completePhoneNumber por CarrierSubscription :: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completePhoneNumber: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.countryCode + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.number }</code> </pre> <br>  Nós adicionamos <b>[self sem dono]</b> à lista de captura de fechamento.  Isso significa que nos capturamos como um elo <b>sem dono em</b> vez de forte. <br><br>  Inicie o aplicativo e você verá que o CarrierSubscription foi lançado. <br><br>  De fato, a sintaxe acima é uma forma abreviada de uma mais longa e mais completa, na qual uma nova variável aparece: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> newID = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// Use unowned newID here... }</span></span></code> </pre> <br>  Aqui newID é uma cópia sem dono do eu.  Além do fechamento, o eu permanece em si.  Na forma abreviada dada anteriormente, <b>criamos uma nova variável auto</b> que obscurece o eu existente dentro do fechamento. <br><br><h2>  Use Unowned cuidadosamente </h2><br>  No seu código, o relacionamento entre self e completePhoneNumber é designado como não proprietário. <br><br>  Se você tiver certeza de que o objeto usado no fechamento não será liberado, poderá usar o não proprietário.  Se ele faz, você está com problemas! <br><br>  Adicione este código no final do MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WWDCGreeting</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> who: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(who: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.who = who } <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> } }</code> </pre><br>  Agora, aqui está o fim do runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mermaid = <span class="hljs-type"><span class="hljs-type">WWDCGreeting</span></span>(who: <span class="hljs-string"><span class="hljs-string">"caffeinated mermaid"</span></span>) greetingMaker = mermaid.greetingMaker } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(greetingMaker()) <span class="hljs-comment"><span class="hljs-comment">// !</span></span></code> </pre> <br>  Inicie o aplicativo e você verá uma falha e algo assim no console: <br><br>  O usuário John foi inicializado <br>  O telefone iPhone XS foi inicializado <br>  CarrierSubscription TelBel é inicializado <br>  0032 31415926 <br>  Erro fatal: tentativa de ler uma referência sem dono, mas o objeto 0x600000f0de30 já foi desalocado2019-02-24 12: 29: 40.744248-0600 Ciclos [33489: 5926466] Erro fatal: tentativa de ler uma referência sem dono, mas o objeto 0x600000f0de30 já foi desalocado <br><br>  Uma exceção ocorreu porque o fechamento aguarda a existência de si mesmo, mas foi liberado assim que a sereia saiu do escopo no final do bloco do. <br><br>  Este exemplo pode parecer sugado de um dedo, mas essas coisas acontecem.  Por exemplo, quando usamos fechamentos para iniciar algo muito mais tarde, digamos, após o término da chamada assíncrona na rede. <br><br><h2>  Desarmar a armadilha </h2><br>  Substitua greetingMaker na classe WWDCGreeting por esta: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self?.who)."</span></span> }</code> </pre> <br>  Fizemos duas coisas: primeiro, substituímos os não proprietários pelos fracos.  Em segundo lugar, como o eu se tornou fraco, acessamos a propriedade who através do eu?  Ignore o aviso do Xcode, iremos corrigi-lo em breve. <br><br>  O aplicativo não trava mais, mas se você executá-lo, obtemos um resultado engraçado: "Olá, nada". <br><br>  Talvez o resultado seja bastante aceitável, mas geralmente precisamos fazer algo se o objeto foi liberado.  Isso pode ser feito usando a declaração de guarda. <br><br>  Substitua o texto do fechamento por este: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greetingMaker: () -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"No greeting available."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(self.who)."</span></span> }</code> </pre><br>  A declaração de guarda designa o eu retirado do eu fraco.  Se self for nulo, o fechamento retornará "Nenhuma saudação disponível".  Caso contrário, o eu se torna uma referência forte, de modo que o objeto é garantido até o final do fechamento. <br><br><h2>  Procurando loops de link no Xcode 10 </h2><br>  Agora que você entende como o ARC funciona, o que são loops de link e como quebrá-los, é hora de ver um exemplo de aplicativo real. <br><br>  Abra o projeto Starter localizado na pasta Contatos. <br><br>  Inicie o aplicativo. <br><br><img src="https://habrastorage.org/webt/a8/ce/l1/a8cel1rgbdkm_fel_d880f2swf4.png"><br><br>  Este é o gerenciador de contatos mais simples.  Tente clicar em um contato, adicione alguns novos. <br><br>  Atribuição de arquivo: <br><br>  ContactsTableViewController: mostra todos os contatos. <br>  DetailViewController: mostra as informações detalhadas do contato selecionado. <br>  NewContactViewController: permite adicionar um novo contato. <br>  ContactTableViewCell: célula da tabela mostrando detalhes do contato. <br>  Contato: modelo de contato. <br>  Número: modelo de número de telefone. <br><br>  No entanto, com este projeto, tudo está ruim: há um ciclo de links.  No início, os usuários não perceberão problemas devido ao pequeno tamanho da memória que vazou, pelo mesmo motivo que é difícil encontrar o vazamento. <br><br>  Felizmente, o Xcode 10 possui ferramentas integradas para encontrar o menor vazamento de memória. <br><br>  Inicie o aplicativo novamente.  Exclua 3-4 contatos usando o furto à esquerda e o botão excluir.  Parece que eles desaparecem completamente, certo? <br><br><img src="https://habrastorage.org/webt/xu/d9/qf/xud9qf3rcyaf5ot_08l8vauizto.png"><br><br><h2>  Para onde flui? </h2><br>  Quando o aplicativo estiver em execução, clique no botão Debug Memory Graph: <br><br><img src="https://habrastorage.org/webt/la/na/km/lanakmzc0d2ousrcf5jwkpu-ova.png"><br><br>  Observe os problemas de tempo de execução no navegador Debug.  Eles são marcados com quadrados roxos com um ponto de exclamação branco dentro: <br><br><img src="https://habrastorage.org/webt/uc/ko/vj/uckovjp_eqoplopih79xuz1jl7e.png"><br><br>  Selecione um dos objetos de contato problemáticos no navegador.  O ciclo é claramente visível: os objetos Contato e Número, referindo-se um ao outro, permanecem. <br><br><img src="https://habrastorage.org/webt/7f/wi/os/7fwios8n7zdk4ww7bj81p4kvgle.png"><br><br>  Parece que você deve procurar no código.  Lembre-se de que um contato pode existir sem um número, mas não vice-versa. <br><br>  Como você resolveria esse loop?  Link de contato para número ou de número para contato?  fraco ou sem dono?  Tente você mesmo primeiro! <br><br><div class="spoiler">  <b class="spoiler_title">Se você precisasse de ajuda ...</b> <div class="spoiler_text">  Existem 2 soluções possíveis: faça um link de Contato para Número fraco ou de Número para Contato sem dono. <br><br>  A documentação da Apple recomenda que o objeto pai tenha uma forte referência a "filho" - e não vice-versa.  Isso significa que damos ao Contato uma forte referência ao Número e Número - um link não proprietário para o Contato: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contact: <span class="hljs-type"><span class="hljs-type">Contact</span></span> <span class="hljs-comment"><span class="hljs-comment">// Other code... } class Contact { var number: Number? // Other code... }</span></span></code> </pre> <br></div></div><br><h2>  Bônus: loops com tipos de referência e tipos de valor. </h2><br>  Swift tem tipos de referência (classes e fechamentos) e tipos de valor (estruturas, enumerações).  O tipo de valor é copiado quando é passado e os tipos de referência compartilham o mesmo valor usando o link. <br><br>  Isso significa que, no caso de tipos de valor, não pode haver ciclos.  Para que um loop ocorra, precisamos de pelo menos 2 tipos de referência. <br><br>  Vamos voltar ao projeto Cycles e adicionar esse código no final do MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Error var payload = 0 var next: Node? }</span></span></code> </pre><br>  Não vai funcionar!  Estrutura é um tipo de valor e não pode ter recursão em uma instância de si mesma.  Caso contrário, essa estrutura teria tamanho infinito. <br><br>  Mude a estrutura para uma classe. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> payload = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  A referência a si mesma é bastante aceitável para classes (tipo de referência), portanto, o compilador não tem problemas. <br><br>  Agora adicione isso no final do MainViewController.swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Person</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"New person instance: \(name)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">deinit</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Person instance \(name) is being deallocated"</span></span>) } }</code> </pre> <br>  E isso é no final do runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(bert) <span class="hljs-comment"><span class="hljs-comment">// Not deallocated bert.friends.append(ernie) // Not deallocated }</span></span></code> </pre><br>  Inicie o aplicativo.  Observe: nem ernie nem bert são liberados. <br><br><h2>  Link e significado </h2><br>  Este é um exemplo de uma combinação de um tipo de referência e um tipo de valor que levou a um loop de links. <br><br>  ernie e bert permanecem inéditos, mantendo-se nas matrizes de seus amigos, embora as matrizes sejam tipos de valor. <br><br>  Tente fazer com que os amigos arquivem como sem dono, e o Xcode mostrará um erro: sem dono se aplica apenas a classes. <br><br>  Para corrigir esse loop, precisamos criar um objeto wrapper e usá-lo para adicionar instâncias ao array. <br><br>  Adicione a seguinte definição antes da classe Person: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unowned</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyObject</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> (<span class="hljs-number"><span class="hljs-number">_</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } }</code> </pre><br>  Altere a definição de amigos na classe Person: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends: [<span class="hljs-type"><span class="hljs-type">Unowned</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Person</span></span>&gt;] = []</code> </pre> <br>  Por fim, substitua o conteúdo do bloco do em runScenario (): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ernie = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Ernie"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bert = <span class="hljs-type"><span class="hljs-type">Person</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Bert"</span></span>) ernie.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(bert)) bert.friends.append(<span class="hljs-type"><span class="hljs-type">Unowned</span></span>(ernie)) }</code> </pre> <br>  Inicie o aplicativo, agora ernie e bert foram lançados corretamente! <br><br>  A matriz de amigos não é mais uma coleção de objetos Pessoa.  Agora, essa é uma <b>coleção de objetos não proprietários</b> que servem como wrappers para instâncias de Person. <br><br>  Para obter objetos Person de Unowned, use a propriedade value: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstFriend = bert.friends.first?.value <span class="hljs-comment"><span class="hljs-comment">// get ernie</span></span></code> </pre> <br><h2>  Conclusão </h2><br>  Agora você tem um bom entendimento do gerenciamento de memória no Swift e sabe como o ARC funciona.  Espero que a publicação tenha sido útil para você. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Apple: contagem automática de referência</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451130/">https://habr.com/ru/post/pt451130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451116/index.html">Como lutei com a transição de elemento compartilhado e escrevi minha primeira biblioteca de código-fonte aberto</a></li>
<li><a href="../pt451118/index.html">O teste não é para iniciantes</a></li>
<li><a href="../pt451120/index.html">Sobre os desafios de transportar células mortas para plataformas móveis</a></li>
<li><a href="../pt451124/index.html">Desenvolvimento de proteínas na nuvem usando Python e Transcriptic ou Como criar qualquer proteína por US $ 360</a></li>
<li><a href="../pt451126/index.html">Caixa de ferramentas para pesquisadores - Edição um: Auto-organização e visualização de dados</a></li>
<li><a href="../pt451132/index.html">Contratos orientados ao consumidor ou automação de teste de controle de qualidade com base no Gitlab CI</a></li>
<li><a href="../pt451138/index.html">Symfony CLI - Nova ferramenta de desenvolvimento local</a></li>
<li><a href="../pt451140/index.html">Quanto custa criar uma solução de IoT?</a></li>
<li><a href="../pt451144/index.html">Antiguidades: Técnica em publicidade na TV</a></li>
<li><a href="../pt451146/index.html">Acelerando a criação de aplicativos da web com o webpack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>