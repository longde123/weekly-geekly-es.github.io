<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍✈️ 👨‍👦‍👦 🤽🏾 Immersion en développement sur Ethereum. Partie 5: Oraclize 👂🏿 👧 🛅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'accès à des fichiers volumineux et à diverses données dynamiques externes est souvent une partie très importante d'une application décentralisée. Da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Immersion en développement sur Ethereum. Partie 5: Oraclize</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417681/">  L'accès à des fichiers volumineux et à diverses données dynamiques externes est souvent une partie très importante d'une application décentralisée.  Dans le même temps, Ethereum lui-même ne fournit pas de mécanisme pour se tourner vers l'extérieur - les contrats intelligents ne peuvent être lus et écrits que dans la blockchain elle-même.  Dans cet article, nous considérerons Oraclize, qui permet simplement d'interagir avec le monde extérieur en interrogeant presque toutes les ressources Internet.  Un sujet connexe est IPFS, et mentionnez-le brièvement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sp/_k/1m/sp_k1m_ob9-qh3_yiiyhmtecypu.jpeg"></div><br><a name="habracut"></a><br><h2>  IPFS </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IPFS</a> est un système de fichiers distribué avec adressage de contenu.  Cela signifie que pour le contenu de tout fichier qui y est ajouté, un hachage unique est pris en compte.  Le même hachage est ensuite utilisé pour rechercher et récupérer ce contenu à partir du réseau. <br>  Les informations de base ont déjà été décrites dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> et dans plusieurs autres, nous ne voyons donc aucune raison de répéter. <br><br><h3>  Pourquoi utiliser IPFS en conjonction avec Ethereum? </h3><br>  Sauvegarder tout contenu de volume sur la blockchain est trop cher et dangereux pour le réseau.  Par conséquent, la meilleure option consiste à enregistrer une sorte de lien vers le fichier situé dans le stockage hors chaîne, pas nécessairement IPFS.  Mais IPFS présente un certain nombre d'avantages: <br><br><ul><li>  Un lien de fichier est un hachage qui est unique au contenu spécifique du fichier, donc si nous mettons ce hachage sur la blockchain, nous pouvons être sûrs que le fichier reçu est celui qui a été ajouté à l'origine, le fichier ne peut pas être remplacé </li><li>  Le système distribué assure contre l'indisponibilité d'un serveur spécifique (en raison d'un blocage ou pour d'autres raisons) </li><li>  Le lien vers le fichier et la confirmation de hachage sont combinés sur une seule ligne, ce qui signifie que vous pouvez écrire moins sur la blockchain et économiser du gaz </li></ul><br>  Parmi les lacunes, on peut mentionner que puisqu'il n'y a pas de serveur central, alors pour l'accessibilité des fichiers il faut qu'au moins un fichier soit «distribué».  Mais si vous avez un fichier spécifique, la connexion aux distributeurs est facile - démarrez votre démon ipfs et ajoutez le fichier via <code>ipfs add</code> . <br><br>  La technologie est très adaptée à l'idéologie de la décentralisation, par conséquent, en considérant Oraclize maintenant, nous rencontrerons souvent l'utilisation d'IPFS dans différents mécanismes oracle. <br><br><h2>  Oraclize </h2><br>  Pour effectuer presque tous les travaux utiles, un contrat intelligent doit recevoir de nouvelles données.  Cependant, il n'y a pas de capacité intégrée pour répondre à une demande de la blockchain au monde extérieur.  Bien sûr, vous pouvez ajouter manuellement tout ce qui est requis par les transactions, mais il est impossible de vérifier d'où proviennent ces données et leur fiabilité.  De plus, vous devrez peut-être organiser une infrastructure supplémentaire pour mettre à jour rapidement les données dynamiques, telles que les taux de change.  Et les mises à jour à intervalle fixe entraîneront des dépassements de gaz. <br><br>  Par conséquent, le service fourni par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Oraclize</a> est pratique: dans un contrat intelligent, vous pouvez envoyer une demande à presque n'importe quelle API ou ressource sur Internet, assurez-vous que les données reçues de la ressource spécifiée sont inchangées et utilisez le résultat dans le même contrat intelligent. <br><br>  Oraclize n'est pas seulement un service Ethereum, des fonctionnalités similaires sont fournies à d'autres blockchains, mais nous ne décrirons le bundle qu'avec Ethereum. <br><br><h3>  Pour commencer </h3><br>  Tout ce qui est nécessaire pour commencer est d'ajouter l'un des fichiers oraclizeAPI du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel</a> au projet.  Il vous suffit de choisir celui qui convient à votre version du compilateur (solc): oraclizeAPI_0.5.sol pour les versions à partir de 0.4.18, oraclizeAPI_0.4.sol pour les versions à partir de 0.4.1, oraclizeAPI_pre0.4.sol pour tout ce qui est plus ancien, support Cette version a déjà été abandonnée.  Si vous utilisez la truffe, n'oubliez pas de renommer le fichier à l'aide d'Oraclize - cela nécessite que le nom du fichier et le contrat correspondent. <br><br>  En incluant le fichier approprié dans votre projet, vous <code>usingOraclize</code> le contrat de l' <code>usingOraclize</code> d' <code>usingOraclize</code> .  Et vous pouvez commencer à utiliser Oracle, ce qui se résume à deux choses principales: envoyer une demande à l'aide de l'assistant <code>oraclize_query</code> , puis traiter le résultat dans la fonction <code>__callback</code> .  Le contrat intelligent le plus simple (pour obtenir le prix actuel du temps d'antenne en dollars) pourrait ressembler à ceci: <br><br><pre> <code class="javascript hljs">pragma solidity <span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./usingOraclize.sol"</span></span>; contract ExampleContract is usingOraclize { string public ETHUSD; event updatedPrice(string price); event newOraclizeQuery(string description); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleContract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ updatePrice(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (msg.sender == oraclize_cbAddress()); ETHUSD = result; updatedPrice(result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePrice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oraclize_getPrice(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>) &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance) { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was sent, standing by for the answer.."</span></span>); oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>); } } }</code> </pre> <br>  La fonction qui envoie la demande est <code>updatePrice</code> .  Vous pouvez voir qu'en premier lieu, il est vérifié que <code>oraclize_getPrice(“URL”)</code> supérieur au solde actuel du contrat.  En effet, l'appel <code>oraclize_query</code> doit être payé, le prix est calculé comme la somme de la commission fixe et du paiement de gaz pour appeler le rappel.  <code>“URL”</code> est une désignation d'un des types de sources de données, dans ce cas, il s'agit d'une simple demande via https, puis nous considérerons d'autres options.  Les réponses sur demande peuvent être analysées à l'avance en json (comme dans l'exemple) et de plusieurs autres manières (nous examinerons plus loin).  Une ligne de <code>__callback</code> est retournée dans <code>__callback</code> .  Au tout début, il est vérifié que l'appel passé depuis l'adresse de confiance oraclize <br><br>  Toutes les options pour utiliser oraclize sont construites selon un schéma, seules les sources de données et la possibilité d'ajouter une authentification à <code>__callback</code> .  Par conséquent, dans les exemples futurs, nous ne citerons que des différences importantes. <br><br><h3>  Utiliser le prix </h3><br>  Comme déjà mentionné, de l'éther supplémentaire est payé pour les demandes oraclize, et il est retiré du solde du contrat, et non de l'adresse d'appel.  Une exception est seulement la première demande de chaque nouveau contrat, elle est fournie gratuitement.  Il est également intéressant de noter que les mêmes mécanismes sont conservés dans les réseaux de test, mais le paiement est effectué en diffusant le réseau correspondant, c'est-à-dire que dans les demandes de testnet sont pratiquement gratuites. <br><br>  Il a déjà été mentionné que le prix demandé se compose de deux valeurs: une commission fixe et le paiement d'un rappel de gaz.  Une commission fixe est définie en dollars et le montant de l'éther est calculé à partir du taux actuel.  La commission dépend de la source des données et des mécanismes de soutien supplémentaires, sur lesquels nous nous attarderons.  Le tableau des prix actuel ressemble à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/w2/xv/d9w2xvqkoi2laplioqc377xydxm.png"></div><br>  Comme vous pouvez le voir, le prix par demande d'URL est de plusieurs cents.  Est-ce beaucoup ou peu?  Pour ce faire, considérons combien coûte la deuxième partie - les frais de gaz de rappel. <br>  Cela fonctionne selon le schéma suivant: la quantité d'éther nécessaire pour payer une quantité fixe de gaz à un prix fixe est transférée à l'avance avec la demande du contrat.  Ce montant devrait être suffisant pour effectuer un rappel, et le prix devrait être adapté au marché, sinon la transaction ne se fera pas ou se bloquera très longtemps.  Dans le même temps, il est clair qu'il n'est pas toujours possible de connaître la quantité de gaz à l'avance, par conséquent, la planche doit également être en réserve (la réserve n'est pas restituée).  Les valeurs par défaut sont une limite de 200 000 gaz au prix de 20 gwei.  Cela suffit pour un rappel moyen avec plusieurs entrées et une sorte de logique.  Et le prix de 20 gwei, bien qu'il puisse sembler trop élevé pour le moment (au moment de la rédaction, la moyenne est de 4 gwei), mais au moment de l'afflux de transactions, le prix du marché peut soudainement sauter et être encore plus élevé, donc en général, ces valeurs sont proches de celles réellement utilisées.  Ainsi, avec de telles valeurs et le prix de l'air dans la région de 500 $, les paiements de gaz approcheront 2 $, nous pouvons donc dire qu'une commission fixe prend une petite partie. <br><br>  Si vous savez ce que vous faites, il existe une option pour modifier la limite et le prix du gaz, économisant ainsi considérablement sur les demandes. <br><br>  Le prix du gaz peut être défini par une fonction distincte - <code>oraclize_setCustomGasPrice(&lt;  wei&gt;)</code> .  Après l'appel, le prix est enregistré et utilisé dans toutes les demandes suivantes. <br>  La limite peut être définie dans la requête <code>oraclize_query</code> - <code>oraclize_query</code> , en la spécifiant avec le dernier argument, par exemple comme ceci: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span>);</code> </pre> <br>  Si vous avez une logique complexe dans <code>__callback</code> et que le gaz est consommé plus de 200k, alors vous devrez certainement définir une limite qui couvre le pire des cas de consommation de gaz.  Sinon, si la limite est dépassée, <code>__callback</code> simplement <code>__callback</code> . <br><br>  Soit dit en passant, oraclize a récemment obtenu des informations que vous pouvez payer pour des demandes en dehors de la blockchain, ce qui vous permettra de ne pas dépenser la totalité de la limite ou de retourner le solde (et le paiement ne provient pas du contrat).  Nous n'avons pas encore eu à l'utiliser, mais oraclize propose de les contacter à info@oraclize.it, si cette option est intéressante.  Par conséquent, gardez à l'esprit. <br><br><h3>  Comment ça marche </h3><br>  Pourquoi, ayant hérité d'un contrat intelligent régulier, obtenons-nous des fonctionnalités qui n'étaient pas initialement prises en charge par les mécanismes de la chaîne de blocs?  En fait, le service Oracle ne consiste pas seulement en contrats avec des fonctions d'assistance.  Le principal travail d'obtention des données est effectué par un service externe.  Les contrats intelligents forment des applications pour accéder aux données externes et les mettent sur la blockchain.  Service externe - surveille les nouveaux blocs de la blockchain et s'il détecte une application - l'exécute.  Schématiquement, cela peut être représenté comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/th/b0/ka/thb0kan1hwm75ijixmdrqtiwvum.png"></div><br><h3>  Sources de données </h3><br>  En plus de l' <code>URL</code> considérée, oraclize propose 4 autres options (que vous avez vues dans la section sur les prix): <code>WolframAlpha</code> , <code>IPFS</code> , <code>random</code> et <code>computation</code> .  Examinons chacun d'eux. <br><br><h4>  1. URL </h4><br>  L'exemple déjà discuté utilise cette source de données.  Il s'agit de la source des requêtes HTTP vers diverses API.  L'exemple était le suivant: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>);</code> </pre> <br>  C'est le prix de l'éther, et comme api fournit une chaîne json avec un ensemble de données, la demande est enveloppée dans un analyseur json et retourne uniquement le champ dont nous avons besoin.  Dans ce cas, il s'agit de GET, mais l'URL source prend également en charge les requêtes POST.  Le type de demande est automatiquement déterminé par un argument supplémentaire.  S'il y a un json valide comme dans cet exemple: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://shapeshift.io/sendamount).success.deposit"</span></span>, <span class="hljs-string"><span class="hljs-string">'{"pair":"eth_btc","amount":"1","withdrawal":"1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}'</span></span>)</code> </pre> <br>  puis la demande est traitée comme POST (l'api utilisée est décrite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , si vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">êtes</a> intéressé) <br><br><h4>  2. WolframAlpha </h4><br>  Cette source de données vous permet d'accéder au service <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WolframAlpha</a> , qui peut fournir des réponses à diverses demandes de faits ou de calculs, par exemple <br><br><pre> <code class="javascript hljs">oraclize_query(“WolframAlpha”, “president <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Russia”)</code> </pre> <br>  retournera <code>Vladimir Putin</code> , et demander <br><br><pre> <code class="javascript hljs">oraclize_query(“WolframAlpha”, “solve x^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span>”)</code> </pre> <br>  renverra <code>x = 2</code> . <br>  Comme vous pouvez le voir, le résultat a été incomplet car le symbole ± a été perdu.  Par conséquent, avant d'utiliser cette source, vous devez vérifier que la valeur d'une demande spécifique peut être utilisée dans un contrat intelligent.  De plus, l'authentification n'est pas prise en charge pour les réponses. Par conséquent, oraclize lui-même recommande que cette source soit utilisée uniquement pour les tests. <br><br><h4>  3. IPFS </h4><br>  Comme vous pouvez le deviner, il vous permet de récupérer le contenu d'un fichier dans IPFS à l'aide d'un multi-hachage.  Le délai de réception du contenu est de 20 secondes. <br><br><pre> <code class="javascript hljs">oraclize_query(“IPFS”, “QmTL5xNq9PPmwvM1RhxuhiYqoTJcmnaztMz6PQpGxmALkP”)</code> </pre> <br>  reviendra <code>Hello, Habr!</code>  (si le fichier avec ce contenu est toujours disponible) <br><br><h4>  4. aléatoire </h4><br>  La génération de nombres aléatoires fonctionne de la même manière que les autres sources, mais si vous utilisez <code>oraclize_query</code> , la préparation des arguments prend du temps.  Pour éviter cela, vous pouvez utiliser la <code>oraclize_newRandomDSQuery(delay, nbytes, customGasLimit)</code> assistance <code>oraclize_newRandomDSQuery(delay, nbytes, customGasLimit)</code> , en définissant uniquement le délai d'exécution (en secondes), le nombre d'octets générés et la limite de gaz pour appeler <code>__callback</code> . <br>  L'utilisation de <code>random</code> a quelques éléments à garder à l'esprit: <br><br><ul><li>  Pour confirmer que le nombre est réellement aléatoire, un type spécial de vérification est utilisé - Ledger, qui peut être effectué sur la blockchain (contrairement à tout le monde, mais plus à ce sujet plus tard).  Cela signifie que dans le constructeur du contrat intelligent, vous devez définir cette méthode de vérification par la fonction: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_Ledger);</code> </pre> <br>  Et au début du rappel, il devrait y avoir un contrôle lui-même: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 _queryId, string _result, bytes _proof</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) == <span class="hljs-number"><span class="hljs-number">0</span></span>) ); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  Cette vérification nécessite un vrai réseau et ne fonctionnera pas sur la ganache, donc pour les tests locaux, vous pouvez supprimer temporairement cette ligne.  Soit dit en passant, le troisième argument de <code>__callback</code> est le paramètre <code>_proof</code> facultatif.  Il est toujours requis lorsque l'un des types de confirmation est utilisé. </li><li>  Si vous utilisez un nombre aléatoire pour les moments critiques, par exemple, pour déterminer le gagnant de la loterie, capturez les entrées des utilisateurs avant d'envoyer newRandomDSQuery.  Sinon, cette situation peut se produire: oraclize appelle _callback et la transaction est visible par tous dans la liste en attente.  Parallèlement à cela, le nombre aléatoire lui-même est visible.  Si les utilisateurs peuvent continuer, grosso modo, à faire des paris, ils pourront alors spécifier un prix du gaz plus élevé et pousser leur taux avant que _callback ne soit exécuté, sachant à l'avance qu'il gagnera. </li></ul><br><br><h4>  5. calcul </h4><br>  C'est la plus flexible des sources.  Il vous permet d'écrire vos propres scripts et de les utiliser comme source de données.  L'informatique a lieu sur AWS.  Pour l'exécution, vous devez décrire le Dockerfile et le mettre ensemble avec des fichiers supplémentaires arbitraires dans une archive zip, et télécharger l'archive dans IPFS.  La mise en œuvre doit remplir les conditions suivantes: <br><br><ul><li>  Écrivez la réponse que vous souhaitez retourner avec la dernière ligne dans stdout </li><li>  La réponse ne doit pas dépasser 2500 caractères </li><li>  L'initialisation et l'exécution ne devraient pas prendre plus de 5 minutes au total </li></ul><br>  Pour un exemple de la façon dont cela est fait, nous verrons comment effectuer l'union la plus simple des lignes transmises et renvoyer le résultat. <br><br>  Dockerfile: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 MAINTAINER <span class="hljs-string"><span class="hljs-string">"info@rubyruby.ru"</span></span> CMD <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG0</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG1</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG2</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG3</span></span></span><span class="hljs-string">"</span></span></code> </pre><br>  Variables d'environnement <code>ARG0</code> , <code>ARG1</code> , etc.  - Ce sont les paramètres transmis avec la demande. <br>  Ajoutez le dockerfile à l'archive, démarrez le serveur ipfs et ajoutez cette archive là <br><br><pre> <code class="bash hljs">$ zip concatenation.zip Dockerfile $ ipfs daemon &amp; $ ipfs add concatenation.zip QmWbnw4BBFDsh7yTXhZaTGQnPVCNY9ZDuPBoSwB9A4JNJD</code> </pre> <br>  Nous utilisons le hachage résultant pour envoyer la demande via <code>oraclize_query</code> dans le contrat intelligent: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"computation"</span></span>, [<span class="hljs-string"><span class="hljs-string">"QmVAS9TNKGqV49WTEWv55aMCTNyfd4qcGFFfgyz7BYHLdD"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s2"</span></span>, <span class="hljs-string"><span class="hljs-string">"s3"</span></span>, <span class="hljs-string"><span class="hljs-string">"s4"</span></span>]);</code> </pre> <br>  Un tableau est utilisé comme argument, dans lequel le premier élément est l'archive multihash, et tous les autres sont les paramètres qui tombent dans les variables d'environnement. <br><br>  Si vous attendez la fin de la demande, <code>__callback</code> résultat <code>s1 s2 s3 s4</code> . <br><br><h3>  Assistants et sous-requêtes de l'analyseur </h3><br>  À partir de la réponse retournée par n'importe quelle source, vous pouvez présélectionner uniquement les informations requises à l'aide d'un certain nombre d'aides, telles que: <br><br><h4>  1. Analyseur JSON </h4><br>  Vous avez vu cette méthode dans le tout premier exemple, où seul le prix a été retourné à partir du résultat renvoyé par coinmarketcap: <br><br><pre> <code class="bash hljs">json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd</code> </pre> <br>  Le cas d'utilisation est assez évident, renvoyant par exemple: <br><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"symbol"</span></span>: <span class="hljs-string"><span class="hljs-string">"ETH"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rank"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"462.857"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_btc"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0621573"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"24h_volume_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"1993200000.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"market_cap_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"46656433775.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"available_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"total_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_supply"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_1h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-0.5"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_24h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-3.02"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_7d"</span></span>: <span class="hljs-string"><span class="hljs-string">"5.93"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last_updated"</span></span>: <span class="hljs-string"><span class="hljs-string">"1532064934"</span></span> } ]</code> </pre> <br>  Puisqu'il s'agit d'un tableau, nous prenons l'élément <code>0</code> , et de lui - le champ <code>price_usd</code> <br><br><h4>  2. XML </h4><br>  L'utilisation est similaire à JSON, par exemple: <br><br><pre> <code class="bash hljs">xml(https://informer.kovalut.ru/webmaster/getxml.php?kod=7701).Exchange_Rates.Central_Bank_RF.USD.New.Exch_Rate</code> </pre> <br><h4>  3. HTML </h4><br>  Vous pouvez analyser XHTML à l'aide de XPath.  Par exemple, obtenez une capitalisation boursière avec etherscan: <br><br><pre> <code class="bash hljs">html(https://etherscan.io/).xpath(string(//*[contains(@href, <span class="hljs-string"><span class="hljs-string">'/stat/supply'</span></span>)]/font))</code> </pre> <br>  <code>MARKET CAP OF $46.148 BillionB</code> <br><br><h4>  4. Aide binaire </h4><br>  Vous permet de couper des pièces à partir de données brutes à l'aide de la fonction tranche (décalage, longueur).  Autrement dit, nous avons un fichier avec le contenu de "abc": <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"abc"</span></span> &gt; example.bin</code> </pre> <br>  Mettez-le sur IPFS: <br><br><pre> <code class="bash hljs">$ ipfs add example.bin added Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE</code> </pre> <br>  Coupez maintenant 1 caractère du milieu: <br><br><pre> <code class="javascript hljs">binary(Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE).slice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Dans la réponse, nous obtenons <code>b</code> <br><br>  Comme vous l'avez peut-être remarqué, dans le cas de l'assistant binaire, ce n'est pas la source IP qui a été utilisée, mais IPFS.  En fait, les analyseurs peuvent être appliqués à toutes les sources, disons qu'il n'est pas nécessaire d'appliquer JSON à ce qui renvoie l'URL, vous pouvez ajouter un tel contenu au fichier: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"one"</span></span>:<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"two"</span></span>:<span class="hljs-string"><span class="hljs-string">"2"</span></span> }</code> </pre> <br>  Ajoutez-le à IPFS: <br><br><pre> <code class="bash hljs">$ ipfs add test.json added QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp</code> </pre> <br>  Et puis démontez comme ceci: <br><br><pre> <code class="bash hljs">json(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one</code> </pre> <br>  Nous obtenons <code>1</code> <br><br>  Et un cas d'utilisation particulièrement intéressant consiste à combiner toutes les sources de données et tous les analyseurs en une seule demande.  Cela est possible à l'aide d'une source de données <code>nested</code> distincte.  Nous utilisons le fichier que nous venons de créer dans une requête plus complexe (ajout de valeurs dans deux champs): <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">WolframAlpha</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">IPFS</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">json</span></span></span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one} to <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">IPFS</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">json</span></span></span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).two}</code> </pre> <br>  Nous obtenons <code>3</code> <br>  La demande est formée comme suit: spécifiez la source de données <code>nested</code> , puis pour chaque demande, ajoutez le nom de la source devant elle entre crochets et encadrez en outre toutes les sous-requêtes dans <code>${..}</code> . <br><br><h3>  Test </h3><br>  Oraclize fournit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">service de</a> validation de requête <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utile</a> sans avoir besoin de contrats intelligents.  Entrez simplement, choisissez une source de données, une méthode de vérification et vous pouvez voir qu'elle reviendra à __callback si vous envoyez les demandes correspondantes <br><br>  Pour une vérification locale en conjonction avec un contrat intelligent, vous pouvez utiliser une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version spéciale de l'EDI Remix</a> qui prend en charge les demandes oraclize. <br><br>  Et pour vérifier localement avec la ganache, vous aurez besoin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du pont ethereum</a> , qui déploiera ou activera les contrats intelligents sur votre testnet.  Pour les tests, ajoutez d'abord la ligne suivante au constructeur de votre contrat: <br><br><pre> <code class="javascript hljs">OAR = OraclizeAddrResolverI(<span class="hljs-number"><span class="hljs-number">0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475</span></span>);</code> </pre> <br>  courir <br><br><pre> <code class="bash hljs">ganache-cli</code> </pre> <br>  Alors <br><br><pre> <code class="bash hljs">node bridge --dev</code> </pre> <br>  Attendez que les contrats soient morts et vous pourrez tester.  Dans la sortie du <code>node bridge</code> de <code>node bridge</code> vous pouvez voir les demandes envoyées et les réponses reçues. <br><br>  Une autre aide non seulement lors des tests, mais également lors de l'utilisation réelle est la possibilité de surveiller les demandes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Si vous faites une demande sur un réseau public, vous pouvez utiliser le hachage de la transaction dans laquelle la demande est exécutée.  Si vous utilisez l'authentification, gardez à l'esprit qu'ils sont garantis pour être envoyés uniquement au réseau principal, pour les autres réseaux, il peut retourner 0. Si la demande était sur le réseau local, vous pouvez utiliser l'ID de la demande, qui renvoie <code>oraclize_query</code> .  Soit dit en passant, il est recommandé de toujours conserver cet identifiant, par exemple, dans un mappage similaire: <br><br><pre> <code class="javascript hljs">mapping(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32</span></span></span><span class="hljs-function">=&gt;</span></span>bool) validIds;</code> </pre> <br>  Au moment de la demande, marquez l'ID envoyé comme <code>true</code> : <br><br><pre> <code class="javascript hljs">bytes32 queryId = oraclize_query(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">); validIds[queryId] = true;</span></span></code> </pre><br>  Et puis dans <code>__callback</code> vérifiez que la demande avec cet identifiant n'a pas encore été traitée: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(validIds[myid] != bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(msg.sender == oraclize_cbAddress()); validIds[myid] = bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Cela est nécessaire car <code>__callback</code> sur une demande peut être appelée plus d'une fois en raison des particularités des mécanismes Oraclize. <br><br><h3>  Authentification </h3><br>  Dans le tableau avec les sources, vous pouvez voir que différentes sources peuvent prendre en charge différents types de confirmations et que des frais différents peuvent être facturés.  C'est une partie très importante d'Oraclize, mais une description détaillée de ces mécanismes est un sujet distinct. <br><br>  Le mécanisme le plus couramment utilisé, au moins par nous, est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TLSNotary</a> avec stockage dans IPFS.  Le stockage dans IPFS est plus efficace car <code>__callback</code> ne <code>__callback</code> pas la preuve elle-même (peut-être de l'ordre de 4 à 5 kilo-octets), mais un multi-hachage beaucoup plus petit.  Pour spécifier ce type, ajoutez une ligne dans le constructeur: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);</code> </pre> <br>  Nous pouvons seulement dire que ce type, en gros, nous protège de l'inexactitude des données reçues d'Oraclize.  Mais Oraclize utilise des serveurs Amazon, qui agissent en tant qu'auditeur, ils n'ont donc qu'à faire confiance. <br><br>  Lisez plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Conclusion </h2><br>  Oraclize fournit des outils qui augmentent considérablement le nombre de cas d'utilisation pour les contrats intelligents, ainsi que IPFS, qui peuvent être vus dans plusieurs versions des requêtes Oracle.  Le principal problème est que nous utilisons à nouveau des données externes soumises aux menaces que la blockchain aurait dû protéger: centralisation, capacités de blocage, changements de code, usurpation de contenu.  Mais bien que cela soit inévitable et que l'option d'obtenir des données soit très utile et viable, il vous suffit de savoir pourquoi l'utilisation de la blockchain a été introduite dans le projet et si l'utilisation de sources externes non fiables réduit les avantages à zéro. <br><br>  Si vous êtes intéressé par certains sujets de développement sur Ethereum qui n'ont pas encore été divulgués dans ces articles - écrivez dans les commentaires, nous les couvrirons peut-être ci-dessous. <br><br>  Immersion en développement sur Ethereum: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2: Web3.js et le gaz</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: application utilisateur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4: déployer et déboguer dans la truffe, la ganache, l'infura</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417681/">https://habr.com/ru/post/fr417681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417671/index.html">Nouvelles fonctionnalités du langage de programmation ABAP dans les webinaires de SAP</a></li>
<li><a href="../fr417673/index.html">L'enquête mène à Solar Dozor: 5 cas non standard révélés par DLP</a></li>
<li><a href="../fr417675/index.html">Localisation de jeux et d'applications dans Unity. Rapide et facile</a></li>
<li><a href="../fr417677/index.html">Migration d'un projet de yii1 vers yii2 via un travail unique</a></li>
<li><a href="../fr417679/index.html">L'héritage grave du passé. Problèmes de ligne de commande Windows</a></li>
<li><a href="../fr417683/index.html">Code obsolète - Code tiers</a></li>
<li><a href="../fr417685/index.html">Webinaires Skillbox Friday: continuer à apprendre gratuitement</a></li>
<li><a href="../fr417687/index.html">Asymétrie de vie</a></li>
<li><a href="../fr417689/index.html">Mobio s'entretient avec le PDG d'Appnext sur le marché du CPI et les tendances des applications mobiles</a></li>
<li><a href="../fr417691/index.html">Notre étagère est un programmeur C #. Et vous?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>