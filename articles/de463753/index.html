<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüéì üåÜ ü•í PVS-Studio besucht Apache Hive üíø üë®‚Äçüëß‚Äçüëß üë©üèΩ‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten zehn Jahren war die Open-Source-Bewegung einer der Haupttreiber f√ºr die Entwicklung der IT-Branche und ihre entscheidende Komponente. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio besucht Apache Hive</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463753/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/2d0/eb3/0ad2d0eb30d726eefba9c913edaa346a.png" alt="Abbildung 1"></div><br>  In den letzten zehn Jahren war die Open-Source-Bewegung einer der Haupttreiber f√ºr die Entwicklung der IT-Branche und ihre entscheidende Komponente.  Die Rolle von Open-Source-Projekten wird nicht nur quantitativ, sondern auch qualitativ immer wichtiger, was das Konzept ihrer Positionierung auf dem IT-Markt im Allgemeinen ver√§ndert.  Unser mutiges PVS-Studio-Team sitzt nicht unt√§tig und beteiligt sich aktiv an der St√§rkung der Pr√§senz von Open-Source-Software, indem es versteckte Fehler in den enormen Tiefen der Codebasen findet und den Autoren solcher Projekte kostenlose Lizenzoptionen anbietet.  Dieser Artikel ist nur ein weiterer Teil dieser Aktivit√§t!  Heute werden wir √ºber Apache Hive sprechen.  Ich habe den Bericht - und es gibt Dinge, die es wert sind, angeschaut zu werden. <br><a name="habracut"></a><br><h2>  √úber PVS-Studio </h2><br>  Der statische Code-Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> , den es seit mehr als 10 Jahren gibt, ist eine multifunktionale und einfach zu integrierende Softwarel√∂sung.  Derzeit unterst√ºtzt es C, C ++, C # und Java und l√§uft unter Windows, Linux und MacOS. <br><br>  PVS-Studio ist eine kostenpflichtige B2B-L√∂sung, die von zahlreichen Teams in einer Reihe von Unternehmen eingesetzt wird.  Wenn Sie den Analysator ausprobieren m√∂chten, besuchen Sie diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite</a> , um die Distribution herunterzuladen und einen Testschl√ºssel anzufordern. <br><br>  Wenn Sie ein Open-Source-Geek oder beispielsweise ein Student sind, k√∂nnen Sie eine unserer kostenlosen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lizenzoptionen nutzen</a> . <br><br><h2>  √úber Apache Hive </h2><br>  Die Datenmenge ist in den letzten Jahren enorm gewachsen.  Die Standarddatenbanken k√∂nnen dieses schnelle Wachstum nicht mehr bew√§ltigen. Daher kommt der Begriff Big Data zusammen mit anderen verwandten Begriffen (wie Verarbeitung, Speicherung und anderen Vorg√§ngen mit Big Data). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Hadoop</a> gilt derzeit als eine der wegweisenden Big Data-Technologien.  Die Hauptaufgaben sind das Speichern, Verarbeiten und Verwalten gro√üer Datenmengen.  Die Hauptkomponenten des Frameworks sind Hadoop Common, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HDFS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hadoop MapReduce</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hadoop YARN</a> .  Im Laufe der Zeit hat sich rund um Hadoop ein gro√ües √ñkosystem verwandter Projekte und Technologien entwickelt, von denen viele urspr√ºnglich als Teil des Projekts begannen und sich dann auf den Weg machten, um unabh√§ngig zu werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Hive</a> ist einer von ihnen. <br><br>  Apache Hive ist ein verteiltes Data Warehouse.  Es verwaltet die in HDFS gespeicherten Daten und stellt die auf SQL (HiveQL) basierende Abfragesprache bereit, um diese Daten zu verarbeiten.  Weitere Details zum Projekt finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Ausf√ºhren der Analyse </h2><br>  Es dauerte nicht viel M√ºhe oder Zeit, um die Analyse zu starten.  Hier ist mein Algorithmus: <br><br><ul><li>  Heruntergeladener Apache Hive von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ; </li><li>  Lesen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung</a> zum Starten des Java-Analysators und starten Sie die Analyse. </li><li>  Erhielt den Bericht des Analysators, studierte ihn und schrieb die interessantesten F√§lle auf. </li></ul><br>  Die Analyseergebnisse lauten wie folgt: 1456 Warnungen vor hohen und mittleren Werten (602 bzw. 854) in √ºber 6500 Dateien. <br><br>  Nicht alle Warnungen beziehen sich auf echte Fehler.  Das ist ganz normal;  Sie m√ºssen die Einstellungen des Analysators anpassen, bevor Sie ihn regelm√§√üig verwenden k√∂nnen.  Danach erwarten Sie normalerweise eine relativ geringe Rate an Fehlalarmen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ). <br><br>  Ich habe die 407 Warnungen (177 High- und 230 Medium-Level), die von den Testdateien ausgel√∂st wurden, weggelassen.  Ich habe auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6022-</a> Diagnose ignoriert (da Sie nicht zuverl√§ssig zwischen fehlerhaften und korrekten Fragmenten unterscheiden k√∂nnen, wenn Sie mit dem Code nicht vertraut sind), die bis zu 482 Mal ausgel√∂st wurde.  Ich habe auch nicht die 179 Warnungen untersucht, die von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6021-</a> Diagnose generiert wurden. <br><br>  Am Ende hatte ich immer noch genug Warnungen, und da ich die Einstellungen nicht angepasst habe, gibt es immer noch einen gewissen Prozentsatz an Fehlalarmen.  Es macht einfach keinen Sinn, zu viele Warnungen in einen Artikel wie diesen aufzunehmen :).  Also reden wir nur dar√ºber, was mir aufgefallen ist und neugierig genug ausgesehen hat. <br><br><h2>  Vorgegebene Bedingungen </h2><br>  Unter den f√ºr diese Analyse untersuchten Diagnosen enth√§lt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007</a> einen Datensatz f√ºr die Anzahl der ausgegebenen Warnungen.  Etwas mehr als 200 Nachrichten !!!  Einige sehen harmlos aus, andere sind misstrauisch und andere sind doch echte K√§fer!  Schauen wir uns einige davon an. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007</a> Ausdruck 'key.startsWith ("hplsql.")' Ist immer wahr.  Exec.java (675) <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initOptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == null || value == null || !key.startsWith(<span class="hljs-string"><span class="hljs-string">"hplsql."</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } else if (key.compareToIgnoreCase(Conf.CONN_DEFAULT) == 0) { .... } else if (key.startsWith("hplsql.conn.init.")) { .... } else if (key.startsWith(Conf.CONN_CONVERT)) { .... } else if (key.startsWith("hplsql.conn.")) { .... } else if (key.startsWith("hplsql.")) { // &lt;= .... } }</span></span></code> </pre> <br>  Das ist ein ziemlich langwieriges Wenn-Sonst-Wenn-Konstrukt!  Dem Analysator gef√§llt die Bedingung im letzten <i>if (key.startsWith ("hplsql.")) Nicht.</i> Wenn die Ausf√ºhrung sie erreicht, bedeutet dies, dass sie wahr ist.  Wenn Sie sich die erste Zeile dieses gesamten if-else-if-Konstrukts ansehen, werden Sie <i>feststellen,</i> dass es bereits die entgegengesetzte Pr√ºfung enth√§lt. Wenn die Zeichenfolge also nicht mit <i>"hplsql" beginnt.</i>  Die Ausf√ºhrung springt sofort zur n√§chsten Iteration. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007 Der</a> Ausdruck 'columnNameProperty.length () == 0' ist immer falsch.  OrcRecordUpdater.java (238) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDescription </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTypeDescriptionFromTableProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tableProperties != null) { final String columnNameProperty = ....; final String columnTypeProperty = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !Strings.isNullOrEmpty(columnNameProperty) &amp;&amp; !Strings.isNullOrEmpty(columnTypeProperty)) { List&lt;String&gt; columnNames = columnNameProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;() : ....; List&lt;TypeInfo&gt; columnTypes = columnTypeProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;TypeInfo&gt;() : ....; .... } } } .... }</code> </pre> <br>  Der Vergleich der <i>L√§nge der</i> Zeichenfolge <i>columnNameProperty</i> mit Null gibt immer <i>false zur√ºck</i> .  Dies liegt daran, dass dieser Vergleich der <i>Pr√ºfung! Strings.isNullOrEmpty (columnNameProperty)</i> folgt.  Wenn die Ausf√ºhrung unseren Zustand erreicht, bedeutet dies, dass die Zeichenfolge <i>columnNameProperty</i> sicherlich weder null noch leer ist. <br><br>  Gleiches gilt f√ºr die Zeichenfolge <i>columnTypeProperty</i> eine Zeile sp√§ter: <br><br><ul><li>  V6007 Der Ausdruck 'columnTypeProperty.length () == 0' ist immer falsch.  OrcRecordUpdater.java (239) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007 Der</a> Ausdruck 'colOrScalar1.equals ("Column")' ist immer falsch.  GenVectorCode.java (3469) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDateTimeArithmeticIntervalYearMonth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] tdesc)</span></span></span><span class="hljs-function"> throws Exception </span></span>{ .... String colOrScalar1 = tdesc[<span class="hljs-number"><span class="hljs-number">4</span></span>]; .... String colOrScalar2 = tdesc[<span class="hljs-number"><span class="hljs-number">6</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } else if (colOrScalar1.equals("Col") &amp;&amp; colOrScalar1.equals("Scalar")) { .... } else if (colOrScalar1.equals("Scalar") &amp;&amp; colOrScalar1.equals("Column")) { .... } }</span></span></code> </pre><br>  Das gute alte Copy-Paste.  Aus Sicht der aktuellen Logik kann der String <i>colOrScalar1</i> zwei verschiedene Werte gleichzeitig haben, was unm√∂glich ist.  Offensichtlich sollten die Pr√ºfungen die Variable <i>colOrScalar1</i> links und <i>colOrScalar2</i> rechts haben. <br><br>  √Ñhnliche Warnungen einige Zeilen weiter unten: <br><br><ul><li>  V6007 Der Ausdruck 'colOrScalar1.equals ("Scalar")' ist immer falsch.  GenVectorCode.java (3475) </li><li>  V6007 Der Ausdruck 'colOrScalar1.equals ("Column")' ist immer falsch.  GenVectorCode.java (3486) </li></ul><br>  Infolgedessen wird dieses if-else-if-Konstrukt niemals etwas tun. <br><br>  Noch ein paar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007-</a> Warnungen: <br><br><ul><li>  V6007 Der Ausdruck 'Zeichen == null' ist immer falsch.  RandomTypeUtil.java (43) </li><li>  V6007 Der Ausdruck 'writeIdHwm&gt; 0' ist immer falsch.  TxnHandler.java (1603) </li><li>  V6007 Ausdruck 'fields.equals ("*")' ist immer wahr.  Server.java (983) </li><li>  V6007 Ausdruck 'currentGroups! = Null' ist immer wahr.  GenericUDFCurrentGroups.java (90) </li><li>  V6007 Der Ausdruck 'this.wh == null' ist immer falsch.  New gibt eine Referenz ungleich Null zur√ºck.  StorageBasedAuthorizationProvider.java (93), StorageBasedAuthorizationProvider.java (92) </li><li>  und so weiter ... </li></ul><br><h2>  NPE </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6008</a> M√∂gliche Null-Dereferenzierung von 'dagLock'.  QueryTracker.java (557), QueryTracker.java (553) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleFragmentCompleteExternalQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryInfo queryInfo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryInfo.isExternalQuery()) { ReadWriteLock dagLock = getDagLock(queryInfo.getQueryIdentifier()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dagLock == null) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Ignoring fragment completion for unknown query: {}"</span></span>, queryInfo.getQueryIdentifier()); } boolean locked = dagLock.writeLock().tryLock(); ..... } }</code> </pre> <br>  Ein Null-Objekt wird abgefangen, protokolliert und ... das Programm l√§uft einfach weiter.  Infolgedessen folgt auf die Pr√ºfung eine Nullzeiger-Dereferenzierung.  Autsch! <br><br>  Die Entwickler m√ºssen tats√§chlich gewollt haben, dass das Programm die Funktion beendet oder eine spezielle Ausnahme ausl√∂st, wenn eine Nullreferenz abgerufen wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6008</a> Null-Dereferenzierung von 'Puffer' in der Funktion 'UnlockSingleBuffer'.  MetadataCache.java (410), MetadataCache.java (465) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LlapBufferOrBuffers buffers, ....)</span></span></span><span class="hljs-function"> </span></span>{ LlapAllocatorBuffer buffer = buffers.getSingleLlapBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer != null) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return lockOneBuffer(buffer, doNotifyPolicy); } LlapAllocatorBuffer[] bufferArray = buffers.getMultipleLlapBuffers(); for (int i = 0; i &lt; bufferArray.length; ++i) { if (lockOneBuffer(bufferArray[i], doNotifyPolicy)) continue; for (int j = 0; j &lt; i; ++j) { unlockSingleBuffer(buffer, true); // &lt;= } .... } .... } .... private void unlockSingleBuffer(LlapAllocatorBuffer buffer, ....) { boolean isLastDecref = (buffer.decRef() == 0); // &lt;= if (isLastDecref) { .... } }</span></span></code> </pre> <br>  Ein weiteres potenzielles NPE.  Wenn die Ausf√ºhrung die Methode <i>lockerSingleBuffer</i> erreicht, bedeutet dies, dass das <i>Pufferobjekt</i> null ist.  Angenommen, das ist passiert!  Wenn Sie sich die Methode <i>lockerSingleBuffer ansehen</i> , werden Sie gleich in der ersten Zeile feststellen, wie unser Objekt dereferenziert wird.  Gotcha! <br><br><h2>  Eine wilde Verschiebung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6034 Die</a> Verschiebung um den Wert 'bitShiftsInWord - 1' kann mit der Gr√∂√üe des Typs nicht √ºbereinstimmen: 'bitShiftsInWord - 1' = [-1 ... 30].  UnsignedInt128.java (1791) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, boolean roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } assert (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Dies ist eine m√∂gliche Verschiebung um -1.  Wenn die Methode beispielsweise mit <i>wordShifts == 3</i> und <i>bitShiftsInWord == 0</i> aufgerufen wird, <i>endet</i> die gemeldete Zeile mit 1 &lt;&lt; -1.  Ist das ein geplantes Verhalten? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6034 Die</a> Verschiebung um den Wert 'j' kann mit der Gr√∂√üe des Typs nicht √ºbereinstimmen: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, boolean[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  In der angegebenen Zeile kann die Variable <i>j</i> einen Wert im Bereich [0 ... 63] haben.  Aus diesem Grund kann die Berechnung des Werts von <i>val</i> in der Schleife auf unerwartete Weise ausgef√ºhrt werden.  Im Ausdruck <i>(1 &lt;&lt; j)</i> ist der Wert 1 vom Typ <i>int</i> . Wenn Sie ihn also um 32 Bit und mehr verschieben, √ºberschreiten Sie die Grenzen des Typbereichs.  Dies kann durch Schreiben von <i>((lang) 1 &lt;&lt; j)</i> behoben werden. <br><br><h2>  Sich von der Protokollierung mitrei√üen lassen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6046</a> Falsches Format.  Eine andere Anzahl von Formatelementen wird erwartet.  Nicht verwendete Argumente: 1, 2. StatsSources.java (89) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ImmutableList&lt;PersistedRuntimeStats&gt; extractStatsFromPlanMapper (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stat.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> || sig.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { StringBuffer sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuffer(); sb.append(String.format( <span class="hljs-string"><span class="hljs-string">"expected(stat-sig) 1-1, got {}-{} ;"</span></span>, <span class="hljs-comment"><span class="hljs-comment">// &lt;= stat.size(), sig.size() )); .... } .... if (e.getAll(OperatorStats.IncorrectRuntimeStatsMarker.class).size() &gt; 0) { LOG.debug( "Ignoring {}, marked with OperatorStats.IncorrectRuntimeStatsMarker", sig.get(0) ); continue; } .... }</span></span></code> </pre> <br>  Beim Schreiben des Codes zum Formatieren der Zeichenfolge mit <i>String.format ()</i> hat der Entwickler eine falsche Syntax verwendet.  Infolgedessen haben es die √ºbergebenen Parameter nie in die resultierende Zeichenfolge geschafft.  Ich vermute, dass der Entwickler vor dem Schreiben an der Protokollierung gearbeitet hat, von wo er die Syntax ausgeliehen hat. <br><br><h2>  Eine gestohlene Ausnahme </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6051</a> Die Verwendung der Anweisung 'return' im Block 'finally' kann zum Verlust nicht behandelter Ausnahmen f√ºhren.  ObjectStore.java (9080) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;MPartitionColumnStatistics&gt; getMPartitionColumnStatistics(....) throws NoSuchObjectException, MetaException { boolean committed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex instanceof MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } finally { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  Es ist eine sehr schlechte Praxis, etwas aus dem <i>finally-</i> Block zur√ºckzugeben, und dieses Beispiel zeigt anschaulich, warum. <br><br>  Im <i>try-</i> Block bildet das Programm eine Anforderung und greift auf den Speicher zu.  Die <i>festgeschriebene</i> Variable hat standardm√§√üig den Wert <i>false</i> und √§ndert ihren Status erst, nachdem alle vorherigen Aktionen im <i>try-</i> Block erfolgreich ausgef√ºhrt wurden.  Wenn eine Ausnahme ausgel√∂st wird, ist diese Variable immer <i>falsch</i> .  Der <i>catch-</i> Block f√§ngt die Ausnahme ab, passt sie ein wenig an und wirft sie auf.  Wenn also der <i>finally-</i> Block an der Reihe ist, gibt die Ausf√ºhrung die Bedingung ein, aus der eine leere Liste zur√ºckgegeben wird.  Was kostet uns diese R√ºcksendung?  Nun, es kostet uns zu verhindern, dass eine gefangene Ausnahme nach au√üen geworfen wird, wo sie richtig gehandhabt werden kann.  Keine der in der Signatur der Methode angegebenen Ausnahmen wird jemals ausgel√∂st.  Sie sind einfach irref√ºhrend. <br><br>  Eine √§hnliche Diagnosemeldung: <br><br><ul><li>  V6051 Die Verwendung der Anweisung 'return' im Block 'finally' kann zum Verlust nicht behandelter Ausnahmen f√ºhren.  ObjectStore.java (808) </li></ul><br><h2>  Verschiedenes </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6009 Die</a> Funktion 'compareTo' empf√§ngt ein ungerades Argument.  Ein Objekt 'o2.getWorkerIdentity ()' wird als Argument f√ºr seine eigene Methode verwendet.  LlapFixedRegistryImpl.java (244) <br><br><pre> <code class="cpp hljs">@Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;LlapServiceInstance&gt; getAllInstancesOrdered(....) { .... Collections.sort(<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comparator&lt;LlapServiceInstance&gt;() { @Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compare(LlapServiceInstance o1, LlapServiceInstance o2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o2.getWorkerIdentity().compareTo(o2.getWorkerIdentity()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } }); .... }</span></span></code> </pre> <br>  Es kann eine Reihe von Ursachen geben, die zu solch einem dummen Fehler f√ºhren: Kopieren, Einf√ºgen, Nachl√§ssigkeit, Eile und so weiter.  Wir sehen solche Fehler oft in Open-Source-Projekten und haben sogar einen ganzen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> dar√ºber. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6020</a> Durch Null teilen.  Der Bereich der 'Divisor'-Nennerwerte umfasst Null.  SqlMathUtil.java (265) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divideUnsignedLong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divisor &lt; <span class="hljs-number"><span class="hljs-number">0L</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*some comments*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (compareUnsignedLong(dividend, divisor)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0L</span></span> : <span class="hljs-number"><span class="hljs-number">1L</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dividend &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Both inputs non-negative return dividend / divisor; // &lt;= } else { .... } }</span></span></code> </pre> <br>  Dieser ist ziemlich trivial.  Eine Reihe von √úberpr√ºfungen war hilflos, um die Division durch Null abzuwenden. <br><br>  Noch ein paar Warnungen: <br><br><ul><li>  V6020 Mod um Null.  Der Bereich der 'Divisor'-Nennerwerte umfasst Null.  SqlMathUtil.java (309) </li><li>  V6020 Durch Null teilen.  Der Bereich der 'Divisor'-Nennerwerte umfasst Null.  SqlMathUtil.java (276) </li><li>  V6020 Durch Null teilen.  Der Bereich der 'Divisor'-Nennerwerte umfasst Null.  SqlMathUtil.java (312) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6030</a> Die Methode rechts neben dem '|'  Der Operator wird unabh√§ngig vom Wert des linken Operanden aufgerufen.  Vielleicht ist es besser, '||' zu verwenden.  OperatorUtils.java (573) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Operator&lt;? extends OperatorDesc&gt; findSourceRS(....) { .... List&lt;Operator&lt;? extends OperatorDesc&gt;&gt; parents = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parents == null | parents.isEmpty()) { <span class="hljs-comment"><span class="hljs-comment">// reached end eg TS operator return null; } .... }</span></span></code> </pre> <br>  Der Programmierer hat den bitweisen Operator | geschrieben  anstelle des logischen ||.  Dies bedeutet, dass der rechte Teil ausgef√ºhrt wird, unabh√§ngig vom Ergebnis des linken.  Wenn <i>parent == null ist</i> , wird dieser Tippfehler direkt im n√§chsten logischen Unterausdruck mit einem NPE enden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6042</a> Der Ausdruck wird auf Kompatibilit√§t mit Typ 'A' gepr√ºft, aber in Typ 'B' umgewandelt.  VectorColumnAssignFactory.java (347) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VectorColumnAssign </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildObjectAssign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VectorizedRowBatch outputBatch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outColIndex, PrimitiveCategory category)</span></span></span><span class="hljs-function"> throws HiveException </span></span>{ VectorColumnAssign outVCA = null; ColumnVector destCol = outputBatch.cols[outColIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol instanceof LongColumnVector) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(category) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LONG: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorLongColumnAssign() { .... } .init(.... , (LongColumnVector) destCol); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TIMESTAMP: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorTimestampColumnAssign() { .... }.init(...., (TimestampColumnVector) destCol); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case DATE: outVCA = new VectorLongColumnAssign() { .... } .init(...., (LongColumnVector) destCol); break; case INTERVAL_YEAR_MONTH: outVCA = new VectorLongColumnAssign() { .... }.init(...., (LongColumnVector) destCol); break; case INTERVAL_DAY_TIME: outVCA = new VectorIntervalDayTimeColumnAssign() { .... }.init(...., (IntervalDayTimeColumnVector) destCol);// &lt;= break; default: throw new HiveException(....); } } else if (destCol instanceof DoubleColumnVector) { .... } .... else { throw new HiveException(....); } return outVCA; }</span></span></code> </pre> <br>  Wir interessieren uns f√ºr die Klassen <i>LongColumnVector erweitert ColumnVector</i> und <i>TimestampColumnVector erweitert ColumnVector</i> .  Die √úberpr√ºfung, dass das <i>destCol-</i> Objekt eine Instanz von <i>LongColumnVector ist,</i> legt ausdr√ºcklich nahe, dass es sich um ein Objekt dieser Klasse handelt, das im Hauptteil der bedingten Anweisung behandelt wird.  Trotzdem wird es immer noch in <i>TimestampColumnVector umgewandelt</i> !  Wie Sie sehen k√∂nnen, handelt es sich um verschiedene Klassen, mit der Ausnahme, dass sie von demselben √ºbergeordneten Element abgeleitet sind.  Als Ergebnis erhalten wir eine <i>ClassCastException</i> . <br><br>  Gleiches gilt f√ºr das Casting in <i>IntervalDayTimeColumnVector</i> : <br><br><ul><li>  V6042 Der Ausdruck wird auf Kompatibilit√§t mit Typ 'A' gepr√ºft, aber in Typ 'B' umgewandelt.  VectorColumnAssignFactory.java (390) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6060</a> Die ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">var'</a> -Referenz wurde verwendet, bevor sie gegen null verifiziert wurde.  Var.java (402), Var.java (395) <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getClass() != obj.getClass()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } Var var = (Var)obj; if (this == var) { return true; } else if (var == null || // &lt;= var.value == null || this.value == null) { return false; } .... }</span></span></code> </pre> <br>  Hier sehen Sie eine seltsame √úberpr√ºfung des <i>var-</i> Objekts auf <i>null,</i> nachdem die Dereferenzierung bereits aufgetreten ist.  In diesem Zusammenhang sind <i>var</i> und <i>obj</i> dasselbe Objekt ( <i>var = (Var) obj</i> ).  Das Vorhandensein der <i>Nullpr√ºfung</i> impliziert, dass das √ºbergebene Objekt null sein kann.  Das Aufrufen von <i>equals (null)</i> f√ºhrt also zu einer NPE anstelle der erwarteten <i>false</i> direkt in der ersten Zeile.  Ja, der Scheck <i>ist</i> da, aber leider ist er am falschen Ort. <br><br>  Einige andere √§hnliche F√§lle, in denen ein Objekt vor der Pr√ºfung verwendet wird: <br><br><ul><li>  V6060 Die 'Wert'-Referenz wurde verwendet, bevor sie gegen Null verifiziert wurde.  ParquetRecordReaderWrapper.java (168), ParquetRecordReaderWrapper.java (166) </li><li>  V6060 Die Referenz 'defaultConstraintCols' wurde verwendet, bevor sie gegen null verifiziert wurde.  HiveMetaStore.java (2539), HiveMetaStore.java (2530) </li><li>  V6060 Die Referenz 'projIndxLst' wurde verwendet, bevor sie gegen null verifiziert wurde.  RelOptHiveTable.java (683), RelOptHiveTable.java (682) </li><li>  V6060 Die 'oldp'-Referenz wurde verwendet, bevor sie gegen null verifiziert wurde.  ObjectStore.java (4343), ObjectStore.java (4339) </li><li>  und so weiter ... </li></ul><br><h2>  Fazit </h2><br>  Wenn Sie sich jemals f√ºr Big Data interessiert haben, wenn auch nur ein bisschen, dann k√∂nnen Sie kaum √ºbersehen, wie wichtig Apache Hive ist.  Dies ist ein beliebtes und ziemlich gro√ües Projekt, das aus √ºber 6500 Quelldateien (* .java) besteht.  Viele Entwickler haben es √ºber viele Jahre geschrieben, was bedeutet, dass ein statischer Analysator dort viele Dinge zu finden hat.  Es zeigt nur noch einmal, dass statische Analysen bei der Entwicklung mittlerer und gro√üer Projekte √§u√üerst wichtig und n√ºtzlich sind! <br><br>  Hinweis  Einmalige √úberpr√ºfungen wie die hier durchgef√ºhrte sind gut geeignet, um die F√§higkeiten des Analysators zu demonstrieren, stellen jedoch ein v√∂llig unangemessenes Szenario f√ºr die Verwendung dar.  Diese Idee wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier weiter ausgef√ºhrt</a> .  Die statische Analyse ist regelm√§√üig anzuwenden! <br><br>  Diese √úberpr√ºfung von Hive ergab einige M√§ngel und verd√§chtige Fragmente.  Wenn die Autoren von Apache Hive auf diesen Artikel sto√üen, helfen wir Ihnen gerne bei der schwierigen Aufgabe, das Projekt zu verbessern. <br><br>  Sie k√∂nnen sich Apache Hive ohne Apache Hadoop nicht vorstellen, daher k√∂nnte das Einhorn von PVS-Studio auch diesem einen Besuch abstatten.  Aber das ist alles f√ºr heute.  In der Zwischenzeit lade ich Sie ein, den Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterzuladen</a> und Ihre eigenen Projekte zu √ºberpr√ºfen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463753/">https://habr.com/ru/post/de463753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463741/index.html">Mit Firefox (bereits behoben) und Chrome k√∂nnen Sie den Alt-Svc-Header zum Scannen von Intranet-Ports verwenden</a></li>
<li><a href="../de463745/index.html">C ++ zu komplizieren ist unvermeidlich. Und nicht nur C ++</a></li>
<li><a href="../de463747/index.html">Greifen Sie auf Eigenschaften im Jsonb-Feld f√ºr Npgsql zu</a></li>
<li><a href="../de463749/index.html">Scrum vs Kanban: Bleib ruhig und w√§hle, was besser zu dir passt</a></li>
<li><a href="../de463751/index.html">iOS 13: Was Sie brauchen und was Sie bei der Entwicklung f√ºr ein neues Betriebssystem absolut nicht tun m√ºssen</a></li>
<li><a href="../de463755/index.html">Der Unterschied zwischen "Juni", "Mitte" und "Senior". Und was tun, um eine Ebene h√∂her zu kommen?</a></li>
<li><a href="../de463759/index.html">PVS-Studio besucht Apache Hive</a></li>
<li><a href="../de463761/index.html">PHP Microservice Framework - Swoft</a></li>
<li><a href="../de463763/index.html">Vereinfachen Sie die Migration von OpenShift 3 zu OpenShift 4</a></li>
<li><a href="../de463765/index.html">Slurm DevOps: Warum werden wir die Philosophie von DevOps nicht diskutieren und was wird stattdessen passieren?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>