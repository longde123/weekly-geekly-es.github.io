<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🎓 🌆 🥒 PVS-Studio besucht Apache Hive 💿 👨‍👧‍👧 👩🏽‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten zehn Jahren war die Open-Source-Bewegung einer der Haupttreiber für die Entwicklung der IT-Branche und ihre entscheidende Komponente. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio besucht Apache Hive</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463753/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/2d0/eb3/0ad2d0eb30d726eefba9c913edaa346a.png" alt="Abbildung 1"></div><br>  In den letzten zehn Jahren war die Open-Source-Bewegung einer der Haupttreiber für die Entwicklung der IT-Branche und ihre entscheidende Komponente.  Die Rolle von Open-Source-Projekten wird nicht nur quantitativ, sondern auch qualitativ immer wichtiger, was das Konzept ihrer Positionierung auf dem IT-Markt im Allgemeinen verändert.  Unser mutiges PVS-Studio-Team sitzt nicht untätig und beteiligt sich aktiv an der Stärkung der Präsenz von Open-Source-Software, indem es versteckte Fehler in den enormen Tiefen der Codebasen findet und den Autoren solcher Projekte kostenlose Lizenzoptionen anbietet.  Dieser Artikel ist nur ein weiterer Teil dieser Aktivität!  Heute werden wir über Apache Hive sprechen.  Ich habe den Bericht - und es gibt Dinge, die es wert sind, angeschaut zu werden. <br><a name="habracut"></a><br><h2>  Über PVS-Studio </h2><br>  Der statische Code-Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> , den es seit mehr als 10 Jahren gibt, ist eine multifunktionale und einfach zu integrierende Softwarelösung.  Derzeit unterstützt es C, C ++, C # und Java und läuft unter Windows, Linux und MacOS. <br><br>  PVS-Studio ist eine kostenpflichtige B2B-Lösung, die von zahlreichen Teams in einer Reihe von Unternehmen eingesetzt wird.  Wenn Sie den Analysator ausprobieren möchten, besuchen Sie diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite</a> , um die Distribution herunterzuladen und einen Testschlüssel anzufordern. <br><br>  Wenn Sie ein Open-Source-Geek oder beispielsweise ein Student sind, können Sie eine unserer kostenlosen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lizenzoptionen nutzen</a> . <br><br><h2>  Über Apache Hive </h2><br>  Die Datenmenge ist in den letzten Jahren enorm gewachsen.  Die Standarddatenbanken können dieses schnelle Wachstum nicht mehr bewältigen. Daher kommt der Begriff Big Data zusammen mit anderen verwandten Begriffen (wie Verarbeitung, Speicherung und anderen Vorgängen mit Big Data). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Hadoop</a> gilt derzeit als eine der wegweisenden Big Data-Technologien.  Die Hauptaufgaben sind das Speichern, Verarbeiten und Verwalten großer Datenmengen.  Die Hauptkomponenten des Frameworks sind Hadoop Common, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HDFS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hadoop MapReduce</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hadoop YARN</a> .  Im Laufe der Zeit hat sich rund um Hadoop ein großes Ökosystem verwandter Projekte und Technologien entwickelt, von denen viele ursprünglich als Teil des Projekts begannen und sich dann auf den Weg machten, um unabhängig zu werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Hive</a> ist einer von ihnen. <br><br>  Apache Hive ist ein verteiltes Data Warehouse.  Es verwaltet die in HDFS gespeicherten Daten und stellt die auf SQL (HiveQL) basierende Abfragesprache bereit, um diese Daten zu verarbeiten.  Weitere Details zum Projekt finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Ausführen der Analyse </h2><br>  Es dauerte nicht viel Mühe oder Zeit, um die Analyse zu starten.  Hier ist mein Algorithmus: <br><br><ul><li>  Heruntergeladener Apache Hive von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ; </li><li>  Lesen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung</a> zum Starten des Java-Analysators und starten Sie die Analyse. </li><li>  Erhielt den Bericht des Analysators, studierte ihn und schrieb die interessantesten Fälle auf. </li></ul><br>  Die Analyseergebnisse lauten wie folgt: 1456 Warnungen vor hohen und mittleren Werten (602 bzw. 854) in über 6500 Dateien. <br><br>  Nicht alle Warnungen beziehen sich auf echte Fehler.  Das ist ganz normal;  Sie müssen die Einstellungen des Analysators anpassen, bevor Sie ihn regelmäßig verwenden können.  Danach erwarten Sie normalerweise eine relativ geringe Rate an Fehlalarmen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ). <br><br>  Ich habe die 407 Warnungen (177 High- und 230 Medium-Level), die von den Testdateien ausgelöst wurden, weggelassen.  Ich habe auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6022-</a> Diagnose ignoriert (da Sie nicht zuverlässig zwischen fehlerhaften und korrekten Fragmenten unterscheiden können, wenn Sie mit dem Code nicht vertraut sind), die bis zu 482 Mal ausgelöst wurde.  Ich habe auch nicht die 179 Warnungen untersucht, die von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6021-</a> Diagnose generiert wurden. <br><br>  Am Ende hatte ich immer noch genug Warnungen, und da ich die Einstellungen nicht angepasst habe, gibt es immer noch einen gewissen Prozentsatz an Fehlalarmen.  Es macht einfach keinen Sinn, zu viele Warnungen in einen Artikel wie diesen aufzunehmen :).  Also reden wir nur darüber, was mir aufgefallen ist und neugierig genug ausgesehen hat. <br><br><h2>  Vorgegebene Bedingungen </h2><br>  Unter den für diese Analyse untersuchten Diagnosen enthält <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007</a> einen Datensatz für die Anzahl der ausgegebenen Warnungen.  Etwas mehr als 200 Nachrichten !!!  Einige sehen harmlos aus, andere sind misstrauisch und andere sind doch echte Käfer!  Schauen wir uns einige davon an. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007</a> Ausdruck 'key.startsWith ("hplsql.")' Ist immer wahr.  Exec.java (675) <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initOptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == null || value == null || !key.startsWith(<span class="hljs-string"><span class="hljs-string">"hplsql."</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } else if (key.compareToIgnoreCase(Conf.CONN_DEFAULT) == 0) { .... } else if (key.startsWith("hplsql.conn.init.")) { .... } else if (key.startsWith(Conf.CONN_CONVERT)) { .... } else if (key.startsWith("hplsql.conn.")) { .... } else if (key.startsWith("hplsql.")) { // &lt;= .... } }</span></span></code> </pre> <br>  Das ist ein ziemlich langwieriges Wenn-Sonst-Wenn-Konstrukt!  Dem Analysator gefällt die Bedingung im letzten <i>if (key.startsWith ("hplsql.")) Nicht.</i> Wenn die Ausführung sie erreicht, bedeutet dies, dass sie wahr ist.  Wenn Sie sich die erste Zeile dieses gesamten if-else-if-Konstrukts ansehen, werden Sie <i>feststellen,</i> dass es bereits die entgegengesetzte Prüfung enthält. Wenn die Zeichenfolge also nicht mit <i>"hplsql" beginnt.</i>  Die Ausführung springt sofort zur nächsten Iteration. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007 Der</a> Ausdruck 'columnNameProperty.length () == 0' ist immer falsch.  OrcRecordUpdater.java (238) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDescription </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTypeDescriptionFromTableProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tableProperties != null) { final String columnNameProperty = ....; final String columnTypeProperty = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !Strings.isNullOrEmpty(columnNameProperty) &amp;&amp; !Strings.isNullOrEmpty(columnTypeProperty)) { List&lt;String&gt; columnNames = columnNameProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;() : ....; List&lt;TypeInfo&gt; columnTypes = columnTypeProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;TypeInfo&gt;() : ....; .... } } } .... }</code> </pre> <br>  Der Vergleich der <i>Länge der</i> Zeichenfolge <i>columnNameProperty</i> mit Null gibt immer <i>false zurück</i> .  Dies liegt daran, dass dieser Vergleich der <i>Prüfung! Strings.isNullOrEmpty (columnNameProperty)</i> folgt.  Wenn die Ausführung unseren Zustand erreicht, bedeutet dies, dass die Zeichenfolge <i>columnNameProperty</i> sicherlich weder null noch leer ist. <br><br>  Gleiches gilt für die Zeichenfolge <i>columnTypeProperty</i> eine Zeile später: <br><br><ul><li>  V6007 Der Ausdruck 'columnTypeProperty.length () == 0' ist immer falsch.  OrcRecordUpdater.java (239) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007 Der</a> Ausdruck 'colOrScalar1.equals ("Column")' ist immer falsch.  GenVectorCode.java (3469) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDateTimeArithmeticIntervalYearMonth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] tdesc)</span></span></span><span class="hljs-function"> throws Exception </span></span>{ .... String colOrScalar1 = tdesc[<span class="hljs-number"><span class="hljs-number">4</span></span>]; .... String colOrScalar2 = tdesc[<span class="hljs-number"><span class="hljs-number">6</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } else if (colOrScalar1.equals("Col") &amp;&amp; colOrScalar1.equals("Scalar")) { .... } else if (colOrScalar1.equals("Scalar") &amp;&amp; colOrScalar1.equals("Column")) { .... } }</span></span></code> </pre><br>  Das gute alte Copy-Paste.  Aus Sicht der aktuellen Logik kann der String <i>colOrScalar1</i> zwei verschiedene Werte gleichzeitig haben, was unmöglich ist.  Offensichtlich sollten die Prüfungen die Variable <i>colOrScalar1</i> links und <i>colOrScalar2</i> rechts haben. <br><br>  Ähnliche Warnungen einige Zeilen weiter unten: <br><br><ul><li>  V6007 Der Ausdruck 'colOrScalar1.equals ("Scalar")' ist immer falsch.  GenVectorCode.java (3475) </li><li>  V6007 Der Ausdruck 'colOrScalar1.equals ("Column")' ist immer falsch.  GenVectorCode.java (3486) </li></ul><br>  Infolgedessen wird dieses if-else-if-Konstrukt niemals etwas tun. <br><br>  Noch ein paar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6007-</a> Warnungen: <br><br><ul><li>  V6007 Der Ausdruck 'Zeichen == null' ist immer falsch.  RandomTypeUtil.java (43) </li><li>  V6007 Der Ausdruck 'writeIdHwm&gt; 0' ist immer falsch.  TxnHandler.java (1603) </li><li>  V6007 Ausdruck 'fields.equals ("*")' ist immer wahr.  Server.java (983) </li><li>  V6007 Ausdruck 'currentGroups! = Null' ist immer wahr.  GenericUDFCurrentGroups.java (90) </li><li>  V6007 Der Ausdruck 'this.wh == null' ist immer falsch.  New gibt eine Referenz ungleich Null zurück.  StorageBasedAuthorizationProvider.java (93), StorageBasedAuthorizationProvider.java (92) </li><li>  und so weiter ... </li></ul><br><h2>  NPE </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6008</a> Mögliche Null-Dereferenzierung von 'dagLock'.  QueryTracker.java (557), QueryTracker.java (553) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleFragmentCompleteExternalQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryInfo queryInfo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryInfo.isExternalQuery()) { ReadWriteLock dagLock = getDagLock(queryInfo.getQueryIdentifier()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dagLock == null) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Ignoring fragment completion for unknown query: {}"</span></span>, queryInfo.getQueryIdentifier()); } boolean locked = dagLock.writeLock().tryLock(); ..... } }</code> </pre> <br>  Ein Null-Objekt wird abgefangen, protokolliert und ... das Programm läuft einfach weiter.  Infolgedessen folgt auf die Prüfung eine Nullzeiger-Dereferenzierung.  Autsch! <br><br>  Die Entwickler müssen tatsächlich gewollt haben, dass das Programm die Funktion beendet oder eine spezielle Ausnahme auslöst, wenn eine Nullreferenz abgerufen wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6008</a> Null-Dereferenzierung von 'Puffer' in der Funktion 'UnlockSingleBuffer'.  MetadataCache.java (410), MetadataCache.java (465) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LlapBufferOrBuffers buffers, ....)</span></span></span><span class="hljs-function"> </span></span>{ LlapAllocatorBuffer buffer = buffers.getSingleLlapBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer != null) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return lockOneBuffer(buffer, doNotifyPolicy); } LlapAllocatorBuffer[] bufferArray = buffers.getMultipleLlapBuffers(); for (int i = 0; i &lt; bufferArray.length; ++i) { if (lockOneBuffer(bufferArray[i], doNotifyPolicy)) continue; for (int j = 0; j &lt; i; ++j) { unlockSingleBuffer(buffer, true); // &lt;= } .... } .... } .... private void unlockSingleBuffer(LlapAllocatorBuffer buffer, ....) { boolean isLastDecref = (buffer.decRef() == 0); // &lt;= if (isLastDecref) { .... } }</span></span></code> </pre> <br>  Ein weiteres potenzielles NPE.  Wenn die Ausführung die Methode <i>lockerSingleBuffer</i> erreicht, bedeutet dies, dass das <i>Pufferobjekt</i> null ist.  Angenommen, das ist passiert!  Wenn Sie sich die Methode <i>lockerSingleBuffer ansehen</i> , werden Sie gleich in der ersten Zeile feststellen, wie unser Objekt dereferenziert wird.  Gotcha! <br><br><h2>  Eine wilde Verschiebung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6034 Die</a> Verschiebung um den Wert 'bitShiftsInWord - 1' kann mit der Größe des Typs nicht übereinstimmen: 'bitShiftsInWord - 1' = [-1 ... 30].  UnsignedInt128.java (1791) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, boolean roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } assert (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Dies ist eine mögliche Verschiebung um -1.  Wenn die Methode beispielsweise mit <i>wordShifts == 3</i> und <i>bitShiftsInWord == 0</i> aufgerufen wird, <i>endet</i> die gemeldete Zeile mit 1 &lt;&lt; -1.  Ist das ein geplantes Verhalten? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6034 Die</a> Verschiebung um den Wert 'j' kann mit der Größe des Typs nicht übereinstimmen: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, boolean[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  In der angegebenen Zeile kann die Variable <i>j</i> einen Wert im Bereich [0 ... 63] haben.  Aus diesem Grund kann die Berechnung des Werts von <i>val</i> in der Schleife auf unerwartete Weise ausgeführt werden.  Im Ausdruck <i>(1 &lt;&lt; j)</i> ist der Wert 1 vom Typ <i>int</i> . Wenn Sie ihn also um 32 Bit und mehr verschieben, überschreiten Sie die Grenzen des Typbereichs.  Dies kann durch Schreiben von <i>((lang) 1 &lt;&lt; j)</i> behoben werden. <br><br><h2>  Sich von der Protokollierung mitreißen lassen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6046</a> Falsches Format.  Eine andere Anzahl von Formatelementen wird erwartet.  Nicht verwendete Argumente: 1, 2. StatsSources.java (89) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ImmutableList&lt;PersistedRuntimeStats&gt; extractStatsFromPlanMapper (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stat.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> || sig.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { StringBuffer sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuffer(); sb.append(String.format( <span class="hljs-string"><span class="hljs-string">"expected(stat-sig) 1-1, got {}-{} ;"</span></span>, <span class="hljs-comment"><span class="hljs-comment">// &lt;= stat.size(), sig.size() )); .... } .... if (e.getAll(OperatorStats.IncorrectRuntimeStatsMarker.class).size() &gt; 0) { LOG.debug( "Ignoring {}, marked with OperatorStats.IncorrectRuntimeStatsMarker", sig.get(0) ); continue; } .... }</span></span></code> </pre> <br>  Beim Schreiben des Codes zum Formatieren der Zeichenfolge mit <i>String.format ()</i> hat der Entwickler eine falsche Syntax verwendet.  Infolgedessen haben es die übergebenen Parameter nie in die resultierende Zeichenfolge geschafft.  Ich vermute, dass der Entwickler vor dem Schreiben an der Protokollierung gearbeitet hat, von wo er die Syntax ausgeliehen hat. <br><br><h2>  Eine gestohlene Ausnahme </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6051</a> Die Verwendung der Anweisung 'return' im Block 'finally' kann zum Verlust nicht behandelter Ausnahmen führen.  ObjectStore.java (9080) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;MPartitionColumnStatistics&gt; getMPartitionColumnStatistics(....) throws NoSuchObjectException, MetaException { boolean committed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex instanceof MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } finally { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  Es ist eine sehr schlechte Praxis, etwas aus dem <i>finally-</i> Block zurückzugeben, und dieses Beispiel zeigt anschaulich, warum. <br><br>  Im <i>try-</i> Block bildet das Programm eine Anforderung und greift auf den Speicher zu.  Die <i>festgeschriebene</i> Variable hat standardmäßig den Wert <i>false</i> und ändert ihren Status erst, nachdem alle vorherigen Aktionen im <i>try-</i> Block erfolgreich ausgeführt wurden.  Wenn eine Ausnahme ausgelöst wird, ist diese Variable immer <i>falsch</i> .  Der <i>catch-</i> Block fängt die Ausnahme ab, passt sie ein wenig an und wirft sie auf.  Wenn also der <i>finally-</i> Block an der Reihe ist, gibt die Ausführung die Bedingung ein, aus der eine leere Liste zurückgegeben wird.  Was kostet uns diese Rücksendung?  Nun, es kostet uns zu verhindern, dass eine gefangene Ausnahme nach außen geworfen wird, wo sie richtig gehandhabt werden kann.  Keine der in der Signatur der Methode angegebenen Ausnahmen wird jemals ausgelöst.  Sie sind einfach irreführend. <br><br>  Eine ähnliche Diagnosemeldung: <br><br><ul><li>  V6051 Die Verwendung der Anweisung 'return' im Block 'finally' kann zum Verlust nicht behandelter Ausnahmen führen.  ObjectStore.java (808) </li></ul><br><h2>  Verschiedenes </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6009 Die</a> Funktion 'compareTo' empfängt ein ungerades Argument.  Ein Objekt 'o2.getWorkerIdentity ()' wird als Argument für seine eigene Methode verwendet.  LlapFixedRegistryImpl.java (244) <br><br><pre> <code class="cpp hljs">@Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;LlapServiceInstance&gt; getAllInstancesOrdered(....) { .... Collections.sort(<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comparator&lt;LlapServiceInstance&gt;() { @Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compare(LlapServiceInstance o1, LlapServiceInstance o2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o2.getWorkerIdentity().compareTo(o2.getWorkerIdentity()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } }); .... }</span></span></code> </pre> <br>  Es kann eine Reihe von Ursachen geben, die zu solch einem dummen Fehler führen: Kopieren, Einfügen, Nachlässigkeit, Eile und so weiter.  Wir sehen solche Fehler oft in Open-Source-Projekten und haben sogar einen ganzen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> darüber. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6020</a> Durch Null teilen.  Der Bereich der 'Divisor'-Nennerwerte umfasst Null.  SqlMathUtil.java (265) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divideUnsignedLong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divisor &lt; <span class="hljs-number"><span class="hljs-number">0L</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*some comments*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (compareUnsignedLong(dividend, divisor)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0L</span></span> : <span class="hljs-number"><span class="hljs-number">1L</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dividend &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Both inputs non-negative return dividend / divisor; // &lt;= } else { .... } }</span></span></code> </pre> <br>  Dieser ist ziemlich trivial.  Eine Reihe von Überprüfungen war hilflos, um die Division durch Null abzuwenden. <br><br>  Noch ein paar Warnungen: <br><br><ul><li>  V6020 Mod um Null.  Der Bereich der 'Divisor'-Nennerwerte umfasst Null.  SqlMathUtil.java (309) </li><li>  V6020 Durch Null teilen.  Der Bereich der 'Divisor'-Nennerwerte umfasst Null.  SqlMathUtil.java (276) </li><li>  V6020 Durch Null teilen.  Der Bereich der 'Divisor'-Nennerwerte umfasst Null.  SqlMathUtil.java (312) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6030</a> Die Methode rechts neben dem '|'  Der Operator wird unabhängig vom Wert des linken Operanden aufgerufen.  Vielleicht ist es besser, '||' zu verwenden.  OperatorUtils.java (573) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Operator&lt;? extends OperatorDesc&gt; findSourceRS(....) { .... List&lt;Operator&lt;? extends OperatorDesc&gt;&gt; parents = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parents == null | parents.isEmpty()) { <span class="hljs-comment"><span class="hljs-comment">// reached end eg TS operator return null; } .... }</span></span></code> </pre> <br>  Der Programmierer hat den bitweisen Operator | geschrieben  anstelle des logischen ||.  Dies bedeutet, dass der rechte Teil ausgeführt wird, unabhängig vom Ergebnis des linken.  Wenn <i>parent == null ist</i> , wird dieser Tippfehler direkt im nächsten logischen Unterausdruck mit einem NPE enden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6042</a> Der Ausdruck wird auf Kompatibilität mit Typ 'A' geprüft, aber in Typ 'B' umgewandelt.  VectorColumnAssignFactory.java (347) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VectorColumnAssign </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildObjectAssign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VectorizedRowBatch outputBatch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outColIndex, PrimitiveCategory category)</span></span></span><span class="hljs-function"> throws HiveException </span></span>{ VectorColumnAssign outVCA = null; ColumnVector destCol = outputBatch.cols[outColIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol instanceof LongColumnVector) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(category) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LONG: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorLongColumnAssign() { .... } .init(.... , (LongColumnVector) destCol); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TIMESTAMP: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorTimestampColumnAssign() { .... }.init(...., (TimestampColumnVector) destCol); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case DATE: outVCA = new VectorLongColumnAssign() { .... } .init(...., (LongColumnVector) destCol); break; case INTERVAL_YEAR_MONTH: outVCA = new VectorLongColumnAssign() { .... }.init(...., (LongColumnVector) destCol); break; case INTERVAL_DAY_TIME: outVCA = new VectorIntervalDayTimeColumnAssign() { .... }.init(...., (IntervalDayTimeColumnVector) destCol);// &lt;= break; default: throw new HiveException(....); } } else if (destCol instanceof DoubleColumnVector) { .... } .... else { throw new HiveException(....); } return outVCA; }</span></span></code> </pre> <br>  Wir interessieren uns für die Klassen <i>LongColumnVector erweitert ColumnVector</i> und <i>TimestampColumnVector erweitert ColumnVector</i> .  Die Überprüfung, dass das <i>destCol-</i> Objekt eine Instanz von <i>LongColumnVector ist,</i> legt ausdrücklich nahe, dass es sich um ein Objekt dieser Klasse handelt, das im Hauptteil der bedingten Anweisung behandelt wird.  Trotzdem wird es immer noch in <i>TimestampColumnVector umgewandelt</i> !  Wie Sie sehen können, handelt es sich um verschiedene Klassen, mit der Ausnahme, dass sie von demselben übergeordneten Element abgeleitet sind.  Als Ergebnis erhalten wir eine <i>ClassCastException</i> . <br><br>  Gleiches gilt für das Casting in <i>IntervalDayTimeColumnVector</i> : <br><br><ul><li>  V6042 Der Ausdruck wird auf Kompatibilität mit Typ 'A' geprüft, aber in Typ 'B' umgewandelt.  VectorColumnAssignFactory.java (390) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V6060</a> Die ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">var'</a> -Referenz wurde verwendet, bevor sie gegen null verifiziert wurde.  Var.java (402), Var.java (395) <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getClass() != obj.getClass()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } Var var = (Var)obj; if (this == var) { return true; } else if (var == null || // &lt;= var.value == null || this.value == null) { return false; } .... }</span></span></code> </pre> <br>  Hier sehen Sie eine seltsame Überprüfung des <i>var-</i> Objekts auf <i>null,</i> nachdem die Dereferenzierung bereits aufgetreten ist.  In diesem Zusammenhang sind <i>var</i> und <i>obj</i> dasselbe Objekt ( <i>var = (Var) obj</i> ).  Das Vorhandensein der <i>Nullprüfung</i> impliziert, dass das übergebene Objekt null sein kann.  Das Aufrufen von <i>equals (null)</i> führt also zu einer NPE anstelle der erwarteten <i>false</i> direkt in der ersten Zeile.  Ja, der Scheck <i>ist</i> da, aber leider ist er am falschen Ort. <br><br>  Einige andere ähnliche Fälle, in denen ein Objekt vor der Prüfung verwendet wird: <br><br><ul><li>  V6060 Die 'Wert'-Referenz wurde verwendet, bevor sie gegen Null verifiziert wurde.  ParquetRecordReaderWrapper.java (168), ParquetRecordReaderWrapper.java (166) </li><li>  V6060 Die Referenz 'defaultConstraintCols' wurde verwendet, bevor sie gegen null verifiziert wurde.  HiveMetaStore.java (2539), HiveMetaStore.java (2530) </li><li>  V6060 Die Referenz 'projIndxLst' wurde verwendet, bevor sie gegen null verifiziert wurde.  RelOptHiveTable.java (683), RelOptHiveTable.java (682) </li><li>  V6060 Die 'oldp'-Referenz wurde verwendet, bevor sie gegen null verifiziert wurde.  ObjectStore.java (4343), ObjectStore.java (4339) </li><li>  und so weiter ... </li></ul><br><h2>  Fazit </h2><br>  Wenn Sie sich jemals für Big Data interessiert haben, wenn auch nur ein bisschen, dann können Sie kaum übersehen, wie wichtig Apache Hive ist.  Dies ist ein beliebtes und ziemlich großes Projekt, das aus über 6500 Quelldateien (* .java) besteht.  Viele Entwickler haben es über viele Jahre geschrieben, was bedeutet, dass ein statischer Analysator dort viele Dinge zu finden hat.  Es zeigt nur noch einmal, dass statische Analysen bei der Entwicklung mittlerer und großer Projekte äußerst wichtig und nützlich sind! <br><br>  Hinweis  Einmalige Überprüfungen wie die hier durchgeführte sind gut geeignet, um die Fähigkeiten des Analysators zu demonstrieren, stellen jedoch ein völlig unangemessenes Szenario für die Verwendung dar.  Diese Idee wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier weiter ausgeführt</a> .  Die statische Analyse ist regelmäßig anzuwenden! <br><br>  Diese Überprüfung von Hive ergab einige Mängel und verdächtige Fragmente.  Wenn die Autoren von Apache Hive auf diesen Artikel stoßen, helfen wir Ihnen gerne bei der schwierigen Aufgabe, das Projekt zu verbessern. <br><br>  Sie können sich Apache Hive ohne Apache Hadoop nicht vorstellen, daher könnte das Einhorn von PVS-Studio auch diesem einen Besuch abstatten.  Aber das ist alles für heute.  In der Zwischenzeit lade ich Sie ein, den Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterzuladen</a> und Ihre eigenen Projekte zu überprüfen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463753/">https://habr.com/ru/post/de463753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463741/index.html">Mit Firefox (bereits behoben) und Chrome können Sie den Alt-Svc-Header zum Scannen von Intranet-Ports verwenden</a></li>
<li><a href="../de463745/index.html">C ++ zu komplizieren ist unvermeidlich. Und nicht nur C ++</a></li>
<li><a href="../de463747/index.html">Greifen Sie auf Eigenschaften im Jsonb-Feld für Npgsql zu</a></li>
<li><a href="../de463749/index.html">Scrum vs Kanban: Bleib ruhig und wähle, was besser zu dir passt</a></li>
<li><a href="../de463751/index.html">iOS 13: Was Sie brauchen und was Sie bei der Entwicklung für ein neues Betriebssystem absolut nicht tun müssen</a></li>
<li><a href="../de463755/index.html">Der Unterschied zwischen "Juni", "Mitte" und "Senior". Und was tun, um eine Ebene höher zu kommen?</a></li>
<li><a href="../de463759/index.html">PVS-Studio besucht Apache Hive</a></li>
<li><a href="../de463761/index.html">PHP Microservice Framework - Swoft</a></li>
<li><a href="../de463763/index.html">Vereinfachen Sie die Migration von OpenShift 3 zu OpenShift 4</a></li>
<li><a href="../de463765/index.html">Slurm DevOps: Warum werden wir die Philosophie von DevOps nicht diskutieren und was wird stattdessen passieren?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>