<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéöÔ∏è üîî ü§ï Modul Biner untuk Python üçõ ‚ÜóÔ∏è üëÜüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python itu luar biasa. Kami mengatakan "pip install" dan kemungkinan besar pustaka yang diperlukan akan dikirimkan. Tetapi kadang-kadang jawabannya ad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modul Biner untuk Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/418449/">  Python itu luar biasa.  Kami mengatakan "pip install" dan kemungkinan besar pustaka yang diperlukan akan dikirimkan.  Tetapi kadang-kadang jawabannya adalah: "kompilasi gagal", karena ada modul biner.  Mereka menderita semacam rasa sakit di hampir semua bahasa modern, karena ada banyak arsitektur, sesuatu perlu dirakit untuk mesin tertentu, sesuatu perlu dihubungkan dengan perpustakaan lain.  Secara umum, pertanyaan yang menarik, tetapi sedikit dipelajari: bagaimana mereka dapat dilakukan dan masalah apa yang ada?  Dmitry Zhiltsov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">zaabjuda</a> ) mencoba menjawab pertanyaan ini di MoscowPython Conf tahun lalu. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/P7ihyyIDtME" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Di bawah potongan adalah versi teks dari laporan Dmitry.  Mari kita bahas secara singkat kapan modul biner dibutuhkan, dan kapan lebih baik meninggalkannya.  Mari kita bahas aturan yang harus diikuti saat menulisnya.  Pertimbangkan lima opsi implementasi yang mungkin: <br><br><ul><li>  Ekstensi C / C ++ asli </li><li>  Meneguk </li><li>  Cython </li><li>  Ctypes </li><li>  Karat </li></ul><br>  <strong>Tentang pembicara</strong> : Dmitry Zhiltsov telah berkembang selama lebih dari 10 tahun.  Dia bekerja di CIAN sebagai arsitek sistem, yaitu, dia bertanggung jawab untuk solusi teknis dan pengaturan waktu.  Dalam hidup saya, saya berhasil mencoba assembler, Haskell, C, dan selama 5 tahun terakhir saya telah aktif memprogram dengan Python. <a name="habracut"></a><br><br><h2>  Tentang perusahaan <br></h2><br>  Banyak yang tinggal di Moskow dan menyewa rumah mungkin tahu tentang CIAN.  CYAN adalah 7 juta pembeli dan penyewa per bulan.  Semua pengguna ini setiap bulan, menggunakan layanan kami, menemukan tempat tinggal. <br><br>  Sekitar 75% orang Moskow tahu tentang perusahaan kami, dan ini sangat keren.  Di St. Petersburg dan Moskow, kita secara praktis dianggap sebagai pelaku monopoli.  Saat ini, kami mencoba memasuki daerah, dan oleh karena itu pembangunan telah tumbuh 8 kali selama 3 tahun terakhir.  Ini berarti bahwa tim meningkat 8 kali, kecepatan pengiriman nilai ke pengguna meningkat 8 kali, yaitu.  dari ide produk hingga bagaimana tangan seorang insinyur meluncurkan bangunan ke produksi.  Kami belajar di tim besar kami untuk berkembang sangat cepat, dan sangat cepat memahami apa yang terjadi saat ini, tetapi hari ini kami akan berbicara sedikit tentang sesuatu yang lain. <br><br>  Saya akan berbicara tentang modul biner.  Sekarang hampir 50% perpustakaan Python memiliki beberapa jenis modul biner.  Dan ternyata, banyak orang yang tidak mengenal mereka dan percaya bahwa ini adalah sesuatu yang transendental, sesuatu yang gelap dan tidak perlu.  Dan orang lain menyarankan untuk menulis microservice terpisah dengan lebih baik dan tidak menggunakan modul biner. <br><br>  Artikel akan terdiri dari dua bagian. <br><br><ol><li> Pengalaman saya: mengapa mereka dibutuhkan, kapan mereka paling baik digunakan, dan kapan tidak. <br></li><li>  Alat dan teknologi yang dengannya Anda dapat mengimplementasikan modul biner untuk Python. <br></li></ol><br><h2>  Mengapa modul biner diperlukan? <br></h2><br>  Kita semua tahu betul bahwa Python adalah bahasa yang ditafsirkan.  Ini hampir yang tercepat dari bahasa yang ditafsirkan, tetapi, sayangnya, <strong>kecepatannya tidak selalu cukup</strong> untuk perhitungan matematika yang berat.  Segera timbul pemikiran bahwa C akan lebih cepat. <br><br>  Tapi Python memiliki satu lagi rasa sakit - itu adalah <strong>GIL</strong> .  Sejumlah besar artikel telah ditulis tentang dia dan laporan telah dibuat tentang cara untuk mengelilinginya. <br><br>  Kita juga membutuhkan ekstensi biner untuk <strong>menggunakan kembali logika</strong> .  Misalnya, kami menemukan perpustakaan yang memiliki semua fungsi yang kami butuhkan, dan mengapa tidak menggunakannya.  Artinya, Anda tidak perlu menulis ulang kode, kami hanya mengambil kode yang sudah jadi dan menggunakannya kembali. <br><br>  Banyak orang percaya bahwa menggunakan ekstensi biner Anda dapat <strong>menyembunyikan kode sumber</strong> .  Pertanyaannya sangat, sangat kontroversial, tentu saja, dengan bantuan beberapa penyimpangan liar ini dapat dicapai, tetapi tidak ada jaminan 100%.  Maksimum yang bisa Anda dapatkan adalah tidak membiarkan klien mendekompilasi dan melihat apa yang terjadi dalam kode yang Anda berikan. <br><br><h3>  Kapan ekstensi biner benar-benar dibutuhkan? <br></h3><br>  Tentang kecepatan dan Python sudah jelas - ketika beberapa fungsi bekerja sangat lambat dan menempati 80% waktu eksekusi semua kode, kami mulai berpikir untuk menulis ekstensi biner.  Tetapi untuk membuat keputusan seperti itu, Anda harus mulai, seperti yang dikatakan oleh seorang pembicara terkenal, berpikir dengan otak Anda. <br><br>  Untuk menulis ekstensi ekstensi, orang harus mempertimbangkan bahwa ini, pertama, akan panjang.  Pertama, Anda perlu "menjilat" algoritme Anda, mis.  lihat apakah ada tiang tembok. <br><br><blockquote>  Dalam 90% kasus, setelah memeriksa algoritma secara menyeluruh, kebutuhan untuk menulis beberapa ekstensi menghilang. <br></blockquote><br>  Kasus kedua di mana ekstensi biner benar-benar dibutuhkan adalah <strong>penggunaan multi threading untuk operasi sederhana</strong> .  Sekarang ini tidak begitu relevan, tetapi masih tetap ada di perusahaan berdarah, di beberapa integrator sistem, di mana Python 2.6 masih ditulis.  Tidak ada sinkronisasi, dan bahkan untuk hal-hal sederhana, misalnya, mengunggah banyak gambar, multi-threading naik.  Tampaknya pada awalnya ini tidak menimbulkan biaya jaringan apa pun, tetapi ketika kami mengunggah gambar ke buffer, GIL naas datang dan semacam rem dimulai.  Seperti yang diperlihatkan oleh praktik, hal-hal seperti itu paling baik diselesaikan dengan menggunakan perpustakaan yang tidak diketahui Python. <br><br>  Jika Anda perlu menerapkan beberapa protokol khusus, mungkin lebih mudah untuk membuat kode C / C ++ sederhana dan menghilangkan banyak rasa sakit.  Saya melakukan ini di waktu saya di satu operator telekomunikasi, karena tidak ada perpustakaan yang siap pakai - saya harus menulis sendiri.  Tapi saya ulangi, sekarang ini tidak terlalu relevan, karena ada asyncio, dan untuk sebagian besar tugas ini sudah cukup. <br><br>  Tentang <strong>operasi yang</strong> jelas <strong>sulit,</strong> saya sudah katakan sebelumnya.  Ketika Anda memiliki crash, matriks besar dan sejenisnya, masuk akal bahwa Anda perlu melakukan ekstensi ke C / C ++.  Saya ingin mencatat bahwa beberapa orang berpikir bahwa kita tidak memerlukan ekstensi biner di sini, lebih baik untuk membuat layanan mikro dalam " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa super cepat</a> " dan mentransfer matriks besar melalui jaringan.  Tidak, lebih baik tidak melakukannya. <br><br>  Contoh lain yang baik ketika mereka dapat dan bahkan harus diambil adalah ketika Anda memiliki <strong>logika modul yang sudah ada</strong> .  Jika Anda memiliki modul atau pustaka Python di perusahaan Anda selama 3 tahun sudah, ada perubahan di dalamnya setahun sekali dan kemudian 2 baris, maka mengapa tidak membuatnya menjadi pustaka C normal jika ada sumber daya dan waktu gratis.  Minimal, dapatkan peningkatan produktivitas.  Dan juga akan ada pemahaman bahwa jika beberapa perubahan kardinal diperlukan di perpustakaan, maka ini tidak begitu sederhana dan, mungkin, ada baiknya untuk berpikir lagi dengan otak dan menggunakan perpustakaan ini dengan cara yang berbeda. <br><br><h3>  5 aturan emas <br></h3><br>  Saya mendapatkan aturan ini dalam praktik saya.  Mereka tidak hanya menyangkut Python, tetapi juga bahasa lain di mana Anda dapat menggunakan ekstensi biner.  Anda bisa berdebat dengan mereka, tetapi Anda juga bisa berpikir dan membawanya sendiri. <br><br><ol><li>  <strong>Hanya fungsi ekspor</strong> .  Membangun kelas dalam Python di perpustakaan biner cukup memakan waktu: Anda perlu menjelaskan banyak antarmuka, Anda perlu meninjau banyak integritas referensi dalam modul itu sendiri.  Lebih mudah untuk menulis antarmuka kecil untuk fungsi tersebut. <br></li><li>  <strong>Gunakan kelas wrapper</strong> .  Beberapa sangat menyukai OOP dan benar-benar menginginkan kelas.  Bagaimanapun, bahkan jika ini bukan kelas, lebih baik menulis pembungkus Python: membuat kelas, mendefinisikan metode kelas atau metode biasa, panggil fungsi C / C ++ asli.  Paling tidak, ini membantu menjaga integritas arsitektur data.  Jika Anda menggunakan semacam C / C ++ ekstensi pihak ketiga yang tidak dapat Anda perbaiki, maka di bungkusnya Anda bisa meretasnya agar semuanya berfungsi. <br></li><li>  <strong>Anda tidak bisa meneruskan argumen dari Python ke ekstensi - ini</strong> bahkan bukan aturan, melainkan persyaratan.  Dalam beberapa kasus, ini mungkin berhasil, tetapi biasanya ide yang buruk.  Oleh karena itu, dalam kode Anda, Anda harus terlebih dahulu membuat handler yang menggunakan tipe Python untuk mengetik C. Dan hanya setelah itu memanggil fungsi asli apa pun yang sudah bekerja dengan tipe s.  Handler yang sama menerima respons dari fungsi yang dapat dieksekusi dan mengubahnya menjadi tipe data Python, dan melemparkannya ke dalam kode Python. <br></li><li>  <strong>Mempertimbangkan pengumpulan sampah akun</strong> .  Python memiliki GC yang terkenal, dan Anda tidak boleh melupakannya.  Sebagai contoh, kami melewati sebagian besar teks dengan referensi dan mencoba menemukan beberapa kata di perpustakaan.  Kami ingin memparalelkan ini, kami meneruskan tautan ke area memori ini dan ke peluncuran beberapa utas.  Pada saat ini, GC hanya mengambil dan memutuskan bahwa tidak ada lagi yang mengacu pada objek ini dan memindahkannya dari area memori.  Dalam kode yang sama, kami hanya mendapatkan referensi nol, dan ini biasanya kesalahan segmentasi.  Kita tidak boleh melupakan fitur pengumpul sampah seperti itu dan meneruskan tipe data paling sederhana ke pustaka char: char, integer, dll. <br><br>  Di sisi lain, bahasa tempat ekstensi ditulis mungkin memiliki pemulung sendiri.  Kombinasi Python dan C # library adalah rasa sakit dalam pengertian ini. <br></li><li>  <strong>Secara eksplisit mendefinisikan argumen dari fungsi yang diekspor</strong> .  Dengan ini, saya ingin mengatakan bahwa fungsi-fungsi ini perlu dijelaskan secara kualitatif.  Jika kami menerima fungsi PyObject, dan dalam hal apa pun kami akan menerimanya di pustaka kami, maka kami perlu secara eksplisit menunjukkan argumen mana yang termasuk tipe yang mana.  Ini berguna karena jika kita melewati tipe data yang salah, kita akan mendapatkan kesalahan di perpustakaan.  Artinya, Anda membutuhkannya untuk kenyamanan Anda. <br></li></ol><br><h3>  Arsitektur ekstensi biner <br></h3><br><img src="https://habrastorage.org/webt/xq/q1/-0/xqq1-0l_omlmuok-v8yqryqkvku.png"><br><br>  Sebenarnya, tidak ada yang rumit dalam arsitektur ekstensi biner.  Ada Python, ada fungsi panggilan yang mendarat di bungkus yang secara asli memanggil kode.  Panggilan ini pada gilirannya mendarat pada fungsi yang diekspor ke Python dan dapat langsung dipanggil.  Dalam fungsi ini Anda perlu melemparkan tipe data ke tipe data bahasa Anda.  Dan hanya setelah fungsi ini menerjemahkan semuanya kepada kami, kami memanggil fungsi asli, yang melakukan logika utama, mengembalikan hasilnya ke arah yang berlawanan dan melemparkannya ke Python, menerjemahkan kembali tipe data. <br><br><h2>  Teknologi dan Alat <br></h2><br>  Cara paling terkenal untuk menulis ekstensi biner adalah ekstensi Native C / C ++.  Hanya karena itu adalah teknologi Python standar. <br><br><h3>  Ekstensi C / C ++ asli <br></h3><br>  Python sendiri diimplementasikan dalam C, dan metode dan struktur dari python.h digunakan untuk menulis ekstensi.  Ngomong-ngomong, hal ini juga bagus karena sangat mudah untuk mengimplementasikannya dalam proyek yang sudah ada.  Cukup menentukan xt_modules di setup.py dan mengatakan bahwa untuk membangun proyek Anda perlu mengkompilasi sumber-sumber tersebut dengan flag kompilasi seperti itu.  Di bawah ini adalah contohnya. <br><br><pre><code class="cpp hljs">name = <span class="hljs-string"><span class="hljs-string">'DateTime.mxDateTime.mxDateTime'</span></span> src = <span class="hljs-string"><span class="hljs-string">'mxDateTime/mxDateTime.c'</span></span> extra_compile_args=[<span class="hljs-string"><span class="hljs-string">'-g3'</span></span>, <span class="hljs-string"><span class="hljs-string">'-o0'</span></span>, <span class="hljs-string"><span class="hljs-string">'-DDEBUG=2'</span></span>, <span class="hljs-string"><span class="hljs-string">'-UNDEBUG'</span></span>, <span class="hljs-string"><span class="hljs-string">'-std=c++11'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wall'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wextra'</span></span>] setup ( ... ext_modules = [(name, { <span class="hljs-string"><span class="hljs-string">'sources'</span></span>: [src], <span class="hljs-string"><span class="hljs-string">'include_dirs'</span></span>: [<span class="hljs-string"><span class="hljs-string">'mxDateTime'</span></span>] , extra_compile_args: extra_compile_args } )] )</code> </pre> <br>  Kelebihan dari Ekstensi C / C ++ Asli <br><br><ul><li>  Teknologi asli. </li><li>  Mudah diintegrasikan ke dalam perakitan proyek. </li><li>  Jumlah dokumentasi terbesar. </li><li>  Memungkinkan Anda membuat tipe data Anda sendiri. </li></ul><br>  Kekurangan Native C / C ++ Extension <br><br><ul><li>  Ambang entri tinggi. </li><li>  Pengetahuan tentang C. diperlukan </li><li>  Boost.Python. </li><li>  Kesalahan Segmentasi. </li><li>  Kesulitan dalam debugging. </li></ul><br>  Menurut teknologi ini, sejumlah besar dokumentasi ditulis, baik posting standar maupun blog.  Nilai tambah yang besar adalah kita bisa melakukan tipe data Python kita sendiri dan membangun kelas kita. <br><br>  Pendekatan ini memiliki kelemahan besar.  Pertama, ini adalah ambang masuk - tidak semua orang tahu cukup C untuk membuat kode untuk produksi.  Anda perlu memahami bahwa untuk ini tidak cukup membaca buku dan menjalankan untuk menulis ekstensi asli.  Jika Anda ingin melakukan ini, maka: pertama, pelajari C;  kemudian mulai menulis utilitas perintah;  setelah itu baru lanjutkan menulis ekstensi. <br><br>  Boost.Python sangat baik untuk C ++, memungkinkan Anda untuk hampir sepenuhnya abstrak dari semua pembungkus yang kami gunakan dalam Python.  Tapi minusnya, saya pikir, adalah Anda perlu banyak berkeringat untuk mengambil sebagian dan mengimpornya ke dalam proyek tanpa mengunduh seluruh Boost. <br><br>  Mendaftar kesulitan dalam debugging di minus, maksud saya sekarang semua orang terbiasa menggunakan debugger grafis, dan dengan modul biner hal seperti itu tidak akan berfungsi.  Kemungkinan besar Anda perlu menginstal GDB dengan plugin untuk Python. <br><br>  Mari kita lihat contoh bagaimana kita membuat ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Python.h&gt; static PyObject*addList_add(Pyobject* self, Pyobject* args){ PyObject * listObj; if (! PyARg_Parsetuple( args, "", &amp;listObj)) return NULL; long length = PyList_Size(listObj) int i, sum =0; //   return Py_BuildValue("i", sum); }</span></span></span></span></code> </pre><br>  Untuk memulai, kami menyertakan file header Python.  Setelah itu, kami menjelaskan fungsi addList_add yang akan digunakan Python.  Yang paling penting adalah memberi nama fungsi dengan benar, dalam hal ini addList adalah nama modul, _add adalah nama fungsi yang akan digunakan dalam Python.  Kami melewati modul PyObject itu sendiri dan meneruskan argumen menggunakan PyObject juga.  Setelah itu, kami melakukan pemeriksaan standar.  Dalam hal ini, kami mencoba menguraikan argumen tuple dan mengatakan bahwa itu adalah objek - literal "O" harus ditentukan secara eksplisit.  Setelah itu, kita tahu bahwa kita melewatkan listObj sebagai objek, dan kami mencoba mencari tahu panjangnya menggunakan metode Python standar: PyList_Size.  Catatan, di sini kita masih tidak dapat menggunakan panggilan panggilan untuk mengetahui panjang vektor ini, tetapi menggunakan fungsi Python.  Kami mengabaikan implementasi, setelah itu perlu mengembalikan semua nilai kembali ke Python.  Untuk melakukan ini, panggil Py_BuildValue, tentukan tipe data mana yang kami kembalikan, dalam hal ini "i" adalah bilangan bulat, dan jumlah variabel itu sendiri. <br><br>  Dalam hal ini, semua orang mengerti - kami menemukan jumlah semua elemen dari daftar.  Mari kita melangkah lebih jauh. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; length; i++){ <span class="hljs-comment"><span class="hljs-comment">//     //   Python- PyObject* temp = PyList_GetItem(listObj, i); //  ,      //     C long long elem= PyLong_AsLong(temp); sum += elem; }</span></span></code> </pre><br>  Ini adalah hal yang sama, saat ini, listObj adalah objek Python.  Dan dalam hal ini, kami mencoba untuk mengambil item daftar.  Python.h memiliki semua yang Anda butuhkan untuk ini. <br><br>  Setelah kami mendapatkan temp, kami mencoba untuk membuangnya terlalu lama.  Dan hanya setelah itu Anda dapat melakukan sesuatu dalam C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  static char addList_docs[] = "add( ): add all elements of the list\n"; //    static PyMethodDef addList_funcs[] = { {"add", (PyCFunction)addList_add, METH_VARARGS, addList_docs}, {NULL, NULL, 0, NULL} };</span></span></code> </pre><br>  Setelah kami mengimplementasikan seluruh fungsi, kita perlu menulis dokumentasi.  <strong>Dokumentasi selalu baik</strong> , dan toolkit ini memiliki segalanya untuk perawatan yang mudah.  Mengikuti konvensi penamaan, kami memberi nama modul addList_docs dan menyimpan deskripsi di sana.  Sekarang Anda perlu mendaftar modul, untuk ini ada struktur PyMethodDef khusus.  Menjelaskan properti, kita mengatakan bahwa fungsi diekspor ke Python dengan nama "add", yang fungsi ini memanggil PyCFunction.  METH_VARARGS berarti bahwa suatu fungsi berpotensi mengambil sejumlah variabel.  Kami juga menulis baris tambahan dan menjelaskan pemeriksaan standar, kalau-kalau kami hanya mengimpor modul, tetapi tidak menggunakan metode apa pun sehingga tidak jatuh. <br><br>  Setelah kami mengumumkan semua ini, kami mencoba membuat modul.  Kami membuat moduledef dan meletakkan semua yang kami lakukan di sana. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PyModuleDef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">moduledef</span></span></span><span class="hljs-class"> = {</span></span> PyModuleDef_HEAD_INIT, <span class="hljs-string"><span class="hljs-string">"addList example module"</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, adList_funcs, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre><br>  PyModuleDef_HEAD_INIT adalah konstanta Python standar yang harus selalu Anda gunakan.  -1 menunjukkan bahwa tidak ada memori tambahan yang perlu dialokasikan pada tahap impor. <br><br>  Ketika kita membuat modul itu sendiri, kita perlu menginisialisasi itu.  Python selalu mencari init, jadi buat PyInit_addList untuk addList.  Sekarang dari struktur rakitan, Anda dapat memanggil PyModule_Create dan akhirnya membuat modul itu sendiri.  Selanjutnya, tambahkan meta-informasi dan kembalikan modul itu sendiri. <br><br><pre> <code class="cpp hljs">PyInit_addList(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>){ PyObject *<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> = PyModule_Create(&amp;mdef); If (<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PyModule_AddStringConstant(<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>, <span class="hljs-string"><span class="hljs-string">"__author__"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bruse Lee&lt;brus@kf.ch&gt;:"</span></span>); PyModule_addStringConstant (Module, <span class="hljs-string"><span class="hljs-string">"__version__"</span></span>, <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>; }</code> </pre><br>  Seperti yang telah Anda perhatikan, ada banyak hal yang harus diubah.  Anda harus selalu ingat Python ketika kami menulis dalam C / C ++. <br><br>  Itulah sebabnya, untuk memfasilitasi kehidupan seorang programmer fana biasa, sekitar 15 tahun yang lalu, teknologi SWIG muncul. <br><br><h3>  Meneguk <br></h3><br>  Alat ini memungkinkan Anda untuk mengambil abstrak dari binding Python dan menulis kode asli.  Ini memiliki pro dan kontra yang sama dengan Native C / C ++, tetapi ada pengecualian. <br><br>  SWIG Pro: <br><br><ul><li>  Teknologi stabil. </li><li>  Sejumlah besar dokumentasi. </li><li>  Abstrak dari pengikatan ke Python. </li></ul><br>  Kekurangan SWIG: <br><br><ul><li>  Pengaturan panjang. </li><li>  Pengetahuan C. </li><li>  Kesalahan Segmentasi. </li><li>  Kesulitan dalam debugging. </li><li>  Kompleksitas integrasi ke dalam perakitan proyek. </li></ul><br>  Kekurangan pertama adalah <strong>saat Anda mengaturnya, Anda akan kehilangan akal</strong> .  Ketika saya mengaturnya untuk pertama kalinya, saya menghabiskan satu setengah hari untuk meluncurkannya.  Maka, tentu saja, lebih mudah.  SWIG 3.x menjadi lebih mudah. <br><br>  Agar tidak lagi masuk ke kode, pertimbangkan skema umum SWIG. <br><br><img src="https://habrastorage.org/webt/93/4h/ul/934huleqgml-qurdnxrw8k0gjes.png"><br><br>  example.c adalah modul C yang tidak tahu apa-apa tentang Python sama sekali.  Ada file antarmuka example.i, yang dijelaskan dalam format SWIG.  Setelah itu, jalankan utilitas SWIG, yang membuat example_wrap.c dari file antarmuka - ini adalah pembungkus yang sama yang biasa kita lakukan dengan tangan kita.  Artinya, SWIG hanya membuat pembungkus file untuk kita, yang disebut jembatan.  Setelah itu, menggunakan GCC, kita mengkompilasi dua file dan mendapatkan dua file objek (example.o dan example_wrap.o) dan hanya dengan begitu kita membuat library kita.  Semuanya sederhana dan jelas. <br><br><h3>  Cython <br></h3><br>  Andrey Svetlov membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> luar biasa di MoscowPython Conf, jadi saya hanya akan mengatakan bahwa ini adalah teknologi populer dengan dokumentasi yang baik. <br><br>  Kelebihan Cython: <br><br><ul><li>  Teknologi populer. </li><li>  Cukup stabil. </li><li>  Mudah diintegrasikan ke dalam perakitan proyek. </li><li>  Dokumentasi yang bagus. </li></ul><br>  Kekurangan dari Cython: <br><br><ul><li>  Sintaksnya sendiri. </li><li>  Pengetahuan C. </li><li>  Kesalahan Segmentasi. </li><li>  Kesulitan dalam debugging. </li></ul><br>  Kontra, seperti biasa, adalah.  Yang utama adalah sintaksnya sendiri, yang mirip dengan C / C ++, dan sangat mirip dengan Python. <br><br>  Tetapi saya ingin menunjukkan bahwa kode Python dapat dipercepat menggunakan Cython dengan menulis kode asli. <br><br><img src="https://habrastorage.org/webt/tk/8t/sh/tk8tshw1gla6nevwcjda4c9iq20.png"><br><br>  Seperti yang Anda lihat, ada banyak dekorator, dan ini tidak terlalu bagus.  Jika Anda ingin menggunakan Cython - lihat laporan Andrei Svetlov. <br><br><h3>  CTypes <br></h3><br>  CTypes adalah pustaka Python standar yang berfungsi dengan Antarmuka Fungsi Asing.  FFI adalah perpustakaan tingkat rendah.  Ini adalah teknologi asli, sangat sering digunakan dalam kode, dengan bantuannya mudah untuk mengimplementasikan lintas-platform. <br><br>  Tapi FFI membawa banyak overhead karena semua jembatan, semua penangan saat runtime dibuat secara dinamis.  Artinya, kami memuat pustaka dinamis, dan Python pada saat ini tidak tahu apa pustaka itu.  Hanya ketika perpustakaan dipanggil dalam memori jembatan ini dibangun secara dinamis. <br><br>  Kelebihan dari CTypes: <br><br><ul><li>  Teknologi asli. </li><li>  Mudah digunakan dalam kode. </li><li>  Mudah untuk mengimplementasikan lintas-platform. </li><li>  Anda dapat menggunakan hampir semua bahasa. </li></ul><br>  CTypes Kontra: <br><br><ul><li>  Membawa di atas kepala. </li><li>  Kesulitan dalam debugging. </li></ul><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment">#load the shared object file Adder = CDLL('./adder.so') #Calculate factorial res_int = adder.fact(4) print("Fact of 4 = " + str(res_int))</span></span></code> </pre><br>  Mereka mengambil adder.so dan menyebutnya runtime.  Kita bahkan dapat mengirimkan tipe Python asli. <br><br>  Setelah semua ini, pertanyaannya adalah: "Entah bagaimana rumit, di mana pun C, apa yang harus dilakukan?". <br><br><h3>  Karat <br></h3><br>  Pada suatu waktu, saya tidak memberikan perhatian yang tepat pada bahasa itu, tetapi sekarang saya praktis menoleh ke sana. <br><br>  Kelebihan Karat: <br><br><ul><li>  Bahasa yang aman. </li><li>  Jaminan statis yang kuat untuk perilaku yang benar. </li><li>  Mudah diintegrasikan ke dalam build proyek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyO3</a> ). </li></ul><br>  Kekurangan Karat: <br><br><ul><li>  Ambang entri tinggi. </li><li>  Pengaturan panjang. </li><li>  Kesulitan dalam debugging. </li><li>  Ada sedikit dokumentasi. </li><li>  Dalam beberapa kasus, overhead. </li></ul><br>  Karat adalah bahasa yang aman dengan bukti kerja otomatis.  Sintaksis itu sendiri dan preprocessor bahasa itu sendiri tidak memungkinkan kesalahan eksplisit dibuat.  Pada saat yang sama, ini difokuskan pada variabilitas, yaitu, ia harus memproses setiap hasil dari eksekusi kode cabang. <br><br>  Berkat tim PyO3, ada pengikat Python yang bagus untuk Rust, dan alat untuk diintegrasikan ke dalam proyek. <br><br>  Pada sisi negatifnya, saya anggap itu untuk programmer yang tidak siap, butuh waktu yang sangat lama untuk mengkonfigurasinya.  Beberapa dokumentasi, tetapi alih-alih kontra, kami tidak memiliki kesalahan segmentasi.  Di Rust, dengan cara yang baik, dalam 99% kasus, seorang programmer bisa mendapatkan kesalahan segmentasi hanya jika ia secara eksplisit menunjukkan membuka dan hanya mencetaknya. <br><br>  Contoh kecil kode, modul yang sama yang kami periksa sebelumnya. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(proc_macro)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> pyo3; Use pyo3::prelude::*; <span class="hljs-comment"><span class="hljs-comment">/// Module documentation string 1 #[py::modinit(_addList)] fn init(py: Python, m: PyModule) -&gt; PyResult &lt;()&gt;{ py_exception!(_addList, EmptyListError); /// Function documentation string 1 #[pufn(m, "run", args= "*", kwargs="**" )] fn run_py(_py: Python, args: &amp;PyTuple, kwargs: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;()&gt; { run(args, kwargs) } #[pyfn(m, "run", args="*", kwatgs="**")] fn run_py(_py: Python, args: &amp;PyTuple, kwargs: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;()&gt;{ run(args,kwargs) } #[pyfn(m,"add")] fn add(_py: Python, py_list: &amp;PyList) -&gt; PyResult&lt;i32&gt;{ let mut sum : i32 = 0 match py_list.len() { /// Some code Ok(sum) } Ok(()) }</span></span></code> </pre><br>  Kode memiliki sintaksis tertentu, tetapi Anda terbiasa dengan sangat cepat.  Faktanya, semuanya sama di sini.  Menggunakan makro, kami membuat modinit, yang bagi kami melakukan semua pekerjaan tambahan untuk menghasilkan semua jenis pengikat untuk Python.  Ingat saya katakan, Anda perlu melakukan handler wrapper, ini dia sama.  run_py mengonversi jenis, maka kita memanggil kode asli. <br><br>  Seperti yang Anda lihat, untuk mengekspor beberapa fungsi, ada gula sintaksis.  Kami hanya mengatakan bahwa kami memerlukan fungsi add dan tidak menggambarkan antarmuka apa pun.  Kami menerima daftar, yang persis py_list, bukan Object, karena Rust sendiri akan menyiapkan binder yang diperlukan pada saat kompilasi.  Jika kami melewati tipe data yang salah, seperti dalam ekstensi ekstensi, TypeError akan terjadi.  Setelah kami mendapatkan daftarnya, kami mulai memprosesnya. <br><br>  Mari kita lihat lebih detail apa yang dia mulai lakukan. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[pyfn(m, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"add"</span></span></span><span class="hljs-meta">, py_list=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"*"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(_py: Python, py_list: &amp;PyList) -&gt; PyResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> py_list.len() { <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt;<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(EmptyListError::new(<span class="hljs-string"><span class="hljs-string">"List is empty"</span></span>)), _ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sum : <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> py_list.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp:<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> item.extract() { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(v) =&gt; v, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(_) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> err_msg: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"List item {} is not int"</span></span>, item); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(ItemListError::new(err_msg)) } }; sum += temp; } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(sum) } } }</code> </pre><br>  Kode yang sama yang ada di C / C ++ / Ctypes, tetapi hanya di Rust.  Di sana saya mencoba untuk melemparkan PyObject ke beberapa jenis panjang.  Apa yang akan terjadi jika kita mendaftar, kecuali angka, akankah kita mendapatkan string?  Ya, kami akan mendapatkan SystemEerror.  Dalam hal ini, melalui <strong>let mut</strong> sum <strong>: i32 =</strong> 0;  kami juga mencoba untuk mendapatkan nilai dari daftar dan mengirimkannya ke i32.  Artinya, kita tidak akan dapat menulis kode ini tanpa item.extract (), secara tidak sadar dan dilemparkan ke tipe yang diinginkan.  Ketika kami menulis i32, dalam kasus kesalahan Rust, pada tahap kompilasi ia akan mengatakan: "Menangani kasus ketika bukan i32".  Dalam hal ini, jika kita memiliki i32, kita mengembalikan nilai, jika ini adalah kesalahan, kita melempar pengecualian. <br><br><h2>  Apa yang harus dipilih <br></h2><br>  Setelah tur singkat ini, kami akan memikirkan apa yang harus dipilih pada akhirnya? <br><br>  Jawabannya benar-benar sesuai dengan selera dan warna Anda. <br><br>  Saya tidak akan mempromosikan teknologi spesifik apa pun. <br><br><img src="https://habrastorage.org/webt/hu/kt/bn/huktbnnsqfoydatdp7gzsisysjg.png"><br><br>  Ringkas apa yang dikatakan: <br><br><ul><li>  Dalam kasus SWIG dan C / C ++, Anda harus tahu C / C ++ dengan sangat baik, pahami bahwa pengembangan modul ini akan menimbulkan beberapa overhead tambahan.  Tetapi minimum alat akan digunakan, dan kami akan bekerja dalam teknologi Python asli, yang didukung oleh pengembang. </li><li>  Dalam kasus Cython, kami memiliki ambang input kecil, kami memiliki kecepatan pengembangan tinggi, dan juga ini adalah generator kode biasa. </li><li>  Dengan mengorbankan CTypes, saya ingin memperingatkan Anda tentang overhead yang relatif besar.  Pemuatan perpustakaan dinamis, ketika kita tidak tahu perpustakaan macam apa itu, dapat menyebabkan banyak masalah. </li><li>  Saya akan menyarankan Rust untuk membawa seseorang yang tidak tahu C / C ++ dengan baik.  Karat dalam produksi benar-benar membawa masalah paling sedikit. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Tautan yang bermanfaat</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/zaabjuda/moscowpythonconf2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.python.org/3/extending/building.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://cython.org</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.python.org/376/library/ctypes.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.swig.org</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.rust-land.org/en-US/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/PyO3</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.youtube.com/watch?v=5-WoT4X17sk</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://packaging.python.org/tutorials/distributing-packages/#platformwheels</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/PushAMP/pamagent</a> (contoh pertarungan penggunaan bersama) </div></div><br><blockquote>  Panggilan untuk surat-surat <br><br>  Kami menerima aplikasi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moscow Python Conf ++</a> hingga 7 September - tulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">formulir</a> sederhana ini yang Anda ketahui tentang Python yang benar-benar perlu Anda bagikan dengan komunitas. <br><br>  Bagi mereka yang lebih tertarik mendengarkan, saya dapat berbicara tentang laporan keren. <br><br><ul><li>  <strong>Donald Whyte</strong> suka berbicara tentang percepatan matematika dengan Python dan menyiapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cerita baru</a> untuk kita: bagaimana membuat matematika 10 kali lebih cepat menggunakan perpustakaan populer, trik dan kegelapan, dan kodenya dapat dimengerti dan didukung. <br></li><li>  <strong>Artyom Malyshev telah</strong> mengumpulkan semua pengalaman bertahun-tahun dalam mengembangkan Django dan mempresentasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan laporan</a> tentang kerangka kerja!  Segala sesuatu yang terjadi antara menerima permintaan HTTP dan mengirim halaman web yang sudah selesai: mengekspos sihir, peta mekanisme internal kerangka kerja, dan banyak tips berguna untuk proyek Anda. <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418449/">https://habr.com/ru/post/id418449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418439/index.html">Dasar-dasar Aplikasi Web Progresif</a></li>
<li><a href="../id418441/index.html">Dasar-dasar eskalasi hak istimewa Windows</a></li>
<li><a href="../id418443/index.html">GObject: enkapsulasi, instantiasi, introspeksi</a></li>
<li><a href="../id418445/index.html">Django Channels - jawaban untuk web modern</a></li>
<li><a href="../id418447/index.html">Mengapa Moscow Python Conf sekarang ++</a></li>
<li><a href="../id418451/index.html">Pelajaran pencetakan 3D. Dukungan efektif dan perubahan ketinggian lapisan dalam praktik dari 3Dtool</a></li>
<li><a href="../id418453/index.html">Pengamatan GRAVITY selanjutnya memvalidasi relativitas umum</a></li>
<li><a href="../id418455/index.html">Buka webinar "Spesialis yang memimpin: pengalaman pertama dan kesalahan"</a></li>
<li><a href="../id418457/index.html">Terima kasih posting: hari administrator sistem</a></li>
<li><a href="../id418459/index.html">Pengembangan scaler LVDS dengan dua antarmuka DisplayPort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>