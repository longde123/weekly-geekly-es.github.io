<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèπ üéÖ ‚õ±Ô∏è Sechseckkarten in Unity: Wasserkreislauf, Erosion, Biomes, zylindrische Karte üë®‚Äçüë®‚Äçüëß üòå ü§ß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenh√∂hen 

 Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen 

 Teile 8-11: Wasser, Landformen und W√§lle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sechseckkarten in Unity: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427567/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenh√∂hen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und W√§lle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 24: Regionen und Erosion </h1><br><ul><li>  F√ºgen Sie einen Wasserrand um die Karte hinzu. </li><li>  Wir teilen die Karte in mehrere Regionen. </li><li>  Wir verwenden Erosion, um Klippen abzuschneiden. </li><li>  Wir bewegen das Land, um das Relief zu gl√§tten. </li></ul><br>  Im vorigen Teil haben wir den Grundstein f√ºr die prozedurale Kartengenerierung gelegt.  Dieses Mal werden wir die Orte des m√∂glichen Auftretens von Land begrenzen und mit Erosion darauf einwirken. <br><br>  Dieses Tutorial wurde in Unity 2017.1.0 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>Trenne und glatte das Land.</i> <br><a name="habracut"></a><br><h2>  Kartenrand </h2><br>  Da wir Landfl√§chen zuf√§llig erh√∂hen, kann es vorkommen, dass Land den Rand der Karte ber√ºhrt.  Dies kann unerw√ºnscht sein.  Die wasserbegrenzte Karte enth√§lt eine nat√ºrliche Barriere, die Spieler daran hindert, sich dem Rand zu n√§hern.  Daher w√§re es sch√∂n, wenn wir dem Land verbieten w√ºrden, sich in der N√§he des Kartenrandes √ºber den Wasserspiegel zu erheben. <br><br><h3>  Randgr√∂√üe </h3><br>  Wie nah sollte das Land am Rand der Karte sein?  Es gibt keine richtige Antwort auf diese Frage, daher werden wir diesen Parameter anpassbar machen.  Wir werden der <code>HexMapGenerator</code> Komponente zwei Schieberegler <code>HexMapGenerator</code> , einen f√ºr R√§nder entlang der Kanten entlang der X-Achse und einen f√ºr R√§nder entlang der Z-Achse. So k√∂nnen wir einen breiteren Rand in einer der Dimensionen verwenden oder sogar einen Rand in nur einer Dimension erstellen.  Verwenden wir ein Intervall von 0 bis 10 mit einem Standardwert von 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Schieberegler f√ºr Kartenr√§nder.</i> <br><br><h3>  Wir begrenzen die Zentren von Landfl√§chen </h3><br>  Ohne Rahmen sind alle Zellen g√ºltig.  Wenn es Grenzen gibt, nehmen die minimal zul√§ssigen Versatzkoordinaten zu und die maximal zul√§ssigen Koordinaten ab.  Da wir zum Generieren der Diagramme das zul√§ssige Intervall kennen m√ºssen, verfolgen wir es anhand von vier ganzzahligen Feldern. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Wir initialisieren die Einschr√§nkungen in <code>GenerateMap</code> bevor wir Sushi erstellen.  Wir verwenden diese Werte als Parameter f√ºr <code>Random.Range</code> Aufrufe, sodass die H√∂hen tats√§chlich au√üergew√∂hnlich sind.  Ohne Rand sind sie gleich der Anzahl der Messzellen, also nicht minus 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); ‚Ä¶ }</code> </pre> <br>  Wir werden das Erscheinen von Land jenseits der Grenze nicht strikt verbieten, da dies zu scharf geschnittenen Kanten f√ºhren w√ºrde.  Stattdessen beschr√§nken wir nur die Zellen, die zum Starten der Erstellung von Plots verwendet werden.  Das hei√üt, die ungef√§hren Zentren der Standorte werden begrenzt sein, aber Teile der Standorte k√∂nnen √ºber das Grenzgebiet hinausgehen.  Dies kann durch √Ñndern von <code>GetRandomCell</code> sodass eine Zelle im Bereich der zul√§ssigen Offsets ausgew√§hlt wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>Die R√§nder der Karte sind 0 √ó 0, 5 √ó 5, 10 √ó 10 und 0 √ó 10.</i> <br><br>  Wenn alle Kartenparameter auf ihre Standardwerte eingestellt sind, sch√ºtzt ein Rand der Gr√∂√üe 5 den Rand der Karte zuverl√§ssig vor Landber√ºhrungen.  Dies ist jedoch nicht garantiert.  Das Land kann sich manchmal dem Rand n√§hern und es manchmal an mehreren Stellen ber√ºhren. <br><br>  Die Wahrscheinlichkeit, dass Land die gesamte Grenze √ºberschreitet, h√§ngt von der Gr√∂√üe der Grenze und der maximalen Gr√∂√üe des Standorts ab.  Ohne zu z√∂gern bleiben die Abschnitte Sechsecke.  Volles Sechseck mit Radius <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> r </script>  enth√§lt <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.32ex" height="2.539ex" viewBox="0 -935.7 5304.3 1093.4" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="1628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="2628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="3129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="3803" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="4803" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 3r ^ 2 + 3r + 1 </script>  Zellen.  Wenn es Sechsecke mit einem Radius gibt, der der Gr√∂√üe des Randes entspricht, k√∂nnen sie diesen √ºberqueren.  Ein volles Sechseck mit einem Radius von 5 enth√§lt 91 Zellen.  Da das Maximum standardm√§√üig 100 Zellen pro Abschnitt betr√§gt, bedeutet dies, dass Land eine Br√ºcke √ºber 5 Zellen legen kann, insbesondere wenn Vibrationen auftreten.  Um dies zu verhindern, verringern Sie entweder die maximale Gr√∂√üe des Diagramms oder vergr√∂√üern Sie den Rand. <br><br><div class="spoiler">  <b class="spoiler_title">Wie wird die Formel f√ºr die Anzahl der Zellen in der hexagonalen Region abgeleitet?</b> <div class="spoiler_text">  Bei einem Radius von 0 handelt es sich um eine einzelne Zelle.  Es kam von 1. Mit einem Radius von 1 um die Mitte gibt es sechs zus√§tzliche Zellen, das hei√üt <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.165ex" height="2.211ex" viewBox="0 -772.3 2223.9 952" role="img" focusable="false" style="vertical-align: -0.417ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="722" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="1723" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 6 + 1 </script>  .  Diese sechs Zellen k√∂nnen als die Enden von sechs Dreiecken betrachtet werden, die die Mitte ber√ºhren.  Mit einem Radius von 2 wird diesen Dreiecken eine zweite Reihe hinzugef√ºgt, dh zwei weitere Zellen werden auf dem Dreieck erhalten, und insgesamt <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.14ex" height="2.762ex" viewBox="0 -831.5 5226.9 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="3113" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="3725" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="4726" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> 6 (1 + 2) + 1 </script>  .  Mit einem Radius von 3 wird eine dritte Zeile hinzugef√ºgt, dh drei weitere Zellen pro Dreieck und insgesamt <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.143ex" height="2.762ex" viewBox="0 -831.5 6950.3 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="3336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="4336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="4837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="5449" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="6449" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> 6 (1 + 2 + 3) + 1 </script>  .  Usw.  Das hei√üt, im Allgemeinen sieht die Formel so aus <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mo stretchy=&quot;false&quot;>(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="73.646ex" height="3.312ex" viewBox="0 -950 31708.4 1426" role="img" focusable="false" aria-hidden="true" style="vertical-align: -1.106ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-73" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-75" x="1359" y="0"></use><g transform="translate(1932,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="1242" y="-264"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-69" x="3185" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-3D" x="3809" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="4865" y="0"></use><g transform="translate(5365,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-69" x="6174" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="6520" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="7131" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="8132" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-3D" x="8910" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="9967" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="10467" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="10857" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="11246" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="11698" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="12087" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="12761" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="13762" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="14213" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="14603" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2F" x="14992" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="15493" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="15993" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="16605" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="17606" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-3D" x="18384" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="19440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="19941" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="20392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="20782" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="21455" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="22456" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="22957" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="23568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="24569" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-3D" x="25347" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="26404" y="0"></use><g transform="translate(26904,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="28032" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="29032" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="29533" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="30207" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="31207" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mo stretchy="false">(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-6"> 6 (sum_ (i = 1) ^ r i) +1 = 6 ((r (r + r)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 </script>  . </div></div><br>  Um dies klarer zu sehen, k√∂nnen wir die Rahmengr√∂√üe auf 200 einstellen. Da ein volles Sechseck mit einem Radius von 8 217 Zellen enth√§lt, ber√ºhrt Land wahrscheinlich den Rand der Karte.  Zumindest wenn Sie den Standardwert f√ºr die Rahmengr√∂√üe (5) verwenden.  Wenn Sie den Rand auf 10 erh√∂hen, verringert sich die Wahrscheinlichkeit erheblich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>Das Grundst√ºck hat eine konstante Gr√∂√üe von 200, die R√§nder der Karte sind 5 und 10.</i> <br><br><h3>  Pangaea </h3><br>  Beachten Sie, dass wir das Land zwingen, eine kleinere Fl√§che zu bilden, wenn Sie den Kartenrand vergr√∂√üern und den gleichen Prozentsatz an Land beibehalten.  Infolgedessen erzeugt eine gro√üe Karte standardm√§√üig sehr wahrscheinlich eine einzige gro√üe Landmasse - den Superkontinent Pangaea - m√∂glicherweise mit mehreren kleinen Inseln.  Mit zunehmender Gr√∂√üe der Grenze steigt die Wahrscheinlichkeit, dass dies geschieht, und bei bestimmten Werten ist fast garantiert, dass wir einen Superkontinent bekommen.  Wenn jedoch der Landanteil zu gro√ü ist, f√ºllen sich die meisten verf√ºgbaren Fl√§chen und als Ergebnis erhalten wir eine fast rechteckige Landmasse.  Um dies zu verhindern, m√ºssen Sie den Landanteil reduzieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>40% Sushi mit einem Kartenrand von 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Woher kommt der Name Pangaea?</b> <div class="spoiler_text">  Das war der Name des letzten bekannten Superkontinents, der vor vielen Jahren auf der Erde existierte.  Der Name besteht aus den griechischen W√∂rtern pan und Gaia und bedeutet so etwas wie "alle Natur" oder "alles Land". </div></div><br><br><h3>  Wir sch√ºtzen vor unm√∂glichen Karten </h3><br>  Wir erzeugen die richtige Menge Land, indem wir das Land einfach weiter anheben, bis wir die gew√ºnschte Landmasse erreicht haben.  Dies funktioniert, weil wir fr√ºher oder sp√§ter jede Zelle auf dem Wasserspiegel anheben werden.  Wenn Sie jedoch den Rand der Karte verwenden, k√∂nnen wir nicht jede Zelle erreichen.  Wenn ein zu hoher Prozentsatz an Land ben√∂tigt wird, f√ºhrt dies zu endlosen ‚ÄûVersuchen und Fehlern‚Äú des Generators, mehr Land zu heben, und es bleibt in einem endlosen Zyklus stecken.  In diesem Fall friert die Anwendung ein, dies sollte jedoch nicht geschehen. <br><br>  Wir k√∂nnen unm√∂gliche Konfigurationen nicht zuverl√§ssig im Voraus finden, aber wir k√∂nnen uns vor endlosen Zyklen sch√ºtzen.  Wir werden einfach die Anzahl der in <code>CreateLand</code> ausgef√ºhrten Zyklen <code>CreateLand</code> .  Wenn es zu viele Iterationen gibt, stecken wir h√∂chstwahrscheinlich fest und sollten aufh√∂ren. <br><br>  F√ºr eine gro√üe Karte scheinen tausend Iterationen akzeptabel zu sein, und zehntausend Iterationen scheinen bereits absurd.  Verwenden wir diesen Wert also als Endpunkt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); ‚Ä¶ } }</span></span></code> </pre> <br>  Wenn wir eine besch√§digte Karte erhalten, nehmen 10.000 Iterationen nicht viel Zeit in Anspruch, da viele Zellen schnell die maximale H√∂he erreichen, wodurch das Wachstum neuer Bereiche verhindert wird. <br><br>  Selbst nach dem Durchbrechen der Schleife erhalten wir immer noch die richtige Karte.  Es gibt einfach nicht die richtige Menge an Sushi und es wird nicht sehr interessant aussehen.  Lassen Sie uns eine Benachrichtigung dar√ºber in der Konsole anzeigen und uns mitteilen, welches verbleibende Land wir nicht ausgegeben haben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>95% des Landes mit einer Kartengrenze von 10 konnten nicht den gesamten Betrag ausgeben.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Warum weist eine fehlerhafte Karte immer noch Abweichungen auf?</b> <div class="spoiler_text">  Die K√ºste ist variabel, denn wenn die H√∂hen innerhalb des Erstellungsbereichs zu hoch werden, k√∂nnen sie in neuen Bereichen nicht nach au√üen wachsen.  Das gleiche Prinzip erlaubt es Parzellen nicht, in kleine Landfl√§chen zu wachsen, bis sie die maximale H√∂he erreicht haben und sich einfach als vermisst herausstellen.  Au√üerdem nimmt die Variabilit√§t beim Absenken der Diagramme zu. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Eine Karte partitionieren </h2><br>  Nachdem wir den Kartenrand haben, haben wir die Karte im Wesentlichen in zwei separate Regionen unterteilt: die Grenzregion und die Region, in der die Diagramme erstellt wurden.  Da uns nur die Region der Sch√∂pfung wichtig ist, k√∂nnen wir einen solchen Fall als eine Situation mit einer Region betrachten.  Die Region deckt einfach nicht die gesamte Karte ab.  Wenn dies jedoch unm√∂glich ist, hindert uns nichts daran, die Karte in mehrere nicht zusammenh√§ngende Regionen der Landsch√∂pfung zu unterteilen.  Dadurch k√∂nnen sich Landmassen unabh√§ngig voneinander bilden und verschiedene Kontinente bestimmen. <br><br><h3>  Kartenregion </h3><br>  Beginnen wir damit, eine Region der Karte als Struktur zu beschreiben.  Dies wird unsere Arbeit mit mehreren Regionen vereinfachen.  Erstellen <code>MapRegion</code> hierf√ºr eine <code>MapRegion</code> Struktur, die einfach die Randfelder der Region enth√§lt.  Da wir diese Struktur nicht au√üerhalb von <code>HexMapGenerator</code> , k√∂nnen wir sie innerhalb dieser Klasse als private interne Struktur definieren.  Dann k√∂nnen vier ganzzahlige Felder durch ein <code>MapRegion</code> Feld ersetzt werden. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  Damit alles funktioniert, m√ºssen wir das Regionspr√§fix zu den Minimum-Maximum-Feldern in <code>GenerateMap</code> hinzuf√ºgen <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  Und auch in <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  Mehrere Regionen </h3><br>  Ersetzen Sie ein <code>MapRegion</code> Feld <code>MapRegion</code> Liste von Regionen, um mehrere Regionen zu unterst√ºtzen. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  An dieser Stelle w√§re es sch√∂n, eine separate Methode zum Erstellen von Regionen hinzuzuf√ºgen.  Es sollte die gew√ºnschte Liste erstellen oder l√∂schen, falls sie bereits vorhanden ist.  Danach bestimmt er wie zuvor eine Region und f√ºgt sie der Liste hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Wir werden diese Methode in <code>GenerateMap</code> aufrufen und die Region nicht direkt erstellen. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  Damit <code>GetRandomCell</code> mit einer beliebigen Region arbeiten kann, geben Sie ihm den <code>MapRegion</code> Parameter. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Jetzt sollten die <code>SinkTerrain</code> <code>RaiseTerraion</code> und <code>SinkTerrain</code> die entsprechende Region an <code>GetRandomCell</code> .  Dazu ben√∂tigt jeder von ihnen auch einen Regionsparameter. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ }</code> </pre> <br>  Die <code>CreateLand</code> Methode sollte f√ºr jede Region festlegen, dass die Abschnitte <code>CreateLand</code> oder <code>CreateLand</code> werden sollen.  Um das Land zwischen den Regionen auszugleichen, werden wir einfach wiederholt die Liste der Regionen im Zyklus durchgehen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  Wir m√ºssen jedoch die Absenkung der Parzellen gleichm√§√üig verteilen.  Dies kann erfolgen, w√§hrend f√ºr alle Regionen entschieden wird, ob sie weggelassen werden sollen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Um genau die gesamte Landmenge zu nutzen, m√ºssen wir den Prozess stoppen, sobald die Menge Null erreicht.  Dies kann in jeder Phase des Zyklus der Region geschehen.  Daher verschieben wir die Nullsummenpr√ºfung in die innere Schleife.  Tats√§chlich k√∂nnen wir diese √úberpr√ºfung nur durchf√ºhren, nachdem wir Land angehoben haben, da beim Absenken der Betrag niemals ausgegeben wird.  Wenn wir fertig sind, k√∂nnen wir die <code>CreateLand</code> Methode sofort <code>CreateLand</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Zwei Regionen </h3><br>  Obwohl wir jetzt die Unterst√ºtzung mehrerer Regionen haben, fragen wir immer noch nur eine.  √Ñndern Sie die <code>CreateRegions</code> so, dass die Karte vertikal in zwei <code>CreateRegions</code> .  Dazu halbieren wir den <code>xMax</code> Wert der hinzugef√ºgten Region.  Dann verwenden wir denselben Wert f√ºr <code>xMin</code> und erneut den urspr√ºnglichen Wert f√ºr <code>xMax</code> , wobei <code>xMax</code> ihn als zweiten Bereich verwenden. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  Das Generieren von Karten in dieser Phase macht keinen Unterschied.  Obwohl wir zwei Regionen identifiziert haben, besetzen sie dieselbe Region wie eine alte Region.  Um sie auseinander zu verteilen, m√ºssen Sie einen leeren Raum zwischen ihnen lassen.  Dies kann durch Hinzuf√ºgen eines Schiebereglers zum Rand der Region erfolgen, wobei das gleiche Intervall und der gleiche Standardwert wie f√ºr die R√§nder der Karte verwendet werden. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Regionsrand-Schieberegler.</i> <br><br>  Da Land auf beiden Seiten des Raums zwischen Regionen gebildet werden kann, steigt die Wahrscheinlichkeit, Landbr√ºcken an den R√§ndern der Karte zu erstellen.  Um dies zu verhindern, verwenden wir den Rand der Region, um eine landfreie Zone zwischen der Trennlinie und der Region zu definieren, in der die Diagramme beginnen k√∂nnen.  Dies bedeutet, dass der Abstand zwischen benachbarten Regionen zwei gr√∂√üer ist als die Gr√∂√üe der Region. <br><br>  Um diese Bereichsgrenze anzuwenden, subtrahieren Sie sie vom <code>xMax</code> ersten Region und f√ºgen Sie die zweite Region zu <code>xMin</code> . <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>Die Karte ist vertikal in zwei Regionen unterteilt.</i> <br><br>  Mit den Standardeinstellungen werden zwei deutlich getrennte Regionen erstellt. Wie bei einer Region und einem gro√üen Kartenrand wird jedoch nicht garantiert, dass wir genau zwei Landmassen erhalten.  Meistens sind es zwei gro√üe Kontinente, m√∂glicherweise mit mehreren Inseln.  Manchmal k√∂nnen jedoch zwei oder mehr gro√üe Inseln in einer Region erstellt werden.  Und manchmal k√∂nnen zwei Kontinente durch eine Landenge verbunden werden. <br><br>  Nat√ºrlich k√∂nnen wir die Karte auch horizontal teilen und die Ans√§tze f√ºr die Messung von X und Z √§ndern. W√§hlen wir zuf√§llig eine von zwei m√∂glichen Ausrichtungen. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Karte horizontal in zwei Regionen unterteilt.</i> <br><br>  Da wir eine breite Karte verwenden, werden breitere und d√ºnnere Regionen mit horizontaler Trennung erstellt.  Infolgedessen bilden diese Regionen mit gr√∂√üerer Wahrscheinlichkeit mehrere geteilte Landmassen. <br><br><h3>  Vier Regionen </h3><br>  Lassen Sie uns die Anzahl der Regionen anpassbar machen und Unterst√ºtzung von 1 bis 4 Regionen erstellen. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Schieberegler f√ºr die Anzahl der Regionen.</i> <br><br>  Mit der <code>switch</code> k√∂nnen wir die Ausf√ºhrung des entsprechenden Regionalcodes ausw√§hlen.  Wir beginnen mit der Wiederholung des Codes f√ºr eine Region, die standardm√§√üig verwendet wird, und belassen den Code f√ºr die beiden Regionen f√ºr Fall 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was ist die switch-Anweisung?</b> <div class="spoiler_text">  Dies ist eine Alternative zum Schreiben einer Folge von if-else-if-else-Anweisungen.  Der Schalter wird auf die Variable angewendet, und Beschriftungen geben an, welcher Code ausgef√ºhrt werden muss.  Es gibt auch eine <code>default</code> , die als letzter <code>else</code> Block verwendet wird.  Jede Option muss entweder mit einer <code>break</code> Anweisung oder einer <code>return</code> enden. <br><br>  Um den <code>switch</code> lesbar zu halten, ist es normalerweise am besten, alle F√§lle kurz zu halten, idealerweise mit einer einzelnen Anweisung oder einem Methodenaufruf.  Ich werde dies nicht als Beispiel f√ºr einen Regionalcode tun, aber wenn Sie interessantere Regionen erstellen m√∂chten, empfehle ich, separate Methoden zu verwenden.  Zum Beispiel: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Drei Regionen √§hneln zwei, nur Drittel werden anstelle der H√§lfte verwendet.  In diesem Fall werden durch die horizontale Unterteilung zu enge Bereiche erstellt, sodass nur die vertikale Unterteilung unterst√ºtzt wird.  Beachten Sie, dass wir dadurch den Grenzbereich der Region verdoppelt haben, sodass der Platz zum Erstellen neuer Websites geringer ist als bei zwei Regionen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Drei Regionen.</i> <br><br>  Es k√∂nnen vier Regionen erstellt werden, indem die horizontale und vertikale Trennung kombiniert und jeder Ecke der Karte eine Region hinzugef√ºgt wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Vier Regionen.</i> <br><br>  Der hier verwendete Ansatz ist der einfachste Weg, eine Karte zu teilen.  Es erzeugt ungef√§hr die gleichen Regionen nach Landmasse, und ihre Variabilit√§t wird durch andere Parameter der Kartenerzeugung gesteuert.  Es wird jedoch immer ziemlich offensichtlich sein, dass die Karte in gerade Linien geteilt wurde.  Je mehr Kontrolle wir brauchen, desto weniger organisch wird das Ergebnis aussehen.  Daher ist dies normal, wenn Sie f√ºr das Gameplay ungef√§hr gleiche Regionen ben√∂tigen.  Wenn Sie jedoch das abwechslungsreichste und unbegrenzteste Land ben√∂tigen, m√ºssen Sie es mit Hilfe einer Region schaffen. <br><br>  Dar√ºber hinaus gibt es andere M√∂glichkeiten, die Karte zu teilen.  Wir k√∂nnen uns nicht nur auf gerade Linien beschr√§nken.  Wir m√ºssen nicht einmal Regionen gleicher Gr√∂√üe verwenden und die gesamte Karte damit abdecken.  Wir k√∂nnen L√∂cher hinterlassen.  Sie k√∂nnen auch Schnittpunkte von Regionen zulassen oder die Landverteilung zwischen Regionen √§ndern.  Sie k√∂nnen sogar Ihre eigenen Generatorparameter f√ºr jede Region festlegen (obwohl dies komplizierter ist), um beispielsweise einen gro√üen Kontinent und einen Archipel auf der Karte zu haben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Erosion </h2><br>  Bisher sahen alle Karten, die wir generiert haben, ziemlich unh√∂flich und kaputt aus.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine echte Erleichterung mag so aussehen, aber mit der Zeit wird sie immer glatter, und ihre scharfen Teile werden durch Erosion stumpf. </font><font style="vertical-align: inherit;">Um die Karten zu verbessern, k√∂nnen wir diesen Erosionsprozess anwenden. </font><font style="vertical-align: inherit;">Wir werden dies tun, nachdem wir raues Land in einer separaten Methode geschaffen haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosionsprozentsatz </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je mehr Zeit vergeht, desto mehr Erosion tritt auf. </font><font style="vertical-align: inherit;">Daher m√∂chten wir, dass die Erosion nicht dauerhaft, sondern anpassbar ist. </font><font style="vertical-align: inherit;">Die Erosion ist mindestens Null, was den zuvor erstellten Karten entspricht. </font><font style="vertical-align: inherit;">Bei maximaler Erosion ist umfassend, dh die weitere Anwendung von Erosionskr√§ften ver√§ndert das Gel√§nde nicht mehr. </font><font style="vertical-align: inherit;">Das hei√üt, der Erosionsparameter sollte ein Prozentsatz von 0 bis 100 sein, und standardm√§√üig nehmen wir 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosionsschieber.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach erosionszerst√∂renden Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosion macht das Relief glatter. In unserem Fall sind die einzigen scharfen Teile die Klippen. Daher werden sie das Ziel des Erosionsprozesses sein. Wenn eine Klippe vorhanden ist, sollte sie durch Erosion verringert werden, bis sie schlie√ülich zu einem Hang wird. Wir werden die Pisten nicht gl√§tten, da dies zu einem langweiligen Gel√§nde f√ºhren wird. Dazu m√ºssen wir bestimmen, welche Zellen sich oben auf den Klippen befinden, und ihre H√∂he senken. Dies sind erosionsanf√§llige Zellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns eine Methode erstellen, die bestimmt, ob eine Zelle anf√§llig f√ºr Erosion ist. </font><font style="vertical-align: inherit;">Er ermittelt dies, indem er die Nachbarn der Zelle √ºberpr√ºft, bis er einen ausreichend gro√üen H√∂henunterschied findet. </font><font style="vertical-align: inherit;">Da Klippen einen H√∂henunterschied von mindestens einer oder zwei H√∂henstufen erfordern, ist die Zelle einer Erosion ausgesetzt, wenn sich einer oder mehrere ihrer Nachbarn mindestens zwei Stufen darunter befinden. </font><font style="vertical-align: inherit;">Wenn es keinen solchen Nachbarn gibt, kann die Zelle keine Erosion erfahren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen diese Methode verwenden </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um alle Zellen zu durchlaufen und alle erosionsanf√§lligen Zellen in eine tempor√§re Liste zu schreiben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald wir die Gesamtzahl der erosionsanf√§lligen Zellen kennen, k√∂nnen wir den Prozentsatz der Erosion verwenden, um die Anzahl der verbleibenden erosionsanf√§lligen Zellen zu bestimmen. </font><font style="vertical-align: inherit;">Wenn der Prozentsatz beispielsweise 50 betr√§gt, m√ºssen wir Erosionszellen erodieren, bis die H√§lfte der urspr√ºnglichen Menge √ºbrig bleibt. </font><font style="vertical-align: inherit;">Wenn der Prozentsatz 100 betr√§gt, werden wir nicht aufh√∂ren, bis wir alle erosionsanf√§lligen Zellen zerst√∂rt haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollten wir nicht nur Zellen ber√ºcksichtigen, die zu Landerosion neigen?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellreduktion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit einem naiven Ansatz und nehmen wir an, dass eine einfache Verringerung der H√∂he der durch Erosion zerst√∂rten Zellen dazu f√ºhrt, dass sie nicht mehr anf√§llig f√ºr Erosion sind. </font><font style="vertical-align: inherit;">Wenn dies wahr w√§re, k√∂nnten wir einfach zuf√§llige Zellen aus der Liste nehmen, ihre H√∂he verringern und sie dann aus der Liste entfernen. </font><font style="vertical-align: inherit;">Wir w√ºrden diesen Vorgang wiederholen, bis wir die gew√ºnschte Anzahl erosionsanf√§lliger Zellen erreicht haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die erforderliche Suche zu verhindern </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √ºberschreiben wir die aktuelle Zelle zuletzt in der Liste und l√∂schen dann das letzte Element. </font><font style="vertical-align: inherit;">Ihre Bestellung ist uns immer noch egal.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naive Abnahme von 0% und 100% erosionsanf√§lliger Zellen, Samenkarte 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosionsverfolgung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser naiver Ansatz erm√∂glicht es uns, Erosion anzuwenden, aber nicht im richtigen Ma√üe. </font><font style="vertical-align: inherit;">Dies geschieht, weil die Zelle nach einer Verringerung der H√∂he immer noch anf√§llig f√ºr Erosion bleiben kann. </font><font style="vertical-align: inherit;">Daher werden wir eine Zelle nur dann aus der Liste entfernen, wenn sie nicht mehr der Erosion ausgesetzt ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% Erosion unter Beibehaltung erosionsanf√§lliger Zellen in der Liste. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bekommen also eine viel st√§rkere Erosion, aber wenn wir 100% verwenden, werden wir immer noch nicht alle Klippen los. </font><font style="vertical-align: inherit;">Der Grund ist, dass nach dem Verringern der H√∂he der Zelle einer ihrer Nachbarn anf√§llig f√ºr Erosion werden kann. </font><font style="vertical-align: inherit;">Infolgedessen haben wir m√∂glicherweise mehr erosionsanf√§llige Zellen als urspr√ºnglich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Zelle abgesenkt haben, m√ºssen wir alle Nachbarn √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Wenn sie jetzt anf√§llig f√ºr Erosion sind, aber noch nicht auf der Liste stehen, m√ºssen Sie sie dort hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle erodierten Zellen werden weggelassen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir sparen viel Land </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt kann der Erosionsprozess fortgesetzt werden, bis alle Klippen verschwunden sind. Dies wirkt sich stark auf das Land aus. Der gr√∂√üte Teil der Landmasse verschwand und wir bekamen viel weniger als den Prozentsatz des ben√∂tigten Landes. Es ist passiert, weil wir Land von der Karte entfernen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wahre Erosion zerst√∂rt keine Materie. Sie nimmt es von einem Ort und platziert es woanders. Wir k√∂nnen das Gleiche tun. Mit einer Abnahme in einer Zelle m√ºssen wir einen ihrer Nachbarn gro√üziehen. Tats√§chlich wird eine H√∂henstufe auf eine untere Zelle √ºbertragen. Dies spart die Gesamtmenge der Kartenh√∂hen und gl√§ttet sie einfach.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu realisieren, m√ºssen wir entscheiden, wohin Erosionsprodukte √ºbertragen werden sollen. </font><font style="vertical-align: inherit;">Dies wird unser Erosionsziel sein. </font><font style="vertical-align: inherit;">Erstellen wir eine Methode, um den Zielpunkt einer zu erodierenden Zelle zu bestimmen. </font><font style="vertical-align: inherit;">Da diese Zelle eine Unterbrechung enth√§lt, w√§re es logisch, die unter dieser Unterbrechung befindliche Zelle als Ziel auszuw√§hlen. </font><font style="vertical-align: inherit;">Eine erosionsgef√§hrdete Zelle kann jedoch mehrere Pausen haben. Daher √ºberpr√ºfen wir alle Nachbarn und setzen alle Kandidaten auf eine tempor√§re Liste. Anschlie√üend w√§hlen wir zuf√§llig einen von ihnen aus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definieren wir die Zielzelle unmittelbar nach Auswahl der Erosionszelle. </font><font style="vertical-align: inherit;">Dann verringern und erh√∂hen wir die Zellh√∂hen unmittelbar nacheinander. </font><font style="vertical-align: inherit;">In diesem Fall kann die Zielzelle selbst anf√§llig f√ºr Erosion werden. Diese Situation wird jedoch behoben, wenn wir die Nachbarn der neu erodierten Zelle √ºberpr√ºfen.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir die Zielzelle angehoben haben, ist ein Teil der Nachbarn dieser Zelle m√∂glicherweise nicht mehr der Erosion ausgesetzt. </font><font style="vertical-align: inherit;">Es ist notwendig, um sie herumzugehen und zu pr√ºfen, ob sie anf√§llig f√ºr Erosion sind. </font><font style="vertical-align: inherit;">Wenn nicht, aber sie sind in der Liste enthalten, m√ºssen Sie sie daraus entfernen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% Erosion unter Beibehaltung der Landmasse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Erosion kann das Gel√§nde jetzt viel besser gegl√§ttet werden, indem einige Bereiche abgesenkt und andere angehoben werden. </font><font style="vertical-align: inherit;">Infolgedessen kann die Landmasse sowohl zunehmen als auch sich verengen. </font><font style="vertical-align: inherit;">Dies kann den Landanteil in der einen oder anderen Richtung um mehrere Prozent ver√§ndern, es treten jedoch selten schwerwiegende Abweichungen auf. </font><font style="vertical-align: inherit;">Das hei√üt, je mehr Erosion wir anwenden, desto weniger Kontrolle haben wir √ºber den resultierenden Prozentsatz an Land.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beschleunigte Erosion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir uns nicht wirklich um die Effektivit√§t des Erosionsalgorithmus k√ºmmern m√ºssen, k√∂nnen wir ihn einfach verbessern. </font><font style="vertical-align: inherit;">Beachten Sie zun√§chst, dass wir explizit pr√ºfen, ob die von uns erodierte Zelle erodiert werden kann. </font><font style="vertical-align: inherit;">Wenn nicht, entfernen wir es im Wesentlichen aus der Liste. </font><font style="vertical-align: inherit;">Daher k√∂nnen Sie das √úberpr√ºfen dieser Zelle √ºberspringen, wenn Sie die Nachbarn der Zielzelle durchlaufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens mussten wir die Nachbarn der Zielzelle nur √ºberpr√ºfen, wenn zwischen ihnen eine Pause bestand, aber jetzt ist dies nicht notwendig. </font><font style="vertical-align: inherit;">Dies geschieht nur, wenn der Nachbar jetzt einen Schritt h√∂her als die Zielzelle ist. </font><font style="vertical-align: inherit;">Wenn ja, ist der Nachbar garantiert auf der Liste, sodass wir dies nicht √ºberpr√ºfen m√ºssen, dh wir k√∂nnen die unn√∂tige Suche √ºberspringen.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drittens k√∂nnen wir einen √§hnlichen Trick anwenden, wenn wir die Nachbarn einer erosionsanf√§lligen Zelle √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Befindet sich jetzt eine Klippe zwischen ihnen, ist der Nachbar anf√§llig f√ºr Erosion. </font><font style="vertical-align: inherit;">Um das herauszufinden, m√ºssen wir nicht anrufen </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen jedoch noch pr√ºfen, ob die Zielzelle anf√§llig f√ºr Erosion ist, aber der oben gezeigte Zyklus tut dies nicht mehr. </font><font style="vertical-align: inherit;">Daher f√ºhren wir dies explizit f√ºr die Zielzelle durch.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Erosion schnell genug und auf den gew√ºnschten Prozentsatz im Verh√§ltnis zur anf√§nglichen Anzahl der erzeugten Klippen anwenden. </font><font style="vertical-align: inherit;">Beachten Sie, dass sich das Ergebnis aufgrund der Tatsache, dass wir die Stelle, an der die Zielzelle zur erosionsgef√§hrdeten Liste hinzugef√ºgt wird, geringf√ºgig ge√§ndert haben, gegen√ºber dem Ergebnis vor den Optimierungen geringf√ºgig ge√§ndert hat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% und 100% Erosion. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie auch, dass sich die Topologie trotz der ver√§nderten Form der K√ºste nicht grundlegend ge√§ndert hat. </font><font style="vertical-align: inherit;">Landmassen bleiben normalerweise entweder verbunden oder getrennt. </font><font style="vertical-align: inherit;">Nur kleine Inseln k√∂nnen vollst√§ndig ertrinken. </font><font style="vertical-align: inherit;">Die Reliefdetails werden gegl√§ttet, die allgemeinen Formen bleiben jedoch gleich. </font><font style="vertical-align: inherit;">Ein schmales Gelenk kann verschwinden oder ein wenig wachsen. </font><font style="vertical-align: inherit;">Eine kleine L√ºcke kann sich leicht f√ºllen oder ausdehnen. </font><font style="vertical-align: inherit;">Daher wird die Erosion die geteilten Regionen nicht stark zusammenhalten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vier vollst√§ndig erodierte Regionen bleiben immer noch getrennt. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 25: Der Wasserkreislauf </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie rohe Kartendaten an. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bilden ein Klima von Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie eine Teilsimulation des Wasserkreislaufs. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werden wir Feuchtigkeit an Land hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Tutorial wurde in Unity 2017.3.0 erstellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden den Wasserkreislauf, um Biomes zu bestimmen.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Wolken </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Punkt hat der Kartengenerierungsalgorithmus nur die Zellenh√∂he ge√§ndert. </font><font style="vertical-align: inherit;">Der gr√∂√üte Unterschied zwischen den Zellen bestand darin, ob sie sich √ºber oder unter Wasser befanden. </font><font style="vertical-align: inherit;">Obwohl wir verschiedene Gel√§ndetypen definieren k√∂nnen, ist dies nur eine einfache Visualisierung der H√∂he. </font><font style="vertical-align: inherit;">Angesichts des lokalen Klimas ist es besser, die Arten der Erleichterung anzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Erdklima ist ein sehr komplexes System. </font><font style="vertical-align: inherit;">Gl√ºcklicherweise m√ºssen wir keine realistischen Klimasimulationen erstellen. </font><font style="vertical-align: inherit;">Wir werden etwas brauchen, das nat√ºrlich genug aussieht. </font><font style="vertical-align: inherit;">Der wichtigste Aspekt des Klimas ist der Wasserkreislauf, denn Flora und Fauna ben√∂tigen fl√ºssiges Wasser, um zu √ºberleben. </font><font style="vertical-align: inherit;">Die Temperatur ist ebenfalls sehr wichtig, aber im Moment konzentrieren wir uns auf Wasser, wobei die globale Temperatur im Wesentlichen konstant bleibt und nur die Luftfeuchtigkeit ge√§ndert wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wasserkreislauf beschreibt die Bewegung von Wasser in der Umwelt. </font><font style="vertical-align: inherit;">Einfach ausgedr√ºckt, die Teiche verdunsten, was zur Bildung von Regenwolken f√ºhrt, die wieder in die Teiche flie√üen. </font><font style="vertical-align: inherit;">Das System hat viel mehr Aspekte, aber die Simulation dieser Schritte kann bereits ausreichen, um eine nat√ºrlich aussehende Wasserverteilung auf der Karte zu erzielen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenvisualisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir mit dieser Simulation beginnen, ist es hilfreich, die relevanten Daten direkt anzuzeigen. </font><font style="vertical-align: inherit;">Dazu √§ndern wir den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir f√ºgen ihm eine umschaltbare Eigenschaft hinzu, die in den Datenvisualisierungsmodus umgeschaltet werden kann, in dem anstelle der √ºblichen Relieftexturen Rohkartendaten angezeigt werden. </font><font style="vertical-align: inherit;">Dies kann mithilfe einer float-Eigenschaft mit einem umschaltbaren Attribut implementiert werden, das das Schl√ºsselwort definiert. </font><font style="vertical-align: inherit;">Aus diesem Grund wird es im Materialinspektor als Flag angezeigt, das die Definition eines Schl√ºsselworts steuert. </font><font style="vertical-align: inherit;">Der Name der Immobilie selbst ist nicht wichtig, wir interessieren uns nur f√ºr das Schl√ºsselwort. </font><font style="vertical-align: inherit;">Wir verwenden </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wechseln Sie zur Anzeige der Kartendaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine Shader-Funktion hinzu, um die Keyword-Unterst√ºtzung zu aktivieren.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden daf√ºr sorgen, dass ein einzelner Float angezeigt wird, wie dies bei den √ºbrigen Reliefdaten der Fall ist. </font><font style="vertical-align: inherit;">Um dies zu implementieren, f√ºgen wir der Struktur ein </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld hinzu </font><font style="vertical-align: inherit;">, </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn das Schl√ºsselwort definiert ist.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Vertex-Programm verwenden wir den Z-Kanal dieser Zellen zum Ausf√ºllen </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie immer zwischen Zellen interpoliert.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Zelldaten anzeigen m√ºssen, verwenden Sie diese direkt als Albedofragment anstelle der √ºblichen Farbe. </font><font style="vertical-align: inherit;">Multiplizieren Sie es mit dem Raster, damit das Raster beim Rendern der Daten weiterhin aktiviert ist.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Daten tats√§chlich an einen Shader zu √ºbertragen. </font><font style="vertical-align: inherit;">Wir m√ºssen der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">hinzuf√ºgen, die </font><font style="vertical-align: inherit;">etwas in den blauen Texturdatenkanal schreibt. </font><font style="vertical-align: inherit;">Daten sind ein einzelner Gleitkommawert, der auf 0‚Äì1 begrenzt ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Entscheidung wirkt sich jedoch auf das Forschungssystem aus. </font><font style="vertical-align: inherit;">Ein blauer Kanaldatenwert 255 wird verwendet, um anzuzeigen, dass sich die Sichtbarkeit der Zelle im √úbergang befindet. </font><font style="vertical-align: inherit;">Damit dieses System weiterhin funktioniert, m√ºssen wir maximal den Bytewert 254 verwenden. Beachten Sie, dass durch die Bewegung der Abteilung alle Kartendaten gel√∂scht werden. Dies passt jedoch zu uns, da sie zum Debuggen der Kartengenerierung verwendet werden.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine Methode mit demselben Namen und in hinzu </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Anforderung wird an die Shader-Daten √ºbertragen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Funktionsweise des Codes zu √ºberpr√ºfen, √§ndern wir ihn </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass die Daten jeder Zelle der Karte festgelegt werden. </font><font style="vertical-align: inherit;">Lassen Sie uns die H√∂he visualisieren, die im Intervall 0‚Äì1 von Integer in Float konvertiert wurde. </font><font style="vertical-align: inherit;">Dies erfolgt durch Subtrahieren der minimalen H√∂he von der Zellenh√∂he, gefolgt vom Teilen durch die maximale H√∂he minus die minimale. </font><font style="vertical-align: inherit;">Lassen Sie uns die Division Gleitkomma machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir zwischen normalen Erleichterung und Visualisierung von Daten mit Hilfe der Kontrollk√§stchen wechseln k√∂nnen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte zeigen Daten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inventar Material </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte 1208905299, normales Gel√§nde und H√∂henvisualisierung.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klimasch√∂pfung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Klima zu simulieren, m√ºssen wir Klimadaten verfolgen. </font><font style="vertical-align: inherit;">Da die Karte aus diskreten Zellen besteht, hat jede von ihnen ihr eigenes lokales Klima. </font><font style="vertical-align: inherit;">Erstellen Sie eine Struktur </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Speichern aller relevanten Daten. </font><font style="vertical-align: inherit;">Nat√ºrlich k√∂nnen Sie den Zellen selbst Daten hinzuf√ºgen, aber wir werden sie nur beim Generieren der Karte verwenden. </font><font style="vertical-align: inherit;">Daher werden wir sie separat speichern. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir diese Struktur intern definieren k√∂nnen </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie z </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir beginnen damit, nur Wolken zu verfolgen, die mit einem einzigen Float-Feld implementiert werden k√∂nnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie eine Liste hinzu, um Klimadaten f√ºr alle Zellen zu verfolgen. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt brauchen wir eine Methode, um eine Klimakarte zu erstellen. </font><font style="vertical-align: inherit;">Zun√§chst sollte die Liste der Klimazonen gel√∂scht und dann f√ºr jede Zelle ein Element hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">Die anf√§nglichen Klimadaten sind einfach Null, dies kann mit einem Standardkonstruktor erreicht werden </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Klima sollte nach der Exposition gegen√ºber Landerosion geschaffen werden, bevor die Arten von Reliefs festgelegt werden. </font><font style="vertical-align: inherit;">In Wirklichkeit wird Erosion haupts√§chlich durch die Bewegung von Luft und Wasser verursacht, die Teil des Klimas sind, aber wir werden dies nicht simulieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie dies </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass Cloud-Daten anstelle der Zellenh√∂he angezeigt werden. </font><font style="vertical-align: inherit;">Anfangs sieht es aus wie eine schwarze Karte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klima √§ndern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schritt in der Klimasimulation ist die Verdunstung. </font><font style="vertical-align: inherit;">Wie viel Wasser sollte verdunsten? </font><font style="vertical-align: inherit;">Lassen Sie uns diesen Wert mit dem Schieberegler steuern. </font><font style="vertical-align: inherit;">Ein Wert von 0 bedeutet keine Verdunstung, 1 - maximale Verdunstung. </font><font style="vertical-align: inherit;">Standardm√§√üig verwenden wir 0,5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdunstungsschieber. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns eine andere Methode speziell zur Gestaltung des Klimas einer Zelle entwickeln. </font><font style="vertical-align: inherit;">Wir geben ihm den Zellindex als Parameter und verwenden ihn, um die entsprechende Zelle und ihre Klimadaten zu erhalten. </font><font style="vertical-align: inherit;">Befindet sich die Zelle unter Wasser, handelt es sich um ein Reservoir, das verdunsten muss. </font><font style="vertical-align: inherit;">Wir verwandeln den Dampf sofort in Wolken (ohne Ber√ºcksichtigung der Taupunkte und der Kondensation), sodass wir den Wert der Zellwolken direkt verdampfen. </font><font style="vertical-align: inherit;">Wenn Sie damit fertig sind, kopieren Sie die Klimadaten zur√ºck in die Liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie diese Methode f√ºr jede Zelle in auf </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das reicht aber nicht. </font><font style="vertical-align: inherit;">Um eine komplexe Simulation zu erstellen, m√ºssen wir das Klima der Zellen mehrmals formen. </font><font style="vertical-align: inherit;">Je √∂fter wir dies tun, desto besser wird das Ergebnis sein. </font><font style="vertical-align: inherit;">W√§hlen wir einfach einen konstanten Wert. </font><font style="vertical-align: inherit;">Ich benutze 40 Zyklen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da wir zwar nur den Wert der Wolken √ºber den mit Wasser √ºberfluteten Zellen erh√∂hen, erhalten wir dadurch schwarzes Land und wei√üe Stauseen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdunstung √ºber Wasser.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wolkenstreuung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolken sind nicht st√§ndig an einem Ort, besonders wenn immer mehr Wasser verdunstet. </font><font style="vertical-align: inherit;">Der Druckunterschied bewirkt, dass sich die Luft bewegt, was sich in Form von Wind manifestiert, wodurch sich auch die Wolken bewegen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es keine dominante Windrichtung gibt, verteilen sich die Zellwolken im Durchschnitt gleichm√§√üig in alle Richtungen und erscheinen in benachbarten Zellen. </font><font style="vertical-align: inherit;">Wenn Sie im n√§chsten Zyklus neue Wolken erzeugen, verteilen wir alle Wolken in der Zelle auf die Nachbarn. </font><font style="vertical-align: inherit;">Das hei√üt, jeder Nachbar erh√§lt ein Sechstel aus den Zellwolken, wonach es zu einer lokalen Abnahme auf Null kommt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um Ihren Nachbarn tats√§chlich Wolken hinzuzuf√ºgen, m√ºssen Sie sie in einer Schleife umgehen, ihre Klimadaten abrufen, den Wert der Wolken erh√∂hen und sie zur√ºck in die Liste kopieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolken streuen.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dadurch entsteht eine fast wei√üe Karte, da Unterwasserzellen mit jedem Zyklus mehr und mehr Wolken zum globalen Klima hinzuf√ºgen. Nach dem ersten Zyklus haben Landzellen neben Wasser auch Wolken, die verteilt werden m√ºssen. Dieser Vorgang wird fortgesetzt, bis der gr√∂√üte Teil der Karte mit Wolken bedeckt ist. Bei der Karte 1208905299 mit den Standardparametern blieb nur der innere Teil der gro√üen Landmasse im Nordosten vollst√§ndig unbedeckt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass Teiche unendlich viele Wolken erzeugen k√∂nnen. </font><font style="vertical-align: inherit;">Der Wasserstand ist nicht Teil der Klimasimulation. </font><font style="vertical-align: inherit;">In der Realit√§t bleiben Stauseen nur erhalten, weil Wasser mit etwa der Verdunstungsrate in sie zur√ºckflie√üt. </font><font style="vertical-align: inherit;">Das hei√üt, wir simulieren nur einen Teilwasserkreislauf. </font><font style="vertical-align: inherit;">Dies ist normal, aber wir m√ºssen verstehen, je l√§nger die Simulation stattfindet, desto mehr Wasser wird dem Klima hinzugef√ºgt. </font><font style="vertical-align: inherit;">Bisher tritt Wasserverlust nur an den R√§ndern der Karte auf, wo verstreute Wolken aufgrund des Mangels an Nachbarn verloren gehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen den Wasserverlust oben auf der Karte sehen, insbesondere in den Zellen oben rechts. </font><font style="vertical-align: inherit;">In der letzten Zelle gibt es √ºberhaupt keine Wolken, weil es die letzte bleibt, in der sich das Klima bildet. </font><font style="vertical-align: inherit;">Sie hat noch keine Wolken von einem Nachbarn erhalten.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollte sich nicht das Klima aller Zellen parallel bilden?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3>  Niederschlag </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser bleibt nicht f√ºr immer kalt. Irgendwann sollte sie wieder zu Boden fallen. Dies geschieht normalerweise in Form von Regen, aber manchmal kann es Schnee, Hagel oder nasser Schnee sein. All dies wird allgemein als Niederschlag bezeichnet. Das Ausma√ü und die Rate des Verschwindens von Wolken variieren stark, aber wir verwenden nur eine benutzerdefinierte globale Niederschlagsrate. Ein Wert von 0 bedeutet kein Niederschlag, ein Wert von 1 bedeutet, dass alle Wolken sofort verschwinden. Der Standardwert ist 0,25. Dies bedeutet, dass in jedem Zyklus ein Viertel der Wolken verschwindet.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regler f√ºr den Niederschlagskoeffizienten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden Niederschl√§ge nach der Verdunstung und vor der Wolkenstreuung simulieren. </font><font style="vertical-align: inherit;">Dies bedeutet, dass ein Teil des aus den Reservoirs verdampften Wassers sofort ausf√§llt, sodass die Anzahl der sich zerstreuenden Wolken abnimmt. </font><font style="vertical-align: inherit;">√úber Land f√ºhrt Niederschlag zum Verschwinden von Wolken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschwindende Wolken. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jetzt in jedem Zyklus 25% der Wolken zerst√∂ren, ist das Land wieder fast schwarz. </font><font style="vertical-align: inherit;">Die Wolken bewegen sich nur wenige Schritte landeinw√§rts und werden dann unsichtbar. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2>  Luftfeuchtigkeit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl Regen Wolken zerst√∂rt, sollten sie dem Klima kein Wasser entziehen. </font><font style="vertical-align: inherit;">Nach dem Sturz auf den Boden wird Wasser nur in einem anderen Zustand gespeichert. </font><font style="vertical-align: inherit;">Es kann in vielen Formen existieren, die wir allgemein als Feuchtigkeit betrachten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Feuchtigkeitsverfolgung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden das Klimamodell verbessern, indem wir zwei Wasserbedingungen verfolgen: Wolken und Feuchtigkeit. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu das </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld </font><font style="vertical-align: inherit;">hinzu, um dies zu implementieren </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In seiner allgemeinsten Form ist Verdunstung der Prozess der Umwandlung von Feuchtigkeit in Wolken, zumindest in unserem einfachen Klimamodell. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die Verdunstung kein konstanter Wert sein sollte, sondern ein weiterer Faktor. </font><font style="vertical-align: inherit;">Daher f√ºhren wir ein Refactoring-Umbenennen </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in durch </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich die Zelle unter Wasser befindet, geben wir einfach an, dass die Luftfeuchtigkeit 1 betr√§gt. Dies bedeutet, dass die Verdunstung gleich dem Verdunstungskoeffizienten ist. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir aber auch aus Sushi-Zellen verdunsten. </font><font style="vertical-align: inherit;">In diesem Fall m√ºssen wir die Verdunstung berechnen, von der Luftfeuchtigkeit abziehen und das Ergebnis zu den Wolken addieren. </font><font style="vertical-align: inherit;">Danach wird der Feuchtigkeit Niederschlag zugesetzt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Wolken jetzt durch Verdunstung von oben unterst√ºtzt werden, k√∂nnen wir sie weiter ins Landesinnere bewegen. </font><font style="vertical-align: inherit;">Jetzt ist der Gro√üteil des Landes grau geworden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolken mit Verdunstung der Feuchtigkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern wir es </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es Feuchtigkeit anstelle von Wolken anzeigt, da wir es verwenden werden, um die Arten von Reliefs zu bestimmen.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feuchtigkeitsanzeige. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt sieht die Luftfeuchtigkeit den Wolken ziemlich √§hnlich (au√üer dass alle Unterwasserzellen wei√ü sind), aber das wird sich bald √§ndern.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Niederschlag abflie√üen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdunstung ist nicht der einzige Weg, auf dem Feuchtigkeit die Zelle verlassen kann. </font><font style="vertical-align: inherit;">Der Wasserkreislauf sagt uns, dass der gr√∂√üte Teil der Feuchtigkeit, die dem Land hinzugef√ºgt wird, irgendwie im Wasser landet. </font><font style="vertical-align: inherit;">Der auff√§lligste Prozess ist der Wasserfluss √ºber Land unter dem Einfluss der Schwerkraft. </font><font style="vertical-align: inherit;">Wir werden keine echten Fl√ºsse simulieren, sondern einen benutzerdefinierten Niederschlagsabflusskoeffizienten verwenden. </font><font style="vertical-align: inherit;">Es zeigt den Prozentsatz des Wassers an, das in die unteren Bereiche abflie√üt. </font><font style="vertical-align: inherit;">Standardm√§√üig betr√§gt die Aktie 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schieberegler entleeren.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden keine Fl√ºsse erzeugen?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wasserabfluss wirkt wie eine Wolkenstreuung, jedoch mit drei Unterschieden. Erstens wird nicht die gesamte Feuchtigkeit aus der Zelle entfernt. Zweitens tr√§gt es Feuchtigkeit, keine Wolken. Drittens geht es runter, das hei√üt nur zu Nachbarn mit geringerer H√∂he. Der Abflusskoeffizient beschreibt die Menge an Feuchtigkeit, die aus der Zelle herausflie√üen w√ºrde, wenn alle Nachbarn niedriger w√§ren, aber oft sind sie geringer. Dies bedeutet, dass wir die Zellfeuchtigkeit nur reduzieren, wenn wir unten einen Nachbarn finden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser l√§uft auf eine niedrigere H√∂he ab. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen haben wir eine vielf√§ltigere Verteilung der Luftfeuchtigkeit, da hohe Zellen ihre Feuchtigkeit auf die niedrigere √ºbertragen. </font><font style="vertical-align: inherit;">Wir sehen auch viel weniger Feuchtigkeit in den K√ºstenzellen, weil sie die Feuchtigkeit in die Unterwasserzellen ableiten. </font><font style="vertical-align: inherit;">Um diesen Effekt abzuschw√§chen, m√ºssen wir auch den Wasserstand verwenden, um festzustellen, ob die Zelle niedriger ist, dh die scheinbare H√∂he nehmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die sichtbare H√∂he.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versickerung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser flie√üt nicht nur nach unten, es breitet sich aus, sickert durch die ebene Topographie und wird vom Land neben den Gew√§ssern absorbiert. </font><font style="vertical-align: inherit;">Dieser Effekt hat zwar nur geringe Auswirkungen, ist jedoch n√ºtzlich, um die Verteilung der Luftfeuchtigkeit zu gl√§tten. F√ºgen Sie ihn daher der Simulation hinzu. </font><font style="vertical-align: inherit;">Erstellen wir einen eigenen benutzerdefinierten Koeffizienten, der standardm√§√üig 0,125 betr√§gt.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leckage-Schieberegler. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Versickern √§hnelt einem Abfluss, au√üer dass es verwendet wird, wenn der Nachbar die gleiche sichtbare H√∂he wie die Zelle selbst hat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein wenig Leckage hinzugef√ºgt. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regenschatten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir bereits eine w√ºrdige Simulation des Wasserkreislaufs erstellt haben, sieht es nicht sehr interessant aus, da es keine Regenschatten gibt, die die klimatischen Unterschiede am deutlichsten zeigen. </font><font style="vertical-align: inherit;">Regenschatten sind Gebiete, in denen im Vergleich zu benachbarten Gebieten ein erheblicher Niederschlagsmangel besteht. </font><font style="vertical-align: inherit;">Solche Gebiete existieren, weil Berge verhindern, dass die Wolken sie erreichen. </font><font style="vertical-align: inherit;">Ihre Schaffung erfordert hohe Berge und eine dominante Windrichtung.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Wind </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem Hinzuf√ºgen einer dominanten Windrichtung zur Simulation. </font><font style="vertical-align: inherit;">Obwohl die dominanten Windrichtungen auf der Erdoberfl√§che stark variieren, werden wir mit einer anpassbaren globalen Windrichtung auskommen. </font><font style="vertical-align: inherit;">Verwenden wir standardm√§√üig Nordwesten. </font><font style="vertical-align: inherit;">Lassen Sie uns au√üerdem die Windkraft von 1 bis 10 mit einem Standardwert von 4 einstellbar machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Richtung und St√§rke des Windes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die St√§rke des dominanten Windes wird relativ zur Gesamtstreuung der Wolken ausgedr√ºckt. </font><font style="vertical-align: inherit;">Wenn die Windkraft 1 ist, ist die Streuung in alle Richtungen gleich. </font><font style="vertical-align: inherit;">Wenn es 2 ist, ist die Streuung in Windrichtung um zwei h√∂her als in andere Richtungen und so weiter. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir den Divisor in der Wolkenstreuungsformel √§ndern. </font><font style="vertical-align: inherit;">Anstelle von sechs entspricht dies f√ºnf plus Windkraft.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich bestimmt die Windrichtung die Richtung, aus der der Wind weht. </font><font style="vertical-align: inherit;">Daher m√ºssen wir die entgegengesetzte Richtung als Hauptstreurichtung verwenden.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir √ºberpr√ºfen, ob sich der Nachbar in der Hauptstreurichtung befindet. </font><font style="vertical-align: inherit;">Wenn ja, dann m√ºssen wir die Streuung der Wolken mit der Kraft des Windes multiplizieren.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nordwestwind, Kraft 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der dominierende Wind erh√∂ht die Richtungsverteilung der Feuchtigkeit √ºber Land. </font><font style="vertical-align: inherit;">Je st√§rker der Wind, desto st√§rker wird der Effekt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Absolute H√∂he </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Zutat, um Regenschatten zu bekommen, sind die Berge. Wir haben keine strenge Klassifizierung dessen, was ein Berg ist, so wie es die Natur auch nicht hat. Nur die absolute H√∂he ist wichtig. Wenn sich die Luft √ºber den Berg bewegt, muss sie aufsteigen, wird gek√ºhlt und enth√§lt m√∂glicherweise weniger Wasser, was zu Niederschl√§gen f√ºhrt, bevor Luft √ºber den Berg str√∂mt. Infolgedessen erhalten wir auf der anderen Seite trockene Luft, dh einen Regenschatten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je h√∂her die Luft steigt, desto weniger Wasser kann sie enthalten. </font><font style="vertical-align: inherit;">In unserer Simulation k√∂nnen wir uns dies als eine erzwungene Einschr√§nkung des maximalen Wolkenwerts f√ºr jede Zelle vorstellen. </font><font style="vertical-align: inherit;">Je h√∂her die sichtbare Zellenh√∂he ist, desto niedriger sollte dieses Maximum sein. </font><font style="vertical-align: inherit;">Der einfachste Weg, dies zu tun, besteht darin, das Maximum auf 1 abz√ºglich der scheinbaren H√∂he, geteilt durch die maximale H√∂he, zu setzen. </font><font style="vertical-align: inherit;">Tats√§chlich teilen wir jedoch durch ein Maximum von minus 1. Dadurch kann ein kleiner Teil der Wolken auch durch die h√∂chsten Zellen gelangen. </font><font style="vertical-align: inherit;">Wir weisen dieses Maximum nach der Berechnung des Niederschlags und vor der Streuung zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir dadurch mehr Wolken als akzeptabel bekommen, wandeln wir die √ºbersch√ºssigen Wolken einfach in Feuchtigkeit um. </font><font style="vertical-align: inherit;">Auf diese Weise f√ºgen wir zus√§tzlichen Niederschlag hinzu, wie es in echten Bergen der Fall ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regenschatten durch H√∂henlage. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir vervollst√§ndigen die Simulation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir bereits eine sehr hochwertige Teilsimulation des Wasserkreislaufs. </font><font style="vertical-align: inherit;">Lassen Sie es uns ein wenig ordnen und dann anwenden, um die Art des Reliefs der Zellen zu bestimmen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paralleles Rechnen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits unter dem Spoiler erw√§hnt, beeinflusst die Reihenfolge, in der Zellen gebildet werden, das Simulationsergebnis. </font><font style="vertical-align: inherit;">Idealerweise sollte dies nicht so sein und im Wesentlichen bilden wir alle Zellen parallel. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem alle √Ñnderungen des aktuellen Bildungsstadiums auf die zweite Liste des Klimas angewendet werden </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂schen und initialisieren Sie diese Liste wie alle anderen auch. </font><font style="vertical-align: inherit;">Dann werden wir Listen zu jedem Zyklus austauschen. </font><font style="vertical-align: inherit;">In diesem Fall verwendet die Simulation abwechselnd die beiden Listen und wendet die aktuellen und n√§chsten Klimadaten an.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn eine Zelle das Klima ihres Nachbarn beeinflusst, m√ºssen wir die folgenden Klimadaten √§ndern, nicht die aktuellen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; ‚Ä¶ nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und anstatt die folgenden Klimadaten zur√ºck in die aktuelle Klimaliste zu kopieren, erhalten wir die folgenden Klimadaten, f√ºgen die aktuelle Luftfeuchtigkeit hinzu und kopieren sie alle in die n√§chste Liste. </font><font style="vertical-align: inherit;">Danach setzen wir die Daten in der aktuellen Liste zur√ºck, damit sie f√ºr den n√§chsten Zyklus aktualisiert werden.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen wir dabei auch die Luftfeuchtigkeit auf maximal 1 ein, damit Landzellen nicht feuchter als unter Wasser sind. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralleles Rechnen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellfeuchtigkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es besteht die M√∂glichkeit, dass die Simulation zu viel trockenes Land erzeugt, insbesondere bei einem hohen Prozentsatz an Land. </font><font style="vertical-align: inherit;">Um das Bild zu verbessern, k√∂nnen wir eine benutzerdefinierte Anfangsfeuchtigkeit mit einem Standardwert von 0,1 hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oben ist der Schieberegler der urspr√ºnglichen Luftfeuchtigkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diesen Wert f√ºr die Luftfeuchtigkeit der anf√§nglichen Klimaliste, jedoch nicht f√ºr Folgendes.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit urspr√ºnglicher Luftfeuchtigkeit.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomes definieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schlie√üen mit der Verwendung von Feuchtigkeit anstelle von H√∂he, um die Art der Zellentlastung festzulegen. </font><font style="vertical-align: inherit;">Verwenden wir Schnee f√ºr vollst√§ndig trockenes Land, f√ºr trockene Regionen verwenden wir Schnee, dann gibt es Stein, Gras f√ºr ausreichend Feuchtigkeit und Land f√ºr wasserges√§ttigte und Unterwasserzellen. </font><font style="vertical-align: inherit;">Am einfachsten ist es, f√ºnf Intervalle in Schritten von 0,2 zu verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei gleichm√§√üiger Verteilung ist das Ergebnis nicht sehr gut und sieht unnat√ºrlich aus. </font><font style="vertical-align: inherit;">Es ist besser, andere Schwellenwerte zu verwenden, z. B. 0,05, 0,12, 0,28 und 0,85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifizierte Biome. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 26: Biomes und Fl√ºsse </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schaffen die Fl√ºsse, die aus hohen Zellen mit Feuchtigkeit stammen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir erstellen ein einfaches Temperaturmodell. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verwenden die Biomatrix f√ºr die Zellen und √§ndern sie dann. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werden wir den Wasserkreislauf mit Fl√ºssen und Temperaturen erg√§nzen und den Zellen interessantere Biome zuweisen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Tutorial wurde mit Unity 2017.3.0p3 erstellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hitze und Wasser beleben die Karte.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flusserzeugung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fl√ºsse sind eine Folge des Wasserkreislaufs. </font><font style="vertical-align: inherit;">Tats√§chlich werden sie durch Abfl√ºsse gebildet, die mit Hilfe der Kanalerosion herausgerissen werden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie Fl√ºsse basierend auf dem Wert der Zellabl√§ufe hinzuf√ºgen k√∂nnen. </font><font style="vertical-align: inherit;">Dies garantiert jedoch nicht, dass wir etwas bekommen, das echten Fl√ºssen √§hnelt. </font><font style="vertical-align: inherit;">Wenn wir den Fluss starten, muss er so weit wie m√∂glich flie√üen, m√∂glicherweise durch viele Zellen. </font><font style="vertical-align: inherit;">Dies steht nicht im Einklang mit unserer Simulation des Wasserkreislaufs, bei dem Zellen parallel verarbeitet werden. </font><font style="vertical-align: inherit;">Dar√ºber hinaus ist normalerweise die Kontrolle der Anzahl der Fl√ºsse auf einer Karte erforderlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Fl√ºsse sehr unterschiedlich sind, werden wir sie separat erzeugen. </font><font style="vertical-align: inherit;">Wir verwenden die Ergebnisse der Wasserkreislaufsimulation, um den Standort der Fl√ºsse zu bestimmen, aber die Fl√ºsse haben wiederum keinen Einfluss auf die Simulation.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist der Fluss manchmal falsch?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         (¬´¬ª). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } ‚Ä¶ }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen mit hoher Luftfeuchtigkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf unseren Karten kann eine Zelle einen Fluss haben oder nicht. Dar√ºber hinaus k√∂nnen sie verzweigen oder verbinden. In Wirklichkeit sind Fl√ºsse viel flexibler, aber wir m√ºssen mit dieser Ann√§herung auskommen, die nur gro√üe Fl√ºsse erzeugt. Am wichtigsten ist, dass wir den Ort des Beginns eines gro√üen Flusses bestimmen, der zuf√§llig ausgew√§hlt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Fl√ºsse Wasser ben√∂tigen, muss sich die Quelle des Flusses in einer Zelle mit hoher Luftfeuchtigkeit befinden. Das reicht aber nicht. Fl√ºsse flie√üen die H√§nge hinunter, daher sollte die Quelle idealerweise eine gro√üe H√∂he haben. Je h√∂her die Zelle √ºber dem Wasserspiegel ist, desto besser ist sie f√ºr die Rolle der Flussquelle geeignet. Wir k√∂nnen dies als Kartendaten visualisieren, indem wir die Zellenh√∂he durch die maximale H√∂he teilen. Damit das Ergebnis relativ zum Wasserstand erhalten wird, werden wir es vor dem Teilen von beiden H√∂hen abziehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luftfeuchtigkeit und H√∂he. Gro√üe Kartennummer 1208905299 mit Standardeinstellungen.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die besten Kandidaten sind Zellen mit hoher Luftfeuchtigkeit und hoher H√∂he. Wir k√∂nnen diese Kriterien kombinieren, indem wir sie multiplizieren. Das Ergebnis ist der Wert der Fitness oder des Gewichts f√ºr die Quellen der Fl√ºsse.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewichte f√ºr die Quellen von Fl√ºssen.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idealerweise w√ºrden wir diese Gewichte verwenden, um die zuf√§llige Auswahl der Quellzelle abzulehnen. Obwohl wir eine Liste mit den richtigen Gewichten erstellen und daraus ausw√§hlen k√∂nnen, ist dies ein nicht trivialer Ansatz, der den Generierungsprozess verlangsamt. Eine einfachere Klassifizierung der Signifikanz in vier Ebenen wird uns ausreichen. Die ersten Kandidaten sind Gewichte mit Werten √ºber 0,75. Gute Kandidaten haben Gewichte von 0,5. Geeignete Kandidaten sind gr√∂√üer als 0,25. Alle anderen Zellen werden verworfen. Lassen Sie uns zeigen, wie es grafisch aussieht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewichtskategorien von Flussquellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem Klassifizierungsschema erhalten wir wahrscheinlich Fl√ºsse mit Quellen in den h√∂chsten und feuchtesten Bereichen der Karte. </font><font style="vertical-align: inherit;">Dennoch bleibt die Wahrscheinlichkeit bestehen, Fl√ºsse in relativ trockenen oder niedrigen Gebieten zu erzeugen, was die Variabilit√§t erh√∂ht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine Methode hinzu </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die eine Liste von Zellen basierend auf diesen Kriterien f√ºllt. </font><font style="vertical-align: inherit;">Geeignete Zellen werden dieser Liste einmal, gute zweimal und die Hauptkandidaten viermal hinzugef√ºgt. </font><font style="vertical-align: inherit;">Unterwasserzellen werden immer verworfen, daher k√∂nnen Sie sie nicht √ºberpr√ºfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Methode muss nachher aufgerufen werden, </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">damit uns Feuchtigkeitsdaten zur Verf√ºgung stehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem Sie die Klassifizierung abgeschlossen haben, k√∂nnen Sie die Visualisierung der Daten auf der Karte entfernen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flusspunkte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie viele Fl√ºsse brauchen wir? </font><font style="vertical-align: inherit;">Dieser Parameter muss anpassbar sein. </font><font style="vertical-align: inherit;">Da die L√§nge der Fl√ºsse variiert, ist es logischer, sie mit Hilfe von Flusspunkten zu steuern, die die Anzahl der Landzellen bestimmen, in denen die Fl√ºsse enthalten sein sollen. </font><font style="vertical-align: inherit;">Lassen Sie uns sie als Prozentsatz mit maximal 20% und einem Standardwert von 10% ausdr√ºcken. </font><font style="vertical-align: inherit;">Wie der Prozentsatz an Sushi ist dies ein Zielwert, kein garantierter. </font><font style="vertical-align: inherit;">Infolgedessen haben wir m√∂glicherweise zu wenige Kandidaten oder Fl√ºsse, die zu kurz sind, um die erforderliche Landmenge abzudecken. </font><font style="vertical-align: inherit;">Deshalb sollte der maximale Prozentsatz nicht zu gro√ü sein.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider Prozent Fl√ºsse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Flusspunkte zu bestimmen, ausgedr√ºckt als Anzahl der Zellen, m√ºssen wir uns daran erinnern, in wie vielen Landzellen erzeugt wurden </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Inneren kann die </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzahl der Flusspunkte jetzt auf die gleiche Weise berechnet werden wie in </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem werden wir weiterhin zuf√§llige Zellen aus der urspr√ºnglichen Liste nehmen und entfernen, solange wir noch Punkte und Quellzellen haben. </font><font style="vertical-align: inherit;">Wenn die Anzahl der Punkte erreicht ist, wird in der Konsole eine Warnung angezeigt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich f√ºgen wir eine Methode zum direkten Erstellen von Fl√ºssen hinzu. </font><font style="vertical-align: inherit;">Als Parameter ben√∂tigt er eine Anfangszelle und muss nach Fertigstellung die L√§nge des Flusses zur√ºckgeben. </font><font style="vertical-align: inherit;">Wir beginnen mit dem Speichern einer Methode, die die L√§nge Null zur√ºckgibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Methode am Ende des Zyklus, den wir gerade hinzugef√ºgt haben </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">, um die Anzahl der verbleibenden Punkte zu reduzieren. </font><font style="vertical-align: inherit;">Wir stellen sicher, dass ein neuer Fluss nur dann erstellt wird, wenn in der ausgew√§hlten Zelle kein Fluss flie√üt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aktuelle Fl√ºsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist logisch, Fl√ºsse zu schaffen, die zum Meer oder zu anderen Gew√§ssern flie√üen. </font><font style="vertical-align: inherit;">Wenn wir von der Quelle ausgehen, erhalten wir sofort die L√§nge 1. Danach w√§hlen wir einen zuf√§lligen Nachbarn aus und erh√∂hen die L√§nge. </font><font style="vertical-align: inherit;">Wir bewegen uns weiter, bis wir die Unterwasserzelle erreichen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuf√§llige Fl√ºsse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis eines solchen naiven Ansatzes erhalten wir zuf√§llig verstreute Flussfragmente, haupts√§chlich aufgrund des Ersatzes zuvor erzeugter Fl√ºsse. </font><font style="vertical-align: inherit;">Dies kann sogar zu Fehlern f√ºhren, da wir nicht pr√ºfen, ob der Nachbar tats√§chlich existiert. </font><font style="vertical-align: inherit;">Wir m√ºssen alle Richtungen in der Schleife √ºberpr√ºfen und sicherstellen, dass dort ein Nachbar ist. </font><font style="vertical-align: inherit;">Wenn dies der Fall ist, f√ºgen wir diese Richtung der Liste der m√∂glichen Str√∂mungsrichtungen hinzu, jedoch nur, wenn der Fluss noch nicht durch diesen Nachbarn flie√üt. </font><font style="vertical-align: inherit;">W√§hlen Sie dann einen zuf√§lligen Wert aus dieser Liste.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem neuen Ansatz stehen m√∂glicherweise keine Str√∂mungsrichtungen zur Verf√ºgung. </font><font style="vertical-align: inherit;">In diesem Fall kann der Fluss nicht mehr weiter flie√üen und muss enden. </font><font style="vertical-align: inherit;">Wenn in diesem Moment die L√§nge 1 ist, bedeutet dies, dass wir nicht aus der urspr√ºnglichen Zelle austreten konnten, das hei√üt, es kann √ºberhaupt keinen Fluss geben. </font><font style="vertical-align: inherit;">In diesem Fall ist die L√§nge des Flusses Null.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erhaltene Fl√ºsse.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lauf runter </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt retten wir die bereits geschaffenen Fl√ºsse, aber wir k√∂nnen immer noch isolierte Fragmente der Fl√ºsse erhalten. </font><font style="vertical-align: inherit;">Dies geschieht, weil wir die H√∂hen ignoriert haben. </font><font style="vertical-align: inherit;">Jedes Mal, wenn wir den Fluss zwangen, in eine gr√∂√üere H√∂he zu flie√üen, wurde </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser Versuch unterbrochen, was zu Br√ºchen in den Fl√ºssen f√ºhrte. </font><font style="vertical-align: inherit;">Daher m√ºssen wir auch Richtungen √ºberspringen, die dazu f√ºhren, dass Fl√ºsse hochflie√üen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fl√ºsse flie√üen herab. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So werden wir viele Fragmente von Fl√ºssen los, aber einige bleiben noch √ºbrig. </font><font style="vertical-align: inherit;">Von diesem Moment an ist es eine Frage der Verfeinerung, die h√§sslichsten Fl√ºsse loszuwerden. </font><font style="vertical-align: inherit;">Fl√ºsse flie√üen zun√§chst lieber so schnell wie m√∂glich ab. </font><font style="vertical-align: inherit;">Sie werden nicht unbedingt die k√ºrzest m√∂gliche Route w√§hlen, aber die Wahrscheinlichkeit daf√ºr ist gro√ü. </font><font style="vertical-align: inherit;">Um dies zu simulieren, f√ºgen wir der Liste dreimal Anweisungen hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie scharfe Kurven </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser flie√üt nicht nur nach unten, sondern hat auch Tr√§gheit. </font><font style="vertical-align: inherit;">Ein Fluss flie√üt eher gerade oder biegt sich leicht als eine pl√∂tzliche scharfe Kurve. </font><font style="vertical-align: inherit;">Wir k√∂nnen diese Verzerrung hinzuf√ºgen, indem wir die letzte Richtung des Flusses verfolgen. </font><font style="vertical-align: inherit;">Wenn die potenzielle Richtung des Stroms nicht zu stark von dieser Richtung abweicht, f√ºgen Sie sie erneut zur Liste hinzu. </font><font style="vertical-align: inherit;">Dies ist kein Problem f√ºr die Quelle, daher f√ºgen wir es einfach immer wieder hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies verringert die Wahrscheinlichkeit von Fl√ºssen im Zickzack, die h√§sslich aussehen, erheblich. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weniger scharfe Kurven.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenfluss des Flusses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal stellt sich heraus, dass der Fluss direkt neben der Quelle des zuvor geschaffenen Flusses flie√üt. </font><font style="vertical-align: inherit;">Wenn sich die Quelle dieses Flusses nicht in einer h√∂heren H√∂he befindet, k√∂nnen wir entscheiden, dass der neue Fluss in den alten flie√üt. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir einen langen Fluss und nicht zwei benachbarte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu lassen wir den Nachbarn nur passieren, wenn sich ein Fluss darin befindet oder wenn er die Quelle des aktuellen Flusses ist. </font><font style="vertical-align: inherit;">Nachdem wir festgestellt haben, dass diese Richtung nicht stimmt, pr√ºfen wir, ob ein abflie√üender Fluss vorhanden ist. </font><font style="vertical-align: inherit;">Wenn ja, dann haben wir wieder den alten Fluss gefunden. </font><font style="vertical-align: inherit;">Da dies ziemlich selten vorkommt, werden wir uns nicht mit der √úberpr√ºfung anderer benachbarter Quellen befassen und die Fl√ºsse sofort kombinieren.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fl√ºsse vor und nach dem Pooling.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abstand halten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da gute Kandidaten f√ºr die Quellrolle normalerweise in Gruppen zusammengefasst sind, erhalten wir Flusscluster. </font><font style="vertical-align: inherit;">Au√üerdem haben wir m√∂glicherweise Fl√ºsse, die die Quelle direkt neben dem Stausee nehmen, was zu Fl√ºssen der L√§nge 1 f√ºhrt. Wir k√∂nnen die Quellen verteilen und diejenigen verwerfen, die sich in der N√§he des Flusses oder Stausees befinden. </font><font style="vertical-align: inherit;">Wir tun dies, indem wir die Nachbarn der ausgew√§hlten Quelle in einer Schleife im Inneren umgehen </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir einen Nachbarn finden, der gegen die Regeln verst√∂√üt, passt die Quelle nicht zu uns und wir m√ºssen sie √ºberspringen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und obwohl die Fl√ºsse immer noch nebeneinander flie√üen, bedecken sie tendenziell ein gr√∂√üeres Gebiet. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne Distanz und damit.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir beenden den Fluss mit einem See </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle Fl√ºsse erreichen den Stausee, einige bleiben in den T√§lern stecken oder werden von anderen Fl√ºssen blockiert. Dies ist kein besonderes Problem, da oft auch echte Fl√ºsse zu verschwinden scheinen. Dies kann beispielsweise passieren, wenn sie unter der Erde flie√üen, sich in einem sumpfigen Gebiet verteilen oder austrocknen. Unsere Fl√ºsse k√∂nnen sich das nicht vorstellen, also enden sie einfach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen jedoch versuchen, die Anzahl solcher F√§lle zu minimieren. Obwohl wir die Fl√ºsse nicht vereinen oder zum Flie√üen bringen k√∂nnen, k√∂nnen wir sie in Seen enden lassen, die in der Realit√§t oft vorkommen und gut aussehen. Daf√ºr</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte den Wasserstand in der Zelle erh√∂hen, wenn sie stecken bleibt. </font><font style="vertical-align: inherit;">Die M√∂glichkeit hierf√ºr h√§ngt von der Mindesth√∂he der Nachbarn dieser Zelle ab. </font><font style="vertical-align: inherit;">Um dies beim Studieren von Nachbarn zu verfolgen, ist daher eine kleine √Ñnderung des Codes erforderlich.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir nicht weiterkommen, m√ºssen wir zun√§chst pr√ºfen, ob wir noch an der Quelle sind. </font><font style="vertical-align: inherit;">Wenn ja, dann stornieren Sie einfach den Fluss. </font><font style="vertical-align: inherit;">Andernfalls pr√ºfen wir, ob alle Nachbarn mindestens so hoch sind wie die aktuelle Zelle. </font><font style="vertical-align: inherit;">Wenn ja, k√∂nnen wir das Wasser auf dieses Niveau bringen. </font><font style="vertical-align: inherit;">Dadurch entsteht aus einer Zelle ein See, es sei denn, die Zellenh√∂he bleibt auf dem gleichen Niveau. </font><font style="vertical-align: inherit;">Wenn ja, weisen Sie die H√∂he einfach eine Ebene unter dem Wasserspiegel zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Enden von Fl√ºssen ohne Seen und mit Seen. </font><font style="vertical-align: inherit;">In diesem Fall betr√§gt der Prozentsatz der Fl√ºsse 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beachten Sie, dass wir jetzt m√∂glicherweise Unterwasserzellen √ºber dem Wasserspiegel haben, der zur Erstellung der Karte verwendet wurde. </font><font style="vertical-align: inherit;">Sie werden Seen √ºber dem Meeresspiegel bezeichnen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zus√§tzliche Seen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen auch Seen schaffen, auch wenn wir nicht festsitzen. </font><font style="vertical-align: inherit;">Dies kann dazu f√ºhren, dass ein Fluss in den See hinein und aus ihm heraus flie√üt. </font><font style="vertical-align: inherit;">Wenn wir nicht stecken bleiben, kann ein See geschaffen werden, indem der Wasserstand und dann die aktuelle Zellenh√∂he erh√∂ht und dann die Zellenh√∂he verringert werden. </font><font style="vertical-align: inherit;">Dies gilt nur, wenn die Mindesth√∂he des Nachbarn mindestens der H√∂he der aktuellen Zelle entspricht. </font><font style="vertical-align: inherit;">Wir tun dies am Ende des Flusszyklus und bevor wir zur n√§chsten Zelle √ºbergehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne zus√§tzliche Seen und mit ihnen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Seen sind wundersch√∂n, aber ohne Grenzen k√∂nnen wir zu viele Seen schaffen. </font><font style="vertical-align: inherit;">F√ºgen wir daher eine benutzerdefinierte Wahrscheinlichkeit f√ºr zus√§tzliche Seen mit einem Standardwert von 0,25 hinzu.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn m√∂glich, wird sie die Wahrscheinlichkeit der Erzeugung eines zus√§tzlichen Sees kontrollieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzliche Seen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit der Schaffung von Seen mit mehr als einer Zelle?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperatur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser ist nur einer der Faktoren, die das Biom einer Zelle bestimmen k√∂nnen. </font><font style="vertical-align: inherit;">Ein weiterer wichtiger Faktor ist die Temperatur. </font><font style="vertical-align: inherit;">Obwohl wir den Fluss und die Diffusion von Temperaturen wie die Simulation von Wasser simulieren k√∂nnen, brauchen wir nur einen komplexen Faktor, um ein interessantes Klima zu schaffen. </font><font style="vertical-align: inherit;">Lassen Sie uns daher die Temperatur einfach halten und f√ºr jede Zelle einstellen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperatur und Breitengrad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gr√∂√üte Einfluss auf die Temperatur ist der Breitengrad. </font><font style="vertical-align: inherit;">Es ist hei√ü am √Ñquator, kalt an den Polen und es gibt einen reibungslosen √úbergang zwischen ihnen. </font><font style="vertical-align: inherit;">Erstellen wir eine Methode </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Temperatur einer bestimmten Zelle zur√ºckgibt. </font><font style="vertical-align: inherit;">Zu Beginn verwenden wir einfach die Z-Koordinate der Zelle geteilt durch die Dimension Z als Breitengrad und verwenden diesen Wert dann als Temperatur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir definieren die Temperatur in </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden sie als Kartendaten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breitengrad als Temperatur, s√ºdliche Hemisph√§re. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten einen linearen Temperaturgradienten, der von unten nach oben zunimmt. </font><font style="vertical-align: inherit;">Sie k√∂nnen damit die s√ºdliche Hemisph√§re simulieren, mit einer Stange unten und einem √Ñquator oben. </font><font style="vertical-align: inherit;">Wir m√ºssen aber nicht die gesamte Hemisph√§re beschreiben. </font><font style="vertical-align: inherit;">Mit einem kleineren Temperaturunterschied oder √ºberhaupt keinem Unterschied k√∂nnen wir einen kleineren Bereich beschreiben. </font><font style="vertical-align: inherit;">Dazu werden wir niedrige und hohe Temperaturen anpassbar machen. </font><font style="vertical-align: inherit;">Wir werden diese Temperaturen im Bereich von 0 bis 1 einstellen und die Extremwerte als Standardwerte verwenden.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperaturregler. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wenden den Temperaturbereich durch lineare Interpolation an, wobei der Breitengrad als Interpolator verwendet wird. </font><font style="vertical-align: inherit;">Da wir den Breitengrad als Wert von 0 bis 1 ausdr√ºcken, k√∂nnen wir ihn verwenden </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass niedrige Temperaturen nicht unbedingt niedriger als hoch sind. </font><font style="vertical-align: inherit;">Falls gew√ºnscht, k√∂nnen Sie sie umdrehen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hemisph√§re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die s√ºdliche und m√∂glicherweise die n√∂rdliche Hemisph√§re simulieren, wenn wir zuerst die Temperaturen messen. </font><font style="vertical-align: inherit;">Es ist jedoch viel bequemer, eine separate Konfigurationsoption zu verwenden, um zwischen den Hemisph√§ren zu wechseln. </font><font style="vertical-align: inherit;">Lassen Sie uns eine Aufz√§hlung und ein Feld daf√ºr erstellen. </font><font style="vertical-align: inherit;">Daher werden wir auch die Option hinzuf√ºgen, beide Hemisph√§ren zu erstellen, die standardm√§√üig anwendbar ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahl der Hemisph√§re. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir die n√∂rdliche Hemisph√§re brauchen, k√∂nnen wir den Breitengrad einfach umdrehen und von 1 subtrahieren. Um beide Hemisph√§ren zu simulieren, sollten sich die Pole unter und √ºber der Karte befinden und der √Ñquator sollte in der Mitte liegen. </font><font style="vertical-align: inherit;">Sie k√∂nnen dies tun, indem Sie den Breitengrad verdoppeln, w√§hrend die untere Hemisph√§re korrekt verarbeitet wird und die obere einen Breitengrad von 1 bis 2 hat. Um dies zu beheben, subtrahieren wir den Breitengrad von 2, wenn er 1 √ºberschreitet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Hemisph√§ren. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist erw√§hnenswert, dass dies die M√∂glichkeit schafft, eine exotische Karte zu erstellen, in der der √Ñquator kalt und die Pole warm sind.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je h√∂her desto k√§lter </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben dem Breitengrad wird die Temperatur auch ma√ügeblich von der H√∂he beeinflusst. </font><font style="vertical-align: inherit;">Je h√∂her wir steigen, desto k√§lter wird es im Durchschnitt. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies zu einem Faktor machen, wie wir es bei den Flusskandidaten getan haben. </font><font style="vertical-align: inherit;">In diesem Fall verwenden wir die Zellenh√∂he. </font><font style="vertical-align: inherit;">Au√üerdem nimmt dieser Indikator mit der H√∂he ab, dh gleich 1 minus der H√∂he geteilt durch das Maximum relativ zum Wasserstand. </font><font style="vertical-align: inherit;">Damit der Indikator auf der h√∂chsten Ebene nicht auf Null f√§llt, addieren wir zum Divisor. </font><font style="vertical-align: inherit;">Verwenden Sie dann diesen Indikator, um die Temperatur zu skalieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die H√∂he beeinflusst die Temperatur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperaturschwankungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die Einfachheit des Temperaturgradienten weniger bemerkbar machen, indem wir zuf√§llige Temperaturschwankungen hinzuf√ºgen. </font><font style="vertical-align: inherit;">Eine kleine Chance, es realistischer zu machen, aber mit zu viel Schwankung werden sie willk√ºrlich aussehen. </font><font style="vertical-align: inherit;">Lassen Sie uns die St√§rke von Temperaturschwankungen anpassbar machen und sie als maximale Temperaturabweichung mit einem Standardwert von 0,1 ausdr√ºcken.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schieberegler f√ºr Temperaturschwankungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solche Schwankungen sollten mit geringf√ºgigen lokalen √Ñnderungen gleichm√§√üig sein. </font><font style="vertical-align: inherit;">Hierf√ºr k√∂nnen Sie unsere Rauschstruktur verwenden. </font><font style="vertical-align: inherit;">Wir werden </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Position der Zelle, skaliert mit 0,1, </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">und als Argument verwenden. </font><font style="vertical-align: inherit;">Nehmen wir den Kanal W, zentrieren ihn und skalieren ihn mit dem Schwingungskoeffizienten. </font><font style="vertical-align: inherit;">Dann addieren wir diesen Wert zur zuvor berechneten Temperatur.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperaturschwankungen mit Werten von 0,1 und 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen den Schwankungen auf jeder Karte eine leichte Variabilit√§t hinzuf√ºgen, indem wir zuf√§llig aus den vier Rauschkan√§len ausw√§hlen. </font><font style="vertical-align: inherit;">Stellen Sie den Kanal einmal ein </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und indizieren Sie dann die Farbkan√§le </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiedliche Temperaturschwankungen bei maximaler Kraft. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir Daten zu Luftfeuchtigkeit und Temperatur haben, k√∂nnen wir eine Biomatrix erstellen. </font><font style="vertical-align: inherit;">Durch Indizieren dieser Matrix k√∂nnen wir allen Zellen Biomes zuweisen, wodurch eine komplexere Landschaft entsteht als bei Verwendung nur einer Datendimension.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biom-Matrix </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele Klimamodelle, aber wir werden keines davon verwenden. Wir werden es sehr einfach machen, wir interessieren uns nur f√ºr Logik. Trocken bedeutet W√ºste (kalt oder hei√ü), daf√ºr verwenden wir Sand. Kalt und nass bedeutet Schnee. Hei√ü und feucht bedeutet viel Vegetation, also Gras. Zwischen ihnen wird eine Taiga oder Tundra sein, die wir als graue Textur der Erde bezeichnen werden. Eine 4 √ó 4-Matrix reicht aus, um √úberg√§nge zwischen diesen Biomen zu erzeugen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor haben wir H√∂hentypen basierend auf f√ºnf Feuchtigkeitsintervallen zugewiesen. Wir senken einfach den trockensten Streifen auf 0,05 und speichern den Rest. F√ºr Temperaturb√§nder verwenden wir 0,1, 0,3, 0,6 und h√∂her. Der Einfachheit halber werden diese Werte in statischen Arrays festgelegt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir nur den Relieftyp anhand des Bioms angeben, k√∂nnen wir damit andere Parameter bestimmen. </font><font style="vertical-align: inherit;">Definieren wir daher eine </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Konfiguration eines einzelnen Bioms beschreibt. </font><font style="vertical-align: inherit;">Bisher enth√§lt es nur den Bump-Index sowie die entsprechende Konstruktormethode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese Struktur, um ein statisches Array mit Matrixdaten zu erstellen. </font><font style="vertical-align: inherit;">Wir verwenden Feuchtigkeit als X-Koordinate und Temperatur als Y. Wir f√ºllen die Linie mit der niedrigsten Temperatur mit Schnee, die zweite Linie mit Tundra und die anderen beiden mit Gras. </font><font style="vertical-align: inherit;">Dann ersetzen wir die trockenste S√§ule durch die W√ºste und definieren die Temperaturwahl neu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrix von Biomen mit Indizes eines eindimensionalen Arrays.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomdefinition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen </font><font style="vertical-align: inherit;">im </font><font style="vertical-align: inherit;">Biom </font><font style="vertical-align: inherit;">zu bestimmen </font><font style="vertical-align: inherit;">, werden wir die Temperatur- und Feuchtigkeitsbereiche im Zyklus durchlaufen, um die ben√∂tigten Matrixindizes zu bestimmen. </font><font style="vertical-align: inherit;">Wir verwenden sie, um das gew√ºnschte Biom zu erhalten und die Art der Zelltopographie zu spezifizieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // ‚Ä¶ // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief basierend auf einer Biomatrix.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biom-Setup </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen √ºber die in der Matrix definierten Biome hinausgehen. Beispielsweise werden in der Matrix alle trockenen Biome als Sandw√ºsten definiert, aber nicht alle trockenen W√ºsten sind mit Sand gef√ºllt. Es gibt viele felsige W√ºsten, die sehr unterschiedlich aussehen. Ersetzen wir deshalb einige der W√ºstenzellen durch Steine. Wir werden dies einfach auf der Grundlage der H√∂he tun: Sand befindet sich in geringer H√∂he, und nackte Felsen befinden sich normalerweise oben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Sand verwandelt sich in Stein, wenn die H√∂he der Zelle n√§her an der maximalen H√∂he als am Wasserspiegel liegt. Dies ist die H√∂henlinie der felsigen W√ºsten, die wir zu Beginn berechnen k√∂nnen </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn wir einer Zelle mit Sand begegnen und ihre H√∂he gro√ü genug ist, verwandeln wir das Relief des Bioms in Stein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sandige und felsige W√ºsten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere √Ñnderung basierend auf der H√∂he besteht darin, Zellen in maximaler H√∂he zu zwingen, sich unabh√§ngig von ihrer Temperatur in Schneespitzen zu verwandeln, nur wenn sie nicht zu trocken sind. </font><font style="vertical-align: inherit;">Dies erh√∂ht die Wahrscheinlichkeit von Schneespitzen in der N√§he des hei√üen und feuchten √Ñquators.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schneekappen in maximaler H√∂he.</font></font></i> <br><br><h3>  Pflanzen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen wir nun die Biomasse den Gehalt an Pflanzenzellen bestimmen. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu das </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld der Pflanzen hinzu und </font><font style="vertical-align: inherit;">f√ºgen Sie </font><font style="vertical-align: inherit;">es in den Konstruktor ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den k√§ltesten und trockensten Biomen gibt es √ºberhaupt keine Pflanzen. </font><font style="vertical-align: inherit;">Im √úbrigen sind die Pflanzen umso pflanzlicher, je w√§rmer und feuchter das Klima ist. </font><font style="vertical-align: inherit;">Die zweite Feuchtigkeitss√§ule erh√§lt nur die erste Pflanzenstufe f√ºr die hei√üeste Reihe, daher [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">Die dritte Spalte erh√∂ht die Pegel um eins, mit Ausnahme von Schnee, dh [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">Und die feuchteste S√§ule erh√∂ht sie wieder, das hei√üt, es stellt sich heraus [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">√Ñndern Sie das Array, </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem Sie die Anlagenkonfiguration hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrix von Biomen mit Pflanzenebenen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir das Niveau der Pflanzen f√ºr die Zelle einstellen.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes mit Pflanzen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sehen Pflanzen jetzt anders aus?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    ‚Äî (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen das Niveau der Pflanzen f√ºr Biome √§ndern. </font><font style="vertical-align: inherit;">Zuerst m√ºssen wir sicherstellen, dass sie nicht auf dem schneebedeckten Gel√§nde erscheinen, das wir bereits einrichten konnten. </font><font style="vertical-align: inherit;">Zweitens wollen wir das Niveau der Pflanzen entlang der Fl√ºsse erh√∂hen, wenn es noch nicht das Maximum erreicht hat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifizierte Pflanzen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterwasserbiome </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Moment haben wir die Unterwasserzellen v√∂llig ignoriert. </font><font style="vertical-align: inherit;">F√ºgen wir ihnen eine kleine Variation hinzu, und wir werden nicht f√ºr alle die Textur der Erde verwenden. </font><font style="vertical-align: inherit;">Eine einfache L√∂sung basierend auf der H√∂he reicht bereits aus, um ein interessanteres Bild zu erstellen. </font><font style="vertical-align: inherit;">Verwenden wir zum Beispiel Gras f√ºr Zellen einen Schritt unter dem Wasserspiegel. </font><font style="vertical-align: inherit;">Verwenden wir Gras auch f√ºr Zellen √ºber dem Wasserspiegel, dh f√ºr Seen, die von Fl√ºssen erzeugt werden. </font><font style="vertical-align: inherit;">Zellen mit einer negativen H√∂he sind Tiefseegebiete, daher verwenden wir Stein f√ºr sie. </font><font style="vertical-align: inherit;">Alle anderen Zellen bleiben gemahlen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterwasservariabilit√§t.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen wir einige weitere Details f√ºr die Unterwasserzellen entlang der K√ºste hinzu. Dies sind Zellen mit mindestens einem Nachbarn √ºber dem Wasser. Wenn eine solche Zelle flach ist, werden wir einen Strand schaffen. Und wenn es sich neben der Klippe befindet, ist es das dominierende visuelle Detail, und wir verwenden den Stein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies festzustellen, werden wir die Nachbarn von Zellen √ºberpr√ºfen, die sich einen Schritt unter dem Wasserspiegel befinden. Z√§hlen wir die Anzahl der Verbindungen durch Klippen und H√§nge mit benachbarten Landzellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir diese Informationen verwenden, um Zellen zu klassifizieren. </font><font style="vertical-align: inherit;">Erstens, wenn mehr als die H√§lfte der Nachbarn Land sind, dann haben wir es mit einem See oder einer Bucht zu tun. </font><font style="vertical-align: inherit;">F√ºr diese Zellen verwenden wir eine Grasstruktur. </font><font style="vertical-align: inherit;">Wenn wir sonst Klippen haben, verwenden wir Stein. </font><font style="vertical-align: inherit;">Wenn wir sonst H√§nge haben, verwenden wir Sand, um einen Strand zu schaffen. </font><font style="vertical-align: inherit;">Die einzige verbleibende Option ist ein flaches Gebiet vor der K√ºste, f√ºr das wir noch Gras verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilit√§t der K√ºste. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns abschlie√üend √ºberpr√ºfen, ob wir im k√§ltesten Temperaturbereich keine gr√ºnen Unterwasserzellen haben. </font><font style="vertical-align: inherit;">F√ºr solche Zellen benutzen wir die Erde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir hatten die M√∂glichkeit, zuf√§llige Karten zu generieren, die mit vielen Konfigurationsoptionen sehr interessant und nat√ºrlich aussehen. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 27: Eine Karte falten </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir teilen die Karten in Spalten, die verschoben werden k√∂nnen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zentrieren Sie die Karte in der Kamera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir brechen alles zusammen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem letzten Teil werden wir Unterst√ºtzung f√ºr die Minimierung der Karte hinzuf√ºgen und die √∂stlichen und westlichen R√§nder verbinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Tutorial wurde mit Unity 2017.3.0p3 erstellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch das Falten dreht sich die Welt.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faltkarten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Karten k√∂nnen verwendet werden, um Bereiche unterschiedlicher Gr√∂√üe zu modellieren, sie sind jedoch immer auf eine rechteckige Form beschr√§nkt. Wir k√∂nnen eine Karte einer Insel oder eines ganzen Kontinents erstellen, aber nicht des gesamten Planeten. Die Planeten sind kugelf√∂rmig, sie haben keine starren Grenzen, die die Bewegung auf ihrer Oberfl√§che behindern. Wenn Sie sich weiter in eine Richtung bewegen, kehren Sie fr√ºher oder sp√§ter zum Ausgangspunkt zur√ºck. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen kein Sechseckgitter um eine Kugel wickeln, eine solche √úberlappung ist unm√∂glich. In bester N√§herung wird die ikosaedrische Topologie verwendet, bei der die zw√∂lf Zellen Pentagone sein m√ºssen. Ohne Verzerrung oder Ausnahme kann das Netz jedoch um den Zylinder gewickelt werden. Verbinden Sie dazu einfach den √∂stlichen und den westlichen Rand der Karte. Mit Ausnahme der Wrapping-Logik bleibt alles andere gleich.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Zylinder ist eine schlechte Ann√§herung an eine Kugel, da wir keine Pole modellieren k√∂nnen. </font><font style="vertical-align: inherit;">Dies hinderte die Entwickler vieler Spiele jedoch nicht daran, das Falten von Ost nach West zum Modellieren von Planetenkarten zu verwenden. </font><font style="vertical-align: inherit;">Polarregionen sind einfach nicht Teil der Spielzone.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie w√§re es nach Norden und S√ºden?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei M√∂glichkeiten, eine zylindrische Faltung durchzuf√ºhren. </font><font style="vertical-align: inherit;">Die erste besteht darin, die Karte tats√§chlich zylindrisch zu machen, indem ihre Oberfl√§che und alles darauf gebogen werden, so dass die √∂stlichen und westlichen R√§nder in Kontakt sind. </font><font style="vertical-align: inherit;">Jetzt spielen Sie nicht mehr auf einer ebenen Fl√§che, sondern auf einem echten Zylinder. </font><font style="vertical-align: inherit;">Der zweite Ansatz besteht darin, eine flache Karte zu speichern und Teleportation oder Duplizierung zum Kollabieren zu verwenden. </font><font style="vertical-align: inherit;">Die meisten Spiele verwenden den zweiten Ansatz, also werden wir es nehmen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionales Zusammenklappen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Notwendigkeit, die Karte zu reduzieren, h√§ngt von ihrem Ma√üstab ab - lokal oder planetarisch. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Unterst√ºtzung von beiden nutzen, indem wir das Falten optional machen. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu dem </font><font style="vertical-align: inherit;">Men√º " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neue Karte erstellen"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen </font><font style="vertical-align: inherit;">neuen Schalter hinzu, f√ºr den das </font><em><font style="vertical-align: inherit;">Reduzieren</font></em><font style="vertical-align: inherit;"> standardm√§√üig aktiviert ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Men√º der neuen Karte mit der Option zum Reduzieren. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld eine Option zum Verfolgen der Auswahl sowie eine Methode zum √Ñndern der Auswahl hinzu. </font><font style="vertical-align: inherit;">Lassen Sie uns diese Methode aufrufen, wenn sich der Status des Schalters √§ndert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn eine neue Karte angefordert wird, √ºbergeben wir den Wert der Minimierungsoption. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie es </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es dieses neue Argument akzeptiert und es dann an weiterleitet </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ grid.CreateMap(x, z, wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code&gt; HexGrid sollte wissen, ob wir zusammenbrechen. F√ºgen Sie also ein Feld hinzu und setzen Sie </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es. </font><font style="vertical-align: inherit;">Andere Klassen sollten ihre Logik √§ndern, je nachdem, ob das Raster minimiert ist, daher werden wir das Feld allgemein machen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus k√∂nnen Sie den Standardwert √ºber den Inspektor festlegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; ‚Ä¶ }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anrufe </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an zwei Orten besitzen. </font><font style="vertical-align: inherit;">Wir k√∂nnen einfach ein eigenes Feld f√ºr das Kollapsargument verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ CreateMap(cellCountX, cellCountZ, wrapping); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Gitterklappschalter ist standardm√§√üig aktiviert.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern und laden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da f√ºr jede Karte eine Faltung festgelegt ist, muss sie gespeichert und geladen werden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie das Dateispeicherformat √§ndern m√ºssen, also erh√∂hen Sie die Versionskonstante in </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie </font><font style="vertical-align: inherit;">beim Speichern </font><font style="vertical-align: inherit;">einfach den booleschen Faltwert nach der Kartengr√∂√üe schreiben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Laden lesen wir es nur mit der richtigen Version der Datei. </font><font style="vertical-align: inherit;">Wenn es anders ist, ist dies eine alte Karte und sollte nicht minimiert werden. </font><font style="vertical-align: inherit;">Speichern Sie diese Informationen in einer lokalen Variablen und vergleichen Sie sie mit dem aktuellen Status der Faltung. </font><font style="vertical-align: inherit;">Wenn dies anders ist, k√∂nnen wir die vorhandene Kartentopologie nicht auf die gleiche Weise wiederverwenden wie beim Laden einer Karte mit anderen Gr√∂√üen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faltmetriken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Minimieren der Karte erfordert wesentliche √Ñnderungen in der Logik, beispielsweise bei der Berechnung von Entfernungen. </font><font style="vertical-align: inherit;">Daher k√∂nnen sie Code ber√ºhren, der keine direkte Verbindung zum Raster hat. </font><font style="vertical-align: inherit;">Anstatt diese Informationen als Argumente zu √ºbergeben, f√ºgen wir sie hinzu </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen Sie eine statische Ganzzahl hinzu, die die Faltgr√∂√üe enth√§lt, die der Breite der Karte entspricht. </font><font style="vertical-align: inherit;">Wenn es gr√∂√üer als Null ist, handelt es sich um eine zusammenklappbare Karte. </font><font style="vertical-align: inherit;">F√ºgen Sie eine Eigenschaft hinzu, um dies zu √ºberpr√ºfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen die Faltgr√∂√üe f√ºr jeden Anruf einstellen </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da diese Daten die Neukompilierung im Wiedergabemodus nicht √ºberleben, setzen wir sie ein </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellenbreite </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir mit zusammenklappbaren Karten arbeiten, m√ºssen wir uns h√§ufig mit Positionen entlang der X-Achse befassen, gemessen in der Breite der Zellen. </font><font style="vertical-align: inherit;">Obwohl es daf√ºr verwendet werden kann </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, w√§re es bequemer, wenn wir nicht jedes Mal eine Multiplikation hinzuf√ºgen w√ºrden. </font><font style="vertical-align: inherit;">F√ºgen wir also eine Konstante hinzu </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen den Durchmesser bereits an drei Stellen verwenden. </font><font style="vertical-align: inherit;">Erstens </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Positionieren einer neuen Zelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens bei der </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begrenzung der Position der Kamera.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und auch bei der </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umrechnung von Position zu Koordinaten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartenzentrierung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Karte nicht kollabiert, hat sie klar definierte √∂stliche und westliche R√§nder und daher ein klares horizontales Zentrum. </font><font style="vertical-align: inherit;">Bei einer zusammenklappbaren Karte ist jedoch alles anders. </font><font style="vertical-align: inherit;">Es hat weder den √∂stlichen noch den westlichen Rand noch das Zentrum. </font><font style="vertical-align: inherit;">Alternativ k√∂nnen wir davon ausgehen, dass sich in der Mitte die Kamera befindet. </font><font style="vertical-align: inherit;">Dies ist n√ºtzlich, da die Karte immer auf unserem Standpunkt zentriert sein soll. </font><font style="vertical-align: inherit;">Dann werden wir, wo immer wir sind, die √∂stlichen oder westlichen R√§nder der Karte nicht sehen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartenfragmentspalten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Kartenvisualisierung relativ zur Kamera zentriert ist, m√ºssen wir die Platzierung der Elemente abh√§ngig von der Bewegung der Kamera √§ndern. Wenn es sich nach Westen bewegt, m√ºssen wir das, was sich derzeit am Rand des √∂stlichen Teils befindet, an den Rand des westlichen Teils verschieben. Gleiches gilt f√ºr die Gegenrichtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Idealfall sollten wir die am weitesten entfernte Zellens√§ule sofort auf die andere Seite verschieben, sobald sich die Kamera zur benachbarten Zellens√§ule bewegt. Wir m√ºssen jedoch nicht so genau sein. Stattdessen k√∂nnen wir ganze Kartenfragmente √ºbertragen. Auf diese Weise k√∂nnen wir Teile der Karte verschieben, ohne die Netze √§ndern zu m√ºssen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir ganze Spalten von Fragmenten gleichzeitig verschieben, gruppieren wir sie, indem wir f√ºr jede Gruppe ein √ºbergeordnetes Spaltenobjekt erstellen. </font><font style="vertical-align: inherit;">F√ºgen Sie ein Array f√ºr diese Objekte hinzu </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und wir werden es in initialisieren </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden sie nur als Container verwenden, daher m√ºssen wir nur die Verkn√ºpfung zu ihren Komponenten verfolgen </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie bei Fragmenten befinden sich ihre Anfangspositionen am lokalen Ursprung der Gitterkoordinaten.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt sollte das Fragment ein untergeordnetes Element der entsprechenden Spalte werden, nicht des Rasters. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmente in Spalten gruppiert. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da jetzt alle Fragmente zu Kindern der Spalten geworden sind, reicht </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es aus, alle Spalten direkt zu zerst√∂ren, nicht die Fragmente. </font><font style="vertical-align: inherit;">Also werden wir Tochterfragmente los.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spalten teleportieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuen Methode </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Position X als Parameter hinzu. </font><font style="vertical-align: inherit;">Konvertieren Sie die Position in den Spaltenindex und teilen Sie sie durch die Fragmentbreite in Einheitseinheiten. </font><font style="vertical-align: inherit;">Dies ist der Index der Spalte, in der sich die Kamera gerade befindet, dh die mittlere Spalte der Karte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es reicht aus, die Visualisierung der Karte nur zu √§ndern, wenn sich der Index der zentralen Spalte √§ndert. </font><font style="vertical-align: inherit;">Verfolgen wir es also vor Ort. </font><font style="vertical-align: inherit;">Wir verwenden den Standardwert ‚àí1 beim Erstellen einer Karte, damit neue Karten immer zentriert werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir den Index der zentralen Spalte kennen, k√∂nnen wir den minimalen und maximalen Index bestimmen, indem wir einfach die H√§lfte der Spalten subtrahieren und addieren. Da wir ganzzahlige Werte mit einer ungeraden Anzahl von Spalten verwenden, funktioniert dies perfekt. Bei einer geraden Zahl kann es keine perfekt zentrierte Spalte geben, sodass einer der Indizes einen Schritt weiter als n√∂tig ist. Dies erzeugt einen Versatz von einer Spalte in Richtung des √§u√üersten Randes der Karte, aber f√ºr uns ist dies kein Problem.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass diese Indizes m√∂glicherweise negativ oder gr√∂√üer als der nat√ºrliche maximale Spaltenindex sind. </font><font style="vertical-align: inherit;">Das Minimum ist nur dann Null, wenn sich die Kamera in der N√§he des nat√ºrlichen Mittelpunkts der Karte befindet. </font><font style="vertical-align: inherit;">Unsere Aufgabe ist es, die Spalten so zu verschieben, dass sie diesen relativen Indizes entsprechen. </font><font style="vertical-align: inherit;">Dies kann durch √Ñndern der lokalen X-Koordinate jeder Spalte in der Schleife erfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr jede Spalte pr√ºfen wir, ob der Index des Mindestindex kleiner ist. </font><font style="vertical-align: inherit;">Wenn ja, dann ist es zu weit links von der Mitte. </font><font style="vertical-align: inherit;">Er muss sich auf die andere Seite der Karte teleportieren. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem die X-Koordinate der Breite der Karte entspricht. </font><font style="vertical-align: inherit;">Wenn der Spaltenindex gr√∂√üer als der maximale Index ist, befindet er sich zu weit rechts von der Mitte und sollte sich auf die andere Seite teleportieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamerabewegung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie dies </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass er stattdessen </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anruft </font><font style="vertical-align: inherit;">, wenn er mit einer zusammenklappbaren Karte arbeitet </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Machen Sie die neue Methode zun√§chst einfach zu einem </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duplikat </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber mit dem einzigen Unterschied: Am Ende wird sie aufgerufen </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Karte sofort zentriert ist, rufen wir die </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode auf </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegen Sie sich nach links und rechts, wenn Sie auf der Kamera zentrieren. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir die Bewegung der Kamera immer noch einschr√§nken, versucht die Karte jetzt, relativ zur Kamera zu zentrieren, und teleportiert bei Bedarf Spalten mit Kartenfragmenten. </font><font style="vertical-align: inherit;">Mit einer kleinen Karte und einer Remote-Kamera ist dies deutlich sichtbar, aber auf einer gro√üen Karte befinden sich teleportierte Fragmente au√üerhalb des Sichtbereichs der Kamera. </font><font style="vertical-align: inherit;">Offensichtlich sind nur die anf√§nglichen √∂stlichen und westlichen R√§nder der Karte erkennbar, da noch keine Triangulation zwischen ihnen besteht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Kamera zu kollabieren, entfernen wir die Einschr√§nkung ihrer X-Koordinate </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen werden wir die X-Koordinate weiterhin um die Breite der Karte erh√∂hen, w√§hrend sie unter Null liegt, und sie verringern, w√§hrend sie gr√∂√üer als die Breite der Karte ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Roll-up-Kamera bewegt sich entlang der Karte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenklappbare Shader-Texturen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Ausnahme des Triangulationsraums sollte eine Minimierung der Kamera im Spielemodus nicht wahrnehmbar sein. In diesem Fall tritt jedoch eine visuelle Ver√§nderung in der H√§lfte der Topographie und des Wassers auf. Dies geschieht, weil wir eine Position in der Welt verwenden, um diese Texturen abzutasten. Eine scharfe Teleportation des Fragments ver√§ndert die Position der Texturen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen dieses Problem l√∂sen, indem wir die Texturen in Kacheln anzeigen lassen, die ein Vielfaches der Fragmentgr√∂√üe sind. Die Fragmentgr√∂√üe wird aus den Konstanten in berechnet. </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie also die Shader-Include-Datei </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexMetrics.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und f√ºgen Sie die entsprechenden Definitionen ein. Die grundlegende Kachelskala wird aus der Fragmentgr√∂√üe und dem Au√üenradius der Zelle berechnet. Wenn Sie andere Metriken verwenden, m√ºssen Sie die Datei entsprechend √§ndern.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ergibt eine Kachelskala von 0,00866025404. </font><font style="vertical-align: inherit;">Wenn wir ein ganzzahliges Vielfaches dieses Werts verwenden, wird die Texturierung durch die Teleportation von Fragmenten nicht beeinflusst. </font><font style="vertical-align: inherit;">Au√üerdem werden die Texturen am √∂stlichen und westlichen Rand der Karte nahtlos verbunden, nachdem wir ihre Verbindung korrekt trianguliert haben. </font><font style="vertical-align: inherit;">Wir haben 0,02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als UV-Skala im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader verwendet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen k√∂nnen wir die doppelte Kachelskala verwenden, die 0,01732050808 betr√§gt. </font><font style="vertical-align: inherit;">Die Skala wird etwas weniger erhalten als sie war, und die Skala der Textur nahm leicht zu, aber visuell ist sie unsichtbar.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">f√ºr UV-Rauschen haben wir eine Skala von 0,025 verwendet. </font><font style="vertical-align: inherit;">Stattdessen k√∂nnen Sie die dreifache Kachelskala verwenden. </font><font style="vertical-align: inherit;">Dies gibt uns 0.02598076212, was ziemlich nahe ist.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">bei </font><em><font style="vertical-align: inherit;">Water.cginc</font></em><font style="vertical-align: inherit;"> 0,015 f√ºr Schaum und 0,025 f√ºr Wellen verwendet. </font><font style="vertical-align: inherit;">Hier k√∂nnen wir diese Werte wieder durch eine doppelte und dreifache Kachelskala ersetzen.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); ‚Ä¶ } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Vereinigung von Ost und West </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt ist der einzige visuelle Beweis f√ºr die Minimierung der Karte eine kleine L√ºcke zwischen der √∂stlichsten und der westlichsten Spalte. </font><font style="vertical-align: inherit;">Diese L√ºcke tritt auf, weil wir die Verbindungen von Kanten und Winkeln zwischen Zellen auf gegen√ºberliegenden Seiten der Karte noch nicht trianguliert haben, ohne sie zu falten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platz am Rand.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachbarn falten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Ost-West-Verbindung zu triangulieren, m√ºssen wir die Zellen auf gegen√ºberliegenden Seiten zu Nachbarn machen. </font><font style="vertical-align: inherit;">Bisher tun wir dies nicht, da die </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EW-Verbindung mit der vorherigen Zelle nur hergestellt wird, wenn ihr Index in X gr√∂√üer als Null ist. </font><font style="vertical-align: inherit;">Um diese Verbindung zu trennen, m√ºssen wir die letzte Zelle der Zeile mit der ersten Zelle in derselben Zeile verbinden, wenn die Karte gefaltet ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Verbindung der Nachbarn E - W hergestellt haben, erhalten wir eine partielle Triangulation der L√ºcke. </font><font style="vertical-align: inherit;">Die Verbindung der Kanten ist nicht ideal, da die Verzerrung falsch ausgeblendet ist. </font><font style="vertical-align: inherit;">Wir werden uns sp√§ter darum k√ºmmern.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindungen E - W. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen auch die NE-SW-Verbindungen reduzieren. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem die erste Zelle jeder geraden Zeile mit den letzten Zellen der vorherigen Zeile verbunden wird. </font><font style="vertical-align: inherit;">Es wird nur die vorherige Zelle sein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NE - SW - Verbindungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich werden SE-NW-Verbindungen am Ende jeder ungeraden Zeile unterhalb der ersten hergestellt. </font><font style="vertical-align: inherit;">Diese Zellen m√ºssen mit der ersten Zelle der vorherigen Zeile verbunden sein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindungen SE - NW.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ger√§uschfaltung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die L√ºcke perfekt zu verbergen, m√ºssen wir sicherstellen, dass der √∂stliche und der westliche Rand der Karte mit dem Rauschen √ºbereinstimmen, das perfekt zum Verzerren der Positionen der Scheitelpunkte verwendet wird. </font><font style="vertical-align: inherit;">Wir k√∂nnen den gleichen Trick verwenden, der f√ºr Shader verwendet wurde, aber f√ºr die Verzerrung wurde eine Rauschskala von 0,003 verwendet. </font><font style="vertical-align: inherit;">Um das Kacheln sicherzustellen, m√ºssen Sie den Ma√üstab erheblich erh√∂hen, was zu einer chaotischeren Verzerrung der Scheitelpunkte f√ºhrt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine alternative L√∂sung besteht nicht darin, das Rauschen zu reduzieren, sondern das Rauschen an den R√§ndern der Karte gleichm√§√üig zu d√§mpfen. </font><font style="vertical-align: inherit;">Wenn Sie eine gleichm√§√üige D√§mpfung entlang der Breite einer Zelle durchf√ºhren, erzeugt die Verzerrung einen glatten √úbergang ohne L√ºcken. </font><font style="vertical-align: inherit;">Das Rauschen in diesem Bereich wird leicht gegl√§ttet, und aus gro√üer Entfernung erscheint die √Ñnderung scharf, aber dies ist nicht so offensichtlich, wenn eine leichte Verzerrung der Scheitelpunkte verwendet wird.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit Temperaturschwankungen?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir die Karte nicht kollabieren, k√∂nnen wir mit einer </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einzigen Probe </font><font style="vertical-align: inherit;">auskommen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beim Zusammenklappen muss jedoch eine D√§mpfung hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">Speichern Sie das Beispiel daher vor der R√ºckgabe in einer Variablen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Minimieren m√ºssen wir mit der zweiten Probe mischen. </font><font style="vertical-align: inherit;">Wir werden den √úbergang im √∂stlichen Teil der Karte durchf√ºhren, daher muss die zweite Stichprobe nach Westen verschoben werden.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die D√§mpfung erfolgt durch einfache lineare Interpolation vom westlichen zum √∂stlichen Teil √ºber die Breite einer Zelle. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rauschmischung, eine unvollst√§ndige L√∂sung.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Infolgedessen erhalten wir keine genaue √úbereinstimmung, da einige der Zellen auf der Ostseite negative X-Koordinaten haben. Um sich diesem Bereich nicht zu n√§hern, verschieben wir den √úbergangsbereich um die H√§lfte der Zellbreite nach Westen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtige D√§mpfung.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellbearbeitung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem die Triangulation korrekt erscheint, stellen wir sicher, dass wir alles auf der Karte und an der Naht der Faltung bearbeiten k√∂nnen. Wie sich herausstellt, sind in teleportierten Fragmenten die Koordinaten falsch und gro√üe Pinsel werden durch eine Naht abgeschnitten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Pinsel ist zugeschnitten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um dies zu beheben, m√ºssen wir das </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falten </font><font style="vertical-align: inherit;">melden </font><font style="vertical-align: inherit;">. Wir k√∂nnen dies tun, indem wir die X-Koordinate in der Konstruktormethode abgleichen. Wir wissen, dass die Axialkoordinate X aus der X-Koordinate des Versatzes durch Subtrahieren der H√§lfte der Z-Koordinate erhalten wird. Mit diesen Informationen k√∂nnen Sie die inverse Transformation durchf√ºhren und pr√ºfen, ob die Nullkoordinate kleiner als Null ist. Wenn ja, dann haben wir die Koordinate jenseits der Ostseite der entfalteten Karte. Da wir in jede Richtung nicht mehr als die H√§lfte der Karte teleportieren, reicht es aus, die Faltgr√∂√üe einmal zu X hinzuzuf√ºgen. Und wenn die Versatzkoordinate gr√∂√üer als die Faltgr√∂√üe ist, m√ºssen wir eine Subtraktion durchf√ºhren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Bearbeiten des unteren oder oberen Randes der Karte </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">treten </font><font style="vertical-align: inherit;">manchmal Fehler auf. </font><font style="vertical-align: inherit;">Dies geschieht, wenn der Cursor aufgrund von Verzerrungen der Scheitelpunkte in der Zellenreihe au√üerhalb der Karte angezeigt wird. </font><font style="vertical-align: inherit;">Dies ist ein Fehler, der auftritt, weil die Koordinaten nicht </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Vektorparameter </font><font style="vertical-align: inherit;">√ºbereinstimmen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies kann behoben werden, indem eine Methode </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit Koordinaten als Parametern </font><font style="vertical-align: inherit;">angewendet </font><font style="vertical-align: inherit;">wird, die die erforderlichen √úberpr√ºfungen durchf√ºhrt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> K√ºstenfaltung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Triangulation funktioniert gut f√ºr das Gel√§nde, aber entlang der Ost-West-Naht gibt es keine R√§nder der Wasserk√ºste. </font><font style="vertical-align: inherit;">Tats√§chlich brechen sie einfach nicht zusammen. </font><font style="vertical-align: inherit;">Sie werden umgedreht und auf die andere Seite der Karte gestreckt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlender Rand des Wassers. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschieht, weil wir beim Triangulieren des K√ºstenwassers die Position eines Nachbarn verwenden. </font><font style="vertical-align: inherit;">Um dies zu beheben, m√ºssen wir feststellen, womit wir es zu tun haben, auf der anderen Seite der Karte. </font><font style="vertical-align: inherit;">Um die Aufgabe zu vereinfachen, f√ºgen wir der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft f√ºr den Index eine Zellenspalte hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie diesen Index zu </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie ist einfach gleich der Versatzkoordinate X geteilt durch die Fragmentgr√∂√üe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bestimmen, was minimiert wird, indem </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">den Spaltenindex der aktuellen Zelle und ihres Nachbarn vergleichen. </font><font style="vertical-align: inherit;">Wenn der Index der Spalte des Nachbarn weniger als einen Schritt kleiner ist, befinden wir uns auf der Westseite und der Nachbar auf der Ostseite. </font><font style="vertical-align: inherit;">Deshalb m√ºssen wir unseren Nachbarn nach Westen wenden. </font><font style="vertical-align: inherit;">Das gleiche und in die entgegengesetzte Richtung.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rippen der K√ºste, aber keine Ecken. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir uns um die Rippen der K√ºste gek√ºmmert, uns aber bisher nicht um Ecken gek√ºmmert. </font><font style="vertical-align: inherit;">Wir m√ºssen dasselbe mit dem n√§chsten Nachbarn tun.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtig gek√ºrzte K√ºste.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartengenerierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die M√∂glichkeit, die Ost- und Westseite zu verbinden, wirkt sich auf die Erstellung von Karten aus. </font><font style="vertical-align: inherit;">Bei der Minimierung der Karte sollte auch der Generierungsalgorithmus minimiert werden. </font><font style="vertical-align: inherit;">Dies f√ºhrt zur Erstellung einer weiteren Karte. Wenn Sie jedoch einen Kartenrand </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ungleich Null verwenden </font><em><font style="vertical-align: inherit;">, ist das</font></em><font style="vertical-align: inherit;"> Falten nicht offensichtlich.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gro√üe Karte 1208905299 mit Standardeinstellungen. Mit und ohne Falten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn minimierter nicht sinnvoll zu verwenden , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Karte Border die X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aber wir k√∂nnen es nicht einfach loswerden, weil gleichzeitig die Regionen verschmelzen werden. Beim Minimieren k√∂nnen wir einfach einen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder verwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir √§ndern uns </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ersetzen in jedem Fall </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diese neue Variable ist gleich oder </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, abh√§ngig vom Wert der Option zum Reduzieren. Unten habe ich die √Ñnderungen nur f√ºr den ersten Fall gezeigt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichzeitig bleiben die Regionen getrennt, dies ist jedoch nur erforderlich, wenn sich auf der Ost- und Westseite der Karte unterschiedliche Regionen befinden. </font><font style="vertical-align: inherit;">Es gibt zwei F√§lle, in denen dies nicht beachtet wird. </font><font style="vertical-align: inherit;">Das erste ist, wenn wir nur eine Region haben. </font><font style="vertical-align: inherit;">Die zweite ist, wenn zwei Regionen die Karte horizontal teilen. </font><font style="vertical-align: inherit;">In diesen F√§llen k√∂nnen wir einen </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert von Null </font><font style="vertical-align: inherit;">zuweisen </font><font style="vertical-align: inherit;">, der es den Landmassen erm√∂glicht, die Ost-West-Naht zu √ºberqueren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Region bricht zusammen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf den ersten Blick scheint alles richtig zu funktionieren, aber es gibt tats√§chlich eine L√ºcke entlang der Naht. </font><font style="vertical-align: inherit;">Dies wird deutlicher, wenn Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosionsprozentsatz auf</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Null setzen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Erosion deaktiviert ist, macht sich eine Naht am Relief bemerkbar.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die L√ºcke entsteht, weil die Naht das Wachstum von Relieffragmenten verhindert. Um zu bestimmen, was zuerst hinzugef√ºgt wird, wird der Abstand von der Zelle zur Mitte des Fragments verwendet, und die Zellen auf der anderen Seite der Karte k√∂nnen sehr weit entfernt sein, sodass sie sich fast nie einschalten. Das ist nat√ºrlich falsch. Wir m√ºssen sicherstellen, dass wir </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºber die minimierte Karte Bescheid wissen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berechnen den Abstand zwischen </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, summieren die absoluten Abst√§nde entlang jeder der drei Achsen und halbieren das Ergebnis. Der Abstand entlang Z ist immer wahr, aber das Falten entlang kann die X- und Y-Abst√§nde beeinflussen. Beginnen wir also mit einer separaten Berechnung von X + Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist keine leichte Aufgabe, festzustellen, ob durch das Falten ein k√ºrzerer Abstand f√ºr beliebige Zellen entsteht. Berechnen wir also einfach X + Y f√ºr F√§lle, in denen wir eine andere Koordinate nach Westen falten. </font><font style="vertical-align: inherit;">Wenn der Wert kleiner als das urspr√ºngliche X + Y ist, verwenden Sie ihn.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn dies nicht zu einer k√ºrzeren Entfernung f√ºhrt, ist es m√∂glich, in die andere Richtung k√ºrzer zu drehen, also werden wir es √ºberpr√ºfen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt erhalten wir immer die k√ºrzeste Entfernung auf der zusammenklappbaren Karte. </font><font style="vertical-align: inherit;">Gel√§ndefragmente werden nicht mehr durch eine Naht blockiert, wodurch sich Landmassen zusammenrollen k√∂nnen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtig faltbares Relief ohne Erosion und Erosion. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Welt bereisen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir uns mit der Kartenerstellung und Triangulation befasst haben, fahren wir nun mit der √úberpr√ºfung der Trupps, der Erkundung und der Sichtbarkeit fort. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naht testen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das erste Hindernis, auf das wir sto√üen, wenn wir einen Trupp um die Welt bewegen, ist der Rand der Karte, der nicht erkundet werden kann. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Naht der Karte kann nicht untersucht werden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zellen am Rand der Karte werden nicht erforscht, um die abrupte Fertigstellung der Karte zu verbergen. </font><font style="vertical-align: inherit;">Wenn die Karte jedoch minimiert ist, sollten nur die Nord- und S√ºdzellen markiert werden, nicht jedoch die Ost- und Westzellen. </font><font style="vertical-align: inherit;">√Ñndern Sie dies </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um dies zu ber√ºcksichtigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit von Reliefmerkmalen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberpr√ºfen wir nun, ob die Sichtbarkeit entlang der Naht funktioniert. </font><font style="vertical-align: inherit;">Es funktioniert f√ºr Gel√§nde, aber nicht f√ºr Gel√§ndeobjekte. </font><font style="vertical-align: inherit;">Es sieht so aus, als w√ºrden kollabierende Objekte die Sichtbarkeit der letzten Zelle erhalten, die nicht reduziert wurde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsche Sichtbarkeit von Objekten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschieht, weil der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klemmmodus </font><font style="vertical-align: inherit;">f√ºr den verwendeten Texturfaltmodus eingestellt ist </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um das Problem zu l√∂sen, √§ndern Sie einfach den Klemmmodus, um ihn zu wiederholen. </font><font style="vertical-align: inherit;">Wir m√ºssen dies jedoch nur f√ºr die Koordinaten von U tun, daher werden </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separat </font><font style="vertical-align: inherit;">einstellen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } ‚Ä¶ }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trupps und Spalten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Problem ist, dass die Einheiten noch nicht zusammenbrechen. </font><font style="vertical-align: inherit;">Nach dem Verschieben der S√§ule, in der sie sich befinden, bleiben die Einheiten an derselben Stelle.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ger√§t wird nicht √ºbertragen und befindet sich auf der falschen Seite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Problem kann gel√∂st werden, indem Squads untergeordnete Elemente von Spalten erstellt werden, wie wir es bei Fragmenten getan haben. </font><font style="vertical-align: inherit;">Erstens werden wir sie nicht l√§nger zu den unmittelbaren Kindern des Gitters machen </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da sich die Einheiten bewegen, werden sie m√∂glicherweise in einer anderen Spalte angezeigt. Das hei√üt, sie m√ºssen ihre √ºbergeordneten Einheiten √§ndern. </font><font style="vertical-align: inherit;">Um dies zu erm√∂glichen, f√ºgen wir der </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Methode hinzu </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und √ºbergeben als Parameter die Komponente des </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untergeordneten Elements und den Spaltenindex.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Methode aufrufen, wenn die Eigenschaft festgelegt ist </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies l√∂st das Problem der Erstellung von Einheiten. </font><font style="vertical-align: inherit;">Wir m√ºssen sie aber auch dazu bringen, sich beim Verschieben in die gew√ºnschte Spalte zu bewegen. </font><font style="vertical-align: inherit;">Dazu m√ºssen Sie </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die aktuelle Spalte </font><font style="vertical-align: inherit;">im </font><font style="vertical-align: inherit;">Index </font><font style="vertical-align: inherit;">verfolgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zu Beginn dieser Methode ist dies der Index der Zellenspalte am Anfang des Pfads oder der aktuelle, wenn die Verschiebung durch Neukompilierung unterbrochen wurde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> W√§hrend jeder Iteration der Verschiebung pr√ºfen wir, ob der Index der n√§chsten Spalte unterschiedlich ist, und wenn ja, √§ndern wir das √ºbergeordnete Element der Reihenfolge. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch k√∂nnen sich Einheiten √§hnlich wie Fragmente bewegen. </font><font style="vertical-align: inherit;">Wenn Sie sich jedoch durch die Naht der Karte bewegen, fallen die Einheiten noch nicht zusammen. </font><font style="vertical-align: inherit;">Stattdessen bewegen sie sich pl√∂tzlich in die falsche Richtung. </font><font style="vertical-align: inherit;">Dies geschieht unabh√§ngig von der Position der Naht, jedoch am deutlichsten, wenn sie √ºber die gesamte Karte springen.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pferderennen √ºber die Karte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier k√∂nnen wir den gleichen Ansatz verwenden, der f√ºr die K√ºste verwendet wurde, nur dass wir diesmal die Kurve drehen, entlang der sich die Abl√∂sung bewegt. </font><font style="vertical-align: inherit;">Wenn die n√§chste Spalte nach Osten gedreht wird, teleportieren wir die Kurve auch nach Osten, √§hnlich f√ºr die andere Richtung. </font><font style="vertical-align: inherit;">Sie m√ºssen die Kontrollpunkte der Kurve </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">√§ndern </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was sich auch auf den Kontrollpunkt auswirkt </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); ‚Ä¶ }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegung mit Falten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Letzte, was Sie tun m√ºssen, ist, die erste Runde des Trupps zu √§ndern, wenn es auf die erste Zelle schaut, in die es sich bewegen wird. Befindet sich diese Zelle auf der anderen Seite der Ost-West-Naht, schaut das Ger√§t in die falsche Richtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Minimieren einer Karte gibt es zwei M√∂glichkeiten, einen Punkt zu betrachten, der sich nicht genau im Norden oder S√ºden befindet. Sie k√∂nnen entweder nach Osten oder nach Westen schauen. Es ist logisch, in die Richtung zu schauen, die dem n√§chstgelegenen Abstand zum Punkt entspricht, da dies auch die Bewegungsrichtung ist. Verwenden wir sie also in </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Minimieren √ºberpr√ºfen wir den relativen Abstand entlang der X-Achse. Wenn er kleiner als die negative H√§lfte der Kartenbreite ist, sollten wir nach Westen schauen. Dies kann durch Drehen des Punkts nach Westen erfolgen. </font><font style="vertical-align: inherit;">Andernfalls m√ºssen wir nach Osten kollabieren, wenn die Entfernung mehr als die H√§lfte der Breite der Karte betr√§gt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben also eine voll funktionsf√§hige minimierte Karte. </font><font style="vertical-align: inherit;">Damit ist die Reihe der Tutorials auf Sechseckkarten abgeschlossen. </font><font style="vertical-align: inherit;">Wie in den vorherigen Abschnitten erw√§hnt, k√∂nnen andere Themen ber√ºcksichtigt werden, sie sind jedoch nicht spezifisch f√ºr Sechseckkarten. </font><font style="vertical-align: inherit;">Vielleicht werde ich sie in zuk√ºnftigen Tutorials ber√ºcksichtigen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe das letzte Paket heruntergeladen und bekomme im Play-Modus Turn-Fehler</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe das letzte Paket heruntergeladen und die Grafiken sind nicht so sch√∂n wie in den Screenshots</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe das letzte Paket heruntergeladen und es generiert st√§ndig die gleiche Karte</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427567/">https://habr.com/ru/post/de427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427555/index.html">Tiere, die Menschen mithilfe der Gesichtserkennungstechnologie zu verfolgen gelernt haben</a></li>
<li><a href="../de427557/index.html">Zusammenfassung der IT-Ereignisse im November (Teil 1)</a></li>
<li><a href="../de427561/index.html">Recht auf Reparatur: Die ersten Schritte in die richtige Richtung von Motorola</a></li>
<li><a href="../de427563/index.html">In Firefox Nightly implementierter verschl√ºsselter SNI-Standard</a></li>
<li><a href="../de427565/index.html">‚ÄûMeine Leistung war, dass ich im Allgemeinen zum Beruf zur√ºckgekehrt bin‚Äú - 10 Fragen an den Programmierer, Ausgabe 10</a></li>
<li><a href="../de427569/index.html">Optimieren Sie OpenStack unter hoher Last</a></li>
<li><a href="../de427571/index.html">Die Vereinigung von R und PostgreSQL. Wir analysieren die Arbeit von Flugh√§fen, berechnen Renten</a></li>
<li><a href="../de427573/index.html">S√º√üigkeiten oder Leben: Halloween als Grund, Ihr Kind f√ºr die Wissenschaft zu begeistern</a></li>
<li><a href="../de427575/index.html">Warum Wi-Fi nicht wie geplant funktioniert und warum Sie wissen, welches Telefon der Mitarbeiter verwendet</a></li>
<li><a href="../de427577/index.html">Maschinelles Lernen vs. Signaturanalyse beim Erkennen von Angriffen auf eine Webanwendung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>