<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏹 🎅 ⛱️ Sechseckkarten in Unity: Wasserkreislauf, Erosion, Biomes, zylindrische Karte 👨‍👨‍👧 😌 🤧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teile 1-3: Netz, Farben und Zellenhöhen 

 Teile 4-7: Unebenheiten, Flüsse und Straßen 

 Teile 8-11: Wasser, Landformen und Wälle 

 Teile 12-15: Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sechseckkarten in Unity: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427567/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenhöhen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Flüsse und Straßen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und Wälle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 24: Regionen und Erosion </h1><br><ul><li>  Fügen Sie einen Wasserrand um die Karte hinzu. </li><li>  Wir teilen die Karte in mehrere Regionen. </li><li>  Wir verwenden Erosion, um Klippen abzuschneiden. </li><li>  Wir bewegen das Land, um das Relief zu glätten. </li></ul><br>  Im vorigen Teil haben wir den Grundstein für die prozedurale Kartengenerierung gelegt.  Dieses Mal werden wir die Orte des möglichen Auftretens von Land begrenzen und mit Erosion darauf einwirken. <br><br>  Dieses Tutorial wurde in Unity 2017.1.0 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>Trenne und glatte das Land.</i> <br><a name="habracut"></a><br><h2>  Kartenrand </h2><br>  Da wir Landflächen zufällig erhöhen, kann es vorkommen, dass Land den Rand der Karte berührt.  Dies kann unerwünscht sein.  Die wasserbegrenzte Karte enthält eine natürliche Barriere, die Spieler daran hindert, sich dem Rand zu nähern.  Daher wäre es schön, wenn wir dem Land verbieten würden, sich in der Nähe des Kartenrandes über den Wasserspiegel zu erheben. <br><br><h3>  Randgröße </h3><br>  Wie nah sollte das Land am Rand der Karte sein?  Es gibt keine richtige Antwort auf diese Frage, daher werden wir diesen Parameter anpassbar machen.  Wir werden der <code>HexMapGenerator</code> Komponente zwei Schieberegler <code>HexMapGenerator</code> , einen für Ränder entlang der Kanten entlang der X-Achse und einen für Ränder entlang der Z-Achse. So können wir einen breiteren Rand in einer der Dimensionen verwenden oder sogar einen Rand in nur einer Dimension erstellen.  Verwenden wir ein Intervall von 0 bis 10 mit einem Standardwert von 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Schieberegler für Kartenränder.</i> <br><br><h3>  Wir begrenzen die Zentren von Landflächen </h3><br>  Ohne Rahmen sind alle Zellen gültig.  Wenn es Grenzen gibt, nehmen die minimal zulässigen Versatzkoordinaten zu und die maximal zulässigen Koordinaten ab.  Da wir zum Generieren der Diagramme das zulässige Intervall kennen müssen, verfolgen wir es anhand von vier ganzzahligen Feldern. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Wir initialisieren die Einschränkungen in <code>GenerateMap</code> bevor wir Sushi erstellen.  Wir verwenden diese Werte als Parameter für <code>Random.Range</code> Aufrufe, sodass die Höhen tatsächlich außergewöhnlich sind.  Ohne Rand sind sie gleich der Anzahl der Messzellen, also nicht minus 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); … }</code> </pre> <br>  Wir werden das Erscheinen von Land jenseits der Grenze nicht strikt verbieten, da dies zu scharf geschnittenen Kanten führen würde.  Stattdessen beschränken wir nur die Zellen, die zum Starten der Erstellung von Plots verwendet werden.  Das heißt, die ungefähren Zentren der Standorte werden begrenzt sein, aber Teile der Standorte können über das Grenzgebiet hinausgehen.  Dies kann durch Ändern von <code>GetRandomCell</code> sodass eine Zelle im Bereich der zulässigen Offsets ausgewählt wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>Die Ränder der Karte sind 0 × 0, 5 × 5, 10 × 10 und 0 × 10.</i> <br><br>  Wenn alle Kartenparameter auf ihre Standardwerte eingestellt sind, schützt ein Rand der Größe 5 den Rand der Karte zuverlässig vor Landberührungen.  Dies ist jedoch nicht garantiert.  Das Land kann sich manchmal dem Rand nähern und es manchmal an mehreren Stellen berühren. <br><br>  Die Wahrscheinlichkeit, dass Land die gesamte Grenze überschreitet, hängt von der Größe der Grenze und der maximalen Größe des Standorts ab.  Ohne zu zögern bleiben die Abschnitte Sechsecke.  Volles Sechseck mit Radius <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> r </script>  enthält <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.32ex" height="2.539ex" viewBox="0 -935.7 5304.3 1093.4" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="1628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="2628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="3129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="3803" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="4803" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 3r ^ 2 + 3r + 1 </script>  Zellen.  Wenn es Sechsecke mit einem Radius gibt, der der Größe des Randes entspricht, können sie diesen überqueren.  Ein volles Sechseck mit einem Radius von 5 enthält 91 Zellen.  Da das Maximum standardmäßig 100 Zellen pro Abschnitt beträgt, bedeutet dies, dass Land eine Brücke über 5 Zellen legen kann, insbesondere wenn Vibrationen auftreten.  Um dies zu verhindern, verringern Sie entweder die maximale Größe des Diagramms oder vergrößern Sie den Rand. <br><br><div class="spoiler">  <b class="spoiler_title">Wie wird die Formel für die Anzahl der Zellen in der hexagonalen Region abgeleitet?</b> <div class="spoiler_text">  Bei einem Radius von 0 handelt es sich um eine einzelne Zelle.  Es kam von 1. Mit einem Radius von 1 um die Mitte gibt es sechs zusätzliche Zellen, das heißt <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.165ex" height="2.211ex" viewBox="0 -772.3 2223.9 952" role="img" focusable="false" style="vertical-align: -0.417ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="722" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="1723" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 6 + 1 </script>  .  Diese sechs Zellen können als die Enden von sechs Dreiecken betrachtet werden, die die Mitte berühren.  Mit einem Radius von 2 wird diesen Dreiecken eine zweite Reihe hinzugefügt, dh zwei weitere Zellen werden auf dem Dreieck erhalten, und insgesamt <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.14ex" height="2.762ex" viewBox="0 -831.5 5226.9 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="3113" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="3725" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="4726" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> 6 (1 + 2) + 1 </script>  .  Mit einem Radius von 3 wird eine dritte Zeile hinzugefügt, dh drei weitere Zellen pro Dreieck und insgesamt <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.143ex" height="2.762ex" viewBox="0 -831.5 6950.3 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="3336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="4336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="4837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="5449" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="6449" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> 6 (1 + 2 + 3) + 1 </script>  .  Usw.  Das heißt, im Allgemeinen sieht die Formel so aus <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mo stretchy=&quot;false&quot;>(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="73.646ex" height="3.312ex" viewBox="0 -950 31708.4 1426" role="img" focusable="false" aria-hidden="true" style="vertical-align: -1.106ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-73" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-75" x="1359" y="0"></use><g transform="translate(1932,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="1242" y="-264"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-69" x="3185" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-3D" x="3809" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="4865" y="0"></use><g transform="translate(5365,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-69" x="6174" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="6520" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="7131" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="8132" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-3D" x="8910" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-36" x="9967" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="10467" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="10857" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="11246" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="11698" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="12087" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="12761" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="13762" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="14213" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="14603" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2F" x="14992" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="15493" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="15993" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="16605" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="17606" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-3D" x="18384" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="19440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="19941" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-28" x="20392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="20782" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="21455" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="22456" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-29" x="22957" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="23568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="24569" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-3D" x="25347" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="26404" y="0"></use><g transform="translate(26904,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="28032" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-33" x="29032" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMATHI-72" x="29533" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-2B" x="30207" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhjhMm4xJNIrc_DPlY1SWqQxDY5msA#MJMAIN-31" x="31207" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mo stretchy="false">(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-6"> 6 (sum_ (i = 1) ^ r i) +1 = 6 ((r (r + r)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 </script>  . </div></div><br>  Um dies klarer zu sehen, können wir die Rahmengröße auf 200 einstellen. Da ein volles Sechseck mit einem Radius von 8 217 Zellen enthält, berührt Land wahrscheinlich den Rand der Karte.  Zumindest wenn Sie den Standardwert für die Rahmengröße (5) verwenden.  Wenn Sie den Rand auf 10 erhöhen, verringert sich die Wahrscheinlichkeit erheblich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>Das Grundstück hat eine konstante Größe von 200, die Ränder der Karte sind 5 und 10.</i> <br><br><h3>  Pangaea </h3><br>  Beachten Sie, dass wir das Land zwingen, eine kleinere Fläche zu bilden, wenn Sie den Kartenrand vergrößern und den gleichen Prozentsatz an Land beibehalten.  Infolgedessen erzeugt eine große Karte standardmäßig sehr wahrscheinlich eine einzige große Landmasse - den Superkontinent Pangaea - möglicherweise mit mehreren kleinen Inseln.  Mit zunehmender Größe der Grenze steigt die Wahrscheinlichkeit, dass dies geschieht, und bei bestimmten Werten ist fast garantiert, dass wir einen Superkontinent bekommen.  Wenn jedoch der Landanteil zu groß ist, füllen sich die meisten verfügbaren Flächen und als Ergebnis erhalten wir eine fast rechteckige Landmasse.  Um dies zu verhindern, müssen Sie den Landanteil reduzieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>40% Sushi mit einem Kartenrand von 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Woher kommt der Name Pangaea?</b> <div class="spoiler_text">  Das war der Name des letzten bekannten Superkontinents, der vor vielen Jahren auf der Erde existierte.  Der Name besteht aus den griechischen Wörtern pan und Gaia und bedeutet so etwas wie "alle Natur" oder "alles Land". </div></div><br><br><h3>  Wir schützen vor unmöglichen Karten </h3><br>  Wir erzeugen die richtige Menge Land, indem wir das Land einfach weiter anheben, bis wir die gewünschte Landmasse erreicht haben.  Dies funktioniert, weil wir früher oder später jede Zelle auf dem Wasserspiegel anheben werden.  Wenn Sie jedoch den Rand der Karte verwenden, können wir nicht jede Zelle erreichen.  Wenn ein zu hoher Prozentsatz an Land benötigt wird, führt dies zu endlosen „Versuchen und Fehlern“ des Generators, mehr Land zu heben, und es bleibt in einem endlosen Zyklus stecken.  In diesem Fall friert die Anwendung ein, dies sollte jedoch nicht geschehen. <br><br>  Wir können unmögliche Konfigurationen nicht zuverlässig im Voraus finden, aber wir können uns vor endlosen Zyklen schützen.  Wir werden einfach die Anzahl der in <code>CreateLand</code> ausgeführten Zyklen <code>CreateLand</code> .  Wenn es zu viele Iterationen gibt, stecken wir höchstwahrscheinlich fest und sollten aufhören. <br><br>  Für eine große Karte scheinen tausend Iterationen akzeptabel zu sein, und zehntausend Iterationen scheinen bereits absurd.  Verwenden wir diesen Wert also als Endpunkt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); … } }</span></span></code> </pre> <br>  Wenn wir eine beschädigte Karte erhalten, nehmen 10.000 Iterationen nicht viel Zeit in Anspruch, da viele Zellen schnell die maximale Höhe erreichen, wodurch das Wachstum neuer Bereiche verhindert wird. <br><br>  Selbst nach dem Durchbrechen der Schleife erhalten wir immer noch die richtige Karte.  Es gibt einfach nicht die richtige Menge an Sushi und es wird nicht sehr interessant aussehen.  Lassen Sie uns eine Benachrichtigung darüber in der Konsole anzeigen und uns mitteilen, welches verbleibende Land wir nicht ausgegeben haben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>95% des Landes mit einer Kartengrenze von 10 konnten nicht den gesamten Betrag ausgeben.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Warum weist eine fehlerhafte Karte immer noch Abweichungen auf?</b> <div class="spoiler_text">  Die Küste ist variabel, denn wenn die Höhen innerhalb des Erstellungsbereichs zu hoch werden, können sie in neuen Bereichen nicht nach außen wachsen.  Das gleiche Prinzip erlaubt es Parzellen nicht, in kleine Landflächen zu wachsen, bis sie die maximale Höhe erreicht haben und sich einfach als vermisst herausstellen.  Außerdem nimmt die Variabilität beim Absenken der Diagramme zu. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Eine Karte partitionieren </h2><br>  Nachdem wir den Kartenrand haben, haben wir die Karte im Wesentlichen in zwei separate Regionen unterteilt: die Grenzregion und die Region, in der die Diagramme erstellt wurden.  Da uns nur die Region der Schöpfung wichtig ist, können wir einen solchen Fall als eine Situation mit einer Region betrachten.  Die Region deckt einfach nicht die gesamte Karte ab.  Wenn dies jedoch unmöglich ist, hindert uns nichts daran, die Karte in mehrere nicht zusammenhängende Regionen der Landschöpfung zu unterteilen.  Dadurch können sich Landmassen unabhängig voneinander bilden und verschiedene Kontinente bestimmen. <br><br><h3>  Kartenregion </h3><br>  Beginnen wir damit, eine Region der Karte als Struktur zu beschreiben.  Dies wird unsere Arbeit mit mehreren Regionen vereinfachen.  Erstellen <code>MapRegion</code> hierfür eine <code>MapRegion</code> Struktur, die einfach die Randfelder der Region enthält.  Da wir diese Struktur nicht außerhalb von <code>HexMapGenerator</code> , können wir sie innerhalb dieser Klasse als private interne Struktur definieren.  Dann können vier ganzzahlige Felder durch ein <code>MapRegion</code> Feld ersetzt werden. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  Damit alles funktioniert, müssen wir das Regionspräfix zu den Minimum-Maximum-Feldern in <code>GenerateMap</code> hinzufügen <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  Und auch in <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  Mehrere Regionen </h3><br>  Ersetzen Sie ein <code>MapRegion</code> Feld <code>MapRegion</code> Liste von Regionen, um mehrere Regionen zu unterstützen. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  An dieser Stelle wäre es schön, eine separate Methode zum Erstellen von Regionen hinzuzufügen.  Es sollte die gewünschte Liste erstellen oder löschen, falls sie bereits vorhanden ist.  Danach bestimmt er wie zuvor eine Region und fügt sie der Liste hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Wir werden diese Methode in <code>GenerateMap</code> aufrufen und die Region nicht direkt erstellen. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  Damit <code>GetRandomCell</code> mit einer beliebigen Region arbeiten kann, geben Sie ihm den <code>MapRegion</code> Parameter. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Jetzt sollten die <code>SinkTerrain</code> <code>RaiseTerraion</code> und <code>SinkTerrain</code> die entsprechende Region an <code>GetRandomCell</code> .  Dazu benötigt jeder von ihnen auch einen Regionsparameter. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … }</code> </pre> <br>  Die <code>CreateLand</code> Methode sollte für jede Region festlegen, dass die Abschnitte <code>CreateLand</code> oder <code>CreateLand</code> werden sollen.  Um das Land zwischen den Regionen auszugleichen, werden wir einfach wiederholt die Liste der Regionen im Zyklus durchgehen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  Wir müssen jedoch die Absenkung der Parzellen gleichmäßig verteilen.  Dies kann erfolgen, während für alle Regionen entschieden wird, ob sie weggelassen werden sollen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Um genau die gesamte Landmenge zu nutzen, müssen wir den Prozess stoppen, sobald die Menge Null erreicht.  Dies kann in jeder Phase des Zyklus der Region geschehen.  Daher verschieben wir die Nullsummenprüfung in die innere Schleife.  Tatsächlich können wir diese Überprüfung nur durchführen, nachdem wir Land angehoben haben, da beim Absenken der Betrag niemals ausgegeben wird.  Wenn wir fertig sind, können wir die <code>CreateLand</code> Methode sofort <code>CreateLand</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Zwei Regionen </h3><br>  Obwohl wir jetzt die Unterstützung mehrerer Regionen haben, fragen wir immer noch nur eine.  Ändern Sie die <code>CreateRegions</code> so, dass die Karte vertikal in zwei <code>CreateRegions</code> .  Dazu halbieren wir den <code>xMax</code> Wert der hinzugefügten Region.  Dann verwenden wir denselben Wert für <code>xMin</code> und erneut den ursprünglichen Wert für <code>xMax</code> , wobei <code>xMax</code> ihn als zweiten Bereich verwenden. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  Das Generieren von Karten in dieser Phase macht keinen Unterschied.  Obwohl wir zwei Regionen identifiziert haben, besetzen sie dieselbe Region wie eine alte Region.  Um sie auseinander zu verteilen, müssen Sie einen leeren Raum zwischen ihnen lassen.  Dies kann durch Hinzufügen eines Schiebereglers zum Rand der Region erfolgen, wobei das gleiche Intervall und der gleiche Standardwert wie für die Ränder der Karte verwendet werden. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Regionsrand-Schieberegler.</i> <br><br>  Da Land auf beiden Seiten des Raums zwischen Regionen gebildet werden kann, steigt die Wahrscheinlichkeit, Landbrücken an den Rändern der Karte zu erstellen.  Um dies zu verhindern, verwenden wir den Rand der Region, um eine landfreie Zone zwischen der Trennlinie und der Region zu definieren, in der die Diagramme beginnen können.  Dies bedeutet, dass der Abstand zwischen benachbarten Regionen zwei größer ist als die Größe der Region. <br><br>  Um diese Bereichsgrenze anzuwenden, subtrahieren Sie sie vom <code>xMax</code> ersten Region und fügen Sie die zweite Region zu <code>xMin</code> . <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>Die Karte ist vertikal in zwei Regionen unterteilt.</i> <br><br>  Mit den Standardeinstellungen werden zwei deutlich getrennte Regionen erstellt. Wie bei einer Region und einem großen Kartenrand wird jedoch nicht garantiert, dass wir genau zwei Landmassen erhalten.  Meistens sind es zwei große Kontinente, möglicherweise mit mehreren Inseln.  Manchmal können jedoch zwei oder mehr große Inseln in einer Region erstellt werden.  Und manchmal können zwei Kontinente durch eine Landenge verbunden werden. <br><br>  Natürlich können wir die Karte auch horizontal teilen und die Ansätze für die Messung von X und Z ändern. Wählen wir zufällig eine von zwei möglichen Ausrichtungen. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Karte horizontal in zwei Regionen unterteilt.</i> <br><br>  Da wir eine breite Karte verwenden, werden breitere und dünnere Regionen mit horizontaler Trennung erstellt.  Infolgedessen bilden diese Regionen mit größerer Wahrscheinlichkeit mehrere geteilte Landmassen. <br><br><h3>  Vier Regionen </h3><br>  Lassen Sie uns die Anzahl der Regionen anpassbar machen und Unterstützung von 1 bis 4 Regionen erstellen. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Schieberegler für die Anzahl der Regionen.</i> <br><br>  Mit der <code>switch</code> können wir die Ausführung des entsprechenden Regionalcodes auswählen.  Wir beginnen mit der Wiederholung des Codes für eine Region, die standardmäßig verwendet wird, und belassen den Code für die beiden Regionen für Fall 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was ist die switch-Anweisung?</b> <div class="spoiler_text">  Dies ist eine Alternative zum Schreiben einer Folge von if-else-if-else-Anweisungen.  Der Schalter wird auf die Variable angewendet, und Beschriftungen geben an, welcher Code ausgeführt werden muss.  Es gibt auch eine <code>default</code> , die als letzter <code>else</code> Block verwendet wird.  Jede Option muss entweder mit einer <code>break</code> Anweisung oder einer <code>return</code> enden. <br><br>  Um den <code>switch</code> lesbar zu halten, ist es normalerweise am besten, alle Fälle kurz zu halten, idealerweise mit einer einzelnen Anweisung oder einem Methodenaufruf.  Ich werde dies nicht als Beispiel für einen Regionalcode tun, aber wenn Sie interessantere Regionen erstellen möchten, empfehle ich, separate Methoden zu verwenden.  Zum Beispiel: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Drei Regionen ähneln zwei, nur Drittel werden anstelle der Hälfte verwendet.  In diesem Fall werden durch die horizontale Unterteilung zu enge Bereiche erstellt, sodass nur die vertikale Unterteilung unterstützt wird.  Beachten Sie, dass wir dadurch den Grenzbereich der Region verdoppelt haben, sodass der Platz zum Erstellen neuer Websites geringer ist als bei zwei Regionen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Drei Regionen.</i> <br><br>  Es können vier Regionen erstellt werden, indem die horizontale und vertikale Trennung kombiniert und jeder Ecke der Karte eine Region hinzugefügt wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Vier Regionen.</i> <br><br>  Der hier verwendete Ansatz ist der einfachste Weg, eine Karte zu teilen.  Es erzeugt ungefähr die gleichen Regionen nach Landmasse, und ihre Variabilität wird durch andere Parameter der Kartenerzeugung gesteuert.  Es wird jedoch immer ziemlich offensichtlich sein, dass die Karte in gerade Linien geteilt wurde.  Je mehr Kontrolle wir brauchen, desto weniger organisch wird das Ergebnis aussehen.  Daher ist dies normal, wenn Sie für das Gameplay ungefähr gleiche Regionen benötigen.  Wenn Sie jedoch das abwechslungsreichste und unbegrenzteste Land benötigen, müssen Sie es mit Hilfe einer Region schaffen. <br><br>  Darüber hinaus gibt es andere Möglichkeiten, die Karte zu teilen.  Wir können uns nicht nur auf gerade Linien beschränken.  Wir müssen nicht einmal Regionen gleicher Größe verwenden und die gesamte Karte damit abdecken.  Wir können Löcher hinterlassen.  Sie können auch Schnittpunkte von Regionen zulassen oder die Landverteilung zwischen Regionen ändern.  Sie können sogar Ihre eigenen Generatorparameter für jede Region festlegen (obwohl dies komplizierter ist), um beispielsweise einen großen Kontinent und einen Archipel auf der Karte zu haben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Erosion </h2><br>  Bisher sahen alle Karten, die wir generiert haben, ziemlich unhöflich und kaputt aus.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine echte Erleichterung mag so aussehen, aber mit der Zeit wird sie immer glatter, und ihre scharfen Teile werden durch Erosion stumpf. </font><font style="vertical-align: inherit;">Um die Karten zu verbessern, können wir diesen Erosionsprozess anwenden. </font><font style="vertical-align: inherit;">Wir werden dies tun, nachdem wir raues Land in einer separaten Methode geschaffen haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosionsprozentsatz </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je mehr Zeit vergeht, desto mehr Erosion tritt auf. </font><font style="vertical-align: inherit;">Daher möchten wir, dass die Erosion nicht dauerhaft, sondern anpassbar ist. </font><font style="vertical-align: inherit;">Die Erosion ist mindestens Null, was den zuvor erstellten Karten entspricht. </font><font style="vertical-align: inherit;">Bei maximaler Erosion ist umfassend, dh die weitere Anwendung von Erosionskräften verändert das Gelände nicht mehr. </font><font style="vertical-align: inherit;">Das heißt, der Erosionsparameter sollte ein Prozentsatz von 0 bis 100 sein, und standardmäßig nehmen wir 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosionsschieber.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach erosionszerstörenden Zellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosion macht das Relief glatter. In unserem Fall sind die einzigen scharfen Teile die Klippen. Daher werden sie das Ziel des Erosionsprozesses sein. Wenn eine Klippe vorhanden ist, sollte sie durch Erosion verringert werden, bis sie schließlich zu einem Hang wird. Wir werden die Pisten nicht glätten, da dies zu einem langweiligen Gelände führen wird. Dazu müssen wir bestimmen, welche Zellen sich oben auf den Klippen befinden, und ihre Höhe senken. Dies sind erosionsanfällige Zellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns eine Methode erstellen, die bestimmt, ob eine Zelle anfällig für Erosion ist. </font><font style="vertical-align: inherit;">Er ermittelt dies, indem er die Nachbarn der Zelle überprüft, bis er einen ausreichend großen Höhenunterschied findet. </font><font style="vertical-align: inherit;">Da Klippen einen Höhenunterschied von mindestens einer oder zwei Höhenstufen erfordern, ist die Zelle einer Erosion ausgesetzt, wenn sich einer oder mehrere ihrer Nachbarn mindestens zwei Stufen darunter befinden. </font><font style="vertical-align: inherit;">Wenn es keinen solchen Nachbarn gibt, kann die Zelle keine Erosion erfahren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können diese Methode verwenden </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um alle Zellen zu durchlaufen und alle erosionsanfälligen Zellen in eine temporäre Liste zu schreiben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald wir die Gesamtzahl der erosionsanfälligen Zellen kennen, können wir den Prozentsatz der Erosion verwenden, um die Anzahl der verbleibenden erosionsanfälligen Zellen zu bestimmen. </font><font style="vertical-align: inherit;">Wenn der Prozentsatz beispielsweise 50 beträgt, müssen wir Erosionszellen erodieren, bis die Hälfte der ursprünglichen Menge übrig bleibt. </font><font style="vertical-align: inherit;">Wenn der Prozentsatz 100 beträgt, werden wir nicht aufhören, bis wir alle erosionsanfälligen Zellen zerstört haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollten wir nicht nur Zellen berücksichtigen, die zu Landerosion neigen?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellreduktion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit einem naiven Ansatz und nehmen wir an, dass eine einfache Verringerung der Höhe der durch Erosion zerstörten Zellen dazu führt, dass sie nicht mehr anfällig für Erosion sind. </font><font style="vertical-align: inherit;">Wenn dies wahr wäre, könnten wir einfach zufällige Zellen aus der Liste nehmen, ihre Höhe verringern und sie dann aus der Liste entfernen. </font><font style="vertical-align: inherit;">Wir würden diesen Vorgang wiederholen, bis wir die gewünschte Anzahl erosionsanfälliger Zellen erreicht haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die erforderliche Suche zu verhindern </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, überschreiben wir die aktuelle Zelle zuletzt in der Liste und löschen dann das letzte Element. </font><font style="vertical-align: inherit;">Ihre Bestellung ist uns immer noch egal.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naive Abnahme von 0% und 100% erosionsanfälliger Zellen, Samenkarte 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosionsverfolgung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser naiver Ansatz ermöglicht es uns, Erosion anzuwenden, aber nicht im richtigen Maße. </font><font style="vertical-align: inherit;">Dies geschieht, weil die Zelle nach einer Verringerung der Höhe immer noch anfällig für Erosion bleiben kann. </font><font style="vertical-align: inherit;">Daher werden wir eine Zelle nur dann aus der Liste entfernen, wenn sie nicht mehr der Erosion ausgesetzt ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% Erosion unter Beibehaltung erosionsanfälliger Zellen in der Liste. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bekommen also eine viel stärkere Erosion, aber wenn wir 100% verwenden, werden wir immer noch nicht alle Klippen los. </font><font style="vertical-align: inherit;">Der Grund ist, dass nach dem Verringern der Höhe der Zelle einer ihrer Nachbarn anfällig für Erosion werden kann. </font><font style="vertical-align: inherit;">Infolgedessen haben wir möglicherweise mehr erosionsanfällige Zellen als ursprünglich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Zelle abgesenkt haben, müssen wir alle Nachbarn überprüfen. </font><font style="vertical-align: inherit;">Wenn sie jetzt anfällig für Erosion sind, aber noch nicht auf der Liste stehen, müssen Sie sie dort hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle erodierten Zellen werden weggelassen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir sparen viel Land </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt kann der Erosionsprozess fortgesetzt werden, bis alle Klippen verschwunden sind. Dies wirkt sich stark auf das Land aus. Der größte Teil der Landmasse verschwand und wir bekamen viel weniger als den Prozentsatz des benötigten Landes. Es ist passiert, weil wir Land von der Karte entfernen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wahre Erosion zerstört keine Materie. Sie nimmt es von einem Ort und platziert es woanders. Wir können das Gleiche tun. Mit einer Abnahme in einer Zelle müssen wir einen ihrer Nachbarn großziehen. Tatsächlich wird eine Höhenstufe auf eine untere Zelle übertragen. Dies spart die Gesamtmenge der Kartenhöhen und glättet sie einfach.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu realisieren, müssen wir entscheiden, wohin Erosionsprodukte übertragen werden sollen. </font><font style="vertical-align: inherit;">Dies wird unser Erosionsziel sein. </font><font style="vertical-align: inherit;">Erstellen wir eine Methode, um den Zielpunkt einer zu erodierenden Zelle zu bestimmen. </font><font style="vertical-align: inherit;">Da diese Zelle eine Unterbrechung enthält, wäre es logisch, die unter dieser Unterbrechung befindliche Zelle als Ziel auszuwählen. </font><font style="vertical-align: inherit;">Eine erosionsgefährdete Zelle kann jedoch mehrere Pausen haben. Daher überprüfen wir alle Nachbarn und setzen alle Kandidaten auf eine temporäre Liste. Anschließend wählen wir zufällig einen von ihnen aus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definieren wir die Zielzelle unmittelbar nach Auswahl der Erosionszelle. </font><font style="vertical-align: inherit;">Dann verringern und erhöhen wir die Zellhöhen unmittelbar nacheinander. </font><font style="vertical-align: inherit;">In diesem Fall kann die Zielzelle selbst anfällig für Erosion werden. Diese Situation wird jedoch behoben, wenn wir die Nachbarn der neu erodierten Zelle überprüfen.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir die Zielzelle angehoben haben, ist ein Teil der Nachbarn dieser Zelle möglicherweise nicht mehr der Erosion ausgesetzt. </font><font style="vertical-align: inherit;">Es ist notwendig, um sie herumzugehen und zu prüfen, ob sie anfällig für Erosion sind. </font><font style="vertical-align: inherit;">Wenn nicht, aber sie sind in der Liste enthalten, müssen Sie sie daraus entfernen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); … } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% Erosion unter Beibehaltung der Landmasse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Erosion kann das Gelände jetzt viel besser geglättet werden, indem einige Bereiche abgesenkt und andere angehoben werden. </font><font style="vertical-align: inherit;">Infolgedessen kann die Landmasse sowohl zunehmen als auch sich verengen. </font><font style="vertical-align: inherit;">Dies kann den Landanteil in der einen oder anderen Richtung um mehrere Prozent verändern, es treten jedoch selten schwerwiegende Abweichungen auf. </font><font style="vertical-align: inherit;">Das heißt, je mehr Erosion wir anwenden, desto weniger Kontrolle haben wir über den resultierenden Prozentsatz an Land.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beschleunigte Erosion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir uns nicht wirklich um die Effektivität des Erosionsalgorithmus kümmern müssen, können wir ihn einfach verbessern. </font><font style="vertical-align: inherit;">Beachten Sie zunächst, dass wir explizit prüfen, ob die von uns erodierte Zelle erodiert werden kann. </font><font style="vertical-align: inherit;">Wenn nicht, entfernen wir es im Wesentlichen aus der Liste. </font><font style="vertical-align: inherit;">Daher können Sie das Überprüfen dieser Zelle überspringen, wenn Sie die Nachbarn der Zielzelle durchlaufen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens mussten wir die Nachbarn der Zielzelle nur überprüfen, wenn zwischen ihnen eine Pause bestand, aber jetzt ist dies nicht notwendig. </font><font style="vertical-align: inherit;">Dies geschieht nur, wenn der Nachbar jetzt einen Schritt höher als die Zielzelle ist. </font><font style="vertical-align: inherit;">Wenn ja, ist der Nachbar garantiert auf der Liste, sodass wir dies nicht überprüfen müssen, dh wir können die unnötige Suche überspringen.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drittens können wir einen ähnlichen Trick anwenden, wenn wir die Nachbarn einer erosionsanfälligen Zelle überprüfen. </font><font style="vertical-align: inherit;">Befindet sich jetzt eine Klippe zwischen ihnen, ist der Nachbar anfällig für Erosion. </font><font style="vertical-align: inherit;">Um das herauszufinden, müssen wir nicht anrufen </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen jedoch noch prüfen, ob die Zielzelle anfällig für Erosion ist, aber der oben gezeigte Zyklus tut dies nicht mehr. </font><font style="vertical-align: inherit;">Daher führen wir dies explizit für die Zielzelle durch.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Erosion schnell genug und auf den gewünschten Prozentsatz im Verhältnis zur anfänglichen Anzahl der erzeugten Klippen anwenden. </font><font style="vertical-align: inherit;">Beachten Sie, dass sich das Ergebnis aufgrund der Tatsache, dass wir die Stelle, an der die Zielzelle zur erosionsgefährdeten Liste hinzugefügt wird, geringfügig geändert haben, gegenüber dem Ergebnis vor den Optimierungen geringfügig geändert hat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% und 100% Erosion. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie auch, dass sich die Topologie trotz der veränderten Form der Küste nicht grundlegend geändert hat. </font><font style="vertical-align: inherit;">Landmassen bleiben normalerweise entweder verbunden oder getrennt. </font><font style="vertical-align: inherit;">Nur kleine Inseln können vollständig ertrinken. </font><font style="vertical-align: inherit;">Die Reliefdetails werden geglättet, die allgemeinen Formen bleiben jedoch gleich. </font><font style="vertical-align: inherit;">Ein schmales Gelenk kann verschwinden oder ein wenig wachsen. </font><font style="vertical-align: inherit;">Eine kleine Lücke kann sich leicht füllen oder ausdehnen. </font><font style="vertical-align: inherit;">Daher wird die Erosion die geteilten Regionen nicht stark zusammenhalten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vier vollständig erodierte Regionen bleiben immer noch getrennt. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 25: Der Wasserkreislauf </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie rohe Kartendaten an. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bilden ein Klima von Zellen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie eine Teilsimulation des Wasserkreislaufs. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werden wir Feuchtigkeit an Land hinzufügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Tutorial wurde in Unity 2017.3.0 erstellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden den Wasserkreislauf, um Biomes zu bestimmen.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Wolken </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Punkt hat der Kartengenerierungsalgorithmus nur die Zellenhöhe geändert. </font><font style="vertical-align: inherit;">Der größte Unterschied zwischen den Zellen bestand darin, ob sie sich über oder unter Wasser befanden. </font><font style="vertical-align: inherit;">Obwohl wir verschiedene Geländetypen definieren können, ist dies nur eine einfache Visualisierung der Höhe. </font><font style="vertical-align: inherit;">Angesichts des lokalen Klimas ist es besser, die Arten der Erleichterung anzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Erdklima ist ein sehr komplexes System. </font><font style="vertical-align: inherit;">Glücklicherweise müssen wir keine realistischen Klimasimulationen erstellen. </font><font style="vertical-align: inherit;">Wir werden etwas brauchen, das natürlich genug aussieht. </font><font style="vertical-align: inherit;">Der wichtigste Aspekt des Klimas ist der Wasserkreislauf, denn Flora und Fauna benötigen flüssiges Wasser, um zu überleben. </font><font style="vertical-align: inherit;">Die Temperatur ist ebenfalls sehr wichtig, aber im Moment konzentrieren wir uns auf Wasser, wobei die globale Temperatur im Wesentlichen konstant bleibt und nur die Luftfeuchtigkeit geändert wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wasserkreislauf beschreibt die Bewegung von Wasser in der Umwelt. </font><font style="vertical-align: inherit;">Einfach ausgedrückt, die Teiche verdunsten, was zur Bildung von Regenwolken führt, die wieder in die Teiche fließen. </font><font style="vertical-align: inherit;">Das System hat viel mehr Aspekte, aber die Simulation dieser Schritte kann bereits ausreichen, um eine natürlich aussehende Wasserverteilung auf der Karte zu erzielen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenvisualisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir mit dieser Simulation beginnen, ist es hilfreich, die relevanten Daten direkt anzuzeigen. </font><font style="vertical-align: inherit;">Dazu ändern wir den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir fügen ihm eine umschaltbare Eigenschaft hinzu, die in den Datenvisualisierungsmodus umgeschaltet werden kann, in dem anstelle der üblichen Relieftexturen Rohkartendaten angezeigt werden. </font><font style="vertical-align: inherit;">Dies kann mithilfe einer float-Eigenschaft mit einem umschaltbaren Attribut implementiert werden, das das Schlüsselwort definiert. </font><font style="vertical-align: inherit;">Aus diesem Grund wird es im Materialinspektor als Flag angezeigt, das die Definition eines Schlüsselworts steuert. </font><font style="vertical-align: inherit;">Der Name der Immobilie selbst ist nicht wichtig, wir interessieren uns nur für das Schlüsselwort. </font><font style="vertical-align: inherit;">Wir verwenden </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wechseln Sie zur Anzeige der Kartendaten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine Shader-Funktion hinzu, um die Keyword-Unterstützung zu aktivieren.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden dafür sorgen, dass ein einzelner Float angezeigt wird, wie dies bei den übrigen Reliefdaten der Fall ist. </font><font style="vertical-align: inherit;">Um dies zu implementieren, fügen wir der Struktur ein </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld hinzu </font><font style="vertical-align: inherit;">, </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn das Schlüsselwort definiert ist.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Vertex-Programm verwenden wir den Z-Kanal dieser Zellen zum Ausfüllen </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie immer zwischen Zellen interpoliert.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Zelldaten anzeigen müssen, verwenden Sie diese direkt als Albedofragment anstelle der üblichen Farbe. </font><font style="vertical-align: inherit;">Multiplizieren Sie es mit dem Raster, damit das Raster beim Rendern der Daten weiterhin aktiviert ist.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Daten tatsächlich an einen Shader zu übertragen. </font><font style="vertical-align: inherit;">Wir müssen der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">hinzufügen, die </font><font style="vertical-align: inherit;">etwas in den blauen Texturdatenkanal schreibt. </font><font style="vertical-align: inherit;">Daten sind ein einzelner Gleitkommawert, der auf 0–1 begrenzt ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Entscheidung wirkt sich jedoch auf das Forschungssystem aus. </font><font style="vertical-align: inherit;">Ein blauer Kanaldatenwert 255 wird verwendet, um anzuzeigen, dass sich die Sichtbarkeit der Zelle im Übergang befindet. </font><font style="vertical-align: inherit;">Damit dieses System weiterhin funktioniert, müssen wir maximal den Bytewert 254 verwenden. Beachten Sie, dass durch die Bewegung der Abteilung alle Kartendaten gelöscht werden. Dies passt jedoch zu uns, da sie zum Debuggen der Kartengenerierung verwendet werden.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine Methode mit demselben Namen und in hinzu </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Anforderung wird an die Shader-Daten übertragen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Funktionsweise des Codes zu überprüfen, ändern wir ihn </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass die Daten jeder Zelle der Karte festgelegt werden. </font><font style="vertical-align: inherit;">Lassen Sie uns die Höhe visualisieren, die im Intervall 0–1 von Integer in Float konvertiert wurde. </font><font style="vertical-align: inherit;">Dies erfolgt durch Subtrahieren der minimalen Höhe von der Zellenhöhe, gefolgt vom Teilen durch die maximale Höhe minus die minimale. </font><font style="vertical-align: inherit;">Lassen Sie uns die Division Gleitkomma machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir zwischen normalen Erleichterung und Visualisierung von Daten mit Hilfe der Kontrollkästchen wechseln können </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte zeigen Daten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inventar Material </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte 1208905299, normales Gelände und Höhenvisualisierung.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klimaschöpfung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Klima zu simulieren, müssen wir Klimadaten verfolgen. </font><font style="vertical-align: inherit;">Da die Karte aus diskreten Zellen besteht, hat jede von ihnen ihr eigenes lokales Klima. </font><font style="vertical-align: inherit;">Erstellen Sie eine Struktur </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Speichern aller relevanten Daten. </font><font style="vertical-align: inherit;">Natürlich können Sie den Zellen selbst Daten hinzufügen, aber wir werden sie nur beim Generieren der Karte verwenden. </font><font style="vertical-align: inherit;">Daher werden wir sie separat speichern. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir diese Struktur intern definieren können </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie z </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir beginnen damit, nur Wolken zu verfolgen, die mit einem einzigen Float-Feld implementiert werden können.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie eine Liste hinzu, um Klimadaten für alle Zellen zu verfolgen. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt brauchen wir eine Methode, um eine Klimakarte zu erstellen. </font><font style="vertical-align: inherit;">Zunächst sollte die Liste der Klimazonen gelöscht und dann für jede Zelle ein Element hinzugefügt werden. </font><font style="vertical-align: inherit;">Die anfänglichen Klimadaten sind einfach Null, dies kann mit einem Standardkonstruktor erreicht werden </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Klima sollte nach der Exposition gegenüber Landerosion geschaffen werden, bevor die Arten von Reliefs festgelegt werden. </font><font style="vertical-align: inherit;">In Wirklichkeit wird Erosion hauptsächlich durch die Bewegung von Luft und Wasser verursacht, die Teil des Klimas sind, aber wir werden dies nicht simulieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie dies </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass Cloud-Daten anstelle der Zellenhöhe angezeigt werden. </font><font style="vertical-align: inherit;">Anfangs sieht es aus wie eine schwarze Karte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klima ändern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schritt in der Klimasimulation ist die Verdunstung. </font><font style="vertical-align: inherit;">Wie viel Wasser sollte verdunsten? </font><font style="vertical-align: inherit;">Lassen Sie uns diesen Wert mit dem Schieberegler steuern. </font><font style="vertical-align: inherit;">Ein Wert von 0 bedeutet keine Verdunstung, 1 - maximale Verdunstung. </font><font style="vertical-align: inherit;">Standardmäßig verwenden wir 0,5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdunstungsschieber. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns eine andere Methode speziell zur Gestaltung des Klimas einer Zelle entwickeln. </font><font style="vertical-align: inherit;">Wir geben ihm den Zellindex als Parameter und verwenden ihn, um die entsprechende Zelle und ihre Klimadaten zu erhalten. </font><font style="vertical-align: inherit;">Befindet sich die Zelle unter Wasser, handelt es sich um ein Reservoir, das verdunsten muss. </font><font style="vertical-align: inherit;">Wir verwandeln den Dampf sofort in Wolken (ohne Berücksichtigung der Taupunkte und der Kondensation), sodass wir den Wert der Zellwolken direkt verdampfen. </font><font style="vertical-align: inherit;">Wenn Sie damit fertig sind, kopieren Sie die Klimadaten zurück in die Liste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie diese Methode für jede Zelle in auf </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das reicht aber nicht. </font><font style="vertical-align: inherit;">Um eine komplexe Simulation zu erstellen, müssen wir das Klima der Zellen mehrmals formen. </font><font style="vertical-align: inherit;">Je öfter wir dies tun, desto besser wird das Ergebnis sein. </font><font style="vertical-align: inherit;">Wählen wir einfach einen konstanten Wert. </font><font style="vertical-align: inherit;">Ich benutze 40 Zyklen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da wir zwar nur den Wert der Wolken über den mit Wasser überfluteten Zellen erhöhen, erhalten wir dadurch schwarzes Land und weiße Stauseen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdunstung über Wasser.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wolkenstreuung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolken sind nicht ständig an einem Ort, besonders wenn immer mehr Wasser verdunstet. </font><font style="vertical-align: inherit;">Der Druckunterschied bewirkt, dass sich die Luft bewegt, was sich in Form von Wind manifestiert, wodurch sich auch die Wolken bewegen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es keine dominante Windrichtung gibt, verteilen sich die Zellwolken im Durchschnitt gleichmäßig in alle Richtungen und erscheinen in benachbarten Zellen. </font><font style="vertical-align: inherit;">Wenn Sie im nächsten Zyklus neue Wolken erzeugen, verteilen wir alle Wolken in der Zelle auf die Nachbarn. </font><font style="vertical-align: inherit;">Das heißt, jeder Nachbar erhält ein Sechstel aus den Zellwolken, wonach es zu einer lokalen Abnahme auf Null kommt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um Ihren Nachbarn tatsächlich Wolken hinzuzufügen, müssen Sie sie in einer Schleife umgehen, ihre Klimadaten abrufen, den Wert der Wolken erhöhen und sie zurück in die Liste kopieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolken streuen.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dadurch entsteht eine fast weiße Karte, da Unterwasserzellen mit jedem Zyklus mehr und mehr Wolken zum globalen Klima hinzufügen. Nach dem ersten Zyklus haben Landzellen neben Wasser auch Wolken, die verteilt werden müssen. Dieser Vorgang wird fortgesetzt, bis der größte Teil der Karte mit Wolken bedeckt ist. Bei der Karte 1208905299 mit den Standardparametern blieb nur der innere Teil der großen Landmasse im Nordosten vollständig unbedeckt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass Teiche unendlich viele Wolken erzeugen können. </font><font style="vertical-align: inherit;">Der Wasserstand ist nicht Teil der Klimasimulation. </font><font style="vertical-align: inherit;">In der Realität bleiben Stauseen nur erhalten, weil Wasser mit etwa der Verdunstungsrate in sie zurückfließt. </font><font style="vertical-align: inherit;">Das heißt, wir simulieren nur einen Teilwasserkreislauf. </font><font style="vertical-align: inherit;">Dies ist normal, aber wir müssen verstehen, je länger die Simulation stattfindet, desto mehr Wasser wird dem Klima hinzugefügt. </font><font style="vertical-align: inherit;">Bisher tritt Wasserverlust nur an den Rändern der Karte auf, wo verstreute Wolken aufgrund des Mangels an Nachbarn verloren gehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können den Wasserverlust oben auf der Karte sehen, insbesondere in den Zellen oben rechts. </font><font style="vertical-align: inherit;">In der letzten Zelle gibt es überhaupt keine Wolken, weil es die letzte bleibt, in der sich das Klima bildet. </font><font style="vertical-align: inherit;">Sie hat noch keine Wolken von einem Nachbarn erhalten.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollte sich nicht das Klima aller Zellen parallel bilden?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3>  Niederschlag </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser bleibt nicht für immer kalt. Irgendwann sollte sie wieder zu Boden fallen. Dies geschieht normalerweise in Form von Regen, aber manchmal kann es Schnee, Hagel oder nasser Schnee sein. All dies wird allgemein als Niederschlag bezeichnet. Das Ausmaß und die Rate des Verschwindens von Wolken variieren stark, aber wir verwenden nur eine benutzerdefinierte globale Niederschlagsrate. Ein Wert von 0 bedeutet kein Niederschlag, ein Wert von 1 bedeutet, dass alle Wolken sofort verschwinden. Der Standardwert ist 0,25. Dies bedeutet, dass in jedem Zyklus ein Viertel der Wolken verschwindet.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regler für den Niederschlagskoeffizienten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden Niederschläge nach der Verdunstung und vor der Wolkenstreuung simulieren. </font><font style="vertical-align: inherit;">Dies bedeutet, dass ein Teil des aus den Reservoirs verdampften Wassers sofort ausfällt, sodass die Anzahl der sich zerstreuenden Wolken abnimmt. </font><font style="vertical-align: inherit;">Über Land führt Niederschlag zum Verschwinden von Wolken.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschwindende Wolken. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jetzt in jedem Zyklus 25% der Wolken zerstören, ist das Land wieder fast schwarz. </font><font style="vertical-align: inherit;">Die Wolken bewegen sich nur wenige Schritte landeinwärts und werden dann unsichtbar. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2>  Luftfeuchtigkeit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl Regen Wolken zerstört, sollten sie dem Klima kein Wasser entziehen. </font><font style="vertical-align: inherit;">Nach dem Sturz auf den Boden wird Wasser nur in einem anderen Zustand gespeichert. </font><font style="vertical-align: inherit;">Es kann in vielen Formen existieren, die wir allgemein als Feuchtigkeit betrachten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Feuchtigkeitsverfolgung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden das Klimamodell verbessern, indem wir zwei Wasserbedingungen verfolgen: Wolken und Feuchtigkeit. </font><font style="vertical-align: inherit;">Fügen Sie dazu das </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld </font><font style="vertical-align: inherit;">hinzu, um dies zu implementieren </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In seiner allgemeinsten Form ist Verdunstung der Prozess der Umwandlung von Feuchtigkeit in Wolken, zumindest in unserem einfachen Klimamodell. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die Verdunstung kein konstanter Wert sein sollte, sondern ein weiterer Faktor. </font><font style="vertical-align: inherit;">Daher führen wir ein Refactoring-Umbenennen </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in durch </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich die Zelle unter Wasser befindet, geben wir einfach an, dass die Luftfeuchtigkeit 1 beträgt. Dies bedeutet, dass die Verdunstung gleich dem Verdunstungskoeffizienten ist. </font><font style="vertical-align: inherit;">Jetzt können wir aber auch aus Sushi-Zellen verdunsten. </font><font style="vertical-align: inherit;">In diesem Fall müssen wir die Verdunstung berechnen, von der Luftfeuchtigkeit abziehen und das Ergebnis zu den Wolken addieren. </font><font style="vertical-align: inherit;">Danach wird der Feuchtigkeit Niederschlag zugesetzt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Wolken jetzt durch Verdunstung von oben unterstützt werden, können wir sie weiter ins Landesinnere bewegen. </font><font style="vertical-align: inherit;">Jetzt ist der Großteil des Landes grau geworden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolken mit Verdunstung der Feuchtigkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern wir es </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es Feuchtigkeit anstelle von Wolken anzeigt, da wir es verwenden werden, um die Arten von Reliefs zu bestimmen.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feuchtigkeitsanzeige. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt sieht die Luftfeuchtigkeit den Wolken ziemlich ähnlich (außer dass alle Unterwasserzellen weiß sind), aber das wird sich bald ändern.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Niederschlag abfließen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdunstung ist nicht der einzige Weg, auf dem Feuchtigkeit die Zelle verlassen kann. </font><font style="vertical-align: inherit;">Der Wasserkreislauf sagt uns, dass der größte Teil der Feuchtigkeit, die dem Land hinzugefügt wird, irgendwie im Wasser landet. </font><font style="vertical-align: inherit;">Der auffälligste Prozess ist der Wasserfluss über Land unter dem Einfluss der Schwerkraft. </font><font style="vertical-align: inherit;">Wir werden keine echten Flüsse simulieren, sondern einen benutzerdefinierten Niederschlagsabflusskoeffizienten verwenden. </font><font style="vertical-align: inherit;">Es zeigt den Prozentsatz des Wassers an, das in die unteren Bereiche abfließt. </font><font style="vertical-align: inherit;">Standardmäßig beträgt die Aktie 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schieberegler entleeren.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden keine Flüsse erzeugen?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wasserabfluss wirkt wie eine Wolkenstreuung, jedoch mit drei Unterschieden. Erstens wird nicht die gesamte Feuchtigkeit aus der Zelle entfernt. Zweitens trägt es Feuchtigkeit, keine Wolken. Drittens geht es runter, das heißt nur zu Nachbarn mit geringerer Höhe. Der Abflusskoeffizient beschreibt die Menge an Feuchtigkeit, die aus der Zelle herausfließen würde, wenn alle Nachbarn niedriger wären, aber oft sind sie geringer. Dies bedeutet, dass wir die Zellfeuchtigkeit nur reduzieren, wenn wir unten einen Nachbarn finden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser läuft auf eine niedrigere Höhe ab. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen haben wir eine vielfältigere Verteilung der Luftfeuchtigkeit, da hohe Zellen ihre Feuchtigkeit auf die niedrigere übertragen. </font><font style="vertical-align: inherit;">Wir sehen auch viel weniger Feuchtigkeit in den Küstenzellen, weil sie die Feuchtigkeit in die Unterwasserzellen ableiten. </font><font style="vertical-align: inherit;">Um diesen Effekt abzuschwächen, müssen wir auch den Wasserstand verwenden, um festzustellen, ob die Zelle niedriger ist, dh die scheinbare Höhe nehmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die sichtbare Höhe.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versickerung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser fließt nicht nur nach unten, es breitet sich aus, sickert durch die ebene Topographie und wird vom Land neben den Gewässern absorbiert. </font><font style="vertical-align: inherit;">Dieser Effekt hat zwar nur geringe Auswirkungen, ist jedoch nützlich, um die Verteilung der Luftfeuchtigkeit zu glätten. Fügen Sie ihn daher der Simulation hinzu. </font><font style="vertical-align: inherit;">Erstellen wir einen eigenen benutzerdefinierten Koeffizienten, der standardmäßig 0,125 beträgt.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leckage-Schieberegler. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Versickern ähnelt einem Abfluss, außer dass es verwendet wird, wenn der Nachbar die gleiche sichtbare Höhe wie die Zelle selbst hat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein wenig Leckage hinzugefügt. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regenschatten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir bereits eine würdige Simulation des Wasserkreislaufs erstellt haben, sieht es nicht sehr interessant aus, da es keine Regenschatten gibt, die die klimatischen Unterschiede am deutlichsten zeigen. </font><font style="vertical-align: inherit;">Regenschatten sind Gebiete, in denen im Vergleich zu benachbarten Gebieten ein erheblicher Niederschlagsmangel besteht. </font><font style="vertical-align: inherit;">Solche Gebiete existieren, weil Berge verhindern, dass die Wolken sie erreichen. </font><font style="vertical-align: inherit;">Ihre Schaffung erfordert hohe Berge und eine dominante Windrichtung.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Wind </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem Hinzufügen einer dominanten Windrichtung zur Simulation. </font><font style="vertical-align: inherit;">Obwohl die dominanten Windrichtungen auf der Erdoberfläche stark variieren, werden wir mit einer anpassbaren globalen Windrichtung auskommen. </font><font style="vertical-align: inherit;">Verwenden wir standardmäßig Nordwesten. </font><font style="vertical-align: inherit;">Lassen Sie uns außerdem die Windkraft von 1 bis 10 mit einem Standardwert von 4 einstellbar machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Richtung und Stärke des Windes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Stärke des dominanten Windes wird relativ zur Gesamtstreuung der Wolken ausgedrückt. </font><font style="vertical-align: inherit;">Wenn die Windkraft 1 ist, ist die Streuung in alle Richtungen gleich. </font><font style="vertical-align: inherit;">Wenn es 2 ist, ist die Streuung in Windrichtung um zwei höher als in andere Richtungen und so weiter. </font><font style="vertical-align: inherit;">Wir können dies tun, indem wir den Divisor in der Wolkenstreuungsformel ändern. </font><font style="vertical-align: inherit;">Anstelle von sechs entspricht dies fünf plus Windkraft.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzlich bestimmt die Windrichtung die Richtung, aus der der Wind weht. </font><font style="vertical-align: inherit;">Daher müssen wir die entgegengesetzte Richtung als Hauptstreurichtung verwenden.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir überprüfen, ob sich der Nachbar in der Hauptstreurichtung befindet. </font><font style="vertical-align: inherit;">Wenn ja, dann müssen wir die Streuung der Wolken mit der Kraft des Windes multiplizieren.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nordwestwind, Kraft 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der dominierende Wind erhöht die Richtungsverteilung der Feuchtigkeit über Land. </font><font style="vertical-align: inherit;">Je stärker der Wind, desto stärker wird der Effekt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Absolute Höhe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Zutat, um Regenschatten zu bekommen, sind die Berge. Wir haben keine strenge Klassifizierung dessen, was ein Berg ist, so wie es die Natur auch nicht hat. Nur die absolute Höhe ist wichtig. Wenn sich die Luft über den Berg bewegt, muss sie aufsteigen, wird gekühlt und enthält möglicherweise weniger Wasser, was zu Niederschlägen führt, bevor Luft über den Berg strömt. Infolgedessen erhalten wir auf der anderen Seite trockene Luft, dh einen Regenschatten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je höher die Luft steigt, desto weniger Wasser kann sie enthalten. </font><font style="vertical-align: inherit;">In unserer Simulation können wir uns dies als eine erzwungene Einschränkung des maximalen Wolkenwerts für jede Zelle vorstellen. </font><font style="vertical-align: inherit;">Je höher die sichtbare Zellenhöhe ist, desto niedriger sollte dieses Maximum sein. </font><font style="vertical-align: inherit;">Der einfachste Weg, dies zu tun, besteht darin, das Maximum auf 1 abzüglich der scheinbaren Höhe, geteilt durch die maximale Höhe, zu setzen. </font><font style="vertical-align: inherit;">Tatsächlich teilen wir jedoch durch ein Maximum von minus 1. Dadurch kann ein kleiner Teil der Wolken auch durch die höchsten Zellen gelangen. </font><font style="vertical-align: inherit;">Wir weisen dieses Maximum nach der Berechnung des Niederschlags und vor der Streuung zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir dadurch mehr Wolken als akzeptabel bekommen, wandeln wir die überschüssigen Wolken einfach in Feuchtigkeit um. </font><font style="vertical-align: inherit;">Auf diese Weise fügen wir zusätzlichen Niederschlag hinzu, wie es in echten Bergen der Fall ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regenschatten durch Höhenlage. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir vervollständigen die Simulation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir bereits eine sehr hochwertige Teilsimulation des Wasserkreislaufs. </font><font style="vertical-align: inherit;">Lassen Sie es uns ein wenig ordnen und dann anwenden, um die Art des Reliefs der Zellen zu bestimmen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paralleles Rechnen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits unter dem Spoiler erwähnt, beeinflusst die Reihenfolge, in der Zellen gebildet werden, das Simulationsergebnis. </font><font style="vertical-align: inherit;">Idealerweise sollte dies nicht so sein und im Wesentlichen bilden wir alle Zellen parallel. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem alle Änderungen des aktuellen Bildungsstadiums auf die zweite Liste des Klimas angewendet werden </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Löschen und initialisieren Sie diese Liste wie alle anderen auch. </font><font style="vertical-align: inherit;">Dann werden wir Listen zu jedem Zyklus austauschen. </font><font style="vertical-align: inherit;">In diesem Fall verwendet die Simulation abwechselnd die beiden Listen und wendet die aktuellen und nächsten Klimadaten an.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn eine Zelle das Klima ihres Nachbarn beeinflusst, müssen wir die folgenden Klimadaten ändern, nicht die aktuellen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; … nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und anstatt die folgenden Klimadaten zurück in die aktuelle Klimaliste zu kopieren, erhalten wir die folgenden Klimadaten, fügen die aktuelle Luftfeuchtigkeit hinzu und kopieren sie alle in die nächste Liste. </font><font style="vertical-align: inherit;">Danach setzen wir die Daten in der aktuellen Liste zurück, damit sie für den nächsten Zyklus aktualisiert werden.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen wir dabei auch die Luftfeuchtigkeit auf maximal 1 ein, damit Landzellen nicht feuchter als unter Wasser sind. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralleles Rechnen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellfeuchtigkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es besteht die Möglichkeit, dass die Simulation zu viel trockenes Land erzeugt, insbesondere bei einem hohen Prozentsatz an Land. </font><font style="vertical-align: inherit;">Um das Bild zu verbessern, können wir eine benutzerdefinierte Anfangsfeuchtigkeit mit einem Standardwert von 0,1 hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oben ist der Schieberegler der ursprünglichen Luftfeuchtigkeit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diesen Wert für die Luftfeuchtigkeit der anfänglichen Klimaliste, jedoch nicht für Folgendes.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit ursprünglicher Luftfeuchtigkeit.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomes definieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schließen mit der Verwendung von Feuchtigkeit anstelle von Höhe, um die Art der Zellentlastung festzulegen. </font><font style="vertical-align: inherit;">Verwenden wir Schnee für vollständig trockenes Land, für trockene Regionen verwenden wir Schnee, dann gibt es Stein, Gras für ausreichend Feuchtigkeit und Land für wassergesättigte und Unterwasserzellen. </font><font style="vertical-align: inherit;">Am einfachsten ist es, fünf Intervalle in Schritten von 0,2 zu verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei gleichmäßiger Verteilung ist das Ergebnis nicht sehr gut und sieht unnatürlich aus. </font><font style="vertical-align: inherit;">Es ist besser, andere Schwellenwerte zu verwenden, z. B. 0,05, 0,12, 0,28 und 0,85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifizierte Biome. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 26: Biomes und Flüsse </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir schaffen die Flüsse, die aus hohen Zellen mit Feuchtigkeit stammen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir erstellen ein einfaches Temperaturmodell. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir verwenden die Biomatrix für die Zellen und ändern sie dann. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werden wir den Wasserkreislauf mit Flüssen und Temperaturen ergänzen und den Zellen interessantere Biome zuweisen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Tutorial wurde mit Unity 2017.3.0p3 erstellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hitze und Wasser beleben die Karte.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flusserzeugung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flüsse sind eine Folge des Wasserkreislaufs. </font><font style="vertical-align: inherit;">Tatsächlich werden sie durch Abflüsse gebildet, die mit Hilfe der Kanalerosion herausgerissen werden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie Flüsse basierend auf dem Wert der Zellabläufe hinzufügen können. </font><font style="vertical-align: inherit;">Dies garantiert jedoch nicht, dass wir etwas bekommen, das echten Flüssen ähnelt. </font><font style="vertical-align: inherit;">Wenn wir den Fluss starten, muss er so weit wie möglich fließen, möglicherweise durch viele Zellen. </font><font style="vertical-align: inherit;">Dies steht nicht im Einklang mit unserer Simulation des Wasserkreislaufs, bei dem Zellen parallel verarbeitet werden. </font><font style="vertical-align: inherit;">Darüber hinaus ist normalerweise die Kontrolle der Anzahl der Flüsse auf einer Karte erforderlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Flüsse sehr unterschiedlich sind, werden wir sie separat erzeugen. </font><font style="vertical-align: inherit;">Wir verwenden die Ergebnisse der Wasserkreislaufsimulation, um den Standort der Flüsse zu bestimmen, aber die Flüsse haben wiederum keinen Einfluss auf die Simulation.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist der Fluss manchmal falsch?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         («»). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } … }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen mit hoher Luftfeuchtigkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf unseren Karten kann eine Zelle einen Fluss haben oder nicht. Darüber hinaus können sie verzweigen oder verbinden. In Wirklichkeit sind Flüsse viel flexibler, aber wir müssen mit dieser Annäherung auskommen, die nur große Flüsse erzeugt. Am wichtigsten ist, dass wir den Ort des Beginns eines großen Flusses bestimmen, der zufällig ausgewählt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Flüsse Wasser benötigen, muss sich die Quelle des Flusses in einer Zelle mit hoher Luftfeuchtigkeit befinden. Das reicht aber nicht. Flüsse fließen die Hänge hinunter, daher sollte die Quelle idealerweise eine große Höhe haben. Je höher die Zelle über dem Wasserspiegel ist, desto besser ist sie für die Rolle der Flussquelle geeignet. Wir können dies als Kartendaten visualisieren, indem wir die Zellenhöhe durch die maximale Höhe teilen. Damit das Ergebnis relativ zum Wasserstand erhalten wird, werden wir es vor dem Teilen von beiden Höhen abziehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luftfeuchtigkeit und Höhe. Große Kartennummer 1208905299 mit Standardeinstellungen.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die besten Kandidaten sind Zellen mit hoher Luftfeuchtigkeit und hoher Höhe. Wir können diese Kriterien kombinieren, indem wir sie multiplizieren. Das Ergebnis ist der Wert der Fitness oder des Gewichts für die Quellen der Flüsse.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewichte für die Quellen von Flüssen.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idealerweise würden wir diese Gewichte verwenden, um die zufällige Auswahl der Quellzelle abzulehnen. Obwohl wir eine Liste mit den richtigen Gewichten erstellen und daraus auswählen können, ist dies ein nicht trivialer Ansatz, der den Generierungsprozess verlangsamt. Eine einfachere Klassifizierung der Signifikanz in vier Ebenen wird uns ausreichen. Die ersten Kandidaten sind Gewichte mit Werten über 0,75. Gute Kandidaten haben Gewichte von 0,5. Geeignete Kandidaten sind größer als 0,25. Alle anderen Zellen werden verworfen. Lassen Sie uns zeigen, wie es grafisch aussieht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewichtskategorien von Flussquellen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem Klassifizierungsschema erhalten wir wahrscheinlich Flüsse mit Quellen in den höchsten und feuchtesten Bereichen der Karte. </font><font style="vertical-align: inherit;">Dennoch bleibt die Wahrscheinlichkeit bestehen, Flüsse in relativ trockenen oder niedrigen Gebieten zu erzeugen, was die Variabilität erhöht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine Methode hinzu </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die eine Liste von Zellen basierend auf diesen Kriterien füllt. </font><font style="vertical-align: inherit;">Geeignete Zellen werden dieser Liste einmal, gute zweimal und die Hauptkandidaten viermal hinzugefügt. </font><font style="vertical-align: inherit;">Unterwasserzellen werden immer verworfen, daher können Sie sie nicht überprüfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Methode muss nachher aufgerufen werden, </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">damit uns Feuchtigkeitsdaten zur Verfügung stehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem Sie die Klassifizierung abgeschlossen haben, können Sie die Visualisierung der Daten auf der Karte entfernen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flusspunkte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie viele Flüsse brauchen wir? </font><font style="vertical-align: inherit;">Dieser Parameter muss anpassbar sein. </font><font style="vertical-align: inherit;">Da die Länge der Flüsse variiert, ist es logischer, sie mit Hilfe von Flusspunkten zu steuern, die die Anzahl der Landzellen bestimmen, in denen die Flüsse enthalten sein sollen. </font><font style="vertical-align: inherit;">Lassen Sie uns sie als Prozentsatz mit maximal 20% und einem Standardwert von 10% ausdrücken. </font><font style="vertical-align: inherit;">Wie der Prozentsatz an Sushi ist dies ein Zielwert, kein garantierter. </font><font style="vertical-align: inherit;">Infolgedessen haben wir möglicherweise zu wenige Kandidaten oder Flüsse, die zu kurz sind, um die erforderliche Landmenge abzudecken. </font><font style="vertical-align: inherit;">Deshalb sollte der maximale Prozentsatz nicht zu groß sein.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider Prozent Flüsse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Flusspunkte zu bestimmen, ausgedrückt als Anzahl der Zellen, müssen wir uns daran erinnern, in wie vielen Landzellen erzeugt wurden </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Inneren kann die </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzahl der Flusspunkte jetzt auf die gleiche Weise berechnet werden wie in </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem werden wir weiterhin zufällige Zellen aus der ursprünglichen Liste nehmen und entfernen, solange wir noch Punkte und Quellzellen haben. </font><font style="vertical-align: inherit;">Wenn die Anzahl der Punkte erreicht ist, wird in der Konsole eine Warnung angezeigt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzlich fügen wir eine Methode zum direkten Erstellen von Flüssen hinzu. </font><font style="vertical-align: inherit;">Als Parameter benötigt er eine Anfangszelle und muss nach Fertigstellung die Länge des Flusses zurückgeben. </font><font style="vertical-align: inherit;">Wir beginnen mit dem Speichern einer Methode, die die Länge Null zurückgibt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Methode am Ende des Zyklus, den wir gerade hinzugefügt haben </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">, um die Anzahl der verbleibenden Punkte zu reduzieren. </font><font style="vertical-align: inherit;">Wir stellen sicher, dass ein neuer Fluss nur dann erstellt wird, wenn in der ausgewählten Zelle kein Fluss fließt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aktuelle Flüsse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist logisch, Flüsse zu schaffen, die zum Meer oder zu anderen Gewässern fließen. </font><font style="vertical-align: inherit;">Wenn wir von der Quelle ausgehen, erhalten wir sofort die Länge 1. Danach wählen wir einen zufälligen Nachbarn aus und erhöhen die Länge. </font><font style="vertical-align: inherit;">Wir bewegen uns weiter, bis wir die Unterwasserzelle erreichen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zufällige Flüsse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis eines solchen naiven Ansatzes erhalten wir zufällig verstreute Flussfragmente, hauptsächlich aufgrund des Ersatzes zuvor erzeugter Flüsse. </font><font style="vertical-align: inherit;">Dies kann sogar zu Fehlern führen, da wir nicht prüfen, ob der Nachbar tatsächlich existiert. </font><font style="vertical-align: inherit;">Wir müssen alle Richtungen in der Schleife überprüfen und sicherstellen, dass dort ein Nachbar ist. </font><font style="vertical-align: inherit;">Wenn dies der Fall ist, fügen wir diese Richtung der Liste der möglichen Strömungsrichtungen hinzu, jedoch nur, wenn der Fluss noch nicht durch diesen Nachbarn fließt. </font><font style="vertical-align: inherit;">Wählen Sie dann einen zufälligen Wert aus dieser Liste.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem neuen Ansatz stehen möglicherweise keine Strömungsrichtungen zur Verfügung. </font><font style="vertical-align: inherit;">In diesem Fall kann der Fluss nicht mehr weiter fließen und muss enden. </font><font style="vertical-align: inherit;">Wenn in diesem Moment die Länge 1 ist, bedeutet dies, dass wir nicht aus der ursprünglichen Zelle austreten konnten, das heißt, es kann überhaupt keinen Fluss geben. </font><font style="vertical-align: inherit;">In diesem Fall ist die Länge des Flusses Null.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erhaltene Flüsse.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lauf runter </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt retten wir die bereits geschaffenen Flüsse, aber wir können immer noch isolierte Fragmente der Flüsse erhalten. </font><font style="vertical-align: inherit;">Dies geschieht, weil wir die Höhen ignoriert haben. </font><font style="vertical-align: inherit;">Jedes Mal, wenn wir den Fluss zwangen, in eine größere Höhe zu fließen, wurde </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser Versuch unterbrochen, was zu Brüchen in den Flüssen führte. </font><font style="vertical-align: inherit;">Daher müssen wir auch Richtungen überspringen, die dazu führen, dass Flüsse hochfließen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flüsse fließen herab. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So werden wir viele Fragmente von Flüssen los, aber einige bleiben noch übrig. </font><font style="vertical-align: inherit;">Von diesem Moment an ist es eine Frage der Verfeinerung, die hässlichsten Flüsse loszuwerden. </font><font style="vertical-align: inherit;">Flüsse fließen zunächst lieber so schnell wie möglich ab. </font><font style="vertical-align: inherit;">Sie werden nicht unbedingt die kürzest mögliche Route wählen, aber die Wahrscheinlichkeit dafür ist groß. </font><font style="vertical-align: inherit;">Um dies zu simulieren, fügen wir der Liste dreimal Anweisungen hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie scharfe Kurven </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser fließt nicht nur nach unten, sondern hat auch Trägheit. </font><font style="vertical-align: inherit;">Ein Fluss fließt eher gerade oder biegt sich leicht als eine plötzliche scharfe Kurve. </font><font style="vertical-align: inherit;">Wir können diese Verzerrung hinzufügen, indem wir die letzte Richtung des Flusses verfolgen. </font><font style="vertical-align: inherit;">Wenn die potenzielle Richtung des Stroms nicht zu stark von dieser Richtung abweicht, fügen Sie sie erneut zur Liste hinzu. </font><font style="vertical-align: inherit;">Dies ist kein Problem für die Quelle, daher fügen wir es einfach immer wieder hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies verringert die Wahrscheinlichkeit von Flüssen im Zickzack, die hässlich aussehen, erheblich. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weniger scharfe Kurven.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenfluss des Flusses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal stellt sich heraus, dass der Fluss direkt neben der Quelle des zuvor geschaffenen Flusses fließt. </font><font style="vertical-align: inherit;">Wenn sich die Quelle dieses Flusses nicht in einer höheren Höhe befindet, können wir entscheiden, dass der neue Fluss in den alten fließt. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir einen langen Fluss und nicht zwei benachbarte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu lassen wir den Nachbarn nur passieren, wenn sich ein Fluss darin befindet oder wenn er die Quelle des aktuellen Flusses ist. </font><font style="vertical-align: inherit;">Nachdem wir festgestellt haben, dass diese Richtung nicht stimmt, prüfen wir, ob ein abfließender Fluss vorhanden ist. </font><font style="vertical-align: inherit;">Wenn ja, dann haben wir wieder den alten Fluss gefunden. </font><font style="vertical-align: inherit;">Da dies ziemlich selten vorkommt, werden wir uns nicht mit der Überprüfung anderer benachbarter Quellen befassen und die Flüsse sofort kombinieren.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flüsse vor und nach dem Pooling.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abstand halten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da gute Kandidaten für die Quellrolle normalerweise in Gruppen zusammengefasst sind, erhalten wir Flusscluster. </font><font style="vertical-align: inherit;">Außerdem haben wir möglicherweise Flüsse, die die Quelle direkt neben dem Stausee nehmen, was zu Flüssen der Länge 1 führt. Wir können die Quellen verteilen und diejenigen verwerfen, die sich in der Nähe des Flusses oder Stausees befinden. </font><font style="vertical-align: inherit;">Wir tun dies, indem wir die Nachbarn der ausgewählten Quelle in einer Schleife im Inneren umgehen </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir einen Nachbarn finden, der gegen die Regeln verstößt, passt die Quelle nicht zu uns und wir müssen sie überspringen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und obwohl die Flüsse immer noch nebeneinander fließen, bedecken sie tendenziell ein größeres Gebiet. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne Distanz und damit.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir beenden den Fluss mit einem See </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle Flüsse erreichen den Stausee, einige bleiben in den Tälern stecken oder werden von anderen Flüssen blockiert. Dies ist kein besonderes Problem, da oft auch echte Flüsse zu verschwinden scheinen. Dies kann beispielsweise passieren, wenn sie unter der Erde fließen, sich in einem sumpfigen Gebiet verteilen oder austrocknen. Unsere Flüsse können sich das nicht vorstellen, also enden sie einfach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können jedoch versuchen, die Anzahl solcher Fälle zu minimieren. Obwohl wir die Flüsse nicht vereinen oder zum Fließen bringen können, können wir sie in Seen enden lassen, die in der Realität oft vorkommen und gut aussehen. Dafür</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte den Wasserstand in der Zelle erhöhen, wenn sie stecken bleibt. </font><font style="vertical-align: inherit;">Die Möglichkeit hierfür hängt von der Mindesthöhe der Nachbarn dieser Zelle ab. </font><font style="vertical-align: inherit;">Um dies beim Studieren von Nachbarn zu verfolgen, ist daher eine kleine Änderung des Codes erforderlich.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } … } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir nicht weiterkommen, müssen wir zunächst prüfen, ob wir noch an der Quelle sind. </font><font style="vertical-align: inherit;">Wenn ja, dann stornieren Sie einfach den Fluss. </font><font style="vertical-align: inherit;">Andernfalls prüfen wir, ob alle Nachbarn mindestens so hoch sind wie die aktuelle Zelle. </font><font style="vertical-align: inherit;">Wenn ja, können wir das Wasser auf dieses Niveau bringen. </font><font style="vertical-align: inherit;">Dadurch entsteht aus einer Zelle ein See, es sei denn, die Zellenhöhe bleibt auf dem gleichen Niveau. </font><font style="vertical-align: inherit;">Wenn ja, weisen Sie die Höhe einfach eine Ebene unter dem Wasserspiegel zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Enden von Flüssen ohne Seen und mit Seen. </font><font style="vertical-align: inherit;">In diesem Fall beträgt der Prozentsatz der Flüsse 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beachten Sie, dass wir jetzt möglicherweise Unterwasserzellen über dem Wasserspiegel haben, der zur Erstellung der Karte verwendet wurde. </font><font style="vertical-align: inherit;">Sie werden Seen über dem Meeresspiegel bezeichnen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusätzliche Seen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können auch Seen schaffen, auch wenn wir nicht festsitzen. </font><font style="vertical-align: inherit;">Dies kann dazu führen, dass ein Fluss in den See hinein und aus ihm heraus fließt. </font><font style="vertical-align: inherit;">Wenn wir nicht stecken bleiben, kann ein See geschaffen werden, indem der Wasserstand und dann die aktuelle Zellenhöhe erhöht und dann die Zellenhöhe verringert werden. </font><font style="vertical-align: inherit;">Dies gilt nur, wenn die Mindesthöhe des Nachbarn mindestens der Höhe der aktuellen Zelle entspricht. </font><font style="vertical-align: inherit;">Wir tun dies am Ende des Flusszyklus und bevor wir zur nächsten Zelle übergehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne zusätzliche Seen und mit ihnen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Seen sind wunderschön, aber ohne Grenzen können wir zu viele Seen schaffen. </font><font style="vertical-align: inherit;">Fügen wir daher eine benutzerdefinierte Wahrscheinlichkeit für zusätzliche Seen mit einem Standardwert von 0,25 hinzu.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn möglich, wird sie die Wahrscheinlichkeit der Erzeugung eines zusätzlichen Sees kontrollieren. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzliche Seen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit der Schaffung von Seen mit mehr als einer Zelle?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperatur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasser ist nur einer der Faktoren, die das Biom einer Zelle bestimmen können. </font><font style="vertical-align: inherit;">Ein weiterer wichtiger Faktor ist die Temperatur. </font><font style="vertical-align: inherit;">Obwohl wir den Fluss und die Diffusion von Temperaturen wie die Simulation von Wasser simulieren können, brauchen wir nur einen komplexen Faktor, um ein interessantes Klima zu schaffen. </font><font style="vertical-align: inherit;">Lassen Sie uns daher die Temperatur einfach halten und für jede Zelle einstellen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperatur und Breitengrad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der größte Einfluss auf die Temperatur ist der Breitengrad. </font><font style="vertical-align: inherit;">Es ist heiß am Äquator, kalt an den Polen und es gibt einen reibungslosen Übergang zwischen ihnen. </font><font style="vertical-align: inherit;">Erstellen wir eine Methode </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Temperatur einer bestimmten Zelle zurückgibt. </font><font style="vertical-align: inherit;">Zu Beginn verwenden wir einfach die Z-Koordinate der Zelle geteilt durch die Dimension Z als Breitengrad und verwenden diesen Wert dann als Temperatur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir definieren die Temperatur in </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden sie als Kartendaten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breitengrad als Temperatur, südliche Hemisphäre. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten einen linearen Temperaturgradienten, der von unten nach oben zunimmt. </font><font style="vertical-align: inherit;">Sie können damit die südliche Hemisphäre simulieren, mit einer Stange unten und einem Äquator oben. </font><font style="vertical-align: inherit;">Wir müssen aber nicht die gesamte Hemisphäre beschreiben. </font><font style="vertical-align: inherit;">Mit einem kleineren Temperaturunterschied oder überhaupt keinem Unterschied können wir einen kleineren Bereich beschreiben. </font><font style="vertical-align: inherit;">Dazu werden wir niedrige und hohe Temperaturen anpassbar machen. </font><font style="vertical-align: inherit;">Wir werden diese Temperaturen im Bereich von 0 bis 1 einstellen und die Extremwerte als Standardwerte verwenden.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperaturregler. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wenden den Temperaturbereich durch lineare Interpolation an, wobei der Breitengrad als Interpolator verwendet wird. </font><font style="vertical-align: inherit;">Da wir den Breitengrad als Wert von 0 bis 1 ausdrücken, können wir ihn verwenden </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass niedrige Temperaturen nicht unbedingt niedriger als hoch sind. </font><font style="vertical-align: inherit;">Falls gewünscht, können Sie sie umdrehen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hemisphäre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die südliche und möglicherweise die nördliche Hemisphäre simulieren, wenn wir zuerst die Temperaturen messen. </font><font style="vertical-align: inherit;">Es ist jedoch viel bequemer, eine separate Konfigurationsoption zu verwenden, um zwischen den Hemisphären zu wechseln. </font><font style="vertical-align: inherit;">Lassen Sie uns eine Aufzählung und ein Feld dafür erstellen. </font><font style="vertical-align: inherit;">Daher werden wir auch die Option hinzufügen, beide Hemisphären zu erstellen, die standardmäßig anwendbar ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahl der Hemisphäre. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir die nördliche Hemisphäre brauchen, können wir den Breitengrad einfach umdrehen und von 1 subtrahieren. Um beide Hemisphären zu simulieren, sollten sich die Pole unter und über der Karte befinden und der Äquator sollte in der Mitte liegen. </font><font style="vertical-align: inherit;">Sie können dies tun, indem Sie den Breitengrad verdoppeln, während die untere Hemisphäre korrekt verarbeitet wird und die obere einen Breitengrad von 1 bis 2 hat. Um dies zu beheben, subtrahieren wir den Breitengrad von 2, wenn er 1 überschreitet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Hemisphären. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist erwähnenswert, dass dies die Möglichkeit schafft, eine exotische Karte zu erstellen, in der der Äquator kalt und die Pole warm sind.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je höher desto kälter </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben dem Breitengrad wird die Temperatur auch maßgeblich von der Höhe beeinflusst. </font><font style="vertical-align: inherit;">Je höher wir steigen, desto kälter wird es im Durchschnitt. </font><font style="vertical-align: inherit;">Wir können dies zu einem Faktor machen, wie wir es bei den Flusskandidaten getan haben. </font><font style="vertical-align: inherit;">In diesem Fall verwenden wir die Zellenhöhe. </font><font style="vertical-align: inherit;">Außerdem nimmt dieser Indikator mit der Höhe ab, dh gleich 1 minus der Höhe geteilt durch das Maximum relativ zum Wasserstand. </font><font style="vertical-align: inherit;">Damit der Indikator auf der höchsten Ebene nicht auf Null fällt, addieren wir zum Divisor. </font><font style="vertical-align: inherit;">Verwenden Sie dann diesen Indikator, um die Temperatur zu skalieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Höhe beeinflusst die Temperatur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperaturschwankungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die Einfachheit des Temperaturgradienten weniger bemerkbar machen, indem wir zufällige Temperaturschwankungen hinzufügen. </font><font style="vertical-align: inherit;">Eine kleine Chance, es realistischer zu machen, aber mit zu viel Schwankung werden sie willkürlich aussehen. </font><font style="vertical-align: inherit;">Lassen Sie uns die Stärke von Temperaturschwankungen anpassbar machen und sie als maximale Temperaturabweichung mit einem Standardwert von 0,1 ausdrücken.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schieberegler für Temperaturschwankungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solche Schwankungen sollten mit geringfügigen lokalen Änderungen gleichmäßig sein. </font><font style="vertical-align: inherit;">Hierfür können Sie unsere Rauschstruktur verwenden. </font><font style="vertical-align: inherit;">Wir werden </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Position der Zelle, skaliert mit 0,1, </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">und als Argument verwenden. </font><font style="vertical-align: inherit;">Nehmen wir den Kanal W, zentrieren ihn und skalieren ihn mit dem Schwingungskoeffizienten. </font><font style="vertical-align: inherit;">Dann addieren wir diesen Wert zur zuvor berechneten Temperatur.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperaturschwankungen mit Werten von 0,1 und 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir können den Schwankungen auf jeder Karte eine leichte Variabilität hinzufügen, indem wir zufällig aus den vier Rauschkanälen auswählen. </font><font style="vertical-align: inherit;">Stellen Sie den Kanal einmal ein </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und indizieren Sie dann die Farbkanäle </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiedliche Temperaturschwankungen bei maximaler Kraft. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir Daten zu Luftfeuchtigkeit und Temperatur haben, können wir eine Biomatrix erstellen. </font><font style="vertical-align: inherit;">Durch Indizieren dieser Matrix können wir allen Zellen Biomes zuweisen, wodurch eine komplexere Landschaft entsteht als bei Verwendung nur einer Datendimension.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biom-Matrix </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele Klimamodelle, aber wir werden keines davon verwenden. Wir werden es sehr einfach machen, wir interessieren uns nur für Logik. Trocken bedeutet Wüste (kalt oder heiß), dafür verwenden wir Sand. Kalt und nass bedeutet Schnee. Heiß und feucht bedeutet viel Vegetation, also Gras. Zwischen ihnen wird eine Taiga oder Tundra sein, die wir als graue Textur der Erde bezeichnen werden. Eine 4 × 4-Matrix reicht aus, um Übergänge zwischen diesen Biomen zu erzeugen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor haben wir Höhentypen basierend auf fünf Feuchtigkeitsintervallen zugewiesen. Wir senken einfach den trockensten Streifen auf 0,05 und speichern den Rest. Für Temperaturbänder verwenden wir 0,1, 0,3, 0,6 und höher. Der Einfachheit halber werden diese Werte in statischen Arrays festgelegt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir nur den Relieftyp anhand des Bioms angeben, können wir damit andere Parameter bestimmen. </font><font style="vertical-align: inherit;">Definieren wir daher eine </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Konfiguration eines einzelnen Bioms beschreibt. </font><font style="vertical-align: inherit;">Bisher enthält es nur den Bump-Index sowie die entsprechende Konstruktormethode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese Struktur, um ein statisches Array mit Matrixdaten zu erstellen. </font><font style="vertical-align: inherit;">Wir verwenden Feuchtigkeit als X-Koordinate und Temperatur als Y. Wir füllen die Linie mit der niedrigsten Temperatur mit Schnee, die zweite Linie mit Tundra und die anderen beiden mit Gras. </font><font style="vertical-align: inherit;">Dann ersetzen wir die trockenste Säule durch die Wüste und definieren die Temperaturwahl neu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrix von Biomen mit Indizes eines eindimensionalen Arrays.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomdefinition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen </font><font style="vertical-align: inherit;">im </font><font style="vertical-align: inherit;">Biom </font><font style="vertical-align: inherit;">zu bestimmen </font><font style="vertical-align: inherit;">, werden wir die Temperatur- und Feuchtigkeitsbereiche im Zyklus durchlaufen, um die benötigten Matrixindizes zu bestimmen. </font><font style="vertical-align: inherit;">Wir verwenden sie, um das gewünschte Biom zu erhalten und die Art der Zelltopographie zu spezifizieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // … // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief basierend auf einer Biomatrix.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biom-Setup </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können über die in der Matrix definierten Biome hinausgehen. Beispielsweise werden in der Matrix alle trockenen Biome als Sandwüsten definiert, aber nicht alle trockenen Wüsten sind mit Sand gefüllt. Es gibt viele felsige Wüsten, die sehr unterschiedlich aussehen. Ersetzen wir deshalb einige der Wüstenzellen durch Steine. Wir werden dies einfach auf der Grundlage der Höhe tun: Sand befindet sich in geringer Höhe, und nackte Felsen befinden sich normalerweise oben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Sand verwandelt sich in Stein, wenn die Höhe der Zelle näher an der maximalen Höhe als am Wasserspiegel liegt. Dies ist die Höhenlinie der felsigen Wüsten, die wir zu Beginn berechnen können </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn wir einer Zelle mit Sand begegnen und ihre Höhe groß genug ist, verwandeln wir das Relief des Bioms in Stein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sandige und felsige Wüsten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Änderung basierend auf der Höhe besteht darin, Zellen in maximaler Höhe zu zwingen, sich unabhängig von ihrer Temperatur in Schneespitzen zu verwandeln, nur wenn sie nicht zu trocken sind. </font><font style="vertical-align: inherit;">Dies erhöht die Wahrscheinlichkeit von Schneespitzen in der Nähe des heißen und feuchten Äquators.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schneekappen in maximaler Höhe.</font></font></i> <br><br><h3>  Pflanzen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen wir nun die Biomasse den Gehalt an Pflanzenzellen bestimmen. </font><font style="vertical-align: inherit;">Fügen Sie dazu das </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld der Pflanzen hinzu und </font><font style="vertical-align: inherit;">fügen Sie </font><font style="vertical-align: inherit;">es in den Konstruktor ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den kältesten und trockensten Biomen gibt es überhaupt keine Pflanzen. </font><font style="vertical-align: inherit;">Im Übrigen sind die Pflanzen umso pflanzlicher, je wärmer und feuchter das Klima ist. </font><font style="vertical-align: inherit;">Die zweite Feuchtigkeitssäule erhält nur die erste Pflanzenstufe für die heißeste Reihe, daher [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">Die dritte Spalte erhöht die Pegel um eins, mit Ausnahme von Schnee, dh [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">Und die feuchteste Säule erhöht sie wieder, das heißt, es stellt sich heraus [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">Ändern Sie das Array, </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem Sie die Anlagenkonfiguration hinzufügen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrix von Biomen mit Pflanzenebenen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir das Niveau der Pflanzen für die Zelle einstellen.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes mit Pflanzen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sehen Pflanzen jetzt anders aus?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    — (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können das Niveau der Pflanzen für Biome ändern. </font><font style="vertical-align: inherit;">Zuerst müssen wir sicherstellen, dass sie nicht auf dem schneebedeckten Gelände erscheinen, das wir bereits einrichten konnten. </font><font style="vertical-align: inherit;">Zweitens wollen wir das Niveau der Pflanzen entlang der Flüsse erhöhen, wenn es noch nicht das Maximum erreicht hat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifizierte Pflanzen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterwasserbiome </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Moment haben wir die Unterwasserzellen völlig ignoriert. </font><font style="vertical-align: inherit;">Fügen wir ihnen eine kleine Variation hinzu, und wir werden nicht für alle die Textur der Erde verwenden. </font><font style="vertical-align: inherit;">Eine einfache Lösung basierend auf der Höhe reicht bereits aus, um ein interessanteres Bild zu erstellen. </font><font style="vertical-align: inherit;">Verwenden wir zum Beispiel Gras für Zellen einen Schritt unter dem Wasserspiegel. </font><font style="vertical-align: inherit;">Verwenden wir Gras auch für Zellen über dem Wasserspiegel, dh für Seen, die von Flüssen erzeugt werden. </font><font style="vertical-align: inherit;">Zellen mit einer negativen Höhe sind Tiefseegebiete, daher verwenden wir Stein für sie. </font><font style="vertical-align: inherit;">Alle anderen Zellen bleiben gemahlen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterwasservariabilität.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen wir einige weitere Details für die Unterwasserzellen entlang der Küste hinzu. Dies sind Zellen mit mindestens einem Nachbarn über dem Wasser. Wenn eine solche Zelle flach ist, werden wir einen Strand schaffen. Und wenn es sich neben der Klippe befindet, ist es das dominierende visuelle Detail, und wir verwenden den Stein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies festzustellen, werden wir die Nachbarn von Zellen überprüfen, die sich einen Schritt unter dem Wasserspiegel befinden. Zählen wir die Anzahl der Verbindungen durch Klippen und Hänge mit benachbarten Landzellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir diese Informationen verwenden, um Zellen zu klassifizieren. </font><font style="vertical-align: inherit;">Erstens, wenn mehr als die Hälfte der Nachbarn Land sind, dann haben wir es mit einem See oder einer Bucht zu tun. </font><font style="vertical-align: inherit;">Für diese Zellen verwenden wir eine Grasstruktur. </font><font style="vertical-align: inherit;">Wenn wir sonst Klippen haben, verwenden wir Stein. </font><font style="vertical-align: inherit;">Wenn wir sonst Hänge haben, verwenden wir Sand, um einen Strand zu schaffen. </font><font style="vertical-align: inherit;">Die einzige verbleibende Option ist ein flaches Gebiet vor der Küste, für das wir noch Gras verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilität der Küste. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns abschließend überprüfen, ob wir im kältesten Temperaturbereich keine grünen Unterwasserzellen haben. </font><font style="vertical-align: inherit;">Für solche Zellen benutzen wir die Erde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir hatten die Möglichkeit, zufällige Karten zu generieren, die mit vielen Konfigurationsoptionen sehr interessant und natürlich aussehen. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 27: Eine Karte falten </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir teilen die Karten in Spalten, die verschoben werden können. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zentrieren Sie die Karte in der Kamera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir brechen alles zusammen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem letzten Teil werden wir Unterstützung für die Minimierung der Karte hinzufügen und die östlichen und westlichen Ränder verbinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Tutorial wurde mit Unity 2017.3.0p3 erstellt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch das Falten dreht sich die Welt.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faltkarten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Karten können verwendet werden, um Bereiche unterschiedlicher Größe zu modellieren, sie sind jedoch immer auf eine rechteckige Form beschränkt. Wir können eine Karte einer Insel oder eines ganzen Kontinents erstellen, aber nicht des gesamten Planeten. Die Planeten sind kugelförmig, sie haben keine starren Grenzen, die die Bewegung auf ihrer Oberfläche behindern. Wenn Sie sich weiter in eine Richtung bewegen, kehren Sie früher oder später zum Ausgangspunkt zurück. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können kein Sechseckgitter um eine Kugel wickeln, eine solche Überlappung ist unmöglich. In bester Näherung wird die ikosaedrische Topologie verwendet, bei der die zwölf Zellen Pentagone sein müssen. Ohne Verzerrung oder Ausnahme kann das Netz jedoch um den Zylinder gewickelt werden. Verbinden Sie dazu einfach den östlichen und den westlichen Rand der Karte. Mit Ausnahme der Wrapping-Logik bleibt alles andere gleich.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Zylinder ist eine schlechte Annäherung an eine Kugel, da wir keine Pole modellieren können. </font><font style="vertical-align: inherit;">Dies hinderte die Entwickler vieler Spiele jedoch nicht daran, das Falten von Ost nach West zum Modellieren von Planetenkarten zu verwenden. </font><font style="vertical-align: inherit;">Polarregionen sind einfach nicht Teil der Spielzone.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wäre es nach Norden und Süden?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei Möglichkeiten, eine zylindrische Faltung durchzuführen. </font><font style="vertical-align: inherit;">Die erste besteht darin, die Karte tatsächlich zylindrisch zu machen, indem ihre Oberfläche und alles darauf gebogen werden, so dass die östlichen und westlichen Ränder in Kontakt sind. </font><font style="vertical-align: inherit;">Jetzt spielen Sie nicht mehr auf einer ebenen Fläche, sondern auf einem echten Zylinder. </font><font style="vertical-align: inherit;">Der zweite Ansatz besteht darin, eine flache Karte zu speichern und Teleportation oder Duplizierung zum Kollabieren zu verwenden. </font><font style="vertical-align: inherit;">Die meisten Spiele verwenden den zweiten Ansatz, also werden wir es nehmen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionales Zusammenklappen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Notwendigkeit, die Karte zu reduzieren, hängt von ihrem Maßstab ab - lokal oder planetarisch. </font><font style="vertical-align: inherit;">Wir können die Unterstützung von beiden nutzen, indem wir das Falten optional machen. </font><font style="vertical-align: inherit;">Fügen Sie dazu dem </font><font style="vertical-align: inherit;">Menü " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neue Karte erstellen"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen </font><font style="vertical-align: inherit;">neuen Schalter hinzu, für den das </font><em><font style="vertical-align: inherit;">Reduzieren</font></em><font style="vertical-align: inherit;"> standardmäßig aktiviert ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Menü der neuen Karte mit der Option zum Reduzieren. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie dem </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld eine Option zum Verfolgen der Auswahl sowie eine Methode zum Ändern der Auswahl hinzu. </font><font style="vertical-align: inherit;">Lassen Sie uns diese Methode aufrufen, wenn sich der Status des Schalters ändert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn eine neue Karte angefordert wird, übergeben wir den Wert der Minimierungsoption. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie es </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass es dieses neue Argument akzeptiert und es dann an weiterleitet </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … grid.CreateMap(x, z, wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code&gt; HexGrid sollte wissen, ob wir zusammenbrechen. Fügen Sie also ein Feld hinzu und setzen Sie </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es. </font><font style="vertical-align: inherit;">Andere Klassen sollten ihre Logik ändern, je nachdem, ob das Raster minimiert ist, daher werden wir das Feld allgemein machen. </font><font style="vertical-align: inherit;">Darüber hinaus können Sie den Standardwert über den Inspektor festlegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; … }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anrufe </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an zwei Orten besitzen. </font><font style="vertical-align: inherit;">Wir können einfach ein eigenes Feld für das Kollapsargument verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … CreateMap(cellCountX, cellCountZ, wrapping); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Gitterklappschalter ist standardmäßig aktiviert.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern und laden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da für jede Karte eine Faltung festgelegt ist, muss sie gespeichert und geladen werden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie das Dateispeicherformat ändern müssen, also erhöhen Sie die Versionskonstante in </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie </font><font style="vertical-align: inherit;">beim Speichern </font><font style="vertical-align: inherit;">einfach den booleschen Faltwert nach der Kartengröße schreiben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Laden lesen wir es nur mit der richtigen Version der Datei. </font><font style="vertical-align: inherit;">Wenn es anders ist, ist dies eine alte Karte und sollte nicht minimiert werden. </font><font style="vertical-align: inherit;">Speichern Sie diese Informationen in einer lokalen Variablen und vergleichen Sie sie mit dem aktuellen Status der Faltung. </font><font style="vertical-align: inherit;">Wenn dies anders ist, können wir die vorhandene Kartentopologie nicht auf die gleiche Weise wiederverwenden wie beim Laden einer Karte mit anderen Größen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faltmetriken </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Minimieren der Karte erfordert wesentliche Änderungen in der Logik, beispielsweise bei der Berechnung von Entfernungen. </font><font style="vertical-align: inherit;">Daher können sie Code berühren, der keine direkte Verbindung zum Raster hat. </font><font style="vertical-align: inherit;">Anstatt diese Informationen als Argumente zu übergeben, fügen wir sie hinzu </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fügen Sie eine statische Ganzzahl hinzu, die die Faltgröße enthält, die der Breite der Karte entspricht. </font><font style="vertical-align: inherit;">Wenn es größer als Null ist, handelt es sich um eine zusammenklappbare Karte. </font><font style="vertical-align: inherit;">Fügen Sie eine Eigenschaft hinzu, um dies zu überprüfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen die Faltgröße für jeden Anruf einstellen </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da diese Daten die Neukompilierung im Wiedergabemodus nicht überleben, setzen wir sie ein </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellenbreite </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir mit zusammenklappbaren Karten arbeiten, müssen wir uns häufig mit Positionen entlang der X-Achse befassen, gemessen in der Breite der Zellen. </font><font style="vertical-align: inherit;">Obwohl es dafür verwendet werden kann </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wäre es bequemer, wenn wir nicht jedes Mal eine Multiplikation hinzufügen würden. </font><font style="vertical-align: inherit;">Fügen wir also eine Konstante hinzu </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können den Durchmesser bereits an drei Stellen verwenden. </font><font style="vertical-align: inherit;">Erstens </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Positionieren einer neuen Zelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens bei der </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begrenzung der Position der Kamera.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und auch bei der </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umrechnung von Position zu Koordinaten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartenzentrierung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Karte nicht kollabiert, hat sie klar definierte östliche und westliche Ränder und daher ein klares horizontales Zentrum. </font><font style="vertical-align: inherit;">Bei einer zusammenklappbaren Karte ist jedoch alles anders. </font><font style="vertical-align: inherit;">Es hat weder den östlichen noch den westlichen Rand noch das Zentrum. </font><font style="vertical-align: inherit;">Alternativ können wir davon ausgehen, dass sich in der Mitte die Kamera befindet. </font><font style="vertical-align: inherit;">Dies ist nützlich, da die Karte immer auf unserem Standpunkt zentriert sein soll. </font><font style="vertical-align: inherit;">Dann werden wir, wo immer wir sind, die östlichen oder westlichen Ränder der Karte nicht sehen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartenfragmentspalten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Kartenvisualisierung relativ zur Kamera zentriert ist, müssen wir die Platzierung der Elemente abhängig von der Bewegung der Kamera ändern. Wenn es sich nach Westen bewegt, müssen wir das, was sich derzeit am Rand des östlichen Teils befindet, an den Rand des westlichen Teils verschieben. Gleiches gilt für die Gegenrichtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Idealfall sollten wir die am weitesten entfernte Zellensäule sofort auf die andere Seite verschieben, sobald sich die Kamera zur benachbarten Zellensäule bewegt. Wir müssen jedoch nicht so genau sein. Stattdessen können wir ganze Kartenfragmente übertragen. Auf diese Weise können wir Teile der Karte verschieben, ohne die Netze ändern zu müssen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir ganze Spalten von Fragmenten gleichzeitig verschieben, gruppieren wir sie, indem wir für jede Gruppe ein übergeordnetes Spaltenobjekt erstellen. </font><font style="vertical-align: inherit;">Fügen Sie ein Array für diese Objekte hinzu </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und wir werden es in initialisieren </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden sie nur als Container verwenden, daher müssen wir nur die Verknüpfung zu ihren Komponenten verfolgen </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie bei Fragmenten befinden sich ihre Anfangspositionen am lokalen Ursprung der Gitterkoordinaten.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt sollte das Fragment ein untergeordnetes Element der entsprechenden Spalte werden, nicht des Rasters. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmente in Spalten gruppiert. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da jetzt alle Fragmente zu Kindern der Spalten geworden sind, reicht </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es aus, alle Spalten direkt zu zerstören, nicht die Fragmente. </font><font style="vertical-align: inherit;">Also werden wir Tochterfragmente los.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spalten teleportieren </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuen Methode </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Position X als Parameter hinzu. </font><font style="vertical-align: inherit;">Konvertieren Sie die Position in den Spaltenindex und teilen Sie sie durch die Fragmentbreite in Einheitseinheiten. </font><font style="vertical-align: inherit;">Dies ist der Index der Spalte, in der sich die Kamera gerade befindet, dh die mittlere Spalte der Karte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es reicht aus, die Visualisierung der Karte nur zu ändern, wenn sich der Index der zentralen Spalte ändert. </font><font style="vertical-align: inherit;">Verfolgen wir es also vor Ort. </font><font style="vertical-align: inherit;">Wir verwenden den Standardwert −1 beim Erstellen einer Karte, damit neue Karten immer zentriert werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir den Index der zentralen Spalte kennen, können wir den minimalen und maximalen Index bestimmen, indem wir einfach die Hälfte der Spalten subtrahieren und addieren. Da wir ganzzahlige Werte mit einer ungeraden Anzahl von Spalten verwenden, funktioniert dies perfekt. Bei einer geraden Zahl kann es keine perfekt zentrierte Spalte geben, sodass einer der Indizes einen Schritt weiter als nötig ist. Dies erzeugt einen Versatz von einer Spalte in Richtung des äußersten Randes der Karte, aber für uns ist dies kein Problem.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass diese Indizes möglicherweise negativ oder größer als der natürliche maximale Spaltenindex sind. </font><font style="vertical-align: inherit;">Das Minimum ist nur dann Null, wenn sich die Kamera in der Nähe des natürlichen Mittelpunkts der Karte befindet. </font><font style="vertical-align: inherit;">Unsere Aufgabe ist es, die Spalten so zu verschieben, dass sie diesen relativen Indizes entsprechen. </font><font style="vertical-align: inherit;">Dies kann durch Ändern der lokalen X-Koordinate jeder Spalte in der Schleife erfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für jede Spalte prüfen wir, ob der Index des Mindestindex kleiner ist. </font><font style="vertical-align: inherit;">Wenn ja, dann ist es zu weit links von der Mitte. </font><font style="vertical-align: inherit;">Er muss sich auf die andere Seite der Karte teleportieren. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem die X-Koordinate der Breite der Karte entspricht. </font><font style="vertical-align: inherit;">Wenn der Spaltenindex größer als der maximale Index ist, befindet er sich zu weit rechts von der Mitte und sollte sich auf die andere Seite teleportieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamerabewegung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie dies </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass er stattdessen </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anruft </font><font style="vertical-align: inherit;">, wenn er mit einer zusammenklappbaren Karte arbeitet </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Machen Sie die neue Methode zunächst einfach zu einem </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duplikat </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber mit dem einzigen Unterschied: Am Ende wird sie aufgerufen </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { … transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } … <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Karte sofort zentriert ist, rufen wir die </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode auf </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegen Sie sich nach links und rechts, wenn Sie auf der Kamera zentrieren. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir die Bewegung der Kamera immer noch einschränken, versucht die Karte jetzt, relativ zur Kamera zu zentrieren, und teleportiert bei Bedarf Spalten mit Kartenfragmenten. </font><font style="vertical-align: inherit;">Mit einer kleinen Karte und einer Remote-Kamera ist dies deutlich sichtbar, aber auf einer großen Karte befinden sich teleportierte Fragmente außerhalb des Sichtbereichs der Kamera. </font><font style="vertical-align: inherit;">Offensichtlich sind nur die anfänglichen östlichen und westlichen Ränder der Karte erkennbar, da noch keine Triangulation zwischen ihnen besteht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Kamera zu kollabieren, entfernen wir die Einschränkung ihrer X-Koordinate </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen werden wir die X-Koordinate weiterhin um die Breite der Karte erhöhen, während sie unter Null liegt, und sie verringern, während sie größer als die Breite der Karte ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Roll-up-Kamera bewegt sich entlang der Karte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenklappbare Shader-Texturen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Ausnahme des Triangulationsraums sollte eine Minimierung der Kamera im Spielemodus nicht wahrnehmbar sein. In diesem Fall tritt jedoch eine visuelle Veränderung in der Hälfte der Topographie und des Wassers auf. Dies geschieht, weil wir eine Position in der Welt verwenden, um diese Texturen abzutasten. Eine scharfe Teleportation des Fragments verändert die Position der Texturen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können dieses Problem lösen, indem wir die Texturen in Kacheln anzeigen lassen, die ein Vielfaches der Fragmentgröße sind. Die Fragmentgröße wird aus den Konstanten in berechnet. </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie also die Shader-Include-Datei </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexMetrics.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und fügen Sie die entsprechenden Definitionen ein. Die grundlegende Kachelskala wird aus der Fragmentgröße und dem Außenradius der Zelle berechnet. Wenn Sie andere Metriken verwenden, müssen Sie die Datei entsprechend ändern.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ergibt eine Kachelskala von 0,00866025404. </font><font style="vertical-align: inherit;">Wenn wir ein ganzzahliges Vielfaches dieses Werts verwenden, wird die Texturierung durch die Teleportation von Fragmenten nicht beeinflusst. </font><font style="vertical-align: inherit;">Außerdem werden die Texturen am östlichen und westlichen Rand der Karte nahtlos verbunden, nachdem wir ihre Verbindung korrekt trianguliert haben. </font><font style="vertical-align: inherit;">Wir haben 0,02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als UV-Skala im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader verwendet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Stattdessen können wir die doppelte Kachelskala verwenden, die 0,01732050808 beträgt. </font><font style="vertical-align: inherit;">Die Skala wird etwas weniger erhalten als sie war, und die Skala der Textur nahm leicht zu, aber visuell ist sie unsichtbar.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font><font style="vertical-align: inherit;">für UV-Rauschen haben wir eine Skala von 0,025 verwendet. </font><font style="vertical-align: inherit;">Stattdessen können Sie die dreifache Kachelskala verwenden. </font><font style="vertical-align: inherit;">Dies gibt uns 0.02598076212, was ziemlich nahe ist.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">bei </font><em><font style="vertical-align: inherit;">Water.cginc</font></em><font style="vertical-align: inherit;"> 0,015 für Schaum und 0,025 für Wellen verwendet. </font><font style="vertical-align: inherit;">Hier können wir diese Werte wieder durch eine doppelte und dreifache Kachelskala ersetzen.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); … } … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Vereinigung von Ost und West </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt ist der einzige visuelle Beweis für die Minimierung der Karte eine kleine Lücke zwischen der östlichsten und der westlichsten Spalte. </font><font style="vertical-align: inherit;">Diese Lücke tritt auf, weil wir die Verbindungen von Kanten und Winkeln zwischen Zellen auf gegenüberliegenden Seiten der Karte noch nicht trianguliert haben, ohne sie zu falten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platz am Rand.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachbarn falten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Ost-West-Verbindung zu triangulieren, müssen wir die Zellen auf gegenüberliegenden Seiten zu Nachbarn machen. </font><font style="vertical-align: inherit;">Bisher tun wir dies nicht, da die </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EW-Verbindung mit der vorherigen Zelle nur hergestellt wird, wenn ihr Index in X größer als Null ist. </font><font style="vertical-align: inherit;">Um diese Verbindung zu trennen, müssen wir die letzte Zelle der Zeile mit der ersten Zelle in derselben Zeile verbinden, wenn die Karte gefaltet ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Verbindung der Nachbarn E - W hergestellt haben, erhalten wir eine partielle Triangulation der Lücke. </font><font style="vertical-align: inherit;">Die Verbindung der Kanten ist nicht ideal, da die Verzerrung falsch ausgeblendet ist. </font><font style="vertical-align: inherit;">Wir werden uns später darum kümmern.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindungen E - W. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen auch die NE-SW-Verbindungen reduzieren. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem die erste Zelle jeder geraden Zeile mit den letzten Zellen der vorherigen Zeile verbunden wird. </font><font style="vertical-align: inherit;">Es wird nur die vorherige Zelle sein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NE - SW - Verbindungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich werden SE-NW-Verbindungen am Ende jeder ungeraden Zeile unterhalb der ersten hergestellt. </font><font style="vertical-align: inherit;">Diese Zellen müssen mit der ersten Zelle der vorherigen Zeile verbunden sein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindungen SE - NW.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geräuschfaltung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Lücke perfekt zu verbergen, müssen wir sicherstellen, dass der östliche und der westliche Rand der Karte mit dem Rauschen übereinstimmen, das perfekt zum Verzerren der Positionen der Scheitelpunkte verwendet wird. </font><font style="vertical-align: inherit;">Wir können den gleichen Trick verwenden, der für Shader verwendet wurde, aber für die Verzerrung wurde eine Rauschskala von 0,003 verwendet. </font><font style="vertical-align: inherit;">Um das Kacheln sicherzustellen, müssen Sie den Maßstab erheblich erhöhen, was zu einer chaotischeren Verzerrung der Scheitelpunkte führt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine alternative Lösung besteht nicht darin, das Rauschen zu reduzieren, sondern das Rauschen an den Rändern der Karte gleichmäßig zu dämpfen. </font><font style="vertical-align: inherit;">Wenn Sie eine gleichmäßige Dämpfung entlang der Breite einer Zelle durchführen, erzeugt die Verzerrung einen glatten Übergang ohne Lücken. </font><font style="vertical-align: inherit;">Das Rauschen in diesem Bereich wird leicht geglättet, und aus großer Entfernung erscheint die Änderung scharf, aber dies ist nicht so offensichtlich, wenn eine leichte Verzerrung der Scheitelpunkte verwendet wird.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit Temperaturschwankungen?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir die Karte nicht kollabieren, können wir mit einer </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einzigen Probe </font><font style="vertical-align: inherit;">auskommen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beim Zusammenklappen muss jedoch eine Dämpfung hinzugefügt werden. </font><font style="vertical-align: inherit;">Speichern Sie das Beispiel daher vor der Rückgabe in einer Variablen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Minimieren müssen wir mit der zweiten Probe mischen. </font><font style="vertical-align: inherit;">Wir werden den Übergang im östlichen Teil der Karte durchführen, daher muss die zweite Stichprobe nach Westen verschoben werden.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Dämpfung erfolgt durch einfache lineare Interpolation vom westlichen zum östlichen Teil über die Breite einer Zelle. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rauschmischung, eine unvollständige Lösung.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Infolgedessen erhalten wir keine genaue Übereinstimmung, da einige der Zellen auf der Ostseite negative X-Koordinaten haben. Um sich diesem Bereich nicht zu nähern, verschieben wir den Übergangsbereich um die Hälfte der Zellbreite nach Westen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtige Dämpfung.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellbearbeitung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem die Triangulation korrekt erscheint, stellen wir sicher, dass wir alles auf der Karte und an der Naht der Faltung bearbeiten können. Wie sich herausstellt, sind in teleportierten Fragmenten die Koordinaten falsch und große Pinsel werden durch eine Naht abgeschnitten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Pinsel ist zugeschnitten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um dies zu beheben, müssen wir das </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falten </font><font style="vertical-align: inherit;">melden </font><font style="vertical-align: inherit;">. Wir können dies tun, indem wir die X-Koordinate in der Konstruktormethode abgleichen. Wir wissen, dass die Axialkoordinate X aus der X-Koordinate des Versatzes durch Subtrahieren der Hälfte der Z-Koordinate erhalten wird. Mit diesen Informationen können Sie die inverse Transformation durchführen und prüfen, ob die Nullkoordinate kleiner als Null ist. Wenn ja, dann haben wir die Koordinate jenseits der Ostseite der entfalteten Karte. Da wir in jede Richtung nicht mehr als die Hälfte der Karte teleportieren, reicht es aus, die Faltgröße einmal zu X hinzuzufügen. Und wenn die Versatzkoordinate größer als die Faltgröße ist, müssen wir eine Subtraktion durchführen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Bearbeiten des unteren oder oberen Randes der Karte </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">treten </font><font style="vertical-align: inherit;">manchmal Fehler auf. </font><font style="vertical-align: inherit;">Dies geschieht, wenn der Cursor aufgrund von Verzerrungen der Scheitelpunkte in der Zellenreihe außerhalb der Karte angezeigt wird. </font><font style="vertical-align: inherit;">Dies ist ein Fehler, der auftritt, weil die Koordinaten nicht </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Vektorparameter </font><font style="vertical-align: inherit;">übereinstimmen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies kann behoben werden, indem eine Methode </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit Koordinaten als Parametern </font><font style="vertical-align: inherit;">angewendet </font><font style="vertical-align: inherit;">wird, die die erforderlichen Überprüfungen durchführt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Küstenfaltung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Triangulation funktioniert gut für das Gelände, aber entlang der Ost-West-Naht gibt es keine Ränder der Wasserküste. </font><font style="vertical-align: inherit;">Tatsächlich brechen sie einfach nicht zusammen. </font><font style="vertical-align: inherit;">Sie werden umgedreht und auf die andere Seite der Karte gestreckt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlender Rand des Wassers. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschieht, weil wir beim Triangulieren des Küstenwassers die Position eines Nachbarn verwenden. </font><font style="vertical-align: inherit;">Um dies zu beheben, müssen wir feststellen, womit wir es zu tun haben, auf der anderen Seite der Karte. </font><font style="vertical-align: inherit;">Um die Aufgabe zu vereinfachen, fügen wir der </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft für den Index eine Zellenspalte hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie diesen Index zu </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie ist einfach gleich der Versatzkoordinate X geteilt durch die Fragmentgröße.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bestimmen, was minimiert wird, indem </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">den Spaltenindex der aktuellen Zelle und ihres Nachbarn vergleichen. </font><font style="vertical-align: inherit;">Wenn der Index der Spalte des Nachbarn weniger als einen Schritt kleiner ist, befinden wir uns auf der Westseite und der Nachbar auf der Ostseite. </font><font style="vertical-align: inherit;">Deshalb müssen wir unseren Nachbarn nach Westen wenden. </font><font style="vertical-align: inherit;">Das gleiche und in die entgegengesetzte Richtung.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rippen der Küste, aber keine Ecken. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir uns um die Rippen der Küste gekümmert, uns aber bisher nicht um Ecken gekümmert. </font><font style="vertical-align: inherit;">Wir müssen dasselbe mit dem nächsten Nachbarn tun.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtig gekürzte Küste.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kartengenerierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Möglichkeit, die Ost- und Westseite zu verbinden, wirkt sich auf die Erstellung von Karten aus. </font><font style="vertical-align: inherit;">Bei der Minimierung der Karte sollte auch der Generierungsalgorithmus minimiert werden. </font><font style="vertical-align: inherit;">Dies führt zur Erstellung einer weiteren Karte. Wenn Sie jedoch einen Kartenrand </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ungleich Null verwenden </font><em><font style="vertical-align: inherit;">, ist das</font></em><font style="vertical-align: inherit;"> Falten nicht offensichtlich.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Große Karte 1208905299 mit Standardeinstellungen. Mit und ohne Falten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn minimierter nicht sinnvoll zu verwenden , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Karte Border die X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aber wir können es nicht einfach loswerden, weil gleichzeitig die Regionen verschmelzen werden. Beim Minimieren können wir einfach einen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder verwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir ändern uns </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ersetzen in jedem Fall </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diese neue Variable ist gleich oder </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, abhängig vom Wert der Option zum Reduzieren. Unten habe ich die Änderungen nur für den ersten Fall gezeigt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichzeitig bleiben die Regionen getrennt, dies ist jedoch nur erforderlich, wenn sich auf der Ost- und Westseite der Karte unterschiedliche Regionen befinden. </font><font style="vertical-align: inherit;">Es gibt zwei Fälle, in denen dies nicht beachtet wird. </font><font style="vertical-align: inherit;">Das erste ist, wenn wir nur eine Region haben. </font><font style="vertical-align: inherit;">Die zweite ist, wenn zwei Regionen die Karte horizontal teilen. </font><font style="vertical-align: inherit;">In diesen Fällen können wir einen </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert von Null </font><font style="vertical-align: inherit;">zuweisen </font><font style="vertical-align: inherit;">, der es den Landmassen ermöglicht, die Ost-West-Naht zu überqueren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Region bricht zusammen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf den ersten Blick scheint alles richtig zu funktionieren, aber es gibt tatsächlich eine Lücke entlang der Naht. </font><font style="vertical-align: inherit;">Dies wird deutlicher, wenn Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosionsprozentsatz auf</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Null setzen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Erosion deaktiviert ist, macht sich eine Naht am Relief bemerkbar.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Lücke entsteht, weil die Naht das Wachstum von Relieffragmenten verhindert. Um zu bestimmen, was zuerst hinzugefügt wird, wird der Abstand von der Zelle zur Mitte des Fragments verwendet, und die Zellen auf der anderen Seite der Karte können sehr weit entfernt sein, sodass sie sich fast nie einschalten. Das ist natürlich falsch. Wir müssen sicherstellen, dass wir </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">über die minimierte Karte Bescheid wissen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berechnen den Abstand zwischen </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, summieren die absoluten Abstände entlang jeder der drei Achsen und halbieren das Ergebnis. Der Abstand entlang Z ist immer wahr, aber das Falten entlang kann die X- und Y-Abstände beeinflussen. Beginnen wir also mit einer separaten Berechnung von X + Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist keine leichte Aufgabe, festzustellen, ob durch das Falten ein kürzerer Abstand für beliebige Zellen entsteht. Berechnen wir also einfach X + Y für Fälle, in denen wir eine andere Koordinate nach Westen falten. </font><font style="vertical-align: inherit;">Wenn der Wert kleiner als das ursprüngliche X + Y ist, verwenden Sie ihn.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn dies nicht zu einer kürzeren Entfernung führt, ist es möglich, in die andere Richtung kürzer zu drehen, also werden wir es überprüfen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt erhalten wir immer die kürzeste Entfernung auf der zusammenklappbaren Karte. </font><font style="vertical-align: inherit;">Geländefragmente werden nicht mehr durch eine Naht blockiert, wodurch sich Landmassen zusammenrollen können.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtig faltbares Relief ohne Erosion und Erosion. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Welt bereisen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir uns mit der Kartenerstellung und Triangulation befasst haben, fahren wir nun mit der Überprüfung der Trupps, der Erkundung und der Sichtbarkeit fort. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naht testen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das erste Hindernis, auf das wir stoßen, wenn wir einen Trupp um die Welt bewegen, ist der Rand der Karte, der nicht erkundet werden kann. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Naht der Karte kann nicht untersucht werden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zellen am Rand der Karte werden nicht erforscht, um die abrupte Fertigstellung der Karte zu verbergen. </font><font style="vertical-align: inherit;">Wenn die Karte jedoch minimiert ist, sollten nur die Nord- und Südzellen markiert werden, nicht jedoch die Ost- und Westzellen. </font><font style="vertical-align: inherit;">Ändern Sie dies </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um dies zu berücksichtigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sichtbarkeit von Reliefmerkmalen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüfen wir nun, ob die Sichtbarkeit entlang der Naht funktioniert. </font><font style="vertical-align: inherit;">Es funktioniert für Gelände, aber nicht für Geländeobjekte. </font><font style="vertical-align: inherit;">Es sieht so aus, als würden kollabierende Objekte die Sichtbarkeit der letzten Zelle erhalten, die nicht reduziert wurde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsche Sichtbarkeit von Objekten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschieht, weil der </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klemmmodus </font><font style="vertical-align: inherit;">für den verwendeten Texturfaltmodus eingestellt ist </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um das Problem zu lösen, ändern Sie einfach den Klemmmodus, um ihn zu wiederholen. </font><font style="vertical-align: inherit;">Wir müssen dies jedoch nur für die Koordinaten von U tun, daher werden </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separat </font><font style="vertical-align: inherit;">einstellen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } … }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trupps und Spalten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Problem ist, dass die Einheiten noch nicht zusammenbrechen. </font><font style="vertical-align: inherit;">Nach dem Verschieben der Säule, in der sie sich befinden, bleiben die Einheiten an derselben Stelle.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gerät wird nicht übertragen und befindet sich auf der falschen Seite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Problem kann gelöst werden, indem Squads untergeordnete Elemente von Spalten erstellt werden, wie wir es bei Fragmenten getan haben. </font><font style="vertical-align: inherit;">Erstens werden wir sie nicht länger zu den unmittelbaren Kindern des Gitters machen </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da sich die Einheiten bewegen, werden sie möglicherweise in einer anderen Spalte angezeigt. Das heißt, sie müssen ihre übergeordneten Einheiten ändern. </font><font style="vertical-align: inherit;">Um dies zu ermöglichen, fügen wir der </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Methode hinzu </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und übergeben als Parameter die Komponente des </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untergeordneten Elements und den Spaltenindex.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Methode aufrufen, wenn die Eigenschaft festgelegt ist </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies löst das Problem der Erstellung von Einheiten. </font><font style="vertical-align: inherit;">Wir müssen sie aber auch dazu bringen, sich beim Verschieben in die gewünschte Spalte zu bewegen. </font><font style="vertical-align: inherit;">Dazu müssen Sie </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die aktuelle Spalte </font><font style="vertical-align: inherit;">im </font><font style="vertical-align: inherit;">Index </font><font style="vertical-align: inherit;">verfolgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zu Beginn dieser Methode ist dies der Index der Zellenspalte am Anfang des Pfads oder der aktuelle, wenn die Verschiebung durch Neukompilierung unterbrochen wurde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Während jeder Iteration der Verschiebung prüfen wir, ob der Index der nächsten Spalte unterschiedlich ist, und wenn ja, ändern wir das übergeordnete Element der Reihenfolge. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { … Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch können sich Einheiten ähnlich wie Fragmente bewegen. </font><font style="vertical-align: inherit;">Wenn Sie sich jedoch durch die Naht der Karte bewegen, fallen die Einheiten noch nicht zusammen. </font><font style="vertical-align: inherit;">Stattdessen bewegen sie sich plötzlich in die falsche Richtung. </font><font style="vertical-align: inherit;">Dies geschieht unabhängig von der Position der Naht, jedoch am deutlichsten, wenn sie über die gesamte Karte springen.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pferderennen über die Karte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier können wir den gleichen Ansatz verwenden, der für die Küste verwendet wurde, nur dass wir diesmal die Kurve drehen, entlang der sich die Ablösung bewegt. </font><font style="vertical-align: inherit;">Wenn die nächste Spalte nach Osten gedreht wird, teleportieren wir die Kurve auch nach Osten, ähnlich für die andere Richtung. </font><font style="vertical-align: inherit;">Sie müssen die Kontrollpunkte der Kurve </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">ändern </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was sich auch auf den Kontrollpunkt auswirkt </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); … }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegung mit Falten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Letzte, was Sie tun müssen, ist, die erste Runde des Trupps zu ändern, wenn es auf die erste Zelle schaut, in die es sich bewegen wird. Befindet sich diese Zelle auf der anderen Seite der Ost-West-Naht, schaut das Gerät in die falsche Richtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Minimieren einer Karte gibt es zwei Möglichkeiten, einen Punkt zu betrachten, der sich nicht genau im Norden oder Süden befindet. Sie können entweder nach Osten oder nach Westen schauen. Es ist logisch, in die Richtung zu schauen, die dem nächstgelegenen Abstand zum Punkt entspricht, da dies auch die Bewegungsrichtung ist. Verwenden wir sie also in </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Minimieren überprüfen wir den relativen Abstand entlang der X-Achse. Wenn er kleiner als die negative Hälfte der Kartenbreite ist, sollten wir nach Westen schauen. Dies kann durch Drehen des Punkts nach Westen erfolgen. </font><font style="vertical-align: inherit;">Andernfalls müssen wir nach Osten kollabieren, wenn die Entfernung mehr als die Hälfte der Breite der Karte beträgt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben also eine voll funktionsfähige minimierte Karte. </font><font style="vertical-align: inherit;">Damit ist die Reihe der Tutorials auf Sechseckkarten abgeschlossen. </font><font style="vertical-align: inherit;">Wie in den vorherigen Abschnitten erwähnt, können andere Themen berücksichtigt werden, sie sind jedoch nicht spezifisch für Sechseckkarten. </font><font style="vertical-align: inherit;">Vielleicht werde ich sie in zukünftigen Tutorials berücksichtigen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe das letzte Paket heruntergeladen und bekomme im Play-Modus Turn-Fehler</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe das letzte Paket heruntergeladen und die Grafiken sind nicht so schön wie in den Screenshots</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe das letzte Paket heruntergeladen und es generiert ständig die gleiche Karte</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427567/">https://habr.com/ru/post/de427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427555/index.html">Tiere, die Menschen mithilfe der Gesichtserkennungstechnologie zu verfolgen gelernt haben</a></li>
<li><a href="../de427557/index.html">Zusammenfassung der IT-Ereignisse im November (Teil 1)</a></li>
<li><a href="../de427561/index.html">Recht auf Reparatur: Die ersten Schritte in die richtige Richtung von Motorola</a></li>
<li><a href="../de427563/index.html">In Firefox Nightly implementierter verschlüsselter SNI-Standard</a></li>
<li><a href="../de427565/index.html">„Meine Leistung war, dass ich im Allgemeinen zum Beruf zurückgekehrt bin“ - 10 Fragen an den Programmierer, Ausgabe 10</a></li>
<li><a href="../de427569/index.html">Optimieren Sie OpenStack unter hoher Last</a></li>
<li><a href="../de427571/index.html">Die Vereinigung von R und PostgreSQL. Wir analysieren die Arbeit von Flughäfen, berechnen Renten</a></li>
<li><a href="../de427573/index.html">Süßigkeiten oder Leben: Halloween als Grund, Ihr Kind für die Wissenschaft zu begeistern</a></li>
<li><a href="../de427575/index.html">Warum Wi-Fi nicht wie geplant funktioniert und warum Sie wissen, welches Telefon der Mitarbeiter verwendet</a></li>
<li><a href="../de427577/index.html">Maschinelles Lernen vs. Signaturanalyse beim Erkennen von Angriffen auf eine Webanwendung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>