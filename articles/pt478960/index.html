<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüíª üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üñïüèª Mini sensor de luz e choque | nRF52840 üëßüèΩ üï∂Ô∏è üåå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No artigo de hoje, quero falar sobre um novo sensor de luz e vibra√ß√£o. O sensor funciona no m√≥dulo E73-2G4M08S1C (nRF52840). O motivo do desenvolvimen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mini sensor de luz e choque | nRF52840</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478960/">  No artigo de hoje, quero falar sobre um novo sensor de luz e vibra√ß√£o.  O sensor funciona no m√≥dulo E73-2G4M08S1C (nRF52840).  O motivo do desenvolvimento do MK foi a simples adi√ß√£o de suporte ao IDE do Arduino com base na biblioteca Sandeep Mistry, baixo custo, excelentes recursos e a capacidade de continuar a alternar perfeitamente do MySensors para o ZigBee, por exemplo :) <br><br><img src="https://habrastorage.org/webt/dm/b0/dt/dmb0dtvbakfgj_pgye8k_wjlmdc.jpeg"><br><a name="habracut"></a><br>  A necessidade desse projeto surgiu com o advento de uma cortina de rolo em minha casa :).  Era necess√°rio que o controlador de cortinas de rolo recebesse dados sobre o n√≠vel de ilumina√ß√£o diretamente da janela em que a cortina √© controlada pelo controlador. <br><br>  Inicialmente, planejei usar o sensor BH1750FVI, as caracter√≠sticas desse sensor eram boas, ele foi usado mais de uma vez em meus outros projetos de bricolage.  Mas, em algum momento, ao discutir todos os tipos de sensores, algu√©m sugeriu dar uma olhada no sensor MAX44009.  Olhei atentamente e, a partir daquele momento, nunca mais me lembrei do BH1750FVI. <br><br><img src="https://habrastorage.org/webt/d7/bg/a_/d7bga_4sti9_x359xlgirab0egk.jpeg"><br><br>  <b>Especifica√ß√µes do MAX44009:</b> <br><br><ul><li>  Faixa de tens√£o de alimenta√ß√£o 1,7-3,6 V, </li><li>  Corrente de opera√ß√£o ultra baixa - 0,65 ŒºA (menor que a corrente no modo de desligamento para muitos produtos similares), </li><li>  Amplo intervalo din√¢mico de 22 bits 0,045-188000, </li><li>  A presen√ßa da fun√ß√£o de interrup√ß√£o, a capacidade de monitorar continuamente o n√≠vel de ilumina√ß√£o e gerar um sinal de interrup√ß√£o para o MC ao exceder os limites especificados. </li></ul><br>  Eu tamb√©m queria universalidade ou algum tipo de funcionalidade avan√ßada, depois de um pouco de reflex√£o, decidi adicionar um aceler√¥metro ao projeto que funcionaria como um sensor de vibra√ß√£o.  Isso adicionar√° funcionalidade de seguran√ßa ao sensor.  No meu caso, com base no evento, um script em UD ser√° acionado a partir do sensor que simula a presen√ßa na casa (acenda a luz nas salas), quando ativado, ningu√©m est√° em casa.  Em geral, o sensor tamb√©m pode ser usado como um sensor de vibra√ß√£o e choque independente, apenas um sensor de luz ou apenas um aceler√¥metro podem ser soldados.  O aceler√¥metro tamb√©m pode ser reprogramado para reconhecer tapas, curvas e assim por diante. <br><br>  Como aceler√¥metro, foi escolhido o sensor LIS2DW12, um dos aceler√¥metros mais econ√¥micos do mercado, se n√£o o mais econ√¥mico. <br><br><img src="https://habrastorage.org/webt/ex/jc/op/exjcop6l77shvd-ietzkuksg5hq.jpeg"><br><br>  <b>Recursos do LIS2DW12:</b> <br><br><ul><li>  Faixa de tens√£o de alimenta√ß√£o 1,62-3,6 V, </li><li>  50 nA no modo de espera </li><li>  1 ŒºA no modo de baixa pot√™ncia, </li><li>  A presen√ßa da fun√ß√£o de interrup√ß√£o, a possibilidade de opera√ß√£o cont√≠nua do sensor e a forma√ß√£o de um sinal de interrup√ß√£o para o MC ao exceder os limites especificados. </li></ul><br>  Prevendo poss√≠veis problemas para os irm√£os Arduino com o lan√ßamento deste modelo de aceler√¥metro devido √† completa falta de bibliotecas Arduino prontas para o LIS2DW12, mais tarde foi adicionado suporte para outro modelo de aceler√¥metro LIS2DH12 com caracter√≠sticas semelhantes, mas maior consumo no modo de baixa energia - 2 ŒºA.  Para aceler√¥metros LIS2DH12, existem boas bibliotecas do Arduino. <br><br>  O sensor de luz √© alimentado por uma bateria CR2032. <br><br><img src="https://habrastorage.org/webt/bd/z3/lf/bdz3lfe167cepe3m-5vvg0fc5-0.jpeg"><br><br>  Muitos que j√° usam o projeto MySensors para construir sua Smart Home provavelmente conhecem a l√≥gica n√£o ideal dos MySensors em dispositivos de bateria.  Envio constante de apresenta√ß√µes quando o dispositivo √© reinicializado, modo sub√≥timo de recupera√ß√£o autom√°tica de dispositivos na rede, consumo sub√≥timo com interrup√ß√µes ativadas na fun√ß√£o dormir, em geral, a presen√ßa de apenas duas interrup√ß√µes em um sonho.  Todas as circunst√¢ncias sugerem que os fundadores do projeto Maysensors t√™m uma m√° atitude em rela√ß√£o √†s baterias :) <br><br>  Neste projeto, tentei minimizar essas defici√™ncias. <br><br>  A coisa mais b√°sica com a qual eu queria lidar era com interrup√ß√µes.  Normalmente, quando as interrup√ß√µes s√£o ativadas na fun√ß√£o de suspens√£o, o nRF52 MK come√ßa a consumir + 10mKA para o consumo do pr√≥prio MK (de 1,4 ŒºA para nRF52810-52811 e at√© 4,7 ŒºA para nRF52832-52840).  Um total de 2 interrup√ß√µes est√£o dispon√≠veis. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> sleep(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> interrupt1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> mode1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> interrupt2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> mode2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sleepingMS = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> smartSleep = <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  Anteriormente, na busca de solu√ß√µes para otimizar o consumo em um sonho, foi realizada a possibilidade de usar interrup√ß√µes no comparador de baixo consumo embutido, o consumo em um sonho n√£o era mais + 10 ŒºA, mas na regi√£o de +1 ŒºA, mas era poss√≠vel usar apenas uma interrup√ß√£o.  Em princ√≠pio, al√©m da inconveni√™ncia no c√≥digo (processamento de sinais de pinos adicionais) e elementos extras na placa (diodos), essa era uma boa solu√ß√£o.  Mas eu queria ainda melhor. <br><br>  Nessa √©poca, eu j√° estava um pouco familiarizado :) com o nRF5 SDK, ent√£o, depois de estudar no f√≥rum mysensors.org (dicas, dicas :)), decidi procurar a solu√ß√£o no nRF5 SDK ... e a encontrei.  Agora, est√° dispon√≠vel um n√∫mero ilimitado de interrup√ß√µes que praticamente n√£o consomem nada extra.  A principal coisa a fazer √© fazer uma pequena altera√ß√£o no c√≥digo da biblioteca Sandeepmistry nRF5, no arquivo WInterrupts.Antes da fun√ß√£o GPIOTE_IRQHandler (), adicione o atributo "fraco", que permitir√° redefinir essa fun√ß√£o da biblioteca no c√≥digo do usu√°rio - __attribute__ ((fraco)) <br><br><img src="https://habrastorage.org/webt/s5/sf/oy/s5sfoy5fdmvjiu16afhtkcrxkjg.png"><br><br>  O arquivo est√° localizado no caminho - C: \ Usu√°rios \ USER_COMPA \ AppData \ Local \ Arduino15 \ packages \ sandeepmistry \ <br>  hardware \ nRF5 \ 0.6.0 \ cores \ nRF5 \ <br>  Os arquivos que precisam ser adicionados ao projeto est√£o localizados no meu Gita na pasta EFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUINO /, um exemplo de uso est√° no esbo√ßo EFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUINO / vibro_ambi_ <br><br>  A pr√≥xima coisa que eu queria finalizar era a pr√≥pria biblioteca Sandeepmistry nRF5, para que fosse conveniente trabalhar com o novo MK nRF52840, nRF52811 e antigo, mas, por alguma raz√£o, indecentemente n√£o adicionou o nRF52810 (afinal, 1,4 ŒºA em um sonho n√£o √© para voc√™ :)).  Claro, voc√™ pode trabalhar com o nRF52840 no IDE do Arduino e no nRF52832, mas ... eu queria torn√°-lo mais confort√°vel.  Acima, escrevi que h√° interesse em fazer algo no SDK n√≥rdico, especialmente o Segger Embedded Studio √© gratuito ao trabalhar com o MK nRF5.  O suporte para todas as placas interessantes para mim foi retirado do SDK e transferido para o Arduino (at√© agora sem dispositivo de software, e n√£o √© necess√°rio com os mysensors).  Novas placas tamb√©m foram adicionadas √† biblioteca MySensors. <br><br><img src="https://habrastorage.org/webt/xc/hy/dy/xchydy8gbj0ld1tcvtyjiqbu70o.png"><br><br>  <a href="https://github.com/smartboxchannel/arduino-nRF5" rel="nofollow">github.com/smartboxchannel/arduino-nRF5</a> <br>  <a href="https://github.com/smartboxchannel/MySensors" rel="nofollow">github.com/smartboxchannel/MySensors</a> <br><br>  Se um dos leitores j√° estiver familiarizado com os meus artigos anteriores, provavelmente voc√™ n√£o ficar√° surpreso que eu, como antes, fiz uma impressora de pol√≠mero l√≠quido no SLA com um estojo para um sensor de luz.  As vantagens da impress√£o nesta tecnologia s√£o sua alta precis√£o.  Mas √© claro que tamb√©m h√° desvantagens, os pol√≠meros com os quais as impressoras dom√©sticas SLA s√£o capazes de trabalhar ainda s√£o inferiores em resist√™ncia aos pl√°sticos para FDM.O modelo 3D do gabinete consiste em 2 partes, cada metade foi impressa por 40 minutos (espessura da camada 50 m√≠crons).  Especialmente, provavelmente n√£o h√° necessidade de parar por a√≠, apenas algumas fotos do processo de desenvolvimento em um editor 3D. <br><br><img src="https://habrastorage.org/webt/a0/x0/qt/a0x0qtl5jiglsmcidmbjibr_5wi.png"><br><br><img src="https://habrastorage.org/webt/by/cz/rk/byczrkmuesyuzijn5yyvv71uroa.png"><br><br><img src="https://habrastorage.org/webt/i4/ct/qc/i4ctqcrbeduw2p4an1a1jpkie9s.png"><br><br>  O programa do sensor implementou uma reinicializa√ß√£o do dispositivo sem enviar apresenta√ß√µes.  Funciona assim: enquanto o dispositivo √© novo e n√£o √© adicionado √† sua rede, quando √© adicionado √† rede pela primeira vez, ele registra e completa a apresenta√ß√£o, ap√≥s o registro bem-sucedido, o dispositivo que recebeu o identificador n√£o envia mais a apresenta√ß√£o novamente, mas voc√™ pode envi√°-la clicando no bot√£o no sensor (este necess√°rio, por exemplo, se nem todos os sensores foram apresentados com sucesso imediatamente).  Al√©m disso, o programa desabilita a possibilidade de uma recupera√ß√£o autom√°tica padr√£o da atividade da rede (se o sensor perder a rede), sua pr√≥pria op√ß√£o n√£o padronizada foi inventada :).  Funciona assim: se o sensor detectar mais de 5 tentativas sem √™xito de enviar mensagens seguidas, o dispositivo para de enviar dados dos sensores e come√ßa a enviar uma mensagem de pesquisa de rede com um intervalo inicialmente igual ao intervalo de envio de / 2 sensores e aumentando periodicamente esse intervalo c cada envio, entre envios, um sonho saud√°vel.  Tudo isso permite economizar significativamente a energia da bateria. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de teste</b> <div class="spoiler_text"><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">SDK</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PORT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">extern</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>" { #include "app_gpiote.h" #include "nrf_gpio.h" } <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">APP_GPIOTE_MAX_USERS</span></span> 1 <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">LIS2DW12Sensor</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MAX44009</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; //<span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_DEBUG</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_RADIO_NRF5_ESB</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_DISABLED_SERIAL</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mtwr</span></span>; <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_TRANSPORT_WAIT_READY_MS</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">mtwr</span></span>) <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_NRF5_ESB_PA_LEVEL</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">NRF5_PA_MAX</span></span>) <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MySensors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SN</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX</span></span> &amp; <span class="hljs-selector-tag"><span class="hljs-selector-tag">VIBRO</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SENS</span></span>" <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SV</span></span> "1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>" <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span> 1 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span></span> 2 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span></span> 3 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span></span> 220 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span></span> 230 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span></span> 240 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SIGNAL_Q_ID</span></span> 253 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TEMP_CHILD_ID</span></span> 254 //<span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">any</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tests</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MySensors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vibroMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_TRIPPED</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_LEVEL</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">wpmMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_LEVEL</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_wpmMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_vsensMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_interv_rluxMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tempMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TEMP_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); //<span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">any</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tests</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">nosleep</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">button_flag</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">configMode</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">wpm_enable</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">onoff</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_update_transport_param</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_sendRoute_parent</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_no_present</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_nogateway_mode</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_find_parent_process</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_fcount</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ack_TL</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ack_FP</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT_ACK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_vibro_set</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interval_reading_lux</span></span> = 10; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">err_delivery_beat</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">problem_mode_count</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">countbatt</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">batt_cap</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_batt_cap</span></span> = 100; //<span class="hljs-selector-tag"><span class="hljs-selector-tag">unsigned</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">long</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BATT_TIME</span></span> = 43200000; //12 <span class="hljs-selector-tag"><span class="hljs-selector-tag">hours</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BATT_TIME</span></span> = 7200000; //12 <span class="hljs-selector-tag"><span class="hljs-selector-tag">hours</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME_TEMP</span></span> = 60000; //1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">minute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">C_BATT_TIME</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">oldmillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">newmillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">previousMillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightMillisR</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">configMillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interrupt_time</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME_W</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">axel_time</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">result</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightness</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lastbrightness</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightThreshold</span></span> = 25; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">myid</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mypar</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_mypar</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">-1</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">master_id</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Wpm</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_1Hz6_LP_ONLY</span></span> = 1<span class="hljs-selector-class"><span class="hljs-selector-class">.6f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_12Hz5</span></span> = 12<span class="hljs-selector-class"><span class="hljs-selector-class">.5f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_25Hz</span></span> = 25<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_50Hz</span></span> = 50<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_100Hz</span></span> = 100<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_200Hz</span></span> = 200<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vibro</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">app_gpiote_user_id_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">m_gpiote_user_id</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PIN_BUTTON1_MASK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AXEL_INT1_MASK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">volatile</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">axelInt1Status</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">volatile</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttInt1Status</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">batteryVoltage</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">linkQuality</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_linkQuality</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">LIS2DW12Sensor</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">lis2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">MAX44009</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">preHwInit</span></span>() { board_Init(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">before</span></span>() { blinky(1, 1, GREEN_LED); wait(1000); nRF_Init(); device_Conf(); happy_init(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup</span></span>() { interrupt_Init(); sensors_Init(); config_Happy_node(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">presentation</span></span>() { if (!sendSketchInfo(SN, SV)) { _transportSM.failedUplinkTransmissions = 0; sleep(1000); wait(50); if (!sendSketchInfo(SN, SV)) { _transportSM.failedUplinkTransmissions = 0; } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">present</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">S_VIBRATION</span></span>, "<span class="hljs-selector-tag"><span class="hljs-selector-tag">STATUS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VIBRO</span></span>", 1); <span class="hljs-selector-tag"><span class="hljs-selector-tag">wait</span></span>(2500, <span class="hljs-selector-tag"><span class="hljs-selector-tag">C_PRESENTATION</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">S_VIBRATION</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">CORE_DEBUG</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">PSTR</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">MyS</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">TEST</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WAIT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AFTER</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SENSOR</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>")); <span class="hljs-selector-tag"><span class="hljs-selector-tag">if</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT_ACK</span></span> == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(V_SENS_CHILD_ID, S_VIBRATION, "STATUS VIBRO", 1); wait(2500, C_PRESENTATION, S_VIBRATION); CORE_DEBUG(PSTR("<span class="hljs-attribute"><span class="hljs-attribute">MyS</span></span>: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>LUX<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>LUX<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>W/M^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>W/M^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(SIGNAL_Q_ID, S_CUSTOM, "</span></span>SIGNAL QUALITY<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(SIGNAL_Q_ID, S_CUSTOM, "</span></span>SIGNAL QUALITY<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span></span>ON|OFF WPM<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span></span>ON|OFF WPM<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span></span>SENS LEVEL VIBRO<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span></span>SENS LEVEL VIBRO<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span></span>INTERVAL RLUX|MIN<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span></span>INTERVAL RLUX|MIN<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } send(conf_wpmMsg.set(wpm_enable), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_wpmMsg.set(wpm_enable), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } send(conf_vsensMsg.set(conf_vibro_set), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_vsensMsg.set(conf_vibro_set), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } send(conf_interv_rluxMsg.set(interval_reading_lux), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_interv_rluxMsg.set(interval_reading_lux), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } } void loop() { if (flag_update_transport_param == 1) { update_Happy_transport(); } if (flag_sendRoute_parent == 1) { present_only_parent(); } if (isTransportReady() == true) { if (flag_nogateway_mode == 0) { if (flag_find_parent_process == 1) { find_parent_process(); } if (configMode == 0) { if ((axelInt1Status == AXEL_INT1) || (buttInt1Status == PIN_BUTTON1)) { if (axelInt1Status == AXEL_INT1) { nosleep = 1; send_Axel(); axelInt1Status = 0; newmillis = millis(); interrupt_time = newmillis - oldmillis; SLEEP_TIME_W = SLEEP_TIME_W - interrupt_time; if (SLEEP_TIME_W &lt; 5000) { SLEEP_TIME_W = SLEEP_TIME; send_Brigh(1); countbatt++; if (countbatt == C_BATT_TIME) { sendBatteryStatus(1); countbatt = 0; } } nosleep = 0; } if (buttInt1Status == PIN_BUTTON1) { if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) { button_flag = 1; nosleep = 1; previousMillis = millis(); ledsOff(); } if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) { if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 1750)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(GREEN_LED, onoff); } } if ((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) { ledsOff(); } if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(BLUE_LED, onoff); } } if ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) { ledsOff(); } if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) { ledsOff(); } if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500)) { if (millis() - lightMillisR &gt; 50) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if (millis() - previousMillis &gt; 8500) { ledsOff(); } } if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) { if (millis() - previousMillis &lt;= 2000) { ledsOff(); send_Brigh(0); nosleep = 0; button_flag = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000)) { ledsOff(); configMode = 1; button_flag = 0; configMillis = millis(); } if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250)) { ledsOff(); blinky(2, 2, RED_LED); button_flag = 0; buttInt1Status = 0; presentation(); nosleep = 0; } if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500)) { ledsOff(); blinky(3, 3, RED_LED); new_device(); } if (((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) || ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) || ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) || ((millis() - previousMillis &gt; 8500))) { ledsOff(); blinky(1, 2, GREEN_LED); nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } else { SLEEP_TIME_W = SLEEP_TIME; send_Brigh(1); countbatt++; if (countbatt == C_BATT_TIME) { sendBatteryStatus(1); countbatt = 0; } nosleep = 0; } } else { if (millis() - configMillis &gt; 30000) { blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } else { if (buttInt1Status == PIN_BUTTON1) { if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) { button_flag = 1; nosleep = 1; previousMillis = millis(); ledsOff(); } if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) { if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 500)) { ledsOff(); } if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500)) { lightMillisR = millis(); onoff = !onoff; digitalWrite(BLUE_LED, onoff); } if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750)) { ledsOff(); } if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750)) { if (millis() - lightMillisR &gt; 50) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if (millis() - previousMillis &gt; 4750) { ledsOff(); blinky(3, 1, GREEN_LED); button_flag = 0; nosleep = 0; buttInt1Status = 0; } } if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) { if (millis() - previousMillis &lt;= 500) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500)) { ledsOff(); blinky(1, 1, BLUE_LED); check_parent(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750)) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750)) { ledsOff(); blinky(3, 3, RED_LED); new_device(); } if (millis() - previousMillis &gt; 4750) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } } } else { check_parent(); } } } if (_transportSM.failureCounter &gt; 0) { _transportConfig.parentNodeId = loadState(101); _transportConfig.nodeId = myid; _transportConfig.distanceGW = loadState(103); mypar = _transportConfig.parentNodeId; nosleep = 0; flag_fcount = 1; err_delivery_beat = 5; happy_node_mode(); gateway_fail(); } if (configMode == 0) { if (nosleep == 0) { oldmillis = millis(); axelInt1Status = 0; buttInt1Status = 0; wait(100); sleep(SLEEP_TIME_W, false); wait(50); nosleep = 1; } } } float GetWpm() { float SunLuxCoef = 0.0079; float Wpm_temp = 0; Wpm_temp = (float)brightness; Wpm_temp *= SunLuxCoef; return Wpm_temp; } void blinky(uint8_t pulses, uint8_t repit, uint8_t ledColor) { for (int x = 0; x &lt; repit; x++) { if (x &gt; 0) { sleep(300); } for (int i = 0; i &lt; pulses; i++) { if (i &gt; 0) { sleep(80); } digitalWrite(ledColor, LOW); sleep(20); digitalWrite(ledColor, HIGH); } } } void ledsOff() { digitalWrite(RED_LED, HIGH); digitalWrite(GREEN_LED, HIGH); digitalWrite(BLUE_LED, HIGH); } void nRF_Init() { NRF_POWER-&gt;DCDCEN = 1; NRF_NFCT-&gt;TASKS_DISABLE = 1; NRF_NVMC-&gt;CONFIG = 1; NRF_UICR-&gt;NFCPINS = 0; NRF_NVMC-&gt;CONFIG = 0; NRF_SAADC -&gt;ENABLE = 0; NRF_PWM0 -&gt;ENABLE = 0; NRF_PWM1 -&gt;ENABLE = 0; NRF_PWM2 -&gt;ENABLE = 0; NRF_TWIM1 -&gt;ENABLE = 0; NRF_TWIS1 -&gt;ENABLE = 0; NRF_RADIO-&gt;TXPOWER = 8; } void sensors_Init() { Wire.begin(); wait(100); light.begin(); wait(100); lis2 = new LIS2DW12Sensor (&amp;Wire); vibro_Init(); if (isTransportReady() == true) { blinky(3, 1, BLUE_LED); wait(200); blinky(3, 1, GREEN_LED); wait(200); blinky(3, 1, RED_LED); SLEEP_TIME_W = SLEEP_TIME; send_Brigh(0); wait(50); sendBatteryStatus(0); axel_time = millis(); } else { blinky(5, 3, RED_LED); } } void vibro_Init() { if (conf_vibro_set == 1) { lis2-&gt;ODRTEMP = ODR_1Hz6_LP_ONLY; } if (conf_vibro_set == 2) { lis2-&gt;ODRTEMP = ODR_12Hz5; } if (conf_vibro_set == 3) { lis2-&gt;ODRTEMP = ODR_25Hz; } if (conf_vibro_set == 4) { lis2-&gt;ODRTEMP = ODR_100Hz; } if (conf_vibro_set == 5) { lis2-&gt;ODRTEMP = ODR_200Hz; } lis2-&gt;Enable_X(); wait(50); lis2-&gt;Enable_Wake_Up_Detection(); wait(50); } void board_Init() { pinMode(PIN_BUTTON1, INPUT); pinMode(AXEL_INT1, INPUT); pinMode(AXEL_INT2, INPUT); pinMode(AMBI_INT, INPUT); pinMode(RED_LED, OUTPUT); pinMode(GREEN_LED, OUTPUT); pinMode(BLUE_LED, OUTPUT); ledsOff(); } void send_Axel() { if (millis() - axel_time &gt;= 5000) { blinky(6, 1, RED_LED); lis2-&gt;Disable_Wake_Up_Detection(); wait(100); if (_transportConfig.parentNodeId == 0) { if (send(vibroMsg.set(vibro))) { wait(100); err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } lis2-&gt;Enable_Wake_Up_Detection(); wait(100); axel_time = millis(); nosleep = 0; } if (_transportConfig.parentNodeId &gt; 0) { send(vibroMsg.set(vibro), 1); wait(2500, C_SET, V_TRIPPED); if (Ack_TL == 1) { Ack_TL = 0; err_delivery_beat = 0; //sleep_flag = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } lis2-&gt;Enable_Wake_Up_Detection(); wait(100); axel_time = millis(); nosleep = 0; } } else { nosleep = 0; } } void send_Brigh(bool start) { brightness = light.get_lux() * 2; wait(50); if (start == 1) { if (abs(brightness - lastbrightness) &gt;= brightThreshold) { if (_transportConfig.parentNodeId == 0) { if (send(brightMsg.set(brightness, 0))) { err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } } if (_transportConfig.parentNodeId &gt; 0) { send(brightMsg.set(brightness, 0), 1); wait(2500, C_SET, V_LEVEL); if (Ack_TL == 1) { Ack_TL = 0; err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } } } } else { send(brightMsg.set(brightness, 0)); lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } } void interrupt_Init() { //*** //SET //NRF_GPIO_PIN_NOPULL //NRF_GPIO_PIN_PULLUP //NRF_GPIO_PIN_PULLDOWN //*** nrf_gpio_cfg_input(PIN_BUTTON1, NRF_GPIO_PIN_PULLUP); nrf_gpio_cfg_input(AXEL_INT1, NRF_GPIO_PIN_NOPULL); APP_GPIOTE_INIT(APP_GPIOTE_MAX_USERS); PIN_BUTTON1_MASK = 1 &lt;&lt; PIN_BUTTON1; AXEL_INT1_MASK = 1 &lt;&lt; AXEL_INT1; // app_gpiote_user_register(p_user_id, pins_low_to_high_mask, pins_high_to_low_mask, event_handler) app_gpiote_user_register(&amp;m_gpiote_user_id, AXEL_INT1_MASK, PIN_BUTTON1_MASK, gpiote_event_handler); app_gpiote_user_enable(m_gpiote_user_id); axelInt1Status = 0; buttInt1Status = 0; } void gpiote_event_handler(uint32_t event_pins_low_to_high, uint32_t event_pins_high_to_low) { MY_HW_RTC-&gt;CC[0] = (MY_HW_RTC-&gt;COUNTER + 2); if (PIN_BUTTON1_MASK &amp; event_pins_high_to_low) { if ((buttInt1Status == 0) &amp;&amp; (axelInt1Status == 0)) { buttInt1Status = PIN_BUTTON1; } } if (flag_nogateway_mode == 0) { if (configMode == 0) { if (AXEL_INT1_MASK &amp; event_pins_low_to_high) { if ((axelInt1Status == 0) &amp;&amp; (buttInt1Status == 0)) { axelInt1Status = AXEL_INT1; } } } } /*** if ((PIN_BUTTON_MASK &amp; event_pins_low_to_high) || (PIN_BUTTON1_MASK &amp; event_pins_high_to_low)) ***/ } void device_Conf() { conf_vibro_set = loadState(230); if ((conf_vibro_set &gt; 5) || (conf_vibro_set == 0)) { conf_vibro_set = 1; saveState(230, conf_vibro_set); } wpm_enable = loadState(240); if (wpm_enable &gt; 1) { wpm_enable = 0; saveState(240, wpm_enable); } interval_reading_lux = loadState(220); if (interval_reading_lux &gt; 60) { interval_reading_lux = 60; saveState(230, interval_reading_lux); } else if (interval_reading_lux &lt; 1) { interval_reading_lux = 1; saveState(230, interval_reading_lux); } SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux; C_BATT_TIME = BATT_TIME / SLEEP_TIME; } void sendBatteryStatus(bool start) { sleep(5000); wait(200); batteryVoltage = hwCPUVoltage(); wait(10); batt_cap = battery_level_in_percent(batteryVoltage); if (start == 1) { if (batt_cap &lt; old_batt_cap) { sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1); wait(2500, C_INTERNAL, I_BATTERY_LEVEL); old_batt_cap = batt_cap; } } else { sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1); wait(2500, C_INTERNAL, I_BATTERY_LEVEL); } linkQuality = calculationRxQuality(); if (linkQuality != old_linkQuality) { wait(10); sendSignalStrength(linkQuality); wait(50); old_linkQuality = linkQuality; } } bool sendSignalStrength(const int16_t level, const bool ack) { return _sendRoute(build(_msgTmp, GATEWAY_ADDRESS, SIGNAL_Q_ID, C_SET, V_VAR1, ack).set(level)); } int16_t calculationRxQuality() { int16_t nRFRSSI_temp = transportGetReceivingRSSI(); int16_t nRFRSSI = map(nRFRSSI_temp, -85, -40, 0, 100); if (nRFRSSI &lt; 0) { nRFRSSI = 0; } if (nRFRSSI &gt; 100) { nRFRSSI = 100; } return nRFRSSI; } void happy_init() { //hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); // ******************** checking the node config reset ************************* if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 0) { hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); } if (loadState(100) == 0) { saveState(100, 255); } CORE_DEBUG(PSTR("</span></span>EEPROM NODE ID: %d\n<span class="hljs-string"><span class="hljs-string">"), hwReadConfig(EEPROM_NODE_ID_ADDRESS)); CORE_DEBUG(PSTR("</span></span>USER MEMORY SECTOR NODE ID: %d\n<span class="hljs-string"><span class="hljs-string">"), loadState(100)); if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 255) { mtwr = 0; } else { mtwr = 10000; no_present(); } CORE_DEBUG(PSTR("</span></span>MY_TRANSPORT_WAIT_MS: %d\n<span class="hljs-string"><span class="hljs-string">"), mtwr); } void new_device() { hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); saveState(100, 255); wdt_enable(WDTO_15MS); } void config_Happy_node() { if (mtwr == 0) { myid = getNodeId(); saveState(100, myid); mypar = _transportConfig.parentNodeId; old_mypar = mypar; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* saveState(101, mypar); saveState(102, _transportConfig.distanceGW); } if (mtwr != 0) { myid = getNodeId(); if (myid != loadState(100)) { saveState(100, myid); } if (isTransportReady() == true) { mypar = _transportConfig.parentNodeId; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* if (mypar != loadState(101)) { saveState(101, mypar); } if (_transportConfig.distanceGW != loadState(102)) { saveState(102, _transportConfig.distanceGW); } present_only_parent(); } if (isTransportReady() == false) { no_present(); flag_fcount = 1; err_delivery_beat = 5; _transportConfig.nodeId = myid; _transportConfig.parentNodeId = loadState(101); _transportConfig.distanceGW = loadState(102); mypar = _transportConfig.parentNodeId; happy_node_mode(); gateway_fail(); } } } void no_present() { _coreConfig.presentationSent = true; _coreConfig.nodeRegistered = true; } void happy_node_mode() { _transportSM.findingParentNode = false; _transportSM.transportActive = true; _transportSM.uplinkOk = true; _transportSM.pingActive = false; transportSwitchSM(stReady); _transportSM.failureCounter = 0; } void gateway_fail() { flag_nogateway_mode = 1; flag_update_transport_param = 0; SLEEP_TIME_W = SLEEP_TIME / 2; lis2-&gt;Disable_Wake_Up_Detection(); } void find_parent_process() { flag_update_transport_param = 1; flag_find_parent_process = 0; CORE_DEBUG(PSTR("</span></span>MyS: STANDART TRANSPORT MODE IS RESTORED\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; lis2-&gt;Enable_Wake_Up_Detection(); } void update_Happy_transport() { CORE_DEBUG(PSTR("</span></span>MyS: UPDATE TRANSPORT CONFIGURATION\n<span class="hljs-string"><span class="hljs-string">")); mypar = _transportConfig.parentNodeId; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* if (mypar != loadState(101)) { saveState(101, mypar); } if (_transportConfig.distanceGW != loadState(102)) { saveState(102, _transportConfig.distanceGW); } present_only_parent(); wait(50); nosleep = 0; flag_update_transport_param = 0; } void present_only_parent() { if (old_mypar != mypar) { CORE_DEBUG(PSTR("</span></span>MyS: SEND LITTLE PRESENT:) WITH PARENT ID\n<span class="hljs-string"><span class="hljs-string">")); if (_sendRoute(build(_msgTmp, 0, NODE_SENSOR_ID, C_INTERNAL, 6).set(mypar))) { flag_sendRoute_parent = 0; old_mypar = mypar; } else { flag_sendRoute_parent = 1; } } } void check_parent() { _transportSM.findingParentNode = true; CORE_DEBUG(PSTR("</span></span>MyS: SEND FIND PARENT REQUEST, WAIT RESPONSE\n<span class="hljs-string"><span class="hljs-string">")); _sendRoute(build(_msg, 255, NODE_SENSOR_ID, C_INTERNAL, 7).set("</span></span><span class="hljs-string"><span class="hljs-string">")); wait(1500, C_INTERNAL, 8); if (_msg.sensor == 255) { if (mGetCommand(_msg) == 3) { if (_msg.type == 8) { Ack_FP = 1; CORE_DEBUG(PSTR("</span></span>MyS: PARENT RESPONSE FOUND\n<span class="hljs-string"><span class="hljs-string">")); } } } if (Ack_FP == 1) { CORE_DEBUG(PSTR("</span></span>MyS: FIND PARENT PROCESS\n<span class="hljs-string"><span class="hljs-string">")); Ack_FP = 0; transportSwitchSM(stParent); flag_nogateway_mode = 0; flag_find_parent_process = 1; SLEEP_TIME_W = SLEEP_TIME; problem_mode_count = 0; } else { _transportSM.findingParentNode = false; CORE_DEBUG(PSTR("</span></span>MyS: PARENT RESPONSE NOT FOUND\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; nosleep = 0; if (problem_mode_count &lt; 24) { CORE_DEBUG(PSTR("</span></span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string"><span class="hljs-string">"), problem_mode_count); problem_mode_count++; SLEEP_TIME_W = SLEEP_TIME / 100 * 120; } else if (problem_mode_count == 24) { SLEEP_TIME_W = SLEEP_TIME * 30; CORE_DEBUG(PSTR("</span></span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string"><span class="hljs-string">"), problem_mode_count); } } } void receive(const MyMessage &amp; message) { if (message.sensor == ENABLE_WPM_SENS_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { wpm_enable = message.getBool(); saveState(240, wpm_enable); wait(10); send(conf_wpmMsg.set(wpm_enable)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == LEVEL_SENSIV_V_SENS_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { conf_vibro_set = message.getByte(); vibro_Init(); saveState(230, conf_vibro_set); wait(10); send(conf_vsensMsg.set(conf_vibro_set)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == INTERVAL_R_LUX_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { interval_reading_lux = message.getByte(); SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux; C_BATT_TIME = BATT_TIME / SLEEP_TIME; saveState(220, interval_reading_lux); wait(10); send(conf_interv_rluxMsg.set(interval_reading_lux)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == LUX_SENS_CHILD_ID) { if (message.type == V_LEVEL) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } } } } if (message.sensor == V_SENS_CHILD_ID) { if (message.type == V_TRIPPED) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } } } } if (mGetCommand(message) == 0) { PRESENT_ACK = 1; CORE_DEBUG(PSTR("</span></span>MyS: !!!ACK OF THE PRESENTATION IN THE FUNCTION RECEIVE RECEIVED!!!\n<span class="hljs-string"><span class="hljs-string">")); } }</span></span></code> </pre><br></div></div><br>  ( ,  , , , BOM): <br> <a href="https://github.com/smartboxchannel/EFEKTA-LIS2DW12-MAX44009-E73C" rel="nofollow">github.com/smartboxchannel/EFEKTA-LIS2DW12-MAX44009-E73C</a> <br><br> <b> :</b> <br><br><ul><li>    2-3 , </li><li> 6.7   , </li><li> 8     , </li><li> E73-2G4M08S1C nRF52840, </li><li> MAX44009 Ambient Light Sensor, </li><li> LIS2DW12\LIS2DH12 3-axis MEMS accelerometer, </li><li> RGB Led, </li><li> User botton, </li><li>   SWD + Serial. </li></ul><br>        Majordomo,        o    MySensors,     . <br><br><img src="https://habrastorage.org/webt/bm/xj/zj/bmxjzjfpzn0wuvccte-w5xqtn3e.png"><br><br><img src="https://habrastorage.org/webt/5t/9k/xr/5t9kxrdt4agswilm1yukte51m4g.jpeg"><br><br><div class="spoiler"> <b class="spoiler_title">   ,   ,  </b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/I2ywIxp-RsE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wc/xl/hk/wcxlhkb-zb-paorsmpqx4jwkg-4.jpeg"><br><br><img src="https://habrastorage.org/webt/mh/f-/ak/mhf-akawv5xgbnuijpdv0edgcoo.jpeg"><br><br><img src="https://habrastorage.org/webt/ie/1q/ig/ie1qign_51mb0ya5ysfiurmdgkm.jpeg"><br></div></div><br>     . <br><br>            MYSENSORS ( ,    nRF5   Arduino IDE,      mysensors,   ‚Äî   <a href="https://tgclick.com/mysensors_rus" rel="nofollow">@mysensors_rus</a> <br><br>       ! <br><br> PS/   ,      <a href="https://habr.com/ru/post/452532/"></a>          ,         .        /  ,         nRF52811.      . <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/T66y83lF-xg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><img src="https://habrastorage.org/webt/rg/dh/u2/rgdhu2htxcazyavpoh5mgf71hfo.jpeg"><br><br><img src="https://habrastorage.org/webt/uz/mx/_n/uzmx_nvuyazh3nihtfjxgb_tkpi.jpeg"><br><br><img src="https://habrastorage.org/webt/xn/7s/a2/xn7sa2lbrn3g2jvje5mr1wbcuh8.jpeg"><br><br><img src="https://habrastorage.org/webt/4y/-s/la/4y-slajjmwr_ydmqdq0v2vcify4.jpeg"><br><br><img src="https://habrastorage.org/webt/90/ub/i7/90ubi72wfku6mlf7dshkfl2nqfo.jpeg"><br><br><img src="https://habrastorage.org/webt/p9/fe/9e/p9fe9ehr29jqggmkhutdipmqygu.jpeg"><br><br><img src="https://habrastorage.org/webt/sn/gm/ou/sngmou0381zr6ias3gbtsfez3lg.jpeg"><br><br><img src="https://habrastorage.org/webt/o5/t2/j-/o5t2j-gncldts6gsxg7kxl26dce.jpeg"><br><br><img src="https://habrastorage.org/webt/jt/vl/ro/jtvlrov-l3qclnkgilhu7aqpls4.jpeg"><br><br><img src="https://habrastorage.org/webt/be/3v/je/be3vjejo_xhuxhpc_hyg9fmz4ns.jpeg"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478960/">https://habr.com/ru/post/pt478960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478950/index.html">Os resultados da semana: a Huawei se adapta √†s san√ß√µes, Putin assina leis sensacionais e na R√∫ssia bloqueia o ShutterStock</a></li>
<li><a href="../pt478952/index.html">Um m√™s com o Onyx Boox Note Pro</a></li>
<li><a href="../pt478954/index.html">RE: Medo e √≥dio em TI</a></li>
<li><a href="../pt478956/index.html">Apresentando o 3CX V16 Update 4 Beta com um cliente de VoIP do Chrome e aplicativo de v√≠deo para Android</a></li>
<li><a href="../pt478958/index.html">Guia completo de atualiza√ß√£o do Windows 10 para empresas de qualquer tamanho</a></li>
<li><a href="../pt478962/index.html">Ilya Yakyamsev: Efici√™ncia n√£o funciona</a></li>
<li><a href="../pt478966/index.html">Como sobreviver e se tornar um desenvolvedor frontend no mundo moderno?</a></li>
<li><a href="../pt478968/index.html">SpaceX lan√ßa Nanoracks para criar esta√ß√µes orbitais de detritos espaciais</a></li>
<li><a href="../pt478970/index.html">Bot√£o de chamada DIY parte 2. Videofone do Raspberry Pi</a></li>
<li><a href="../pt478974/index.html">Carregamento autom√°tico do m√≥dulo usando importa√ß√£o din√¢mica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>