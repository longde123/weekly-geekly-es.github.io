<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌱 🤱🏾 🚶🏽 魔术学院 🧖 ✖️ 🗝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP中的魔术是什么？ 这通常意味着_construct()或__get() 。 PHP中的魔术方法是漏洞，可帮助开发人员完成出色的工作。 网络中充满了您可能熟悉的使用说明。 但是，如果我们说您还没有看到真正的魔法该怎么办？ 毕竟，您似乎对所有事情都了解的越多，魔术越难以捉摸。 



 让我们放弃...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>魔术学院</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/478618/"> PHP中的魔术是什么？ 这通常意味着<code>_construct()</code>或<code>__get()</code> 。  PHP中的魔术方法是漏洞，可帮助开发人员完成出色的工作。 网络中充满了您可能熟悉的使用说明。 但是，如果我们说您还没有看到真正的魔法该怎么办？ 毕竟，您似乎对所有事情都了解的越多，魔术越难以捉摸。 <br><br><img src="https://habrastorage.org/webt/kd/xp/vm/kdxpvmeklgs6av1hp8ldzbnq4vc.jpeg"><br><br> 让我们放弃已建立的OOP规则框架，并在PHP魔术学校中使不可能变为可能。 学校的主要魔法老师是<b>亚历山大·利萨琴科</b> （ <a href="https://habr.com/ru/users/nighttiger/" class="user_link">NightTiger</a> ）。 他将教授魔术思维，也许您会喜欢魔术方法，访问属性的非标准方法，更改上下文，面向方面的编程和流过滤器。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1W3UR7v3sAo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <b>Alexander Lisachenko</b>是Alpari网站开发和架构部门的负责人。 面向方面的框架<a href="http://go.aopphp.com/">Go！</a>的作者和首席开发人员<a href="http://go.aopphp.com/">。</a>  <a href="http://go.aopphp.com/">Aop</a> 。 在PHP国际会议上的演讲者。 <br><br> 在好电影《欺骗的幻觉》中，有一个短语： <br><blockquote>  “你离得越近，看到的东西就越少。” </blockquote><br> 关于PHP，可以说是一样的，它是一种魔术，使您可以做一些不寻常的事情。 但首先，它是为了欺骗您而创建的：“ ...旨在欺骗他人的行为，既可以作为欺骗某人的方式，也可以作为一种玩笑或娱乐形式。” <br><br> 如果我们一起使用PHP并尝试编写一些神奇的东西，很可能我会欺骗您。 我会做一些技巧，您很长一段时间以来都会想知道为什么会这样。 这是因为PHP是一种以其不寻常的东西而闻名的编程语言。 <br><br><h2> 魔术装备 </h2><br> 我们需要魔术装备什么？ 痛苦的熟悉方法。 <br><br> <code>__construct(), __destruct(), __clone(), <br> __call(), __callStatic(), <br> __get(), __set(), __isset(), __unset(), <br> __sleep(), __wakeup(), <br> __toString(), __invoke(), __set_state(), <br> __debugInfo()</code> <br> <br> 我将分别说明最后一种方法-有了它，您就可以解决不寻常的事情。 但这还不是全部。 <br><br><ul><li>  <code>declare(ticks=1)</code> 。 <br></li><li>  <code>debug_backtrace()</code> 。 这是我们的同伴，以了解我们在当前代码中的位置，了解谁给我们打电话，为什么给我们打电话，以及带有什么参数。 决定不遵循所有逻辑很有用。 <br></li><li>  <code>unset(), isset()</code> 。 似乎没什么特别的，但是这些设计隐藏了很多技巧，我们将进一步考虑这些技巧。 <br></li><li>  <code>by-reference passing</code> 。 当我们通过引用传递某些对象或变量时，我们应该期望不可避免地会发生一些魔术。 <br></li><li>  <code>bound closures</code> 。 关于闭包以及它们可以绑定的事实，您可以构建很多技巧。 <br></li><li>  Reflection API有助于将反射提高到一个新的水平。 <br></li><li>  StreamWrapper API。 <br></li></ul><br> 设备已经准备就绪-我会提醒魔术的第一法则。 <br><br><blockquote> 永远是房间里最聪明的人。 </blockquote><br><h2> 绝招＃1。 不可能的比较 </h2><br> 让我们从第一个技巧开始，我将其称为“不可能比较”。 <br> 仔细看一下代码，看看这是否可能在PHP中发生。 <br><br><img src="https://habrastorage.org/webt/ji/sd/8i/jisd8ip2pzz7kx9otvdxq8_c-k4.png"><br><br> 有一个变量，我们声明它的值，然后突然它不等于自己。 <br><br><h3> 非数字 </h3><br> 有一个不可思议的人工产物，例如NaN-非数字。 <br><br><img src="https://habrastorage.org/webt/gf/fw/3b/gffw3bl5rfz8xz1br3ut9ocmhnw.jpeg"><br><br> 它的惊人功能是它不等于自身。 这是我们的第一个技巧：使用NaN迷惑一个朋友。 但是，NaN并不是此任务的唯一解决方案。 <br><br><h3> 我们使用常量 </h3><br><img src="https://habrastorage.org/webt/7c/hd/l1/7chdl1uranfz-cg9lbhc078ipnq.jpeg"><br><br> 诀窍是我们可以将<code>namespace</code> <code>false</code>声明为<code>true</code>并进行比较。 不幸的开发人员会很长一段时间想知道为什么存在<code>false</code> 。 <br><br><h3> 处理程序 </h3><br> 下一个招数是比前两个选项更强大的火炮。 让我们看看它是如何工作的。 <br><br><img src="https://habrastorage.org/webt/xj/3g/5j/xj3g5jvenlytadytgnqth9yb47c.jpeg"><br><br> 技巧是基于<code>tick_function</code>并且正如我提到的， <code>declare(ticks=1)</code> 。 <br><br> 开箱即用怎么办？ 首先，我们声明一些函数，并通过引用采用<code>isMagic</code>参数，然后尝试将该值更改为<code>true</code> 。 在我们声明了<code>declare(ticks=1)</code> ，PHP解释器在每个基本操作之后调用<code>register_tick_function</code>回调。 在此回调中，我们可以将以前为<code>false</code>的值更改为<code>true</code> 。 魔术！ <br><br><h2> 绝招＃2。 魔术表情 </h2><br> 以声明两个变量的示例为例。 其中一个是<code>false</code> ，另一个是<code>true</code> 。 我们<code>isBlack</code>和<code>isWhite</code>和var_dump结果。 您认为结果如何？ <br><br><img src="https://habrastorage.org/webt/yy/5r/kx/yy5rkxfp5zdicpodqjrutq1diri.png"><br><br>  <b>优先运营商</b> 。 正确答案是<code>false</code> ，因为在PHP中存在诸如“运算符优先级”之类的东西。 <br><br><img src="https://habrastorage.org/webt/tm/8e/uf/tm8eufef1fi8j46c3fc3xbgl1z8.jpeg"><br><br> 令人惊讶的是，逻辑运算符<code>or</code>优先级低于赋值操作。 因此，简单地分配<code>false</code> 。 在<code>isWhite</code>如果第一部分失败<code>isWhite</code>可以执行任何其他表达式。 <br><br><h3> 魔术表情 </h3><br> 看下面的代码。 有一些包含构造函数的类，还有一些工厂，其代码将更进一步。 <br><br><img src="https://habrastorage.org/webt/bk/md/w5/bkmdw5zdb6bxcpml7jzygu9vjhs.jpeg"><br><br> 注意最后一行。 <br><br><pre> <code class="php hljs">$value = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $factory-&gt;build(Foo::class);</code> </pre> <br> 有几种选择可能发生。 <br><br><ul><li>  <code>$factory</code>将被用作<code>new</code>的类名； <br></li><li> 会有解析错误； <br></li><li> 将使用调用<code>$factory-&gt;build()</code> ，此函数将返回其值，结果将为<code>new</code> ； <br></li><li>  <code>$factory-&gt;build</code>属性的值将用于构造类。 <br></li></ul><br> 让我们看看最后一个想法。 在<code>$factory</code>类中，我们声明了一系列魔术函数。 他们将编写我们的工作：调用属性，调用方法，甚至尝试在对象上调用<code>invoke</code> 。 <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Getting property {$name}"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Foo::class;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name, $arg)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Calling method {$name}"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Foo::class;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Invoking {$name}"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Foo::class;} }</code> </pre> <br> 正确答案：我们不是在调用方法，而是在调用属性。 在<code>$factory-&gt;build</code>有一个用于构造函数的参数，该参数将传递给此类。 <br><br> 顺便说一下，在这个框架中，我实现了一个称为“拦截新对象的创建”的功能-您可以“锁定”该设计。 <br><br><h3> 解析器漏洞 </h3><br> 以下示例适用于PHP解析器本身。 您是否尝试过在花括号内调用函数或分配变量？ <br><br><img src="https://habrastorage.org/webt/wi/b5/kb/wib5kbzb1j_0gzdurptouztvb7u.jpeg"><br><br> 我在Twitter上获得了这个技巧，它的工作非常不规范。 <br><br><pre> <code class="php hljs">$result = ${<span class="hljs-string"><span class="hljs-string">'_'</span></span> . !$_=getCallback()}(); $_=getCallback(); <span class="hljs-comment"><span class="hljs-comment">// string(5) "hello" !$_=getCallback()}(); // bool(false) '_'.!$_=getCallback()}(); // string(1) "_" ${'_'.!$_=getCallback()}(); // string(5) "hello"</span></span></code> </pre> <br> 首先，我们将表达式的值分配给名为<code>_</code> （下划线）的变量。 我们已经有一个变量，尝试在逻辑上将其值求反，然后我们得到<code>false</code>该行强制转换为<code>true</code> 。 然后，将它们全部粘贴到变量名中，然后将其放在大括号内。 <br><br><blockquote> 什么是魔术？ 这是一种娱乐活动，使我们感到鼓舞，不寻常，说：“什么？ 所以有可能吗？！ </blockquote><br><h2> 绝招＃3。 违反规则 </h2><br> 我对PHP的满意之处在于，您可以打破每个人创建的规则，以使其变得超级安全。 有一种称为“密封类”的设计，该设计具有私有构造函数。 作为魔术师的学生，您的任务是创建此类的一个实例。 <br><br><img src="https://habrastorage.org/webt/rt/uw/h4/rtuwh49inyhecfbsbea1hvb6kq4.jpeg"><br><br> 考虑如何执行此操作的三个选项。 <br><br><h3> 解决方法 </h3><br> 第一种方法是最明显的。 每个开发人员都应该熟悉-这是该语言为我们提供的标准API。 <br><br><img src="https://habrastorage.org/webt/w2/or/df/w2ordfmqdhs3qg-nnzbff9yiilc.png"><br><br>  <code>newInstanceWithoutConstructor</code>构造允许您绕过构造函数是私有的语言限制，并绕过我们所有的私有构造函数声明创建类的实例。 <br><br> 该选项有效，简单，不需要任何解释。 <br><br><h3> 短路 </h3><br> 第二种选择需要更多的关注和技巧。 创建一个匿名函数，然后将其绑定到该类的鱼鹰。 <br><br><img src="https://habrastorage.org/webt/2z/6k/lz/2z6klzhpzlkbcglexaslmiu9ezo.png"><br><br> 在这里，我们位于类内部，可以安全地调用私有方法。 我们通过在类的上下文中调用<code>new static</code>来使用它。 <br><br><img src="https://habrastorage.org/webt/fn/v5/ul/fnv5ulkueuayx56vd07u7tfk128.png"><br><br><h3> 反序列化 </h3><br> 我认为，第三个选项是最高级的。 <br><br><img src="https://habrastorage.org/webt/ky/qi/xb/kyqixbfapmoxxaisd6g3mlypuny.png"><br><br> 如果您以特定格式编写特定行，请在其中替换某些值-我们的班级将会出来。 <br><br><img src="https://habrastorage.org/webt/d2/0k/fi/d20kfibw1fnqmmovhc90_mqb1sy.png"><br><br> 反序列化之后，我们得到<code>instance</code> 。 <br><br><h3> 教义/实例化程序包 </h3><br>  Magic通常会成为文档化的框架或库-例如，在<b>学说/实例化器中，</b>所有这一切都得以实现。 我们可以用任何代码创建任何对象。 <br><br><pre> <code class="plaintext hljs">composer show doctrine/instantiator --all name : doctrine/instantiator descrip. : A small, lightweight utility to instantiate objects in PHP without invoking their constructors keywords : constructor, instantiate type : library license : MIT License (MIT)</code> </pre> <br><h2> 绝招＃4。 拦截财产访问 </h2><br> 乌云密布：类是秘密的，属性和构造函数是私有的，还有回调。 <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Secret</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $secret = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Secret is: '</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;secret; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPropAccess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Accessing property {$name}"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100500</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// How to create a secret instance and intercept the secret value?</span></span></code> </pre> <br> 作为向导，我们的任务是以某种方式调用回调。 <br><br><h3> 添加魔术...吸气剂 </h3><br> 添加一些魔法使其起作用。 <br><br><img src="https://habrastorage.org/webt/p7/ut/2w/p7ut2w699vysx99jnvmxvr0akfy.png"><br><br> 这种魔法是一种神奇的<code>getter</code> 。 它调用一个函数，到目前为止没有发生任何可怕的事情。 但是，我们将使用前面的技巧，并绕过私有构造创建此对象的实例。 <br><br><img src="https://habrastorage.org/webt/b0/oy/gu/b0oyguiksznuw3rzfn19rsz1s4y.jpeg"><br><br> 现在我们需要以某种方式调用回调。 <br><br><h3> 电路内部“未设置” </h3><br> 为此，创建一个闭合。 在类作用域内的闭包内部，我们使用<code>unset()</code>函数删除此变量。 <br><br><img src="https://habrastorage.org/webt/-n/2l/md/-n2lmdkswrc0cgk6tcobilajlgk.jpeg"><br><br>  <code>unset</code>允许您临时排除变量，这将允许调用我们的magic <code>get</code>方法。 <br><br><h3> 我们称私有构造函数 </h3><br> 由于我们有一个显示<code>echo</code>的私有构造函数，您只需获取此构造函数，即可通过调用它使其可访问。 <br><br><img src="https://habrastorage.org/webt/1z/-g/vo/1z-gvohztwjnrbeujkiwecxdowi.jpeg"><br><br> 因此，我们的秘密班级崩溃了。 <br><br><img src="https://habrastorage.org/webt/om/cv/ef/omcvefwmkjdrmnvuepdf3mmvf5k.png"><br><br> 我们收到一条消息，我们： <br><br><ul><li> 被拦截 <br></li><li> 返回了完全不同的东西。 <br></li></ul><br><h3>  leedavis / altr-ego软件包 </h3><br> 已经记录了很多魔术。  <b>altr-ego</b>软件包只是伪装成您的组件。 <br><br><pre> <code class="plaintext hljs">composer show leedavis81/altr-ego --all name : leedavis81/altr-ego descrip. : Access an objects protected / private properties and methods keywords : php, break scope versions : dev-master, v1.0.2, v1.0.1, v1.0.0 type : library license : MIT License (MIT)</code> </pre> <br> 您可以创建一个对象，然后再添加一个对象。 这将允许更改设施。 他会乖乖地改变并实现您的所有愿望。 <br><br><h2> 绝招＃5。  PHP中的不可变对象 </h2><br>  PHP中有不可变对象吗？ 是的，而且非常非常长的时间。 <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Magic</span></span> { $<span class="hljs-title"><span class="hljs-title">object</span></span> = (<span class="hljs-title"><span class="hljs-title">object</span></span>) [ "\0<span class="hljs-title"><span class="hljs-title">Secret</span></span>\0<span class="hljs-title"><span class="hljs-title">property</span></span>" =&gt; '<span class="hljs-title"><span class="hljs-title">test</span></span>' ]; var_dump($object); }</code> </pre> <br> 以一种有趣的方式获得它们。 有趣的是，我们创建了一个具有<b>特殊键</b>的数组。 它从结构<code>\0</code> -这是一个零字节字符，在<code>Secret</code>之后，我们也看到<code>\0</code> 。 <br><br>  PHP中使用该构造在类中声明私有属性。 如果尝试将对象强制转换为数组，则会看到相同的键。 除了<code>stdClass</code>我们什么都没有。 它包含<code>Secret</code>类的私有属性，该属性等于<code>test</code> 。 <br><br><pre> <code class="php hljs">object(stdClass) [<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-string"><span class="hljs-string">'property'</span></span> (Secret) =&gt; string <span class="hljs-string"><span class="hljs-string">'test'</span></span> (length=<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br> 唯一的问题是-那么您无法从那里获得此属性。 它已创建，但不可用。 <br><br> 我认为这很不方便-我们有不可变的对象，但是您不能使用它。 因此，我认为是时候提出我的决定了。 我使用了PHP中提供的所有知识和魔术，根据所有魔术技巧创建了一个结构。 <br><br>  <b>让我们从一个简单的例子开始-创建一个DTO</b>并尝试截取其中的所有属性（请参阅前面的技巧）。 <br><br>  <b>我们</b>将从那里捕获<b>的值保存在安全的地方</b> 。 它们将无法通过任何方法访问： <code>reflection</code> ，闭包或其他魔术方法。 但是存在不确定性-PHP中是否有这样的地方可以保证保存一些变量，以便没有一个狡猾的年轻程序员能到达那里？ <br><br>  <b>我们提供了一种魔术方法，</b>以便您可以读取此值。 为此，我们有魔术<code>getters</code> ，魔术<code>isset</code>方法，这些方法使我们能够提供API。 <br><br> 让我们回到一个可靠的地方，尝试搜索。 <br><br><ul><li>  <code>Global variables</code>取消-任何人都可以更改它们。 <br></li><li>  <code>Public properties</code>也不适合。 <br></li><li>  <code>Protected properties</code>的，因为子类将通过。 <br></li><li>  <code>Private properties</code> 。 没有信任，因为可以通过关闭或<code>reflection</code>来更改它。 <br></li><li> 可以尝试使用<code>Private static properties</code> ，但是<code>reflection</code>也会中断。 <br></li></ul><br> 似乎没有地方可以隐藏变量的值。 但是有一件神奇的事情- <code>Static variables in functions</code> -这些是函数内部的变量。 <br><br><h3> 安全存储价值 </h3><br> 我在特殊的Stack Overflow频道上询问了<b>Nikita Popov</b>和<b>Jay Watkins</b> 。 <br><br><img src="https://habrastorage.org/webt/dz/lg/ev/dzlgevsl3qi9lwbi91sjwladbpu.png"><br><br> 这是一个在其中声明静态变量的函数。 是否有可能摆脱它，改变它？ 答案是否定的。 <br><br> 我们在另一个受保护的变量世界中发现了一个小漏洞，我们想使用它。 <br><br><h3> 通过链接传递值 </h3><br> 我们将非标准地将其用作对象的属性。 但是您不能传递属性，因此我们通过引用使用经典的值传递。 <br><br><img src="https://habrastorage.org/webt/xr/qe/vn/xrqevnya2a0a8mizylf8gbimfb8.jpeg"><br><br> 事实证明，有一个类中有一个神奇的<code>callStatic</code>方法，并在其中声明了<code>Static</code>变量。 在对某个函数的任何调用中，我们都通过引用所有嵌套方法来传递Immutable对象中变量的值。 因此，我们提供了上下文。 <br><br><h3> 保存状态 </h3><br> 让我们看看状态如何保存。 <br><br><img src="https://habrastorage.org/webt/ef/5j/tm/ef5jtmjn0yuws-_nkbegq0neqag.png"><br><br> 很简单 对于传输的对象，我们使用<code>spl_object_id</code>函数，该函数为每个实例返回一个单独的标识符。 我们已经从对象获得的状态正在尝试保存在那里。 没什么特别的 <br><br><h3> 应用对象的状态 </h3><br> 同样，这里有一种通过引用和未<code>unset</code>属性传递值的构造。 我们取消了所有当前属性，之前已将它们保存在<code>State</code>变量中，然后为对象设置此上下文。 该对象不再包含任何属性，而仅包含其标识符，该标识符使用<code>spl_object_id</code>声明，并在该对象仍然存在时附加到该对象。 <br><br><img src="https://habrastorage.org/webt/tl/gp/b9/tlgpb9z5yi8ibnwqmod_kifacrq.jpeg"><br><br><h3> 获取状态 </h3><br> 然后，一切都很简单。 <br><br><img src="https://habrastorage.org/webt/2n/om/aq/2nomaqdui4jxeusbrlzucow9dck.png"><br><br> 我们在魔术获取器上获取此上下文，并从中调用我们的属性。 现在，连接此<code>Trait</code>后，没有人可以更改值。 <br><br><img src="https://habrastorage.org/webt/m7/iu/_y/m7iu_yazwpqoc4hxhlg6rv4srbo.png"><br><br> 所有魔术方法都将被覆盖并实现对象的不变性。 <br><br><img src="https://habrastorage.org/webt/jy/he/ht/jyheht4ncrsuwsh7ngerdnd5x4m.jpeg"><br><br><h3> 利萨琴科/不可变对象 </h3><br> 正如预期的那样，所有内容都会立即在库中正式化并可以使用。 <br><br><pre> <code class="plaintext hljs">composer show /immutable-object --all name : /immutable-object descrip. : Immutable object library keywords : versions : * dev-master type : library license : MIT License (MIT)</code> </pre> <br> 该库看起来很简单。 我们将其连接并创建我们的课程。 它具有不同的属性：私有，受保护的和公共的。 我们连接<code>ImmutableTrait</code> 。 <br><br><img src="https://habrastorage.org/webt/xj/gt/pe/xjgtpettshurwn257f51iaj5u78.jpeg"><br><br> 之后，您可以一次初始化对象-查看其值。 它确实保存在那里，甚至看起来像一个真正的DTO。 <br><br><pre> <code class="php hljs">object (MagicObject) [<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-string"><span class="hljs-string">'value'</span></span> =&gt; int <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre> <br> 但是，例如，如果我们尝试更改它，例如... <br><br><img src="https://habrastorage.org/webt/su/s2/dh/sus2dhhps9ts4gwpx5nxk9301m4.jpeg"><br><br>  ...然后立即得到<code>fatal exception</code> 。 我们无法更改属性，因为它是不可变的。 怎么会这样 <br><br><img src="https://habrastorage.org/webt/sh/iy/1c/shiy1cl8vmbfmwzbmah8whsbnyu.png"><br><br> 如果您参与了一个激动人心的挑战并试图降低它的竞争力，您将获得以下收益。 <br><br><img src="https://habrastorage.org/webt/ga/ym/l6/gayml6qurl3mr1o6qpvhzk1_rgi.png"><br><br> 这是我的礼物。 一旦您尝试在此类的PHPStorm中失败，它将立即停止命令的执行。 我不希望您深入研究此代码-这太危险了。 他将警告没有事可做。 <br><br><h2> 绝招＃6。 线程处理 </h2><br> 考虑设计。 <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'php://filter/read=string.toupper/resource=magic.php'</span></span>;</code> </pre> <br> 有一个神奇的东西：一个PHP过滤器， <code>read</code> ，最后连接了某种magic.php <b>文件</b> 。 这个文件看起来很简单。 <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, world!'</span></span></code> </pre> <br> 请注意，情况有所不同。 但是，如果我们通过设计“填充”文件，则会得到以下信息： <br><br><pre> <code class="php hljs">HELLO, WORLD!</code> </pre> <br> 那一刻发生了什么事？ 使用<code>include</code> PHP过滤器的构造，您可以连接任何过滤器（包括您自己的过滤器）来分析源代码。 您正在管理此源代码中的所有内容。 您可以从类和方法中删除<code>final</code> ，将属性设为公共-您可以通过此方法进行处理。 <br><br> 我的方面框架的一部分是基于此的。 连接您的类后，它将对其进行分析并将其转换为将要执行的内容。 <br><br>  PHP开箱即用，已经有一大堆现成的过滤器。 <br><br><pre> <code class="php hljs">var_dump(stream_get_filters()); <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> (size=<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">'zlib.*'</span></span> (length=<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">'bzip2.*'</span></span> (length=<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">'convert.iconv.*'</span></span> (length=<span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">' string.rotl3'</span></span> (length=<span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">'string.toupper'</span></span> (length=<span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">'string.tolower'</span></span> (length=<span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-number"><span class="hljs-number">6</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">'string.strip_tags'</span></span> (length=<span class="hljs-number"><span class="hljs-number">17</span></span>) <span class="hljs-number"><span class="hljs-number">7</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">'convert.*'</span></span> (length=<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-number"><span class="hljs-number">8</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">'consumed'</span></span> (length=<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-number"><span class="hljs-number">9</span></span> =&gt; string <span class="hljs-string"><span class="hljs-string">'dechunk'</span></span> (length=<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br> 它们允许您“压缩”内容，将其转换为大写或小写。 <br><br> 我想展示的主要技巧已经结束。 现在，让我们继续我能做的所有事情的精髓-面向方面的编程。 <br><br><h2> 绝招＃7。 面向方面的编程 </h2><br> 查看此代码，并从您的角度考虑它是好是坏。 <br><br><img src="https://habrastorage.org/webt/xx/za/wa/xxzawap4whyavczg4g5ptvsx6q0.jpeg"><br><br> 该代码似乎已经足够了。 它检查访问权限，执行日志记录，创建用户，保留，尝试捕获<code>exception</code> 。 <br><br> 如果您查看所有这些面条，则在我们的每种方法中都将其重复，这里唯一有价值的是将其标记为绿色。 <br><br><img src="https://habrastorage.org/webt/uk/za/mo/ukzamorqli1-u6wijf7d7knpwu4.jpeg"><br><br> 其他所有内容：“次要关注点”或“跨领域关注点”是跨领域功能。 <br><br> 传统的OOP使得无法使用复制粘贴复制所有这些结构，将它们删除并将它们带到某个地方。 这很糟糕，因为您必须重复此操作。 我希望代码总是看起来整洁。 <br><br><img src="https://habrastorage.org/webt/hg/vw/pm/hgvwpmdhsbhaeeh0uj5tdngunqo.jpeg"><br><br> 因此它不包含日志记录（以某种方式应用它）并且不包含<code>security</code> 。 <br><br><img src="https://habrastorage.org/webt/yz/-4/i2/yz-4i2yxrju_ti0839xg7idj5ua.jpeg"><br><br> 以上就是所有内容，包括日志记录... <br><br><img src="https://habrastorage.org/webt/sb/g1/8u/sbg18ud79gi4fg2dhc4h__ojxie.jpeg"><br><br>  ...和安全检查，... <br><br><img src="https://habrastorage.org/webt/3p/-s/07/3p-s07k5zl65ze55vxs4iddkia8.jpeg"><br><br>  ...自己表演。 <br><br> 这是可能的。 <br><br><h3> 术语表“方面” </h3><br> 有一个东西叫做Aspect。 这是一个检查权限的简单示例。 多亏了他，您可以看到一些注释，PhpStorm的插件也突出显示了该注释。  “ Aspect”声明SQL表达式，代码中要对此条件应用的点。 例如，在下面，我们要对<code>UserService</code>类中的所有公共方法应用闭包。 <br><br><img src="https://habrastorage.org/webt/jx/y_/g4/jxy_g4pvoli4gjezfp3w1vqpkpi.jpeg"><br><br> 我们使用<code>$invocation</code>方法获得闭包。 <br><br><img src="https://habrastorage.org/webt/ym/ju/mp/ymjump3eozldipcvntd-lpo9zbi.jpeg"><br><br> 这是<code>reflection</code>方法顶部的一种包装，其中包含更多参数。 <br><br> 此外，在每种方法的此回调中，您可以检查必要的访问权限，这称为“建议”。 <br><br><img src="https://habrastorage.org/webt/i8/zz/pq/i8zzpqsvck05an3amyc8hihxj00.jpeg"><br><br> 我们用这种语言来表达：“亲爱的PHP，请在每次从<code>UserService</code>类调用公共方法之前应用此方法<code>UserService</code> ” 只需一行，但很有用。 <br><br><h3> 方面与事件侦听器 </h3><br> 为了更加清楚，我将Aspect与Event Listener进行了比较。 许多人在Symfony工作，并且知道什么是Event Dispatcher。 <br><br><img src="https://habrastorage.org/webt/5v/8o/ge/5v8oge0pczc4pteufmb0bvxf-da.jpeg"><br><br> 它们的相似之处在于，我们传递了某种依赖关系，例如<code>AutorizationChecker</code> ，并声明了这种情况下的应用位置。 在Listener的情况下，这是一个名为<code>UserCreate</code> ；在<code>Aspect</code>的情况下<code>Aspect</code>我们从<code>UserService</code>预订了对公共方法的所有调用。       callback  :   -    . <br><br> ,      . <br><br> <b> </b> ,    ,  <b></b> <code>Aspects</code> . <br><br><img src="https://habrastorage.org/webt/-i/ae/iy/-iaeiyqqw4oar3tyxzbe4au38n8.jpeg"><br><br> <b> </b> .   ,    <b>  PHP-</b> . <br><br><img src="https://habrastorage.org/webt/6z/sq/da/6zsqda5rxa9alxpilq57s0wyspc.jpeg"><br><br>   ,     .    ,      ,     OPcache. <br><br> <b> </b> .     <code>Composer</code> .    Go! AOP,      <code>Composer</code>    ,    . <br><br><img src="https://habrastorage.org/webt/or/v8/l9/orv8l9yh9swl-mxtzowmrzoomm4.jpeg"><br><br>         <code>Aspects</code> ,   <code>Aspects</code> .       . <br><br>     . <br><br> <b>PHP-Parser</b> .     ,   ,      <b></b> . ,      <b> </b> ,  <a href="https://github.com/nikic/PHP-Parser">PHP-Parser</a> .           . <br><br><img src="https://habrastorage.org/webt/eg/ys/dm/egysdmlqf0bbvkmnacewmrrx-bw.jpeg"><br><br> <b> </b> .     ,   <b>goaop/parser-reflection</b> . <br><br><img src="https://habrastorage.org/webt/b_/oc/6d/b_oc6dfphlk-dtq3jxoijxzmn3i.jpeg"><br><br>    AST-      ,     .    ,        ,       ,       . <br><br>      . <br><br><img src="https://habrastorage.org/webt/9p/lu/an/9pluanmjyprlie0muf8sndyudba.jpeg"><br><br> ,         ,     <code>Aspect</code> . <br><br><img src="https://habrastorage.org/webt/3u/36/3z/3u363ztvggoi6ugvvsunvuilvuy.jpeg"><br><br>            ,     . <br><br><img src="https://habrastorage.org/webt/7z/tv/8p/7ztv8pyc8zti-wlpidlp3fm2zqk.jpeg"><br><br>    ,             ,       .      —     ,   -   ,      . <br><br><img src="https://habrastorage.org/webt/ea/o9/zn/eao9znftd3ywdjzd14acr-9w-fe.png"><br><br>      ,    .      ,   . <br><br>      Aspect MOCK.   «»,      ,   .     . <br><br>       —   <code>joinPoint</code> .   -    <code>joinPoint</code> :  ,   ,    . <br><br><h3> 接下来是什么？ </h3><br>    . <br><br> <b>OPcache preloading for AOP Core</b> .  AOP-      .          10   . Bootstrapping     ,       PHP. <br><br> <b>FFI integration to modify binary opcodes</b> . ,    ,    .     PHP-opcodes,        <code>.bin</code> .   FFI  . <br><br> <b>Modifying PHP engine internal callbacks</b>   PHP-   userland.  PHP   .   FFI  PHP     userland,       , , .     . <br><br>    ,   . <br><br><h2>  #8. goaop/framework </h2><br>   ,   <a href="https://github.com/goaop/framework"> GitHub</a>       . <br><br><pre> <code class="plaintext hljs">composer show goaop/framework --all name : goaop/framework descrip. : Framework for aspect-oriented programming in PHP. keywords : php, aop, library, aspect versions : dev-master, 3.0.x-dev, 2.x-dev, 2.3.1, … type : library license : MIT License</code> </pre> <br>    ,        PhpStorm. <br><br><img src="https://habrastorage.org/webt/ut/ah/rp/utahrp4yrgxj7ch2d0brjr_p7fk.jpeg"><br><br>   ,     Pointcuts.  ,    ,  .     —    ,   ,     . <br><br><h2> Trick #9.   </h2><br>          . ,    . <br><br>   :  ,   -    .           <code>fastcgi_finish_request</code> .    ,      ,   , - callback  —   . <br><br>         ? <br><br>   ,   <code>Deffered</code> ,  ,       . <br><br><img src="https://habrastorage.org/webt/yy/zh/7d/yyzh7dcpvv14sd3r75kroe07xky.jpeg"><br><br>    <code>Aspect</code> ,  ,    ,   <code>Deffered</code> ,    . <br><br><img src="https://habrastorage.org/webt/cc/y5/zj/ccy5zjad0olfwzemsxmnmo8mi_c.png"><br><br>   <code>Aspect</code>    :  ,  , ,      callback,  ,     callback.      . <br><br>  React ,     <code>promise</code> .     ,  -    ,  -     ,   . <br><br> ,       . <br><br><img src="https://habrastorage.org/webt/yp/zl/zp/ypzlzpf5k7tmuiculbcntozf0ga.png"><br><br>  <code>shutdown_function</code>   <code>Aspect</code> .     ,    callback,  ,   ,   ,   callback <code>onPhpTerminate</code> .     <code>fastcgi_finish_request</code>  : «, , ,   ,  ».         . <br><br>   ,          <code>sendPushNotification</code> . <br><br><img src="https://habrastorage.org/webt/z4/4g/g0/z44gg0rpyaguh-rs8xge_tf6ync.jpeg"><br><br> , -       —   2 . <br><br><img src="https://habrastorage.org/webt/v9/oa/rr/v9oarrwwsrifqgxpfpldsbezd4s.jpeg"><br><br>   ,  ,      ,  2   . <br><br>    ,  <code>Deferred</code> . <br><br><img src="https://habrastorage.org/webt/62/um/gw/62umgw3pjrqokgzk462oyhtlcpu.jpeg"><br><br>   ,    . -       ,  ,      . <br><br> 仅此而已。 ,          - .  ,   . <br><br><blockquote>    <a href="https://phprussia.ru/moscow/2020">PHP Russia 2020</a>   .        — <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dpc2020"> </a> .   <a href="http://eepurl.com/VYVaf"></a>  <a href="https://t.me/PHPRussiaConfChannel">telegram-</a> ,       PHP Russia 2020. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN478618/">https://habr.com/ru/post/zh-CN478618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN478596/index.html">PHP匿名函数：公开黑魔法会议</a></li>
<li><a href="../zh-CN478602/index.html">带有可脚本编写对象的Unity中的MVC。 第二部分</a></li>
<li><a href="../zh-CN478604/index.html">从劳动者到php程序员。 不寻常的发展事业</a></li>
<li><a href="../zh-CN478606/index.html">“晚安”-聪明的小工具如何剥夺人们的睡眠</a></li>
<li><a href="../zh-CN478616/index.html">Windows UAC永远不会停止惊奇，或者如何检测内部人员</a></li>
<li><a href="../zh-CN478620/index.html">为什么要尝试FastAPI？</a></li>
<li><a href="../zh-CN478626/index.html">使用strace调试软件部署</a></li>
<li><a href="../zh-CN478628/index.html">高CRI中文</a></li>
<li><a href="../zh-CN478630/index.html">Pascal玩Go。 业余编译器中方法和接口的实现</a></li>
<li><a href="../zh-CN478634/index.html">机器学习项目管理中的陷阱</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>