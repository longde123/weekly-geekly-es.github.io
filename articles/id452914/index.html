<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏼 🎁 👩‍👦 ML di Scala dengan senyum, untuk mereka yang tidak takut bereksperimen ✍🏿 👋🏾 ⚾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Hari ini kita akan berbicara tentang implementasi pembelajaran mesin di Scala. Saya akan mulai dengan menjelaskan bagaimana kita sampai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ML di Scala dengan senyum, untuk mereka yang tidak takut bereksperimen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/youla/blog/452914/"><img src="https://habrastorage.org/webt/n4/cq/gu/n4cqgunchqczcws7cj09vm0kpiq.png"><br><br>  Halo semuanya!  Hari ini kita akan berbicara tentang implementasi pembelajaran mesin di Scala.  Saya akan mulai dengan menjelaskan bagaimana kita sampai pada kehidupan seperti itu.  Jadi, tim kami untuk waktu yang lama menggunakan semua fitur pembelajaran mesin dengan Python.  Lebih mudah, ada banyak perpustakaan yang berguna untuk persiapan data, infrastruktur yang baik untuk pengembangan, maksud saya Jupyter Notebook.  Semuanya akan baik-baik saja, tetapi dihadapkan dengan masalah paralelisasi perhitungan dalam produksi, dan memutuskan untuk menggunakan Scala di prod.  Mengapa tidak, kami pikir, ada banyak perpustakaan di luar sana, bahkan Apache Spark ditulis dalam Scala!  Pada saat yang sama, hari ini kami mengembangkan model dalam Python, dan kemudian mengulangi pelatihan di Scala untuk serialisasi lebih lanjut dan digunakan dalam produksi.  Tetapi, seperti kata mereka, iblis ada dalam rinciannya. <br><br>  Segera saya ingin menjelaskan, pembaca yang budiman, artikel ini tidak ditulis untuk merusak reputasi Python dalam pembelajaran mesin.  Tidak, tujuan utamanya adalah membuka pintu ke dunia pembelajaran mesin pada Scala, memberikan tinjauan singkat tentang pendekatan alternatif yang mengikuti dari pengalaman kami, dan memberi tahu Anda kesulitan apa yang kami temui. <br><a name="habracut"></a><br>  Dalam praktiknya, ternyata itu tidak begitu menyenangkan: tidak ada banyak perpustakaan yang menerapkan algoritma pembelajaran mesin klasik, dan yang sering menjadi proyek OpenSource tanpa dukungan vendor besar.  Ya, tentu saja, ada Spark MLib, tetapi sangat terkait dengan ekosistem Apache Hadoop, dan saya benar-benar tidak ingin menyeretnya ke dalam arsitektur layanan mikro. <br><br>  Apa yang dibutuhkan adalah solusi yang akan menyelamatkan dunia dan membawa kembali tidur nyenyak, dan itu ditemukan! <br><br><h2>  Apa yang kamu butuhkan </h2><br>  Ketika kami memilih alat untuk pembelajaran mesin, kami melanjutkan dari kriteria berikut: <br><br><ul><li>  itu harus sederhana; <br></li><li>  meskipun sederhana, tidak ada yang membatalkan fungsionalitas luas; <br></li><li>  Saya benar-benar ingin dapat mengembangkan model dalam web-interpreter, dan tidak melalui konsol atau rakitan dan kompilasi yang konstan; <br></li><li>  ketersediaan dokumentasi memainkan peran penting; <br></li><li>  idealnya, akan ada dukungan setidaknya untuk menjawab masalah github. <br></li></ul><br><h2>  Apa yang kita lihat? </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Spark MLib</a> : tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cocok untuk</a> kita.  Seperti yang disebutkan di atas, kumpulan perpustakaan ini sangat terkait dengan tumpukan Apache Hadoop dan Spark Core itu sendiri, yang terlalu berat untuk membangun layanan microser berdasarkan itu. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache PredictionIO</a> : proyek yang menarik, banyak kontributor, ada dokumentasi dengan contoh-contoh.  Bahkan, ini adalah server REST di mana model berputar.  Ada model yang sudah jadi, misalnya, klasifikasi teks, yang peluncurannya dijelaskan dalam dokumentasi.  Dokumentasi menjelaskan bagaimana Anda dapat menambah dan melatih model Anda.  Kami tidak cocok, karena Spark digunakan di bawah tenda, dan ini lebih dari bidang solusi monolitik, daripada arsitektur layanan mikro. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache MXNet</a> : kerangka kerja yang menarik untuk bekerja dengan jaringan saraf, ada dukungan untuk Scala dan Python - ini nyaman, Anda dapat melatih jaringan saraf dengan Python, dan kemudian memuat hasil yang disimpan dari Scala saat membuat solusi produksi.  Kami menggunakannya dalam solusi produksi, ada artikel terpisah tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Senyum</a> : sangat mirip dengan paket scikit-learn untuk Python.  Ada banyak implementasi algoritma pembelajaran mesin klasik, dokumentasi yang baik dengan contoh-contoh, dukungan pada github, visualizer terintegrasi (didukung oleh Swing), Anda dapat menggunakan Jupyter Notebook untuk mengembangkan model.  Inilah yang Anda butuhkan! <br></li></ul><br><h2>  Persiapan lingkungan </h2><br>  Jadi, kami memilih Smile.  Saya akan memberi tahu Anda cara menjalankannya di Notebook Jupyter menggunakan algoritma pengelompokan k-means sebagai contoh.  Hal pertama yang perlu kita lakukan adalah menginstal Jupyter Notebook dengan dukungan Scala.  Ini dapat dilakukan melalui pip, atau menggunakan gambar Docker yang sudah dirakit dan dikonfigurasi.  Saya untuk opsi kedua yang lebih sederhana. <br><br>  Untuk membuat Jupyter berteman dengan Scala, saya ingin menggunakan BeakerX, yang merupakan bagian dari gambar Docker, tersedia di repositori resmi BeakerX.  Gambar ini direkomendasikan dalam dokumentasi Smile, dan Anda dapat menjalankannya seperti ini: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   BeakerX docker run -p 8888:8888 beakerx/beakerx</span></span></code> </pre> <br>  Tapi di sini masalah pertama sedang menunggu: pada saat penulisan artikel, BeakerX 1.0.0 dipasang di dalam gambar beakerx / beakerx, dan versi 1.4.1 sudah tersedia di github resmi proyek (lebih tepatnya, rilis terbaru 1.3.0, tetapi panduan berisi 1.4.1, dan itu bekerja :-)). <br><br>  Jelas bahwa saya ingin bekerja dengan versi terbaru, jadi saya mengumpulkan gambar saya sendiri berdasarkan BeakerX 1.4.1.  Saya tidak akan membuat Anda bosan dengan konten Dockerfile, ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautannya</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#         mkdir -p /tmp/my_code docker run -it \ -p 8888:8888 \ -v /tmp/my_code:/workspace/my_code \ entony/jupyter-scala:1.4.1</span></span></code> </pre> <br>  Ngomong-ngomong, bagi mereka yang akan menggunakan gambar saya, akan ada bonus kecil: dalam direktori contoh ada contoh k-means untuk urutan acak dengan memplot (ini bukan tugas yang sepenuhnya sepele untuk notebook Scala). <br><br><h2>  Unduh Smile in Jupyter Notebook </h2><br>  Lingkungan yang dipersiapkan dengan sangat baik!  Kami membuat buku catatan Scala baru dalam folder di direktori kami, maka kami perlu mengunduh perpustakaan dari Maven agar Smile bekerja. <br><br><pre> <code class="bash hljs">%%classpath add mvn com.github.haifengl smile-scala_2.12 1.5.2</code> </pre> <br>  Setelah menjalankan kode, daftar file jar yang diunduh akan muncul di blok outputnya. <br><br>  Langkah selanjutnya: mengimpor paket yang diperlukan agar contoh berhasil. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.image.<span class="hljs-type"><span class="hljs-type">BufferedImage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.<span class="hljs-type"><span class="hljs-type">Color</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.imageio.<span class="hljs-type"><span class="hljs-type">ImageIO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.<span class="hljs-type"><span class="hljs-type">File</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> smile.clustering._</code> </pre> <br><h2>  Mempersiapkan data untuk pengelompokan </h2><br>  Sekarang kita akan memecahkan masalah berikut: menghasilkan gambar yang terdiri dari zona tiga warna primer - merah, hijau dan biru (R, G, B).  Salah satu warna dalam gambar akan menang.  Kami mengelompokkan piksel gambar, mengambil kluster di mana akan ada piksel terbanyak, mengubah warnanya menjadi abu-abu dan membangun gambar baru dari semua piksel.  Hasil yang diharapkan: zona warna dominan akan berubah menjadi abu-abu, sisa zona tidak akan berubah warnanya. <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    640  360 val width = 640 val hight = 360 //      val testImage = new BufferedImage(width, hight, BufferedImage.TYPE_INT_RGB) //   .    . for { x &lt;- (0 until width) y &lt;- (0 until hight) color = if (y &lt;= hight / 3 &amp;&amp; (x &lt;= width / 3 || x &gt; width / 3 * 2)) Color.RED else if (y &gt; hight / 3 * 2 &amp;&amp; (x &lt;= width / 3 || x &gt; width / 3 * 2)) Color.GREEN else Color.BLUE } testImage.setRGB(x, y, color.getRGB) //    testImage</span></span></code> </pre><br>  Sebagai hasil dari mengeksekusi kode ini, gambar berikut ini ditampilkan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/499/b59/811/499b59811386f85ef8c0cf68dd01a396.png"><br><br>  Langkah selanjutnya: mengonversi gambar ke satu set piksel.  Dengan piksel yang kami maksud entitas dengan properti berikut: <br><br><ul><li>  koordinat sisi lebar (x); <br></li><li>  koordinat sisi sempit (y); <br></li><li>  nilai warna; <br></li><li>  nilai opsional dari nomor kelas / kluster (sebelum pengelompokan selesai, itu akan kosong). <br></li></ul><br>  Sebagai entitas, mudah untuk menggunakan <code>case class</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pixel</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">x: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, y: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, rgbArray: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-class"><span class="hljs-params">], clusterNumber: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Option</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">] = </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">None</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br>  Di sini, untuk nilai warna, array <code>rgbArray</code> dari tiga nilai merah, hijau dan biru digunakan (misalnya, untuk <code>Array(255.0, 0, 0)</code> warna merah <code>Array(255.0, 0, 0)</code> ). <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//      (Pixel) val pixels = for { x &lt;- (0 until testImage.getWidth).toArray y &lt;- (0 until testImage.getHeight) color = new Color(testImage.getRGB(x, y)) } yield Pixel(x, y, Array(color.getRed.toDouble, color.getGreen.toDouble, color.getBlue.toDouble)) //   10   pixels.take(10)</span></span></code> </pre> <br>  Ini melengkapi persiapan data. <br><br><h2>  Pengelompokan warna piksel </h2><br>  Jadi, kami memiliki koleksi piksel tiga warna primer, jadi kami akan mengelompokkan piksel menjadi tiga kelas. <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   val countColors = 3 //   val clusters = kmeans(pixels.map(_.rgbArray), k = countColors, runs = 20)</span></span></code> </pre> <br>  Dokumentasi merekomendasikan pengaturan parameter <code>runs</code> di kisaran 10 hingga 20. <br><br>  Ketika kode ini dieksekusi, objek jenis <code>KMeans</code> akan dibuat.  Blok output akan berisi informasi tentang hasil pengelompokan: <br><br><pre> <code class="bash hljs">K-Means distortion: 0.00000 Clusters of 230400 data points of dimension 3: 0 50813 (22.1%) 1 51667 (22.4%) 2 127920 (55.5%)</code> </pre> <br>  Satu cluster memang mengandung lebih banyak piksel daripada yang lainnya.  Sekarang kita perlu menandai koleksi piksel kita dengan kelas dari 0 hingga 2. <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    val clusteredPixels = (pixels zip clusters.getClusterLabel()).map {case (pixel, cluster) =&gt; pixel.copy(clusterNumber = Some(cluster))} //  10   clusteredPixels.take(10)</span></span></code> </pre> <br><h2>  Gambar cat ulang </h2><br>  Satu-satunya yang tersisa adalah memilih cluster dengan jumlah piksel terbesar dan mengecat ulang semua piksel yang termasuk dalam cluster ini menjadi abu-abu (ubah nilai array <code>rgbArray</code> ). <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   val grayColor = Array(127.0, 127.0, 127.0) //       val blueClusterNumber = clusteredPixels.groupBy(pixel =&gt; pixel.clusterNumber) .map {case (clusterNumber, pixels) =&gt; (clusterNumber, pixels.size) } .maxBy(_._2)._1 //       val modifiedPixels = clusteredPixels.map { case p: Pixel if p.clusterNumber == blueClusterNumber =&gt; p.copy(rgbArray = grayColor) case p: Pixel =&gt; p } //  10      modifiedPixels.take(10)</span></span></code> </pre> <br>  Tidak ada yang rumit, cukup kelompokkan dengan nomor cluster (ini adalah <code>Option:[Int]</code> kami <code>Option:[Int]</code> ), hitung jumlah elemen dalam setiap grup dan tarik keluar cluster dengan jumlah maksimum elemen.  Selanjutnya, ubah warna menjadi abu-abu hanya untuk piksel yang termasuk dalam kluster yang ditemukan. <br><br><h2>  Buat gambar baru dan simpan hasilnya. </h2><br>  Mengumpulkan gambar baru dari koleksi piksel: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//       val modifiedImage = new BufferedImage(width, hight, BufferedImage.TYPE_INT_RGB) //     modifiedPixels.foreach { case Pixel(x, y, rgbArray, _) =&gt; val r = rgbArray(0).toInt val g = rgbArray(1).toInt val b = rgbArray(2).toInt modifiedImage.setRGB(x, y, new Color(r, g, b).getRGB) } //    modifiedImage</span></span></code> </pre> <br>  Itulah yang, pada akhirnya, kami lakukan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/950/d15/69a/950d1569a1bc51920f4758499a9bbe26.png"><br><br>  Kami menyimpan kedua gambar. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ImageIO</span></span>.write(testImage, <span class="hljs-string"><span class="hljs-string">"png"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">File</span></span>(<span class="hljs-string"><span class="hljs-string">"testImage.png"</span></span>)) <span class="hljs-type"><span class="hljs-type">ImageIO</span></span>.write(modifiedImage, <span class="hljs-string"><span class="hljs-string">"png"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">File</span></span>(<span class="hljs-string"><span class="hljs-string">"modifiedImage.png"</span></span>))</code> </pre> <br><h2>  Kesimpulan </h2><br>  Pembelajaran mesin pada Scala ada.  Untuk mengimplementasikan algoritma dasar, tidak perlu menyeret beberapa perpustakaan besar.  Contoh di atas menunjukkan bahwa selama pengembangan Anda tidak bisa melepaskan cara biasa, Notebook Jupyter yang sama dapat dengan mudah berteman dengan Scala. <br><br>  Tentu saja, untuk ikhtisar lengkap semua fitur Smile, satu artikel tidak cukup, dan ini tidak termasuk dalam rencana.  Tugas utama - untuk membuka pintu ke dunia pembelajaran mesin di Scala - saya pikir sudah selesai.  Apakah menggunakan alat-alat ini, dan lebih dari itu, menyeretnya ke dalam produksi atau tidak, terserah Anda! <br><br><h2>  Referensi </h2><br><ul><li>  Dockerfile untuk Scala Jupyter Notebook gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/AntonYurchenko/docker/blob/master/jupyter-scala/Dockerfile</a> <br></li><li>  Git dengan sebuah contoh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/AntonYurchenko/habr/tree/master/scala-smile-clustering</a> <br></li><li>  Apache Spark MLib: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://spark.apache.org/mllib</a> <br></li><li>  Apache PredictionIO: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://predictionio.apache.org</a> <br></li><li>  Apache MXNet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://mxnet.incubator.apache.org</a> <br></li><li>  Senyum: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://haifengl.github.io/smile</a> <br></li><li>  Git BeakerX: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/twosigma/beakerx</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452914/">https://habr.com/ru/post/id452914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452902/index.html">Menyelesaikan pelatihan 4 tahun sebagai programmer, saya mengerti bahwa saya jauh dari seorang programmer</a></li>
<li><a href="../id452904/index.html">Bagaimana mesin berkomunikasi - protokol MQTT</a></li>
<li><a href="../id452906/index.html">Mesin JavaScript: bagaimana cara kerjanya? Dari tumpukan panggilan ke janji-janji, (hampir) semua yang perlu Anda ketahui</a></li>
<li><a href="../id452908/index.html">Selenium WebDriver - Metrik uji waktu-nyata menggunakan Grafana dan InfluxDB</a></li>
<li><a href="../id452910/index.html">Halo, Habr! Halo Tercon</a></li>
<li><a href="../id452916/index.html">Bangun dan pergi. Operasi tulang belakang: kapan harus melakukan, apa yang berbahaya</a></li>
<li><a href="../id452922/index.html">Tabel Grid CSS Fleksibel</a></li>
<li><a href="../id452924/index.html">Apa yang perlu Anda lakukan untuk mencegah akun Google Anda dicuri</a></li>
<li><a href="../id452926/index.html">Pengujian statis atau simpan Private Ryan</a></li>
<li><a href="../id452928/index.html">Kami mengembalikan mesin virtual dari Datastore yang diinisialisasi secara salah. Kisah satu omong kosong dengan akhir yang bahagia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>