<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😺 🤛🏼 👨🏾‍🌾 C # ist eine einfache Sprache? 🍲 🤫 🧠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich bin ein großer Fan von allem, was Fabien Sanglard tut, ich mag seinen Blog und ich lese beide Bücher von vorne bis hinten (beschrieben in einem kü...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # ist eine einfache Sprache?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443804/">  Ich bin ein großer Fan von allem, was <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fabien Sanglard</a> tut, ich mag seinen Blog und ich lese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beide</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bücher von</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorne bis hinten</a> (beschrieben in einem kürzlich erschienenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hansleminutes-Podcast</a> ). <br><br>  Fabien hat kürzlich einen großartigen Beitrag geschrieben, in dem er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen winzigen</a> Raytracer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entschlüsselt</a> , den Code deobfusciert und die Mathematik fantastisch schön erklärt hat.  Ich empfehle wirklich, sich die Zeit zu nehmen, um dies zu lesen! <br><br>  Aber ich habe mich gefragt, <i><b>ob es möglich ist, diesen C ++ - Code nach C # zu portieren</b></i> .  Da ich in letzter Zeit in meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptjob</a> ziemlich viel C ++ geschrieben habe, dachte ich, ich könnte es versuchen. <br><br>  Aber was noch wichtiger ist, ich wollte eine bessere Vorstellung davon bekommen, <b>ob C # eine einfache Sprache ist</b> . <br><a name="habracut"></a><br>  Eine etwas andere, aber verwandte Frage: Inwieweit ist C # für die "Systemprogrammierung" geeignet?  Zu diesem Thema empfehle ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Joe Duffys hervorragenden Beitrag aus dem Jahr 2013</a> . <br><br><h1>  Leitungsport </h1><br>  Ich begann damit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deobfuscierten C ++ - Code</a> einfach Zeile für Zeile nach C # zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">portieren</a> .  Es war ziemlich einfach: Es scheint, dass die Wahrheit immer noch gesagt wird, dass C # C ++++ ist !!! <br><br>  Das Beispiel zeigt die Hauptdatenstruktur - 'Vektor', hier ein Vergleich, C ++ links, C # rechts: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f14/ecc/cbd/f14ecccbd0091486caf57fc43fb2ac7f.png"></a> <br><br>  Es gibt also einige syntaktische Unterschiede, aber da Sie mit .NET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ihre eigenen Werttypen</a> definieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können</a> , konnte ich dieselbe Funktionalität erhalten.  Dies ist wichtig, da die Behandlung von "Vektor" als Struktur bedeutet, dass wir eine bessere "Datenlokalität" erzielen können und den .NET-Garbage Collector nicht einbeziehen müssen, da die Daten auf den Stapel übertragen werden (ja, ich weiß, dass dies ein Implementierungsdetail ist). <br><br>  Weitere Informationen zu <code>structs</code> oder „ <code>structs</code> “ in .NET finden Sie hier: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heap versus Stack, Werttyp versus Referenztyp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Werttypen versus Referenztypen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicher in .NET: wohin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Wahrheit über Werttypen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Stack ist ein Implementierungsdetail, Teil eins</a> </li></ul><br>  Insbesondere in Eric Lipperts letztem Beitrag finden wir ein so nützliches Zitat, dass deutlich wird, was „Werttypen“ wirklich sind: <br><br><blockquote>  Das Wichtigste an den Wertetypen sind natürlich <b>nicht die Implementierungsdetails, <i>wie sie zugeordnet werden</i></b> , sondern die <i>ursprüngliche semantische Bedeutung des</i> „Wertetyps“, <b>nämlich, dass er <i>immer „nach Wert“ kopiert wird</i></b> .  Wenn Zuordnungsinformationen wichtig wären, würden wir sie "Heap-Typen" und "Stack-Typen" nennen.  Aber in den meisten Fällen spielt es keine Rolle.  Meistens ist die Semantik des Kopierens und Identifizierens relevant. </blockquote><br>  Nun wollen wir sehen, wie einige andere Methoden im Vergleich aussehen (wieder C ++ links, C # rechts), zuerst <code>RayTracing(..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d0/3c5/277/4d03c5277ffa4f1e73462dab4edc7dd0.png"></a> <br><br>  Dann <code>QueryDatabase (..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2fc/c17/839/2fcc17839a00bfc619e14c7323e28f52.png"></a> <br><br>  (In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fabians Beitrag finden Sie</a> eine Erklärung, was diese beiden Funktionen bewirken.) <br><br>  Tatsache ist jedoch, dass C # das Schreiben von C ++ - Code sehr einfach macht!  In diesem Fall hilft uns das Schlüsselwort <code>ref</code> am meisten, wodurch wir einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wert als Referenz übergeben können</a> .  Wir haben <code>ref</code> seit einiger Zeit in Methodenaufrufen verwendet, aber in letzter Zeit wurden Anstrengungen unternommen, um <code>ref</code> anderer Stelle aufzulösen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ref return und ref local</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serie C # 7, Teil 9: Ref. Struktur</a> </li></ul><br>  <i>Manchmal</i> verbessert die Verwendung von <code>ref</code> <i>manchmal</i> die Leistung, da die Struktur dann nicht kopiert werden muss. Weitere Informationen finden Sie in den Benchmarks im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag von Adam Stinix</a> und unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Leistung fängt Ref-Einheimische und Ref-Rückgaben in C # ein“</a> . <br><br>  Das Wichtigste ist jedoch, dass ein solches Skript unserem C # -Port das gleiche Verhalten wie der C ++ - Quellcode verleiht.  Obwohl ich darauf hinweisen möchte, dass die sogenannten "verwalteten Links" nicht ganz mit "Zeigern" identisch sind, können Sie mit ihnen keine Arithmetik durchführen. Weitere Informationen hierzu finden Sie hier: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ref return ist kein Zeiger</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwaltete Zeiger</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Links sind keine Adressen</a> </li></ul><br><h2>  Leistung </h2><br>  Somit war der Code gut portiert, aber auch die Leistung ist wichtig.  Besonders im Ray Tracer, der den Frame für mehrere Minuten berechnen kann.  C ++ - Code enthält die Variable <code>sampleCount</code> , die die endgültige Bildqualität steuert, mit <code>sampleCount = 2</code> wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/17e/e2d/10a17ee2df5205f5fa8bd138693bc4a6.png"><br><br>  Offensichtlich nicht sehr realistisch! <br><br>  Aber wenn Sie auf <code>sampleCount = 2048</code> , sieht alles <i>viel</i> besser aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/304/4b2/14d/3044b214da9027dd34dcbc19fdc75d2f.png"><br><br>  Das Starten mit <code>sampleCount = 2048</code> ist jedoch <b>sehr</b> zeitaufwändig, sodass alle anderen Läufe mit einem Wert von <code>2</code> werden, um mindestens eine Minute zu erreichen.  Das Ändern von <code>sampleCount</code> wirkt sich nur auf die Anzahl der Iterationen der äußersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeschleife</a> aus. Eine Erläuterung finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Übersicht</a> . <br><br><h3>  Ergebnisse nach einem "naiven" Leitungsport </h3><br>  Um C ++ und C # inhaltlich zu vergleichen, habe ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitfenster-</a> Tool verwendet. Dies ist der Port des Befehls <code>time</code> unix.  Die ersten Ergebnisse sahen folgendermaßen aus: <br><br><table><thead><tr><th></th><th>  C ++ (VS 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) </th></tr></thead><tbody><tr><td>  Zeit (Sek.) </td><td>  47,40 </td><td>  80.14 </td><td>  78.02 </td></tr><tr><td>  Im Kern (Sek.) </td><td>  0,14 (0,3%) </td><td>  0,72 (0,9%) </td><td>  0,63 (0,8%) </td></tr><tr><td>  Im User-Space (Sek.) </td><td>  43,86 (92,5%) </td><td>  73,06 (91,2%) </td><td>  70,66 (90,6%) </td></tr><tr><td>  Anzahl der Seitenfehlerfehler </td><td>  1143 </td><td>  4818 </td><td>  5945 </td></tr><tr><td>  Arbeitssatz (KB) </td><td>  4232 </td><td>  13 624 </td><td>  17 052 </td></tr><tr><td>  Extrudierter Speicher (KB) </td><td>  95 </td><td>  172 </td><td>  154 </td></tr><tr><td>  Nicht präventives Gedächtnis </td><td>  7 </td><td>  14 </td><td>  16 </td></tr><tr><td>  Datei tauschen (KB) </td><td>  1460 </td><td>  10 936 </td><td>  11 024 </td></tr></tbody></table><br>  Zunächst sehen wir, dass C # -Code etwas langsamer als die C ++ - Version ist, aber besser wird (siehe unten). <br><br>  Aber lassen Sie uns zuerst sehen, was die .NET-JIT auch mit diesem „naiven“ zeilenweisen Port mit uns macht.  Erstens gelingt es gut, kleinere Hilfsmethoden einzubetten.  Dies zeigt sich in der Ausgabe des hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inlining Analyzer-</a> Tools (grün = integriert): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cc/484/0a5/4cc4840a53f18362d3b4f3a4249fb2d5.png"></a> <br><br>  Es werden jedoch nicht alle Methoden eingebettet. Beispielsweise wird <code>QueryDatabase(..)</code> aufgrund der Komplexität übersprungen: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9e2/648/da2/9e2648da2a8ae7df5f94ceb77771c0ab.png"></a> <br><br>  Eine weitere JIT-Compilerfunktion (.NET Just-In-Time) ist die Konvertierung bestimmter Methodenaufrufe in die entsprechenden CPU-Anweisungen.  Wir können dies in Aktion mit der <code>sqrt</code> Shell-Funktion sehen. Hier ist der C # <code>Math.Sqrt</code> (beachten Sie den Aufruf von <code>Math.Sqrt</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); }</span></span></code> </pre> <br>  Und hier ist der Assembler-Code, den die .NET-JIT generiert: Es gibt keinen Aufruf von <code>Math.Sqrt</code> und die Prozessoranweisung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vsqrtsd wird verwendet</a> : <br><br><pre> <code class="plaintext hljs">; Assembly listing for method Program:sqrtf(float):float ; Emitting BLENDED_CODE for X64 CPU with AVX - Windows ; Tier-1 compilation ; optimized code ; rsp based frame ; partially interruptible ; Final local variable assignments ; ; V00 arg0 [V00,T00] ( 3, 3 ) float -&gt; mm0 ;# V01 OutArgs [V01 ] ( 1, 1 ) lclBlk ( 0) [rsp+0x00] "OutgoingArgSpace" ; ; Lcl frame size = 0 G_M8216_IG01: vzeroupper G_M8216_IG02: vcvtss2sd xmm0, xmm0 vsqrtsd xmm0, xmm0 vcvtsd2ss xmm0, xmm0 G_M8216_IG03: ret ; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float ; ============================================================</code> </pre> <br>  (Um dieses Problem zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beheben</a> , befolgen Sie <a href="">diese Anweisungen</a> , verwenden Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VS2019-Add-On "Disasmo"</a> oder schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SharpLab.io an.</a> ) <br><br>  Diese Ersetzungen werden auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intrinsics bezeichnet</a> . Im folgenden Code können wir sehen, wie die JIT sie generiert.  Dieses Snippet zeigt die Zuordnung nur für <code>AMD64</code> , aber die JIT zielt auch auf <code>X86</code> , <code>ARM</code> und <code>ARM64</code> , die vollständige Methode <a href="">hier</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Compiler::IsTargetIntrinsic(CorInfoIntrinsics intrinsicId) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND)) switch (intrinsicId) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1 // instructions to directly compute round/ceiling/floor. // // </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> Because the x86 backend only targets SSE for floating-point code, // it does not treat Sine, Cosine, or Round as intrinsics (JIT32 // implemented those intrinsics as x87 instructions). If this poses // a CQ problem, it may be necessary to change the implementation of // the helper calls to decrease call overhead or switch back to the // x87 instructions. This is tracked by #7097. case CORINFO_INTRINSIC_Sqrt: case CORINFO_INTRINSIC_Abs: return true; case CORINFO_INTRINSIC_Round: case CORINFO_INTRINSIC_Ceiling: case CORINFO_INTRINSIC_Floor: return compSupports(InstructionSet_SSE41); default: return false; } ... }</span></span></span></span></code> </pre> <br>  Wie Sie sehen können, sind einige Methoden wie <code>Sqrt</code> und <code>Abs</code> implementiert, während andere C ++ - Laufzeitfunktionen verwenden, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">powf</a> . <br><br>  Dieser gesamte Prozess wird im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Wie wird Math.Pow () in .NET Framework implementiert?“</a> Sehr gut erläutert.  kann es auch in der CoreCLR-Quelle gesehen werden: <br><br><ul><li>  Implementierung von <code><a href="">COMSingle::Pow</a></code> , <code><a href="">COMSingle::Pow</a></code> der Methode, die ausgeführt wird, wenn <code>MathF.Pow(..)</code> aus C # -Code aufgerufen wird <br></li><li>  Abbildung in der <a href="">Implementierung der C-Laufzeitmethode</a> <br></li><li>  Plattformübergreifende Version <a href="">der powf-Implementierung</a> , die im gesamten Betriebssystem das gleiche Verhalten bietet </li></ul><br><h3>  Ergebnisse nach einfachen Leistungsverbesserungen </h3><br>  Ich frage mich, ob Sie den naiven Line-by-Port-Port sofort verbessern können.  Nach einigen Profilen habe ich zwei wichtige Änderungen vorgenommen: <br><br><ul><li>  Inline-Array-Initialisierung entfernen </li><li>  Ersetzen der Funktionen von <code>Math.XXX(..)</code> durch Analoga von <code>MathF.()</code> </li></ul><br>  Diese Änderungen werden nachstehend ausführlicher erläutert. <br><br><h4>  Inline-Array-Initialisierung entfernen </h4><br>  Weitere Informationen dazu, warum dies erforderlich ist, finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser hervorragenden Antwort</a> zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stapelüberlauf</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrei Akinshin</a> sowie in Benchmarks und Assembler-Code.  Er kommt zu folgendem Schluss: <br><br><blockquote>  <b>Fazit</b> <br><br><ul><li>  <i><b>Zwischenspeichert .NET fest codierte lokale Arrays?</b></i>  Wie diejenigen, die den Roslyn-Compiler in Metadaten einfügen. </li><li>  <i><b>In diesem Fall wird es Overhead geben?</b></i>  Leider ja: Bei jedem Aufruf kopiert JIT den Inhalt des Arrays aus den Metadaten, was im Vergleich zu einem statischen Array zusätzliche Zeit in Anspruch nimmt.  Die Laufzeit wählt auch Objekte aus und erzeugt Datenverkehr im Speicher. </li><li>  <i><b>Muss man sich darüber Sorgen machen?</b></i>  Möglicherweise.  Wenn dies eine heiße Methode ist und Sie ein gutes Leistungsniveau erreichen möchten, müssen Sie ein statisches Array verwenden.  Wenn dies eine kalte Methode ist, die die Anwendungsleistung nicht beeinträchtigt, müssen Sie wahrscheinlich „guten“ Quellcode schreiben und das Array im Methodenbereich platzieren. </li></ul></blockquote><br>  Sie können die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Diff</a> vorgenommenen Änderungen sehen. <br><br><h4>  Verwenden von MathF-Funktionen anstelle von Math </h4><br>  Zweitens und vor allem habe ich die Leistung erheblich verbessert, indem ich die folgenden Änderungen vorgenommen habe: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / MathF.Sqrt(q % q)); } #else public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); } #endif</span></span></span></span></code> </pre> <br>  Ab .NET Standard 2.1 gibt es konkrete Implementierungen gängiger mathematischer <code>float</code> Funktionen.  Sie befinden sich in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System.MathF-</a> Klasse.  Weitere Informationen zu dieser API und ihrer Implementierung finden Sie hier: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neue mathematische API mit einfacher Genauigkeit</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fügen Sie mathematische Funktionen mit einfacher Genauigkeit hinzu</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereitstellung einer Unit-Test-Suite für neue mathematische APIs mit einfacher Genauigkeit</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System.Math und System.MathF sollten in verwaltetem Code implementiert werden, nicht als FCALL für die C-Laufzeit</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschieben von Math.Abs ​​(double) und Math.Abs ​​(float) zur Implementierung in verwaltetem Code</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Design und Prozess zum Hinzufügen plattformspezifischer eingebetteter Tools zu .NET</a> </li></ul><br>  Nach diesen Änderungen wurde der Unterschied in der C # - und C ++ - Codeleistung auf etwa 10% reduziert: <br><br><table><thead><tr><th></th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC AUS </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  Zeit (Sek.) </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td>  Im Kern (Sek.) </td><td>  0,05 (0,1%) </td><td>  0,06 (0,1%) </td><td>  0,14 (0,3%) </td><td>  0,13 (0,3%) </td></tr><tr><td>  Im User-Space (Sek.) </td><td>  41,19 (99,5%) </td><td>  58,34 (99,1%) </td><td>  44,72 (97,1%) </td><td>  44,03 (99,3%) </td></tr><tr><td>  Anzahl der Seitenfehlerfehler </td><td>  1119 </td><td>  4749 </td><td>  5776 </td><td>  5661 </td></tr><tr><td>  Arbeitssatz (KB) </td><td>  4136 </td><td>  13.440 </td><td>  16.788 </td><td>  16.652 </td></tr><tr><td>  Extrudierter Speicher (KB) </td><td>  89 </td><td>  172 </td><td>  150 </td><td>  150 </td></tr><tr><td>  Nicht präventives Gedächtnis </td><td>  7 </td><td>  13 </td><td>  16 </td><td>  16 </td></tr><tr><td>  Datei tauschen (KB) </td><td>  1428 </td><td>  10 904 </td><td>  10 960 </td><td>  11 044 </td></tr></tbody></table><br>  TC - Multilevel-Kompilierung, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tiered Compilation</a> ( <i>ich nehme an</i> , <i>dass</i> sie in .NET Core 3.0 standardmäßig aktiviert ist) <br><br>  Der Vollständigkeit halber sind hier die Ergebnisse mehrerer Läufe: <br><br><table><thead><tr><th>  Ausführen </th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC AUS </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  TestRun-01 </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td>  TestRun-02 </td><td>  41.19 </td><td>  57,65 </td><td>  46.23 </td><td>  45,96 </td></tr><tr><td>  TestRun-03 </td><td>  42.17 </td><td>  62,64 </td><td>  46,22 </td><td>  48,73 </td></tr></tbody></table><br>  <b>Hinweis</b> : Der Unterschied zwischen .NET Core und .NET Framework ist auf das Fehlen der MathF-API in .NET Framework 4.7.2 zurückzuführen. Weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Support-Ticket .Net Framework (4.8?). Netstandard 2.1</a> . <br><br><h1>  Weitere Steigerung der Produktivität </h1><br>  Ich bin sicher, dass der Code noch verbessert werden kann! <br><br>  Wenn Sie den Leistungsunterschied beheben möchten, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier den C # -Code</a> .  Zum Vergleich können Sie C ++ - Assembler-Code über den hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler Explorer-</a> Dienst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigen</a> . <br><br>  Wenn dies hilfreich ist, finden Sie hier die Visual Studio-Profilerausgabe mit einer Anzeige "Hot Path" (nach den oben beschriebenen Leistungsverbesserungen): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b78/3df/2e6/b783df2e692b62f492b78c8e7affcbf4.png"></a> <br><br><h1>  Ist C # eine einfache Sprache? </h1><br>  Oder genauer: <br><br><blockquote>  <b><b>Welche Sprachfunktionen der C # / F # / VB.NET- oder BCL / Runtime-Funktionalität bedeuten "Low Level" * -Programmierung?</b></b> </blockquote><br>  * Ja, ich verstehe, dass "niedriges Niveau" ein subjektiver Begriff ist. <br><br>  <b>Hinweis:</b> Jeder C # -Entwickler hat seine eigene Vorstellung von der „niedrigen Ebene“. Diese Funktionen werden von C ++ - oder Rust-Programmierern als selbstverständlich angesehen. <br><br>  Hier ist die Liste, die ich gemacht habe: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ref kehrt zurück und ref Einheimische</a> <br><ul><li>  „Übergeben und Zurückgeben als Referenz, um das Kopieren großer Strukturen zu vermeiden.  Sichere Typen und Speicher können sogar <b>schneller</b> als unsicher sein! “ </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsicherer Code in .NET</a> <br><ul><li>  „Die in den vorherigen Kapiteln definierte C # -Sprachsprache unterscheidet sich stark von C und C ++, da ihr Zeiger als Datentyp fehlen.  Stattdessen bietet C # Links und die Möglichkeit, Objekte zu erstellen, die vom Garbage Collector verwaltet werden.  Dieses Design in Kombination mit anderen Funktionen macht C # zu einer viel sichereren Sprache als C oder C ++. “ </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwaltete Zeiger in .NET</a> <br><ul><li>  „In der CLR gibt es einen anderen Zeigertyp - einen verwalteten Zeiger.  Es kann als allgemeinere Art von Verknüpfung definiert werden, die auf andere Orte und nicht nur auf den Anfang des Objekts verweisen kann. “ </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C # 7-Serie, Teil 10: Span &lt;T&gt; und Universal Memory Management</a> <br><ul><li>  „System.Span &lt;T&gt; ist nur ein Stapeltyp ( <code>ref struct</code> ), der alle Speicherzugriffsmuster umschließt. Es ist ein Typ für den universellen kontinuierlichen Speicherzugriff.  Wir können uns eine Span-Implementierung mit einer Dummy-Referenz und einer Länge vorstellen, die alle drei Arten des Speicherzugriffs akzeptiert. " </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kompatibilität („C # -Programmierhandbuch“)</a> <br><ul><li>  "Das .NET Framework bietet Interoperabilität mit nicht verwaltetem Code über Plattformaufrufdienste, den <code>System.Runtime.InteropServices</code> , die C ++ - Kompatibilität und die COM-Kompatibilität (COM-Interoperabilität)." </li></ul></li></ul><br>  Ich habe auch auf Twitter geweint und viel mehr Optionen für die Aufnahme in die Liste erhalten: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ben Adams</a> : „Integrierte Tools für Plattformen (CPU-Anweisungen)“ <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mark Gravell</a> : „SIMD via Vector (was gut zu Span <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">passt</a> ) ist * ziemlich * niedrig;  .NET Core sollte (bald?) Direkte CPU-Embedded-Tools für die explizitere Verwendung spezifischer CPU-Anweisungen anbieten. “ <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mark Gravell</a> : „Leistungsstarke JIT: Dinge wie die Entfernungsentfernung für Arrays / Intervalle sowie die Verwendung von Per-Struct-T-Regeln zum Entfernen großer Codeteile, von denen JIT sicher weiß, dass sie für dieses T oder für Ihr spezifisches T nicht verfügbar sind CPU (BitConverter.IsLittleEndian, Vector.IsHardwareAccelerated usw.) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kevin Jones</a> : „Ich würde besonders die Klassen <code>MemoryMarshal</code> und <code>Unsafe</code> sowie einige andere Dinge in den <code>System.Runtime.CompilerServices</code> “ <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theodoros Chatsigiannakis</a> : „Sie können auch <code>__makeref</code> und den Rest <code>__makeref</code> “ <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Damageboy</a> : "Die Fähigkeit, dynamisch Code zu generieren, der genau der erwarteten Eingabe entspricht, da letztere nur zur Laufzeit bekannt ist und sich regelmäßig ändern kann?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Robert Hacken</a> : "Dynamische Emission von IL" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victor Baybekov</a> : „Stackalloc wurde nicht erwähnt.  Es ist auch möglich, reines IL zu schreiben (nicht dynamisch, daher wird es bei einem Funktionsaufruf gespeichert), z. B. zwischengespeicherte <code>ldftn</code> und sie über <code>calli</code> aufzurufen.  In VS2017 gibt es eine Projektvorlage, die dies trivial macht, indem die Methoden extern + MethodImplOptions.ForwardRef + ilasm.ex »neu geschrieben werden.» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victor Baybekov</a> : „MethodImplOptions.AggressiveInlining aktiviert auch die Low-Level-Programmierung in dem Sinne, dass Sie High-Level-Code mit vielen kleinen Methoden schreiben und dennoch das Verhalten von JIT steuern können, um ein optimiertes Ergebnis zu erzielen.  Andernfalls Kopieren und Einfügen von Hunderten von LOC-Methoden ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ben Adams</a> : "Verwenden Sie die gleichen Aufrufkonventionen (ABI) wie auf der Basisplattform und p / ruft zur Interaktion auf?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victor Baibekov</a> : „Da Sie #fsharp erwähnt haben, hat es ein <code>inline</code> , das auf IL-Ebene für JIT funktioniert. Daher wurde es auf Sprachebene als wichtig angesehen.  C # Dies ist (bisher) nicht genug für Lambdas, bei denen es sich immer um virtuelle Anrufe handelt, und Problemumgehungen sind oft seltsam (begrenzte Generika). " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexandre Mutel</a> : „Neue eingebettete SIMD, Nachbearbeitung der unsicheren Dienstprogrammklasse / IL (z. B. benutzerdefiniert, Fody usw.).  Für C # 8.0 kommende Funktionszeiger ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexandre Mutel</a> : „In Bezug auf IL unterstützt F # IL direkt in einer Sprache, zum Beispiel.“ <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OmariO</a> : „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BinaryPrimitives</a> .  Niedriges Niveau, aber sicher " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koji Matsui</a> : „Wie wäre es mit Ihrem eigenen eingebauten Assembler?  Es ist sowohl für das Toolkit als auch für die Laufzeit schwierig, kann jedoch die aktuelle p / invoke-Lösung ersetzen und gegebenenfalls den eingebetteten Code implementieren. “ <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frank A. Kruger</a> : "Ldobj, stobj, initobj, initblk, cpyblk" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conrad Coconut</a> : „Vielleicht lokalen Speicher streamen?  Puffer mit fester Größe?  Sie sollten wahrscheinlich nicht verwaltete Einschränkungen und blittable Typen erwähnen :) ” <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sebastiano Mandala</a> : „Nur eine kleine Ergänzung zu allem, was gesagt wurde: Wie wäre es mit etwas Einfachem wie dem Anordnen von Strukturen und wie das Füllen und Ausrichten von Speicher- und Ordnungsfeldern die Cache-Leistung beeinflussen kann?  Das muss ich selbst erforschen. “ <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nino Floris</a> : "Konstanten, die über Readonlyspan, Stackalloc, Finalizer, WeakReference, offene Delegaten, MethodImplOptions, MemoryBarriers, TypedReference, Varargs, SIMD und Unsafe.AsRef eingebettet sind, können die Strukturtypen genau nach dem Layout festlegen (das für TaskAwaiter und seine Version verwendet wird)." </li></ul><br>  <b>Am Ende würde ich also sagen, dass C # es Ihnen sicherlich ermöglicht, Code zu schreiben, der wie C ++ aussieht, und in Kombination mit den Laufzeit- und Basisklassenbibliotheken viele Funktionen auf niedriger Ebene bietet.</b> <br><br><h1>  Weiterführende Literatur </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlagen für leistungsstarkes C #.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Federico Andres Lois</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungsquiz Nr. 6 - Chinesisch-Englisch Wörterbuch</a> (seit 2005 kämpfen zwei Microsoft-Blogger im Kampf um die C ++ - Leistung gegen C #) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Performance Quiz # 6 - Fazit, Weltraumforschung</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie viel schneller ist C ++ als C #?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierung von verwaltetem C # und nativem C ++ - Code</a> (2005) </li></ul><br>  Unity Burst Compiler: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie Unity (eine Teilmenge) von C # so schnell wie C ++ machte</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unity Burst Compiler: Einfache Leistungsoptimierung</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daily Pathtracer, Teil 3: C # und Unity Burst</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++, C # und Unity</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tauchen Sie ein in den Burst-Compiler - Unite LA</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443804/">https://habr.com/ru/post/de443804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443788/index.html">Die Grundlagen des statischen Routings in Mikrotik RouterOS</a></li>
<li><a href="../de443790/index.html">Fehler des Überlebenden</a></li>
<li><a href="../de443792/index.html">Typische Fehler bei der Arbeit mit PostgreSQL. Teil 2</a></li>
<li><a href="../de443794/index.html">Die Hauptrichtungen für IT-Startups im Bereich Immobilienverkäufe</a></li>
<li><a href="../de443798/index.html">Zotero-Hacks: unbegrenzter synchronisierter Speicher und reibungslose Verwendung mit rmarkdown</a></li>
<li><a href="../de443808/index.html">Analyse von Mädchen mit geringer sozialer Verantwortung (mit Power BI, Qlik Sense, Tableau beauftragt)</a></li>
<li><a href="../de443810/index.html">Wie viel verdienen Entwickler unterschiedlicher Qualifikationen, 2018?</a></li>
<li><a href="../de443812/index.html">So implementieren Sie eine Programmiersprache in JavaScript. Teil 2: Dolmetscher</a></li>
<li><a href="../de443814/index.html">Geben ist mein "ehemaliges Geschäft"</a></li>
<li><a href="../de443816/index.html">Das Kommunikationsministerium besteht auf einem einzigen 5G-Betreiber</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>