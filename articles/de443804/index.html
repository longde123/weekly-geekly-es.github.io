<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò∫ ü§õüèº üë®üèæ‚Äçüåæ C # ist eine einfache Sprache? üç≤ ü§´ üß†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich bin ein gro√üer Fan von allem, was Fabien Sanglard tut, ich mag seinen Blog und ich lese beide B√ºcher von vorne bis hinten (beschrieben in einem k√º...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # ist eine einfache Sprache?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443804/">  Ich bin ein gro√üer Fan von allem, was <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fabien Sanglard</a> tut, ich mag seinen Blog und ich lese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beide</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B√ºcher von</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorne bis hinten</a> (beschrieben in einem k√ºrzlich erschienenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hansleminutes-Podcast</a> ). <br><br>  Fabien hat k√ºrzlich einen gro√üartigen Beitrag geschrieben, in dem er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen winzigen</a> Raytracer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entschl√ºsselt</a> , den Code deobfusciert und die Mathematik fantastisch sch√∂n erkl√§rt hat.  Ich empfehle wirklich, sich die Zeit zu nehmen, um dies zu lesen! <br><br>  Aber ich habe mich gefragt, <i><b>ob es m√∂glich ist, diesen C ++ - Code nach C # zu portieren</b></i> .  Da ich in letzter Zeit in meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptjob</a> ziemlich viel C ++ geschrieben habe, dachte ich, ich k√∂nnte es versuchen. <br><br>  Aber was noch wichtiger ist, ich wollte eine bessere Vorstellung davon bekommen, <b>ob C # eine einfache Sprache ist</b> . <br><a name="habracut"></a><br>  Eine etwas andere, aber verwandte Frage: Inwieweit ist C # f√ºr die "Systemprogrammierung" geeignet?  Zu diesem Thema empfehle ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Joe Duffys hervorragenden Beitrag aus dem Jahr 2013</a> . <br><br><h1>  Leitungsport </h1><br>  Ich begann damit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deobfuscierten C ++ - Code</a> einfach Zeile f√ºr Zeile nach C # zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">portieren</a> .  Es war ziemlich einfach: Es scheint, dass die Wahrheit immer noch gesagt wird, dass C # C ++++ ist !!! <br><br>  Das Beispiel zeigt die Hauptdatenstruktur - 'Vektor', hier ein Vergleich, C ++ links, C # rechts: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f14/ecc/cbd/f14ecccbd0091486caf57fc43fb2ac7f.png"></a> <br><br>  Es gibt also einige syntaktische Unterschiede, aber da Sie mit .NET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ihre eigenen Werttypen</a> definieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√∂nnen</a> , konnte ich dieselbe Funktionalit√§t erhalten.  Dies ist wichtig, da die Behandlung von "Vektor" als Struktur bedeutet, dass wir eine bessere "Datenlokalit√§t" erzielen k√∂nnen und den .NET-Garbage Collector nicht einbeziehen m√ºssen, da die Daten auf den Stapel √ºbertragen werden (ja, ich wei√ü, dass dies ein Implementierungsdetail ist). <br><br>  Weitere Informationen zu <code>structs</code> oder ‚Äû <code>structs</code> ‚Äú in .NET finden Sie hier: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heap versus Stack, Werttyp versus Referenztyp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Werttypen versus Referenztypen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicher in .NET: wohin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Wahrheit √ºber Werttypen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Stack ist ein Implementierungsdetail, Teil eins</a> </li></ul><br>  Insbesondere in Eric Lipperts letztem Beitrag finden wir ein so n√ºtzliches Zitat, dass deutlich wird, was ‚ÄûWerttypen‚Äú wirklich sind: <br><br><blockquote>  Das Wichtigste an den Wertetypen sind nat√ºrlich <b>nicht die Implementierungsdetails, <i>wie sie zugeordnet werden</i></b> , sondern die <i>urspr√ºngliche semantische Bedeutung des</i> ‚ÄûWertetyps‚Äú, <b>n√§mlich, dass er <i>immer ‚Äûnach Wert‚Äú kopiert wird</i></b> .  Wenn Zuordnungsinformationen wichtig w√§ren, w√ºrden wir sie "Heap-Typen" und "Stack-Typen" nennen.  Aber in den meisten F√§llen spielt es keine Rolle.  Meistens ist die Semantik des Kopierens und Identifizierens relevant. </blockquote><br>  Nun wollen wir sehen, wie einige andere Methoden im Vergleich aussehen (wieder C ++ links, C # rechts), zuerst <code>RayTracing(..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d0/3c5/277/4d03c5277ffa4f1e73462dab4edc7dd0.png"></a> <br><br>  Dann <code>QueryDatabase (..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2fc/c17/839/2fcc17839a00bfc619e14c7323e28f52.png"></a> <br><br>  (In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fabians Beitrag finden Sie</a> eine Erkl√§rung, was diese beiden Funktionen bewirken.) <br><br>  Tatsache ist jedoch, dass C # das Schreiben von C ++ - Code sehr einfach macht!  In diesem Fall hilft uns das Schl√ºsselwort <code>ref</code> am meisten, wodurch wir einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wert als Referenz √ºbergeben k√∂nnen</a> .  Wir haben <code>ref</code> seit einiger Zeit in Methodenaufrufen verwendet, aber in letzter Zeit wurden Anstrengungen unternommen, um <code>ref</code> anderer Stelle aufzul√∂sen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ref return und ref local</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serie C # 7, Teil 9: Ref. Struktur</a> </li></ul><br>  <i>Manchmal</i> verbessert die Verwendung von <code>ref</code> <i>manchmal</i> die Leistung, da die Struktur dann nicht kopiert werden muss. Weitere Informationen finden Sie in den Benchmarks im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag von Adam Stinix</a> und unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûLeistung f√§ngt Ref-Einheimische und Ref-R√ºckgaben in C # ein‚Äú</a> . <br><br>  Das Wichtigste ist jedoch, dass ein solches Skript unserem C # -Port das gleiche Verhalten wie der C ++ - Quellcode verleiht.  Obwohl ich darauf hinweisen m√∂chte, dass die sogenannten "verwalteten Links" nicht ganz mit "Zeigern" identisch sind, k√∂nnen Sie mit ihnen keine Arithmetik durchf√ºhren. Weitere Informationen hierzu finden Sie hier: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ref return ist kein Zeiger</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwaltete Zeiger</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Links sind keine Adressen</a> </li></ul><br><h2>  Leistung </h2><br>  Somit war der Code gut portiert, aber auch die Leistung ist wichtig.  Besonders im Ray Tracer, der den Frame f√ºr mehrere Minuten berechnen kann.  C ++ - Code enth√§lt die Variable <code>sampleCount</code> , die die endg√ºltige Bildqualit√§t steuert, mit <code>sampleCount = 2</code> wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/17e/e2d/10a17ee2df5205f5fa8bd138693bc4a6.png"><br><br>  Offensichtlich nicht sehr realistisch! <br><br>  Aber wenn Sie auf <code>sampleCount = 2048</code> , sieht alles <i>viel</i> besser aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/304/4b2/14d/3044b214da9027dd34dcbc19fdc75d2f.png"><br><br>  Das Starten mit <code>sampleCount = 2048</code> ist jedoch <b>sehr</b> zeitaufw√§ndig, sodass alle anderen L√§ufe mit einem Wert von <code>2</code> werden, um mindestens eine Minute zu erreichen.  Das √Ñndern von <code>sampleCount</code> wirkt sich nur auf die Anzahl der Iterationen der √§u√üersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeschleife</a> aus. Eine Erl√§uterung finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser √úbersicht</a> . <br><br><h3>  Ergebnisse nach einem "naiven" Leitungsport </h3><br>  Um C ++ und C # inhaltlich zu vergleichen, habe ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitfenster-</a> Tool verwendet. Dies ist der Port des Befehls <code>time</code> unix.  Die ersten Ergebnisse sahen folgenderma√üen aus: <br><br><table><thead><tr><th></th><th>  C ++ (VS 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) </th></tr></thead><tbody><tr><td>  Zeit (Sek.) </td><td>  47,40 </td><td>  80.14 </td><td>  78.02 </td></tr><tr><td>  Im Kern (Sek.) </td><td>  0,14 (0,3%) </td><td>  0,72 (0,9%) </td><td>  0,63 (0,8%) </td></tr><tr><td>  Im User-Space (Sek.) </td><td>  43,86 (92,5%) </td><td>  73,06 (91,2%) </td><td>  70,66 (90,6%) </td></tr><tr><td>  Anzahl der Seitenfehlerfehler </td><td>  1143 </td><td>  4818 </td><td>  5945 </td></tr><tr><td>  Arbeitssatz (KB) </td><td>  4232 </td><td>  13 624 </td><td>  17 052 </td></tr><tr><td>  Extrudierter Speicher (KB) </td><td>  95 </td><td>  172 </td><td>  154 </td></tr><tr><td>  Nicht pr√§ventives Ged√§chtnis </td><td>  7 </td><td>  14 </td><td>  16 </td></tr><tr><td>  Datei tauschen (KB) </td><td>  1460 </td><td>  10 936 </td><td>  11 024 </td></tr></tbody></table><br>  Zun√§chst sehen wir, dass C # -Code etwas langsamer als die C ++ - Version ist, aber besser wird (siehe unten). <br><br>  Aber lassen Sie uns zuerst sehen, was die .NET-JIT auch mit diesem ‚Äûnaiven‚Äú zeilenweisen Port mit uns macht.  Erstens gelingt es gut, kleinere Hilfsmethoden einzubetten.  Dies zeigt sich in der Ausgabe des hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inlining Analyzer-</a> Tools (gr√ºn = integriert): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cc/484/0a5/4cc4840a53f18362d3b4f3a4249fb2d5.png"></a> <br><br>  Es werden jedoch nicht alle Methoden eingebettet. Beispielsweise wird <code>QueryDatabase(..)</code> aufgrund der Komplexit√§t √ºbersprungen: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9e2/648/da2/9e2648da2a8ae7df5f94ceb77771c0ab.png"></a> <br><br>  Eine weitere JIT-Compilerfunktion (.NET Just-In-Time) ist die Konvertierung bestimmter Methodenaufrufe in die entsprechenden CPU-Anweisungen.  Wir k√∂nnen dies in Aktion mit der <code>sqrt</code> Shell-Funktion sehen. Hier ist der C # <code>Math.Sqrt</code> (beachten Sie den Aufruf von <code>Math.Sqrt</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); }</span></span></code> </pre> <br>  Und hier ist der Assembler-Code, den die .NET-JIT generiert: Es gibt keinen Aufruf von <code>Math.Sqrt</code> und die Prozessoranweisung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vsqrtsd wird verwendet</a> : <br><br><pre> <code class="plaintext hljs">; Assembly listing for method Program:sqrtf(float):float ; Emitting BLENDED_CODE for X64 CPU with AVX - Windows ; Tier-1 compilation ; optimized code ; rsp based frame ; partially interruptible ; Final local variable assignments ; ; V00 arg0 [V00,T00] ( 3, 3 ) float -&gt; mm0 ;# V01 OutArgs [V01 ] ( 1, 1 ) lclBlk ( 0) [rsp+0x00] "OutgoingArgSpace" ; ; Lcl frame size = 0 G_M8216_IG01: vzeroupper G_M8216_IG02: vcvtss2sd xmm0, xmm0 vsqrtsd xmm0, xmm0 vcvtsd2ss xmm0, xmm0 G_M8216_IG03: ret ; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float ; ============================================================</code> </pre> <br>  (Um dieses Problem zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beheben</a> , befolgen Sie <a href="">diese Anweisungen</a> , verwenden Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VS2019-Add-On "Disasmo"</a> oder schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SharpLab.io an.</a> ) <br><br>  Diese Ersetzungen werden auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intrinsics bezeichnet</a> . Im folgenden Code k√∂nnen wir sehen, wie die JIT sie generiert.  Dieses Snippet zeigt die Zuordnung nur f√ºr <code>AMD64</code> , aber die JIT zielt auch auf <code>X86</code> , <code>ARM</code> und <code>ARM64</code> , die vollst√§ndige Methode <a href="">hier</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Compiler::IsTargetIntrinsic(CorInfoIntrinsics intrinsicId) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND)) switch (intrinsicId) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1 // instructions to directly compute round/ceiling/floor. // // </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> Because the x86 backend only targets SSE for floating-point code, // it does not treat Sine, Cosine, or Round as intrinsics (JIT32 // implemented those intrinsics as x87 instructions). If this poses // a CQ problem, it may be necessary to change the implementation of // the helper calls to decrease call overhead or switch back to the // x87 instructions. This is tracked by #7097. case CORINFO_INTRINSIC_Sqrt: case CORINFO_INTRINSIC_Abs: return true; case CORINFO_INTRINSIC_Round: case CORINFO_INTRINSIC_Ceiling: case CORINFO_INTRINSIC_Floor: return compSupports(InstructionSet_SSE41); default: return false; } ... }</span></span></span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, sind einige Methoden wie <code>Sqrt</code> und <code>Abs</code> implementiert, w√§hrend andere C ++ - Laufzeitfunktionen verwenden, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">powf</a> . <br><br>  Dieser gesamte Prozess wird im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûWie wird Math.Pow () in .NET Framework implementiert?‚Äú</a> Sehr gut erl√§utert.  kann es auch in der CoreCLR-Quelle gesehen werden: <br><br><ul><li>  Implementierung von <code><a href="">COMSingle::Pow</a></code> , <code><a href="">COMSingle::Pow</a></code> der Methode, die ausgef√ºhrt wird, wenn <code>MathF.Pow(..)</code> aus C # -Code aufgerufen wird <br></li><li>  Abbildung in der <a href="">Implementierung der C-Laufzeitmethode</a> <br></li><li>  Plattform√ºbergreifende Version <a href="">der powf-Implementierung</a> , die im gesamten Betriebssystem das gleiche Verhalten bietet </li></ul><br><h3>  Ergebnisse nach einfachen Leistungsverbesserungen </h3><br>  Ich frage mich, ob Sie den naiven Line-by-Port-Port sofort verbessern k√∂nnen.  Nach einigen Profilen habe ich zwei wichtige √Ñnderungen vorgenommen: <br><br><ul><li>  Inline-Array-Initialisierung entfernen </li><li>  Ersetzen der Funktionen von <code>Math.XXX(..)</code> durch Analoga von <code>MathF.()</code> </li></ul><br>  Diese √Ñnderungen werden nachstehend ausf√ºhrlicher erl√§utert. <br><br><h4>  Inline-Array-Initialisierung entfernen </h4><br>  Weitere Informationen dazu, warum dies erforderlich ist, finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser hervorragenden Antwort</a> zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stapel√ºberlauf</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrei Akinshin</a> sowie in Benchmarks und Assembler-Code.  Er kommt zu folgendem Schluss: <br><br><blockquote>  <b>Fazit</b> <br><br><ul><li>  <i><b>Zwischenspeichert .NET fest codierte lokale Arrays?</b></i>  Wie diejenigen, die den Roslyn-Compiler in Metadaten einf√ºgen. </li><li>  <i><b>In diesem Fall wird es Overhead geben?</b></i>  Leider ja: Bei jedem Aufruf kopiert JIT den Inhalt des Arrays aus den Metadaten, was im Vergleich zu einem statischen Array zus√§tzliche Zeit in Anspruch nimmt.  Die Laufzeit w√§hlt auch Objekte aus und erzeugt Datenverkehr im Speicher. </li><li>  <i><b>Muss man sich dar√ºber Sorgen machen?</b></i>  M√∂glicherweise.  Wenn dies eine hei√üe Methode ist und Sie ein gutes Leistungsniveau erreichen m√∂chten, m√ºssen Sie ein statisches Array verwenden.  Wenn dies eine kalte Methode ist, die die Anwendungsleistung nicht beeintr√§chtigt, m√ºssen Sie wahrscheinlich ‚Äûguten‚Äú Quellcode schreiben und das Array im Methodenbereich platzieren. </li></ul></blockquote><br>  Sie k√∂nnen die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Diff</a> vorgenommenen √Ñnderungen sehen. <br><br><h4>  Verwenden von MathF-Funktionen anstelle von Math </h4><br>  Zweitens und vor allem habe ich die Leistung erheblich verbessert, indem ich die folgenden √Ñnderungen vorgenommen habe: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / MathF.Sqrt(q % q)); } #else public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); } #endif</span></span></span></span></code> </pre> <br>  Ab .NET Standard 2.1 gibt es konkrete Implementierungen g√§ngiger mathematischer <code>float</code> Funktionen.  Sie befinden sich in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System.MathF-</a> Klasse.  Weitere Informationen zu dieser API und ihrer Implementierung finden Sie hier: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neue mathematische API mit einfacher Genauigkeit</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºgen Sie mathematische Funktionen mit einfacher Genauigkeit hinzu</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereitstellung einer Unit-Test-Suite f√ºr neue mathematische APIs mit einfacher Genauigkeit</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System.Math und System.MathF sollten in verwaltetem Code implementiert werden, nicht als FCALL f√ºr die C-Laufzeit</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschieben von Math.Abs ‚Äã‚Äã(double) und Math.Abs ‚Äã‚Äã(float) zur Implementierung in verwaltetem Code</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Design und Prozess zum Hinzuf√ºgen plattformspezifischer eingebetteter Tools zu .NET</a> </li></ul><br>  Nach diesen √Ñnderungen wurde der Unterschied in der C # - und C ++ - Codeleistung auf etwa 10% reduziert: <br><br><table><thead><tr><th></th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC AUS </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  Zeit (Sek.) </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td>  Im Kern (Sek.) </td><td>  0,05 (0,1%) </td><td>  0,06 (0,1%) </td><td>  0,14 (0,3%) </td><td>  0,13 (0,3%) </td></tr><tr><td>  Im User-Space (Sek.) </td><td>  41,19 (99,5%) </td><td>  58,34 (99,1%) </td><td>  44,72 (97,1%) </td><td>  44,03 (99,3%) </td></tr><tr><td>  Anzahl der Seitenfehlerfehler </td><td>  1119 </td><td>  4749 </td><td>  5776 </td><td>  5661 </td></tr><tr><td>  Arbeitssatz (KB) </td><td>  4136 </td><td>  13.440 </td><td>  16.788 </td><td>  16.652 </td></tr><tr><td>  Extrudierter Speicher (KB) </td><td>  89 </td><td>  172 </td><td>  150 </td><td>  150 </td></tr><tr><td>  Nicht pr√§ventives Ged√§chtnis </td><td>  7 </td><td>  13 </td><td>  16 </td><td>  16 </td></tr><tr><td>  Datei tauschen (KB) </td><td>  1428 </td><td>  10 904 </td><td>  10 960 </td><td>  11 044 </td></tr></tbody></table><br>  TC - Multilevel-Kompilierung, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tiered Compilation</a> ( <i>ich nehme an</i> , <i>dass</i> sie in .NET Core 3.0 standardm√§√üig aktiviert ist) <br><br>  Der Vollst√§ndigkeit halber sind hier die Ergebnisse mehrerer L√§ufe: <br><br><table><thead><tr><th>  Ausf√ºhren </th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC AUS </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  TestRun-01 </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td>  TestRun-02 </td><td>  41.19 </td><td>  57,65 </td><td>  46.23 </td><td>  45,96 </td></tr><tr><td>  TestRun-03 </td><td>  42.17 </td><td>  62,64 </td><td>  46,22 </td><td>  48,73 </td></tr></tbody></table><br>  <b>Hinweis</b> : Der Unterschied zwischen .NET Core und .NET Framework ist auf das Fehlen der MathF-API in .NET Framework 4.7.2 zur√ºckzuf√ºhren. Weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Support-Ticket .Net Framework (4.8?). Netstandard 2.1</a> . <br><br><h1>  Weitere Steigerung der Produktivit√§t </h1><br>  Ich bin sicher, dass der Code noch verbessert werden kann! <br><br>  Wenn Sie den Leistungsunterschied beheben m√∂chten, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier den C # -Code</a> .  Zum Vergleich k√∂nnen Sie C ++ - Assembler-Code √ºber den hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler Explorer-</a> Dienst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigen</a> . <br><br>  Wenn dies hilfreich ist, finden Sie hier die Visual Studio-Profilerausgabe mit einer Anzeige "Hot Path" (nach den oben beschriebenen Leistungsverbesserungen): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b78/3df/2e6/b783df2e692b62f492b78c8e7affcbf4.png"></a> <br><br><h1>  Ist C # eine einfache Sprache? </h1><br>  Oder genauer: <br><br><blockquote>  <b><b>Welche Sprachfunktionen der C # / F # / VB.NET- oder BCL / Runtime-Funktionalit√§t bedeuten "Low Level" * -Programmierung?</b></b> </blockquote><br>  * Ja, ich verstehe, dass "niedriges Niveau" ein subjektiver Begriff ist. <br><br>  <b>Hinweis:</b> Jeder C # -Entwickler hat seine eigene Vorstellung von der ‚Äûniedrigen Ebene‚Äú. Diese Funktionen werden von C ++ - oder Rust-Programmierern als selbstverst√§ndlich angesehen. <br><br>  Hier ist die Liste, die ich gemacht habe: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ref kehrt zur√ºck und ref Einheimische</a> <br><ul><li>  ‚Äû√úbergeben und Zur√ºckgeben als Referenz, um das Kopieren gro√üer Strukturen zu vermeiden.  Sichere Typen und Speicher k√∂nnen sogar <b>schneller</b> als unsicher sein! ‚Äú </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsicherer Code in .NET</a> <br><ul><li>  ‚ÄûDie in den vorherigen Kapiteln definierte C # -Sprachsprache unterscheidet sich stark von C und C ++, da ihr Zeiger als Datentyp fehlen.  Stattdessen bietet C # Links und die M√∂glichkeit, Objekte zu erstellen, die vom Garbage Collector verwaltet werden.  Dieses Design in Kombination mit anderen Funktionen macht C # zu einer viel sichereren Sprache als C oder C ++. ‚Äú </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwaltete Zeiger in .NET</a> <br><ul><li>  ‚ÄûIn der CLR gibt es einen anderen Zeigertyp - einen verwalteten Zeiger.  Es kann als allgemeinere Art von Verkn√ºpfung definiert werden, die auf andere Orte und nicht nur auf den Anfang des Objekts verweisen kann. ‚Äú </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C # 7-Serie, Teil 10: Span &lt;T&gt; und Universal Memory Management</a> <br><ul><li>  ‚ÄûSystem.Span &lt;T&gt; ist nur ein Stapeltyp ( <code>ref struct</code> ), der alle Speicherzugriffsmuster umschlie√üt. Es ist ein Typ f√ºr den universellen kontinuierlichen Speicherzugriff.  Wir k√∂nnen uns eine Span-Implementierung mit einer Dummy-Referenz und einer L√§nge vorstellen, die alle drei Arten des Speicherzugriffs akzeptiert. " </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kompatibilit√§t (‚ÄûC # -Programmierhandbuch‚Äú)</a> <br><ul><li>  "Das .NET Framework bietet Interoperabilit√§t mit nicht verwaltetem Code √ºber Plattformaufrufdienste, den <code>System.Runtime.InteropServices</code> , die C ++ - Kompatibilit√§t und die COM-Kompatibilit√§t (COM-Interoperabilit√§t)." </li></ul></li></ul><br>  Ich habe auch auf Twitter geweint und viel mehr Optionen f√ºr die Aufnahme in die Liste erhalten: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ben Adams</a> : ‚ÄûIntegrierte Tools f√ºr Plattformen (CPU-Anweisungen)‚Äú <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mark Gravell</a> : ‚ÄûSIMD via Vector (was gut zu Span <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">passt</a> ) ist * ziemlich * niedrig;  .NET Core sollte (bald?) Direkte CPU-Embedded-Tools f√ºr die explizitere Verwendung spezifischer CPU-Anweisungen anbieten. ‚Äú <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mark Gravell</a> : ‚ÄûLeistungsstarke JIT: Dinge wie die Entfernungsentfernung f√ºr Arrays / Intervalle sowie die Verwendung von Per-Struct-T-Regeln zum Entfernen gro√üer Codeteile, von denen JIT sicher wei√ü, dass sie f√ºr dieses T oder f√ºr Ihr spezifisches T nicht verf√ºgbar sind CPU (BitConverter.IsLittleEndian, Vector.IsHardwareAccelerated usw.) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kevin Jones</a> : ‚ÄûIch w√ºrde besonders die Klassen <code>MemoryMarshal</code> und <code>Unsafe</code> sowie einige andere Dinge in den <code>System.Runtime.CompilerServices</code> ‚Äú <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theodoros Chatsigiannakis</a> : ‚ÄûSie k√∂nnen auch <code>__makeref</code> und den Rest <code>__makeref</code> ‚Äú <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Damageboy</a> : "Die F√§higkeit, dynamisch Code zu generieren, der genau der erwarteten Eingabe entspricht, da letztere nur zur Laufzeit bekannt ist und sich regelm√§√üig √§ndern kann?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Robert Hacken</a> : "Dynamische Emission von IL" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victor Baybekov</a> : ‚ÄûStackalloc wurde nicht erw√§hnt.  Es ist auch m√∂glich, reines IL zu schreiben (nicht dynamisch, daher wird es bei einem Funktionsaufruf gespeichert), z. B. zwischengespeicherte <code>ldftn</code> und sie √ºber <code>calli</code> aufzurufen.  In VS2017 gibt es eine Projektvorlage, die dies trivial macht, indem die Methoden extern + MethodImplOptions.ForwardRef + ilasm.ex ¬ªneu geschrieben werden.¬ª <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victor Baybekov</a> : ‚ÄûMethodImplOptions.AggressiveInlining aktiviert auch die Low-Level-Programmierung in dem Sinne, dass Sie High-Level-Code mit vielen kleinen Methoden schreiben und dennoch das Verhalten von JIT steuern k√∂nnen, um ein optimiertes Ergebnis zu erzielen.  Andernfalls Kopieren und Einf√ºgen von Hunderten von LOC-Methoden ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ben Adams</a> : "Verwenden Sie die gleichen Aufrufkonventionen (ABI) wie auf der Basisplattform und p / ruft zur Interaktion auf?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victor Baibekov</a> : ‚ÄûDa Sie #fsharp erw√§hnt haben, hat es ein <code>inline</code> , das auf IL-Ebene f√ºr JIT funktioniert. Daher wurde es auf Sprachebene als wichtig angesehen.  C # Dies ist (bisher) nicht genug f√ºr Lambdas, bei denen es sich immer um virtuelle Anrufe handelt, und Problemumgehungen sind oft seltsam (begrenzte Generika). " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexandre Mutel</a> : ‚ÄûNeue eingebettete SIMD, Nachbearbeitung der unsicheren Dienstprogrammklasse / IL (z. B. benutzerdefiniert, Fody usw.).  F√ºr C # 8.0 kommende Funktionszeiger ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexandre Mutel</a> : ‚ÄûIn Bezug auf IL unterst√ºtzt F # IL direkt in einer Sprache, zum Beispiel.‚Äú <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OmariO</a> : ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BinaryPrimitives</a> .  Niedriges Niveau, aber sicher " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koji Matsui</a> : ‚ÄûWie w√§re es mit Ihrem eigenen eingebauten Assembler?  Es ist sowohl f√ºr das Toolkit als auch f√ºr die Laufzeit schwierig, kann jedoch die aktuelle p / invoke-L√∂sung ersetzen und gegebenenfalls den eingebetteten Code implementieren. ‚Äú <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frank A. Kruger</a> : "Ldobj, stobj, initobj, initblk, cpyblk" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conrad Coconut</a> : ‚ÄûVielleicht lokalen Speicher streamen?  Puffer mit fester Gr√∂√üe?  Sie sollten wahrscheinlich nicht verwaltete Einschr√§nkungen und blittable Typen erw√§hnen :) ‚Äù <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sebastiano Mandala</a> : ‚ÄûNur eine kleine Erg√§nzung zu allem, was gesagt wurde: Wie w√§re es mit etwas Einfachem wie dem Anordnen von Strukturen und wie das F√ºllen und Ausrichten von Speicher- und Ordnungsfeldern die Cache-Leistung beeinflussen kann?  Das muss ich selbst erforschen. ‚Äú <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nino Floris</a> : "Konstanten, die √ºber Readonlyspan, Stackalloc, Finalizer, WeakReference, offene Delegaten, MethodImplOptions, MemoryBarriers, TypedReference, Varargs, SIMD und Unsafe.AsRef eingebettet sind, k√∂nnen die Strukturtypen genau nach dem Layout festlegen (das f√ºr TaskAwaiter und seine Version verwendet wird)." </li></ul><br>  <b>Am Ende w√ºrde ich also sagen, dass C # es Ihnen sicherlich erm√∂glicht, Code zu schreiben, der wie C ++ aussieht, und in Kombination mit den Laufzeit- und Basisklassenbibliotheken viele Funktionen auf niedriger Ebene bietet.</b> <br><br><h1>  Weiterf√ºhrende Literatur </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlagen f√ºr leistungsstarkes C #.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Federico Andres Lois</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungsquiz Nr. 6 - Chinesisch-Englisch W√∂rterbuch</a> (seit 2005 k√§mpfen zwei Microsoft-Blogger im Kampf um die C ++ - Leistung gegen C #) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Performance Quiz # 6 - Fazit, Weltraumforschung</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie viel schneller ist C ++ als C #?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierung von verwaltetem C # und nativem C ++ - Code</a> (2005) </li></ul><br>  Unity Burst Compiler: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie Unity (eine Teilmenge) von C # so schnell wie C ++ machte</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unity Burst Compiler: Einfache Leistungsoptimierung</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daily Pathtracer, Teil 3: C # und Unity Burst</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++, C # und Unity</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tauchen Sie ein in den Burst-Compiler - Unite LA</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443804/">https://habr.com/ru/post/de443804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443788/index.html">Die Grundlagen des statischen Routings in Mikrotik RouterOS</a></li>
<li><a href="../de443790/index.html">Fehler des √úberlebenden</a></li>
<li><a href="../de443792/index.html">Typische Fehler bei der Arbeit mit PostgreSQL. Teil 2</a></li>
<li><a href="../de443794/index.html">Die Hauptrichtungen f√ºr IT-Startups im Bereich Immobilienverk√§ufe</a></li>
<li><a href="../de443798/index.html">Zotero-Hacks: unbegrenzter synchronisierter Speicher und reibungslose Verwendung mit rmarkdown</a></li>
<li><a href="../de443808/index.html">Analyse von M√§dchen mit geringer sozialer Verantwortung (mit Power BI, Qlik Sense, Tableau beauftragt)</a></li>
<li><a href="../de443810/index.html">Wie viel verdienen Entwickler unterschiedlicher Qualifikationen, 2018?</a></li>
<li><a href="../de443812/index.html">So implementieren Sie eine Programmiersprache in JavaScript. Teil 2: Dolmetscher</a></li>
<li><a href="../de443814/index.html">Geben ist mein "ehemaliges Gesch√§ft"</a></li>
<li><a href="../de443816/index.html">Das Kommunikationsministerium besteht auf einem einzigen 5G-Betreiber</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>