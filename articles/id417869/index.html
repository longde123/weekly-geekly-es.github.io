<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐯 ⛹️ 😜 Bagaimana cara debug WebRTC 👴🏻 🍐 👉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di Voximplant, kami telah menggunakan WebRTC sejak awal: pertama sebagai alternatif untuk Flash untuk panggilan suara dan video, dan kemudian sebagai ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara debug WebRTC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/417869/">  Di Voximplant, kami telah menggunakan WebRTC sejak awal: pertama sebagai alternatif untuk Flash untuk panggilan suara dan video, dan kemudian sebagai pengganti yang lengkap.  Teknologi ini telah menempuh jalan perkembangan yang panjang dan menyakitkan, hanya baru-baru ini semua browser utama telah mulai mendukungnya, ada kesulitan dengan transfer layar, beberapa aliran video, dan kadang-kadang browser mogok hanya jika Anda mematikan dan menghidupkan aliran video.  Akumulasi pengalaman memungkinkan kami menerjemahkan artikel menarik untuk Habr, dan hari ini kami menyampaikan kata tersebut kepada Lee Sylvester dari Xirsys, yang akan berbicara tentang debugging (video) panggilan di Chrome, Firefox, Safari, dan Edge.  Debugging WebRTC tidak mudah, kami bahkan memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi</a> khusus untuk menghapus log di browser populer.  Dan apa yang dimiliki Lee - Anda akan menemukan jawabannya (spoiler: banyak dari semuanya, termasuk WireShark). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/yz/h0/cfyzh02gdgxjvmew9ifyv8p9iju.jpeg"></div><a name="habracut"></a><br><h2>  Sisi gelap WebRTC </h2><br>  Saat bekerja di Xirsys, saya melihat beberapa aplikasi keren yang menggunakan WebRTC.  Tetapi sementara sekelompok kecil pengembang menciptakan hal-hal berteknologi tinggi, sebagian besar programmer bahkan tidak dapat mulai menggunakan WebRTC.  Mengapa  Dan semuanya sederhana.  Ini rumit. <br><br>  Banyak dari kita yang akrab dengan aplikasi web biasa.  Aplikasi semacam itu memiliki klien yang mengirimkan permintaan dan server yang menanggapi permintaan ini.  Proses yang sederhana, linier, dan mudah diprediksi.  Jika terjadi kesalahan, kita biasanya tahu di mana harus melihat log dan apa yang bisa terjadi.  Tetapi dengan WebRTC, semuanya tidak begitu sederhana. <br><br><h2>  Sinkronisasi </h2><br>  Jika Anda pernah menulis aplikasi multi-utas, maka Anda mungkin tahu tentang sakit kepala yang diberikan pengembangan ini.  Penerbangan, memori buruk - tetapi paling sering hanya bug yang sulit ditemukan. <br><br>  WebRTC bersifat asinkron.  Dan ini sama sekali bukan asinkron AJAX sederhana.  Untuk menarik analogi, ini adalah beberapa permintaan AJAX yang diluncurkan secara bersamaan yang mencoba untuk merekonsiliasi data pada dua komputer.  Itu masih hiburan. <br><br><h2>  Lewati ladang tambang NAT </h2><br>  Membuat aplikasi web dilakukan untuk mengembangkan sesuatu yang berjalan di server dan menanggapi permintaan.  Hal terburuk yang bisa terjadi adalah port yang tidak terbuka di IPTables.  Ini dirawat dalam 2 menit.  Anda tidak bisa mengatakan tentang WebRTC. <br><br>  Server web, bahkan perangkat lunaknya, tetapi perangkat keras, adalah perangkat dengan alamat IP publik.  Mereka dibuat dapat diakses dari mana saja.  Dan WebRTC dibuat untuk mengirim dan menerima data dari komputer pengguna.  Yang biasanya memiliki alamat IP 192.168. Sesuatu dan tidak menyala dengan keinginan untuk menanggapi permintaan jaringan. <br><br>  Para penulis WebRTC tahu tentang ini, sehingga mesin akan memilah-milah metode koneksi yang berbeda, dalam upaya untuk membuat koneksi antara dua komputer yang tidak terlalu dirancang untuk itu. <br><br><h2>  Di mana memulai debugging </h2><br>  Pada artikel ini saya berbicara tentang alat dasar untuk menyelesaikan masalah yang paling populer.  Tetapi sebelum itu, mari kita lihat bagaimana WebRTC biasanya membangun koneksi. <br><br><h2>  Bagaimana WebRTC membuat koneksi </h2><br>  Semua koneksi WebRTC memerlukan sedikit bantuan dari protokol pensinyalan.  “Sedikit bantuan” adalah server dan protokol Anda sendiri yang dengannya pemanggil akan dapat berkomunikasi dengan orang yang ia panggil sebelum membuat koneksi Peer-to-peer. <br><br>  WebRTC akan menggunakan protokol pensinyalan untuk mengirimkan informasi tentang alamat IP, kemampuan untuk menangkap dan memutar suara dan video, topologi jaringan, dan data yang dikirimkan. <br><br>  Protokol yang umum digunakan adalah COMET (atau SIP - catatan penerjemah) dan soket web.  WebRTC tidak membatasi pengembang untuk apa pun, sehingga Anda dapat menggunakan apa pun yang Anda suka, setidaknya mentransfer data melalui Notepad dan salin-tempel (dilakukan di salah satu bengkel, berfungsi - lagi penerjemah).  Pensinyalan yang terhubung ke kedua komputer memungkinkan Anda memulai koneksi yang sudah melalui WebRTC. <br><br><h4>  Tawarkan dan jawab </h4><br>  Koneksi WebRTC menggunakan "offer" dan "answer": <br><br><ol><li>  Penggagas koneksi menciptakan dan meneruskan ke "penawaran" pihak lain. </li><li>  Pihak lain menerima "tawaran", menciptakan "respons" dan meneruskannya kembali. </li><li>  Inisiator koneksi menerima "jawaban". </li></ol><br>  Ini dalam teori.  Dalam praktiknya, pertukaran sapa tidak terlihat begitu sederhana. <br><br><ol><li>  Sebelum mentransmisikan "penawaran", inisiator koneksi membuat instance dari <b>RTCPeerConnection</b> dan menerima darinya paket teks "SDP" (Protokol Deskripsi Sesi) menggunakan <b>rtcPeerConnection.createOffer ()</b> ;  Paket ini menjelaskan kemampuan untuk menerima / mengirimkan suara dan video untuk browser. </li><li>  Isi paket SDP ditetapkan sebagai "deskripsi sisi lokal koneksi" menggunakan <b>rtcPeerConnection.setLocalDescription ()</b> . </li><li>  Paket dikirim ke sisi lain, di mana isinya diatur sebagai "deskripsi sisi lain koneksi" menggunakan <b>rtcPeerConnection.setRemoteDescription ()</b> . </li><li>  Di sisi lain koneksi, paket SDP-nya dibuat menggunakan <b>rtcPeerConnection.createAnswer ()</b> , isinya ditetapkan sebagai "deskripsi sisi lokal koneksi". </li><li>  Paket dilewatkan ke inisiator koneksi, yang menetapkan isinya sebagai "deskripsi sisi lain koneksi". </li></ol><br>  Dan hanya setelah semua tindakan, kedua pihak yang terhubung mengetahui kemampuan masing-masing untuk menerima dan mengirim suara / video. <br><br><h4>  Kandidat ICE </h4><br>  Tetapi kemampuan untuk bekerja dengan media tidak cukup.  Bagaimanapun, pihak-pihak yang berkontrak belum mengatakan apa-apa tentang keadaan jaringan. <br><br>  Anda dapat mengetahui codec video mana yang didukung browser dan apakah ada kamera di laptop hampir secara instan.  Butuh waktu untuk mengetahui alamat IP eksternal Anda dan logika operasi NAT, dan informasi tentang status jaringan dipertukarkan ketika informasi ini diterima. <br><br>  Berkat teknologi Trickle ICE (tidak didukung oleh semua browser - catatan penerjemah), koneksi antara dua perangkat WebRTC dapat dibuat kapan saja - segera setelah "kandidat" yang cocok ditemukan. <br><br>  Pengembang harus berlangganan ke acara <b>onicecandidate</b> (semua huruf kecil!) Dan meneruskan paket SDP yang diterima ke sisi lain, di mana paket tersebut harus ditransmisikan oleh WebRTC menggunakan metode <b>addIceCandidate</b> (dan di sini, kejutan, huruf kapital).  Ini bekerja dua arah. <br><br><h2>  Koneksi </h2><br>  WebRTC menggunakan hal-hal seperti STUN (Session Traversal Utilities for NAT) dan TURN (Traversal Menggunakan Relay di sekitar NAT) untuk membuat koneksi.  Kedengarannya menakutkan, tetapi pada kenyataannya hanya ada dua protokol jaringan. <br><br><h4>  STUN server </h4><br>  Protokol pertama dari kedua protokol ini sedikit lebih rumit daripada server gema.  Saat menghubungkan peserta, mereka ingin menjelaskan cara menghubungkan mereka, mereka membutuhkan alamat IP publik mereka.  Dan kemungkinan besar itu bukan alamat IP komputer, perangkat publik jarang dialokasikan untuk perangkat pengguna.  Seluruh teknologi NAT diciptakan agar tidak mengisolasi.  Untuk tetap mengetahui alamat publik Anda, browser membuat permintaan ke server STUN.  Melewati NAT, paket jaringan mengubah alamat pengirim ke publik.  Setelah menerima paket dengan permintaan, server STUN menyalin alamat pengirim untuk muatannya dan mengirimkan paket kembali.  Melewati NAT di arah yang berlawanan, paket kehilangan alamat IP publiknya, tetapi salinan alamat ini tetap dalam muatan, di mana WebRTC dapat membacanya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/vo/8r/qhvo8rafhc4akmapxnb7vtni2pe.png"></div><br><h2>  HIDUPKAN server </h2><br>  Server TURN menggunakan ekstensi protokol STUN.  Paket, header, dan hal yang sama: <b>perintah</b> .  Server adalah proxy: kedua klien terhubung melalui port <b>alokasi</b> UDP dan mengirimkan data mereka melalui server. <br><br>  TURN server dirancang sedemikian rupa sehingga pemrakarsa koneksi memiliki lebih banyak fitur daripada sisi lainnya.  Ini mengarah ke efek yang menarik ketika panggilan melalui server MENGHIDUPKAN berhasil atau tidak berhasil, tergantung pada siapa yang memanggil siapa (ingat semua penerjemah Skype - note). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/07/j6/qq/07j6qqsbyc7fod_yx2vuk_9zctu.png"></div><br><h2>  Debugging </h2><br>  Jadi, Anda membaca hingga paragraf ini.  Kami senang dengan penerjemah dan ingat bahwa artikelnya adalah tentang debugging WebRTC.  Tetapi semua hal di atas adalah minimum yang diperlukan, yang tanpanya Anda bahkan tidak bisa memulai.  Tetapi jika Anda memulai, dan Anda tidak memiliki keberuntungan yang tidak manusiawi, maka itu akan hancur. <br><br>  Ini akan pecah dengan berbagai cara.  Yang pertama adalah kurangnya konektivitas.  Anda melewati pengaturan STUN dan TURN server ke kedua WebRTC, membantu mereka bertukar penawaran, menjawab, dan kandidat ICE, tetapi tidak ada video atau suara.  Di mana untuk memulai?  Dengan masalah pemutaran lokal. <br><br><h2>  WebRTC debugging lokal </h2><br>  Seperti yang saya tulis di atas, pekerjaan utama WebRTC terjadi di sisi browser.  STUN dan TURN server sangat sederhana, sehingga sebagian besar masalah terjadi pada kode JavaScript Anda, yang berjalan di dua browser.  Sedih tapi benar.  Di sisi lain, jika hal yang paling menarik terjadi secara lokal di peramban, maka Anda memiliki banyak peluang untuk melakukan debug! <br><br>  Hal pertama yang harus diperiksa adalah pensinyalan Anda.  Ini adalah kode Anda yang mentransmisikan konfigurasi audio dengan video (penawaran, jawaban) dan informasi tentang pengaturan jaringan (kandidat es) di antara browser.  Anda perlu memeriksa paket mana yang dikirim, yang menerima dan mengirim WebRTC: <br><br><ul><li>  sisi lain koneksi menerima tawaran?  Sudahkah inisiator koneksi menerima tanggapan?  Koneksi tidak akan terjadi tanpa pertukaran fasilitas minimal ini; </li><li>  Apakah WebRTC di kedua ujung koneksi memberikan Anda paket dengan kandidat ICE?  Apakah Anda menukar paket-paket ini dan meneruskannya kembali ke sisi yang berlawanan menggunakan <b>addIceCandidate</b> ? </li><li>  jika semuanya berjalan baik dengan pertukaran paket, <b>apakah</b> event handler <b>onaddstream dipanggil</b> dan apakah Anda menginstal objek yang dihasilkan dalam elemen HTML untuk memutar video (atau audio)? </li></ul><br>  Jika pertukaran paket tidak mencurigakan, maka Anda dapat mempelajari isi sesi ini. <br><br><h2>  Protokol deskripsi sesi </h2><br>  Paket penawaran, Jawaban, dan kandidat ICE dibuat oleh WebRTC dalam format teks SDP.  Pada pandangan pertama, isi paket terlihat menakutkan, tetapi dengan sedikit persiapan Anda bisa mendapatkan banyak manfaat darinya selama debugging.  Wikipedia menggambarkan SDP dengan cukup baik, tetapi saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi yang lebih baik</a> untuk Anda. <br><br>  Bidang yang paling penting dalam paket ICE SDP kandidat adalah <b>typ</b> .  Untuk WebRTC, bidang dapat memiliki salah satu dari tiga nilai: <br><br><ul><li>  inang ketik; </li><li>  ketik srflx; </li><li>  ketik relay. </li></ul><br><h4>  ketik host </h4><br>  Tipe <b>host</b> menentukan kandidat ICE untuk koneksi area lokal (WebRTC menyebutkan beberapa kandidat dengan harapan membangun koneksi, tidak diketahui sebelumnya mana yang akan keluar - perhatikan oleh penerjemah).  Koneksi semacam itu tidak memerlukan STUN atau TURN server, karena perangkat di jaringan lokal seringkali dapat membuat koneksi jaringan secara langsung.  Saat melakukan debug dari jaringan lokal, Anda hanya perlu memeriksa dan men-debug pengiriman paket <b>host</b> dan memastikan bahwa perangkat dapat saling mengirim paket UDP.  Meskipun ada pengecualian, dalam praktiknya saya telah melihat konfigurasi jaringan di mana browser membutuhkan server TURN untuk menghubungkan ... ke dirinya sendiri. <br><br><h4>  ketik srflx </h4><br>  Kombinasi huruf "srflx" adalah singkatan dari "Server Reflexive" dan menandai kandidat koneksi menggunakan alamat IP eksternal, di mana server STUN cukup untuk koneksi (menggunakan teknologi penetrasi NAT, yang berhasil dalam sekitar 80% kasus, catat penerjemah). <br><br><h4>  ketik relay </h4><br>  "Relay" menandai koneksi melalui server TURN, yang hampir selalu berhasil.  Penting untuk diingat bahwa WebRTC tidak diharuskan untuk membuat tepat tiga paket berbeda dengan bidang "typ";  bagaimana kandidat dipilih tergantung pada implementasi WebRTC dalam versi browser tertentu. <br><br><h2>  Menguji konektivitas perangkat </h2><br>  Google menawarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi web</a> khusus untuk menguji koneksi WebRTC pada perangkat Anda.  Buka halaman, klik tombol "mulai" dan kode JavaScript akan mencoba membuat koneksi ke server Google menggunakan pensinyalan, server STUN dan TURN Google. <br><br><h2>  WebRTC Internal </h2><br>  Anda memeriksa semua paket, memeriksa kodenya, semuanya terlihat benar, tetapi tidak berhasil?  Untuk kasus seperti itu, Google telah menyediakan browser Chrome dengan bagian khusus yang menunjukkan internal WebRTC selama penyiapan koneksi dan beberapa grafik yang indah jika koneksi berhasil.  Untuk menggunakan, buka tautan teknis khusus di browser: <br><br> <code>chrome://webrtc-internals</code> <br> <br>  Jika Anda sudah memiliki aplikasi menggunakan WebRTC terbuka, Anda akan segera melihat banyak data teknis.  Jika tidak, buka saja tab lain dan ada sesuatu di dalamnya yang menggunakan WebRTC.  Tab menampilkan semua panggilan ke objek <b>RTCPeerConnection</b> dan memungkinkan Anda untuk melihat secara real time bagaimana koneksi dibuat. <br><br><h2>  Pengaturan ICE </h2><br>  Di bagian atas halaman adalah string ICE yang digunakan untuk menginisialisasi koneksi.  Jika kesalahan dibuat selama pembentukannya, ini akan segera terlihat (oleh "ICE line" penulis merujuk ke konfigurasi objek RTCPeerConnection dengan daftar STUN dan MENGHIDUPKAN server (objek 'iceServers') - catatan oleh penerjemah).  Mungkin tidak ada daftar server?  Anda harus mengonfigurasi objek RTCPeerConnection sebelum melakukan panggilan pertama ke <b>createOffer</b> atau <b>createAnswer</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/hz/xo/lohzxoou7x8sbrhqfwuruhcwsw4.png"></div><br><h2>  Acara RTCPeerConnection </h2><br>  Bagian internal berikutnya menunjukkan panggilan ke metode <b>RTCPeerConnection</b> dan peristiwa yang diterima dari objek dalam urutan kronologis.  Kesalahan disorot dengan hati-hati dalam warna merah.  Harap perhatikan bahwa <b>addIceCandidateFailed</b> merah seringkali bukan merupakan tanda kesalahan dan koneksi dapat terbentuk secara normal.  Jika koneksi berhasil, acara terakhir dalam daftar akan menjadi <b>iceconnectionstatechange</b> event dengan nilai <b>selesai</b> . <br><br><h2>  Bagian 'statistik' </h2><br>  Bagian selanjutnya relevan ketika koneksi berhasil dibuat.  Ini berisi statistik dari data yang dikirim dan penundaan jaringan.  Dua opsi yang paling menarik adalah: <b>ssrc</b> dan <b>bweforvideo</b> . <br><br><ul><li>  <b>ssrc</b> , "Stream Source", menandai setiap trek audio dan video Anda.  Menampilkan statistik data dan parameter yang dikirimkan seperti <b>waktu pulang pergi</b> ; </li><li>  <b>bweforvideo</b> , Perkiraan BandWidth, menampilkan lebar saluran jaringan yang digunakan. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/9e/wt/te9ewt2nl26jhbezdqj3_rkr8d4.png"></div><br><h2>  Fungsi GetStats </h2><br>  Seringkali Anda tidak akan dapat mengakses halaman internal.  Misalnya, ketika terjadi masalah dengan pengguna Anda.  Dalam hal ini, Anda bisa mendapatkan data yang sama dengan yang ditunjukkan halaman internal dengan memanggil metode <b>getStats</b> pada objek <b>RTCPeerConnection</b> .  Metode ini mengatur fungsi panggilan balik yang akan dipanggil WebRTC setiap kali sesuatu yang menarik terjadi.  Fungsi yang dipanggil mendapatkan objek dengan bidang yang ditampilkan halaman internal: <br><br><pre> <code class="javascript hljs">rtcPeerConnection.getStats(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"lostpackets"</span></span>).innerText = stats.packetsLost; });</code> </pre><br>  Alat lain yang bermanfaat adalah event <b>oniceconnectionstatechange</b> objek <b>RTCPeerConnection</b> .  Handler event akan menerima informasi progres koneksi.  Opsi yang memungkinkan: <br><br><ul><li>  <b>baru</b> : WebRTC mengharapkan kandidat dari sisi kedua koneksi, yang harus ditambahkan menggunakan metode <b>addIceCandidate</b> ; </li><li>  <b>memeriksa</b> : WebRTC menerima kandidat dari sisi kedua koneksi, membandingkannya dengan yang lokal dan beralih pada opsi; </li><li>  <b>terhubung</b> : sepasang kandidat yang cocok dipilih dan koneksi dibuat.  Patut dicatat bahwa setelah ini, kandidat dapat terus datang, sesuai dengan protokol Trickle ICE; </li><li>  <b>selesai</b> : semua kandidat diterima dan koneksi dibuat. </li><li>  <b>terputus</b> : koneksi <b>terputus</b> .  Pada saluran yang tidak stabil, WebRTC dapat terhubung kembali, kami memantau flag yang <b>terhubung</b> ; </li><li>  <b>ditutup</b> : koneksi terputus dan WebRTC tidak lagi berfungsi dengannya. </li></ul><br>  Jika koneksi berakhir dalam keadaan <b>gagal</b> , maka kita dapat memeriksa kandidat yang diterima di kedua sisi dan memahami mengapa koneksi gagal.  Misalnya, jika satu sisi menyediakan <b>host</b> dan <b>kandidat srflx</b> , sisi lain <b>host</b> dan <b>relay</b> , tetapi perangkat berada di jaringan yang berbeda. <br><br><h2>  Kotak hitam bukan video </h2><br>  Seringkali ada situasi ketika koneksi dibuat, suara ditransmisikan, tetapi bukannya video, satu atau kedua peserta memiliki persegi panjang hitam.  Paling sering ini terjadi jika Anda menetapkan objek video yang diterima ke elemen HTML sebelum koneksi transisi ke keadaan <b>selesai</b> . <br><br><h2>  Cara menyodok tongkat di luar </h2><br>  Selain objek <b>RTCPeerConnection itu sendiri</b> dan internal yang ditampilkan oleh browser, Anda dapat menggunakan alat analisis paket jaringan seperti Wireshark.  Alat-alat ini dapat menampilkan paket-paket protokol WebRTC yang digunakan.  Misalnya, Wireshark akan menunjukkan kepada Anda konten paket STUN di jendela utama, dan Anda dapat memfilternya dengan mengetikkan kata kunci “setrum” di bidang filter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c4/89/jf/c489jf68awl5u25fah6xnv8piee.png"></div><br>  Apa yang harus dilihat di respons server?  Jika Anda hanya melihat jawaban dengan tipe <b>Binding</b> , ini berarti hanya STUN (pembicaraan IP eksternal) yang didukung, dan WebRTC hanya dapat menawarkan kandidat <b>srflx</b> .  Jika jawaban berisi paket TURN khusus <b>Alokasi</b> dan <b>CreatePermission</b> , maka WebRTC akan memiliki kesempatan untuk mencoba menghubungkan melalui server proxy.  Penganalisa paket menandai <b>Alokasi yang</b> berhasil dan tidak berhasil.  Jika tidak ada satu yang berhasil, maka kemungkinan besar parameter akses yang salah ke server TURN (yang hampir selalu dilindungi dengan nama pengguna dan kata sandi - catatan penerjemah) dilewatkan. <br><br>  Jika ada paket <b>Respons Keberhasilan CreatePermission</b> di log, maka kita dapat mengasumsikan bahwa semuanya baik-baik saja dengan konfigurasi STUN dan TURN.  Dan jika ada juga paket <b>ChannelBind</b> , maka dimungkinkan untuk membuat koneksi ke server MENGHIDUPKAN dengan kecepatan tinggi. <br><br><h2>  Masalah Seluler </h2><br>  Dalam praktik saya, banyak solusi WebRTC yang membuat koneksi WiFi tidak dapat terhubung melalui 3G / 4G.  Aplikasi yang diluncurkan pada perangkat seluler lebih sulit untuk di-debug: kami tidak memiliki penganalisa paket sederhana seperti Wireshark, dan Safari tidak dapat menampilkan internal WebRTC.  Logika menunjukkan bahwa jika aplikasi berfungsi dengan baik melalui WiFi, maka masalahnya bukan pada aplikasi itu sendiri, tetapi dalam komunikasi seluler.  Bagaimana cara debug?  Ambil laptop dan sambungkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dongle 3G</a> ke dalamnya.  Jadi Anda memiliki penganalisa paket dan log yang mudah digunakan yang dapat Anda temukan akar semua masalah dalam waktu yang wajar. <br><br><h2>  Kesimpulan </h2><br>  Debugging WebRTC tidak mudah, tetapi jika Anda mencari dengan baik di Internet, Anda dapat menemukan banyak artikel dan contoh.  Jika Anda bekerja di bidang komunikasi waktu nyata, maka saya sarankan Anda membaca spesifikasi RFC untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STUN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MENGHIDUPKAN</a> protokol dan teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebRTC</a> .  Dokumennya besar, tetapi informasi yang terkandung di dalamnya membantu membuat keputusan yang andal dan menjawab pertanyaan "mengapa tidak berdering". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417869/">https://habr.com/ru/post/id417869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417859/index.html">3CX Integrasi dengan Microsoft Dynamics 365</a></li>
<li><a href="../id417861/index.html">Pola prima tak berujung</a></li>
<li><a href="../id417863/index.html">Anak-anak memesan segera? Dewan Etika Inggris mengesahkan rekayasa genetika embrio manusia</a></li>
<li><a href="../id417865/index.html">Aksesibilitas Android - serigala berbulu domba? Kuliah Yandex</a></li>
<li><a href="../id417867/index.html">Cara mengevaluasi durasi proyek TI, dan ketika itu tidak layak dilakukan sama sekali</a></li>
<li><a href="../id417871/index.html">Di garis finish pariwisata suborbital</a></li>
<li><a href="../id417873/index.html">Cara Membuat PopUp Windows</a></li>
<li><a href="../id417875/index.html">Keluar dari Rabbit Hole SPA dengan Modern Rails</a></li>
<li><a href="../id417877/index.html">Bagaimana Tinder (sedikit) menyembunyikan lokasi Anda</a></li>
<li><a href="../id417879/index.html">Cara mengambil ujian dari Microsoft secara gratis [misalnya, kompetisi terbaru]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>