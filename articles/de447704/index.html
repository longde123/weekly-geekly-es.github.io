<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè≥Ô∏è‚Äçüåà üñ®Ô∏è üïç Elbrus besteigen - Aufkl√§rung im Kampf. Technischer Teil 1. Register, Stapel und andere technische Details ‚ô¶Ô∏è üåó üï∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie versprochen sprechen wir weiterhin √ºber die Entwicklung von Elbrus-Prozessoren . Dieser Artikel ist technisch. Die Informationen in diesem Artikel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elbrus besteigen - Aufkl√§rung im Kampf. Technischer Teil 1. Register, Stapel und andere technische Details</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447704/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie versprochen</a> sprechen wir weiterhin √ºber die Entwicklung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Elbrus-Prozessoren</a> .  Dieser Artikel ist technisch.  Die Informationen in diesem Artikel sind keine offiziellen Unterlagen, da sie w√§hrend des Studiums von Elbrus √§hnlich wie eine Black Box erhalten wurden.  Aber es wird sicherlich interessant f√ºr ein besseres Verst√§ndnis der Elbrus-Architektur sein, denn obwohl wir eine offizielle Dokumentation hatten, wurden viele Details erst nach langwierigen Experimenten klar, als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Embox</a> funktionierte. <br><br>  Denken Sie daran, dass wir im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> √ºber den grundlegenden Systemstart und den Treiber f√ºr die serielle Schnittstelle gesprochen haben.  Embox wurde gestartet, aber f√ºr die weitere Weiterentwicklung brauchten wir Interrupts, einen System-Timer und nat√ºrlich m√∂chte ich einige Unit-Tests einbinden, und daf√ºr brauchen wir setjmp.  Dieser Artikel konzentriert sich auf Register, Stapel und andere technische Details, die zur Implementierung all dieser Dinge erforderlich sind. <br><a name="habracut"></a><br>  Beginnen wir mit einer kurzen Einf√ºhrung in die Architektur. Dies sind die Mindestinformationen, die erforderlich sind, um zu verstehen, was sp√§ter erl√§utert wird.  In Zukunft werden wir auf die Informationen aus diesem Abschnitt verweisen. <br><br><h3>  Kurze Einf√ºhrung: Stapel </h3><br>  In Elbrus gibt es drei Stapel: <br><br><ul><li>  Prozedurstapel (PS) </li><li> Prozedur Chain Stack (PCS) </li><li>  User Stack (US) </li></ul><br>  Lassen Sie uns sie genauer analysieren.  Die Adressen in der Abbildung sind bedingt und zeigen, in welche Richtung die Bewegungen gerichtet sind - von einer gr√∂√üeren Adresse zu einer kleineren oder umgekehrt. <br><br><img src="https://habrastorage.org/webt/le/bc/ac/lebcace6fqkdk5vvhwke6kajyuu.png"><br><br>  Der Prozedurstapel (PS) ist f√ºr Daten vorgesehen, die "Betriebsregistern" zugeordnet sind. <br><br>  Beispielsweise kann es sich um Funktionsargumente handeln. In ‚Äûnormalen‚Äú Architekturen ist dieses Konzept den Allzweckregistern am n√§chsten.  Im Gegensatz zu "normalen" Prozessorarchitekturen werden in E2K in Registern verwendete Register auf einem separaten Stapel gestapelt. <br><br>  Der Stapel von Bindungsinformationen (PCS) dient zum Platzieren von Informationen √ºber die vorherige (aufrufende) Prozedur und wird bei der R√ºckgabe verwendet.  Die Daten auf der Absenderadresse sowie bei den Registern werden an einem separaten Ort abgelegt.  Daher ist die Stapelheraufstufung (z. B. das Beenden ausnahmsweise in C ++) zeitaufw√§ndiger als in ‚Äûnormalen‚Äú Architekturen.  Auf der anderen Seite werden dadurch Stapel√ºberlaufprobleme beseitigt. <br><br>  Beide Stapel (PS und PCS) sind durch eine Basisadresse, Gr√∂√üe und einen Stromversatz gekennzeichnet.  Diese Parameter werden in den PSP- und PCSP-Registern eingestellt, sie sind 128-Bit und im Assembler m√ºssen Sie auf bestimmte Felder verweisen (z. B. hoch oder niedrig).  Dar√ºber hinaus h√§ngt die Funktionsweise der Stapel eng mit dem Konzept einer Registerdatei zusammen, mehr dazu weiter unten.  Die Interaktion mit der Datei erfolgt √ºber den Mechanismus des Pumpens / Austauschs von Registern.  Eine aktive Rolle in diesem Mechanismus spielt der sogenannte "Hardware-Zeiger auf die Oberseite des Stapels" der Prozedur bzw. des Stapels von Bindungsinformationen.  Dar√ºber auch weiter unten.  Es ist wichtig, dass sich die Daten dieser Stapel zu jedem Zeitpunkt entweder im RAM oder in einer Registerdatei befinden. <br><br>  Es ist auch erw√§hnenswert, dass diese Stapel (der prozedurale Stapel und der Stapel von Bindungsinformationen) erwachsen <i>werden</i> .  Wir sind darauf gesto√üen, als wir context_switch implementiert haben. <br><br>  Der Benutzerstapel erh√§lt auch die Basisadresse und -gr√∂√üe.  Der aktuelle Zeiger befindet sich im Register USD.lo.  Im Kern ist es ein klassischer Stapel, der nach unten w√§chst.  Nur passen im Gegensatz zu ‚Äûnormalen‚Äú Architekturen Informationen von anderen Stapeln (Registern und R√ºcksprungadressen) nicht dorthin. <br><br>  Eine meiner Meinung nach nicht standardm√§√üige Anforderung f√ºr die Grenzen und Gr√∂√üen der Stapel ist die 4K-Ausrichtung, und sowohl die Basisadresse des Stapels als auch seine Gr√∂√üe m√ºssen auf 4K ausgerichtet sein.  In anderen Architekturen bin ich einer solchen Einschr√§nkung nicht begegnet.  Dieses Detail ist uns erneut begegnet, als wir context_switch implementiert haben. <br><br><h3>  Kurze Einf√ºhrung: Register.  Dateien registrieren.  Fenster registrieren </h3><br>  Nachdem wir die Stapel ein wenig herausgefunden haben, m√ºssen wir verstehen, wie die Informationen in ihnen dargestellt werden.  Dazu m√ºssen wir einige weitere Konzepte einf√ºhren. <br><br>  Eine Registerdatei (RF) ist ein Satz aller Register.  Es gibt zwei Registerdateien, die wir ben√∂tigen: Eine Datei mit Verbindungsinformationen (Chain-Datei - CF), die andere wird als Registerdatei (RF) bezeichnet und speichert "Betriebsregister", die auf dem prozeduralen Stapel gespeichert sind. <br><br>  Das Registerfenster ist der Bereich (Registersatz) der Registerdatei, der derzeit verf√ºgbar ist. <br><br>  Ich werde es genauer erkl√§ren.  Was ist eine Reihe von Registern, denke ich, muss niemand erkl√§ren. <br><br>  Es ist bekannt, dass einer der Engp√§sse in der x86-Architektur genau eine kleine Anzahl von Registern ist.  In RISC-Architekturen mit Registern ist es einfacher, normalerweise etwa 16 Register, von denen mehrere (2-3) f√ºr offizielle Zwecke belegt sind.  Warum nicht einfach 128 Register erstellen, denn dies scheint die Systemleistung zu steigern?  Die Antwort ist ganz einfach: Ein Prozessorbefehl ben√∂tigt einen Platz zum Speichern der Registeradresse, und wenn es viele davon gibt, werden auch viele Bits daf√ºr ben√∂tigt.  Deshalb gehen sie zu allen m√∂glichen Tricks, erstellen Schattenregister, registrieren Banken, Fenster und so weiter.  Mit Schattenregistern meine ich das Prinzip der Registerorganisation in ARM.  Wenn eine Unterbrechung oder eine andere Situation auftritt, ist ein anderer Satz von Registern mit denselben Namen (Nummern) verf√ºgbar, w√§hrend die im urspr√ºnglichen Satz gespeicherten Informationen dort verbleiben.  Registerbanken sind in der Tat Schattenregistern sehr √§hnlich, es gibt einfach keine Hardware-Umschaltung von Registers√§tzen, und der Programmierer w√§hlt aus, welche Bank (Registersatz) jetzt kontaktiert werden soll. <br><br>  Registerfenster dienen dazu, die Arbeit mit dem Stapel zu optimieren.  Wie Sie wahrscheinlich verstehen, geben Sie in einer ‚Äûnormalen‚Äú Architektur eine Prozedur ein, speichern Register im Stapel (oder das Speichern der aufrufenden Prozedur h√§ngt von der Vereinbarung ab) und Sie k√∂nnen Register verwenden, da die Informationen bereits auf dem Stapel gespeichert sind.  Der Speicherzugriff ist jedoch langsam und sollte daher vermieden werden.  Wenn Sie die Prozedur eingeben, stellen Sie einfach einen neuen Registersatz zur Verf√ºgung. Die Daten des alten werden gespeichert, sodass Sie sie nicht in den Speicher kopieren m√ºssen.  Wenn Sie zur aufrufenden Prozedur zur√ºckkehren, wird au√üerdem das vorherige Registerfenster zur√ºckgegeben, sodass alle Daten in den Registern relevant sind.  Dies ist das Konzept eines Registerfensters. <br><br><img src="https://habrastorage.org/webt/lg/5e/6u/lg5e6u_pfus75yedi6hefckkqkk.png"><br><br>  Es ist klar, dass Sie die Register noch auf dem Stapel (im Speicher) speichern m√ºssen, dies kann jedoch erfolgen, wenn die freien Registerfenster beendet sind. <br><br>  Und was tun mit den Eingabe- und Ausgaberegistern (Argumente bei der Eingabe der Funktion und dem zur√ºckgegebenen Ergebnis)?  Lassen Sie das Fenster einen Teil der Register enthalten, die vom vorherigen Fenster aus sichtbar sind, genauer gesagt, ein Teil der Register ist f√ºr beide Fenster verf√ºgbar.  Wenn Sie dann die Funktion aufrufen, m√ºssen Sie im Allgemeinen nicht auf den Speicher zugreifen.  Angenommen, unsere Register sehen so aus <br><br><img src="https://habrastorage.org/webt/n9/ki/zw/n9kizwn2qkag4rew2jspyassaco.png"><br><br>  Das hei√üt, r0 im ersten Fenster ist das gleiche Register wie r2 in Null und r1 aus dem ersten Fenster im gleichen Register wie r3.  Das hei√üt, wenn wir vor dem Aufruf der Prozedur in r2 schreiben (die Fensternummer √§ndern), erhalten wir den Wert in r0 in der aufgerufenen Prozedur.  Dieses Prinzip wird als Mechanismus zum Drehen von Fenstern bezeichnet. <br><br>  Lassen Sie uns etwas mehr optimieren, denn die Macher von Elbrus haben genau das getan.  Lassen Sie die Fenster, die wir haben, keine feste Gr√∂√üe haben, sondern variabel, die Fenstergr√∂√üe kann zum Zeitpunkt des Eintritts in die Prozedur eingestellt werden.  Wir werden das gleiche mit der Anzahl der gedrehten Register tun.  Dies f√ºhrt nat√ºrlich zu einigen Problemen, da in den klassischen drehbaren Fenstern ein Fensterindex vorhanden ist, √ºber den bestimmt wird, dass Sie Daten aus der Registerdatei auf dem Stapel speichern oder laden m√ºssen.  Wenn Sie jedoch nicht den Fensterindex eingeben, sondern den Registerindex, von dem aus unser aktuelles Fenster startet, tritt dieses Problem nicht auf.  In Elbrus sind diese Indizes in den Registern PSHTP (f√ºr den PS-Prozedurstapel) und PCSHTP (f√ºr den PCS-Prozedurinformationsstapel) enthalten.  Die Dokumentation bezieht sich auf ‚ÄûHardware-Zeiger auf die Oberseite des Stapels‚Äú.  Jetzt k√∂nnen Sie erneut versuchen, √ºber die Stapel zu lesen. Ich denke, es wird klarer. <br><br>  Wie Sie verstehen, impliziert ein solcher Mechanismus, dass Sie steuern k√∂nnen, was sich im Speicher befindet.  Synchronisieren Sie also die Registerdatei und den Stapel.  Ich meine einen Systemprogrammierer.  Wenn Sie ein Anwendungsprogrammierer sind, bietet das Ger√§t einen transparenten Ein- und Ausstieg aus dem Verfahren.  Das hei√üt, wenn beim Versuch, ein neues Fenster auszuw√§hlen, nicht gen√ºgend Register vorhanden sind, wird das Registerfenster automatisch ‚Äûabgepumpt‚Äú.  In diesem Fall werden alle Daten aus der Registerdatei auf dem entsprechenden Stapel (im Speicher) gespeichert und der ‚ÄûZeiger auf die Hardware-Oberseite des Stapels‚Äú (Offset-Index) wird auf Null zur√ºckgesetzt.  Ebenso erfolgt das Austauschen einer Registerdatei vom Stapel automatisch.  Wenn Sie beispielsweise eine Kontextumschaltung entwickeln, die genau das ist, was wir getan haben, ben√∂tigen Sie einen Mechanismus f√ºr die Arbeit mit dem verborgenen Teil der Registerdatei.  In Elbrus werden hierf√ºr die Befehle FLUSHR und FLUSHC verwendet.  FLUSHR - Wenn die Registerdatei gel√∂scht wird, werden alle Fenster au√üer dem aktuellen in den prozeduralen Stapel geleert. Der PSHTP-Index wird dementsprechend auf Null zur√ºckgesetzt.  FLUSHC - Bereinigt die Bindungsinformationsdatei. Alles au√üer dem aktuellen Fenster wird auf den Bindungsinformationsstapel geschrieben. Der PCSHTP-Index wird ebenfalls auf Null zur√ºckgesetzt. <br><br><h3>  Kurze Einf√ºhrung: Implementierung in Elbrus </h3><br>  Nachdem wir die nicht offensichtliche Arbeit mit Registern und Stapeln besprochen haben, werden wir genauer auf verschiedene Situationen in Elbrus eingehen. <br><br>  Wenn wir die n√§chste Funktion aufrufen, erstellt der Prozessor zwei Fenster: ein Fenster auf dem PS-Stapel und ein Fenster auf dem PCS-Stapel. <br><br>  Ein Fenster im PCS-Stapel enth√§lt die Informationen, die f√ºr die R√ºckkehr von einer Funktion erforderlich sind: z. B. IP (Instruction Pointer) der Anweisung, bei der Sie von der Funktion zur√ºckkehren m√ºssen.  Damit ist alles mehr oder weniger klar. <br><br>  Das Fenster auf dem PS-Stack ist etwas kniffliger.  Das Konzept der Register des aktuellen Fensters wird vorgestellt.  In diesem Fenster haben Sie Zugriff auf die Register des aktuellen Fensters -% dr0,% dr1, ...,% dr15, ... Das hei√üt, f√ºr uns als Benutzer sind sie immer von 0 nummeriert, dies ist jedoch eine Nummerierung relativ zur Basisadresse des aktuellen Fensters.  √úber diese Register werden die Argumente √ºbergeben, wenn die Funktion aufgerufen wird, und der Wert wird zur√ºckgegeben, und die Funktion wird als Allzweckregister innerhalb der Funktion verwendet.  Tats√§chlich wurde dies unter Ber√ºcksichtigung des Mechanismus des Drehens von Registerfenstern erkl√§rt. <br><br>  Die Gr√∂√üe des Registerfensters in Elbrus kann gesteuert werden.  Dies ist, wie gesagt, zur Optimierung notwendig.  In einer Funktion ben√∂tigen wir beispielsweise nur 4 Register zum √úbergeben von Argumenten und einige Berechnungen. In diesem Fall entscheidet der Programmierer (oder Compiler), wie viele Register der Funktion zugewiesen werden sollen, und legt basierend darauf die Fenstergr√∂√üe fest.  Die Fenstergr√∂√üe wird durch die Operation setwd festgelegt: <br><br><pre><code class="cpp hljs">setwd wsz=<span class="hljs-number"><span class="hljs-number">0x10</span></span></code> </pre> <br>  Gibt die Fenstergr√∂√üe in Form von Quad-Registern (128-Bit-Registern) an. <br><br><img src="https://habrastorage.org/webt/tf/ov/px/tfovpxrj1wkos3e29zsl0fj_8p8.png"><br><br>  Angenommen, Sie m√∂chten eine Funktion von einer Funktion aus aufrufen.  Hierzu wird das bereits beschriebene Konzept eines gedrehten Registerfensters angewendet.  Das Bild oben zeigt ein Fragment einer Registerdatei, in der eine Funktion mit Fenster 1 (gr√ºn) eine Funktion mit Fenster 2 (orange) aufruft.  In jeder dieser beiden Funktionen haben Sie Zugriff auf% dr0,% dr1, ... Die Argumente werden jedoch √ºber die sogenannten Rotationsregister weitergeleitet.  Mit anderen Worten, ein Teil der Register von Fenster 1 wird zu den Registern von Fenster 2 (beachten Sie, dass sich diese beiden Fenster schneiden).  Diese Register werden ebenfalls vom Fenster eingestellt (siehe Rotationsregister im Bild) und haben die Adresse% db [0],% db [1], ... Somit ist das% dr0-Register in Fenster 2 nichts anderes als das% db [0] -Register in Fenster 1. <br><br>  Das Rotationsregisterfenster wird durch die Operation setbn festgelegt: <br><br><pre> <code class="cpp hljs"> setbn rbs = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rsz = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  rbs legt die Gr√∂√üe des gedrehten Fensters fest und rsz legt die Basisadresse fest, jedoch relativ zum aktuellen Registerfenster.  Das hei√üt,  Hier haben wir ab dem 8. 3 Register zugeordnet. <br><br>  Basierend auf dem Vorstehenden zeigen wir, wie der Funktionsaufruf aussieht.  Der Einfachheit halber nehmen wir an, dass die Funktion ein Argument akzeptiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Um diese Funktion aufzurufen, m√ºssen Sie ein Fenster mit Rotationsregistern vorbereiten (dies haben wir bereits √ºber setbn getan).  Als n√§chstes geben wir im% db0-Register den Wert ein, der an my_func √ºbergeben wird.  Danach m√ºssen Sie die CALL-Anweisung aufrufen und nicht vergessen, ihr mitzuteilen, wo das Fenster der gedrehten Register beginnt.  Wir √ºberspringen jetzt die Vorbereitung f√ºr den Anruf (den Befehl disp), da nicht zwischen Gro√ü- und Kleinschreibung unterschieden wird.  In Assembler sollte ein Aufruf dieser Funktion daher folgenderma√üen aussehen: <br><br><pre> <code class="cpp hljs"> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, my_func call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  Also, mit Registern ein wenig herausgefunden.  Schauen wir uns nun den Stapel verbindlicher Informationen an.  Es speichert die sogenannten CR-Register.  In der Tat zwei - CR0, CR1.  Und sie enthalten bereits die Informationen, die f√ºr die R√ºckkehr von der Funktion erforderlich sind. <br><br><img src="https://habrastorage.org/webt/rc/8q/kl/rc8qklg-pb3tgwv3jjz_8pc6l3g.png"><br><br>  Die Register CR0 und CR1 des Fensters der Funktion, die die Funktion mit den orange markierten Registern aufgerufen hat, sind gr√ºn.  Die CR0-Register enthalten den Anweisungszeiger der aufrufenden Funktion und eine bestimmte Pr√§dikatdatei (PF-Pr√§dikatdatei). Eine Geschichte dar√ºber geht definitiv √ºber den Rahmen dieses Artikels hinaus. <br><br>  Die CR1-Register enthalten Daten wie PSR (Textverarbeitungsstatus), Fensternummer, Fenstergr√∂√üen usw.  In Elbrus ist alles so flexibel, dass jede Prozedur Informationen in CR1 speichert, selbst dar√ºber, ob Gleitkommaoperationen in der Prozedur enthalten sind, und ein Register, das Informationen zu Software-Ausnahmen enth√§lt. Daf√ºr m√ºssen Sie nat√ºrlich f√ºr das Speichern zus√§tzlicher Informationen bezahlen. <br><br>  Es ist sehr wichtig, nicht zu vergessen, dass die Registerdatei und die Bindungsinformationsdatei aus dem RAM herausgepumpt und ausgetauscht werden k√∂nnen und umgekehrt (von den oben beschriebenen PS- und PCS-Stapeln).  Dieser Punkt ist wichtig bei der Implementierung von setjmp, das sp√§ter beschrieben wird. <br><br><h3>  SETJMP / LONGJMP </h3><br>  Und schlie√ülich, wenn Sie zumindest irgendwie verstehen, wie die Stapel und Register in Elbrus angeordnet sind, k√∂nnen Sie damit beginnen, etwas N√ºtzliches zu tun, dh Embox neue Funktionen hinzuzuf√ºgen. <br><br>  In Embox ben√∂tigt das Unit-Testing-System setjmp / longjmp, daher mussten wir diese Funktionen implementieren. <br><br>  F√ºr die Implementierung m√ºssen die Register CR0, CR1, PSP, PCSP, USD gespeichert / wiederhergestellt werden - die uns bereits aus einer kurzen Einf√ºhrung bekannt sind.  Tats√§chlich ist das Speichern / Wiederherstellen in unserer Stirn implementiert, aber es gibt eine signifikante Nuance, die in der Beschreibung von Stapeln und Registern h√§ufig angedeutet wurde, n√§mlich: Stapel sollten synchronisiert werden, da sie sich nicht nur im Speicher, sondern auch in der Registerdatei befinden.  Diese Nuance bedeutet, dass Sie sich um mehrere Funktionen k√ºmmern m√ºssen, ohne die nichts funktioniert. <br><br>  Die erste Funktion besteht darin, Interrupts w√§hrend des Speicherns und Wiederherstellens zu deaktivieren.  Wenn Sie einen Interrupt wiederherstellen, m√ºssen Sie ihn unbedingt verbieten. Andernfalls kann es vorkommen, dass wir den Interrupt-Handler mit halbgeschalteten Stapeln aufrufen (siehe Auspumpen des in der ‚ÄûKurzbeschreibung‚Äú beschriebenen Austauschs der Registerdateien).  Und beim Speichern besteht das Problem darin, dass der Prozessor nach dem Eintreten und Verlassen des Interrupts wieder einen Teil der Registerdatei aus dem RAM austauschen kann (und dies ruiniert die unver√§nderlichen Bedingungen PSHTP = 0 und PSCHTP = 0, etwas mehr √ºber sie).  Aus diesem Grund m√ºssen Interrupts sowohl in setjmp als auch in longjmp deaktiviert werden.  Hierbei ist auch zu beachten, dass Spezialisten des MCST uns empfohlen haben, atomare Klammern zu verwenden, anstatt Interrupts zu deaktivieren. Derzeit verwenden wir jedoch die einfachste (f√ºr uns verst√§ndliche) Implementierung. <br><br>  Die zweite Funktion bezieht sich auf das Abpumpen / Auspumpen einer Registerdatei aus dem Speicher.  Es ist wie folgt.  Die Registerdatei hat eine begrenzte Gr√∂√üe und wird daher h√§ufig in den Speicher gepumpt und umgekehrt.  Wenn wir also einfach die Werte der PSP- und PSHTP-Register speichern, legen wir den Wert des aktuellen Zeigers im Speicher und in der Registerdatei fest.  Da sich die Registerdatei jedoch √§ndert, werden zum Zeitpunkt der Kontextwiederherstellung bereits falsche (nicht die von uns "gespeicherten") Daten angezeigt.  Um dies zu vermeiden, m√ºssen Sie die gesamte Registerdatei in den Speicher leeren.  Wenn wir also in setjmp speichern, haben wir PSP.ind-Register im Speicher und PSHTP.ind-Register im Registerfenster.  Es stellt sich heraus, dass Sie die gesamten Register PCSP.ind + PCSHTP.ind speichern m√ºssen.  Die folgende Funktion f√ºhrt diese Operation aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PCSP, 2nd arg is PCSHTP * Returns new PCSP value with updated PCSP.ind */</span></span> .type update_pcsp_ind,@function $update_pcsp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 10 is size of PCSHTP.ind. Here we * extend the sign of PCSHTP.ind */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PCSP.ind += PCSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  Es ist auch notwendig, einen kleinen Punkt in diesem im Kommentar beschriebenen Code zu verdeutlichen, n√§mlich das Zeichen im Index PCSHTP.ind programmgesteuert zu erweitern, da der Index negativ sein und in zus√§tzlichem Code gespeichert werden kann.  Dazu wechseln wir zuerst zu (64-10) nach links (64-Bit-Register), zu einem 10-Bit-Feld und dann zur√ºck. <br><br>  Gleiches gilt f√ºr die PSP (Procedure Stack) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PSP, 2nd arg is PSHTP * Returns new PSP value with updated PSP.ind */</span></span> .type update_psp_ind,@function $update_psp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 12 is size of PSHTP.ind. Here we * extend the sign of PSHTP.ind as stated in documentation */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 muld %dr1, <span class="hljs-number"><span class="hljs-number">2</span></span>, %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PSP.ind += PSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  Mit einem kleinen Unterschied (das Feld ist 12 Bit, und die Register werden dort in 128-Bit-Begriffen gez√§hlt, dh der Wert muss mit 2 multipliziert werden). <br><br>  Setjmp Code selbst <br><br><pre> <code class="cpp hljs">C_ENTRY(setjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* It's for db[N] registers */</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* Store some registers to jmp_buf */</span></span> rrd %cr0.hi, %dr1 rrd %cr1.lo, %dr2 rrd %cr1.hi, %dr3 rrd %usd.lo, %dr4 rrd %usd.hi, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* Prepare RF stack to flush in longjmp */</span></span> rrd %psp.hi, %dr6 rrd %pshtp, %dr7 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr6, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_psp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr6 <span class="hljs-comment"><span class="hljs-comment">/* Prepare CF stack to flush in longjmp */</span></span> rrd %pcsp.hi, %dr7 rrd %pcshtp, %dr8 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr8, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_pcsp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr7 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + E2K_JMBBUFF_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_JMBBUFF_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_JMBBUFF_CR1_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_JMBBUFF_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_JMBBUFF_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_JMBBUFF_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_JMBBUFF_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* return 0 */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, %r0 E2K_ASM_RETURN</code> </pre> <br>  Bei der Implementierung von longjmp ist es wichtig, die Synchronisation beider Registerdateien nicht zu vergessen. Daher m√ºssen Sie nicht nur das Registerfenster (flushr), sondern auch die Binderdatei (flushc) leeren.  Beschreiben wir das Makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_ASM_FLUSH_CPU \ flushr; \ nop 2; \ flushc; \ nop 3;</span></span></code> </pre> <br>  Jetzt, da alle Informationen im Speicher sind, k√∂nnen wir die Wiederherstellung in longjmp sicher registrieren. <br><br><pre> <code class="cpp hljs">C_ENTRY(longjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* We have to flush both RF and CF to memory because saved values * of P[C]SHTP can be not valid here. */</span></span> E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Load registers previously saved in setjmp. */</span></span> ldd [%dr0 + E2K_JMBBUFF_CR0_HI], %dr2 ldd [%dr0 + E2K_JMBBUFF_CR1_LO], %dr3 ldd [%dr0 + E2K_JMBBUFF_CR1_HI], %dr4 ldd [%dr0 + E2K_JMBBUFF_USD_LO], %dr5 ldd [%dr0 + E2K_JMBBUFF_USD_HI], %dr6 ldd [%dr0 + E2K_JMBBUFF_PSP_HI], %dr7 ldd [%dr0 + E2K_JMBBUFF_PCSP_HI], %dr8 rwd %dr2, %cr0.hi rwd %dr3, %cr1.lo rwd %dr4, %cr1.hi rwd %dr5, %usd.lo rwd %dr6, %usd.hi rwd %dr7, %psp.hi rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Actually, we return to setjmp caller with second * argument of longjmp stored on r1 register. */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, %r1, %r0 E2K_ASM_RETURN</code> </pre> <br><h3>  Kontextwechsel </h3><br>  Nachdem wir setjmp / longjmp herausgefunden hatten, schien uns die grundlegende Implementierung von context_switch klar genug zu sein.  In der Tat m√ºssen wir wie im ersten Fall die Register der Verbindungsinformationen und Stapel speichern / wiederherstellen und das Prozessorstatusregister (UPSR) korrekt wiederherstellen. <br><br>  Ich werde es erkl√§ren.  Wie im Fall von setjmp m√ºssen Sie beim Speichern von Registern zuerst die Registerdatei und die Bindungsinformationsdatei in den Speicher zur√ºcksetzen (flushr + flushc).  Danach m√ºssen wir die aktuellen Werte der Register CR0 und CR1 speichern, damit wir bei unserer R√ºckkehr genau dorthin springen, von wo der aktuelle Stream umgeschaltet wurde.  Als N√§chstes speichern wir die Deskriptoren der PS-, PCS- und US-Stapel.  Und schlie√ülich m√ºssen Sie f√ºr die korrekte Wiederherstellung des Interrupt-Modus sorgen - f√ºr diese Zwecke speichern wir auch das UPSR-Register. <br><br>  Assembler-Code context_switch: <br><br><pre> <code class="cpp hljs">C_ENTRY(context_switch): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Save prev UPSR */</span></span> rrd %upsr, %dr2 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_UPSR] <span class="hljs-comment"><span class="hljs-comment">/* Disable interrupts before saving/restoring context */</span></span> rrd %upsr, %dr2 andnd %dr2, (UPSR_IE | UPSR_NMIE), %dr2 rwd %dr2, %upsr E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Save prev CRs */</span></span> rrd %cr0.lo, %dr2 rrd %cr0.hi, %dr3 rrd %cr1.lo, %dr4 rrd %cr1.hi, %dr5 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_CR0_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_CR1_HI] <span class="hljs-comment"><span class="hljs-comment">/* Save prev stacks */</span></span> rrd %usd.lo, %dr3 rrd %usd.hi, %dr4 rrd %psp.lo, %dr5 rrd %psp.hi, %dr6 rrd %pcsp.lo, %dr7 rrd %pcsp.hi, %dr8 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_PSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_CTX_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_CTX_PCSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr8, [%dr0 + E2K_CTX_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Load next CRs */</span></span> ldd [%dr1 + E2K_CTX_CR0_LO], %dr2 ldd [%dr1 + E2K_CTX_CR0_HI], %dr3 ldd [%dr1 + E2K_CTX_CR1_LO], %dr4 ldd [%dr1 + E2K_CTX_CR1_HI], %dr5 rwd %dr2, %cr0.lo rwd %dr3, %cr0.hi rwd %dr4, %cr1.lo rwd %dr5, %cr1.hi <span class="hljs-comment"><span class="hljs-comment">/* Load next stacks */</span></span> ldd [%dr1 + E2K_CTX_USD_LO], %dr3 ldd [%dr1 + E2K_CTX_USD_HI], %dr4 ldd [%dr1 + E2K_CTX_PSP_LO], %dr5 ldd [%dr1 + E2K_CTX_PSP_HI], %dr6 ldd [%dr1 + E2K_CTX_PCSP_LO], %dr7 ldd [%dr1 + E2K_CTX_PCSP_HI], %dr8 rwd %dr3, %usd.lo rwd %dr4, %usd.hi rwd %dr5, %psp.lo rwd %dr6, %psp.hi rwd %dr7, %pcsp.lo rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Restore next UPSR */</span></span> ldd [%dr1 + E2K_CTX_UPSR], %dr2 rwd %dr2, %upsr E2K_ASM_RETURN</code> </pre> <br>  Ein weiterer wichtiger Punkt ist die Initialisierung des Betriebssystem-Threads.  In Embox hat jeder Thread eine bestimmte prim√§re Prozedur <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _<span class="hljs-function"><span class="hljs-function">NORETURN </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_trampoline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  in dem alle weiteren Arbeiten des Streams ausgef√ºhrt werden.  Daher m√ºssen wir die Stapel irgendwie f√ºr den Aufruf dieser Funktion vorbereiten. Hier sehen wir uns mit der Tatsache konfrontiert, dass es drei Stapel gibt, die nicht in die gleiche Richtung wachsen.  Durch die Architektur erstellen wir einen Stream mit einem einzelnen Stapel, oder besser gesagt, er hat eine einzelne Stelle unter dem Stapel. Oben haben wir eine Struktur, die den Stream selbst beschreibt. Hier mussten wir uns um verschiedene Stapel k√ºmmern, um nicht zu vergessen, dass sie ausgerichtet werden sollten 4 kB, vergessen Sie nicht alle Arten von Zugriffsrechten und so weiter. <br><br>  Aus diesem Grund haben wir im Moment beschlossen, den Platz unter dem Stapel in drei Teile zu unterteilen, ein Viertel unter dem Stapel verbindlicher Informationen, ein Viertel unter dem prozeduralen Stapel und die H√§lfte unter dem Benutzerstapel. <br><br><div class="spoiler">  <b class="spoiler_title">Ich bringe den Code mit, damit Sie beurteilen k√∂nnen, wie gro√ü er ist. Sie m√ºssen ber√ºcksichtigen, dass dies eine minimale Initialisierung ist.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* This value is used for both stack base and size align. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_STACK_ALIGN (1UL </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 12) #define round_down(x, bound) ((x) &amp; ~((bound) - 1)) /* Reserve 1/4 for PSP stack, 1/4 for PCSP stack, and 1/2 for USD stack */ #define PSP_CALC_STACK_BASE(sp, size) binalign_bound(sp - size, E2K_STACK_ALIGN) #define PSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define PCSP_CALC_STACK_BASE(sp, size) \ (PSP_CALC_STACK_BASE(sp, size) + PSP_CALC_STACK_SIZE(sp, size)) #define PCSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define USD_CALC_STACK_BASE(sp, size) round_down(sp, E2K_STACK_ALIGN) #define USD_CALC_STACK_SIZE(sp, size) \ round_down(USD_CALC_STACK_BASE(sp, size) - PCSP_CALC_STACK_BASE(sp, size),\ E2K_STACK_ALIGN) static void e2k_calculate_stacks(struct context *ctx, uint64_t sp, uint64_t size) { uint64_t psp_size, pcsp_size, usd_size; log_debug("Stacks:\n"); ctx-&gt;psp_lo |= PSP_CALC_STACK_BASE(sp, size) &lt;&lt; PSP_BASE; ctx-&gt;psp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PSP_RW; psp_size = PSP_CALC_STACK_SIZE(sp, size); assert(psp_size); ctx-&gt;psp_hi |= psp_size &lt;&lt; PSP_SIZE; log_debug(" PSP.base=0x%lx, PSP.size=0x%lx\n", PSP_CALC_STACK_BASE(sp, size), psp_size); ctx-&gt;pcsp_lo |= PCSP_CALC_STACK_BASE(sp, size) &lt;&lt; PCSP_BASE; ctx-&gt;pcsp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PCSP_RW; pcsp_size = PCSP_CALC_STACK_SIZE(sp, size); assert(pcsp_size); ctx-&gt;pcsp_hi |= pcsp_size &lt;&lt; PCSP_SIZE; log_debug(" PCSP.base=0x%lx, PCSP.size=0x%lx\n", PCSP_CALC_STACK_BASE(sp, size), pcsp_size); ctx-&gt;usd_lo |= USD_CALC_STACK_BASE(sp, size) &lt;&lt; USD_BASE; usd_size = USD_CALC_STACK_SIZE(sp, size); assert(usd_size); ctx-&gt;usd_hi |= usd_size &lt;&lt; USD_SIZE; log_debug(" USD.base=0x%lx, USD.size=0x%lx\n", USD_CALC_STACK_BASE(sp, size), usd_size); } static void e2k_calculate_crs(struct context *ctx, uint64_t routine_addr) { uint64_t usd_size = (ctx-&gt;usd_hi &gt;&gt; USD_SIZE) &amp; USD_SIZE_MASK; /* Reserve space in hardware stacks for @routine_addr */ /* Remark: We do not update psp.hi to reserve space for arguments, * since routine do not accepts any arguments. */ ctx-&gt;pcsp_hi |= SZ_OF_CR0_CR1 &lt;&lt; PCSP_IND; ctx-&gt;cr0_hi |= (routine_addr &gt;&gt; CR0_IP) &lt;&lt; CR0_IP; ctx-&gt;cr1_lo |= PSR_ALL_IRQ_ENABLED &lt;&lt; CR1_PSR; /* Divide on 16 because it field contains size in terms * of 128 bit values. */ ctx-&gt;cr1_hi |= (usd_size &gt;&gt; 4) &lt;&lt; CR1_USSZ; } void context_init(struct context *ctx, unsigned int flags, void (*routine_fn)(void), void *sp, unsigned int stack_size) { memset(ctx, 0, sizeof(*ctx)); e2k_calculate_stacks(ctx, sp, stack_size); e2k_calculate_crs(ctx, (uint64_t) routine_fn); if (!(flags &amp; CONTEXT_IRQDISABLE)) { ctx-&gt;upsr |= (UPSR_IE | UPSR_NMIE); } }</span></span></span></span></code> </pre> <br></div></div><br>  Der Artikel enthielt auch Arbeiten mit Interrupts, Ausnahmen und Timern, aber da er so gro√ü ausfiel, beschlossen wir, im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chsten Teil dar√ºber</a> zu sprechen. <br><br>  Nur f√ºr den Fall, ich wiederhole, dieses Material ist keine offizielle Dokumentation!  F√ºr offizielle Unterst√ºtzung, Dokumentation und den Rest m√ºssen Sie sich direkt an das ICST wenden.  Der Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Embox</a> ist nat√ºrlich offen, aber um ihn zu kompilieren, ben√∂tigen Sie einen Cross-Compiler, der wiederum vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MCST bezogen werden kann</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447704/">https://habr.com/ru/post/de447704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447694/index.html">Kompilierte verteilte Systemkonfiguration</a></li>
<li><a href="../de447696/index.html">Warum St√§dte gegen Amazon Go sind, die ersten bargeldlosen Gesch√§fte</a></li>
<li><a href="../de447698/index.html">Red Hogwarts: Akademiker ohne Diplom</a></li>
<li><a href="../de447700/index.html">Emotionale Flexibilit√§t ist der Schl√ºssel zum pers√∂nlichen Wachstum.</a></li>
<li><a href="../de447702/index.html">Der ideale mathematische Kreis existiert nicht</a></li>
<li><a href="../de447706/index.html">Kein einziger ORM</a></li>
<li><a href="../de447708/index.html">Yandex √ºberreichte jungen Wissenschaftlern und Wissenschaftlern die ersten Ilya Segalovich-Preise</a></li>
<li><a href="../de447712/index.html">Hallo, SaaS | Russische SaaS 2018 - Ergebnisse</a></li>
<li><a href="../de447714/index.html">Zur Anwendung der Theorie der ARMA-Prozesse in der Ingenieurpraxis</a></li>
<li><a href="../de447716/index.html">Einheit: Zeichnen Sie viele Gesundheitsbalken in einem Zug</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>