<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüè´ üè¨ üë©üèº‚Äçüç≥ Wenig bekannte JavaScript-Funktionen üï≥Ô∏è ü§∑üèø üë©üèº‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript wird oft als die einfachste Sprache f√ºr Anf√§nger bezeichnet, in der Programmierung, die am schwierigsten zu beherrschen ist. Der Autor des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wenig bekannte JavaScript-Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431878/">  JavaScript wird oft als die einfachste Sprache f√ºr Anf√§nger bezeichnet, in der Programmierung, die am schwierigsten zu beherrschen ist.  Der Autor des Materials, dessen √úbersetzung wir ver√∂ffentlichen, sagt, dass er dieser Aussage nur zustimmen kann.  Die Sache ist, dass JS eine sehr alte und sehr flexible Sprache ist.  Es ist voll von mysteri√∂sen syntaktischen Konstrukten und veralteten Funktionen, die es immer noch unterst√ºtzt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/bdc/ddf/340/bdcddf340ecf674873a62e6e8c38b38b.jpg" alt="Bild"></a> <br><br>  Heute werden wir √ºber die wenig bekannten JavaScript-Funktionen und -Optionen f√ºr ihre praktische Anwendung sprechen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript ist immer etwas Neues</font> </h2><br>  Ich arbeite seit vielen Jahren mit JavaScript und sto√üe st√§ndig auf etwas, von dem ich nicht vermutete, dass es es gibt.  Hier habe ich versucht, √§hnliche wenig bekannte Merkmale der Sprache aufzulisten.  Im strengen Modus funktionieren einige von ihnen nicht, im normalen Modus sind sie jedoch vollst√§ndig korrekte JS-Codebeispiele.  Es sollte angemerkt werden, dass ich nicht davon ausgehe, den Lesern zu raten, all dies in Betrieb zu nehmen.  Obwohl das, wor√ºber ich sprechen werde, f√ºr Sie sehr interessant erscheint, k√∂nnen Sie all dies nutzen, wenn Sie in einem Team arbeiten und, gelinde gesagt, Ihre Kollegen √ºberraschen. <br><br>  ‚Üí Den Code, den wir hier diskutieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier.</a> <br><br>  Bitte beachten Sie, dass ich Dinge wie das Ausl√∂sen von Variablen, Schlie√üungen, Proxy-Objekten, Prototyp-Vererbung, Async / Warten, Generatoren und dergleichen nicht ber√ºcksichtigt habe.  Obwohl diese Merkmale der Sprache schwer zu verstehen sind, sind sie nicht bekannt. <br><br><h2>  <font color="#3AC1EF">Leerer Operator</font> </h2><br>  JavaScript hat einen un√§ren <code>void</code> Operator.  M√∂glicherweise sind Sie in Form von <code>void(0)</code> oder <code>void 0</code> .  Sein einziger Zweck ist es, den Ausdruck zu seiner Rechten zu berechnen und <code>undefined</code> .  <code>0</code> hier wird es einfach verwendet, weil es √ºblich ist, obwohl dies nicht notwendig ist, und hier k√∂nnen Sie jeden g√ºltigen Ausdruck verwenden.  True, dieser Operator gibt auf jeden Fall <code>undefined</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  void void 0                  // undefined void (0)                // undefined void 'abc'              // undefined void {}                 // undefined void (1 === 1)          // undefined void (1 !== 1)          // undefined void anyfunction()      // undefined</span></span></code> </pre> <br>  Warum der Sprache, die zur R√ºckgabe von <code>undefined</code> dient, ein spezielles Schl√ºsselwort hinzuf√ºgen, wenn Sie nur den Standardwert <code>undefined</code> ?  Ist es nicht so, gibt es eine gewisse Redundanz? <br><br>  Wie sich herausstellte, konnte vor dem Erscheinen des ES5-Standards in den meisten Browsern einem Standardwert von <code>undefined</code> ein neuer Wert zugewiesen werden.  Angenommen, Sie k√∂nnten diesen Befehl erfolgreich ausf√ºhren: <code>undefined = "abc"</code> .  Infolgedessen ist ein <code>undefined</code> Wert m√∂glicherweise nicht so, wie er sein sollte.  In jenen Tagen erm√∂glichte uns die Verwendung von <code>void</code> , das Vertrauen in die Verwendung des echten <code>undefined</code> zu gew√§hrleisten. <br><br><h2>  <font color="#3AC1EF">Klammern beim Aufrufen von Konstruktoren sind optional</font> </h2><br>  Die Klammern, die nach dem Klassennamen eingef√ºgt werden und den Konstruktor aufrufen, sind vollst√§ndig optional (es sei denn, der Konstruktor muss Argumente √ºbergeben). <br><br>  Im folgenden Beispiel wirkt sich das Vorhandensein oder Fehlen von Klammern nicht auf den korrekten Betrieb des Programms aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     const date = new Date() const month = new Date().getMonth() const myInstance = new MyClass() //     const date = new Date const month = (new Date).getMonth() const myInstance = new MyClass</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Klammern k√∂nnen nicht mit IIFE verwendet werden</font> </h2><br>  Die IIFE-Syntax erschien mir immer seltsam.  Warum gibt es all diese Klammern? <br><br>  Wie sich herausstellte, werden die Klammern nur ben√∂tigt, um dem JavaScript-Parser mitzuteilen, dass ein Code ein Funktionsausdruck ist und kein falscher Versuch, eine Funktion zu deklarieren.  Wenn wir diese Tatsache kennen, k√∂nnen wir verstehen, dass es viele M√∂glichkeiten gibt, die Klammern, in denen IIFE eingeschlossen ist, zu entfernen und gleichzeitig Arbeitscode zu schreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// IIFE (function () { console.log('Normal IIFE called') })() // Normal IIFE called void function () { console.log('Cool IIFE called') }() // Cool IIFE called</span></span></code> </pre> <br>  Hier teilt der <code>void</code> Operator dem Parser mit, dass der darauf folgende Code ein Funktionsausdruck ist.  Dies erm√∂glicht es, die Klammern um die Funktionsdeklaration zu entfernen.  √úbrigens k√∂nnen Sie hier jeden un√§ren Operator verwenden ( <code>void</code> , <code>+</code> , <code>!</code> , <code>-</code> usw.), und der Code funktioniert weiterhin.  Ist das nicht wunderbar? <br><br>  Wenn Sie jedoch ein aufmerksamer Leser sind, fragen Sie sich m√∂glicherweise, ob der un√§re Operator das von IIFE zur√ºckgegebene Ergebnis beeinflusst.  In der Tat so wie es ist.  Das Gute ist jedoch, dass Sie keine Klammern um IIFE ben√∂tigen, wenn Sie das Ergebnis von IIFE ben√∂tigen, das Sie beispielsweise in einer Variablen speichern.  Hier ist ein Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// IIFE,    let result = (function () { // ... -  return 'Victor Sully' })() console.log(result) // Victor Sully let result1 = function () { // ... -  return 'Nathan Drake' }() console.log(result1) // Nathan Drake</span></span></code> </pre> <br>  Die geschweiften Klammern um das erste IIFE verbessern nur die Lesbarkeit des Codes, ohne dessen Betrieb zu beeintr√§chtigen. <br><br>  Wenn Sie IIFE besser verstehen m√∂chten, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material an. <br><br><h2>  <font color="#3AC1EF">Bau mit</font> </h2><br>  Wissen Sie, dass JavaScript ein <code>with</code> Konstrukt hat, das Ausdrucksbl√∂cke unterst√ºtzt?  Es sieht so aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (object)  statement <span class="hljs-comment"><span class="hljs-comment">//       with (object) {  statement  statement  ... }</span></span></code> </pre> <br>  Das Konstrukt <code>with</code> f√ºgt alle Eigenschaften des Objekts hinzu, das in der Bereichskette √ºbergeben wird, die beim Ausf√ºhren der Befehle verwendet wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    with const person = { firstname: 'Nathan', lastname: 'Drake', age: 29 } with (person) { console.log(`${firstname} ${lastname} is ${age} years old`) } // Nathan Drake is 29 years old</span></span></code> </pre> <br>  <code>with</code> mag wie ein tolles Werkzeug erscheinen.  Es scheint sogar noch besser zu sein als die neuen Funktionen von JS f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektzerst√∂rung</a> , aber tats√§chlich ist es nicht so. <br><br>  Die <code>with</code> Konstruktion ist veraltet und wird nicht zur Verwendung empfohlen.  Im strengen Modus ist seine Verwendung verboten.  Es stellt sich heraus, dass Bl√∂cke Leistungs- und Sicherheitsprobleme verursachen. <br><br><h2>  <font color="#3AC1EF">Funktionskonstruktor</font> </h2><br>  Die Verwendung des <code>function</code> ist nicht die einzige M√∂glichkeit, eine neue Funktion zu definieren.  Sie k√∂nnen Funktionen dynamisch mit dem <code>Function</code> und dem <code>new</code> Operator definieren.  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Function const multiply = new Function('x', 'y', 'return x*y') multiply(2,3) // 6</span></span></code> </pre> <br>  Das letzte an den Konstruktor √ºbergebene Argument ist eine Zeichenfolge mit dem Funktionscode.  Zwei weitere Argumente sind Funktionsparameter. <br><br>  Es ist interessant festzustellen, dass der <code>Function</code> das "√ºbergeordnete" Element aller Konstruktoren in JavaScript ist.  Sogar der <code>Object</code> ist ein <code>Function</code> .  Und der native <code>Function</code> ist auch <code>Function</code> .  Infolgedessen gibt ein Aufruf vom Typ <code>object.constructor.constructor...</code> der f√ºr ein JS-Objekt ausreichend oft ausgef√ºhrt wurde, den <code>Function</code> als Ergebnis zur√ºck. <br><br><h2>  <font color="#3AC1EF">Feature-Eigenschaften</font> </h2><br>  Wir alle wissen, dass Funktionen in JavaScript erstklassige Objekte sind.  Daher hindert uns niemand daran, Funktionen neue Eigenschaften hinzuzuf√ºgen.  Dies ist v√∂llig normal, wird aber selten verwendet. <br><br>  Wann kann das n√∂tig sein? <br><br>  In der Tat gibt es mehrere Situationen, in denen diese Funktion n√ºtzlich sein kann.  Betrachten Sie sie. <br><br><h3>  <font color="#3AC1EF">‚ñç Benutzerdefinierte Funktionen</font> </h3><br>  Angenommen, wir haben eine <code>greet()</code> Funktion.  Sie muss je nach den verwendeten regionalen Einstellungen unterschiedliche Begr√º√üungsnachrichten anzeigen.  Diese Einstellungen k√∂nnen in einer Variablen au√üerhalb der Funktion gespeichert werden.  Dar√ºber hinaus verf√ºgt die Funktion m√∂glicherweise √ºber eine Eigenschaft, die diese Einstellungen definiert, insbesondere die Spracheinstellungen des Benutzers.  Wir werden den zweiten Ansatz verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   function greet () { if (greet.locale === 'fr') {   console.log('Bonjour!') } else if (greet.locale === 'es') {   console.log('Hola!') } else {   console.log('Hello!') } } greet() // Hello! greet.locale = 'fr' greet() // Bonjour!</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçFunktionen mit statischen Variablen</font> </h3><br>  Hier ist ein weiteres √§hnliches Beispiel.  Angenommen, wir m√ºssen einen bestimmten Generator implementieren, der eine Folge von geordneten Zahlen erzeugt.  In solchen Situationen werden normalerweise statische Z√§hlervariablen in Klassen oder IIFE verwendet, um Informationen √ºber die zuletzt generierte Zahl zu speichern.  Mit diesem Ansatz beschr√§nken wir den Zugang zum Schalter und verhindern die Verschmutzung des globalen Bereichs durch zus√§tzliche Variablen. <br><br>  Aber was ist, wenn wir Flexibilit√§t brauchen, wenn wir den Wert eines solchen Z√§hlers lesen oder sogar √§ndern m√ºssen und den globalen Bereich nicht verstopfen? <br><br>  Nat√ºrlich k√∂nnen Sie eine Klasse mit der entsprechenden Variablen und mit Methoden erstellen, um damit zu arbeiten.  Oder Sie k√∂nnen sich nicht mit solchen Dingen besch√§ftigen und nur die Eigenschaften von Funktionen nutzen. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   function generateNumber () { if (!generateNumber.counter) {   generateNumber.counter = 0 } return ++generateNumber.counter } console.log(generateNumber()) // 1 console.log(generateNumber()) // 2 console.log('current counter value: ', generateNumber.counter) // current counter value: 2 generateNumber.counter = 10 console.log('current counter value: ', generateNumber.counter) // current counter value: 10 console.log(generateNumber()) // 11</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Argumente Objekteigenschaften</font> </h2><br>  Ich bin sicher, die meisten von Ihnen wissen, dass Funktionen ein <code>arguments</code> .  Dies ist ein Array-√§hnliches Objekt, auf das in allen Funktionen zugegriffen werden kann (mit Ausnahme von Pfeilfunktionen, die kein eigenes <code>arguments</code> ).  Es enth√§lt eine Liste von Argumenten, die beim Aufruf an die Funktion √ºbergeben wurden.  Dar√ºber hinaus hat es einige interessante Eigenschaften: <br><br><ul><li>  <code>arguments.callee</code> enth√§lt einen Link zur aktuellen Funktion. </li><li>  <code>arguments.caller</code> enth√§lt einen Verweis auf die Funktion, die die aktuelle Funktion aufgerufen hat. </li></ul><br>  Betrachten Sie ein Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  callee  caller  arguments const myFunction = function () { console.log('Current function: ', arguments.callee.name) console.log('Invoked by function: ', arguments.callee.caller.name) } void function main () { myFunction() } () // Current function: myFunction // Invoked by function: main</span></span></code> </pre> <br>  Der ES5-Standard verbietet die Verwendung von <code>callee</code> und <code>callee</code> im strengen Modus, ist jedoch in vielen mit JavaScript kompilierten Programmtexten, z. B. in Bibliotheken, noch weit verbreitet.  Daher ist es n√ºtzlich, √ºber sie Bescheid zu wissen. <br><br><h2>  <font color="#3AC1EF">Tagged Template Literals</font> </h2><br>  Wenn Sie etwas mit JavaScript-Programmierung zu tun haben, haben Sie sicherlich von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlagenliteralen geh√∂rt</a> .  Vorlagenliterale sind eine der vielen gro√üen Innovationen des ES6-Standards.  Kennen Sie jedoch markierte Vorlagenliterale? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    `Hello ${username}!` //    myTag`Hello ${username}!`</span></span></code> </pre> <br>  Mit markierten Vorlagenliteralen kann der Entwickler steuern, wie aus dem Vorlagenliteral eine Zeichenfolge wird.  Dies erfolgt mithilfe spezieller Tags.  Ein Tag ist nur der Name einer Parserfunktion, die ein Array von Zeichenfolgen und Werten empf√§ngt, die von einem Zeichenfolgenmuster interpretiert werden.  Bei Verwendung einer Tag-Funktion wird erwartet, dass die fertige Zeichenfolge zur√ºckgegeben wird. <br><br>  Im folgenden Beispiel interpretiert unser Tag " <code>highlight</code> die Daten eines Vorlagenliterals und bettet diese Daten in eine fertige Zeile ein. Platzieren Sie sie im HTML-Tag <code>&lt;mark&gt;</code> , um sie auszuw√§hlen, wenn dieser Text auf einer Webseite angezeigt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    function highlight(strings, ...values) { //  i -      let result = '' strings.forEach((str, i) =&gt; {   result += str   if (values[i]) {     result += `&lt;mark&gt;${values[i]}&lt;/mark&gt;`   } }) return result } const author = 'Henry Avery' const statement = `I am a man of fortune &amp; I must seek my fortune` const quote = highlight`${author} once said, ${statement}` // &lt;mark&gt;Henry Avery&lt;/mark&gt; once said, &lt;mark&gt;I am a man of fortune // &amp; I must seek my fortune&lt;/mark&gt;</span></span></code> </pre> <br>  Interessante M√∂glichkeiten zur Verwendung dieser Funktion finden Sie in vielen Bibliotheken.  Hier einige Beispiele: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Styled-Komponenten</a> - zur Verwendung in React-Anwendungen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es2015-i18n-tag</a> - zur √úbersetzung und Internationalisierung von Projekten. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kreide</a> - zur Ausgabe mehrfarbiger Nachrichten an die Konsole. </li></ul><br><h2>  <font color="#3AC1EF">Getter und Setter in ES5</font> </h2><br>  JavaScript-Objekte sind gr√∂√ütenteils ziemlich einfach.  Angenommen, wir haben ein <code>user</code> und versuchen, mit dem Konstrukt <code>user.age</code> auf seine Eigenschaft <code>age</code> <code>user.age</code> .  Wenn bei diesem Ansatz diese Eigenschaft definiert ist, erhalten wir ihren Wert, und wenn sie nicht definiert ist, werden wir <code>undefined</code> .  Alles ist sehr einfach. <br><br>  Das Arbeiten mit Eigenschaften muss jedoch gar nicht so primitiv sein.  JS-Objekte implementieren das Konzept von Gettern und Setzern.  Anstatt den Wert einer Eigenschaft des Objekts direkt zur√ºckzugeben, k√∂nnen wir unsere eigene Getter-Funktion schreiben, die das zur√ºckgibt, was wir f√ºr notwendig halten.  Gleiches gilt f√ºr das Schreiben neuer Werte in die Eigenschaften mithilfe von Setterfunktionen. <br><br>  Mit Gettern und Setzern k√∂nnen Sie erweiterte Schemata f√ºr die Arbeit mit Eigenschaften implementieren.  Beim Lesen oder Schreiben von Eigenschaften k√∂nnen Sie die Konzepte virtueller Felder verwenden, die Werte von Feldern √ºberpr√ºfen und beim Schreiben oder Lesen k√∂nnen einige n√ºtzliche Nebenwirkungen auftreten. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const user = { firstName: 'Nathan', lastName: 'Drake', // fullname -    get fullName() {   return this.firstName + ' ' + this.lastName }, //      set age(value) {   if (isNaN(value)) throw Error('Age has to be a number')   this._age = Number(value) }, get age() {   return this._age } } console.log(user.fullName) // Nathan Drake user.firstName = 'Francis' console.log(user.fullName) // Francis Drake user.age = '29' console.log(user.age) // 29 // user.age = 'invalid text' // Error: Age has to be a number</span></span></code> </pre> <br>  Getter und Setter sind keine ES5-Standardinnovationen.  Sie waren immer in der Sprache pr√§sent.  In ES5 wurden nur praktische Syntaxwerkzeuge hinzugef√ºgt, um mit ihnen zu arbeiten.  Details zu Gettern und Setzern finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Beispiele f√ºr die Verwendung von Gettern sind die beliebte Node.js <a href="">Colors-</a> Bibliothek. <br><br>  Diese Bibliothek <a href="">erweitert die String-Klasse</a> und f√ºgt ihr viele Getter-Methoden hinzu.  Auf diese Weise k√∂nnen Sie eine Zeichenfolge in ihre "farbige" Version konvertieren, sodass diese Zeichenfolge dann f√ºr die Protokollierung verwendet werden kann.  Dies erfolgt durch Arbeiten mit Zeichenfolgeneigenschaften. <br><br><h2>  <font color="#3AC1EF">Komma-Operator</font> </h2><br>  JS hat einen Kommaoperator.  Sie k√∂nnen mehrere Ausdr√ºcke in eine einzelne Zeile schreiben, die durch ein Komma getrennt sind, und das Ergebnis der Auswertung des letzten Ausdrucks zur√ºckgeben.  So sehen solche Designs aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = expression1, expression2,... expressionN</code> </pre> <br>  Hier werden die Werte aller Ausdr√ºcke berechnet, wonach der Wert von expressionN in die <code>result</code> gelangt. <br><br>  M√∂glicherweise haben Sie den Komma-Operator bereits <code>for</code> Schleifen verwendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">10</span></span>; a &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; a++, b--)</code> </pre> <br>  Manchmal ist dieser Operator sehr n√ºtzlich, wenn Sie mehrere Ausdr√ºcke in dieselbe Zeile schreiben m√ºssen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter), counter }</code> </pre> <br>  Dies kann beim Entwerfen kleiner Pfeilfunktionen hilfreich sein. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSquare = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log (x), x * x)</code> </pre> <br><h2>  <font color="#3AC1EF">Plus-Betreiber</font> </h2><br>  Wenn Sie eine Zeichenfolge schnell in eine Zahl umwandeln m√ºssen, ist der Plus-Operator hilfreich f√ºr Sie.  Er kann mit einer Vielzahl von Zahlen arbeiten, und nicht nur, wie es scheint, mit positiven.  Wir sprechen von negativen, oktalen, hexadezimalen Zahlen und Zahlen in Exponentialschreibweise.  Dar√ºber hinaus k√∂nnen Datumsobjekte und Moment.js-Bibliotheksobjekte in Zeitstempel konvertiert werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  "" +'9.11'          // 9.11 +'-4'            // -4 +'0xFF'          // 255 +true            // 1 +'123e-5'        // 0.00123 +false           // 0 +null            // 0 +'Infinity'      // Infinity +'1,234'         // NaN +new Date      // 1542975502981 ( ) +momentObject    // 1542975502981 ( )</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Doppeltes Ausrufezeichen</font> </h2><br>  Es sollte beachtet werden, dass das, was manchmal als "doppelter Ausrufezeichenoperator" (Bang Bang oder Double Bang) bezeichnet wird, tats√§chlich kein Operator ist.  Dies ist ein logischer NOT-Operator oder ein logischer Negationsoperator, der wie ein Ausrufezeichen aussieht, das zweimal wiederholt wird.  Das doppelte Ausrufezeichen ist gut, da Sie damit jeden Ausdruck in einen booleschen Wert konvertieren k√∂nnen.  Wenn der Ausdruck aus Sicht von JS true ist, wird true zur√ºckgegeben, nachdem er mit einem doppelten Ausrufezeichen verarbeitet wurde.  Andernfalls wird <code>false</code> zur√ºckgegeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     !!null            // false !!undefined       // false !!false           // false !!true            // true !!""              // false !!"string"        // true !!0               // false !!1               // true !!{}              // true !![]              // true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Bitweiser Negationsoperator</font> </h2><br>  Seien wir ehrlich: Niemand k√ºmmert sich um bitweise Operatoren.  Ich spreche nicht davon, sie zu benutzen.  Der bitweise Negationsoperator kann jedoch in vielen Situationen verwendet werden. <br><br>  Wenn dieser Operator auf Zahlen angewendet wird, konvertiert er sie wie folgt: Aus der Zahl <code>N</code> ergibt sich <code>-(N+1)</code> .  Ein solcher Ausdruck ergibt <code>0</code> wenn <code>N</code> <code>-1</code> . <br><br>  Diese Funktion kann mit der <code>indexOf()</code> -Methode verwendet werden, wenn die Existenz eines Elements in einem Array oder einer Zeichenfolge √ºberpr√ºft wird, da diese Methode <code>-1</code> zur√ºckgibt, wenn das Element nicht gefunden wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      indexOf let username = "Nathan Drake" if (~username.indexOf("Drake")) { console.log('Access denied') } else { console.log('Access granted') }</span></span></code> </pre> <br>  Es ist zu beachten, dass in den ES6- bzw. ES7-Standards f√ºr Strings und Arrays die Methode include <code>includes()</code> wurde.  Es ist definitiv viel bequemer, das Vorhandensein von Elementen zu bestimmen, als den bitweisen Negationsoperator und <code>indexOf()</code> . <br><br><h2>  <font color="#3AC1EF">Benannte Bl√∂cke</font> </h2><br>  JavaScript hat ein Konzept von Beschriftungen, mit denen Sie Schleifen Namen (Beschriftungen) zuweisen k√∂nnen.  Sie k√∂nnen diese Beschriftungen dann verwenden, um auf die entsprechende Schleife zu verweisen, wenn Sie break- oder <code>continue</code> Anweisungen anwenden.  Beschriftungen k√∂nnen auch regul√§ren Codebl√∂cken zugewiesen werden. <br><br>  Beschriftete Schleifen sind n√ºtzlich, wenn Sie mit verschachtelten Schleifen arbeiten.  Sie k√∂nnen aber auch verwendet werden, um Code bequem in Bl√∂cken zu organisieren oder um Bl√∂cke zu erstellen, in denen Code unterbrochen werden kann. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    declarationBlock: { //       //     var i, j } forLoop1: //     - "forLoop1" for (i = 0; i &lt; 3; i++) {       forLoop2: //     -  "forLoop2"  for (j = 0; j &lt; 3; j++) {       if (i === 1 &amp;&amp; j === 1) {        continue forLoop1     }     console.log('i = ' + i + ', j = ' + j)  } } /* i = 0, j = 0 i = 0, j = 1 i = 0, j = 2 i = 1, j = 0 i = 2, j = 0 i = 2, j = 1 i = 2, j = 2 */ //      loopBlock4: { console.log('I will print') break loopBlock4 console.log('I will not print') } // I will print</span></span></code> </pre> <br>  Beachten Sie, dass es in JS im Gegensatz zu einigen anderen Sprachen keine <code>goto</code> .  Daher werden Beschriftungen nur mit <code>break</code> und <code>continue</code> Anweisungen verwendet. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir √ºber wenig bekannte JavaScript-Funktionen gesprochen, deren Kenntnis f√ºr jeden JS-Programmierer n√ºtzlich ist, zumindest um bereit zu sein, etwas Ungew√∂hnliches im Code eines anderen zu treffen.  Wenn das Thema ‚ÄûUnbekannter JS‚Äú f√ºr Sie interessant ist, k√∂nnen Sie sich unsere Ver√∂ffentlichung ansehen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie einige wenig bekannte Funktionen von JS kennen und Optionen f√ºr deren praktische Anwendung sehen, teilen Sie uns diese bitte mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431878/">https://habr.com/ru/post/de431878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431868/index.html">Stunden auf Gasentladungslampen (GRI) sind sie Nixie Uhr</a></li>
<li><a href="../de431870/index.html">Entwickler interaktiver B√ºcher mit LEDs beschweren sich √ºber den Diebstahl von Ideen durch Google-Mitarbeiter</a></li>
<li><a href="../de431872/index.html">JavaScript-Handbuch Teil 9: √úbersicht √ºber die ES7-, ES8- und ES9-Standards</a></li>
<li><a href="../de431874/index.html">Imba: JavaScript-kompatible Sprache f√ºr die schnelle Arbeit mit DOM</a></li>
<li><a href="../de431876/index.html">Optimierung von Winkelanwendungen</a></li>
<li><a href="../de431880/index.html">Doom of SceneKit. Yandex Erfahrung mit 3D-Grafik in iOS</a></li>
<li><a href="../de431884/index.html">Microsoft hat Apple bei der Marktkapitalisierung √ºbertroffen: Wie ist das passiert?</a></li>
<li><a href="../de431886/index.html">Al Lowy hat seine Quellcode-Sammlung f√ºr Sierra-Produkte bei eBay hochgeladen</a></li>
<li><a href="../de431888/index.html">‚ÄûIch denke, Teamideen sind bei der Entwicklung eines Produkts am wichtigsten.‚Äú</a></li>
<li><a href="../de431890/index.html">So geben Sie eine Bestellung an der freiberuflichen B√∂rse auf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>