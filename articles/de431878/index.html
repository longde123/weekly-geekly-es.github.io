<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🏫 🏬 👩🏼‍🍳 Wenig bekannte JavaScript-Funktionen 🕳️ 🤷🏿 👩🏼‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript wird oft als die einfachste Sprache für Anfänger bezeichnet, in der Programmierung, die am schwierigsten zu beherrschen ist. Der Autor des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wenig bekannte JavaScript-Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431878/">  JavaScript wird oft als die einfachste Sprache für Anfänger bezeichnet, in der Programmierung, die am schwierigsten zu beherrschen ist.  Der Autor des Materials, dessen Übersetzung wir veröffentlichen, sagt, dass er dieser Aussage nur zustimmen kann.  Die Sache ist, dass JS eine sehr alte und sehr flexible Sprache ist.  Es ist voll von mysteriösen syntaktischen Konstrukten und veralteten Funktionen, die es immer noch unterstützt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/bdc/ddf/340/bdcddf340ecf674873a62e6e8c38b38b.jpg" alt="Bild"></a> <br><br>  Heute werden wir über die wenig bekannten JavaScript-Funktionen und -Optionen für ihre praktische Anwendung sprechen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript ist immer etwas Neues</font> </h2><br>  Ich arbeite seit vielen Jahren mit JavaScript und stoße ständig auf etwas, von dem ich nicht vermutete, dass es es gibt.  Hier habe ich versucht, ähnliche wenig bekannte Merkmale der Sprache aufzulisten.  Im strengen Modus funktionieren einige von ihnen nicht, im normalen Modus sind sie jedoch vollständig korrekte JS-Codebeispiele.  Es sollte angemerkt werden, dass ich nicht davon ausgehe, den Lesern zu raten, all dies in Betrieb zu nehmen.  Obwohl das, worüber ich sprechen werde, für Sie sehr interessant erscheint, können Sie all dies nutzen, wenn Sie in einem Team arbeiten und, gelinde gesagt, Ihre Kollegen überraschen. <br><br>  → Den Code, den wir hier diskutieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier.</a> <br><br>  Bitte beachten Sie, dass ich Dinge wie das Auslösen von Variablen, Schließungen, Proxy-Objekten, Prototyp-Vererbung, Async / Warten, Generatoren und dergleichen nicht berücksichtigt habe.  Obwohl diese Merkmale der Sprache schwer zu verstehen sind, sind sie nicht bekannt. <br><br><h2>  <font color="#3AC1EF">Leerer Operator</font> </h2><br>  JavaScript hat einen unären <code>void</code> Operator.  Möglicherweise sind Sie in Form von <code>void(0)</code> oder <code>void 0</code> .  Sein einziger Zweck ist es, den Ausdruck zu seiner Rechten zu berechnen und <code>undefined</code> .  <code>0</code> hier wird es einfach verwendet, weil es üblich ist, obwohl dies nicht notwendig ist, und hier können Sie jeden gültigen Ausdruck verwenden.  True, dieser Operator gibt auf jeden Fall <code>undefined</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  void void 0                  // undefined void (0)                // undefined void 'abc'              // undefined void {}                 // undefined void (1 === 1)          // undefined void (1 !== 1)          // undefined void anyfunction()      // undefined</span></span></code> </pre> <br>  Warum der Sprache, die zur Rückgabe von <code>undefined</code> dient, ein spezielles Schlüsselwort hinzufügen, wenn Sie nur den Standardwert <code>undefined</code> ?  Ist es nicht so, gibt es eine gewisse Redundanz? <br><br>  Wie sich herausstellte, konnte vor dem Erscheinen des ES5-Standards in den meisten Browsern einem Standardwert von <code>undefined</code> ein neuer Wert zugewiesen werden.  Angenommen, Sie könnten diesen Befehl erfolgreich ausführen: <code>undefined = "abc"</code> .  Infolgedessen ist ein <code>undefined</code> Wert möglicherweise nicht so, wie er sein sollte.  In jenen Tagen ermöglichte uns die Verwendung von <code>void</code> , das Vertrauen in die Verwendung des echten <code>undefined</code> zu gewährleisten. <br><br><h2>  <font color="#3AC1EF">Klammern beim Aufrufen von Konstruktoren sind optional</font> </h2><br>  Die Klammern, die nach dem Klassennamen eingefügt werden und den Konstruktor aufrufen, sind vollständig optional (es sei denn, der Konstruktor muss Argumente übergeben). <br><br>  Im folgenden Beispiel wirkt sich das Vorhandensein oder Fehlen von Klammern nicht auf den korrekten Betrieb des Programms aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     const date = new Date() const month = new Date().getMonth() const myInstance = new MyClass() //     const date = new Date const month = (new Date).getMonth() const myInstance = new MyClass</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Klammern können nicht mit IIFE verwendet werden</font> </h2><br>  Die IIFE-Syntax erschien mir immer seltsam.  Warum gibt es all diese Klammern? <br><br>  Wie sich herausstellte, werden die Klammern nur benötigt, um dem JavaScript-Parser mitzuteilen, dass ein Code ein Funktionsausdruck ist und kein falscher Versuch, eine Funktion zu deklarieren.  Wenn wir diese Tatsache kennen, können wir verstehen, dass es viele Möglichkeiten gibt, die Klammern, in denen IIFE eingeschlossen ist, zu entfernen und gleichzeitig Arbeitscode zu schreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// IIFE (function () { console.log('Normal IIFE called') })() // Normal IIFE called void function () { console.log('Cool IIFE called') }() // Cool IIFE called</span></span></code> </pre> <br>  Hier teilt der <code>void</code> Operator dem Parser mit, dass der darauf folgende Code ein Funktionsausdruck ist.  Dies ermöglicht es, die Klammern um die Funktionsdeklaration zu entfernen.  Übrigens können Sie hier jeden unären Operator verwenden ( <code>void</code> , <code>+</code> , <code>!</code> , <code>-</code> usw.), und der Code funktioniert weiterhin.  Ist das nicht wunderbar? <br><br>  Wenn Sie jedoch ein aufmerksamer Leser sind, fragen Sie sich möglicherweise, ob der unäre Operator das von IIFE zurückgegebene Ergebnis beeinflusst.  In der Tat so wie es ist.  Das Gute ist jedoch, dass Sie keine Klammern um IIFE benötigen, wenn Sie das Ergebnis von IIFE benötigen, das Sie beispielsweise in einer Variablen speichern.  Hier ist ein Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// IIFE,    let result = (function () { // ... -  return 'Victor Sully' })() console.log(result) // Victor Sully let result1 = function () { // ... -  return 'Nathan Drake' }() console.log(result1) // Nathan Drake</span></span></code> </pre> <br>  Die geschweiften Klammern um das erste IIFE verbessern nur die Lesbarkeit des Codes, ohne dessen Betrieb zu beeinträchtigen. <br><br>  Wenn Sie IIFE besser verstehen möchten, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material an. <br><br><h2>  <font color="#3AC1EF">Bau mit</font> </h2><br>  Wissen Sie, dass JavaScript ein <code>with</code> Konstrukt hat, das Ausdrucksblöcke unterstützt?  Es sieht so aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (object)  statement <span class="hljs-comment"><span class="hljs-comment">//       with (object) {  statement  statement  ... }</span></span></code> </pre> <br>  Das Konstrukt <code>with</code> fügt alle Eigenschaften des Objekts hinzu, das in der Bereichskette übergeben wird, die beim Ausführen der Befehle verwendet wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    with const person = { firstname: 'Nathan', lastname: 'Drake', age: 29 } with (person) { console.log(`${firstname} ${lastname} is ${age} years old`) } // Nathan Drake is 29 years old</span></span></code> </pre> <br>  <code>with</code> mag wie ein tolles Werkzeug erscheinen.  Es scheint sogar noch besser zu sein als die neuen Funktionen von JS für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektzerstörung</a> , aber tatsächlich ist es nicht so. <br><br>  Die <code>with</code> Konstruktion ist veraltet und wird nicht zur Verwendung empfohlen.  Im strengen Modus ist seine Verwendung verboten.  Es stellt sich heraus, dass Blöcke Leistungs- und Sicherheitsprobleme verursachen. <br><br><h2>  <font color="#3AC1EF">Funktionskonstruktor</font> </h2><br>  Die Verwendung des <code>function</code> ist nicht die einzige Möglichkeit, eine neue Funktion zu definieren.  Sie können Funktionen dynamisch mit dem <code>Function</code> und dem <code>new</code> Operator definieren.  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Function const multiply = new Function('x', 'y', 'return x*y') multiply(2,3) // 6</span></span></code> </pre> <br>  Das letzte an den Konstruktor übergebene Argument ist eine Zeichenfolge mit dem Funktionscode.  Zwei weitere Argumente sind Funktionsparameter. <br><br>  Es ist interessant festzustellen, dass der <code>Function</code> das "übergeordnete" Element aller Konstruktoren in JavaScript ist.  Sogar der <code>Object</code> ist ein <code>Function</code> .  Und der native <code>Function</code> ist auch <code>Function</code> .  Infolgedessen gibt ein Aufruf vom Typ <code>object.constructor.constructor...</code> der für ein JS-Objekt ausreichend oft ausgeführt wurde, den <code>Function</code> als Ergebnis zurück. <br><br><h2>  <font color="#3AC1EF">Feature-Eigenschaften</font> </h2><br>  Wir alle wissen, dass Funktionen in JavaScript erstklassige Objekte sind.  Daher hindert uns niemand daran, Funktionen neue Eigenschaften hinzuzufügen.  Dies ist völlig normal, wird aber selten verwendet. <br><br>  Wann kann das nötig sein? <br><br>  In der Tat gibt es mehrere Situationen, in denen diese Funktion nützlich sein kann.  Betrachten Sie sie. <br><br><h3>  <font color="#3AC1EF">▍ Benutzerdefinierte Funktionen</font> </h3><br>  Angenommen, wir haben eine <code>greet()</code> Funktion.  Sie muss je nach den verwendeten regionalen Einstellungen unterschiedliche Begrüßungsnachrichten anzeigen.  Diese Einstellungen können in einer Variablen außerhalb der Funktion gespeichert werden.  Darüber hinaus verfügt die Funktion möglicherweise über eine Eigenschaft, die diese Einstellungen definiert, insbesondere die Spracheinstellungen des Benutzers.  Wir werden den zweiten Ansatz verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   function greet () { if (greet.locale === 'fr') {   console.log('Bonjour!') } else if (greet.locale === 'es') {   console.log('Hola!') } else {   console.log('Hello!') } } greet() // Hello! greet.locale = 'fr' greet() // Bonjour!</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Funktionen mit statischen Variablen</font> </h3><br>  Hier ist ein weiteres ähnliches Beispiel.  Angenommen, wir müssen einen bestimmten Generator implementieren, der eine Folge von geordneten Zahlen erzeugt.  In solchen Situationen werden normalerweise statische Zählervariablen in Klassen oder IIFE verwendet, um Informationen über die zuletzt generierte Zahl zu speichern.  Mit diesem Ansatz beschränken wir den Zugang zum Schalter und verhindern die Verschmutzung des globalen Bereichs durch zusätzliche Variablen. <br><br>  Aber was ist, wenn wir Flexibilität brauchen, wenn wir den Wert eines solchen Zählers lesen oder sogar ändern müssen und den globalen Bereich nicht verstopfen? <br><br>  Natürlich können Sie eine Klasse mit der entsprechenden Variablen und mit Methoden erstellen, um damit zu arbeiten.  Oder Sie können sich nicht mit solchen Dingen beschäftigen und nur die Eigenschaften von Funktionen nutzen. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   function generateNumber () { if (!generateNumber.counter) {   generateNumber.counter = 0 } return ++generateNumber.counter } console.log(generateNumber()) // 1 console.log(generateNumber()) // 2 console.log('current counter value: ', generateNumber.counter) // current counter value: 2 generateNumber.counter = 10 console.log('current counter value: ', generateNumber.counter) // current counter value: 10 console.log(generateNumber()) // 11</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Argumente Objekteigenschaften</font> </h2><br>  Ich bin sicher, die meisten von Ihnen wissen, dass Funktionen ein <code>arguments</code> .  Dies ist ein Array-ähnliches Objekt, auf das in allen Funktionen zugegriffen werden kann (mit Ausnahme von Pfeilfunktionen, die kein eigenes <code>arguments</code> ).  Es enthält eine Liste von Argumenten, die beim Aufruf an die Funktion übergeben wurden.  Darüber hinaus hat es einige interessante Eigenschaften: <br><br><ul><li>  <code>arguments.callee</code> enthält einen Link zur aktuellen Funktion. </li><li>  <code>arguments.caller</code> enthält einen Verweis auf die Funktion, die die aktuelle Funktion aufgerufen hat. </li></ul><br>  Betrachten Sie ein Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  callee  caller  arguments const myFunction = function () { console.log('Current function: ', arguments.callee.name) console.log('Invoked by function: ', arguments.callee.caller.name) } void function main () { myFunction() } () // Current function: myFunction // Invoked by function: main</span></span></code> </pre> <br>  Der ES5-Standard verbietet die Verwendung von <code>callee</code> und <code>callee</code> im strengen Modus, ist jedoch in vielen mit JavaScript kompilierten Programmtexten, z. B. in Bibliotheken, noch weit verbreitet.  Daher ist es nützlich, über sie Bescheid zu wissen. <br><br><h2>  <font color="#3AC1EF">Tagged Template Literals</font> </h2><br>  Wenn Sie etwas mit JavaScript-Programmierung zu tun haben, haben Sie sicherlich von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlagenliteralen gehört</a> .  Vorlagenliterale sind eine der vielen großen Innovationen des ES6-Standards.  Kennen Sie jedoch markierte Vorlagenliterale? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    `Hello ${username}!` //    myTag`Hello ${username}!`</span></span></code> </pre> <br>  Mit markierten Vorlagenliteralen kann der Entwickler steuern, wie aus dem Vorlagenliteral eine Zeichenfolge wird.  Dies erfolgt mithilfe spezieller Tags.  Ein Tag ist nur der Name einer Parserfunktion, die ein Array von Zeichenfolgen und Werten empfängt, die von einem Zeichenfolgenmuster interpretiert werden.  Bei Verwendung einer Tag-Funktion wird erwartet, dass die fertige Zeichenfolge zurückgegeben wird. <br><br>  Im folgenden Beispiel interpretiert unser Tag " <code>highlight</code> die Daten eines Vorlagenliterals und bettet diese Daten in eine fertige Zeile ein. Platzieren Sie sie im HTML-Tag <code>&lt;mark&gt;</code> , um sie auszuwählen, wenn dieser Text auf einer Webseite angezeigt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    function highlight(strings, ...values) { //  i -      let result = '' strings.forEach((str, i) =&gt; {   result += str   if (values[i]) {     result += `&lt;mark&gt;${values[i]}&lt;/mark&gt;`   } }) return result } const author = 'Henry Avery' const statement = `I am a man of fortune &amp; I must seek my fortune` const quote = highlight`${author} once said, ${statement}` // &lt;mark&gt;Henry Avery&lt;/mark&gt; once said, &lt;mark&gt;I am a man of fortune // &amp; I must seek my fortune&lt;/mark&gt;</span></span></code> </pre> <br>  Interessante Möglichkeiten zur Verwendung dieser Funktion finden Sie in vielen Bibliotheken.  Hier einige Beispiele: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Styled-Komponenten</a> - zur Verwendung in React-Anwendungen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es2015-i18n-tag</a> - zur Übersetzung und Internationalisierung von Projekten. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kreide</a> - zur Ausgabe mehrfarbiger Nachrichten an die Konsole. </li></ul><br><h2>  <font color="#3AC1EF">Getter und Setter in ES5</font> </h2><br>  JavaScript-Objekte sind größtenteils ziemlich einfach.  Angenommen, wir haben ein <code>user</code> und versuchen, mit dem Konstrukt <code>user.age</code> auf seine Eigenschaft <code>age</code> <code>user.age</code> .  Wenn bei diesem Ansatz diese Eigenschaft definiert ist, erhalten wir ihren Wert, und wenn sie nicht definiert ist, werden wir <code>undefined</code> .  Alles ist sehr einfach. <br><br>  Das Arbeiten mit Eigenschaften muss jedoch gar nicht so primitiv sein.  JS-Objekte implementieren das Konzept von Gettern und Setzern.  Anstatt den Wert einer Eigenschaft des Objekts direkt zurückzugeben, können wir unsere eigene Getter-Funktion schreiben, die das zurückgibt, was wir für notwendig halten.  Gleiches gilt für das Schreiben neuer Werte in die Eigenschaften mithilfe von Setterfunktionen. <br><br>  Mit Gettern und Setzern können Sie erweiterte Schemata für die Arbeit mit Eigenschaften implementieren.  Beim Lesen oder Schreiben von Eigenschaften können Sie die Konzepte virtueller Felder verwenden, die Werte von Feldern überprüfen und beim Schreiben oder Lesen können einige nützliche Nebenwirkungen auftreten. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const user = { firstName: 'Nathan', lastName: 'Drake', // fullname -    get fullName() {   return this.firstName + ' ' + this.lastName }, //      set age(value) {   if (isNaN(value)) throw Error('Age has to be a number')   this._age = Number(value) }, get age() {   return this._age } } console.log(user.fullName) // Nathan Drake user.firstName = 'Francis' console.log(user.fullName) // Francis Drake user.age = '29' console.log(user.age) // 29 // user.age = 'invalid text' // Error: Age has to be a number</span></span></code> </pre> <br>  Getter und Setter sind keine ES5-Standardinnovationen.  Sie waren immer in der Sprache präsent.  In ES5 wurden nur praktische Syntaxwerkzeuge hinzugefügt, um mit ihnen zu arbeiten.  Details zu Gettern und Setzern finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Beispiele für die Verwendung von Gettern sind die beliebte Node.js <a href="">Colors-</a> Bibliothek. <br><br>  Diese Bibliothek <a href="">erweitert die String-Klasse</a> und fügt ihr viele Getter-Methoden hinzu.  Auf diese Weise können Sie eine Zeichenfolge in ihre "farbige" Version konvertieren, sodass diese Zeichenfolge dann für die Protokollierung verwendet werden kann.  Dies erfolgt durch Arbeiten mit Zeichenfolgeneigenschaften. <br><br><h2>  <font color="#3AC1EF">Komma-Operator</font> </h2><br>  JS hat einen Kommaoperator.  Sie können mehrere Ausdrücke in eine einzelne Zeile schreiben, die durch ein Komma getrennt sind, und das Ergebnis der Auswertung des letzten Ausdrucks zurückgeben.  So sehen solche Designs aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = expression1, expression2,... expressionN</code> </pre> <br>  Hier werden die Werte aller Ausdrücke berechnet, wonach der Wert von expressionN in die <code>result</code> gelangt. <br><br>  Möglicherweise haben Sie den Komma-Operator bereits <code>for</code> Schleifen verwendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">10</span></span>; a &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; a++, b--)</code> </pre> <br>  Manchmal ist dieser Operator sehr nützlich, wenn Sie mehrere Ausdrücke in dieselbe Zeile schreiben müssen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter), counter }</code> </pre> <br>  Dies kann beim Entwerfen kleiner Pfeilfunktionen hilfreich sein. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSquare = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log (x), x * x)</code> </pre> <br><h2>  <font color="#3AC1EF">Plus-Betreiber</font> </h2><br>  Wenn Sie eine Zeichenfolge schnell in eine Zahl umwandeln müssen, ist der Plus-Operator hilfreich für Sie.  Er kann mit einer Vielzahl von Zahlen arbeiten, und nicht nur, wie es scheint, mit positiven.  Wir sprechen von negativen, oktalen, hexadezimalen Zahlen und Zahlen in Exponentialschreibweise.  Darüber hinaus können Datumsobjekte und Moment.js-Bibliotheksobjekte in Zeitstempel konvertiert werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  "" +'9.11'          // 9.11 +'-4'            // -4 +'0xFF'          // 255 +true            // 1 +'123e-5'        // 0.00123 +false           // 0 +null            // 0 +'Infinity'      // Infinity +'1,234'         // NaN +new Date      // 1542975502981 ( ) +momentObject    // 1542975502981 ( )</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Doppeltes Ausrufezeichen</font> </h2><br>  Es sollte beachtet werden, dass das, was manchmal als "doppelter Ausrufezeichenoperator" (Bang Bang oder Double Bang) bezeichnet wird, tatsächlich kein Operator ist.  Dies ist ein logischer NOT-Operator oder ein logischer Negationsoperator, der wie ein Ausrufezeichen aussieht, das zweimal wiederholt wird.  Das doppelte Ausrufezeichen ist gut, da Sie damit jeden Ausdruck in einen booleschen Wert konvertieren können.  Wenn der Ausdruck aus Sicht von JS true ist, wird true zurückgegeben, nachdem er mit einem doppelten Ausrufezeichen verarbeitet wurde.  Andernfalls wird <code>false</code> zurückgegeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     !!null            // false !!undefined       // false !!false           // false !!true            // true !!""              // false !!"string"        // true !!0               // false !!1               // true !!{}              // true !![]              // true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Bitweiser Negationsoperator</font> </h2><br>  Seien wir ehrlich: Niemand kümmert sich um bitweise Operatoren.  Ich spreche nicht davon, sie zu benutzen.  Der bitweise Negationsoperator kann jedoch in vielen Situationen verwendet werden. <br><br>  Wenn dieser Operator auf Zahlen angewendet wird, konvertiert er sie wie folgt: Aus der Zahl <code>N</code> ergibt sich <code>-(N+1)</code> .  Ein solcher Ausdruck ergibt <code>0</code> wenn <code>N</code> <code>-1</code> . <br><br>  Diese Funktion kann mit der <code>indexOf()</code> -Methode verwendet werden, wenn die Existenz eines Elements in einem Array oder einer Zeichenfolge überprüft wird, da diese Methode <code>-1</code> zurückgibt, wenn das Element nicht gefunden wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      indexOf let username = "Nathan Drake" if (~username.indexOf("Drake")) { console.log('Access denied') } else { console.log('Access granted') }</span></span></code> </pre> <br>  Es ist zu beachten, dass in den ES6- bzw. ES7-Standards für Strings und Arrays die Methode include <code>includes()</code> wurde.  Es ist definitiv viel bequemer, das Vorhandensein von Elementen zu bestimmen, als den bitweisen Negationsoperator und <code>indexOf()</code> . <br><br><h2>  <font color="#3AC1EF">Benannte Blöcke</font> </h2><br>  JavaScript hat ein Konzept von Beschriftungen, mit denen Sie Schleifen Namen (Beschriftungen) zuweisen können.  Sie können diese Beschriftungen dann verwenden, um auf die entsprechende Schleife zu verweisen, wenn Sie break- oder <code>continue</code> Anweisungen anwenden.  Beschriftungen können auch regulären Codeblöcken zugewiesen werden. <br><br>  Beschriftete Schleifen sind nützlich, wenn Sie mit verschachtelten Schleifen arbeiten.  Sie können aber auch verwendet werden, um Code bequem in Blöcken zu organisieren oder um Blöcke zu erstellen, in denen Code unterbrochen werden kann. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    declarationBlock: { //       //     var i, j } forLoop1: //     - "forLoop1" for (i = 0; i &lt; 3; i++) {       forLoop2: //     -  "forLoop2"  for (j = 0; j &lt; 3; j++) {       if (i === 1 &amp;&amp; j === 1) {        continue forLoop1     }     console.log('i = ' + i + ', j = ' + j)  } } /* i = 0, j = 0 i = 0, j = 1 i = 0, j = 2 i = 1, j = 0 i = 2, j = 0 i = 2, j = 1 i = 2, j = 2 */ //      loopBlock4: { console.log('I will print') break loopBlock4 console.log('I will not print') } // I will print</span></span></code> </pre> <br>  Beachten Sie, dass es in JS im Gegensatz zu einigen anderen Sprachen keine <code>goto</code> .  Daher werden Beschriftungen nur mit <code>break</code> und <code>continue</code> Anweisungen verwendet. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir über wenig bekannte JavaScript-Funktionen gesprochen, deren Kenntnis für jeden JS-Programmierer nützlich ist, zumindest um bereit zu sein, etwas Ungewöhnliches im Code eines anderen zu treffen.  Wenn das Thema „Unbekannter JS“ für Sie interessant ist, können Sie sich unsere Veröffentlichung ansehen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie einige wenig bekannte Funktionen von JS kennen und Optionen für deren praktische Anwendung sehen, teilen Sie uns diese bitte mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431878/">https://habr.com/ru/post/de431878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431868/index.html">Stunden auf Gasentladungslampen (GRI) sind sie Nixie Uhr</a></li>
<li><a href="../de431870/index.html">Entwickler interaktiver Bücher mit LEDs beschweren sich über den Diebstahl von Ideen durch Google-Mitarbeiter</a></li>
<li><a href="../de431872/index.html">JavaScript-Handbuch Teil 9: Übersicht über die ES7-, ES8- und ES9-Standards</a></li>
<li><a href="../de431874/index.html">Imba: JavaScript-kompatible Sprache für die schnelle Arbeit mit DOM</a></li>
<li><a href="../de431876/index.html">Optimierung von Winkelanwendungen</a></li>
<li><a href="../de431880/index.html">Doom of SceneKit. Yandex Erfahrung mit 3D-Grafik in iOS</a></li>
<li><a href="../de431884/index.html">Microsoft hat Apple bei der Marktkapitalisierung übertroffen: Wie ist das passiert?</a></li>
<li><a href="../de431886/index.html">Al Lowy hat seine Quellcode-Sammlung für Sierra-Produkte bei eBay hochgeladen</a></li>
<li><a href="../de431888/index.html">„Ich denke, Teamideen sind bei der Entwicklung eines Produkts am wichtigsten.“</a></li>
<li><a href="../de431890/index.html">So geben Sie eine Bestellung an der freiberuflichen Börse auf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>