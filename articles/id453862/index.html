<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏻 🎃 📔 Mengapa Anda harus menggunakan pathlib 👨‍🎨 😓 🛀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari penerjemah: Halo, Habr! Saya hadir untuk Anda terjemahan artikel Mengapa Anda harus menggunakan pathlib dan kelanjutannya, Tidak benar-benar, pat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa Anda harus menggunakan pathlib</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453862/"><p>  <em>Dari penerjemah: Halo, Habr!</em>  <em>Saya hadir untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa Anda harus menggunakan pathlib</a> dan kelanjutannya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tidak benar-benar, pathlib bagus</a> .</em>  <em>Banyak perhatian sekarang sedang dibayarkan untuk fitur Python baru seperti asyncio, the: = operator, dan pengetikan opsional.</em>  <em>Pada saat yang sama, tidak begitu signifikan (meskipun :: sebut inovasi serius bahasa tidak berubah menjadi inovasi serius) berisiko untuk radar, tetapi inovasi yang sangat berguna dalam bahasa.</em>  <em>Secara khusus, pada habr artikel yang ditujukan untuk subjek, saya tidak menemukan (kecuali satu paragraf di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ), oleh karena itu saya memutuskan untuk memperbaiki situasi.</em> </p><br><p> Ketika saya menemukan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pathlib yang</a> baru beberapa tahun yang lalu, saya memutuskan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawah</a> pikiran saya bahwa itu hanya versi berorientasi objek yang agak canggung dari modul <code>os.path</code> .  Saya salah.  <code>pathlib</code> benar-benar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">luar biasa</a> ! </p><br><p>  Pada artikel ini saya akan mencoba jatuh cinta pada <code>pathlib</code> .  Saya harap artikel ini <strong><code>pathlib</code></strong> Anda untuk <strong>menggunakan <code>pathlib</code> dalam situasi apa pun terkait bekerja dengan file dengan Python</strong> . </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>os.path</code> canggung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>os</code> kelebihan beban</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>   glob</code></a> </li> <li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>pathlib</code> membuat hal-hal sederhana menjadi lebih mudah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Objek jalur membuat kode Anda lebih jelas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>    pathlib</code> ?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>    pathlib</code> ?</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Jawaban untuk pertanyaan.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code> os.path</code> dan <code>pathlib</code> jujur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda tidak perlu khawatir tentang normalisasi jalan.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code> ,     ,    pathlib</code> !</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tetapi perpustakaan favorit saya memiliki Path lebih baik dari standar!</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>  pathlib.Path</code> dan <code>str</code> tidak tercampur, kan?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>pathlib</code> terlalu lambat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peningkatan keterbacaan</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>   pathlib.Path</code></a> </li> </ul></li></ul><br><h2 id="chast-1">  Bagian 1 </h2><br><h3 id="ospath-neuklyuzh">  <code>os.path</code> canggung </h3><br><p>  Modul <code>os.path</code> selalu menjadi apa yang kami gunakan ketika datang ke jalur Python.  Pada prinsipnya, ada semua yang Anda butuhkan, tetapi seringkali itu tidak terlihat terlalu elegan. </p><br><p>  Haruskah saya mengimpornya seperti itu? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) TEMPLATES_DIR = os.path.join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Atau lebih? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Mungkin fungsi <code>join</code> memiliki nama yang terlalu umum, dan kita harus melakukan sesuatu seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> joinpath BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = joinpath(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Bagi saya, semua opsi di atas sepertinya tidak terlalu nyaman.  Kami meneruskan string ke fungsi yang mengembalikan string yang kami lewatkan ke fungsi berikutnya yang bekerja dengan string.  Kebetulan mereka semua mengandung jalan, tetapi mereka masih hanya garis. </p><br><p>  Menggunakan string untuk input dan output dalam fungsi <code>os.path</code> sangat tidak nyaman karena Anda harus membaca kode dari dalam ke luar.  Saya ingin mengonversi panggilan ini dari bersarang menjadi berurutan.  Inilah yang memungkinkan Anda untuk melakukan <code>pathlib</code> ! </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path BASE_DIR = Path(__file__).resolve().parent.parent TEMPLATES_DIR = BASE_DIR.joinpath(<span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Modul <code>os.path</code> membutuhkan pemanggilan fungsi bersarang, tetapi <code>pathlib</code> <strong>memungkinkan kita untuk membuat rantai panggilan berurutan ke metode dan atribut kelas <code>Path</code></strong> dengan hasil yang setara. </p><br><p>  Saya tahu apa yang Anda pikirkan: berhenti, objek <code>Path</code> ini tidak sama dengan sebelumnya, kami tidak lagi beroperasi di jalur path!  Kami akan kembali ke masalah ini nanti (petunjuk: dalam hampir semua situasi, kedua pendekatan ini dapat dipertukarkan). </p><br><h3 id="os-peregruzhen">  <code>os</code> kelebihan beban </h3><br><p>  Modul <code>os.path</code> klasik dirancang untuk bekerja dengan jalur.  Tetapi setelah Anda ingin <em>melakukan sesuatu</em> dengan path (misalnya, membuat direktori), Anda perlu mengakses modul lain, sering <code>os</code> . </p><br><p>  <code>os</code> berisi banyak utilitas untuk bekerja dengan file dan direktori: <code>mkdir</code> , <code>getcwd</code> , <code>chmod</code> , <code>stat</code> , <code>remove</code> , <code>rename</code> , <code>rmdir</code> .  Juga <code>chdir</code> , <code>link</code> , <code>walk</code> , <code>listdir</code> , <code>makedirs</code> , <code>renames</code> , <code>removedirs</code> , <code>removedirs</code> <code>unlink</code> , <code>symlink</code> .  Dan banyak hal yang tidak terkait dengan sistem file sama sekali: <code>fork</code> , <code>getenv</code> , <code>putenv</code> , <code>getlogin</code> , <code>getlogin</code> , <code>system</code> , ... Beberapa lusin hal lagi yang tidak akan saya sebutkan di sini. </p><br><p>  <strong>Modul <code>os</code> dirancang untuk berbagai tugas;</strong>  <strong>ini adalah kotak dengan segala sesuatu yang berkaitan dengan sistem operasi.</strong>  Ada banyak kegunaan dalam <code>os</code> , tetapi tidak selalu mudah dinavigasi: sering perlu untuk menggali sedikit ke dalam modul sebelum Anda menemukan apa yang Anda butuhkan. </p><br><p>  <code>pathlib</code> mentransfer sebagian besar fungsi sistem file ke objek <code>Path</code> . </p><br><p>  Berikut adalah kode yang membuat <code>src/__pypackages__</code> dan mengganti nama file <code>.editorconfig</code> kami menjadi <code>src/.editorconfig</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><p>  Berikut adalah kode yang mirip menggunakan <code>Path</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Perhatikan bahwa contoh kode kedua lebih mudah dibaca, karena diatur dari kiri ke kanan - ini semua berkat rangkaian metode. </p><br><h3 id="ne-zabyvayte-pro-glob">  Jangan lupakan <code>glob</code> </h3><br><p>  Tidak hanya <code>os</code> dan <code>os.path</code> berisi metode yang terkait dengan sistem file.  Perlu juga disebutkan tentang <code>glob</code> , yang tidak bisa disebut tidak berguna. </p><br><p>  Kita dapat menggunakan fungsi <code>glob.glob</code> untuk mencari file dengan pola tertentu: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob top_level_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'**/*.csv'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Modul <code>pathlib</code> juga menyediakan metode serupa: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path top_level_csv_files = Path.cwd().glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>)</code> </pre> <br><p>  Setelah beralih ke modul <code>pathlib</code> , <strong>kebutuhan untuk <code>glob</code> menghilang sepenuhnya</strong> : semua yang Anda butuhkan sudah merupakan bagian integral dari objek <code>Path</code> </p><br><h3 id="pathlib-delaet-prostye-veschi-esche-prosche">  <code>pathlib</code> membuat hal-hal sederhana menjadi lebih mudah </h3><br><p>  <code>pathlib</code> menyederhanakan banyak situasi sulit, tetapi juga <strong>membuat beberapa cuplikan kode sederhana menjadi lebih mudah</strong> . </p><br><p>  Ingin membaca semua teks dalam satu file atau lebih? </p><br><p>  Anda dapat membuka file, membaca konten, dan menutup file menggunakan blok <code>with</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob file_contents = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> glob(<span class="hljs-string"><span class="hljs-string">'**/*.py'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> python_file: file_contents.append(python_file.read())</code> </pre> <br><p>  Atau Anda dapat menggunakan metode <code>read_text</code> pada objek <code>Path</code> dan menghasilkan daftar untuk mendapatkan hasil yang sama dalam satu ekspresi: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path file_contents = [ path.read_text() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.py'</span></span>) ]</code> </pre> <br><p>  Tetapi bagaimana jika Anda perlu menulis ke file? </p><br><p>  Begini tampilannya menggunakan <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Atau Anda dapat menggunakan metode <code>write_text</code> : </p><br><pre> <code class="python hljs">Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).write_text(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Jika karena alasan tertentu Anda perlu menggunakan <code>open</code> , baik sebagai manajer konteks atau untuk preferensi pribadi, <code>Path</code> menyediakan metode <code>open</code> sebagai alternatif: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> path.open(mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Atau, dimulai dengan Python 3.6, Anda bisa melewati <code>Path</code> Anda langsung untuk <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><h3 id="obekty-path-delayut-vash-kod-ochevidnee">  Objek jalur membuat kode Anda lebih jelas </h3><br><p>  Apa yang ditunjukkan oleh variabel-variabel berikut?  Apa arti dari artinya? </p><br><pre> <code class="python hljs">person = <span class="hljs-string"><span class="hljs-string">'{"name": "Trey Hunner", "location": "San Diego"}'</span></span> pycon_2019 = <span class="hljs-string"><span class="hljs-string">"2019-05-01"</span></span> home_directory = <span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span></code> </pre> <br><p>  Setiap variabel menunjuk ke sebuah garis.  Tetapi masing-masing dari mereka memiliki arti yang berbeda: yang pertama adalah JSON, yang kedua adalah tanggal, dan yang ketiga adalah path file. </p><br><p>  Representasi objek ini sedikit lebih berguna: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path person = {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Trey Hunner"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Diego"</span></span>} pycon_2019 = date(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) home_directory = Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)</code> </pre> <br><p>  Objek JSON dapat dideserialisasikan ke dalam kamus, tanggal dapat secara asli direpresentasikan menggunakan <code>datetime.date</code> , dan <strong>objek path file dapat direpresentasikan sebagai <code>Path</code></strong> </p><br><p>  Menggunakan objek <code>Path</code> membuat kode Anda lebih eksplisit.  Jika Anda ingin bekerja dengan tanggal, Anda menggunakan <code>date</code> .  Jika Anda ingin bekerja dengan jalur file, gunakan <code>Path</code> . </p><br><p>  Saya bukan pendukung OOP yang sangat besar.  Kelas menambahkan lapisan abstraksi ekstra, dan abstraksi terkadang cenderung mempersulit sistem daripada menyederhanakannya.  Pada saat yang sama, saya percaya bahwa <code>pathlib.Path</code> adalah <strong>abstraksi yang bermanfaat</strong> .  Cukup cepat, itu menjadi keputusan yang diterima. </p><br><p>  Berkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEP 519</a> , <code>Path</code> menjadi standar untuk bekerja dengan paths.  Pada saat Python 3.6, sebagian besar metode <code>os</code> , <code>shutil</code> , <code>os.path</code> bekerja dengan benar dengan objek-objek ini.  <strong>Anda dapat beralih ke <code>pathlib</code> , transparan untuk basis kode Anda!</strong> </p><br><h3 id="chego-ne-hvataet-v-pathlib">  Apa yang hilang di <code>pathlib</code> ? </h3><br><p>  Meskipun <code>pathlib</code> keren, itu tidak komprehensif.  Pasti ada <strong>beberapa kemungkinan yang ingin saya sertakan dalam modul</strong> . </p><br><p>  Hal pertama yang terlintas dalam pikiran adalah kurangnya metode jalur yang setara dengan <code>shutil</code> .  Meskipun Anda bisa meneruskan <code>Path</code> sebagai parameter <code>shutil</code> untuk menyalin / menghapus / memindahkan file dan direktori, Anda tidak bisa menyebutnya sebagai metode pada objek <code>Path</code> . </p><br><p>  Jadi, untuk menyalin file, Anda perlu melakukan sesuatu seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> copyfile source = Path(<span class="hljs-string"><span class="hljs-string">'old_file.txt'</span></span>) destination = Path(<span class="hljs-string"><span class="hljs-string">'new_file.txt'</span></span>) copyfile(source, destination)</code> </pre> <br><p>  Juga tidak ada analog dari metode <code>os.chdir</code> .  Ini berarti bahwa Anda perlu mengimpornya jika Anda perlu mengubah direktori saat ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir parent = Path(<span class="hljs-string"><span class="hljs-string">'..'</span></span>) chdir(parent)</code> </pre> <br><p>  Juga tidak ada yang setara dengan fungsi <code>os.walk</code> .  Meskipun Anda dapat menulis fungsi Anda sendiri dalam semangat <code>walk</code> tanpa terlalu banyak kesulitan. </p><br><p>  Saya berharap bahwa suatu hari objek <code>pathlib.Path</code> akan berisi metode untuk beberapa operasi yang disebutkan.  Tetapi bahkan dalam skenario ini, <strong>saya merasa jauh lebih mudah menggunakan <code>pathlib</code> dengan sesuatu yang lain daripada menggunakan <code>os.path</code> dan yang lainnya</strong> . </p><br><h3 id="vsegda-li-nuzhno-ispolzovat-pathlib">  Apakah selalu perlu menggunakan <code>pathlib</code> ? </h3><br><p>  Dimulai dengan Python 3.6, <strong>Paths bekerja hampir di mana saja Anda menggunakan string</strong> .  Jadi saya tidak melihat alasan <em>untuk tidak</em> menggunakan <code>pathlib</code> jika Anda menggunakan Python 3.6 dan di atasnya. </p><br><p>  Jika Anda menggunakan versi Python 3 yang lebih lama, Anda bisa kapan saja membungkus objek <code>Path</code> dalam panggilan <code>str</code> untuk mendapatkan string jika Anda perlu kembali ke negara baris.  Ini tidak terlalu elegan, tetapi berfungsi: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path chdir(Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   Python 3.6+ chdir(str(Path('/home/trey'))) #     </span></span></code> </pre> <br><h2 id="chast-2-otvety-na-voprosy">  Bagian 2. Jawaban untuk pertanyaan. </h2><br><p>  Setelah bagian pertama diterbitkan, beberapa orang memiliki beberapa pertanyaan.  Seseorang berkata bahwa saya membandingkan <code>pathlib</code> <code>os.path</code> dan <code>pathlib</code> tidak jujur.  Beberapa mengatakan bahwa menggunakan <code>os.path</code> tertanam dalam komunitas Python sehingga beralih ke perpustakaan baru akan memakan waktu yang sangat lama.  Saya juga melihat beberapa pertanyaan tentang kinerja. </p><br><p>  Pada bagian ini, saya ingin mengomentari masalah ini.  Ini dapat dianggap sebagai perlindungan <code>pathlib</code> dan sedikit surat cinta untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEP 519</a> . </p><br><h3 id="sravnenie-ospath-i-pathlib-po-chestnomu">  Bandingkan <code>os.path</code> dan <code>pathlib</code> jujur </h3><br><p>  Pada bagian terakhir, saya membandingkan dua fragmen kode berikut: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Ini mungkin tampak seperti perbandingan yang tidak adil, karena menggunakan <code>os.path.join</code> pada contoh pertama menjamin penggunaan pembatas yang benar pada semua platform, yang tidak saya lakukan pada contoh kedua.  Faktanya, semuanya sudah beres, karena <strong>Path secara otomatis menormalkan pemisah path</strong> </p><br><p>  Kita dapat membuktikan ini dengan melihat konversi objek <code>Path</code> ke string di Windows: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>str(Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src\\__pypackages__'</span></span></code> </pre> <br><p>  Tidak ada bedanya apakah kita menggunakan metode <code>joinpath</code> , tanda <code>'/'</code> di garis path, <code>/</code> operator (fitur bagus <code>Path</code> ), atau meneruskan argumen individual ke konstruktor Path, kita mendapatkan hasil yang sama: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>) / <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span> WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>).joinpath(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Contoh terakhir menyebabkan beberapa kebingungan dari orang-orang yang menyarankan bahwa <code>pathlib</code> tidak cukup pintar untuk mengganti <code>/</code> dengan <code>\</code> dalam string path.  Untungnya, semuanya beres! </p><br><p>  Dengan objek <code>Path</code> , Anda tidak perlu lagi khawatir tentang arah garis miring: tentukan semua jalur Anda menggunakan <code>/</code> , dan hasilnya akan dapat diprediksi untuk platform apa pun. </p><br><h3 id="vy-ne-dolzhny-bespokoitsya-o-normalizacii-putey">  Anda tidak perlu khawatir tentang normalisasi jalan. </h3><br><p>  Jika Anda menjalankan Linux atau Mac, sangat mudah untuk secara tidak sengaja menambahkan bug ke kode Anda yang hanya memengaruhi pengguna Windows.  Jika Anda tidak secara cermat memantau penggunaan <code>os.path.join</code> dan \ atau <code>os.path.normcase</code> untuk mengonversi garis miring menjadi yang cocok untuk platform saat ini, <strong>Anda dapat menulis kode yang tidak akan berfungsi dengan benar di Windows</strong> . </p><br><p>  Berikut adalah contoh bug khusus Windows: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Selain itu, kode tersebut akan berfungsi dengan benar di mana-mana: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = Path(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Sebelumnya, programmer bertanggung jawab untuk menyatukan dan menormalkan jalur, seperti pada Python 2, programmer bertanggung jawab untuk memutuskan di mana harus menggunakan unicode daripada byte.  Ini bukan lagi tugas Anda - <code>Path</code> menyelesaikan semua masalah seperti itu untuk Anda. </p><br><p>  Saya tidak menggunakan Windows, dan saya tidak punya komputer Windows.  Tetapi banyak orang hebat yang akan menggunakan kode saya kemungkinan besar akan menggunakan Windows, dan saya ingin semuanya bekerja dengan benar untuk mereka. </p><br><p>  <strong>Jika ada kemungkinan kode Anda akan berjalan di Windows, Anda harus serius mempertimbangkan beralih ke <code>pathlib</code> .</strong> </p><br><p>  <strong>Jangan khawatir tentang normalisasi</strong> : tetap gunakan <code>Path</code> ketika datang ke path file. </p><br><h3 id="zvuchit-klassno-no-u-menya-storonnyaya-biblioteka-kotoraya-ne-ispolzuet-pathlib">  Kedengarannya keren, tapi saya memiliki perpustakaan pihak ketiga yang tidak menggunakan <code>pathlib</code> ! </h3><br><p>  Anda memiliki basis kode besar yang berfungsi dengan string sebagai path.  Mengapa beralih ke <code>pathlib</code> jika itu berarti semuanya harus ditulis ulang? </p><br><p>  Bayangkan Anda memiliki fungsi berikut: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  Fungsi mengambil direktori dan membuat file <code>.editorconfig</code> , sesuatu seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path &gt;&gt;&gt; make_editorconfig(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Jika Anda mengganti garis dengan <code>Path</code> , semuanya akan berfungsi juga: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Tapi ... bagaimana caranya? </p><br><p>  <code>os.path.join</code> menerima objek <code>Path</code> (sejak Python 3.6).  Hal yang sama dapat dikatakan tentang <code>os.makedirs</code> . <br>  Bahkan, fungsi <code>open</code> built-in menerima <code>Path</code> , <code>shutil</code> menerima <code>Path</code> dan segala sesuatu di perpustakaan standar yang digunakan untuk menerima string sekarang harus bekerja dengan <code>Path</code> dan string. </p><br><p>  Kita harus berterima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEP 519 untuk ini</a> , yang menyediakan kelas abstrak <code>os.PathLike</code> dan mengumumkan bahwa semua utilitas <code>os.PathLike</code> untuk bekerja dengan path file sekarang harus bekerja dengan string dan <code>Path</code> . </p><br><h3 id="no-v-moey-lyubimoy-biblioteke-est-path-luchshe-standartnogo">  Tetapi perpustakaan favorit saya memiliki Path, lebih baik dari standar! </h3><br><p>  Anda mungkin sudah menggunakan perpustakaan pihak ketiga yang menyediakan implementasi <code>Path</code> -nya, yang berbeda dari yang standar.  Mungkin Anda lebih menyukainya. </p><br><p>  Sebagai contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">django</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-viron</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">path.py</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plumbum</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">visidata masing-masing</a> berisi objek <code>Path</code> mereka sendiri.  Beberapa perpustakaan ini lebih tua dari <code>pathlib</code> , dan memutuskan untuk mewarisi dari <code>str</code> sehingga mereka dapat diteruskan ke fungsi yang mengharapkan string sebagai path.  Berkat PEP 519, mengintegrasikan perpustakaan pihak ketiga ke dalam kode Anda akan lebih mudah, dan tanpa perlu warisan dari <code>str</code> . </p><br><p>  Mari kita bayangkan bahwa Anda tidak ingin menggunakan <code>pathlib</code> , karena <code>Path</code> adalah objek yang tidak dapat diubah, dan Anda benar-benar ingin mengubah <code>pathlib</code> .  Dengan PEP 519, Anda dapat membuat versi <code>Path</code> terbaik yang bisa berubah-ubah.  Untuk melakukan ini, cukup terapkan metode <code>__fspath__</code> </p><br><p>  Implementasi <code>Path</code> pun yang ditulis sendiri sekarang dapat berfungsi dengan fungsi bawaan Python yang mengharapkan path file.  <strong>Bahkan jika Anda tidak suka <code>pathlib</code> , fakta keberadaannya merupakan nilai tambah yang besar untuk perpustakaan pihak ketiga dengan <code>Path</code> mereka sendiri</strong> </p><br><h3 id="no-ved-pathlibpath-i-str-ne-smeshivayutsya-pravda">  Tapi <code>pathlib.Path</code> dan <code>str</code> tidak tercampur, kan? </h3><br><p>  Anda mungkin berpikir: ini semua, tentu saja, hebat, tetapi akankah pendekatan ini dengan kadang-kadang-line-dan-kadang-kadang jalan menambahkan beberapa kompleksitas pada kode saya? </p><br><p>  Jawaban atas pertanyaan ini adalah ya, sampai batas tertentu.  Tetapi masalah ini memiliki solusi yang cukup sederhana. </p><br><p>  PEP 519 menambahkan beberapa hal lain selain <code>PathLike</code> : pertama, ini adalah cara untuk mengubah <code>PathLike</code> apa pun menjadi string, dan kedua, itu adalah cara untuk mengubah <code>PathLike</code> apa pun menjadi <code>Path</code> . </p><br><p>  Mari kita ambil dua objek - string dan <code>Path</code> (atau apa pun dengan metode <strong>fspath</strong> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path p1 = os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>) p2 = Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  Fungsi <code>os.fspath</code> menormalkan kedua objek dan mengubahnya menjadi string: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fspath &gt;&gt;&gt; fspath(p1), fspath(p2) (<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>, <span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  Dalam hal ini, <code>Path</code> dapat mengambil kedua objek ini menjadi sebuah konstruktor dan mengubahnya menjadi <code>Path</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(p1), Path(p2) (PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>), PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))</code> </pre> <br><p>  Ini berarti Anda dapat mengonversi hasil <code>make_editorconfig</code> kembali ke <code>Path</code> jika perlu: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; Path(make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))) PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span>)</code> </pre> <br><p>  Meskipun, tentu saja, solusi terbaik adalah menulis ulang <code>make_editorconfig</code> menggunakan <code>pathlib</code> . </p><br><h3 id="pathlib-slishkom-medlennyy">  <code>pathlib</code> terlalu lambat </h3><br><p>  Saya telah melihat beberapa kali tentang kinerja <code>pathlib</code> .  Itu benar - <code>pathlib</code> bisa lambat.  Membuat ribuan objek <code>Path</code> dapat secara signifikan mempengaruhi perilaku program. </p><br><p>  Saya memutuskan untuk mengukur kinerja <code>pathlib</code> dan <code>os.path</code> di komputer saya menggunakan dua program berbeda yang mencari semua file <code>.py</code> di direktori saat ini </p><br><p>  Ini adalah versi <code>os.walk</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filename.endswith(extension): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Dan ini adalah versi dengan <code>Path.rglob</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">f'*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{extension}</span></span></span><span class="hljs-string">'</span></span>): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Menguji kinerja program yang bekerja dengan sistem file adalah tugas yang rumit, karena waktu operasi dapat berubah cukup banyak.  Saya memutuskan untuk menjalankan setiap skrip 10 kali dan membandingkan hasil terbaik untuk setiap program. </p><br><p>  Kedua program menemukan 97507 file di direktori tempat saya menjalankannya.  Yang pertama bekerja dalam 1,914 detik, yang kedua selesai dalam 3,430 detik. </p><br><p>  Ketika saya mengatur parameter <code>extension=''</code> , program-program ini menemukan sekitar 600.000 file, dan perbedaannya meningkat.  Program pertama bekerja dalam 1,888 detik, dan yang kedua dalam 7,485 detik. </p><br><p>  Jadi, <code>pathlib</code> sekitar <strong>dua kali lebih</strong> lambat untuk file dengan ekstensi <code>.py</code> , dan <strong>empat kali lebih lambat</strong> ketika diluncurkan di direktori home saya.  Kesenjangan kinerja relatif antara <code>pathlib</code> dan <code>os</code> luas. </p><br><p>  Dalam kasus saya, kecepatan ini tidak banyak berubah.  Saya mencari semua file di direktori saya dan kehilangan 6 detik.  Jika saya memiliki tugas memproses 10 juta file, kemungkinan besar saya akan menulis ulang.  Tetapi sementara tidak ada kebutuhan seperti itu, Anda bisa menunggu. </p><br><p>  Jika Anda memiliki sepotong kode yang panas dan <code>pathlib</code> jelas berdampak negatif terhadap operasinya, tidak ada yang salah dengan menggantinya dengan alternatif.  <strong>Anda sebaiknya tidak mengoptimalkan kode, yang bukan merupakan hambatan</strong> - ini adalah pemborosan waktu, yang juga biasanya mengarah pada kode yang sulit dibaca, tanpa banyak buang. </p><br><h3 id="uluchshenie-chitaemosti">  Peningkatan keterbacaan </h3><br><p>  Saya ingin mengakhiri aliran pemikiran ini dengan beberapa contoh refactoring menggunakan <code>pathlib</code> .  Saya mengambil beberapa contoh kecil kode yang berfungsi dengan file dan membuatnya bekerja dengan <code>pathlib</code> .  Saya akan meninggalkan sebagian besar kode tanpa mengomentari pengadilan Anda - memutuskan versi mana yang paling Anda sukai. </p><br><p>  Ini adalah fungsi <code>make_editorconfig</code> kita lihat sebelumnya: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  Dan ini adalah versi yang ditulis ulang di <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filepath."""</span></span> path = Path(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.exists(): path.parent.mkdir(exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, parent=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) path.touch() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br><p>  Berikut adalah program konsol yang mengambil garis dengan direktori dan mencetak isi file <code>.gitignore</code> , jika ada: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] ignore_filename = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isfile(ignore_filename): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(ignore_filename, mode=<span class="hljs-string"><span class="hljs-string">'rt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ignore_file: print(ignore_file.read(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Hal yang sama dengan <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = Path(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ignore_path = directory / <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ignore_path.is_file(): print(ignore_path.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Berikut adalah program yang mencetak semua file duplikat di folder dan subfolder saat ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(filepath): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.path.join(root, filename) file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> my_file: file_hash = md5(my_file.read()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre> <br><p>  Hal yang sama dengan c <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path(filepath).rglob(<span class="hljs-string"><span class="hljs-string">'*'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.is_file(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> path file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(Path.cwd()): file_hash = md5(path.read_bytes()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br><p>  , , -,     .       <code>pathlib</code> . </p><br><h3 id="nachnite-ispolzovat-obekty-pathlibpath">    <code>pathlib.Path</code> </h3><br><p>  . </p><br><p>  <code>/</code>   <code>pathlib.Path</code>         .   ,    <strong>      </strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>path1 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>, <span class="hljs-string"><span class="hljs-string">'file'</span></span>) &gt;&gt;&gt; path2 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>) / <span class="hljs-string"><span class="hljs-string">'file'</span></span> &gt;&gt;&gt; path3 = Path(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path3 WindowsPath(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path1 == path2 == path3 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>   Python  (. <code>open</code> )   <code>Path</code> ,  ,  <strong>   <code>pathlib</code> ,        !</strong> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> move <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rename_and_redirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_filename, new_filename)</span></span></span><span class="hljs-function">:</span></span> move(old, new) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(old, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(<span class="hljs-string"><span class="hljs-string">f'This file has moved to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{new}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; old, new = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>), Path(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>) &gt;&gt;&gt; rename_and_redirect(old, new) &gt;&gt;&gt; old.read_text() <span class="hljs-string"><span class="hljs-string">'This file has moved to new.txt'</span></span></code> </pre> <br><p>      <code>pathlib</code> ,     ,    <code>PathLike</code> .  ,   <strong>      ,       ,   PEP 519</strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; my_path = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(my_path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: ... print(f.read()) ... This file has moved to new.txt</code> </pre> <br><p>   <code>pathlib</code>    ,      (  ,    ),    <strong>         ,   </strong> . </p><br><p>  , <code>pathlib</code>     .       Python     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path gitignore = Path(<span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gitignore.is_file(): print(gitignore.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  <code>pathlib</code> — .    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453862/">https://habr.com/ru/post/id453862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453846/index.html">Intisari acara untuk profesional SDM di bidang TI untuk Juni 2019</a></li>
<li><a href="../id453848/index.html">AlphaFold: Menggunakan AI untuk Penemuan Ilmiah</a></li>
<li><a href="../id453850/index.html">Sistem Kredit Sosial Tiongkok - Apakah Iblis Begitu Mengerikan?</a></li>
<li><a href="../id453852/index.html">Mikrobiota. Cara merawat bakteri usus</a></li>
<li><a href="../id453860/index.html">AMD memperkenalkan prosesor baru 7 nm Ryzen generasi ketiga</a></li>
<li><a href="../id453864/index.html">Menggunakan mouse dan keyboard di konsol curang?</a></li>
<li><a href="../id453866/index.html">Permintaan API dengan React Hooks, HOC, atau Render Prop</a></li>
<li><a href="../id453868/index.html">Sentuh sakelar mini dengan panel kaca di nRF52832</a></li>
<li><a href="../id453870/index.html">Kami menulis Reverse socks5 proxy di PowerShell</a></li>
<li><a href="../id453872/index.html">Mengembalikan foto menggunakan jaringan saraf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>