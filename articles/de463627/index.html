<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì¥ üë©‚Äçüíª ü¶ì Assembler-Codegenerator-Bibliothek f√ºr AVR-Mikrocontroller. Teil 4 üò´ ‚úãüèø üëµüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Üê Teil 3. Indirekte Adressierung und Flusskontrolle 
 Teil 5. Entwerfen von Multithread-Anwendungen. ‚Üí 
 Assembler Code Generator Library f√ºr AVR-Mikr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembler-Codegenerator-Bibliothek f√ºr AVR-Mikrocontroller. Teil 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463627/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Üê Teil 3. Indirekte Adressierung und Flusskontrolle</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5. Entwerfen von Multithread-Anwendungen.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Üí</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Assembler Code Generator Library f√ºr AVR-Mikrocontroller </h2><br><h3 id="chast-4-programmirovanie-periferiynyh-ustroystv-i-obrabotka-preryvaniy">  Teil 4. Programmieren von Peripherieger√§ten und Behandeln von Interrupts </h3><br><p>  In diesem Teil des Beitrags werden wir uns, wie versprochen, mit einem der beliebtesten Aspekte der Mikrocontroller-Programmierung befassen - n√§mlich der Arbeit mit Peripherieger√§ten.  Es gibt zwei g√§ngige Ans√§tze f√ºr die periphere Programmierung.  Erstens wei√ü das Programmiersystem nichts √ºber Peripherieger√§te und bietet nur Mittel f√ºr den Zugriff auf Ger√§testeuerungsports.  Dieser Ansatz unterscheidet sich praktisch nicht von der Arbeit mit Ger√§ten auf Assembler-Ebene und erfordert eine gr√ºndliche Untersuchung des Zwecks aller Ports, die mit dem Betrieb eines bestimmten Peripherieger√§ts verbunden sind.  Um die Arbeit der Programmierer zu erleichtern, gibt es spezielle Programme, deren Hilfe jedoch in der Regel mit der Generierung einer Sequenz der anf√§nglichen Ger√§teinitialisierung endet.  Der Vorteil dieses Ansatzes ist der vollst√§ndige Zugriff auf alle Peripheriefunktionen, und der Nachteil ist die Komplexit√§t der Programmierung und die gro√üe Menge an Programmcode. </p><br><p>  Die zweite Arbeit mit Peripherieger√§ten erfolgt auf der Ebene der virtuellen Ger√§te.  Der Hauptvorteil dieses Ansatzes ist die Einfachheit der Ger√§teverwaltung und die F√§higkeit, mit ihnen zu arbeiten, ohne auf die jeweilige Hardwareimplementierung einzugehen.  Der Nachteil dieses Ansatzes ist die Einschr√§nkung der F√§higkeiten von Peripherieger√§ten durch den Zweck und die Funktionen des emulierten virtuellen Ger√§ts. </p><br><p>  Die NanoRTOS-Bibliothek implementiert einen dritten Ansatz.  Jedes Peripherieger√§t wird von einer speziellen Klasse beschrieben, deren Zweck darin besteht, die Einrichtung und den Betrieb des Ger√§ts zu vereinfachen und gleichzeitig seine volle Funktionalit√§t beizubehalten.  Es ist besser, die Funktionen dieses Ansatzes anhand von Beispielen zu demonstrieren. Beginnen wir also. </p><a name="habracut"></a><br><p>  Beginnen wir mit dem einfachsten und gebr√§uchlichsten Peripherieger√§t - dem digitalen Ein- / Ausgangsanschluss.  Dieser Port kombiniert bis zu 8 Kan√§le, von denen jeder unabh√§ngig f√ºr die Ein- oder Ausgabe konfiguriert werden kann.  Eine Klarstellung auf 8 bedeutet, dass die Controller-Architektur die M√∂glichkeit impliziert, alternative Funktionen f√ºr einzelne Port-Bits zuzuweisen, was deren Verwendung als Wasser- / Ausgangsports ausschlie√üt, wodurch die Anzahl der verf√ºgbaren Bits verringert wird.  Setup und weitere Arbeiten k√∂nnen sowohl auf der Ebene eines separaten Bits als auch auf der Ebene des gesamten Ports ausgef√ºhrt werden (Schreiben und Lesen aller 8 Bits mit einem Befehl).  Der in den Beispielen verwendete Mega328-Controller verf√ºgt √ºber 3 Ports: B, C und D. Im Ausgangszustand sind aus Sicht der Bibliothek die Entladungen aller Ports neutral.  Dies bedeutet, dass f√ºr ihre Aktivierung der Verwendungsmodus angegeben werden muss.  Bei dem Versuch, auf einen nicht aktivierten Port zuzugreifen, generiert das Programm einen Kompilierungsfehler.  Dies geschieht, um m√∂gliche Konflikte bei der Zuweisung alternativer Funktionen zu vermeiden.  Um Ports in den Eingabe- / Ausgabemodus zu schalten, verwenden Sie die <em>Mode-</em> Befehle, um den Einzelbitmodus festzulegen, und <em>Direction</em> , um den Modus aller Portbits mit einem Befehl festzulegen.  Aus programmtechnischer Sicht sind alle Ports gleich und ihr Verhalten wird von einer Klasse beschrieben. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT;<span class="hljs-comment"><span class="hljs-comment">// 0   B    m.PortC.Direction(0xFF);//       m.PortB.Activate(); //   m.PortC.Activate(); //  C //   m.PortB[0].Set(); //  0   B  1 m.PortB[0].Clear();//  0   B  0 m.PortB[0].Toggle();//  0   B   m.PortC.Write(0b11000000);// 6  7        var rr = m.REG(); //     rr.Load(0xC0); m.PortC.Write(rr);//      rr var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Das obige Beispiel zeigt, wie die Datenausgabe √ºber Ports organisiert werden kann.  Die Arbeit mit Port B erfolgt hier auf der Ebene einer Kategorie und mit Port C auf der Ebene des gesamten Ports.  Beachten Sie den <em>Aktivierungsbefehl Activate ()</em> .  Sein Zweck besteht darin, im Ausgabecode eine Folge von Ger√§teinitialisierungsbefehlen gem√§√ü den zuvor festgelegten Eigenschaften zu erzeugen.  Daher verwendet der Befehl <em>Activate ()</em> immer den Satz von eingestellten Parametern, der zum Zeitpunkt der Ausf√ºhrung aktuell ist.  Betrachten Sie ein Beispiel f√ºr das Lesen von Daten von einem Port. </p><br><pre> <code class="cs hljs"> m.PortB.Activate(); <span class="hljs-comment"><span class="hljs-comment">//  B m.PortC.Activate(); //  C Bit dd = m.BIT(); //     Register rr = m.REG(); //     m.PortB[0].Read(dd); //  0   B m.PortC.Read(rr);//      rr var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  In diesem Beispiel wurde ein neuer <em>Bit-</em> Datentyp angezeigt.  Das n√§chste Analogon dieses Typs in Hochsprachen ist der <em>Bool-</em> Typ.  Der <em>Bit-</em> Datentyp wird zum Speichern nur eines Informationsbits verwendet und erm√∂glicht die Verwendung seines Werts als Bedingung f√ºr Verzweigungsoperationen.  Um Speicherplatz zu sparen, werden Bitvariablen w√§hrend der Speicherung so zu Bl√∂cken zusammengefasst, dass in einem ROZ-Register 8 Variablen vom Typ <em>Bit</em> gespeichert werden.  Zus√§tzlich zu dem beschriebenen Typ enth√§lt die Bibliothek zwei weitere Bitdatentypen: <em>Pin</em> , der dieselbe Funktionalit√§t wie Bit hat, jedoch E / A- und <em>Mbit-</em> Register zum Speichern von Bitvariablen im RAM-Speicher verwendet.  Mal sehen, wie Sie Bitvariablen verwenden k√∂nnen, um Zweige zu organisieren </p><br><pre> <code class="cs hljs">m.IF(m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>], () =&gt; AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">",   = 1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = m.BIT(); b.Set(); m.IF(b, () =&gt; AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">",   b "</span></span>));</code> </pre> <br><p>  Die erste Zeile √ºberpr√ºft den Status des Eingangsports, und wenn an Eingang 1 der Code des bedingten Blocks ausgef√ºhrt wird.  Die letzte Zeile enth√§lt ein Beispiel, in dem eine Variable vom Typ <em>Bit</em> als Verzweigungsbedingung verwendet wird. </p><br><p>  Das n√§chste h√§ufig verwendete Peripherieger√§t kann als Hardware-Z√§hler / Timer betrachtet werden.  In AVR-Mikrocontrollern verf√ºgt dieses Ger√§t √ºber eine Vielzahl von Funktionen und kann je nach Einstellung verwendet werden, um eine Verz√∂gerung zu erzeugen, einen M√§ander mit einer programmierbaren Frequenz zu erzeugen, die Frequenz eines externen Signals zu messen und auch als Multimode-PWM-Modulator.  Im Gegensatz zu E / A-Ports verf√ºgt jeder der Mega328-Timer √ºber einzigartige Funktionen.  Daher wird jeder Timer durch eine separate Klasse beschrieben. </p><br><p>  Betrachten wir sie genauer.  Als Signalquelle jedes Timers k√∂nnen sowohl ein externes Signal als auch der interne Takt des Prozessors verwendet werden.  Mit den Hardwareeinstellungen des Mikrocontrollers k√∂nnen Sie die Verwendung der vollen Frequenz f√ºr Peripherieger√§te konfigurieren oder den einzelnen Splitter f√ºr alle Peripherieger√§te um 8 einschalten. Da der Mikrocontroller den Betrieb in einem weiten Frequenzbereich erm√∂glicht, muss f√ºr die korrekte Berechnung der Timer-Teilerwerte f√ºr die erforderliche Verz√∂gerung w√§hrend der internen Taktung die Prozessorfrequenz angegeben werden und Prescaler-Modus.  Daher hat der Abschnitt mit den Timer-Einstellungen die folgende Form </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   m.CKDIV8 = false; //     //    Timer1 m.Timer1.Clock = eTimerClockSource.CLK256; //   m.Timer1.OCRA = (ushort)((0.5 * m.FCLK) / 256); //    A m.Timer1.Mode = eWaveFormMode.CTC_OCRA; //    m.Timer1.Activate(); //    Timer1</span></span></code> </pre> <br><p>  Zum Einstellen des Timers m√ºssen Sie nat√ºrlich die Dokumentation des Herstellers lesen, um den richtigen Modus auszuw√§hlen und den Zweck der verschiedenen Einstellungen zu verstehen. Die Verwendung der Bibliothek erleichtert jedoch das Arbeiten mit dem Ger√§t und beh√§lt die M√∂glichkeit, alle Ger√§temodi zu verwenden. </p><br><p>  Jetzt schlage ich eine kleine Ablenkung von der Beschreibung der Verwendung bestimmter Ger√§te vor und diskutiere, bevor ich fortfahre, das Problem des asynchronen Betriebs.  Der Hauptvorteil von Peripherieger√§ten besteht darin, dass sie bestimmte Funktionen ausf√ºhren k√∂nnen, ohne CPU-Ressourcen zu verwenden.  Bei der Organisation der Interaktion zwischen dem Programm und dem Ger√§t kann Komplexit√§t auftreten, da die Ereignisse, die w√§hrend des Betriebs des Peripherieger√§ts auftreten, in Bezug auf den Codeausf√ºhrungsfluss in der CPU asynchron sind.  Synchrone Interaktionsmethoden, bei denen das Programm Zyklen zum Warten auf den gew√ºnschten Ger√§testatus enth√§lt, machen fast alle Vorteile der Peripherie als unabh√§ngige Ger√§te zunichte.  Effizienter und bevorzugter ist der Interrupt-Modus.  In diesem Modus f√ºhrt der Prozessor kontinuierlich den Code des Hauptthreads aus und schaltet den Ausf√ºhrungsthread bei Auftreten des Ereignisses auf seinen Handler um.  Am Ende der Verarbeitung kehrt die Steuerung zum Hauptthread zur√ºck.  Die Vorz√ºge dieses Ansatzes liegen auf der Hand, seine Verwendung kann jedoch durch die Komplexit√§t des Aufbaus erschwert werden.  Um im Assembler einen Interrupt zu verwenden, m√ºssen Sie: </p><br><ul><li>  Stellen Sie die richtige Adresse in der Interrupt-Tabelle ein. </li><li>  Konfigurieren Sie das Ger√§t selbst so, dass es mit Unterbrechungen arbeitet. </li><li>  Beschreiben der Interrupt-Behandlungsfunktion </li><li>  Sorgen Sie daf√ºr, dass alle verwendeten Register und Flags erhalten bleiben, damit der Interrupt den Fortschritt des Hauptthreads nicht beeintr√§chtigt </li><li>  Aktivieren Sie globale Interrupts. </li></ul><br><p>  Um die Programmierung der Arbeit durch Interrupts zu vereinfachen, enthalten die Beschreibungsklassen f√ºr Bibliotheksperipherieger√§te die Eigenschaften eines Ereignishandlers.  Um die Arbeit mit einem Peripherieger√§t √ºber Interrupts zu organisieren, m√ºssen Sie nur den Code f√ºr die Verarbeitung des erforderlichen Ereignisses beschreiben, und die Bibliothek nimmt alle anderen Einstellungen selbst vor.  Kehren wir zur Timer-Einstellung zur√ºck und erg√§nzen sie mit der Definition des Codes, der ausgef√ºhrt werden soll, wenn die Schwellenwerte f√ºr den Vergleich der Timer-Vergleichskan√§le erreicht sind.  Angenommen, wir m√∂chten, dass beim Ausl√∂sen von Schwellenwerten der Vergleichskan√§le bestimmte Bits der E / A-Ports beim √úberlaufen zur√ºckgesetzt werden.  Mit anderen Worten, wir m√∂chten unter Verwendung eines Zeitgebers die Funktion des Erzeugens eines PWM-Signals an ausgew√§hlten beliebigen Ports mit einem Arbeitszyklus implementieren, der durch die <em>OCRA-</em> Werte f√ºr den ersten und <em>OCRB</em> f√ºr den zweiten Kanal bestimmt wird.  Mal sehen, wie der Code in diesem Fall aussehen wird. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>]; bit1.Mode = ePinMode.OUT; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; bit2.Mode = ePinMode.OUT; m.PortB.Activate(); <span class="hljs-comment"><span class="hljs-comment">//  0  1   B   //     m.Timer0.Clock = eTimerClockSource.CLK; m.Timer0.OCRA = 50; m.Timer0.OCRB = 170; m.Timer0.Mode = eWaveFormMode.PWMPC_TOP8; //   m.Timer0.OnCompareA = () =&gt; bit1.Set(); m.Timer0.OnCompareB = () =&gt;bit2.Set(); m.Timer0.OnOverflow = () =&gt; m.PortB.Write(0); m.Timer0.Activate(); m.EnableInterrupt(); //  //   m.LOOP(m.TempH, (r, l) =&gt; m.GO(l), (r) =&gt; { });</span></span></code> </pre> <br><p>  Der Teil bez√ºglich der Einstellung der Timer-Modi wurde bereits fr√ºher betrachtet. Gehen wir also gleich zu den Interrupt-Handlern √ºber.  In diesem Beispiel werden drei Handler verwendet, um zwei PWM-Kan√§le mit einem Timer zu implementieren.  Der Code der Handler ist ziemlich offensichtlich, aber es kann sich die Frage stellen, wie das zuvor erw√§hnte Speichern des Zustands implementiert wird, so dass der Interrupt-Aufruf die Logik des Hauptthreads nicht beeinflusst.  Die L√∂sung, in der alle Register und Flags gespeichert sind, sieht eindeutig redundant aus. Daher analysiert die Bibliothek den Ressourcenverbrauch im Interrupt und speichert nur das erforderliche Minimum.  Die leere Hauptschleife best√§tigt die Idee, dass die Aufgabe der kontinuierlichen Erzeugung mehrerer PWM-Signale ohne die Teilnahme des Hauptprogramms funktioniert. </p><br><p>  Es ist zu beachten, dass die Bibliothek einen einheitlichen Ansatz f√ºr die Arbeit mit Interrupts f√ºr alle Beschreibungsklassen f√ºr Peripherieger√§te implementiert.  Dies vereinfacht die Programmierung und reduziert Fehler. </p><br><p>  Wir werden die Arbeit mit Interrupts weiter untersuchen und eine Situation betrachten, in der das Klicken auf die an den Eingangsports angebrachten Schaltfl√§chen bestimmte Aktionen des Programms hervorrufen sollte.  In dem Prozessor, den wir betrachten, gibt es zwei M√∂glichkeiten, Interrupts zu erzeugen, wenn sich der Status der Eingangsports √§ndert.  Am weitesten fortgeschritten ist die Verwendung des externen Interrupt-Modus.  In diesem Fall k√∂nnen wir f√ºr jede der Schlussfolgerungen separate Interrupts generieren und die Reaktion nur auf ein bestimmtes Ereignis (Front, Rezession, Level) konfigurieren.  Leider gibt es nur zwei davon in unserem Kristall.  Eine andere Methode erm√∂glicht es Ihnen, mittels Interrupts eines der Bits des Eingangsports zu steuern. Die Verarbeitung ist jedoch komplizierter, da das Ereignis auf Portebene auftritt, wenn sich das Eingangssignal eines der konfigurierten Bits √§ndert, und die weitere Kl√§rung der Ursache des Interrupts auf Algorithmenebene durch Software erfolgen sollte . </p><br><p>  Zur Veranschaulichung werden wir versuchen, das Problem der Steuerung des Status der Portausgabe mit zwei Tasten zu l√∂sen.  Einer von ihnen sollte den Wert des von uns angegebenen Ports auf 1 setzen und der andere zur√ºcksetzen.  Da es nur zwei Schaltfl√§chen gibt, werden wir die M√∂glichkeit nutzen, externe Interrupts zu verwenden. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortD[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT; m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0x0C</span></span>); <span class="hljs-comment"><span class="hljs-comment">// pull-up   m.INT0.Mode = eExtIntMode.Falling; //  INT0  . m.INT0.OnChange = () =&gt; m.PortD[0].Set(); //      1 m.INT1.Mode = eExtIntMode.Falling; //  INT1  . m.INT1.OnChange = () =&gt; m.PortD[0].Clear(); //     //  m.INT0.Activate(); m.INT1.Activate(); m.PortD.Activate(); m.EnableInterrupt(); //   //  m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { });</span></span></code> </pre> <br><p>  Durch die Verwendung externer Interrupts konnten wir unser Problem so einfach und klar wie m√∂glich l√∂sen. </p><br><p>  Die programmgesteuerte Verwaltung externer Ports ist nicht die einzig m√∂gliche M√∂glichkeit.  Insbesondere haben Timer eine Einstellung, mit der sie den Ausgang des Mikrocontrollers direkt steuern k√∂nnen.  Dazu m√ºssen Sie in der Timer-Einstellung den Ausgangssteuerungsmodus angeben </p><br><pre> <code class="cs hljs">m.Timer0.CompareModeA = eCompareMatchMode.Set;</code> </pre> <br><p>  Nach dem Aktivieren des Timers erh√§lt das 6. Bit von Port D eine alternative Funktion und wird von einem Timer gesteuert.  Somit k√∂nnen wir ein PWM-Signal am Prozessorausgang nur auf Hardwareebene erzeugen, indem wir nur Software verwenden, um die Signalparameter einzustellen.  Wenn wir gleichzeitig versuchen, mithilfe der Bibliothekstools den Besetzt-Port als Eingabe- / Ausgabe-Port zu verwenden, wird auf Kompilierungsebene ein Fehler angezeigt. </p><br><p>  Das letzte Ger√§t, das wir in diesem Teil des Artikels betrachten werden, ist die serielle USART-Schnittstelle.  Die Funktionalit√§t dieses Ger√§ts ist sehr breit, aber bisher werden wir nur einen der h√§ufigsten Anwendungsf√§lle f√ºr dieses Ger√§t ansprechen. </p><br><p>  Der beliebteste Anwendungsfall f√ºr diesen Port ist das Anschlie√üen eines seriellen Terminals an Eingabe- / Ausgabetextinformationen.  Der Teil des Codes bez√ºglich der Porteinstellungen in diesem Fall kann wie folgt aussehen </p><br><pre> <code class="cs hljs">m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   m.CKDIV8 = false; //     m.Usart.Mode = eUartMode.UART; //    UART m.Usart.Baudrate = 9600; //   9600  m.Usart.FrameFormat = eUartFrame.U8N1; //   8N1</span></span></code> </pre> <br><p>  Die angegebenen Einstellungen stimmen mit den Standardeinstellungen des USART in der Bibliothek √ºberein, daher k√∂nnen sie im Programmtext teilweise oder vollst√§ndig √ºbersprungen werden. </p><br><p>  Stellen Sie sich ein kleines Beispiel vor, in dem wir statischen Text an das Terminal ausgeben.  Um den Code nicht aufzublasen, beschr√§nken wir uns auf die Ausgabe an das Terminal der klassischen "Hallo Welt!"  zu Beginn des Programms. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = m.ROMPTR(); <span class="hljs-comment"><span class="hljs-comment">//      m.CKDIV8 = false; m.FCLK = 16000000; //      m.Usart.Mode = eUartMode.UART; m.Usart.Baudrate = 9600; m.Usart.FrameFormat = eUartFrame.U8N1; //         m.Usart.OnTransmitComplete = () =&gt; { ptr.MLoadInc(m.TempL); m.IF(m.TempL!=0,()=&gt;m.Usart.Transmit(m.TempL)); }; m.Usart.Activate(); m.EnableInterrupt(); //   var str = Const.String("Hello world!"); //   ptr.Load(str); //     ptr.MloadInc(m.TempL); //    m.Usart.Transmit(m.TempL); //   . m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r,l) =&gt; { });</span></span></code> </pre> <br><p>  In diesem Programm wird aus dem Neuen die Deklaration der Konstantenzeichenfolge <em>str</em> .  Die Bibliothek legt alle konstanten Variablen im Programmspeicher ab. <em>Um</em> mit ihnen arbeiten zu k√∂nnen, m√ºssen Sie den <em>ROMPtr-</em> Zeiger verwenden.  Die Datenausgabe an das Terminal beginnt mit der Ausgabe des ersten Zeichens der Zeichenfolgenfolge. Danach geht die Steuerung sofort in die Hauptschleife, ohne auf das Ende der Ausgabe zu warten.  Der Abschluss des Byte√ºbertragungsprozesses verursacht einen Interrupt, in dessen Handler das n√§chste Zeichen der Zeile gelesen wird.  Wenn das Zeichen nicht gleich 0 ist (die Bibliothek verwendet das nullterminierte Format zum Speichern von Zeichenfolgen), wird dieses Zeichen an die serielle Schnittstelle gesendet.  Wenn wir das Ende der Zeile erreichen, wird das Zeichen nicht an den Port gesendet und der Sendezyklus endet. </p><br><p>  Der Nachteil dieses Ansatzes ist der feste Interrupt-Verarbeitungsalgorithmus.  Die serielle Schnittstelle darf nur zur Ausgabe statischer Zeichenfolgen verwendet werden.  Ein weiterer Nachteil dieser Implementierung ist das Fehlen eines Mechanismus zur √úberwachung der Hafenbelegung.  Wenn Sie versuchen, mehrere Leitungen nacheinander zu senden, kann es vorkommen, dass die √úbertragung vorheriger Leitungen unterbrochen oder die Leitungen gemischt werden. </p><br><p>  Effektivere Methoden zur L√∂sung dieses und anderer Probleme sowie zur Arbeit mit anderen Peripherieger√§ten werden wir im n√§chsten Teil des Beitrags sehen.  Darin werden wir uns die Programmierung mit der speziellen <em>Parallel</em> Task Management-Klasse genauer ansehen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463627/">https://habr.com/ru/post/de463627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463613/index.html">Docker-Images k√∂nnen auch mit der √ºblichen Docker-Datei in werf erstellt werden</a></li>
<li><a href="../de463617/index.html">Funktionen zum Testen von mobilem MMO</a></li>
<li><a href="../de463619/index.html">Fernarbeit: unsere Erfahrung</a></li>
<li><a href="../de463623/index.html">Wir werden aus dem Dschungel der Tests ausgew√§hlt: Wir bauen einen kurzen Weg von den Vorrichtungen zum Testen</a></li>
<li><a href="../de463625/index.html">Netzwerk√ºberwachung und Erkennung abnormaler Netzwerkaktivit√§ten mithilfe von Flowmon Networks-L√∂sungen</a></li>
<li><a href="../de463629/index.html">Konfigurieren von NextCloud + ONLYOFFICE auf demselben Server mit Docker</a></li>
<li><a href="../de463631/index.html">Dialoge √ºber Briefe</a></li>
<li><a href="../de463637/index.html">Testen Sie Ihre Infrastruktur als Code mit Pulumi. Teil 2</a></li>
<li><a href="../de463639/index.html">Nun, Apple BLEee</a></li>
<li><a href="../de463647/index.html">Videos und Berichte mit SmartMail Meetup: Frontend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>