<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕤 💅🏼 👩🏽‍🤝‍👨🏼 Tireur de réseau de navigateur sur Node.js 👨‍⚖️ 🗂️ 👨🏾‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le développement de jeux multijoueurs est compliqué pour de nombreuses raisons: leur hébergement peut être coûteux, la structure n'est pas évidente et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tireur de réseau de navigateur sur Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418411/"> Le développement de jeux multijoueurs est compliqué pour de nombreuses raisons: leur hébergement peut être coûteux, la structure n'est pas évidente et la mise en œuvre est difficile.  Dans ce tutoriel, je vais essayer de vous aider à surmonter la dernière barrière. <br><br>  Cet article est destiné aux développeurs qui peuvent créer des jeux et qui connaissent JavaScript, mais qui n'ont jamais écrit de jeux en ligne multijoueurs auparavant.  Après avoir terminé ce didacticiel, vous maîtriserez l'implémentation des composants réseau de base dans votre jeu et pourrez le développer en quelque chose de plus!  Voici ce que nous allons créer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/220/340/e9a22034098ab10a84721a48615a1476.png"></div><br>  Vous pouvez jouer le jeu terminé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> !  Lorsque vous appuyez sur les touches W ou "haut", le vaisseau s'approche du curseur, lorsque vous cliquez sur la souris, il tire.  <em>(Si personne n'est en ligne, pour vérifier le fonctionnement du multijoueur, ouvrez deux fenêtres de navigateur sur un ordinateur ou l'une d'entre elles sur le téléphone).</em>  Si vous souhaitez exécuter le jeu localement, le code source complet est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">GitHub</a> . <br><a name="habracut"></a><br>  Lors de la création du jeu, j'ai utilisé les ressources graphiques du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">Kenney's Pirate Pack</a> et du framework de jeu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">Phaser</a> .  Dans ce didacticiel, vous êtes affecté au rôle de programmeur réseau.  Le point de départ sera une version mono-utilisateur entièrement fonctionnelle du jeu, et notre tâche sera d'écrire un serveur sur Node.js en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Socket.io</a> pour la partie réseau.  Afin de ne pas surcharger le tutoriel, je vais me concentrer sur les parties liées au multijoueur et ignorer les concepts liés à Phaser et Node.js. <br><br>  Vous n'avez pas besoin de configurer quoi que ce soit localement, car nous allons créer ce jeu complètement dans le navigateur sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Glitch.com</a> !  Glitch est un outil génial pour créer des applications Web, y compris des backends, des bases de données, etc.  Il est idéal pour le prototypage, la formation et la collaboration, et je serai très heureux de vous présenter ses capacités dans ce tutoriel. <br><br>  Commençons. <br><br><h2>  1. Préparation </h2><br>  J'ai posté l'ébauche du projet sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">Glitch.com</a> . <br><br>  Conseils d'interface: vous pouvez lancer l'aperçu de l'application en cliquant sur le bouton <strong>Afficher</strong> (en haut à gauche). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac2/8b6/4dd/ac28b64dd9c37370872ad6a913b10078.png"></div><br>  La barre latérale verticale à gauche contient tous les fichiers d'application.  Pour éditer cette application, vous devez créer son «remix».  Nous allons donc en créer une copie dans notre compte (ou «fork» en jargon git).  Cliquez sur le bouton <strong>Remixer ce</strong> bouton. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/88f/6e4/f7188f6e4b66e9b9801d04c7891d42dd.png"></div><br>  À ce stade, vous modifiez l'application sous un compte anonyme.  Pour enregistrer votre travail, vous pouvez vous connecter (en haut à droite). <br><br>  Maintenant, avant de continuer, il est important que vous vous familiarisiez avec le jeu dans lequel nous ajouterons un mode multijoueur.  Jetez un œil à <strong>index.html</strong> .  Il a trois fonctions importantes que vous devez connaître: <code>preload</code> (ligne 99), <code>create</code> (ligne 115) et <code>GameLoop</code> (ligne 142), ainsi que l'objet joueur (ligne 35). <br><br>  Si vous préférez apprendre en vous entraînant, assurez-vous de comprendre le travail du jeu en effectuant les tâches suivantes: <br><br><ul><li>  Augmentez la taille du monde <em>(ligne 29)</em> - <em>notez qu'il existe une taille du monde distincte pour le monde du jeu et une taille de fenêtre pour le canevas de page lui-même</em> . </li><li>  Permet d'avancer à l'aide de «l'espace» <em>(ligne 53).</em> </li><li>  Modifiez le type de navire du joueur <em>(ligne 129).</em> </li><li>  Ralentissez le mouvement des obus <em>(ligne 155).</em> </li></ul><br><h3>  Installez Socket.io </h3><br>  Socket.io est une bibliothèque pour gérer les communications en temps réel à l'intérieur d'un navigateur à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebSockets</a> (au lieu d'utiliser des protocoles comme UDP, qui sont utilisés pour créer des jeux multijoueurs classiques).  De plus, la bibliothèque dispose de moyens redondants pour garantir son fonctionnement, même lorsque les WebSockets ne sont pas pris en charge.  Autrement dit, elle s'occupe des protocoles de messagerie et permet l'utilisation d'un système de messagerie basé sur les événements. <br><br>  La première chose que nous devons faire est d'installer le module Socket.io.  Dans Glitch, cela peut être fait en accédant au fichier <strong>package.json</strong> , puis en entrant le module requis dans les dépendances, ou en cliquant sur <strong>Ajouter un package</strong> et en entrant «socket.io». <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/41f/005/d9441f0059e23044aa69f6f8750c81bb.png"></div><br>  C'est le bon moment pour gérer les journaux du serveur.  Cliquez sur le bouton <strong>Journaux</strong> à gauche pour ouvrir le journal du serveur.  Vous devriez voir qu'il installe Socket.io avec toutes ses dépendances.  C'est là que vous devez rechercher toutes les erreurs et la sortie du code serveur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/6e1/58c/7db6e158c6e48d0d91f70344eaf51af7.png"></div><br>  Passons maintenant à <strong>server.js</strong> .  C'est là que se trouve notre code serveur.  Jusqu'à présent, il n'y a que du code standard pour servir notre HTML.  Ajoutez une ligne en haut du fichier pour activer Socket.io: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(http); <span class="hljs-comment"><span class="hljs-comment">//     http</span></span></code> </pre> <br>  Maintenant, nous devons également activer Socket.io dans le client, revenons donc à <strong>index.html</strong> et ajoutons les lignes suivantes à l'intérieur de la <code>&lt;head&gt;</code> : <br><br><pre> <code class="javascript hljs">&lt;!--    Socket.io --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"/socket.io/socket.io.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  <em>Remarque: Socket.io traite automatiquement le chargement de la bibliothèque cliente le long de ce chemin, donc cette ligne fonctionne même s'il n'y a pas de répertoire /socket.io/ dans vos dossiers.</em> <br><br>  Maintenant, Socket.io est inclus dans le projet et prêt à démarrer! <br><br><h2>  2. Reconnaissance et ponte des joueurs </h2><br>  Notre première vraie étape sera d'accepter les connexions sur le serveur et de créer de nouveaux joueurs dans le client. <br><br><h3>  Accepter les connexions au serveur </h3><br>  Ajoutez ce code au bas de <strong>server.js</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); })</span></span></code> </pre> <br>  Nous demandons donc à Socket.io d'écouter tous <code>connection</code> événements de <code>connection</code> qui se produisent automatiquement lorsqu'un client se connecte.  La bibliothèque crée un nouvel objet <code>socket</code> pour chaque client, où <code>socket.id</code> est l'identificateur unique de ce client. <br><br>  Pour vérifier que cela fonctionne, revenez au client ( <strong>index.html</strong> ) et ajoutez cette ligne quelque part dans la fonction de <strong>création</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> socket = io(); <span class="hljs-comment"><span class="hljs-comment">//    'connection'  </span></span></code> </pre> <br>  Si vous démarrez le jeu et regardez le journal du serveur (cliquez sur le bouton <strong>Journaux</strong> ), vous verrez que le serveur a enregistré cet événement de connexion! <br><br>  Maintenant, lors de la connexion d'un nouveau joueur, nous attendons de lui qu'il nous donne des informations sur son état.  Dans notre cas, nous devons connaître au moins <strong>x</strong> , <strong>y</strong> et l' <strong>angle</strong> afin de le créer correctement au bon point. <br><br>  L'événement de <code>connection</code> était un événement en ligne déclenché par Socket.io.  Nous pouvons écouter tous les événements définis indépendamment.  Je nommerai mon <code>new-player</code> événement, et je m'attendrai à ce que le client l'envoie dès qu'il se connecte avec des informations sur sa position.  Cela ressemblera à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); }) })</span></span></code> </pre> <br>  Si vous exécutez ce code, jusqu'à ce que vous voyiez quoi que ce soit dans le journal du serveur, car nous n'avons pas encore dit au client de générer cet événement de <code>new-player</code> .  Mais supposons un instant que nous l'avons déjà fait et continuons à travailler sur le serveur.  Que devrait-il se passer après avoir obtenu l'emplacement d'un nouveau joueur se joignant? <br><br>  Nous pouvons envoyer un message à tous les <em>autres</em> joueurs connectés afin qu'ils sachent qu'un nouveau joueur est apparu.  Socket.io a une fonction pratique pour cela: <br><br><pre> <code class="javascript hljs">socket.broadcast.emit(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,state_data);</code> </pre> <br>  Lorsque <code>socket.emit</code> appelé <code>socket.emit</code> message est simplement transmis à ce client unique.  Lorsque <code>socket.broadcast.emit</code> est appelé <code>socket.broadcast.emit</code> il est envoyé à chaque client connecté au serveur, sauf sur le socket duquel cette fonction a été appelée. <br><br>  La fonction <code>io.emit</code> envoie un message à chaque client connecté au serveur sans aucune exception.  Dans notre schéma, nous n'en avons pas besoin, car si nous recevons un message du serveur nous demandant de créer notre propre vaisseau, nous obtiendrons un double du sprite, car nous avons déjà créé notre propre vaisseau au début du jeu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici une astuce pratique</a> sur les différents types de fonctionnalités de messagerie que nous utiliserons dans ce didacticiel. <br><br>  Le code du serveur devrait maintenant ressembler à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); socket.broadcast.emit('create-player',state_data); }) })</span></span></code> </pre> <br>  Autrement dit, chaque fois qu'un joueur se connecte, nous nous attendons à ce qu'il nous envoie un message avec des informations sur sa position, et nous envoyons ces données à tous les autres joueurs afin qu'ils puissent créer son sprite. <br><br><h3>  Génération de clients </h3><br>  Maintenant, pour terminer ce cycle, nous devons effectuer deux actions dans le client: <br><br><ol><li>  Générez un message avec les données de notre emplacement après la connexion. </li><li>  Écoutez les événements de <code>create-player</code> et créez un joueur à ce stade. </li></ol><br>  Pour effectuer la première action après avoir créé un joueur dans la fonction de <strong>création</strong> (approximativement à la ligne 135), nous pouvons générer un message contenant les données de localisation que nous devons envoyer: <br><br><pre> <code class="javascript hljs">socket.emit(<span class="hljs-string"><span class="hljs-string">'new-player'</span></span>,{<span class="hljs-attr"><span class="hljs-attr">x</span></span>:player.sprite.x,<span class="hljs-attr"><span class="hljs-attr">y</span></span>:player.sprite.y,<span class="hljs-attr"><span class="hljs-attr">angle</span></span>:player.sprite.rotation})</code> </pre> <br>  Nous n'avons pas à nous soucier de la sérialisation des données envoyées.  Vous pouvez les transférer dans n'importe quel type d'objet, et Socket.io le traitera pour nous. <br><br>  Avant de continuer, <em>testez le code</em> .  Nous devrions voir un message similaire dans les journaux du serveur: <br><br><pre> <code class="javascript hljs">New player has state: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">728.8180247836519</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">261.9979387913289</span></span>, <span class="hljs-attr"><span class="hljs-attr">angle</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Nous savons maintenant que notre serveur reçoit une notification sur la connexion d'un nouveau lecteur et lit correctement les données sur son emplacement! <br><br>  Ensuite, nous voulons écouter les demandes de création d'un nouveau lecteur.  Nous pouvons placer ce code immédiatement après avoir généré le message, il devrait ressembler à ceci: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// CreateShip -      ,     CreateShip(1,state.x,state.y,state.angle) })</span></span></code> </pre> <br>  Testez maintenant <em>le code</em> .  Ouvrez deux fenêtres avec le jeu et assurez-vous que cela fonctionne. <br><br>  Vous devriez voir qu'après avoir ouvert deux clients, le premier client a créé deux navires et le second n'en a qu'un. <br><br><blockquote>  Tâche: pouvez-vous comprendre pourquoi cela s'est produit?  Ou comment pouvez-vous résoudre ce problème?  Suivez pas à pas la logique client / serveur que nous avons écrite et essayez de la déboguer. </blockquote><br>  J'espère que vous avez essayé de le découvrir par vous-même!  Voici ce qui se passe: lorsque le premier joueur se connecte, le serveur envoie un événement <code>create-player</code> à tous les autres joueurs, mais aucun joueur ne peut encore le recevoir.  Après avoir connecté le deuxième joueur, le serveur envoie à nouveau ses messages, et le premier joueur le reçoit et crée correctement le sprite, tandis que le deuxième joueur a raté le message du premier joueur. <br><br>  Autrement dit, le problème est que le deuxième joueur se connecte au jeu plus tard et qu'il a besoin de connaître l'état du jeu.  Nous devons informer tous les nouveaux joueurs connectés que les joueurs existent déjà (ainsi que d'autres événements qui ont eu lieu dans le monde) afin qu'ils puissent s'orienter.  Avant de passer à la résolution de ce problème, j'ai un bref avertissement. <br><br><h3>  Avertissement de synchronisation de l'état du jeu </h3><br>  Il existe deux approches pour implémenter la synchronisation de tous les joueurs.  La première consiste à envoyer un minimum d'informations sur les changements survenus sur le réseau.  Autrement dit, chaque fois qu'un nouveau joueur est connecté, nous n'enverrons à tous les autres joueurs que des informations sur ce nouveau joueur (et enverrons une liste de tous les autres joueurs du monde à ce nouveau joueur), et après la déconnexion, nous informerons tous les joueurs que ce joueur particulier s'est déconnecté. <br><br>  La deuxième approche consiste à transmettre l'état du jeu dans son intégralité.  Dans ce cas, chaque fois que vous vous connectez ou vous déconnectez, nous envoyons à chacun une liste complète de tous les joueurs. <br><br>  La première approche est meilleure en ce qu'elle minimise la quantité d'informations transmises sur le réseau, mais elle peut être très difficile à mettre en œuvre et il est probable que les joueurs ne soient pas synchronisés.  La seconde garantit que les joueurs sont toujours synchronisés, mais chaque message devra envoyer plus de données. <br><br>  Dans notre cas, au lieu d'essayer d'envoyer des messages lorsqu'un joueur est connecté pour le créer et lorsqu'il est déconnecté pour le supprimer, ainsi que lors d'un déplacement pour mettre à jour sa position, nous pouvons combiner tout cela en un seul événement de <code>update</code> commun.  Cet événement de mise à jour enverra toujours les positions de chaque joueur à tous les clients.  C'est ce que le serveur doit faire.  La tâche du client est de maintenir la conformité du monde avec l'état reçu. <br><br>  Pour mettre en œuvre un tel schéma, je ferai ce qui suit: <br><br><ol><li>  Je garderai un dictionnaire des joueurs, dont la clé sera leur identifiant, et la valeur sera les données sur leur emplacement. </li><li>  Ajoutez un lecteur à ce dictionnaire lorsqu'il est connecté et envoyez un événement de mise à jour. </li><li>  Supprimez le lecteur de ce dictionnaire lorsqu'il est éteint et envoyez un événement de mise à jour. </li></ol><br>  Vous pouvez essayer d'implémenter ce système vous-même, car ces étapes sont assez simples ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">mon conseil sur les fonctionnalités</a> peut être utile ici).  Voici à quoi pourrait ressembler l'implémentation complète: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    // 1 -      / var players = {}; io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); // 2 -      players[socket.id] = state_data; //    io.emit('update-players',players); }) socket.on('disconnect',function(){ // 3-       delete players[socket.id]; //    }) })</span></span></code> </pre> <br>  Le côté client est un peu plus compliqué.  D'une part, nous ne devrions plus nous préoccuper que de l'événement <code>update-players</code> , mais d'autre part, nous devrions envisager de créer de nouveaux navires si le serveur envoie plus de navires que nous ne le pensons, ou de les supprimer s'il y en a trop. <br><br>  Voici comment je gère cet événement dans le client: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     // : -         other_players = {} socket.on('update-players',function(players_data){ var players_found = {}; //        for(var id in players_data){ //      if(other_players[id] == undefined &amp;&amp; id != socket.id){ // ,      var data = players_data[id]; var p = CreateShip(1,data.x,data.y,data.angle); other_players[id] = p; console.log("Created new player at (" + data.x + ", " + data.y + ")"); } players_found[id] = true; //     if(id != socket.id){ other_players[id].x = players_data[id].x; //  ,    ,      other_players[id].y = players_data[id].y; other_players[id].rotation = players_data[id].angle; } } //       for(var id in other_players){ if(!players_found[id]){ other_players[id].destroy(); delete other_players[id]; } } })</span></span></code> </pre> <br>  Côté client, je stocke les vaisseaux dans le dictionnaire <code>other_players</code> , que je viens de définir en haut du script (il n'est pas affiché ici).  Étant donné que le serveur envoie les données des joueurs à tous les joueurs, je dois ajouter une vérification afin que le client ne crée pas de sprite supplémentaire pour lui-même.  (Si vous avez des problèmes avec la structuration, alors voici le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">code complet</a> qui devrait être dans index.html pour le moment). <br><br>  Testez maintenant <em>le code</em> .  Vous devriez pouvoir créer plusieurs clients et voir le nombre correct de navires créés dans les bonnes positions! <br><br><h2>  3. Synchronisation des positions des navires </h2><br>  Ici commence une partie très intéressante.  Nous voulons synchroniser les positions des navires sur tous les clients.  Cela révélera la simplicité de la structure que nous avons créée en ce moment.  Nous avons déjà un événement de mise à jour qui peut synchroniser les emplacements de tous les navires.  Il nous suffit de faire ce qui suit: <br><br><ol><li>  Forcer le client à générer un message chaque fois qu'il se déplace vers une nouvelle position. </li><li>  Apprenez au serveur à écouter ce message de déplacement et à mettre à jour l'élément de données du joueur dans le dictionnaire des <code>players</code> . </li><li>  Générez un événement de mise à jour pour tous les clients. </li></ol><br>  Et cela devrait suffire!  C'est maintenant à votre tour d'essayer de l'implémenter vous-même. <br><br>  Si vous êtes complètement confus et que vous avez besoin d'un indice, regardez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet terminé</a> . <br><br><h3>  Remarque sur la minimisation des données transmises sur le réseau </h3><br>  Le moyen le plus simple de le mettre en œuvre est de mettre à jour les positions de tous les joueurs à chaque fois qu'un événement de mouvement est reçu d' <em>un</em> joueur.  C'est formidable si les joueurs obtiennent toujours les dernières informations immédiatement après leur apparition, mais le nombre de messages transmis sur le réseau peut facilement atteindre des centaines par image.  Imaginez que vous avez 10 joueurs, chacun envoyant un message de mouvement dans chaque image.  Le serveur doit les renvoyer aux 10 joueurs.  C'est déjà 100 messages par trame! <br><br>  Il serait préférable de le faire: attendez que le serveur reçoive tous les messages de tous les joueurs, puis envoyez à tous les joueurs une grande mise à jour contenant toutes les informations.  Ainsi, nous réduirons le nombre de messages transmis au nombre d'utilisateurs présents dans le jeu (au lieu du carré de ce nombre).  Le problème ici est que tous les utilisateurs connaîtront le même retard que le lecteur avec la connexion la plus lente. <br><br>  Une autre solution consiste à envoyer les mises à jour du serveur à une fréquence constante, quel que soit le nombre de messages reçus du lecteur.  Une norme courante consiste à mettre à jour le serveur environ 30 fois par seconde. <br><br>  Cependant, lors du choix de la structure de votre serveur, vous devez évaluer le nombre de messages transmis dans chaque trame aux premiers stades du développement du jeu. <br><br><h2>  4. Synchronisation du shell </h2><br>  Nous avons presque fini!  La dernière partie sérieuse est la synchronisation sur un réseau de coques.  Nous pouvons l'implémenter de la même manière que les joueurs synchronisés: <br><br><ul><li>  Chaque client envoie les positions de tous ses coques dans chaque trame. </li><li>  Le serveur les redirige vers chaque joueur. </li></ul><br>  Mais il y a un problème. <br><br><h3>  Protection contre la triche </h3><br>  Si vous redirigez tout ce que le client envoie en tant que vraies positions des obus, le joueur peut facilement tricher en modifiant son client et en vous transmettant de fausses données, par exemple, des obus se téléportant aux positions des navires.  Vous pouvez facilement le vérifier vous-même en téléchargeant la page Web, en modifiant le code en JavaScript et en l'ouvrant à nouveau.  Et c'est un problème non seulement pour les jeux par navigateur.  Dans le cas général, nous ne pouvons jamais faire confiance aux données provenant de l'utilisateur. <br><br>  Pour résoudre partiellement ce problème, nous allons essayer d'utiliser un autre schéma: <br><br><ul><li>  Le client génère un message sur la coquille de tir avec sa position et sa direction. </li><li>  Le serveur simule le mouvement des obus. </li><li>  Le serveur met à jour les données de chaque client, en passant la position de tous les shells. </li><li>  Les clients rendent les obus dans les positions reçues du serveur. </li></ul><br>  Ainsi, le client est responsable de la position du projectile, mais pas de sa vitesse et non de son mouvement ultérieur.  Le client peut changer la position des obus pour lui-même, mais cela ne changera pas ce que les autres clients voient. <br><br>  Pour implémenter un tel schéma, nous ajouterons la génération de message lors du déclenchement.  Je ne créerai plus le sprite lui-même, car son existence et son emplacement seront entièrement déterminés par le serveur.  Maintenant, notre nouveau projectile tiré dans <strong>index.html</strong> ressemblera à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if(game.input.activePointer.leftButton.isDown &amp;&amp; !this.shot){ var speed_x = Math.cos(this.sprite.rotation + Math.PI/2) * 20; var speed_y = Math.sin(this.sprite.rotation + Math.PI/2) * 20; /*    ,       ,       var bullet = {}; bullet.speed_x = speed_x; bullet.speed_y = speed_y; bullet.sprite = game.add.sprite(this.sprite.x + bullet.speed_x,this.sprite.y + bullet.speed_y,'bullet'); bullet_array.push(bullet); */ this.shot = true; //  ,     socket.emit('shoot-bullet',{x:this.sprite.x,y:this.sprite.y,angle:this.sprite.rotation,speed_x:speed_x,speed_y:speed_y}) }</span></span></code> </pre> <br>  De plus, nous pouvons maintenant commenter le fragment de code entier en mettant à jour les shells dans le client: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,         //   for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.sprite.x += bullet.speed_x; bullet.sprite.y += bullet.speed_y; //  ,       if(bullet.sprite.x &lt; -10 || bullet.sprite.x &gt; WORLD_SIZE.w || bullet.sprite.y &lt; -10 || bullet.sprite.y &gt; WORLD_SIZE.h){ bullet.sprite.destroy(); bullet_array.splice(i,1); i--; } } */</span></span></code> </pre> <br>  Enfin, nous devons obliger le client à écouter les mises à jour du shell.  J'ai décidé de l'implémenter de la même manière qu'avec les joueurs, c'est-à-dire que le serveur envoie simplement un tableau de toutes les positions de shell dans un événement appelé <code>bullets-update</code> , et le client crée ou détruit des shells pour maintenir la synchronisation.  Voici à quoi ça ressemble: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     socket.on('bullets-update',function(server_bullet_array){ //     ,   for(var i=0;i&lt;server_bullet_array.length;i++){ if(bullet_array[i] == undefined){ bullet_array[i] = game.add.sprite(server_bullet_array[i].x,server_bullet_array[i].y,'bullet'); } else { //      ! bullet_array[i].x = server_bullet_array[i].x; bullet_array[i].y = server_bullet_array[i].y; } } //    ,   for(var i=server_bullet_array.length;i&lt;bullet_array.length;i++){ bullet_array[i].destroy(); bullet_array.splice(i,1); i--; } })</span></span></code> </pre> <br>   ,     .   ,    ,          ,      ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external"> </a> . <br><br>   server.js      .       ,    : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bullet_array = []; <span class="hljs-comment"><span class="hljs-comment">//        </span></span></code> </pre> <br>      : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   shoot-bullet        socket.on('shoot-bullet',function(data){ if(players[socket.id] == undefined) return; var new_bullet = data; data.owner_id = socket.id; //    id  bullet_array.push(new_bullet); });</span></span></code> </pre> <br>     60   : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   60       function ServerGameLoop(){ for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.x += bullet.speed_x; bullet.y += bullet.speed_y; // ,       if(bullet.x &lt; -10 || bullet.x &gt; 1000 || bullet.y &lt; -10 || bullet.y &gt; 1000){ bullet_array.splice(i,1); i--; } } } setInterval(ServerGameLoop, 16);</span></span></code> </pre> <br>    —     -    (     for): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    ,    io.emit("bullets-update",bullet_array);</span></span></code> </pre> <br>      !    ,    ,       . ,      ,     ,      . ,      ,   ,        ,     ,   ,    . <br><br><h2> 5.    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit de la dernière mécanique de base que nous implémentons. </font><font style="vertical-align: inherit;">J'espère que vous êtes déjà habitué à la procédure de planification de votre implémentation, en complétant tout d'abord l'implémentation client, puis en passant au serveur (ou vice versa). </font><font style="vertical-align: inherit;">Cette méthode est beaucoup moins sujette aux erreurs que de sauter lorsqu'elle est implémentée d'avant en arrière. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La vérification des collisions est un mécanisme de jeu crucial, nous voulons donc qu'il soit protégé contre la tricherie. </font><font style="vertical-align: inherit;">Nous l'implémentons sur le serveur de la même manière que nous l'avons fait avec les shells. </font><font style="vertical-align: inherit;">Nous avons besoin des éléments suivants:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vérifiez si le projectile est suffisamment proche de n'importe quel joueur sur le serveur. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Générez un événement pour tous les clients lorsqu'un projectile frappe un joueur. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apprenez au client à écouter l'événement à succès et à faire clignoter le navire lorsqu'il est touché. </font></font></li></ul><br>      .       ,    -  0: <br><br><pre> <code class="javascript hljs">player.sprite.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>         (    ).      ,      -      - : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> other_players){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(other_players[id].alpha &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>){ other_players[id].alpha += (<span class="hljs-number"><span class="hljs-number">1</span></span> - other_players[id].alpha) * <span class="hljs-number"><span class="hljs-number">0.16</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other_players[id].alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br>        ,        (          ). <br><br> ,                   ,    ,      .      ,    . <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Lissage de mouvement </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez terminé toutes les étapes jusqu'à ce point, je peux vous féliciter. </font><font style="vertical-align: inherit;">Vous venez de créer un jeu multijoueur fonctionnel! </font><font style="vertical-align: inherit;">Envoyez le lien à un ami et voyez comment la magie du multijoueur en ligne peut rassembler les joueurs! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le jeu est entièrement fonctionnel, mais notre travail ne s'arrête pas là. </font><font style="vertical-align: inherit;">Il y a quelques problèmes qui peuvent affecter négativement le gameplay, et nous devons y faire face:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si tout le monde n'a pas une connexion rapide, alors le mouvement des autres joueurs semble très nerveux. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les obus semblent lents, car ils ne sont pas tirés immédiatement. </font><font style="vertical-align: inherit;">Avant d'apparaître sur l'écran du client, ils attendent un message de retour du serveur.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons résoudre le premier problème en interpolant nos données de position du navire dans le client. Par conséquent, si nous ne recevons pas les mises à jour assez rapidement, nous pouvons déplacer facilement le navire à l'endroit où il devrait être, et pas seulement le téléporter là-bas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les coques nécessitent une solution plus complexe. Nous voulons que le serveur traite les obus pour se protéger contre la tricherie, mais nous avons également besoin d'une réaction instantanée: un tir et un projectile volant. La meilleure solution est une approche hybride. Le serveur et le client peuvent simuler des shells, et le serveur enverra toujours des mises à jour des positions des shells. S'ils ne sont pas synchronisés, nous supposons que le serveur a raison et redéfinissons la position du projectile dans le client. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'implémenterons pas ce système shell dans ce tutoriel, mais il est agréable de savoir que cette méthode existe.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interpolation simple des positions des navires est très simple. </font><font style="vertical-align: inherit;">Au lieu de définir une position directement dans l'événement de mise à jour, où nous recevons d'abord de nouvelles données de position, nous enregistrons simplement la position cible:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     if(id != socket.id){ other_players[id].target_x = players_data[id].x; //  ,    ,     other_players[id].target_y = players_data[id].y; other_players[id].target_rotation = players_data[id].angle; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, dans la fonction de mise à jour (également côté client), nous bouclons tous les autres joueurs et les poussons vers leur objectif: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,      for(var id in other_players){ var p = other_players[id]; if(p.target_x != undefined){ px += (p.target_x - px) * 0.16; py += (p.target_y - py) * 0.16; //  ,    /  var angle = p.target_rotation; var dir = (angle - p.rotation) / (Math.PI * 2); dir -= Math.round(dir); dir = dir * Math.PI * 2; p.rotation += dir * 0.16; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ainsi, le serveur nous envoie des mises à jour 30 fois par seconde, mais nous pouvons toujours jouer à 60 fps et le jeu semble toujours aussi fluide! </font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons examiné de nombreuses questions. Répertorions-les: nous avons appris à transférer des messages entre le client et le serveur, à synchroniser l'état du jeu, à le diffuser du serveur à tous les joueurs. C'est le moyen le plus simple de mettre en œuvre un jeu en ligne multijoueur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons également appris à protéger le jeu contre la triche, à simuler ses parties importantes sur le serveur et à informer les clients des résultats. Moins vous faites confiance au client, plus le jeu sera sûr.</font></font><br><br> ,  ,        .   —        (        ).         —        .         ,         , , ,      . <br><br>       —  ,      .        ,     ,   ,       .            .         .         . <br><br>        Glitch,             (Advanced Options)    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/d6b/dba/c62d6bdba51311a7a0d8976c37dbe6fb.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418411/">https://habr.com/ru/post/fr418411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418399/index.html">Sur la vague de Selectel FM</a></li>
<li><a href="../fr418401/index.html">Comment je ne suis pas devenu toi: un message d'amour pour les administrateurs système</a></li>
<li><a href="../fr418403/index.html">Exemple de programmation d'accélérateur FPGA</a></li>
<li><a href="../fr418405/index.html">Le principe de la pyramide inversée en analytique. Nous construisons un tableau de bord compréhensible</a></li>
<li><a href="../fr418407/index.html">L'extraction de cloud Hashflare a fermé. L'argent ne revient pas</a></li>
<li><a href="../fr418415/index.html">Telegram a présenté son propre service de passeport pour la vérification et l'autorisation des utilisateurs</a></li>
<li><a href="../fr418417/index.html">Apollo: 9 mois - vol normal</a></li>
<li><a href="../fr418419/index.html">Comment Dodo Pizza résout les problèmes commerciaux à l'aide de l'apprentissage automatique</a></li>
<li><a href="../fr418423/index.html">Maison intelligente: une nouvelle dimension de confort et la recherche de l'excellence. Première partie</a></li>
<li><a href="../fr418427/index.html">Indexation mobile d'abord. Comment et pourquoi le graphique des liens va-t-il changer?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>