<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∑Ô∏è üàöÔ∏è üë©üèø‚Äç‚öñÔ∏è Intera√ß√£o cliente-servidor em um novo dispositivo m√≥vel de atirador PvP e servidor de jogos: problemas e solu√ß√µes üç≥ üñ±Ô∏è üåû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em artigos anteriores da s√©rie (todos os links no final do artigo) sobre o desenvolvimento de um novo jogo de tiro em ritmo acelerado, examinamos os m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intera√ß√£o cliente-servidor em um novo dispositivo m√≥vel de atirador PvP e servidor de jogos: problemas e solu√ß√µes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/420019/">  Em artigos anteriores da s√©rie (todos os links no final do artigo) sobre o desenvolvimento de um novo jogo de tiro em ritmo acelerado, examinamos os mecanismos da arquitetura b√°sica da l√≥gica de jogos baseada no ECS e os recursos de trabalhar com um jogo de tiro no cliente, em particular, a implementa√ß√£o de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sistema para prever a√ß√µes de jogadores locais</a> para aumentar a capacidade de resposta ao jogo .  Desta vez, abordaremos com mais detalhes quest√µes de intera√ß√£o cliente-servidor em condi√ß√µes de baixa conex√£o de redes m√≥veis e maneiras de melhorar a qualidade do jogo para o usu√°rio final.  Tamb√©m descreverei brevemente a arquitetura do servidor do jogo. <br><br><img src="https://habrastorage.org/webt/py/lp/8q/pylp8q_ki2el3odmsmd_h5ppqh0.jpeg"><br><a name="habracut"></a><br><br>  Durante o desenvolvimento do novo PvP s√≠ncrono para dispositivos m√≥veis, encontramos problemas t√≠picos do g√™nero: <br><br><ol><li>  A qualidade da conex√£o dos clientes m√≥veis √© ruim.  Este √© um ping m√©dio relativamente alto na regi√£o de 200-250 ms e uma distribui√ß√£o de tempo inst√°vel do ping, levando em considera√ß√£o a altera√ß√£o dos pontos de acesso (embora, contrariamente √† cren√ßa popular, a porcentagem de perda de pacotes nas redes m√≥veis 3G + seja bastante baixa - cerca de 1%). </li><li>  As solu√ß√µes t√©cnicas existentes s√£o estruturas monstruosas que levam os desenvolvedores a estruturas r√≠gidas. </li></ol><br>  Criamos o primeiro prot√≥tipo na UNet, apesar de ter imposto restri√ß√µes √† escalabilidade, controle sobre o componente de rede e depend√™ncia adicional √† conex√£o caprichosa de clientes principais.  Depois, mudamos para um c√≥digo de rede auto-escrito em cima do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Photon Server</a> , mas mais sobre isso mais tarde. <br><br>  Considere os mecanismos para organizar intera√ß√µes entre clientes em jogos PvP s√≠ncronos.  O mais popular deles: <br><br><ul><li>  <b>P2P ou ponto a ponto</b> .  Toda a l√≥gica da partida est√° hospedada em um dos clientes e n√£o exige quase nenhum custo de tr√°fego da nossa parte.  Mas o escopo dos trapaceiros e os altos requisitos para o cliente que hospeda a partida, bem como as limita√ß√µes do NAT, n√£o nos permitiram levar essa solu√ß√£o para um jogo para celular. </li><li>  <b>Cliente-servidor</b> .  Um servidor dedicado, pelo contr√°rio, permite controlar totalmente tudo o que acontece na partida (adeus, trapaceiros), e seu desempenho permite calcular algumas coisas espec√≠ficas do nosso projeto.  Al√©m disso, muitos grandes provedores de hospedagem t√™m sua pr√≥pria estrutura de sub-rede, o que fornece um atraso m√≠nimo para o usu√°rio final. </li></ul><br>  Decidiu-se escrever um servidor autorit√°rio. <br><br><img src="https://habrastorage.org/webt/x4/a4/ku/x4a4kunfi3lnbjqeghpddh-hsz8.jpeg"><br>  <i>Rede com ponto a ponto (esquerda) e cliente-servidor (direita)</i> <br><br><h3>  Transfer√™ncia de dados entre cliente e servidor </h3><br>  Utilizamos o <b>Photon Server</b> - isso nos permitiu implantar rapidamente a infraestrutura necess√°ria para o projeto com base em um esquema j√° elaborado ao longo dos anos (nos War Robots, usamos). <br><br>  O Photon Server √© exclusivamente uma solu√ß√£o de transporte para n√≥s, sem designs de alto n√≠vel fortemente vinculados a um mecanismo de jogo espec√≠fico.  O que oferece alguma vantagem, pois a biblioteca de transfer√™ncia de dados pode ser substitu√≠da a qualquer momento. <br><br>  O servidor do jogo √© um aplicativo multiencadeado no cont√™iner Photon.  Um fluxo separado √© criado para cada correspond√™ncia, que encapsula toda a l√≥gica do trabalho e evita a influ√™ncia de uma correspond√™ncia em outra.  Todas as conex√µes do servidor s√£o controladas pelo Photon e os dados que chegam dos clientes s√£o adicionados √† fila, que √© ent√£o analisada no ECS. <br><br><img src="https://habrastorage.org/webt/j-/ws/wm/j-wswmt08qutnwc1jha0dgazkfo.jpeg"><br>  <i>Esquema geral de fluxos de correspond√™ncia no cont√™iner do Photon Server</i> <br><br>  Cada partida consiste em v√°rias etapas: <br><br><ol><li>  O cliente do jogo enfileira no chamado servi√ßo de cria√ß√£o de partidas.  Assim que o n√∫mero necess√°rio de jogadores que satisfazem determinadas condi√ß√µes for reunido, ele relata isso ao servidor do jogo usando o gRPC.  Ao mesmo tempo, todos os dados necess√°rios para criar o jogo s√£o transmitidos. <br><br><img src="https://habrastorage.org/webt/e_/rq/qp/e_rqqp5kiwrz-mxwbtkeuqptfpy.jpeg"><br>  <i>Esquema geral para criar uma correspond√™ncia</i> </li><li>  No servidor do jogo, a inicializa√ß√£o da partida come√ßa.  Todos os par√¢metros de correspond√™ncia s√£o processados ‚Äã‚Äãe preparados, incluindo dados do mapa, bem como todos os dados do cliente recebidos do servi√ßo de cria√ß√£o de correspond√™ncia.  O processamento e a prepara√ß√£o de dados implica que analisemos todos os dados necess√°rios e os gravamos em um subconjunto especial de entidades que chamamos de RuleBook.  Ele armazena estat√≠sticas da partida (que n√£o mudam durante o curso) e ser√° transmitido a todos os clientes durante o processo de conex√£o e autoriza√ß√£o no servidor do jogo uma vez ou ao reconectar ap√≥s a perda da conex√£o.  Os dados de correspond√™ncia est√°tica incluem a configura√ß√£o do mapa (apresenta√ß√£o do mapa pelos componentes do ECS que os conectam ao mecanismo f√≠sico), dados do cliente (apelidos, um conjunto de armas que eles possuem e n√£o mudam durante a batalha etc.). </li><li>  Executando uma partida.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os sistemas ECS</a> que comp√µem o jogo no servidor come√ßam a funcionar.  Todos os sistemas est√£o marcando 30 quadros por segundo. </li><li>  Cada quadro l√™ e descompacta as entradas ou c√≥pias do jogador, se os jogadores n√£o enviarem suas entradas dentro de um determinado intervalo. </li><li>  Ent√£o, no mesmo quadro, a entrada √© processada no sistema ECS, a saber: mudan√ßa de estado do jogador;  o mundo que ele influencia com sua contribui√ß√£o;  e o status de outros jogadores. </li><li>  No final do quadro, o estado mundial resultante √© empacotado para o reprodutor e enviado pela rede. </li><li>  No final da partida, os resultados s√£o enviados aos clientes e ao microsservi√ßo, que processa as recompensas para a batalha usando o gRPC, al√©m do analista da partida. </li><li>  Depois disso, o fluxo de correspond√™ncia se fecha e o fluxo √© fechado. </li></ol><br><img src="https://habrastorage.org/webt/02/8i/jl/028ijlnhor-evm6llkmfbiguf3s.jpeg"><br>  <i>A sequ√™ncia de a√ß√µes no servidor em um quadro</i> <br><br>  No lado do cliente, o processo de conex√£o com uma correspond√™ncia √© o seguinte: <br><br><ol><li>  Primeiro, √© feita uma solicita√ß√£o para enfileiramento no servi√ßo para criar correspond√™ncias atrav√©s do websocket com serializa√ß√£o atrav√©s do protobuf. </li><li>  Ao criar uma partida, este servi√ßo informa o cliente do endere√ßo do servidor do jogo e transfere a carga √∫til adicional exigida pelo cliente antes da partida.  Agora o cliente est√° pronto para iniciar o processo de autoriza√ß√£o no servidor do jogo. </li><li>  O cliente cria um soquete UDP e come√ßa a enviar uma solicita√ß√£o ao servidor do jogo para conectar-se √† partida junto com algumas credenciais.  O servidor j√° est√° aguardando este cliente.  Quando conectado, ele fornece todos os dados necess√°rios para iniciar o jogo e exibir o mundo pela primeira vez.  Eles incluem: RuleBook (uma lista de dados est√°ticos para a partida), bem como StringIntMap, aos quais nos referimos como dados sobre as linhas usadas na jogabilidade que ser√£o identificadas por n√∫meros inteiros durante a partida).  Isso √© necess√°rio para economizar tr√°fego, porque  passando linhas a cada quadro cria uma carga significativa na rede.  Por exemplo, todos os nomes de jogadores, nomes de classes, identificadores de armas, contas e similares, todas as informa√ß√µes s√£o gravadas no StringIntMap, onde s√£o codificadas usando dados inteiros simples. </li></ol><br>  Quando um jogador afeta diretamente outros usu√°rios (causa dano, imp√µe efeitos etc.), um hist√≥rico de estado √© pesquisado no servidor para comparar o mundo do jogo que o cliente realmente v√™ em uma simula√ß√£o espec√≠fica com o que estava acontecendo no servidor com outros naquele momento entidades do jogo. <br><br>  Por exemplo, voc√™ atira no seu cliente.  Para voc√™, isso acontece instantaneamente, mas o cliente j√° "foge" h√° algum tempo √† frente em compara√ß√£o com o mundo ao redor, que ele exibe.  Portanto, devido √† previs√£o local do comportamento do jogador, o servidor precisa entender onde e em que estado os advers√°rios estavam no momento do tiro (talvez eles j√° estivessem mortos ou, inversamente, invulner√°veis).  O servidor verifica todos os fatores e apresenta seu veredicto sobre os danos causados. <br><br><img src="https://habrastorage.org/webt/os/fb/hh/osfbhh4iwrw6gk2hvtpqp8co2sw.jpeg"><br>  <i>Pedido de cria√ß√£o de uma partida, conex√£o com um servidor de jogo e autoriza√ß√£o</i> <br><br><h3>  Serializa√ß√£o e desserializa√ß√£o, empacotamento e descompacta√ß√£o dos primeiros bytes da partida </h3><br>  Temos uma serializa√ß√£o de dados bin√°rios propriet√°rios e, para transfer√™ncia de dados, usamos UDP. <br><br>  O UDP √© a op√ß√£o mais √≥bvia para enviar rapidamente mensagens entre o cliente e o servidor, onde geralmente √© muito mais importante exibir os dados o mais r√°pido poss√≠vel do que exibi-los em princ√≠pio.  Pacotes perdidos fazem ajustes, mas os problemas s√£o resolvidos para cada caso individualmente, como  Como os dados v√™m constantemente do cliente para o servidor e vice-versa, √© poss√≠vel inserir o conceito de conex√£o entre o cliente e o servidor. <br><br>  Para criar um c√≥digo ideal e conveniente, com base na descri√ß√£o declarativa da estrutura do nosso ECS, usamos a gera√ß√£o de c√≥digo.  Ao criar componentes, regras de serializa√ß√£o e desserializa√ß√£o tamb√©m s√£o geradas para eles.  A serializa√ß√£o √© baseada em um empacotador bin√°rio personalizado que permite empacotar dados da maneira mais econ√¥mica.  O conjunto de bytes obtido durante sua opera√ß√£o n√£o √© o ideal, mas permite criar um fluxo a partir do qual voc√™ pode ler alguns dados de pacote sem a necessidade de sua desserializa√ß√£o completa. <br><br>  O limite de transfer√™ncia de dados de 1500 bytes (tamb√©m conhecido como MTU) √©, de fato, o tamanho m√°ximo de pacote que pode ser transferido pela Ethernet.  Essa propriedade pode ser configurada em cada salto da rede e geralmente mesmo abaixo de 1500 bytes.  O que acontece se eu enviar um pacote maior que 1500 bytes?  A fragmenta√ß√£o de pacotes come√ßa.  I.e.  cada pacote ser√° dividido √† for√ßa em v√°rios fragmentos, que ser√£o enviados separadamente de uma interface para outra.  Eles podem ser enviados por rotas completamente diferentes, e o tempo para receber esses pacotes pode aumentar significativamente antes que a camada de rede emita um pacote colado ao seu aplicativo. <br><br>  No caso do Photon, a biblioteca come√ßa a enviar esses pacotes √† for√ßa no modo UDP confi√°vel.  I.e.  O Photon aguardar√° cada fragmento do pacote e encaminhar√° os fragmentos ausentes se eles forem perdidos durante o encaminhamento.  Mas esse trabalho da parte da rede √© inaceit√°vel em jogos em que √© necess√°rio um atraso m√≠nimo na rede.  Portanto, √© recomend√°vel reduzir o tamanho dos pacotes encaminhados ao m√≠nimo e n√£o exceder os 1500 bytes recomendados (em nosso jogo, o tamanho de um estado completo do mundo n√£o excede 1000 bytes; o tamanho do pacote com compacta√ß√£o delta √© de 200 bytes). <br><br>  Cada pacote do servidor possui um cabe√ßalho curto que cont√©m v√°rios bytes que descrevem o tipo de pacote.  O cliente descompacta primeiro esse conjunto de bytes e determina com qual pacote estamos lidando.  Confiamos fortemente nessa propriedade de nosso mecanismo de desserializa√ß√£o durante a autoriza√ß√£o: para n√£o exceder o tamanho recomendado de pacote de 1500 bytes, dividimos os pacotes RuleBook e StringIntMap em v√°rios est√°gios;  e para entender exatamente o que obtivemos do servidor - as regras do jogo ou o pr√≥prio estado - usamos o cabe√ßalho do pacote. <br><br>  Ao desenvolver novos recursos do projeto, o tamanho do pacote est√° aumentando constantemente.  Quando encontramos esse problema, decidiu-se escrever nosso pr√≥prio sistema de compacta√ß√£o delta, bem como o recorte contextual de dados que o cliente n√£o precisava. <br><br><h3>  Otimiza√ß√£o do tr√°fego de rede sens√≠vel ao contexto.  Compress√£o delta </h3><br>  O recorte de dados contextuais √© gravado manualmente com base nos dados que o cliente precisa para exibir corretamente o mundo e na previs√£o local de seus pr√≥prios dados para funcionar corretamente.  Em seguida, a compacta√ß√£o delta √© aplicada aos dados restantes. <br><br>  Nosso jogo a cada tick produz um novo estado do mundo, que deve ser empacotado e repassado aos clientes.  Normalmente, a compacta√ß√£o delta √© primeiro enviar um estado completo com todos os dados necess√°rios para o cliente e, em seguida, enviar apenas altera√ß√µes para esses dados.  Isso pode ser representado da seguinte maneira: <br><br>  <i>deltaGameState = newGameState - prevGameState</i> <br><br>  Mas para cada cliente s√£o enviados dados diferentes e a perda de apenas um pacote pode levar ao fato de que voc√™ deve encaminhar o estado completo do mundo. <br><br>  Encaminhar o estado completo do mundo √© uma tarefa bastante cara para a rede.  Portanto, modificamos a abordagem e enviamos a diferen√ßa entre o estado atual processado do mundo e o que √© recebido exatamente pelo cliente.  Para fazer isso, o cliente em seu pacote com a entrada tamb√©m envia um n√∫mero de tick, que √© um identificador exclusivo do estado do jogo que ele j√° recebeu exatamente.  Agora, o servidor sabe com base em que estado √© necess√°rio criar compacta√ß√£o delta.  Normalmente, o cliente n√£o tem tempo para enviar ao servidor o n√∫mero de escala que possui antes de o servidor preparar o pr√≥ximo quadro com os dados.  Portanto, no cliente h√° um hist√≥rico de estados do servidor no mundo, ao qual o patch deltaGameState gerado pelo servidor √© aplicado. <br><br><img src="https://habrastorage.org/webt/ji/uo/ka/jiuokasgdo-wgmgmzbmchlb1gvm.jpeg"><br>  <i>Ilustra√ß√£o da frequ√™ncia da intera√ß√£o cliente-servidor no projeto</i> <br><br>  Vamos nos debru√ßar com mais detalhes sobre o que o cliente envia.  Nos atiradores cl√°ssicos, esse pacote √© chamado ClientCmd e cont√©m informa√ß√µes sobre as teclas pressionadas do jogador e a hora em que a equipe foi criada.  Dentro do pacote de entrada, enviamos muito mais dados: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputSample</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,        public uint WorldTick; // ,      ,     public uint PlayerSimulationTick; //   .  (idle, , ) public MovementMagnitude MovementMagnitude; //  ,   public float MovementAngle; //    public AimMagnitude AimMagnitude; //    public float AimAngle; //   ,       public uint ShotTarget; //    ,        public float AimMagnitudeCompressed; }</span></span></code> </pre> <br><br>  Existem alguns pontos interessantes.  Em primeiro lugar, o cliente informa ao servidor em que tick v√™ todos os objetos do mundo do jogo que o rodeiam que n√£o √© capaz de prever (WorldTick).  Pode parecer que o cliente √© capaz de "parar" o tempo para o mundo e executar e atirar em todos por causa da previs√£o local.  Isto n√£o √© verdade.  Confiamos apenas em um conjunto limitado de valores do cliente e n√£o o deixamos entrar no passado por mais de um segundo.  O campo WorldTick tamb√©m √© usado como um pacote de reconhecimento, com base no qual a compacta√ß√£o delta √© criada. <br><br>  Voc√™ pode encontrar n√∫meros de ponto flutuante em um pacote.  Normalmente, esses valores costumam ser usados ‚Äã‚Äãpara fazer leituras do joystick do jogador, mas n√£o s√£o muito bem transmitidas pela rede, pois possuem um grande "salto" e geralmente s√£o muito precisas.  Quantificamos esses n√∫meros e empacotamos usando um empacotador bin√°rio para que eles n√£o excedam um valor inteiro que possa caber em v√°rios bits, dependendo do tamanho.  Assim, o empacotamento da entrada do joystick de mira √© quebrado: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(s.AimMagnitudeCompressed) &lt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.Epsilon) { packer.PackByte(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { packer.PackByte(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> min = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> step = <span class="hljs-number"><span class="hljs-number">0.001f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000    , //          //     packer.PackUInt32((uint)((s.AimMagnitudeCompressed - min)/step), CalcFloatRangeBits(min, max, step)); }</span></span></code> </pre> <br><br>  Outro recurso interessante ao enviar entrada √© que alguns comandos podem ser enviados v√°rias vezes.  Muitas vezes nos perguntam o que fazer se uma pessoa pressionou a habilidade final e o pacote com sua entrada foi perdido?  Apenas enviamos essa entrada v√°rias vezes.  Parece entrega garantida, mas mais flex√≠vel e mais r√°pida.  Porque  o tamanho do pacote de entrada √© muito pequeno, podemos empacotar v√°rias entradas adjacentes do player no pacote resultante.  No momento, o tamanho da janela que determina seu n√∫mero √© cinco. <br><br><img src="https://habrastorage.org/webt/gi/08/0g/gi080gxlym3kf7n801ah19gjeq8.jpeg"><br>  <i>Pacotes de entrada gerados no cliente em cada tick e enviados ao servidor</i> <br><br>  A transmiss√£o desse tipo de dados √© a mais r√°pida e confi√°vel o suficiente para resolver nossos problemas sem o uso de UDP confi√°vel.  Partimos do fato de que a probabilidade de perder um n√∫mero t√£o grande de pacotes seguidos √© muito baixa e √© um indicador de uma grave degrada√ß√£o da qualidade da rede como um todo.  Se isso acontecer, o servidor simplesmente copia a √∫ltima entrada recebida do player e a aplica, esperando que permane√ßa inalterada. <br><br>  Se o cliente perceber que ele n√£o recebeu pacotes pela rede por um per√≠odo muito longo, o processo de reconex√£o com o servidor √© iniciado.  O servidor, por sua vez, monitora se a fila de entrada do player est√° conclu√≠da. <br><br><h3>  Em vez de conclus√£o e refer√™ncia </h3><br>  Existem muitos outros sistemas no servidor de jogos que s√£o respons√°veis ‚Äã‚Äãpor detectar, depurar e editar os "ganhos" correspondentes, os designers de jogos atualizando a configura√ß√£o sem reiniciar, registrar e monitorar o status dos servidores.  Tamb√©m queremos escrever sobre isso com mais detalhes, mas separadamente. <br><br>  Antes de tudo, ao desenvolver um jogo em rede em plataformas m√≥veis, voc√™ deve prestar aten√ß√£o √† opera√ß√£o correta do seu cliente com pings altos (cerca de 200 ms), perda de dados um pouco mais frequente e tamanho das informa√ß√µes enviadas.  E voc√™ precisa se encaixar claramente no limite de pacotes de 1500 bytes para evitar atrasos na fragmenta√ß√£o e no tr√°fego. <br><br>  Links √∫teis: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://gafferongames.com/post/udp_vs_tcp/</a> √© um √≥timo artigo sobre como escolher entre TCP e UDP para jogos em rede. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://api.unrealengine.com/udk/Three/NetworkingOverview.html</a> - uma descri√ß√£o do modelo de servidor no Unreal Engine. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://ieeexplore.ieee.org/document/5360721</a> - estudo da qualidade da rede de conex√µes m√≥veis. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://ithare.com/mmog-rtt-input-lag-and-how-to-mitigate-them/</a> - intera√ß√£o de rede em jogos de ritmo acelerado. </li></ul><br>  Artigos anteriores sobre o projeto: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Como entramos em um jogo de tiro r√°pido e m√≥vel: tecnologia e abordagens</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Como e por que escrevemos nossa ECS"</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Como escrevemos o c√≥digo de rede do shooter PvP m√≥vel: sincroniza√ß√£o do jogador no cliente</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420019/">https://habr.com/ru/post/pt420019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420009/index.html">As sutilezas do design do produto</a></li>
<li><a href="../pt420011/index.html">Como escolher uma impressora 3D: Guia para iniciantes</a></li>
<li><a href="../pt420013/index.html">Pesquisa de endere√ßo MAC em comutadores Juniper</a></li>
<li><a href="../pt420015/index.html">Como medir corretamente a velocidade do canal da Internet e parar de parecer um tolo aos olhos do seu provedor</a></li>
<li><a href="../pt420017/index.html">A arte de escolher senhas</a></li>
<li><a href="../pt420021/index.html">Por que voc√™ precisa do Splunk? Internet das Coisas e Dados Industriais</a></li>
<li><a href="../pt420023/index.html">Salvando estados em aplicativos Android</a></li>
<li><a href="../pt420025/index.html">Fazenda inteligente. Como ela ser√°?</a></li>
<li><a href="../pt420029/index.html">Como n√≥s da 1C: Enterprise resolvemos sistemas de equa√ß√µes alg√©bricas</a></li>
<li><a href="../pt420031/index.html">Desenho com destinos de renderiza√ß√£o no Unreal Engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>