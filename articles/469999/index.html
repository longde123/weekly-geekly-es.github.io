<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ§Ô∏è üò∞ üëéüèº C√≥mo negocian los servidores entre s√≠: algoritmo de consenso distribuido Raft ‚ôëÔ∏è üïØÔ∏è üà∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando los cl√∫steres alcanzan cientos, y a veces miles, de m√°quinas, surge la pregunta de la consistencia de los estados del servidor entre s√≠. El alg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo negocian los servidores entre s√≠: algoritmo de consenso distribuido Raft</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/469999/">  Cuando los cl√∫steres alcanzan cientos, y a veces miles, de m√°quinas, surge la pregunta de la consistencia de los estados del servidor entre s√≠.  El algoritmo de consenso distribuido en balsa proporciona la garant√≠a de consistencia m√°s estricta posible.  En este art√≠culo, consideraremos a Raft desde el punto de vista de un ingeniero e intentaremos responder las preguntas "¬øC√≥mo?"  y "¬øpor qu√©?"  El esta trabajando. <br><br><img src="https://habrastorage.org/webt/e7/yf/fs/e7yffsk5gyqcjqxclgt9oqvnyrs.png"><br><br><a name="habracut"></a><br><blockquote>  Autor del art√≠culo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dmitry Pavlushin</a> (desarrollador Dodo Pizza Engineering). </blockquote><br>  Raft es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un algoritmo de consenso distribuido</a> que se necesita para que varios participantes puedan decidir conjuntamente si un evento ocurri√≥ o no, y qu√© sigui√≥. <br><br>  Los datos servidos por el cl√∫ster Raft son un registro que consta de registros.  Cuando un usuario desea cambiar los datos almacenados en un cl√∫ster, intenta agregar un nuevo registro al registro con el comando: <br><br><img src="https://habrastorage.org/webt/vo/wu/sl/vowusleov4a4bpnob0koux_7vns.png"><br>  Estos comandos son ejecutados por m√°quinas de estado distribuidas.  Por simplicidad y claridad, en el marco de este art√≠culo, asumiremos que estos registros simplemente se dan cuando se leen a un cliente que, en base a los eventos que han tenido lugar, restaura el estado actual del sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(ver Fuente de eventos)</a> . <br><br>  Para garantizar el consenso en Raft, primero se selecciona un l√≠der, sobre el cual ser√° responsable de administrar el registro distribuido.  El l√≠der acepta solicitudes de clientes y las replica en otros servidores del cl√∫ster.  Si el l√≠der falla, se seleccionar√° un nuevo l√≠der en el cl√∫ster.  Esto es si por un rato en tres oraciones.  Los detalles seguir√°n. <br><br><h2>  Conceptos basicos </h2><br><ol><li> <b>Estados del servidor</b>  En el cl√∫ster Raft, cada servidor en un momento dado se encuentra en uno de tres estados: <br><ul><li>  L√≠der (l√≠der): procesa todas las solicitudes de los clientes, es la fuente de la verdad de todos los datos en el registro, admite el registro de seguidores. </li><li>  Follower (seguidor) es un servidor pasivo que solo "escucha" las nuevas entradas de registro del l√≠der y redirige todas las solicitudes entrantes de los clientes al l√≠der.  De hecho, es una r√©plica en espera del l√≠der. </li><li>  Candidato (candidato) es un estado especial del servidor, posible solo durante la selecci√≥n de un nuevo l√≠der. </li></ul><br>  Durante el funcionamiento normal en un cl√∫ster, solo un servidor es el l√≠der, el resto son sus seguidores. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre el asincronismo</b> <div class="spoiler_text">  Vale la pena se√±alar aqu√≠ que la condici√≥n es un concepto relativo.  Debido al hecho de que los servidores se comunican de forma as√≠ncrona, diferentes servidores pueden observar las transiciones de otros servidores de un estado a otro en diferentes momentos. <br></div></div></li><li>  <b>Balsa divide el tiempo en segmentos de longitud arbitraria, llamados plazos</b> .  Cada t√©rmino tiene un n√∫mero monot√≥nicamente creciente.  El t√©rmino comienza con la elecci√≥n de un l√≠der cuando uno o m√°s servidores se convierten en candidatos.  Si el candidato recibe la mayor√≠a de los votos, se convierte en l√≠der hasta el final de este per√≠odo.  Si los votos se dividen y ninguno de los candidatos puede obtener la mayor√≠a de los votos, se activa un tiempo de espera y este per√≠odo finaliza.  Despu√©s de eso, comienza un nuevo per√≠odo con nuevos candidatos y elecciones.  Esta situaci√≥n se llama voto dividido.  Un ejemplo se ilustra con el t√©rmino n√∫mero tres en el siguiente diagrama: <br><br><img src="https://habrastorage.org/webt/uw/uj/cr/uwujcro7y3jflbpmc1y2iek_wlg.png"><br>  El t√©rmino n√∫mero sirve como una marca de tiempo l√≥gica en el cl√∫ster Raft.  Ayuda a los servidores a determinar qu√© informaci√≥n es m√°s relevante en este momento. <br><br><div class="spoiler">  <b class="spoiler_title">Reglas y t√©rminos de interacci√≥n del servidor</b> <div class="spoiler_text"><ul><li>  Cada servidor rastrea el n√∫mero de su t√©rmino actual. </li><li>  El servidor incluye su n√∫mero de vencimiento en cada mensaje enviado. </li><li>  Si el servidor recibe un mensaje con un n√∫mero de t√©rmino menor que el suyo, ignora este mensaje. </li><li>  Si el servidor recibe un mensaje con un n√∫mero de fecha l√≠mite m√°s largo que el suyo, entonces actualiza su n√∫mero de fecha l√≠mite para que coincida con el recibido. </li><li>  Si un candidato o l√≠der recibe un mensaje con un n√∫mero de fecha l√≠mite m√°s largo que el suyo, entonces comprende que otros servidores ya han iniciado una nueva fecha l√≠mite, y su fecha l√≠mite ya no es relevante.  Por lo tanto, pasa del estado actual al estado "seguidor" adem√°s de actualizar su n√∫mero. </li></ul></div></div><br></li><li>  <b>Comunicaci√≥n del servidor.</b>  Los servidores en Raft interact√∫an intercambiando solicitudes y respuestas.  El algoritmo b√°sico usa solo dos tipos de llamadas: <br><br><ul><li>  <b>RequestVote es</b> utilizado por los candidatos durante las elecciones.  La solicitud contiene el n√∫mero de t√©rmino y los metadatos del candidato sobre el registro del candidato, que se analizan con m√°s detalle a continuaci√≥n.  La respuesta contiene el n√∫mero de fecha l√≠mite del servidor que responde y el valor "verdadero" si el servidor vota por el candidato;  Falso si el servidor vota en contra del candidato. </li><li>  <b>AppendEntries es</b> utilizado por el l√≠der para la replicaci√≥n de registros, as√≠ como para el mecanismo de latido.  La solicitud contiene el n√∫mero de t√©rmino del l√≠der, una colecci√≥n de entradas que deben agregarse al registro (o una colecci√≥n vac√≠a en el caso de latidos), algunos metadatos sobre el registro del l√≠der, que tambi√©n se analizan con m√°s detalle a continuaci√≥n.  La respuesta contiene el n√∫mero de t√©rmino del seguidor y el valor "verdadero" si el seguidor agreg√≥ entradas exitosamente a su registro;  "Falso" si falla la adici√≥n de entradas de registro. </li></ul></li></ol><br><h2>  Algoritmo de trabajo </h2><br><h4>  1. Elige un l√≠der </h4><br>  Para determinar cu√°ndo es el momento de comenzar una nueva elecci√≥n, Raft se basa en los latidos del coraz√≥n.  El seguidor sigue siendo el seguidor hasta que recibe mensajes del l√≠der o candidato actual.  El l√≠der env√≠a peri√≥dicamente latidos a todos los dem√°s servidores. <br><br>  Si el seguidor no recibe ning√∫n mensaje por alg√∫n tiempo, naturalmente asumir√° que el l√≠der est√° muerto, lo que significa que es hora de tomar la iniciativa en sus manos.  En este punto, el antiguo seguidor inicia la elecci√≥n. <br><br>  Para iniciar la elecci√≥n, el seguidor incrementa su n√∫mero de mandato, cambia al estado "candidato", vota por s√≠ mismo y luego env√≠a la solicitud "RequestVote" a todos los dem√°s servidores.  Despu√©s de eso, el candidato espera uno de los tres eventos: <br><br><ol><li>  <b>El candidato recibe la mayor√≠a de los votos (incluido el suyo) y gana las elecciones.</b>  Cada servidor vota solo una vez en cada per√≠odo, para que se llegue al primer candidato (con algunas excepciones, discutidas a continuaci√≥n), por lo tanto, solo un candidato puede obtener la mayor√≠a de los votos en un t√©rmino espec√≠fico.  El servidor ganador se convierte en el l√≠der, comienza a enviar latidos y atender las solicitudes del cliente al cl√∫ster. </li><li>  <b>El candidato recibe un mensaje del l√≠der actual del t√©rmino actual o de cualquier servidor con un t√©rmino anterior</b> .  En este caso, el candidato entiende que las elecciones en las que se dirige ya no son relevantes.  No tiene m√°s remedio que reconocer un nuevo l√≠der / nuevo t√©rmino y entrar en un estado de seguidor. </li><li>  <b>Un candidato no recibe la mayor√≠a de los votos por un tiempo de espera determinado.</b>  Esto puede suceder cuando varios seguidores se convierten en candidatos, y los votos se dividen entre ellos para que ninguno obtenga la mayor√≠a.  En este caso, el per√≠odo termina sin un l√≠der, y el candidato comienza inmediatamente nuevas elecciones para el pr√≥ximo per√≠odo. </li></ol><br><h4>  2. Repetimos registros </h4><br>  Cuando se selecciona un l√≠der, √©l es responsable de administrar el registro distribuido.  El l√≠der acepta solicitudes de clientes que contienen algunos equipos.  El l√≠der coloca en su registro un nuevo registro que contiene el comando y luego env√≠a "AppendEntries" a todos los seguidores para replicar el registro con el nuevo registro. <br><br>  Cuando el registro se replica con √©xito en la mayor√≠a de los servidores, el l√≠der comienza a considerar el registro cerrado y responde al cliente.  El l√≠der realiza un seguimiento de qu√© registro es el √∫ltimo.  Env√≠a el n√∫mero de este registro a AppendEntries (incluidos los latidos) para que los seguidores puedan confirmar el registro para ellos mismos. <br><br>  En caso de que el l√≠der no pueda alcanzar a algunos seguidores, volver√° sobre las entradas de Append al infinito.  La siguiente imagen muestra c√≥mo se organizan los registros en el cl√∫ster Raft: <br><br><img src="https://habrastorage.org/webt/s3/2l/-z/s32l-zuwjn3u0eoz83j8pysn_uc.png"><br><br>  Cada cuadro es una entrada en el registro.  Cada registro almacena un comando, por ejemplo, x ‚Üê 3 asigna el valor 3 a la tecla x.  El registro tambi√©n almacena el n√∫mero del t√©rmino en el que se gener√≥.  En la imagen, esto se indica mediante un n√∫mero en la parte superior del cuadrado.  La visualizaci√≥n en color de los cuadrados tambi√©n significa el t√©rmino n√∫mero.  Cada registro tiene un n√∫mero de serie (√≠ndice de registro). <br><br><h4>  3. Garantizamos la fiabilidad del algoritmo. </h4><br>  Hasta ahora, de lo que hemos examinado, no est√° claro c√≥mo Raft puede dar al menos algunas garant√≠as.  Sin embargo, el algoritmo proporciona un conjunto de propiedades que juntas garantizan la fiabilidad de su ejecuci√≥n: <br><br><ul><li>  <b>Seguridad electoral</b> : no se puede seleccionar m√°s de un l√≠der en un solo per√≠odo.  Esta propiedad se desprende del hecho de que cada servidor vota dentro de cada t√©rmino solo una vez, y para la formaci√≥n de un l√≠der, se requiere una mayor√≠a de votos </li><li>  <b>L√≠der Anexar-Solo</b> : el l√≠der nunca sobrescribe o borra, no mueve entradas en su registro, solo agrega nuevas entradas.  Esta propiedad se deduce directamente de la descripci√≥n del algoritmo: la √∫nica operaci√≥n que un l√≠der puede realizar con su registro es agregar entradas al final.  Y eso es todo. </li><li>  <b>Coincidencia de registros:</b> si los registros de dos servidores contienen una entrada con el mismo √≠ndice y n√∫mero de caducidad, ambos registros son id√©nticos e incluyen este registro. <br><br><div class="spoiler">  <b class="spoiler_title">Prueba usando inducci√≥n matem√°tica e im√°genes</b> <div class="spoiler_text">  La inducci√≥n matem√°tica es una forma de probar cuando el primer paso es probar una declaraci√≥n para un caso simple.  En el segundo paso, aceptamos la afirmaci√≥n verdadera para alg√∫n caso X. En base a esto, tratamos de probar la afirmaci√≥n para alg√∫n caso vecino X + 1.  Juntos, estos dos pasos ayudan a probar la declaraci√≥n para todos los casos. <br><br>  En nuestra situaci√≥n, un caso simple es registros vac√≠os.  No hay registros, por lo tanto, no hay nada que viole la propiedad. <br><br>  Ahora intentemos asumir que hay algunas entradas en los registros que corresponden a nuestra propiedad.  Raft tiene un mecanismo que evita que la propiedad se rompa cuando cambia un registro.  Este mecanismo se llama <b>comprobaci√≥n de consistencia</b> .  Veamos los ejemplos de inmediato. <br><br>  <b>Buen ejemplo</b>  Hay un l√≠der, por ejemplo, del cuarto t√©rmino, hay un seguidor.  Ambos tienen registros coincidentes de tres entradas. <br><br><img src="https://habrastorage.org/webt/ob/kl/qj/obklqjfsspdfwyxwmpodpyvc-ia.png"><br><br>  Una solicitud del cliente llega al l√≠der, √©l agrega una entrada a su registro. <br><br><img src="https://habrastorage.org/webt/e9/d0/_x/e9d0_xsxyddboyfr9yjjdfake8m.png"><br><br>  El l√≠der env√≠a AppendEntries al seguidor.  Pero, adem√°s del registro m√°s agregado, el l√≠der tambi√©n indica en la solicitud que el registro debe agregarse en el √≠ndice 4, y en el √≠ndice 3, frente a √©l, debe haber un registro del t√©rmino 2. <br><br><img src="https://habrastorage.org/webt/eo/7l/x0/eo7lx0m8xul1tmtzqfkk4cgjdic.png"><br><br>  La entrada de registro en el √≠ndice 3 en el registro de seguidor coincide con la especificada en la solicitud, por lo que el seguidor agrega la entrada a su registro y responde con √©xito al l√≠der.  El final <br><br><img src="https://habrastorage.org/webt/ef/e8/kg/efe8kg2uspvnflbnx6mnkx5-1ko.png"><br><br>  <b>Tambi√©n es un buen ejemplo, pero con un comienzo tr√°gico.</b>  Ahora el registro del seguidor es diferente del registro del l√≠der actual. <br><br><img src="https://habrastorage.org/webt/t8/5d/ae/t85daek6x0n9spztxu-jeu5qee8.png"><br><br>  Cuando el l√≠der recibe una solicitud para agregar una entrada al registro, enviar√° los mismos AppendEntries que en el ejemplo anterior. <br><br><img src="https://habrastorage.org/webt/ka/q5/gw/kaq5gw5c0ezpdflgrdinqmpbmmk.png"><br><br>  Sin embargo, esta vez, dado que el seguidor no coincide con el registro anterior, el seguidor falla. <br><br><img src="https://habrastorage.org/webt/41/wk/zf/41wkzfixq1dr2x8artbwph2s3jw.png"><br><br>  ¬øQu√© hace el l√≠der en este caso?  El l√≠der simplemente retrocede un poco e intenta alimentar al seguidor con el registro que √©l mismo considera estar en el √≠ndice 3. Tambi√©n incluye el registro anterior en la solicitud. <br><br><img src="https://habrastorage.org/webt/y_/gw/br/y_gwbrjzohvl83zh-e2hploan5m.png"><br><br>  Ahora el seguidor responde con √©xito y sobrescribe las entradas en su registro, comenzando desde el √≠ndice 3. <br><br><img src="https://habrastorage.org/webt/8l/oa/wp/8loawpe9iqskomaw0p7zbwek9f8.png"><br><br>  El registro del seguidor puede diferir del registro del l√≠der seg√∫n lo desee.  Puede que no haya suficientes entradas, puede haber entradas adicionales.  En cualquier caso, la verificaci√≥n de consistencia asegura que los registros de seguidores tarde o temprano coincidir√°n con el registro del l√≠der. <br></div></div><br></li><li>  <b>Integridad del l√≠der</b> : si la entrada del registro se confirma en un momento dado, los registros de los l√≠deres de todos los per√≠odos posteriores incluir√°n este registro.  Esta propiedad nos brinda garant√≠as de durabilidad. <br><br><div class="spoiler">  <b class="spoiler_title">Prueba y fotos</b> <div class="spoiler_text">  Considere la siguiente situaci√≥n: tres servidores en un cl√∫ster.  El servidor S1 es el l√≠der del primer t√©rmino actual.  Todos los servidores tienen tres entradas de registro. <br><br><img src="https://habrastorage.org/webt/g6/c9/zb/g6c9zbx5fsewp_4nn0komxcnikm.png"><br><br>  El l√≠der S1 recibe una solicitud del cliente y agrega un nuevo registro a su registro, env√≠a AppendEntries a otros servidores S2 y S3. <br><br><img src="https://habrastorage.org/webt/rz/ki/gf/rzkigfvgmygzxg4qbwy9tfgf914.png"><br><br>  El registro llega con √©xito a S2, pero la red entre S1 y S3 parpadea y se pierde la solicitud.  Como S1 sabe que el registro est√° presente en dos de los tres servidores, puede determinar que el registro est√° confirmado y responder con √©xito al cliente. <br><br>  S1 tambi√©n volver√° a intentar agregar una entrada a S3 hasta que tenga √©xito.  Pero, ¬øqu√© sucede si S1 falla y se apaga?  Adem√°s, ¬øqu√© suceder√° si S3 es el primero en cansarse de esperar y se convierte en candidato?  S2 votar√° a favor, S3 se convertir√° en el l√≠der del segundo mandato y, en la pr√≥xima solicitud para agregar un registro, ¬øS3 sobrescribir√° nuestro registro grabado? <br><br><img src="https://habrastorage.org/webt/_g/ij/l3/_gijl3pklfn6g5xme0ta7-svaus.png"><br><br>  De hecho, esta situaci√≥n no puede suceder en el grupo Raft.  El problema aqu√≠ es que S2 no votar√≠a por S3.  Por qu√©  Porque el registro del servidor S3 en el momento de la votaci√≥n es menos relevante que el registro del servidor S2.  Este mecanismo se llama <b>restricci√≥n de elecci√≥n</b> : el servidor votar√° por otro servidor solo si el registro del candidato no es menos relevante que el registro del votante. <br><br>  Raft compara la relevancia de los registros de dos maneras: <br><br><ul><li>  √öltimo n√∫mero de fecha de registro </li><li>  Longitud del registro </li></ul><br>  Los candidatos incluyen estos dos par√°metros en la solicitud RequestVote para que los seguidores puedan comparar la relevancia de su registro con el registro del candidato. <br><br>  "Lo m√°s importante" es el registro en el que el √∫ltimo registro es m√°s antiguo. <br><br><img src="https://habrastorage.org/webt/7o/2a/-v/7o2a-vpncoa6z4qwmn-xdgckh1m.png"><br><br>  Si los n√∫meros del t√©rmino de las √∫ltimas entradas coinciden, entonces el "principal" es el registro que es m√°s largo. <br><br><img src="https://habrastorage.org/webt/qf/kx/nk/qfkxnk-qv4py6t6lvw3i8wuphu4.png"><br><br>  Si ambos coinciden, los registros son igualmente relevantes y, como se desprende de la propiedad anterior, son absolutamente id√©nticos. <br><br><img src="https://habrastorage.org/webt/hp/ej/x8/hpejx8hkcwkm-fjs7qs98gzn8pc.png"><br><br>  Resulta que el registro del servidor en el que hay un registro seguro siempre ser√° m√°s relevante que el registro en el que no lo est√°.  Y un servidor que tiene un registro seguro no votar√° por un servidor que no lo tenga.  Y dado que hay un registro registrado en la mayor√≠a de los servidores, un candidato sin este registro no podr√° obtener la mayor√≠a de los votos y convertirse en un l√≠der para eliminar este registro de otros servidores. <br></div></div><br></li><li>  <b>State Machine Safety</b> : esta propiedad se describe en el original en t√©rminos de m√°quinas de estado distribuidas, en t√©rminos de nuestro art√≠culo, esta propiedad se puede describir de la siguiente manera: cuando un servidor confirma un registro con cierto √≠ndice, ning√∫n otro servidor confirma otro registro para este √≠ndice. <br><br>  Esta propiedad se sigue del pasado.  Si el seguidor confirma alg√∫n registro en el √≠ndice N, entonces su registro es id√©ntico al registro del l√≠der hasta e incluyendo N.  La propiedad de integridad de L√≠der garantiza que todos los l√≠deres posteriores tambi√©n contendr√°n este registro asegurado en el √≠ndice N, lo que significa que los seguidores que cometan un registro en el √≠ndice N en per√≠odos posteriores cometer√°n el mismo valor. <br></li></ul><br><h2>  Enlaces a materiales para estudios posteriores </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El algoritmo de consenso de balsa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">En busca de un algoritmo de consenso comprensible</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Consenso: Teor√≠a y pr√°ctica de puente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gato Schrodinger sin caja: el problema del consenso en sistemas distribuidos</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469999/">https://habr.com/ru/post/469999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469985/index.html">Acelerar un programa para un procesador sintetizado Redd sin optimizaci√≥n: reemplazar un reloj</a></li>
<li><a href="../469987/index.html">Las 20 principales compa√±√≠as de desarrollo del mercado de todo el mundo</a></li>
<li><a href="../469991/index.html">Procesamos pedidos de la tienda en l√≠nea usando RabbitMQ y TypeScript</a></li>
<li><a href="../469995/index.html">Analizador Python SAX vs analizador Python DOM. Parsim FIAS-casas</a></li>
<li><a href="../469997/index.html">¬øQu√© titulares tienen m√°s probabilidades de llamar la atenci√≥n o el an√°lisis de HabraHabr?</a></li>
<li><a href="../470001/index.html">Consejos y trucos de Linux: servidor, abierto</a></li>
<li><a href="../470003/index.html">F # 1: Hola Mundo</a></li>
<li><a href="../470005/index.html">Control remoto de la computadora a trav√©s del navegador</a></li>
<li><a href="../470009/index.html">Ordenar fotos por datos de EXIF ‚Äã‚Äã+ PHP</a></li>
<li><a href="../470011/index.html">Laboratorio interactivo de termodin√°mica como medio eficaz de entrenamiento en simulaci√≥n.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>