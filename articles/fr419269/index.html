<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌮 🏴 🏴󠁧󠁢󠁥󠁮󠁧󠁿 Rébus dans le code et comment les décrypter. Le pouvoir secret des identifiants 🍝 ⛑️ 🔶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le code pur se lit comme une prose bien écrite. 
 Grady Butch dans Clean Code 
 Rebus comme code 


 Qu'est-ce qu'un rébus? Ceci est un message crypté...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rébus dans le code et comment les décrypter. Le pouvoir secret des identifiants</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419269/"><blockquote>  Le code pur se lit comme une prose bien écrite. <br>  <i>Grady Butch dans Clean Code</i> <br></blockquote><h2>  Rebus comme code </h2><br><img src="https://habrastorage.org/webt/7x/kw/pl/7xkwplb_gdofblahdmwqiqvz4f0.jpeg"><br><br>  Qu'est-ce qu'un rébus?  Ceci est un message crypté.  L'auteur du rébus prend un texte humain ordinaire et le code à l'aide de dessins, de chiffres et de lettres.  Et nous examinons un tel cryptage et essayons de lire le texte source. <br><br>  Le rébus a deux formes.  D'une part, le rébus est le texte original non chiffré, et de l'autre, les dessins chiffrés.  Le texte est le «quoi» du rébus, sa signification, son message.  Les images sont «comment»: <i>comment</i> exactement le message est crypté, par <i>quels</i> moyens.  Devinant le rébus, nous traduisons «comment» en «quoi». <br><a name="habracut"></a><br>  Les dessins sont le langage du rébus, son arsenal de moyens expressifs.  Le rebusnik, pour ainsi dire, nous parle à l'aide de ces dessins, communique quelque chose.  Il n'est pas autorisé à utiliser des mots humains normaux. <br><br>  Voici comment les puzzles se lisent: <br><br><img src="https://habrastorage.org/webt/ot/yj/pe/otyjpegfyy8v5-7gk8vji8s9ddc.jpeg"><br><br><h2>  Le code est comme un rébus </h2><br>  Le code du programme a quelque chose en commun avec le rébus: il a aussi ses propres «quoi» et «comment».  Et il doit aussi parfois être décrypté. <br><br>  Le «quoi» d'un code est son but, sa signification, cet effet et le résultat final que nous attendons de lui.  <i>Que</i> fait-il exactement. <br><br>  «Comment» du code - de quelle manière concrète remplira-t-il son «quoi», avec quelles missions spécifiques, multiplications, comparaisons;  mise en œuvre de l'algorithme, instructions au processeur.  C'est un langage de code autorisé, son arsenal de moyens expressifs. <br><br>  Martin Fowler en parle ainsi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Function Length»</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">original</a> ): <br><blockquote>  Smalltalk a travaillé sur ces machines en noir et blanc.  Si vous aviez besoin de mettre en évidence du texte ou des graphiques, vous deviez inverser la vidéo.  La classe de Smalltalk, responsable du programme, contenait la méthode «surlignage», et dans son implémentation, il n'y avait qu'une seule ligne - un appel à la méthode «inverse».  Le nom de la méthode était plus long que l'implémentation, mais cela n'avait pas d'importance, car il y a une grande distance entre l'intention et l'implémentation de ce code. <br></blockquote>  Ici, le point fort est le «quoi».  Dans la terminologie de Martin - <i>intention</i> : "mettre en évidence un fragment de l'image."  Le nom exprime ce que fait cette fonction.  L'inverse est de savoir comment, la <i>mise en œuvre</i> .  <i>Comment</i> exactement la surbrillance est effectuée (en utilisant l'inversion d'image).  C’est la différence entre «quoi» et «comment». <br><br>  Malgré le fait que le nom de la méthode soit plus long que sa mise en œuvre, l'existence d'une telle méthode est logique pour une raison très simple.  Lorsque nous voyons un appel inverse dans le code, nous devons comprendre ou nous souvenir que l'inversion d'image est utilisée pour rendre cette image plus visible.  Lorsque nous voyons un point culminant, nous lisons simplement: "rendre ce fragment plus visible".  Dans le premier cas, nous passons un peu d'effort mental pour comprendre la mission assignée au code, dans le second - non.  Dans le premier cas, nous voyons un rébus devant nous, nécessitant un décryptage, dans le second - une histoire dans un langage compréhensible. <br><br>  Un programmeur, quand il écrit un programme, c'est comme un rébus.  Le programmeur crypte la description humaine de l'algorithme à l'aide des outils de langage de programmation disponibles (plus primitifs que le langage humain).  Crypte «quoi» avec «comment».  Et plus tard, lui ou son collègue lit le code, déchiffrant <s>ces rébus la</s> description initiale de l'algorithme.  <b>Si dans le processus de lecture du code, nous ne pouvons pas immédiatement comprendre quel résultat entraînera l'exécution de chaque fragment, c'est-à-dire quel est le but, la signification du code, alors ce code est un rébus, et il doit être réécrit dans un langage clair.</b> <br><br>  Le problème avec les énigmes du code est qu'elles nécessitent <i>toujours</i> un effort mental.  Même si nous n'effectuons pas l'ensemble des opérations de décryptage dans notre esprit, mais que nous nous souvenons stupidement de la signification de certains rébus, cela créera toujours une charge: premièrement, se souvenir de sa signification, et deuxièmement, au moment de l'enregistrement de la transformation rébus dans cette valeur. <br><br>  Déchiffrer le rébus en lisant le code est la transformation très mentale dont parle Tim Ottinger dans le livre Clean Code.  Certes, il en discute dans le contexte de l'attribution de noms intelligibles aux variables, mais le problème est affecté exactement de la même manière.  Mot à Tim: <br><blockquote>  En règle générale, les programmeurs sont très intelligents.  Et les gens intelligents aiment parfois montrer la puissance de l'intelligence, démontrant leur capacité à jongler mentalement.  En fin de compte, si vous vous souvenez que la variable r contient une URL avec un hôte distant et un schéma converti en minuscules, cela indique clairement votre esprit. <br>  L'une des différences entre un programmeur intelligent et un programmeur professionnel est qu'un professionnel le comprend: la clarté est primordiale.  Les professionnels utilisent leur pouvoir pour le bien et écrivent du code compréhensible pour les autres. </blockquote>  Même une petite charge de chaque rébus peut devenir un problème s'il existe de nombreux rébus.  Vous avez probablement rencontré du code dont la lecture est tout simplement épuisante.  <b>Savoir: les rébus dans le code sont à blâmer pour votre fatigue.</b>  Les rébus exacerbent la fatigue de même leur propre auteur directement dans le processus d'écriture de code.  Après tout, lors de l'écriture de code, le programmeur relit également en continu ce qui a été écrit.  Malgré le fait que l'auteur ne déchiffre pas ses propres puzzles, mais se souvient simplement, ils créent toujours une charge.  Le piège est que l' <b>auteur ne voit tout simplement pas les puzzles dans son propre code</b> !  Essayez d'imaginer combien d'effort mental vous pouvez économiser le soir, si vous commencez à vous débarrasser des puzzles dans votre code le matin! <br><br>  Ainsi, pour réduire la fatigue liée à l'écriture et à la lecture de code, vous devez éviter les énigmes.  Mais comment faire? <br><br><h2>  La langue du code.  Force de l'identifiant </h2><br>  Je suis d'accord avec la déclaration de Grady Butch selon laquelle un code propre se lit comme une bonne prose.  Il s'agit d'une condition nécessaire, mais non suffisante.  La plupart d'entre nous comprendront intuitivement ce qui est en jeu, mais je voudrais obtenir au moins une définition: qu'est-ce que c'est - une bonne prose. <br><br>  J'ai demandé à mes collègues écrivains: en quoi la bonne prose est-elle différente de la mauvaise prose?  Tout le monde a répondu différemment, mais a souligné d'une certaine manière l'importance du langage: il doit être riche, il doit créer des images claires dans l'esprit et l'âme du lecteur.  Lorsque le lecteur a facilement une image claire que l'auteur a voulu lui dessiner, nous avons affaire à une bonne prose. <br><br>  Le code indique au processeur ce qu'il doit faire.  Un bon code en même temps dit au programmeur - et, en plus, très honnêtement!  - que fait-il ici.  Autrement dit, il présente son algorithme aussi près que possible de la façon dont l'auteur lui-même l'aurait fait dans un langage naturel.  Notre code doit le faire très bien, sinon un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">maniaque débridé avec une tronçonneuse ou un fusil de chasse</a> pourrait venir chez nous.  Le code ne doit pas être un rébus. <br><br>  De quels outils dispose le code pour ne pas être un rébus? <br><br>  Une histoire au nom du code sera facilement comprise par une personne si le code lui-même parle en langage humain.  Cela ne peut être réalisé qu'à l'aide d'identifiants: noms de fonctions, classes, variables et constantes - car ce <b>n'est que dans les identifiants que nous pouvons utiliser les mots du langage humain dont nous avons besoin</b> . <br><br>  Bien sûr, les mots clés d'un langage de programmation sont aussi des mots humains, mais leur vocabulaire est trop misérable.  Quelque chose comme la langue d'Ellochka l'Ogre - vous ne pouvez pas y écrire une bonne prose. <br><br>  Par conséquent, il est essentiel que le code du programme contienne autant d'identifiants correctement choisis que possible.  Pour que leur totalité forme la prose très bien écrite. <br><br>  Voyez à quel point il est facile de lire des lignes de code lorsque les noms des variables et des méthodes sont bien choisis: <br><br><pre><code class="ruby hljs">pageData.hasAttribute(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>) dom_tree.to_html() emails_str.split(<span class="hljs-string"><span class="hljs-string">','</span></span>)</code> </pre> <br>  En regardant ces courtes phrases, il est facile de comprendre de quoi ils parlent.  Nous savons quel résultat nous obtenons, car les identifiants nous en parlent.  Imaginez maintenant qu'à la place de chaque appel se trouve sa mise en œuvre - quelle sera la vitesse de lecture d'un tel code "crypté"? <br><br>  Beaucoup des techniques de refactorisation les plus simples: constantes nommées, sélection d'une méthode, remplacement d'une variable par un appel de méthode, une variable explicative, fractionnement d'une variable temporaire, etc. sont toutes sur la <b>façon de faire parler le code en langage humain, en d'autres termes, comment éviter les énigmes</b> . <br><br><h2>  Méthode Rebus </h2><br>  Quand j'ai lu Pure Code, j'ai été périodiquement visitée par la pensée: "What the hell!". <br><br>  Du haut de ses 40 années d'expérience, Robert Martin nous donne des conseils sur la façon d'améliorer le code.  Par exemple: <br><blockquote>  Première règle: les fonctions doivent être compactes.  Deuxième règle: les fonctions doivent être encore plus compactes. </blockquote>  Et puis il admet qu'il ne peut pas étayer scientifiquement sa demande.  Honnêtement, non scientifique, il fait aussi mal.  L'exigence de compacité des fonctions commence déjà à ressembler à un dogme - c'est pourquoi le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">débat</a> sur la question de la durée d'une fonction n'a pas disparu depuis tant de décennies. <br><br>  Et Bob propose également d'écrire chaque fonction afin qu'elle n'effectue qu'une seule opération.  De plus, quelle est cette opération - n'est pas très claire non plus.  Nous devons appeler à l’aide le principe d’un niveau d’abstraction unique, qui brouille encore la situation.  Tout cela est trop brumeux. <br><br>  Martin Fowler est plus pragmatique. <br><br><blockquote>  Il me semble que l'argument de la séparation de l'intention et de la réalisation a plus de sens.  Si, en regardant un morceau de code, vous devez faire un effort pour comprendre <i>ce</i> qu'il fait, alors vous devez le mettre dans une fonction et lui donner un nom conformément à ce «quoi».  Ensuite, la prochaine fois, le but de la fonction sera immédiatement évident, et dans la plupart des cas, vous ne vous soucierez pas de la façon dont la fonction fait son travail. <br><br><div class="spoiler">  <b class="spoiler_title">L'original</b> <div class="spoiler_text">  L'argument qui me semble le plus logique, cependant, est la séparation entre l'intention et la mise en œuvre.  Si vous devez consacrer des efforts à regarder un fragment de code pour comprendre <i>ce</i> qu'il fait, vous devez l'extraire dans une fonction et nommer la fonction après ce «quoi».  De cette façon, lorsque vous la relisez, le but de la fonction vous saute aux yeux et, la plupart du temps, vous n'aurez pas à vous soucier de la façon dont la fonction remplit son objectif - qui est le corps de la fonction. <br></div></div></blockquote>  Déjà mieux.  Vous voyez maintenant ce que Martin voulait dire dans ce passage?  Il voulait dire: éliminons les énigmes.  Que le code lui-même nous dise quel sera le résultat et comment - qu'il soit caché quelque part plus loin, dans la définition de la fonction.  Laissez tous les puzzles être décryptés.  Pas de puzzles - pas d'effort. <br><br>  Vous ne devez en aucun cas appliquer aveuglément des méthodes de refactoring.  C'est tellement évident, mais comment comprendre quand une refactorisation est vraiment nécessaire, et quand non?  <b>La méthode rebus dit: si après refactoring, le rébus ne disparaît pas, alors le refactoring n'est pas nécessaire</b> . <br><br>  <b>Si vous ne pouvez pas trouver un nom pour une nouvelle fonction qui expliquera clairement ce qui s'y passe, c'est une cloche que vous faites quelque chose de mal ici.</b>  <b>Essayez de sélectionner un fragment de code légèrement différent dans la fonction - à laquelle vous pouvez trouver rapidement un nom court et compréhensible.</b> <br><br><h2>  Un exemple de décodage de puzzles en code (pas très réussi) </h2><br>  À ce titre, je citerai un fragment du livre «Clean Code» que j'ai aimé.  Avant de refactoring, nous voyons du code plein de puzzles.  Le refactoring a été effectué par l'auteur du livre conformément aux règles de bon code promues par lui, et - juste une coïncidence - le code refactoré ressemble exactement au code dans lequel les rébus sont décryptés. <br><br>  L'auteur de la refactorisation a entièrement appliqué des identificateurs lisibles par l'homme (noms de classe, méthodes et variables) pour indiquer ce que fait réellement le code.  Il est dommage que cela ne se soit pas produit partout avec succès, et à certains endroits, de nouvelles énigmes sont apparues à la place des puzzles précédents. <br><br>  Par exemple, la méthode include la plus couramment utilisée dans ce passage <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">include</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String pageName, String arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ WikiPage inheritedPage = findInheritedPage(pageName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inheritedPage != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { String pagePathName = getPathNameForPage(inheritedPage); buildIncludeDirective(pagePathName, arg); } }</code> </pre> <br>  Le nom ne reflète pas du tout ce qui se passe dans la mise en œuvre.  Qu'est-ce qui inclut et où? <br><br>  En regardant l'appel à cette méthode: <br><br><pre> <code class="java hljs">include(<span class="hljs-string"><span class="hljs-string">"TearDown"</span></span>, <span class="hljs-string"><span class="hljs-string">"-teardown"</span></span>);</code> </pre> <br>  il est impossible de dire quel résultat l'auteur du code allait obtenir ici. <br><br>  Suivant: que fait buildIncludeDirective?  À en juger par son nom, il devrait élaborer une sorte de directive sur l'inclusion, et alors quoi?  La ramener?  Mais non.  Il l'ajoute immédiatement au résultat global. <br><br>  Et voici un autre updatePageContent.  Qu'est-ce que updatePageContent nous dit sur le résultat que nous obtenons après avoir appelé la méthode?  Rien.  Certains contenus de page seront remplacés par personne ne sait quoi.  Pourquoi le refactoring appelé extraction de méthode a-t-il été effectué ici?  A-t-il aidé à se débarrasser du rébus?  Cela n'a pas aidé, mais a encore plus brouillé le code.  Nous avons ici le cas même où le corps de la méthode est préférable.  La construction <br><br><pre> <code class="java hljs">pageData.setContent(newPageContent.toString());</code> </pre> <br>  beaucoup plus clair que le updatePageContent () cryptique. <br><br>  À titre de divertissement, je suggère aux lecteurs de chercher quels sont les autres mauvais endroits dans le <a href="">code refactorisé</a> . <br><br>  Pour justifier Bob, je peux dire que ce code n'est plus dans la version actuelle de FitNesse.  Apparemment, à son tour, lui aussi a été refactorisé. <br><br><h2>  Conclusion </h2><br>  La longueur de la fonction est un critère trop vague pour déterminer la qualité de la fonction.  «Fonctions courtes» n'est pas égal à «bonnes fonctions».  La longueur de la fonction n'est pas un critère, oubliez tout. <br><br>  Un bon code devrait donner des réponses aux questions du programmeur - pourquoi est-il (le code) ici, que <s>diable fait-il</s> ici, <s>il</s> atteint le résultat.  Ces réponses ne peuvent être données qu'à l'aide d'identifiants. <br><br>  Comme exemple de ce type de réponses que le code ne devrait pas donner, je veux donner un extrait d'un livre amusant. <br><blockquote>  "Je suis Ronan, Victor of Evil", dit-il lentement.  - Et voici Tarl.  Nous vous en voulons <br>  poser des questions.  Si tu mens, tu meurs.  J'ai compris <br>  «Moi, mon oncle, pour toujours», souffla-t-il.  - S'il te plait.  Je vais tout dire. <br>  "C'est bien," continua Ronan.  - Nom? <br>  - Ronan, vainqueur du mal. <br>  - Oui, pas le mien, idiot! <br>  "Ah, oui, alors Tarle," répondit l'orque en s'excusant. <br>  - Et pas le mien!  Tarle marmonné.  - Votre nom, club!  Prénom! <br>  "Le nom est le nom que j'utilise pour me distinguer des autres", marmonna l'orc. <br>  - Eh bien, donnez ce nom ici!  Hurla Tarle. <br>  Orka se leva soudain. <br>  - Ah!  Pimple! <br>  "Alors Pimple, que fais-tu ici?" <br>  "Je l'ai mis dans mon pantalon", répondit la vérité. <br>  Ronan plissa le nez de dégoût. <br>  "Non, je demande ce que fait votre bande d'orques ici!" <br>  Les yeux de Pimple se tournèrent rapidement, regardant autour de la scène. <br>  "La plupart des gens sont sans tête ici", marmonna-t-il. <br>  Tarle toucha Ronan sur l'épaule. <br>  "Laisse-moi essayer," dit-il avec confiance et se tourna vers l'orc effrayé.  - Dis-moi, <br>  Pimple, continua-t-il, pourquoi es-tu ici? <br>  - Oh, mon oncle, et ne demande pas.  La philosophie existentielle pour moi n'est qu'une forêt sombre. <br>  «Écoute, toi dragon rot», grogna-t-il d'un air étouffé.  - Votre gang d'orques avait un spécial <br>  raison de venir ici.  Qu'est-ce que c'est, dans la forêt? <br>  - Il y a beaucoup d'arbres. <br>  Les yeux de Ronan se gonflèrent et Tarle se détourna.  Le bouton, sentant qu'il n'avait pas donné la réponse attendue, commença à marmonner davantage. <br>  - Et si vous voulez en savoir plus sur la raison, et non sur la forêt, c'est parce que cette personne dans le pub <br>  nous a payé pour venir ici et vous tuer. <br>  <i>James Bibby, Ronan le barbare</i> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419269/">https://habr.com/ru/post/fr419269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419257/index.html">L'Inde présente un nouveau projet de loi sur la protection des PD - un autre analogue au RGPD?</a></li>
<li><a href="../fr419259/index.html">Rust 1.28 Release</a></li>
<li><a href="../fr419261/index.html">Actions sur Google: écrire une application simple pour Google Assistant sur Dialogflow et les fonctions cloud pour Firebase</a></li>
<li><a href="../fr419265/index.html">Utiliser un réseau neuronal multicouche pour éviter les obstacles dans les jeux</a></li>
<li><a href="../fr419267/index.html">Visite de Coworking SOK</a></li>
<li><a href="../fr419271/index.html">Analogues en Python et JavaScript. Quatrième partie</a></li>
<li><a href="../fr419273/index.html">Écriture d'un module du noyau Linux: GPIO avec prise en charge IRQ</a></li>
<li><a href="../fr419277/index.html">Rubans thermiques avec indice de protection IP68. Convient pour la lumière dans un bain public</a></li>
<li><a href="../fr419279/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 264 (30 juillet - 5 août)</a></li>
<li><a href="../fr419281/index.html">rcm - gestionnaire de fichiers rc: réglage et utilisation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>