<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚧 👨🏼‍🎤 🕴🏻 ESP32 + Arduino Core + FreeRTOS + Blynk = Haus mit den Anfängen des Geistes 🛶 👨🏿‍🔧 👩🏿‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Projektziele 


 Irgendwie stellte sich heraus, dass ich mein Haus baute, ein Skelett. In meinem Luxus-Aul gibt es kein Gas und wird in naher Zukunft ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ESP32 + Arduino Core + FreeRTOS + Blynk = Haus mit den Anfängen des Geistes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479156/"><h2 id="celi-proekta">  Projektziele </h2><br><p> Irgendwie stellte sich heraus, dass ich mein Haus baute, ein Skelett.  In meinem Luxus-Aul gibt es kein Gas und wird in naher Zukunft nicht erwartet, deshalb habe ich mich für ein Skelett entschieden - alles andere, für mich wäre es sehr teuer, mit Strom zu heizen.  Nun, auch weil es eine der billigsten Technologien ist. <br>  Ok, ich habe Rohre um das Haus geworfen, Batterien aufgehängt, ein Boiler, es schien warm, aber etwas stimmte nicht. </p><br><p>  Nachdem ich mir selbst zugehört hatte, wurde mir klar, dass dies eine Kröte ist, die ich nicht mag, dass die Heizung funktioniert, wenn ich nicht zu Hause bin (12-16 Stunden am Tag).  Und es könnte sein, dass es nicht funktioniert. Schalten Sie es erst vor der Ankunft ein, da das Skelett eine leichte Trägheit aufweist und Sie die Temperatur schnell erhöhen können.  Die gleiche Situation, wenn irgendwo für eine lange Zeit zu Hause zu verlassen.  Nun, im Allgemeinen ist das Laufen, Drehen des Kesselgriffs bei Temperaturänderungen auf der Straße, irgendwie nicht koscher. </p><a name="habracut"></a><br><p>  Es wurde deutlich, dass der Kessel ohne Automatisierung nirgends der einfachste ist, aber Kontakte zum Anschluss eines externen Steuerrelais hat.  Natürlich könnte man sofort einen Kessel mit allen notwendigen Funktionen kaufen, aber für mich sind solche Kessel irgendwie unmenschlich.  Außerdem wollte ich in die Hocke gehen, etwas für die Seele pinkeln, ein bisschen C lernen, wenn auch in der Arduino-Version. </p><br><p>  Eigentlich über die Anforderungen: </p><br><ul><li>  Solltemperaturregelung </li><li>  Kühlmitteltemperaturregelung je nach Außentemperatur oder manuell </li><li>  Zeitzonen mit unterschiedlichen Einstellungen, kälter bei Tag, heißer bei Nacht </li><li>  Automatikmodus mit automatischem Tag-Nacht-Übergang </li><li>  manueller Modus, keine automatischen Übergänge, für das Wochenende </li><li>  Nichtautomatischer Modus, in dem Sie die Kühlmitteltemperatur manuell einstellen und den Kessel ein- und ausschalten können </li><li>  Heizungssteuerung vor Ort, über Schaltflächen und Bildschirm und über die Website / mobile Anwendung </li></ul><br><p>  Es war am Anfang und dann litt ich und fügte hinzu: </p><br><ul><li>  Straßenlaternensteuerung (LED-Strahler) </li><li>  Alarmsystem basierend auf Bewegungsmelder, Sirene und Straßenlaterne </li><li>  Messung des Energieverbrauchs des Kessels pro Tag / Monat / Jahr + für jeden Monat des Jahres </li><li>  Alarmmodus nur durch langsames Blinken einer Lampe </li><li>  Signalisierungsmodus durch schnelles Blinken einer Lampe und kurze Pieptöne einer Sirene </li><li>  Signalisierungsmodus durch schnelles Blinken einer Lampe und ständiges Heulen einer Sirene </li></ul><br><p>  Der Zweck dieses Artikels ist es, Erfahrungen auszutauschen und etwas auf Russisch zu beschreiben, das ich im Internet nicht finden konnte.  Ich denke, dieser Artikel wird für Anfänger von Arduino-Heimwerkern nützlich sein, die bereits ein wenig mit Programmierung vertraut sind  absolut grundlegende Dinge, die ich nicht beschrieben habe.  Ich habe versucht, den Code so klar wie möglich zu schreiben, ich hoffe, es ist mir gelungen. </p><br><h2 id="chto-bylo-v-nachale">  Was war am Anfang </h2><br><p>  Ursprünglich wurde das Projekt auf einem wilden Haufen Arduino Nano + ESP8266 implementiert, aber ESP ist kein Schutzschild, sondern ein separates Gerät.  Warum so?  Ja, weil ich das alles schon hatte, aber es gab überhaupt kein Geld von dem Wort, also wollte ich im Prinzip kein neues Eisen kaufen.  Warum ist ESP kein Schild?  Jetzt erinnere ich mich nicht einmal mehr. </p><br><p>  Arduino steuerte alle Prozesse, weil es über die erforderliche Menge an GPIO verfügte, und ESP schickte alle Daten an den Blynk-Server, weil es das Internet kannte und nicht über genügend GPIO verfügte.  Sie haben sich über UART verbunden und JSON mit Daten aneinander gesendet.  Das Schema ist ungewöhnlich, aber es hat ein Jahr lang fast ohne Beschwerden funktioniert.  <a href="https://github.com/abashind/HomeHeater">Jeder</a> Interessierte kann den <a href="https://github.com/abashind/HomeHeater">Codec sehen</a> . </p><br><p>  Ich werde sofort eine Reservierung vornehmen. Ich war zu diesem Zeitpunkt nicht sehr geschickt (und möchte es auch jetzt noch besser machen). Daher ist es besser, wenn schwangere Frauen und Kinder nicht zuschauen.  Darüber hinaus wurde alles in der Arduino IDE geschrieben, es wird bei Nacht nicht in Erinnerung bleiben, was in Bezug auf Refactoring stark eingeschränkt ist, alles ist dort sehr primitiv. </p><br><h2 id="zhelezo">  Eisen </h2><br><p>  Also, ein Jahr ist vergangen, erlaubt Finanzen ESP32 devkit v1 zu kaufen, die genug GPIO hat, kann auf das Internet zugreifen und im Allgemeinen einen Super-Controller.  Zusätzlich zu den Witzen mochte ich sie am Ende der Arbeit sehr. </p><br><p>  Eisen Liste: </p><br><ul><li>  ESP32 devkit v1 noname China </li><li>  3 Temperatursensoren DS18B20, Temperatur im Haus, außen und die Temperatur des Kühlmittels in den Rohren </li><li>  Block mit 4 Relais </li><li>  pir sensor HC-SR501 </li></ul><br><p>  Ich werde kein Schema zeichnen, ich denke, aus den Makros mit den Namen der Stifte wird alles klar. </p><br><h2 id="pochemu-freertos-i-arduino-core">  Warum FreeRTOS und Arduino Core? </h2><br><p>  Auf Arduino sind eine Reihe von Bibliotheken geschrieben, insbesondere derselbe Blynk, damit Sie nicht aus dem Arduino Core herauskommen. </p><br><p>  FreeRTOS, weil es Ihnen ermöglicht, die Arbeit eines kleinen Stück Eisens ähnlich der Arbeit eines vollwertigen industriellen Controllers zu organisieren.  Jede Aufgabe kann in eine eigene Aufgabe verschoben, gestoppt, gestartet, bei Bedarf erstellt, gelöscht werden - all dies ist viel flexibler als das Schreiben einer langen Scheiße Arduino-Code, wenn am Ende alles nacheinander in der Schleifenfunktion erledigt wird. </p><br><p>  Bei Verwendung von FreeRTOS wird jede Aufgabe zu einem genau festgelegten Zeitpunkt ausgeführt, wenn nur die Prozessorleistung ausreicht.  Im Gegenteil, in Arduino wird der gesamte Code in einer Funktion in einem Thread ausgeführt. Wenn sich etwas verlangsamt, werden die restlichen Tasks verzögert ausgeführt.  Dies macht sich insbesondere bei der Verwaltung schneller Prozesse bemerkbar. In diesem Projekt werden das Blinken einer Taschenlampe und ein Sirenenton weiter unten erläutert. </p><br><h2 id="pro-logiku">  Über Logik </h2><br><h3 id="pro-freertos-taski">  Informationen zu FreeRTOS-Aufgaben </h3><br><p>  → Link zum <a href="https://github.com/abashind/home_auto_2019">gesamten Codec des Projekts</a> </p><br><p>  Wenn Sie also FreeRTOS verwenden, spielt die Setup-Funktion die Rolle der Hauptfunktion, des Einstiegspunkts in die Anwendung. FreeRTOS-Tasks (im Folgenden Tasks) werden darin erstellt. Die Schleifenfunktion kann überhaupt nicht verwendet werden. </p><br><p>  Betrachten Sie eine kleine Aufgabe zur Berechnung der Temperatur des Kühlmittels: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_water_temp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvParameters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (heating_mode == <span class="hljs-number"><span class="hljs-number">3</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_outside &gt; <span class="hljs-number"><span class="hljs-number">-20</span></span>) max_water_temp = <span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_outside &lt;= <span class="hljs-number"><span class="hljs-number">-20</span></span> &amp;&amp; temp_outside &gt; <span class="hljs-number"><span class="hljs-number">-25</span></span>) max_water_temp = <span class="hljs-number"><span class="hljs-number">65</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_outside &lt;= <span class="hljs-number"><span class="hljs-number">-25</span></span> &amp;&amp; temp_outside &gt; <span class="hljs-number"><span class="hljs-number">-30</span></span>) max_water_temp = <span class="hljs-number"><span class="hljs-number">70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_outside &lt;= <span class="hljs-number"><span class="hljs-number">-30</span></span>) max_water_temp = <span class="hljs-number"><span class="hljs-number">85</span></span>; } vTaskDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span> / portTICK_RATE_MS); } }</code> </pre> <br><p>  Es wird als eine Funktion deklariert, die _void <code>pvParameters</code> annehmen <code>pvParameters</code> , eine Endlosschleife ist in der Funktion organisiert, die ich <code>while (true)</code> . </p><br><p>  Eine einfache Temperaturberechnung wird <code>vTaskDelay(1000 / portTICK_RATE_MS)</code> (sofern der Betriebsmodus dies zulässt) und anschließend die Aufgabe von <code>vTaskDelay(1000 / portTICK_RATE_MS)</code> für 1 Sekunde eingeschläfert.  In diesem Modus wird keine CPU-Zeit verbraucht. Die Variablen, mit denen die Aufgabe gearbeitet hat, dh der Kontext, werden auf dem Stapel gespeichert, um sie zum gewünschten Zeitpunkt wieder freizugeben. </p><br><p>  Die nächste Aufgabe muss im Setup erstellt werden.  Dies geschieht durch Aufrufen der <code>xTaskCreate</code> Methode: </p><br><p> <code>xTaskCreate(calculate_water_temp, "calculate_water_temp", 2048, NULL, 1, NULL);</code> </p> <br><p>  Es gibt viele Argumente, aber für uns ist <em>berechne_Wassertemperatur von</em> Bedeutung - der Name der Funktion, die den Aufgabencode enthält, und 2048 ist die Größe des Stapels in Bytes. </p><br><p>  Die Größe des Stapels hat anfangs alle auf 1024 Byte gesetzt. Dann habe ich die gewünschte Methode durch Eingabe berechnet. Wenn der Controller mit einem Stapelüberlauf zu fallen begann (wie aus der Ausgabe in uart ersichtlich ist), habe ich den Stapel nur um das 2-fache vergrößert, wenn es nicht geholfen hat, um das 2-fache und so weiter bis es funktioniert.  Das spart natürlich nicht zu viel Speicher, aber ESP32 hat genug davon, in meinem Fall könnten Sie sich nicht darum kümmern. </p><br><p>  Sie können auch ein Handle für die Aufgabe angeben - ein Handle, mit dem Sie die Aufgabe nach der Erstellung steuern können - Löschen.  Dies ist die letzte NULL im Beispiel.  Ein Handle wird wie folgt erstellt: </p><br><p> <code>TaskHandle_t slow_blink_handle;</code> </p> <br><p>  Als Nächstes wird beim Erstellen einer Aufgabe ein Zeiger auf das <code>xTaskCreate</code> an den Parameter xTaskCreate übergeben: </p><br><p> <code>xTaskCreate(outside_lamp_blinks, "outside_lamp_blynk", 10000, (void *)1000, 1, &amp;slow_blink_handle);</code> </p> <br><p>  Und wenn wir die Aufgabe entfernen wollen, machen wir das: </p><br><p> <code>vTaskDelete(slow_blink_handle);</code> </p> <br><p>  Wie dies verwendet wird, können Sie dem <code>panic_control</code> Code panic_control entnehmen. </p><br><h3 id="pro-freertos-myuteksy">  FreeRTOS Mutex Pros </h3><br><p>  Mutex wird verwendet, um Konflikte zwischen Aufgaben beim Zugriff auf Ressourcen wie uart, wifi usw. zu beseitigen.  In meinem Fall brauchte ich Mutexe für WLAN und den Zugriff auf Flash-Speicher. </p><br><p>  Erstellen Sie einen Link zum Mutex: </p><br><p> <code>SemaphoreHandle_t wifi_mutex;</code> </p> <br><p>  Erstellen Sie im <code>setup</code> einen Mutex: </p><br><p> <code>wifi_mutex = xSemaphoreCreateMutex();</code> </p> <br><p>  Wenn wir Zugriff auf die Task-Ressource benötigen, wird der Mutex benötigt, wodurch der Rest der Tasks weiß, dass die Ressource belegt ist und es nicht erforderlich ist, zu versuchen, damit zu arbeiten: </p><br><p> <code>xSemaphoreTake(wifi_mutex, portMAX_DELAY);</code> </p> <br><p>  <code>portMAX_DELAY</code> - Warten Sie auf unbestimmte Zeit, bis die Ressource und der Mutex von anderen Tasks freigegeben wurden. In dieser Zeit wird der Task in den Ruhezustand versetzt. </p><br><p>  Nachdem wir mit der Ressource gearbeitet haben, geben wir den Mutex, damit andere ihn verwenden können: </p><br><p> <code>xSemaphoreGive(wifi_mutex);</code> </p> <br><p>  Sie können den Code in der send_data_to_blynk- <code>send_data_to_blynk</code> anzeigen. </p><br><p>  In der Praxis war die Nichtverwendung von Mutexen während des Betriebs des Controllers nicht erkennbar, aber während des JTAG-Debugs verschwanden ständig Fehler, die nach der Verwendung der Mutexe verschwanden. </p><br><h3 id="kratkoe-opisanie-tasok">  Kurze Beschreibung der Tasok </h3><br><p>  <code>get_temps</code> - Empfangen der Temperatur von den Sensoren alle 30 Sekunden, häufiger ist dies nicht erforderlich. <br>  <code>get_time_task</code> - Zeit von NTP-Servern <code>get_time_task</code> .  Früher stammte die Zeit vom RTC-Modul DS3231, aber nach einem Jahr Arbeit fiel sie allmählich aus, sodass ich mich entschied, sie überhaupt loszuwerden.  Ich entschied, dass dies für mich keine besonderen Konsequenzen hat, hauptsächlich beeinflusst die Zeit das Umschalten der Heizzeitzone - Tag oder Nacht.  Verschwindet das Internet während des Betriebs des Controllers, friert die Zeit einfach ein, die Zeitzone bleibt einfach gleich.  Wenn sich der Regler ausschaltet und nach dem Einschalten kein Internet vorhanden ist, ist die Zeit immer 0:00:00 - Heizmodus nachts. <br>  <code>calculate_water_temp</code> - oben betrachtet. <br>  <code>detect_pir_move</code> - <code>detect_pir_move</code> ein Bewegungssignal vom HC-SR501-Sensor.  Der Sensor bildet eine logische Einheit <code>digitalRead</code> V, wenn eine Bewegung erkannt wird, die über <code>digitalRead</code> erkannt wird. Der Pin für die Erkennung dieses Sensors sollte <code>pinMode(pir_pin, INPUT_PULLDOWN);</code> auf GND - <code>pinMode(pir_pin, INPUT_PULLDOWN);</code> <br>  <code>heating_control</code> - <code>heating_control</code> umschalten. <br>  <code>out_lamp_control</code> - Steuerung einer Straßenlampe. <br>  <code>panic_control</code> - Sirene und Scheinwerfer steuern, wenn Bewegung erkannt wird.  Um den Effekt von Sirenen und Blinklichtern zu erzeugen, werden separate Tasks verwendet, <code>outside_lamp_blinks</code> und <code>siren_beeps</code> .  Bei Verwendung von FreeRTOS funktionieren das Blinken und die Signaltöne genau in den festgelegten Intervallen einwandfrei. Andere Aufgaben wirken sich nicht auf die Arbeit aus, da  Sie leben in getrennten Strömen.  FreeRTOS garantiert, dass der Code in der Task zum angegebenen Zeitpunkt ausgeführt wird.  Bei der Implementierung dieser Funktionen in der <code>loop</code> alles nicht so reibungslos funktioniert, weil  beeinflusst durch die Ausführung von anderem Code. <br>  <code>guard_control</code> - Steuerung der Guard-Modi. <br>  <code>send_data_to_blynk</code> - Daten an die Blynk-Anwendung senden. <br>  <code>run_blynk</code> - Task zum Starten von <code>Blynk.run()</code> wie im Handbuch zur Verwendung von Blynk angegeben.  Soweit ich weiß, ist dies erforderlich, um Daten von der Anwendung an die Steuerung zu übertragen.  Im Allgemeinen sollte sich <code>Blynk.run()</code> in einer <code>loop</code> , aber ich wollte im Grunde nichts dort <code>Blynk.run()</code> und habe es zu einer separaten Aufgabe gemacht. <br>  <code>write_setting_to_pref</code> - <code>write_setting_to_pref</code> Einstellungen und Betriebsmodi auf, um sie nach einem Neustart zu erfassen.  Über Pref wird unten beschrieben. <br>  <code>count_heated_hours</code> - Zählen der Betriebszeit des Kessels.  Ich habe es einfach gemacht, wenn der Kessel zum Zeitpunkt des Taskstarts (einmal alle 30 Sekunden) eingeschaltet wird, wird im Flash-Speicher der Wert für die gewünschte Taste um eins erhöht. <br>  <code>send_heated_hours_to_app</code> - In dieser Task werden die Werte extrahiert und mit 0,00833 (1/120 Stunden) multipliziert. Die empfangenen Betriebsstunden des Kessels werden an die Blynk-Anwendung gesendet. <br>  <code>feed_watchdog</code> - <code>feed_watchdog</code> Watchdog.  Ich musste Watchdog schreiben, weil  alle paar tage konnte der controller einfrieren.  Es ist nicht klar, womit es verbunden ist. Möglicherweise liegt eine Störung der Stromversorgung vor, aber die Verwendung von Watchdog löst dieses Problem.  Watchdog-Timer 10 Sekunden. Ist der Controller 10 Sekunden lang nicht verfügbar, ist dies in Ordnung. <br>  <code>heart_beat</code> - Aufgabe mit einem Puls.  Wenn ich den Controller übergebe, möchte ich wissen, dass er einwandfrei funktioniert.  Weil  Auf meinem Board gibt es keine eingebaute LED, ich musste die UART LED verwenden - installiere <code>Serial.begin(9600);</code>  und schreibe einen langen String in UART.  Es funktioniert ziemlich gut </p><br><h3 id="esp32-nvs-wear-leveling">  ESP32 NVS-Verschleißausgleich </h3><br><p>  <em>Die folgenden Beschreibungen sind ziemlich grob, buchstäblich auf den Fingern, nur um das Wesentliche des Problems zu vermitteln.</em>  <em><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html">Ausführlicher</a></em> </p><br><p>  Arduino verwendet einen EEPROM-Speicher, um Daten im nichtflüchtigen Speicher zu speichern.  Dies ist ein kleiner Speicher, in den jedes Byte separat geschrieben und gelöscht werden kann, während der Flash-Speicher nur nach Sektoren gelöscht wird. </p><br><p>  Es gibt kein EEPROM in ESP32, aber normalerweise gibt es einen 4-MB-Flash-Speicher, in dem Sie Partitionen für die Controller-Firmware oder zum Speichern von Benutzerdaten erstellen können.  Es gibt verschiedene Arten von Abschnitten für Benutzerdaten - NVS, FATFS, SPIFFS.  Die Auswahl sollte auf der Grundlage des Datentyps erfolgen, der für die Aufzeichnung vorgesehen ist. </p><br><p>  Weil  Alle Daten, die in diesem Projekt geschrieben werden, sind vom Typ Int. Ich habe NVS - Non-Volitile Storage gewählt.  Dieser Partitionstyp eignet sich gut zum Speichern kleiner, oft überschreibbarer Daten.  Um zu verstehen, warum, sollten Sie etwas tiefer in die Organisation von NVS einsteigen. </p><br><p>  Wie bei EEPROM und FLASH gibt es Einschränkungen beim Überschreiben von Daten, Bytes im EEPROM können 100.000- bis 1.000.000-mal überschrieben werden, und der FLASH-Sektor ist derselbe.  Wenn wir Daten einmal pro Sekunde schreiben, erhalten wir 60 Sekunden x 60 Minuten x 24 Stunden = 86.400 Mal pro Tag.  Das heißt, in diesem Modus dauert das Byte 11 Tage, was ein bisschen ist.  Danach ist das Byte nicht mehr zum Schreiben und Lesen verfügbar. </p><br><p>  Um dieses Problem zu beheben, schreiben die <code>update()</code> <code>put()</code> -Funktionen der Arduino EEPROM-Bibliothek nur Daten, wenn sie sich ändern.  Das heißt, Sie können jede Sekunde einige Einstellungen und Moduscodes schreiben, die sich nur sehr selten ändern. </p><br><p>  NVS verwendet eine andere Methode zur Kontrolle des Verschleißniveaus.  Wie oben erwähnt, können Daten im Flash-Sektor in Teilen geschrieben werden, aber nur der gesamte Sektor kann gelöscht werden.  Daher wird die Datenaufzeichnung in NVS in einer Art Journal durchgeführt, dieses Journal ist in Seiten unterteilt, die in einem Sektor des Flash-Speichers abgelegt sind.  Die Daten werden in Schlüssel-Wert-Paaren geschrieben.  In der Tat ist es sogar einfacher als mit EEPROM, weil  Das Arbeiten mit einem aussagekräftigen Namen ist einfacher als mit einer Adresse im Speicher.  <strong>Update:</strong> Die Schlüssellänge beträgt maximal 15 Zeichen! </p><br><p>  Wenn Sie zuerst den Wert <code>1</code> in den Schlüssel <code>somekey</code> und dann den Wert <code>2</code> in denselben Schlüssel schreiben, wird der erste Wert nicht gelöscht, sondern nur als gelöscht (gelöscht) markiert und ein neuer Eintrag zum Protokoll hinzugefügt: </p><br><p><img src="https://habrastorage.org/webt/pw/ri/of/pwriofnineuwy7bmctgzcngiqrk.jpeg"></p><br><p>  Wenn Sie versuchen, Daten mit <code>somekey</code> Schlüssel zu lesen <code>somekey</code> letzte Wert dieses Schlüssels zurückgegeben.  Weil  Da das Protokoll gemeinsam ist, werden die Werte verschiedener Schlüssel beim Schreiben nebeneinander gespeichert. </p><br><p>  Die Seite hat den Status Leer - leer, ohne Einträge, Aktiv - Daten werden gerade darauf geschrieben, Voll - ist voll, Sie können nicht darauf schreiben.  Sobald der Speicherplatz auf der Seite erschöpft ist, ist sie von <br>  Active wechselt zu Full und die nächste leere Seite wird Active. </p><br><p><img src="https://habrastorage.org/webt/6q/lz/ym/6qlzymofwdhy9ah2x-ekgpd23tq.jpeg"></p><br><p>  Soweit ich aus der Dokumentation auf der Espressif-Website und verschiedenen Foren weiß, beginnt die Seitenbereinigung mit dem Ende der freien Seiten.  Um genauer zu sein, wird demnach gelöscht, wenn nur noch 1 freie Seite übrig ist. </p><br><p>  Wenn die Seite gelöscht werden muss, werden die aktuellen Datensätze (nicht gelöscht) auf eine andere Seite verschoben und die Seite wird überschrieben. </p><br><p>  Daher ist der Schreib-Lösch-Vorgang für jede bestimmte Seite ziemlich selten, je mehr Seiten - desto seltener.  Auf dieser Grundlage habe ich die Größe der NVS-Partition auf 1 MB erhöht. Bei meiner Aufzeichnungsrate reicht dies für 170 Jahre, was im Allgemeinen ausreicht.  Informationen zum Ändern der Größe des NVS-Abschnitts finden Sie als Nächstes. </p><br><p>  Für eine bequeme Arbeit mit NVS verfügt ESP32 für Arduino Core über eine praktische Bibliothek mit Einstellungen. Wie Sie damit arbeiten, erfahren Sie <a href="">hier</a> . </p><br><h3 id="nemnogo-o-visualgdb">  Ein bisschen über VisualGDB </h3><br><p>  Sobald ich anfing, mit der Arduino IDE zu arbeiten, war ich sofort von der miserablen Funktionalität im Vergleich zu Visual Studio überrascht.  Sie sagen, dass VS auch kein Brunnen ist, obwohl es mir passt, aber etwas über 50 Zeilen in der Arduino IDE zu schreiben ist schmerzhaft schmerzhaft und schmerzhaft lang.  Daher stellte sich die Frage, ob eine IDE für die Entwicklung ausgewählt werden sollte.  Weil  Ich bin mit VS vertraut und habe mich für <a href="https://visualgdb.com/tutorials/arduino/esp32/">VisualGDB entschieden</a> . </p><br><p>  Nach der Arduino IDE ist die Entwicklung für den ESP32 einfach ein Hafen.  Was ist der Übergang zur Definition, die Suche nach Aufrufen im Projekt und die Möglichkeit, die Variable umzubenennen. </p><br><h3 id="izmenenie-tablicy-razdelov-esp32-pri-rabote-s-visualgdb">  Ändern der ESP32-Partitionstabelle mit VisualGDB </h3><br><p>  Wie oben erwähnt, kann die Tabelle mit der ESP32-Partition geändert werden, und wir werden prüfen, wie dies getan werden kann. <br>  Die Tabelle wird als CSV-Datei bearbeitet. Standardmäßig schreibt VisualGDB die folgende Tabelle: </p><br><pre> <code class="plaintext hljs">Name, Type, SubType, Offset, Size, Flags nvs, data, nvs, 0x9000, 0x5000, otadata, data, ota, 0xe000, 0x2000, app0, app, ota_0, 0x10000, 0x140000, app1, app, ota_1, 0x150000,0x140000, spiffs, data, spiffs, 0x290000,0x170000,</code> </pre> <br><p>  Hier sehen wir einen Abschnitt unter NVS, zwei Abschnitte für Anwendungen und einige weitere Abschnitte.  Von den Nuancen ist zu beachten, dass app0 (Ihre Anwendung) immer bei Offset 0x10000 ab der Nulladresse geschrieben werden sollte, da der Bootloader dies sonst nicht erkennt.  Offsets sollten auch so ausgewählt werden, dass sich die Abschnitte nicht "überlappen".  Die Partitionstabelle selbst wird mit dem Offset 0x8000 geschrieben.  Wie Sie sehen können, beträgt die Größe des NVS in diesem Fall 0x5000 - 20 KB, was nicht sehr viel ist. </p><br><p>  Ich habe die Partitionstabelle wie folgt geändert: </p><br><pre> <code class="plaintext hljs">Name, Type, SubType, Offset, Size, Flags app0, app, ota_0, 0x10000, 0x140000, nvs, data, nvs, , 1M, otadata, data, ota, , 0x2000, spiffs, data, spiffs, , 0x170000,</code> </pre><br><p>  Vergessen Sie nicht, vor Name ein Raster einzufügen. Wenn Sie diese Tabelle verwenden, muss diese Zeile als Kommentar betrachtet werden. </p><br><p>  Wie Sie sehen, wird die Größe des NVS auf 1 MB erhöht.  Wenn Sie keine Offsets angeben, beginnt der Abschnitt unmittelbar nach dem vorherigen, sodass es ausreicht, den Offset nur für app0 anzugeben.  CSV-Dateien können im Editor als txt bearbeitet werden und ändern dann die Berechtigung für die gespeicherte Datei in csv. </p><br><p>  Als nächstes muss die Partitionstabelle in eine Binärdatei konvertiert werden, weil  es wird in dieser Form in die Steuerung eingegeben.  Führen Sie dazu den Konverter aus: <br>  <code>c:\Users\userName\Documents\ArduinoData\packages\esp32\hardware\esp32\1.0.3\tools\gen_esp32part.exe part_table_name.csv part_table_name.bin</code> .  Der erste Parameter ist Ihre CSV, der zweite Parameter ist die Ausgabe-Binärdatei. </p><br><p>  Die resultierende Binärdatei sollte in <code>c:\Users\userName\Documents\ArduinoData\packages\esp32\hardware\esp32\1.0.3\tools\partitions\part_table_name.csv</code> werden. <code>c:\Users\userName\Documents\ArduinoData\packages\esp32\hardware\esp32\1.0.3\tools\partitions\part_table_name.csv</code> muss angegeben werden, dass er die Lösung erstellt hat Keine Standardpartitionstabelle.  Sie können dies tun, indem Sie den Namen Ihrer Tabelle in die Datei <code>c:\Users\userName\Documents\ArduinoData\packages\esp32\hardware\esp32\1.0.3\boards.txt</code> .  In meinem Fall ist dies <code>esp32doit-devkit-v1.build.partitions=part_table_name</code> <br>  Nach diesen Manipulationen nimmt VisualGDB beim Erstellen der Anwendung genau Ihre Partitionstabelle und legt sie ab <br>  <code>~project_folder_path\Output\board_name\Debug\project_name.ino.partitions.bin</code> , von wo aus es bereits in das Board geschrieben wird. </p><br><h3 id="jtag-otladchik-cjmc-ft232h">  JTAG-Debugger CJMC-FT232H </h3><br><p>  Soweit ich weiß, ist dies der billigste Debugger, der mit ESP32 funktioniert. Er kostet mich ungefähr 600 Rubel. Es gibt eine Menge davon bei Aliexpress. </p><br><p><img src="https://habrastorage.org/webt/gn/cu/gm/gncugmqpjnb1hbmj630nnegxjgq.jpeg"></p><br><p>  Wenn Sie den Debugger verbinden, installiert Windows ungeeignete Treiber, die mit dem Zadig-Programm geändert werden müssen. Dort ist alles einfach, ich werde es nicht beschreiben. </p><br><p>  Es stellt auf folgende Weise eine Verbindung zu ESP32 devkit-v1 her: <br>  FT232H - ESP32 <br>  AD0 - GPIO13 <br>  AD1 - GPIO12 <br>  AD2 - GPIO15 <br>  AD3 - GPIO14 <br>  Anschließend müssen Sie unter <code>Project -&gt; VisualGDB Project Properties</code> folgende Einstellungen vornehmen: </p><br><p><img src="https://habrastorage.org/webt/eg/oi/7b/egoi7bhrpkjaprfvyz-jd9puccw.jpeg"></p><br><p>  Klicken Sie dann auf Test.  Manchmal kommt es vor, dass die Verbindung beim ersten Mal nicht hergestellt wird, der Prozess scheint einzufrieren, dann müssen Sie den Test unterbrechen und wiederholen.  Wenn alles in Ordnung ist, dauert der Test der Verbindung ca. 5 Sekunden. </p><br><p>  Normalerweise habe ich das Projekt zusammengestellt und über USB auf den ESP32 hochgeladen (nicht über den Debugger). Danach habe ich mit <code>Debug -&gt; Attach to Running Embedded Firmware</code> mit dem Debuggen begonnen.  Im Code können Sie Haltepunkte setzen, die Werte der Variablen zum Zeitpunkt der Unterbrechung <code>Debug -&gt; Windows -&gt; Threads</code> und im Fenster <code>Debug -&gt; Windows -&gt; Threads</code> sehen, in welchem ​​FreeRTOS-Code der Code gestoppt wurde. Dies ist hilfreich, wenn beim Debuggen ein Fehler auftritt.  Diese Funktionen des Debuggers reichten aus, um komfortabel zu arbeiten. <br>  Als ich anfing, mit NVS zu arbeiten, wurde das Debuggen ständig durch unklare Fehler unterbrochen.  Soweit ich weiß, muss der Debugger im Standard-NVS-Bereich einen Speicherauszug erstellen, aber zu diesem Zeitpunkt wird der NVS bereits vom Controller verwendet.  Dies könnte natürlich umgangen werden, indem zwei NVS-Partitionen erstellt werden, eine mit dem Standardnamen für das Debuggen und die andere für die eigenen Anforderungen.  Aber da war nichts kompliziertes, im hinzugefügten Code hat es beim ersten Mal funktioniert, also habe ich es nicht überprüft. </p><br><h3 id="glyuki-esp32">  Störungen ESP32 </h3><br><p>  Wie jedes Gerät mit Aliexpress hatte mein ESP32-Board einen eigenen, nirgendwo beschriebenen Fehler.  Als sie ankam, speiste ich einige Peripheriegeräte, die an I2C arbeiteten, von der Platine, aber nach einiger Zeit wurde die Platine neu gestartet, wenn verbrauchende Geräte oder sogar nur ein Kondensator an das + 5-V-Bein angeschlossen waren.  Warum das so ist, ist völlig unverständlich. </p><br><p>  Jetzt versorge ich die Platine mit der chinesischen Ladung 0,7A, die Sensoren ds18b20 am Fuß der 3,3-V-Platine und das Relais und den Bewegungssensor mit einer weiteren Ladung von 2A.  Der GND-Fuß der Platine ist natürlich mit den GND-Stiften des restlichen Eisens verbunden.  Billig und fröhlich ist unsere Option. </p><br><h3 id="o-rezultatah-proekta">  Über die Projektergebnisse </h3><br><p>  Ich hatte die Möglichkeit, die Heizung im Haus flexibel zu regeln und so Geld und Schweiß zu sparen.  Wenn die Heizung den ganzen Tag über zwischen -5 und -7 Grad warm ist, beträgt die Betriebsdauer des Heizkessels derzeit etwa 11 Stunden.  Wenn tagsüber 20 Grad gehalten und erst abends 23 warm werden sollen, dann sind dies bereits 9 Betriebsstunden des Kessels.  Die Kesselleistung beträgt 6 kW, bei einem aktuellen Kilowattpreis von 2,2 Rubel sind dies ca. 26,4 Rubel pro Tag.  Die Dauer der Heizperiode in unserer Region beträgt 200 Tage, die Durchschnittstemperatur in der Heizperiode beträgt nur etwa -5 Grad.  Auf diese Weise sparen wir in der Heizperiode etwa 5000 r. </p><br><p>  Die Kosten für die Ausrüstung überschreiten nicht 2000 R, dh die Kosten werden in wenigen Monaten zurückgezahlt, ganz zu schweigen von der Tatsache, dass ein fertiges System für eine solche Automatisierung mindestens 20 000 R kosten würde.  Eine andere Sache ist, dass ich ungefähr eine Woche reine Arbeitszeit mit dem Schreiben von Firmware und dem Debuggen verbracht habe, aber im Laufe der Arbeit habe ich schließlich festgestellt, was Zeiger in C ++ sind, und eine Menge anderer Erfahrungen gesammelt (zum Beispiel die Erfahrung von vielen Stunden Debuggen von unverständlichen Störungen).  Und Erfahrung ist, wie Sie wissen, schwer zu überschätzen. </p><br><p>  Screenshots der mobilen Blynk-Anwendung: </p><br><p><img src="https://habrastorage.org/webt/f8/a-/57/f8a-57tioype-tcgmjmodpagpwa.jpeg"></p><br><p><img src="https://habrastorage.org/webt/ez/3a/o3/ez3ao3_ht2lgjsbf9jvv_xcoksc.jpeg"></p><br><p><img src="https://habrastorage.org/webt/xi/xv/f-/xixvf-6pvrnw-2trm_toszimwrm.jpeg"></p><br><p>  Natürlich ist der Code im Projekt kein Meisterwerk, aber ich habe ihn unter den Bedingungen eines Zeitmangels geschrieben und mich hauptsächlich auf die Lesbarkeit konzentriert.  Es ist einfach keine Zeit für eine Umgestaltung.  Im Allgemeinen habe ich viele Ausreden, warum mein Code so unheimlich ist, aber das ist mein Favorit, daher werde ich darauf näher eingehen und das Thema nicht weiterentwickeln. </p><br><p>  Wenn mein Scribble jemandem hilft, werde ich aufrichtig froh sein.  Über Kommentare und Anregungen würde ich mich freuen. </p><br><div class="spoiler">  <b class="spoiler_title">Referenzliste</b> <div class="spoiler_text"><ol><li>  <a href="http://microsin.net/programming/ARM/freertos-part1.html">http://microsin.net/programming/ARM/freertos-part1.html</a> </li><li>  <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html">https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html</a> </li><li>  <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/partition-tables.html">https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/partition-tables.html</a> </li><li>  <a href="https://docs.blynk.cc/">https://docs.blynk.cc/</a> </li></ol><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479156/">https://habr.com/ru/post/de479156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479144/index.html">Muss ich meine Marke registrieren lassen?</a></li>
<li><a href="../de479146/index.html">Vergleich der Bypass-Tools \ VPN</a></li>
<li><a href="../de479150/index.html">Agrarroboter schreiten voran</a></li>
<li><a href="../de479152/index.html">Reagiere und schaue ohne npm und baue</a></li>
<li><a href="../de479154/index.html">Noch ein Kampf oder genug?</a></li>
<li><a href="../de479158/index.html">7 Grundprinzipien von ITIL</a></li>
<li><a href="../de479162/index.html">Auroren auf den Planeten des Sonnensystems</a></li>
<li><a href="../de479164/index.html">Was ist EEG und warum wird es benötigt?</a></li>
<li><a href="../de479166/index.html">Schreiben Sie Ihr Capped Expirationd-Modul für Tarantool</a></li>
<li><a href="../de479168/index.html">So erstellen Sie eine RESTful-API auf der Symfony 5 + -API-Plattform für ein MODX-Projekt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>