<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÉ üå§Ô∏è ‚¨úÔ∏è Schreiben von Java-freundlichem Kotlin-Code ‚úàÔ∏è ‚è∏Ô∏è ü§ù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von au√üen mag es so aussehen, als h√§tte Kotlin die Android-Entwicklung vereinfacht, ohne neue Schwierigkeiten zu verursachen: Die Sprache ist Java-kom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben von Java-freundlichem Kotlin-Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/417951/">  Von au√üen mag es so aussehen, als h√§tte Kotlin die Android-Entwicklung vereinfacht, ohne neue Schwierigkeiten zu verursachen: Die Sprache ist Java-kompatibel, sodass selbst ein gro√ües Java-Projekt schrittweise in das Projekt √ºbersetzt werden kann, ohne jemanden zu st√∂ren, oder?  Aber wenn Sie genauer hinschauen, gibt es in jeder Schachtel einen doppelten Boden und im Schminktisch eine Geheimt√ºr.  Programmiersprachen sind zu komplexe Projekte, um ohne knifflige Nuancen kombiniert zu werden. <br><br>  Dies bedeutet nat√ºrlich nicht, dass "alles schlecht ist und Sie Kotlin nicht mit Java verwenden m√ºssen", sondern dass Sie die Nuancen kennen und ber√ºcksichtigen sollten.  Auf unserer <b>Mobius-</b> Konferenz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sprach</a> Sergei Ryabov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dar√ºber,</a> wie man Code auf Kotlin schreibt, auf den bequem von Java aus zugegriffen werden kann.  Das Publikum mochte den Bericht so sehr, dass wir nicht nur beschlossen, ein Video zu ver√∂ffentlichen, sondern auch eine Textversion f√ºr Habr erstellten: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1L0q5VKx_-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Ich schreibe Kotlin seit mehr als drei Jahren, jetzt nur noch darauf, aber zuerst habe ich Kotlin in bestehende Java-Projekte hineingezogen.  Daher stellte sich mir oft die Frage, wie man Java und Kotlin zusammenh√§lt. <br><br>  Wenn Sie einem Projekt Kotlin hinzuf√ºgen, k√∂nnen Sie h√§ufig sehen, wie dies ... <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span></code> </pre> <br>  ... verwandelt sich in: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents-kotlin:xyz'</span></span></code> </pre><br>  Die Besonderheiten der letzten Jahre: Die beliebtesten Bibliotheken erwerben Wrapper, damit sie von Kotlin idiomatischer verwendet werden k√∂nnen. <br><br>  Wenn Sie in Kotlin geschrieben haben, wissen Sie, dass es coole Erweiterungsfunktionen, Inline-Funktionen und Lambda-Ausdr√ºcke gibt, die in Java 6 verf√ºgbar sind. Und das ist cool, es zieht uns zu Kotlin an, aber die Frage stellt sich.  Eine der gr√∂√üten und bekanntesten Funktionen der Sprache ist die Interoperabilit√§t mit Java.  Wenn Sie alle aufgef√ºhrten Funktionen ber√ºcksichtigen, warum nicht einfach Bibliotheken in Kotlin schreiben?  Mit Java funktionieren sie alle sofort einsatzbereit, und Sie m√ºssen nicht alle diese Wrapper unterst√ºtzen. Alle sind gl√ºcklich und zufrieden. <br><br>  Aber in der Praxis ist nat√ºrlich nicht alles so rosig wie in Brosch√ºren, es gibt immer ein "kleines Schriftattribut", es gibt scharfe Kanten an der Kreuzung von Kotlin und Java, und heute werden wir ein wenig dar√ºber sprechen. <br><br><h2>  Scharfe Kanten </h2><br>  Beginnen wir mit den Unterschieden.  Wissen Sie zum Beispiel, dass es in Kotlin keine Schl√ºsselw√∂rter gibt, die fl√ºchtig, synchronisiert, streng, vor√ºbergehend sind?  Sie werden durch gleichnamige Anmerkungen im Paket kotlin.jvm ersetzt.  Der gr√∂√üte Teil der Konversation wird sich also mit dem Inhalt dieses Pakets befassen. <br><br>  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Timber</a> - eine solche Bibliotheksabstraktion √ºber Holzf√§ller der ber√ºchtigten <abbr title="Jake Wharton">Zheka Vartanov</abbr> .  Sie k√∂nnen es √ºberall in Ihrer Anwendung verwenden, und alles, wo Sie Protokolle senden m√∂chten (an logcat oder an Ihren Server zur Analyse oder zur Absturzberichterstattung usw.), wird zu Plug-Ins. <br><br>  Stellen wir uns zum Beispiel vor, wir m√∂chten eine √§hnliche Bibliothek nur f√ºr Analysen schreiben.  Auch auskuppeln. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Analytics { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;Plugin&gt; {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context: Map&lt;String, Any&gt; = emptyMap() )</code> </pre><br>  Wir nehmen das gleiche Konstruktionsmuster, wir haben einen Einstiegspunkt - das ist Analytics.  Wir k√∂nnen dort Ereignisse senden, Plugins hinzuf√ºgen und sehen, was wir dort bereits hinzugef√ºgt haben. <br><br>  Plugin ist eine Plugin-Schnittstelle, die eine bestimmte Analyse-API abstrahiert. <br><br>  Und tats√§chlich die Ereignisklasse, die den Schl√ºssel und unsere Attribute enth√§lt, die wir senden.  In diesem Bericht geht es nicht darum, ob es sich lohnt, Singletones zu verwenden. Lassen Sie uns also keinen Holivar z√ºchten, aber wir werden sehen, wie man das Ganze k√§mmt. <br><br>  Jetzt ein kleiner Tauchgang.  Hier ist ein Beispiel f√ºr die Verwendung unserer Bibliothek in Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> props = mapOf( USER_ID to <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span> to <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins = Analytics.hasPlugins Analytics.addPlugin(EMPTY_PLUGIN) <span class="hljs-comment"><span class="hljs-comment">// dry-run Analytics.addPlugins(listOf(LoggerPlugin("ALog"), SegmentPlugin))) val plugins = Analytics.getPlugins() // ... }</span></span></code> </pre><br>  Im Prinzip sieht es wie erwartet aus.  Ein Einstiegspunkt sind Methoden, die a la statics genannt werden.  Ereignis ohne Parameter, Ereignis mit Attributen.  Wir √ºberpr√ºfen, ob wir Plugins haben, schieben ein leeres Plugin hinein, um nur eine Art "Trockenlauf" zu machen.  Oder f√ºgen Sie einige andere Plugins hinzu, zeigen Sie sie an und so weiter.  Im Allgemeinen hoffe ich, dass bei Standardbenutzerf√§llen bisher alles klar ist. <br><br>  Nun wollen wir sehen, was in Java passiert, wenn wir dasselbe tun: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>, Collections.emptyMap())); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.INSTANCE.getHasPlugins(); Analytics.INSTANCE.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run final List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin("ALog"), new SegmentPlugin()); // ... }</span></span></code> </pre><br>  Die Aufregung mit INSTANCE rauscht mir sofort in die Augen, was sich ausdehnt, das Vorhandensein expliziter Werte f√ºr den Standardparameter mit Attributen, einige Getter mit dummen Namen.  Da wir uns im Allgemeinen hier versammelt haben, um daraus etwas √Ñhnliches wie die vorherige Datei mit Kotlin zu machen, lassen Sie uns jeden Moment durchgehen, den wir nicht m√∂gen, und versuchen, es irgendwie anzupassen. <br><br>  Beginnen wir mit Event.  Wir entfernen den Parameter Colletions.emptyMap () aus der zweiten Zeile, und ein Compilerfehler wird angezeigt.  Was ist der Grund daf√ºr? <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Any</span></span></span><span class="hljs-class">&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emptyMap</span></span></span><span class="hljs-class">() )</span></span></code> </pre><br>  Unser Konstruktor hat einen Standardparameter, an den wir den Wert √ºbergeben.  Wir kommen von Java nach Kotlin. Es ist logisch anzunehmen, dass das Vorhandensein eines Standardparameters zwei Konstruktoren generiert: einen vollst√§ndigen mit zwei Parametern und einen partiellen, f√ºr den nur der Name angegeben werden kann.  Offensichtlich glaubt der Compiler das nicht.  Mal sehen, warum er denkt, wir liegen falsch. <br><br>  Unser Hauptwerkzeug zur Analyse aller Wendungen, wie Kotlin zu einem JVM-Bytecode wird - Kotlin Bytecode Viewer.  In Android Studio und IntelliJ IDEA befindet es sich im Men√º Extras - Kotlin - Kotlin-Bytecode anzeigen.  Sie k√∂nnen einfach Cmd + Umschalt + A dr√ºcken und Kotlin Bytecode in die Suchleiste eingeben. <br><br><img src="https://habrastorage.org/webt/3d/9i/kg/3d9ikgrehu0zgr50qyftivtoahi.png"><br><br>  Hier sehen wir √ºberraschenderweise einen Bytecode dessen, was aus unserer Kotlin-Klasse wird.  Ich erwarte nicht, dass Sie √ºber ausgezeichnete Kenntnisse des Bytecodes verf√ºgen, und vor allem erwarten IDE-Entwickler dies auch nicht.  Daher haben sie eine Schaltfl√§che Dekompilieren gemacht. <br><br>  Nachdem wir darauf geklickt haben, sehen wir einen ungef√§hr guten Java-Code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map context; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, @NotNull Map context)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(name, <span class="hljs-string"><span class="hljs-string">"name"</span></span>); Intrinsics.checkParameterIsNotNull(context, <span class="hljs-string"><span class="hljs-string">"context"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context = context; } <span class="hljs-comment"><span class="hljs-comment">// $FF: Synthetic method public Event(String var1, Map var2, int var3, DefaultConstructorMarker var4) { if ((var3 &amp; 2) != 0) { var2 = MapsKt.emptyMap(); } // ... }</span></span></code> </pre><br>  Wir sehen unsere Felder, Getter, den erwarteten Konstruktor mit zwei Parametern, Name und Kontext, alles l√§uft gut.  Und unten sehen wir den zweiten Konstruktor, und hier ist er mit einer unerwarteten Signatur: nicht mit einem Parameter, sondern aus irgendeinem Grund mit vier. <br><br>  Hier kann es Ihnen peinlich sein, aber Sie k√∂nnen etwas tiefer klettern und herumw√ºhlen.  Wenn wir anfangen zu verstehen, werden wir verstehen, dass DefaultConstructorMarker eine private Klasse aus der Kotlin-Standardbibliothek ist, die hier hinzugef√ºgt wurde, damit es keine Konflikte mit den geschriebenen Konstruktoren gibt, da wir den Parameter vom Typ DefaultConstructorMarker nicht mit unseren H√§nden festlegen k√∂nnen.  Und das Interessante an int var3 ist die Bitmaske, welche Standardwerte wir verwenden sollten.  In diesem Fall wissen wir, wenn varmask mit den beiden √ºbereinstimmt, dass var2 nicht gesetzt ist, unsere Attribute nicht gesetzt sind und wir den Standardwert verwenden. <br><br>  Wie k√∂nnen wir die Situation beheben?  Zu diesem Zweck gibt es eine wundersame Anmerkung @JvmOverloads aus dem Paket, √ºber das ich bereits gesprochen habe.  Wir m√ºssen es an den Konstruktor h√§ngen. <br><br><pre> <code class="hljs delphi">data <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Event @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( val </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">name</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, val context: Map&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt; = emptyMap()</span></span></span><span class="hljs-function"> )</span></span></code> </pre><br>  Und was wird sie tun?  Wenden wir uns demselben Werkzeug zu.  Jetzt sehen wir unseren vollst√§ndigen Konstruktor und den Konstruktor mit DefaultConstructorMarker und, siehe da, einen Konstruktor mit einem Parameter, der jetzt in Java verf√ºgbar ist: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmOverloads</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, (Map)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, (DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre><br>  Und wie Sie sehen, delegiert er die gesamte Arbeit mit Standardparametern mit Bitmasken an unseren Konstruktor.  Daher erzeugen wir keine Informationen dar√ºber, welchen Standardwert wir dort einf√ºgen m√ºssen, sondern delegieren einfach alles in einen Konstruktor.  Sch√∂n.  Wir √ºberpr√ºfen, was wir von der Java-Seite bekommen: Der Compiler ist gl√ºcklich und nicht emp√∂rt. <br><br>  Mal sehen, was uns als n√§chstes nicht gef√§llt.  Wir m√∂gen diesen INSTANZ nicht, der in IDEA ein schwieliger in lila ist.  Ich mag keine lila Farbe :) <br><br><img src="https://habrastorage.org/webt/ys/rq/er/ysrqerlelunfipzn0xat3yek9da.png"><br><br>  Lassen Sie uns √ºberpr√ºfen, was sich herausstellt.  Schauen wir uns den Bytecode noch einmal an. <br><br>  Zum Beispiel markieren wir die Init-Funktion und stellen sicher, dass Init tats√§chlich nicht statisch generiert wird. <br><br><img src="https://habrastorage.org/webt/ek/5h/m2/ek5hm21brrzzf5yfu5mahq4x5eq.png"><br><br>  Das hei√üt, was auch immer man sagen mag, wir m√ºssen mit einer Instanz dieser Klasse arbeiten und diese Methoden darauf aufrufen.  Wir k√∂nnen jedoch die Generierung all dieser Methoden als statisch erzwingen.  Hierf√ºr gibt es eine wunderbare Anmerkung @JvmStatic.  F√ºgen wir es dem Init hinzu und senden Sie Funktionen und √ºberpr√ºfen Sie, was der Compiler jetzt dar√ºber denkt. <br><br>  Wir sehen, dass das statische Schl√ºsselwort zu public final init () hinzugef√ºgt wurde, und wir haben uns vor der Arbeit mit INSTANCE bewahrt.  Wir werden dies im Java-Code √ºberpr√ºfen. <br><br>  Der Compiler teilt uns nun mit, dass wir die statische Methode aus dem INSTANCE-Kontext aufrufen.  Dies kann korrigiert werden: Dr√ºcken Sie Alt + Eingabetaste, w√§hlen Sie "Bereinigungscode" und voila, INSTANZ verschwindet, alles sieht ungef√§hr so ‚Äã‚Äãaus wie in Kotlin: <br><br><pre> <code class="java hljs"> Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>));</code> </pre><br>  Jetzt haben wir ein Schema f√ºr die Arbeit mit statischen Methoden.  F√ºgen Sie diese Anmerkung hinzu, wo immer es uns wichtig ist: <br><br><img src="https://habrastorage.org/webt/0o/m4/ky/0om4kydc_nj_fnmjd6jnfsfqfao.png"><br><br>  Und der Kommentar: Wenn die Methoden, die wir haben, offensichtlich die Instanzmethoden sind, dann ist zum Beispiel bei Eigenschaften nicht alles so offensichtlich.  Die Felder selbst (z. B. Plugins) werden als statisch generiert.  Getter und Setter arbeiten jedoch als Instanzmethoden.  Daher m√ºssen Sie f√ºr Eigenschaften auch diese Anmerkung hinzuf√ºgen, um Setter und Getter statisch zu machen.  Zum Beispiel sehen wir die Variable isInited, f√ºgen die Annotation @JvmStatic hinzu und jetzt sehen wir im Kotlin Bytecode Viewer, dass die Methode isInited () statisch geworden ist, alles ist in Ordnung. <br><br>  Gehen wir jetzt zum Java-Code, "zum Aufr√§umen", und alles sieht ungef√§hr wie Kotlin aus, bis auf die Semikolons und das Wort "Neu" - Sie werden sie nicht los. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.getHasPlugins(); Analytics.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run // ... }</span></span></code> </pre><br>  N√§chster Schritt: Wir sehen diesen dumm benannten getHasPlugins-Getter mit zwei Pr√§fixen gleichzeitig.  Nat√ºrlich bin ich kein gro√üer Kenner der englischen Sprache, aber es scheint mir, dass hier etwas anderes impliziert wurde.  Warum passiert das? <br><br>  Wie sie eng mit Kotlin wussten, werden Eigenschaftsnamen f√ºr Getter und Setter gem√§√ü den JavaBeans-Regeln generiert.  Dies bedeutet, dass Getter im Allgemeinen Get-Pr√§fixe und Setter Setzpr√§fixe haben.  Es gibt jedoch eine Ausnahme: Wenn Sie ein Boolesches Feld haben und dessen Name das Pr√§fix is ‚Äã‚Äãhat, wird dem Getter das Pr√§fix is ‚Äã‚Äãvorangestellt.  Dies ist im Beispiel des obigen Feldes isInited zu sehen. <br><br>  Leider sollten bei weitem nicht immer boolesche Felder durchgerufen werden.  isPlugins w√ºrde nicht ganz das erf√ºllen, was wir semantisch mit Namen zeigen wollen.  Wie geht es uns <br><br>  Und es ist nicht schwer f√ºr uns, daf√ºr gibt es unsere eigene Anmerkung (wie Sie bereits verstanden haben, werde ich dies heute oft wiederholen).  Mit der Annotation @JvmName k√∂nnen Sie einen beliebigen Namen angeben (nat√ºrlich von Java unterst√ºtzt).  F√ºgen Sie es hinzu: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hasPlugin"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  Lassen Sie uns √ºberpr√ºfen, was wir in Java erhalten haben: Die Methode getHasPlugins ist nicht mehr vorhanden, aber hasPlugins ist etwas f√ºr sich.  Dies l√∂ste unser Problem erneut mit einer Anmerkung.  Jetzt l√∂sen wir alle Anmerkungen! <br><br>  Wie Sie sehen k√∂nnen, setzen wir hier die Anmerkung direkt auf den Getter.  Was ist der Grund daf√ºr?  Mit der Tatsache, dass unter der Eigenschaft viel von allem ist, und es ist nicht klar, wof√ºr @JvmName gilt.  Wenn Sie die Anmerkung an val hasPlugins selbst √ºbertragen, versteht der Compiler nicht, worauf sie angewendet werden soll. <br><br>  Kotlin kann jedoch auch angeben, wo Anmerkungen direkt darin verwendet werden.  Sie k√∂nnen den Ziel-Getter, die gesamte Datei, den Parameter, den Delegaten, das Feld, die Eigenschaften, die Empf√§ngererweiterungsfunktionen, den Setter und den Setter-Parameter angeben.  In unserem Fall ist Getter interessant.  Und wenn Sie dies m√∂gen, hat dies den gleichen Effekt wie beim Aufh√§ngen der Anmerkung auf get: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@get:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPlugins"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  Wenn Sie keinen benutzerdefinierten Getter haben, k√∂nnen Sie ihn direkt an Ihr Eigentum anh√§ngen, und alles ist in Ordnung. <br><br>  Der n√§chste Punkt, der uns ein wenig verwirrt, ist "Analytics.INSTANCE.getEMPTY_PLUGIN ()".  Hier ist die Sache nicht mehr einmal auf Englisch, sondern einfach: WARUM?  Die Antwort ist ungef√§hr gleich, aber zuerst eine kleine Einf√ºhrung. <br><br>  Um ein Feld konstant zu machen, haben Sie zwei M√∂glichkeiten.  Wenn Sie eine Konstante als primitiven Typ oder als Zeichenfolge und auch innerhalb des Objekts definieren, k√∂nnen Sie das Schl√ºsselwort const verwenden, und dann werden Getter-Setter und andere Dinge nicht generiert.  Es wird eine gew√∂hnliche Konstante sein - eine private endg√ºltige Statik - und es wird eingef√ºgt, das hei√üt, eine absolut gew√∂hnliche Java-Sache. <br><br>  Wenn Sie jedoch aus einem Objekt, das sich von der Zeichenfolge unterscheidet, eine Konstante erstellen m√∂chten, k√∂nnen Sie das Wort const hierf√ºr nicht verwenden.  Hier haben wir val EMPTY_PLUGIN = EmptyPlugin (), demnach wurde dieser schreckliche Getter offensichtlich generiert.  Wir k√∂nnen @JvmName mit einer Anmerkung umbenennen, dieses get-Pr√§fix entfernen, aber es bleibt eine Methode - mit Klammern.  Alte L√∂sungen funktionieren also nicht, wir suchen nach neuen. <br><br>  Und hier dazu die Anmerkung @JvmField, die besagt: "Ich will hier keine Getter, ich will keine Setter, mach mich zu einem Feld."  Stellen Sie es vor val EMPTY_PLUGIN und √ºberpr√ºfen Sie, ob alles wahr ist. <br><br><img src="https://habrastorage.org/webt/7e/ei/0i/7eei0iwsgrd3pvkg_6lljoylhzm.png"><br><br>  Kotlin Bytecode Viewer zeigt das hervorgehobene St√ºck an, auf dem Sie gerade in der Datei stehen.  Wir stehen jetzt auf EMPTY_PLUGIN, und Sie sehen, dass hier eine Art Initialisierung im Konstruktor geschrieben ist.  Tatsache ist, dass der Getter nicht mehr da ist und der Zugriff nur zur Aufnahme dient.  Und wenn Sie auf Dekompilieren klicken, sehen wir, dass "public static final EmptyPlugin EMPTY_PLUGIN" angezeigt wurde. Genau das haben wir erreicht.  Sch√∂n.  Wir pr√ºfen, ob alles allen gef√§llt, insbesondere dem Compiler.  Das Wichtigste, was Sie beschwichtigen m√ºssen, ist der Compiler. <br><br><h2>  Generika </h2><br>  Machen wir eine Pause vom Code und schauen uns die Generika an.  Dies ist ein ziemlich hei√ües Thema.  Oder rutschig, wer mag das nicht mehr.  Java hat seine eigenen Komplexit√§ten, aber Kotlin ist anders.  Zun√§chst geht es uns um Variationen.  Was ist das? <br><br>  Variabilit√§t ist eine M√∂glichkeit, Informationen √ºber eine Typhierarchie von Basistypen auf Ableitungen zu √ºbertragen, z. B. auf Container oder Generika.  Hier haben wir die Tier- und Hundeklassen mit einem sehr offensichtlichen Zusammenhang: Hund ist ein Subtyp, Tier ist ein Subtyp, der Pfeil kommt vom Subtyp. <br><br><img src="https://habrastorage.org/webt/rz/-b/uz/rz-buzyeywt0xgwewjvauwmf0lc.png"><br><br>  Und welche Verbindung werden ihre Derivate haben?  Schauen wir uns einige F√§lle an. <br><br>  Der erste ist Iterator.  Um festzustellen, was ein Subtyp und was ein Subtyp ist, orientieren wir uns an der Substitutionsregel Barbara Liskov.  Es kann wie folgt formuliert werden: "Der Subtyp sollte nicht mehr erfordern und nicht weniger liefern." <br><br>  In unserer Situation gibt Iterator uns nur typisierte Objekte, zum Beispiel Animal.  Wenn wir Iterator irgendwo akzeptieren, k√∂nnen wir Iterator gut dort einsetzen und Animal von der next () -Methode erhalten, da der Hund auch Animal ist.  Wir bieten nicht weniger, sondern mehr, weil ein Hund ein Subtyp ist. <br><br><img src="https://habrastorage.org/webt/bz/4e/ra/bz4eracdjm_ep_qnzk0mbkr5q7w.png"><br><br>  Ich wiederhole: Wir lesen nur von diesem Typ, daher bleibt hier die Beziehung zwischen dem Typ und dem Subtyp erhalten.  Und solche Typen werden Kovarianten genannt. <br><br>  Ein anderer Fall: Aktion.  Aktion ist eine Funktion, die nichts zur√ºckgibt, einen Parameter akzeptiert und nur an Aktion schreibt, dh einen Hund oder ein Tier von uns nimmt. <br><br><img src="https://habrastorage.org/webt/h5/hg/74/h5hg74k6id9rwtzfq1j2g1qsjyk.png"><br><br>  Wir liefern hier also nicht mehr, sondern fordern, und wir d√ºrfen nicht mehr verlangen.  Dies bedeutet, dass sich unsere Abh√§ngigkeit √§ndert.  "Nicht mehr" haben wir Tier (Tier weniger als ein Hund).  Und solche Typen werden als kontravariante bezeichnet. <br><br>  Es gibt einen dritten Fall - zum Beispiel ArrayList, aus dem wir lesen und schreiben.  Daher versto√üen wir in diesem Fall gegen eine der Regeln, wir ben√∂tigen mehr f√ºr eine Aufzeichnung (ein Hund, kein Tier).  Solche Typen sind in keiner Weise verwandt und werden als invariant bezeichnet. <br><br><img src="https://habrastorage.org/webt/gj/5o/gp/gj5ogpkqy1ifvtmxghqszew7fgk.png"><br><br>  In Java, als es vor Version 1.5 entworfen wurde (wo Generika erschienen), machten sie Arrays standardm√§√üig kovariant.  Dies bedeutet, dass Sie dem Array von Objekten ein Array von Zeichenfolgen zuweisen k√∂nnen, es dann an die Methode √ºbergeben k√∂nnen, an der das Array von Objekten ben√∂tigt wird, und versuchen k√∂nnen, das Objekt dorthin zu verschieben, obwohl dies ein Array von Zeichenfolgen ist.  Alles wird auf dich fallen. <br><br>  Nachdem sie aus bitterer Erfahrung gelernt hatten, dass dies nicht m√∂glich ist, entschieden sie beim Entwerfen von Generika: "Wir werden die Kollektionen unver√§nderlich machen, wir werden nichts mit ihnen machen." <br><br>  Und am Ende stellt sich heraus, dass in so einer scheinbar offensichtlichen Sache alles in Ordnung sein sollte, aber eigentlich nicht in Ordnung: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); List&lt;Animal&gt; animals = dogs;</span></span></code> </pre><br>  Aber wir m√ºssen irgendwie herausfinden, was wir schlie√ülich k√∂nnen: Wenn wir nur von diesem Blatt lesen, warum nicht die M√∂glichkeit geben, die Liste der Hunde hier zu √ºbertragen?  Daher ist es m√∂glich, mit einem Platzhalter zu charakterisieren, welche Art von Variation dieser Typ haben wird: <br><br><pre> <code class="java hljs">List&lt;Dog&gt; dogs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); List&lt;? extends Animal&gt; animals = dogs;</code> </pre><br>  Wie Sie sehen k√∂nnen, ist diese Variante am Verwendungsort angegeben, an dem wir die Hunde zuordnen.  Daher wird dies als Use-Site-Varianz bezeichnet. <br><br>  Was sind die Nachteile davon?  Die negative Seite ist, dass Sie diesen be√§ngstigenden Platzhalter √ºberall dort angeben m√ºssen, wo Sie Ihre API verwenden, und all dies ist im Code sehr fruchtbar.  Aber in Kotlin funktioniert so etwas aus irgendeinem Grund sofort, und Sie m√ºssen nichts angeben: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dogs: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Dog</span></span>&gt; = <span class="hljs-type"><span class="hljs-type">ArrayList</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animals: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Animal</span></span>&gt; = dogs</code> </pre><br>  Was ist der Grund daf√ºr?  Mit der Tatsache, dass die Bl√§tter tats√§chlich unterschiedlich sind.  Liste in Java bedeutet Schreiben, w√§hrend es in Kotlin schreibgesch√ºtzt ist und nicht impliziert.  Daher k√∂nnen wir im Prinzip sofort sagen, dass wir nur von hier aus lesen, daher k√∂nnen wir kovariant sein.  Und dies wird genau in der Typdeklaration festgelegt, wobei das Schl√ºsselwort out den Platzhalter ersetzt: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out E</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">E</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre><br>  Dies wird als Varianz der Deklarationsstelle bezeichnet.  Daher haben wir alles an einer Stelle angegeben, und wo wir es verwenden, ber√ºhren wir dieses Thema nicht mehr.  Und das ist Nishtyak. <br><br><h2>  Zur√ºck zum Code </h2><br>  Gehen wir zur√ºck in unsere Tiefen.  Hier haben wir die addPlugins-Methode, es braucht eine Liste: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }    ,  , List&lt;EmptyPlugin&gt;, ,     : &lt;source lang=<span class="hljs-string"><span class="hljs-string">"java"</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin(<span class="hljs-string"><span class="hljs-string">"Alog"</span></span>), new SegmentPlugin());</code> </pre><br>  Aufgrund der Tatsache, dass List in Kotlin kovariant ist, k√∂nnen wir die Liste der Plugin-Erben hier leicht √ºbergeben.  Alles wird funktionieren, der Compiler hat nichts dagegen.  Aufgrund der Tatsache, dass wir eine Abweichung von der Deklarationsstelle haben, in der wir alles angegeben haben, k√∂nnen wir die Verbindung mit Java zum Zeitpunkt der Verwendung nicht steuern.  Aber was passiert, wenn wir dort wirklich ein Plugin-Blatt wollen, wir wollen dort keine Erben?  Es gibt keine Modifikatoren daf√ºr, aber was?  Das stimmt, es gibt eine Anmerkung.  Und die Annotation hei√üt @JvmSuppressWildcards, das hei√üt, wir denken standardm√§√üig, dass hier ein Typ mit Platzhalter ist, der Typ ist kovariant. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;@</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JvmSuppressWildcards</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }</code> </pre><br>  Wenn wir SuppressWildcards sprechen, unterdr√ºcken wir alle diese Fragen und unsere Signatur √§ndert sich tats√§chlich.  Dar√ºber hinaus zeige ich Ihnen, wie alles im Bytecode aussieht: <br><br><img src="https://habrastorage.org/webt/rn/xp/ft/rnxpft1zqpioojczpiiyn1g3veo.png"><br><br>  Ich werde die Anmerkung vorerst aus dem Code entfernen.  Hier ist unsere Methode.  Sie wissen wahrscheinlich, dass eine L√∂schung vorliegt.  Und in Ihrem Bytecode gibt es keine Informationen dar√ºber, welche Art von Fragen es gab, also Generika im Allgemeinen.  Aber der Compiler folgt dem und signiert es in den Kommentaren zum Bytecode: und dies ist der Typ mit der Frage. <br><br><img src="https://habrastorage.org/webt/u4/5e/mm/u45emmdne71zx9e9whz7uu8law0.png"><br><br>  Jetzt f√ºgen wir die Anmerkung erneut ein und sehen, dass dies unser Typ ist, ohne zu hinterfragen. <br><br><img src="https://habrastorage.org/webt/cu/if/wm/cuifwmem7zn636x3ky7n_41vuly.png"><br><br>  Jetzt wird unser vorheriger Code nicht mehr kompiliert, weil wir Wildcards abgeschnitten haben.  Sie k√∂nnen selbst sehen. <br><br>  Wir haben kovariante Typen erkannt.  Jetzt ist das Gegenteil der Fall. <br><br>  Wir glauben, dass List eine Frage hat.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist offensichtlich anzunehmen, dass dieses Blatt, wenn es von getPlugins zur√ºckkehrt, auch eine Frage enth√§lt. Was bedeutet das? Dies bedeutet, dass wir nicht in der Lage sein werden, darauf zu schreiben, da der Typ kovariant und nicht kontravariant ist. Werfen wir einen Blick darauf, was in Java passiert.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Plugin&gt; plugins = Analytics.getPlugins(); displayPlugins(plugins); Analytics.getPlugins().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niemand ist emp√∂rt, dass wir in der letzten Zeile etwas schreiben, was bedeutet, dass jemand hier falsch liegt. Wenn wir uns den Bytecode ansehen, werden wir von der Richtigkeit unserer Vermutungen √ºberzeugt sein. Wir haben keine Anmerkungen und den Typ aus irgendeinem Grund ohne Frage aufgeh√§ngt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberraschung basiert darauf. Kotlin postuliert sich selbst als pragmatische Sprache. Als all dies entworfen wurde, wurden Statistiken gesammelt, da in Java im Allgemeinen Platzhalter verwendet werden. Es stellte sich heraus, dass die Eingabe meistens eine Varianz zul√§sst, dh die Typen kovariant macht. Nun, es ist n√ºtzlich, wo immer wir wollen, dass eine Liste ein Blatt eines beliebigen Plugin-Erben dort ablegen kann. Und hier, wo wir zur√ºckkehren, wollen wir im Gegenteil reine Typen haben: Da es ein Plugin-Blatt gibt, wird es zur√ºckgegeben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und hier sehen wir aus erster Hand ein Beispiel daf√ºr. Es scheint ein wenig eing√§ngig zu sein, aber es generiert weniger wundervolle Anmerkungen in Ihrem Code, da dies der h√§ufigste Anwendungsfall ist und wenn Sie keine Witze verwenden, funktioniert alles sofort.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall sehen wir jedoch, dass eine solche Situation nichts f√ºr uns ist, weil wir nicht m√∂chten, dass dort etwas aufgezeichnet wird. Und wir wollen auch nicht, dass dies von Java aus m√∂glich ist. In Kotlin ist List hier ein schreibgesch√ºtzter Typ, und wir k√∂nnen dort nichts schreiben, aber der Client unserer Bibliothek kam aus Java und hat alles hineingestopft - wer m√∂chte das? Daher werden wir diese Methode zwingen, eine Liste mit Platzhalter zur√ºckzugeben. Und wir k√∂nnen klarstellen, wie. Wenn wir die Annotation @JvmWildcard hinzuf√ºgen, sagen wir: Generieren Sie einen Typ mit einer Frage f√ºr uns, alles ist ganz einfach. Nun wollen wir sehen, was an diesem Ort in Java passiert. Java sagt "Was machst du?":</font></font><br><br><img src="https://habrastorage.org/webt/su/v_/1r/suv_1rnnuub7bsqlod-oglgra74.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier k√∂nnen wir sogar auf die richtige Liste werfen &lt;? </font><font style="vertical-align: inherit;">erweitert Plugin&gt;, aber sie sagt immer noch "Was machst du?" </font><font style="vertical-align: inherit;">Und im Prinzip passt diese Situation bisher zu uns. </font><font style="vertical-align: inherit;">Aber es gibt ein Skript-Kind, das sagt: "Ich habe die Quelle gesehen, es ist eine Open Source, ich wei√ü, dass es eine ArrayList gibt, und ich werde dich hacken." </font><font style="vertical-align: inherit;">Und alles wird funktionieren, denn es gibt wirklich eine ArrayList und er wei√ü, was dort geschrieben werden kann.</font></font><br><br><pre> <code class="java hljs">((ArrayList&lt;Plugin&gt;) Analytics.getPlugins()).add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√§ngen Sie daher nat√ºrlich coole Anmerkungen auf, aber Sie m√ºssen immer noch das seit langem bekannte defensive Kopieren verwenden. </font><font style="vertical-align: inherit;">Soryan, nirgendwo ohne ihn, wenn Sie m√∂chten, dass Script-Kiddies Sie nicht st√∂ren.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;<span class="hljs-meta"><span class="hljs-meta">@JvmWildcard</span></span> Plugin&gt; = plugin.toImmutableList()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte nur hinzuf√ºgen, dass die Annotation @JvmSuppressWildcard sowohl an den Parameter als auch an die Funktion und an die gesamte Klasse angeh√§ngt werden kann. Dann wird der Abdeckungsbereich erweitert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles scheint in Ordnung zu sein, wir haben unsere Analysen aussortiert. </font><font style="vertical-align: inherit;">Und jetzt die andere Seite, mit der wir uns n√§hern k√∂nnen: das Plugin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wollen das Plugin auf der Java-Seite implementieren. </font><font style="vertical-align: inherit;">Wie die Guten werden wir seine Ausnahme melden:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Event event)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier ist alles sichtbar: </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Kotlin   checked exception.     :   .    , , .  Java   -. : ¬´  Throws -   , ¬ª: <br><br><img src="https://habrastorage.org/webt/g-/v8/go/g-v8gog8gwfa-on0anv0bkwktsk.png"><br><br>    -,   Kotlin? ,   ‚Ä¶ <br><br>   @Throws,     .   throws-   .  ,     IOExeption: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyPlugin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Plugin { @Throws</span></span></span></span>(IOException::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">override</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">send</span></span></span></span>(event: Event) {} <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>        : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Throws(IOException::class)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>   ?   ,   Java,       exception,  .  , .  ,     - ,      ,   @JvmName.  . <br><br>       ,   Java  .   ‚Ä¶ <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> util <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;Int&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it, acc -&gt; it + acc }) } <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printReversedConcatenation"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;String&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(StringBuilder()) { it, acc -&gt; acc.append(it) }) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, es ist uns in Java hier egal, entfernen Sie die Anmerkung. Fehler, jetzt zeigt die IDE einen Fehler in beiden Funktionen. Was denkst du ist der Grund daf√ºr? Ja, ohne Anmerkung werden sie mit demselben Namen generiert, aber hier steht geschrieben, dass einer auf der Liste steht, der andere auf der Liste. Richtig, geben Sie L√∂schen ein. Wir k√∂nnen diesen Fall sogar √ºberpr√ºfen:</font></font><br><br><img src="https://habrastorage.org/webt/qk/oq/jr/qkoqjrub5xc4mdn-twq-s_jehl4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie wissen bereits, wie ich es verstehe, dass alle Funktionen der obersten Ebene in einem statischen Kontext generiert werden. </font><font style="vertical-align: inherit;">Und ohne diese Anmerkung werden wir versuchen, printReversedSum aus List und darunter eine andere ebenfalls aus List zu generieren. </font><font style="vertical-align: inherit;">Denn der Kotlin-Compiler kennt sich mit Generika aus, der Java-Bytecode jedoch nicht. </font><font style="vertical-align: inherit;">Daher ist dies der einzige Fall, in dem die Anmerkungen aus dem Paket kotlin.jvm nicht ben√∂tigt werden, damit Java gut und bequem ist, sondern damit Ihr Kotlin kompiliert. </font><font style="vertical-align: inherit;">Wir setzen einen neuen Namen - sobald wir mit Strings arbeiten, verwenden wir die Verkettung - und alles funktioniert einwandfrei, jetzt wird alles kompiliert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und der zweite Anwenderfall. </font><font style="vertical-align: inherit;">Es ist damit verbunden. </font><font style="vertical-align: inherit;">Wir haben eine umgekehrte Erweiterungsfunktion.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> String.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = StringBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).reverse().toString() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reversedClassName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simpleName</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reverse</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Umkehrung wird in eine statische Klassenmethode namens ReverserKt kompiliert. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(ReverserKt.reverse(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>)); SumsKt.printReversedSum(asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); SumsKt.printReversedConcatenation(asList(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke, das ist nichts Neues f√ºr Sie. Die Nuance ist, dass Leute, die unsere Bibliothek in Java benutzen, vermuten k√∂nnen, dass etwas nicht stimmt. Wir haben die Details der Implementierung unserer Bibliothek auf der Seite des Benutzers durchgesickert und m√∂chten unsere Spuren verwischen. Wie k√∂nnen wir das machen? Wie bereits klar, die Anmerkung @JvmName, √ºber die ich jetzt spreche, aber es gibt eine Einschr√§nkung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst geben wir ihr den gew√ºnschten Namen, wir brennen nicht und es ist wichtig zu sagen, dass wir diese Anmerkung f√ºr die Datei verwenden. Wir m√ºssen die Datei umbenennen.</font></font><br><br><pre> <code class="hljs ruby">@file<span class="hljs-symbol"><span class="hljs-symbol">:Suppress</span></span>(<span class="hljs-string"><span class="hljs-string">"NOTHING_TO_INLINE"</span></span>) @file<span class="hljs-symbol"><span class="hljs-symbol">:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"ReverserUtils"</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt mag der Java-Compiler ReverserKt nicht, aber es wird erwartet, dass wir es durch ReverserUtils ersetzen und alle sind gl√ºcklich. Ein solcher ‚ÄûBenutzerfall 2.1‚Äú ist ein h√§ufiger Fall, wenn Sie mehrere Dateimethoden der obersten Ebene unter einer Klasse und unter einer Fassade sammeln m√∂chten. Zum Beispiel m√∂chten Sie nicht, dass die Methoden der obigen sums.kt von SumsKt aufgerufen werden, sondern dass Sie sich nur um das Umkehren und Zucken von ReverserUtils k√ºmmern. Dann f√ºgen wir dort diese wunderbare @ JvmName-Annotation hinzu, schreiben "ReverserUtils", im Prinzip ist alles in Ordnung, Sie k√∂nnen sogar versuchen, dieses Ding zu kompilieren, aber nein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Umgebung Sie nicht im Voraus warnt, werden Sie beim Kompilieren darauf hingewiesen, dass "Sie zwei Klassen im selben Paket mit demselben Namen, ata, generieren m√∂chten". </font><font style="vertical-align: inherit;">Was muss getan werden? </font><font style="vertical-align: inherit;">F√ºgen Sie die letzte Anmerkung @JvmMultifileClass in dieses Paket ein, die besagt, dass der Inhalt mehrerer Dateien zu einer Klasse wird, dh es gibt nur eine Fassade daf√ºr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In beiden F√§llen f√ºgen wir "@file: JvmMultifileClass" hinzu, und Sie k√∂nnen SumsKt durch ReverserUtils ersetzen. Alle sind gl√ºcklich - glauben Sie mir. </font><font style="vertical-align: inherit;">Mit Anmerkungen fertig! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben mit Ihnen √ºber dieses Paket gesprochen, √ºber alle Anmerkungen. </font><font style="vertical-align: inherit;">Im Prinzip ist bereits aus ihren Namen ersichtlich, wof√ºr sie jeweils verwendet werden. </font><font style="vertical-align: inherit;">Es gibt schwierige F√§lle, in denen Sie beispielsweise ben√∂tigen, dass @JvmName in Kotlin sogar einfach zu verwenden ist.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kotlin-spezifisch </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber h√∂chstwahrscheinlich ist dies nicht alles, was Sie wissen m√∂chten. Es ist auch wichtig zu beachten, wie man mit Kotlin-spezifischen Dingen arbeitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel Inline-Funktionen. Sie sind in Kotlin inline und werden anscheinend sogar √ºber Java in Bytecode zug√§nglich sein? Es stellt sich heraus, dass dies der Fall sein wird, alles in Ordnung sein wird und die Methoden tats√§chlich f√ºr Java verf√ºgbar sind. Wenn Sie beispielsweise ein Nur-Kotlin-Projekt schreiben, wirkt sich dies nicht sehr gut auf Ihr Dex-Z√§hllimit aus. Weil sie in Kotlin nicht ben√∂tigt werden, aber in Wirklichkeit werden sie in Bytecode sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie als N√§chstes die Parameter des Reified-Typs. Solche Parameter sind spezifisch f√ºr Kotlin. Sie sind nur f√ºr Inline-Funktionen verf√ºgbar und erm√∂glichen es Ihnen, Hacks, die in Java nicht verf√ºgbar sind, mit Reflection umzukehren. Da dies nur f√ºr Kotlin gilt, ist es nur f√ºr Kotlin verf√ºgbar, und in Java k√∂nnen Sie leider keine Funktionen mit reified verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.lang.Class. </font><font style="vertical-align: inherit;">Wenn wir ein wenig nachdenken wollen und unsere Bibliothek auch f√ºr Java ist, muss sie unterst√ºtzt werden. </font><font style="vertical-align: inherit;">Sehen wir uns ein Beispiel an. </font><font style="vertical-align: inherit;">Wir haben so ein "Retrofit", das schnell auf mein Knie geschrieben wurde (ich verstehe nicht, was die Jungs so lange geschrieben haben):</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Retrofit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseUrl: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: Client ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T {...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(service.java) } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine Methode, die mit der Java-Klasse funktioniert. Es gibt eine Methode, die mit der Kotlin-KClass funktioniert. Sie m√ºssen nicht zwei verschiedene Implementierungen durchf√ºhren. Sie k√∂nnen Erweiterungseigenschaften verwenden, die Class von KClass und KClass von Class erhalten (im Prinzip hei√üt sie Kotlin offensichtlich). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das wird alles funktionieren, aber es ist ein wenig nicht idiomatisch. </font><font style="vertical-align: inherit;">Im Kotlin-Code √ºbergeben Sie KClass nicht, sondern schreiben mit Reified-Typen. Daher ist es besser, die Methode wie folgt zu wiederholen:</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  .    Kotlin  ,    .  <i>val api = retrofit.create(Api::class)</i>   <i>val api = retrofit.create&lt;Api&gt;()</i> ,   ::class  .    Reified-,    -. <br><br> Unit.     Unit,      ,   void  Java,  .      .       ,       .  -   Scala,   Scala      ,   - ,       ,    ,    void. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Kotlin ist dies jedoch nicht der Fall. </font><font style="vertical-align: inherit;">Kotlin hat nur 22 Schnittstellen, die einen anderen Parametersatz akzeptieren und etwas zur√ºckgeben. </font><font style="vertical-align: inherit;">Somit gibt das Lambda, das Unit zur√ºckgibt, nicht void zur√ºck, sondern Unit. </font><font style="vertical-align: inherit;">Und das setzt seine Grenzen. </font><font style="vertical-align: inherit;">Wie sieht das Lambda aus, das Unit zur√ºckgibt? </font><font style="vertical-align: inherit;">Schauen Sie sie sich jetzt in diesem Codefragment an. </font><font style="vertical-align: inherit;">Lernen Sie sich kennen.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie es von Kotlin: Alles ist in Ordnung, wir verwenden sogar eine Methodenreferenz, wenn wir k√∂nnen, und es liest sich perfekt, unsere Augen sind nicht gef√ºhllos. </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>).forEachReversed(::println) println(reversedClassName&lt;String&gt;()) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist los in Java? </font><font style="vertical-align: inherit;">In Java passiert folgendes Kanu:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Integer&gt; list = asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); ReverserUtils.forEachReversed(list, integer -&gt; { System.out.println(integer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Unit.INSTANCE; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund der Tatsache, dass wir hier etwas zur√ºckgeben m√ºssen. Es ist wie eine Leere mit einem Gro√übuchstaben, wir k√∂nnen nicht einfach darauf punkten. Wir k√∂nnen hier nicht die Referenzmethode verwenden, die leider ung√ºltig zur√ºckgibt. Und dies ist wahrscheinlich das erste, was nach all unseren Manipulationen mit Anmerkungen wirklich die Augen ber√ºhrt. Leider m√ºssen Sie die Unit-Instanz von hier zur√ºckgeben. Sie k√∂nnen sowieso null, niemand braucht es. Ich meine, niemand braucht einen R√ºckgabewert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen wir weiter: Typealiasen sind auch eine ziemlich spezifische Sache, es sind nur Aliase oder Synonyme, sie sind nur bei Kotlin erh√§ltlich, und in Java werden Sie leider das verwenden, was unter diesen Aliasen steht. Entweder ist dies ein M√ºll von dreimal eingeschlossenen Generika oder eine Art verschachtelter Klassen. Java-Programmierer sind es gewohnt, damit zu leben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun zum interessanten Teil: Sichtbarkeit. Oder vielmehr interne Sichtbarkeit. Sie wissen wahrscheinlich, dass es in Kotlin kein privates Paket gibt. Wenn Sie ohne Modifikatoren schreiben, wird es √∂ffentlich sein. Aber es gibt interne. Intern ist so eine knifflige Sache, dass wir uns das jetzt sogar ansehen werden. In Retrofit haben wir eine interne Validierungsmethode.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Retrofit { println(<span class="hljs-string"><span class="hljs-string">"!!!!!! internal fun validate() was called !!!!!!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann nicht von Kotlin aus aufgerufen werden, und das ist verst√§ndlich. </font><font style="vertical-align: inherit;">Was passiert mit Java? </font><font style="vertical-align: inherit;">K√∂nnen wir validate anrufen? </font><font style="vertical-align: inherit;">Vielleicht ist es f√ºr Sie kein Geheimnis, dass intern √∂ffentlich wird. </font><font style="vertical-align: inherit;">Wenn Sie mir nicht glauben, glauben Sie Kotlin Bytecode Viewer. </font></font><br><br><img src="https://habrastorage.org/webt/cc/mr/ts/ccmrtst8oqwmbdvgn4onk8jlrus.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist wirklich √∂ffentlich, aber mit einer so schrecklichen Signatur, die auf eine Person hinweist, dass es wahrscheinlich nicht ganz gedacht war, dass ein solches Kriechen in die √∂ffentliche API kriecht. </font><font style="vertical-align: inherit;">Wenn jemand 80 Zeichen formatiert hat, passt diese Methode m√∂glicherweise nicht einmal in eine Zeile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java haben wir jetzt Folgendes:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$production_sources_for_module_library_main() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen wir, diesen Fall zu kompilieren. </font><font style="vertical-align: inherit;">Zumindest wird es nicht kompiliert, nicht schon schlecht. </font><font style="vertical-align: inherit;">Wir k√∂nnten hier aufh√∂ren, aber lassen Sie mich Ihnen das erkl√§ren. </font><font style="vertical-align: inherit;">Was ist, wenn mir das gef√§llt?</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$library() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann kompiliert. Und die Frage stellt sich: "Warum so?" Was soll ich sagen ... MAGIE! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher ist es sehr wichtig, dass wenn Sie etwas Kritisches in das Interne stecken, dies schlecht ist, da es in Ihre √∂ffentliche API eindringt. Und wenn das Skript-Kind mit einem Kotlin Bytecode Viewer bewaffnet ist, ist es schlecht. Verwenden Sie bei Methoden mit interner Sichtbarkeit nichts sehr Wichtiges. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie mehr Freude haben m√∂chten, empfehle ich zwei Dinge. Um das Arbeiten mit dem Bytecode und das Lesen zu vereinfachen, empfehle ich einen Bericht von Zhenya Vartanov. Es gibt ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kostenloses Video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , obwohl es sich um das SkillsMatter-Ereignis handelt. Sehr cool. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und eine ziemlich alte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von drei Artikeln von Christophe Bales √ºber die verschiedenen Kotlin-Funktionen. </font><font style="vertical-align: inherit;">Dort ist alles cool geschrieben, etwas ist jetzt irrelevant, aber im Allgemeinen ist es sehr verst√§ndlich. </font><font style="vertical-align: inherit;">Trotzdem mit dem Kotlin Bytecode Viewer und all dem.</font></font><br><br>  Vielen Dank! <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihnen der Bericht gefallen hat, achten Sie darauf: Am 8. und 9. Dezember findet der neue </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mobius</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Moskau statt </font><font style="vertical-align: inherit;">, und dort gibt es auch viele interessante Dinge. </font><font style="vertical-align: inherit;">Bereits bekannte Informationen zum Programm finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Website. Dort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen Tickets gekauft werden.</font></font><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417951/">https://habr.com/ru/post/de417951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417941/index.html">Wo verschwindet das Wasser im Wasserkocher?</a></li>
<li><a href="../de417943/index.html">Serverless and React 2: Handfertigkeit und kein Betrug</a></li>
<li><a href="../de417945/index.html">Welche Werkzeuge hat die Parker-Sonde?</a></li>
<li><a href="../de417947/index.html">Datenvisualisierung f√ºr Ihr Webprojekt</a></li>
<li><a href="../de417949/index.html">Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so be√§ngstigend? Kapitel 4.2</a></li>
<li><a href="../de417953/index.html">Trends beim Design von FPGAs. √úbersetzung</a></li>
<li><a href="../de417955/index.html">So werden Sie Interface-Designer. Notwendige F√§higkeiten und leistungsstarke Werkzeuge, √ºber die wir nicht informiert sind</a></li>
<li><a href="../de417957/index.html">√ñffnen Sie das Webinar Linux Containerization Mechanisms</a></li>
<li><a href="../de417959/index.html">10 Tipps zum Interface-Design</a></li>
<li><a href="../de417963/index.html">Wind, Heuschrecke und Frist: Wie wir das Umspannwerk gebaut haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>