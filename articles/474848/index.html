<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèΩ üì∑ ‚ú≥Ô∏è Tetris como impresora üêÇ ü§µüèΩ üè†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al girar, reorganizar y bajar una secuencia predeterminada de formas, el algoritmo de impresora Tetris utiliza la mec√°nica de Tetris para generar mapa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tetris como impresora</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474848/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/az/2c/saaz2chpnuatbjn-rdg3zcryjwo.png"></div><br>  Al girar, reorganizar y bajar una secuencia predeterminada de formas, el algoritmo de impresora Tetris utiliza la mec√°nica de Tetris para generar mapas de bits arbitrarios. <br><br><h2>  Descripci√≥n del algoritmo </h2><br>  El algoritmo convierte los p√≠xeles de la imagen de origen en los cuadrados del campo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tetris</a> l√≠nea por l√≠nea, movi√©ndose de abajo hacia arriba.  Para generar un solo cuadrado, el algoritmo ensambla una estructura que consiste en un √°rea rectangular que est√° completamente soportada por un cuadrado debajo de √©l.  Despu√©s de completar el ensamblaje de la regi√≥n rectangular, sus l√≠neas se borran, dejando un cuadrado debajo de ella.  Aqu√≠ hay tres ejemplos de este comportamiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/895/c80/be8/895c80be864793bcd951c4edb6943f19.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c6/cdf/615/3c6cdf6159a7bbb9dd2dc95e87374055.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/104/674/951/104674951b666a97f36c4d069006df5d.gif"></div><br>  Como se muestra a continuaci√≥n, el algoritmo tambi√©n puede generar varios cuadrados con una estructura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caa/aef/04b/caaaef04b763c02d872079282d3b57d5.gif"></div><br>  En el proceso de construcci√≥n de una fila, todos los cuadrados creados de esta manera deben basarse en algo.  En las im√°genes mostradas arriba, los cuadrados generados est√°n en el piso del campo de juego.  Sin embargo, si una l√≠nea arbitraria contiene agujeros, no podr√° proporcionar el soporte necesario para construir una l√≠nea sobre ella.  El algoritmo resuelve este problema creando una plataforma plana en la parte superior de la cadena con agujeros.  En la animaci√≥n a continuaci√≥n, una plataforma construida en la parte superior de una l√≠nea consta de un cuadrado rojo.  Una plataforma es una estructura temporal, y al insertar la √∫ltima forma se elimina. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acf/f14/c6d/acff14c6d078f15cc01523e4c24389cb.gif"></div><br>  La fila de 5 cuadrados rojos que se muestra a continuaci√≥n est√° en la parte superior de la fila de 3 cuadrados rojos.  Esto se logra mediante la construcci√≥n de una plataforma plana en la parte superior de la l√≠nea de fondo.  La plataforma proporciona el soporte necesario para generar 5 cuadrados rojos.  Al final, la plataforma se elimina insertando la √∫ltima forma, y ‚Äã‚Äãla nueva l√≠nea cae en su lugar.  Tenga en cuenta que si el algoritmo necesita generar l√≠neas en el orden inverso (una l√≠nea de 3 cuadrados rojos sobre una l√≠nea de 5 cuadrados rojos), entonces la plataforma no ser√° necesaria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/0ad/35c/8510ad35cdbf5639b06b5f17957eec79.gif"></div><br><h2>  Patrones de una plaza </h2><br>  Como referencia, dar√© los nombres de 7 tetramino (piezas del juego). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/817/4aa/cef8174aa74b378cb17af2fe0c6f1c7b.png"></div><br>  La versi√≥n del algoritmo de impresora Tetris presentada en el art√≠culo est√° dise√±ada espec√≠ficamente para renderizar sprites de videojuegos antiguos.  Estos juegos empacaron gr√°ficos en 8 √ó 8 mosaicos, y se asignaron 2 bytes por cada p√≠xel.  Por lo tanto, los sprites generalmente conten√≠an solo 3 colores m√°s √°reas transparentes y con mayor frecuencia ten√≠an un tama√±o de 16 √ó 16 o 16 √ó 32 p√≠xeles. <br><br>  La animaci√≥n a continuaci√≥n muestra todos los patrones utilizados para crear cuadrados individuales.  Cada patr√≥n utiliza tetramino intercambiable J, T y L, creando un √∫nico cuadrado en la parte inferior.  El algoritmo asigna este tetramino a uno de los 3 colores presentes en el sprite.  Al resto del tetramino se le asignan colores arbitrarios.  A lo largo del juego, todos los colores permanecen constantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/b1f/efc/dfab1fefc65efed365513213cdf5ad12.gif"></div><br>  Debido a la forma de los tres tetramino, es imposible crear un cuadrado a partir de los tres colores en las primeras dos y √∫ltimas dos columnas.  Por lo tanto, el ancho m√≠nimo del campo de juego para renderizar un sprite con un ancho de 16 p√≠xeles es 2 + 16 + 2 = 20 cuadrados.  Sin embargo, result√≥ que 20 es muy poco. <br><br>  Como se muestra a continuaci√≥n, el √°rea sobre el cuadrado inferior √∫nico no puede consistir en una sola l√≠nea, porque las √∫nicas figuras que pueden caber en ella (tetramino I) no tienen soporte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/1e5/645/87f1e56455f90295b076e72296cc58c1.gif"></div><br>  Con dos l√≠neas, la √∫nica forma de estirar todo el campo de juego para que tenga soporte es usar tetramino S y Z. Pero en este caso, los agujeros permanecer√°n en la l√≠nea superior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58c/ea6/8ef/58cea68ef0e7d83c102402e9ed0255fb.gif"></div><br>  El n√∫mero m√≠nimo de l√≠neas requeridas sobre el cuadrado inferior es 3, y como se muestra varias veces arriba, tales patrones existen.  20 cuadrados es el ancho m√≠nimo requerido para colocar un sprite con un ancho de 16 p√≠xeles.  Pero 20 √ó 3 + 1 = 61, y este n√∫mero no es divisible por 4, lo que significa que no se puede construir a partir de tetramino.  Sin embargo, un ancho de 21 nos da 21 √ó 3 + 1 = 64, y se puede construir a partir de 16 tetramino.  De hecho, este ancho permite que el algoritmo renderice sprites de hasta 17 p√≠xeles de ancho. <br><br>  El campo de juego del Tetris original tiene un tama√±o de 10 √ó 20 cuadrados (relaci√≥n 1: 2).  En esta versi√≥n del algoritmo, esta relaci√≥n se conserva: el campo de juego tiene un tama√±o de 21 √ó 42 cuadrados. <br><br>  Dado que el tetramino J, T y L son intercambiables cuando se crea un cuadrado, y 3 cuadrados de estos tetramino est√°n involucrados en la creaci√≥n de una l√≠nea por encima de √©l, hay 21 - 3 = 18 patrones para crear un solo cuadrado.  Sin embargo, debido a la simetr√≠a de espejo, en realidad solo hay 9. Hay 3 l√≠neas que funcionan para la mayor√≠a de estos 9. Sin embargo, un estudio exhaustivo por computadora mostr√≥ que los dos patrones necesitaban m√°s.  La siguiente opci√≥n posible es 7 l√≠neas, porque 21 √ó 7 + 1 = 148, que requiere 37 tetraminos.  Como se muestra en las im√°genes a continuaci√≥n, existen tales patrones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/643/2ca/7a26432ca3f6e11d43f134057f3bfa73.gif"></div><br><h2>  M√∫ltiples patrones cuadrados </h2><br>  Los patrones para crear m√∫ltiples cuadrados est√°n limitados a los mismos tres colores creados por los patrones de un solo cuadrado.  Los cuadrados resultantes se crean a partir de tetramino J, T y L, cada uno de los cuales ocupa 3 cuadrados en una l√≠nea sobre la l√≠nea de creaci√≥n.  El n√∫mero m√°ximo de cuadrados que se pueden crear potencialmente con un solo patr√≥n es 21/3 = 7. Sin embargo, para sprites con un ancho de 16 p√≠xeles, el tetramino m√°s a la derecha no puede crear un cuadrado.  Incluso en el caso de sprites con un ancho de 17 p√≠xeles, puede crear un cuadrado de un solo color.  Por lo tanto, el patr√≥n de crear a partir de 7 cuadrados rara vez se usa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/9cc/957/e019cc9577348937886f2f160fd8ad1b.gif"></div><br>  El n√∫mero de patrones para crear un n√∫mero arbitrario de cuadrados se puede determinar utilizando la combinatoria de enumeraciones.  Considere el siguiente patr√≥n, que representa una fila sobre una fila de tres cuadrados.  Cada bloque de tres cuadrados blancos adyacentes designa una parte de tetramino;  los cuadrados creados no se muestran. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/b6d/fe5/cefb6dfe5d0c9c3b644189dc13901e63.gif"></div><br>  Tres tetramino crean 4 vac√≠os.  Hay 21 - 3 √ó 3 = 12 cuadrados oscuros que se pueden insertar arbitrariamente en estos vac√≠os para formar un patr√≥n espec√≠fico.  El n√∫mero de formas de distribuir estos cuadrados oscuros se puede calcular coloc√°ndolos en una l√≠nea en la que los cuadrados blancos individuales se tratan como divisores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/160/0fb/3731600fb90642ff32fa58ee059cf4c3.gif"></div><br>  Entonces, la tarea se redujo a calcular el valor del coeficiente del polinomio.  Si observa estos cuadrados blancos, puede comprender que se trata de la cantidad de formas de elegir 3 de 15. <img src="https://habrastorage.org/getpro/habr/post_images/5d4/344/bdb/5d4344bdb66112361fa655447baff0a3.png">  = 455. <br><br>  En el caso general, para <i>n</i> es igual a <img src="https://habrastorage.org/getpro/habr/post_images/f0d/252/47d/f0d25247d7defed1af6417ed76660ba6.png">  .  Pero debido a la simetr√≠a del espejo, de hecho, son la mitad;  si la cantidad es impar, luego dividiendo por dos, redondeamos al entero m√°s cercano para incluir en √©l un patr√≥n perfectamente sim√©trico que deber√≠a existir en este conjunto, como, por ejemplo, se muestra a continuaci√≥n para el caso con 455. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/093/98d/5e609398dfe585680459774fc3b96cdc.gif"></div><br>  Aplicando esta f√≥rmula a 7 tetramino, confirmamos lo obvio: solo hay un patr√≥n para crear 7 cuadrados. <br><br>  El patr√≥n de crear 6 cuadrados se puede construir de dos maneras: dos l√≠neas rellenas (2 √ó 21 + 6 = 48) y seis l√≠neas rellenas (6 √ó 21 + 6 = 132), lo que requiere 12 y 33 tetramino.  La f√≥rmula anterior muestra que hay 84 patrones para crear 6 cuadrados, pero solo 35 de ellos se pueden construir a partir de 2 l√≠neas completas.  49 patrones requieren 6 l√≠neas.  Los n√∫meros son impares debido a los patrones sim√©tricos que se muestran a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c07/fe9/a24/c07fe9a243e3cdfe37103d4f16d01024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/8c5/91b/8a98c591b95b4fc8a533e67adead58ad.gif"></div><br>  Tambi√©n vale la pena se√±alar que aqu√≠ son posibles 2 l√≠neas, porque en contraste con el patr√≥n de crear un cuadrado que requer√≠a tetramino S y Z, se usan 6 figuras en estos patrones. <br><br>  La tabla a continuaci√≥n muestra el n√∫mero de cuadrados creados por cada tipo de patr√≥n, el n√∫mero de l√≠neas completas, el n√∫mero de tetramino utilizado y el n√∫mero de patrones. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Cuadrados creados </th><th>  Lineas completas </th><th>  Tetramino </th><th>  Patrones </th></tr><tr><td>  1 </td><td>  7 y 3 </td><td>  37 y 16 </td><td>  19 (4 y 15) </td></tr><tr><td>  2 </td><td>  6 6 </td><td>  32 </td><td>  136 </td></tr><tr><td>  3 </td><td>  5 5 </td><td>  27 </td><td>  455 </td></tr><tr><td>  4 4 </td><td>  4 4 </td><td>  22 </td><td>  715 </td></tr><tr><td>  5 5 </td><td>  3 </td><td>  17 </td><td>  462 </td></tr><tr><td>  6 6 </td><td>  2 y 6 </td><td>  12 y 33 </td><td>  84 (35 y 49) </td></tr><tr><td>  7 7 </td><td>  1 </td><td>  7 7 </td><td>  1 </td></tr></tbody></table></div><br>  Ejemplos de patrones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/9dc/055/5699dc0558af1a833b43b57defdefbf7.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/b83/682/1d1b83682d599094bcb138958706b8bf.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/510/bbb/efd510bbb099696e35b7e0b9156f35d4.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/079/bd5/d7a/079bd5d7a149568bda463270a5b3baaf.gif"></div><br><h2>  Plataformas </h2><br>  Antes de construir una l√≠nea, el algoritmo examina la l√≠nea debajo de ella.  Si la fila inferior no puede proporcionar soporte para todos los cuadrados encima de ella, entonces se necesita una plataforma temporal.  Cuando se retira la plataforma, baja una nueva l√≠nea y, debido a c√≥mo se implementa la gravedad en el Tetris original, algunos cuadrados permanecen suspendidos en el aire. <br><br>  La siguiente ilustraci√≥n muestra 10 patrones de plataforma.  La construcci√≥n de la plataforma comienza bajando el tetramino T en la parte superior de uno de los cuadrados de la √∫ltima l√≠nea generada.  Los tetraminos restantes se basan en esta primera T. Es decir, si la l√≠nea generada anterior contiene al menos 1 cuadrado, como el cuadrado rojo en la imagen a continuaci√≥n, podemos crear una plataforma plana encima para generar la siguiente l√≠nea. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/299/e1d/5b0299e1d7f2916a802a49ea11c4eb16.gif"></div><br>  En el medio de la construcci√≥n de la plataforma, la l√≠nea de fondo se completa y se elimina, dejando tres l√≠neas sobre ella.  El √∫ltimo tetramino J o L, que eliminar√° estas l√≠neas, no se inserta hasta que los patrones de creaci√≥n generen la siguiente l√≠nea de sprite en la parte superior de la plataforma.  Esta √∫ltima figura impide la creaci√≥n de cuadrados en las dos primeras y √∫ltimas l√≠neas.  Pero, como se mencion√≥ anteriormente, debido a la geometr√≠a del tetramino J, T y L utilizados en este proceso, los patrones para crear cuadrados est√°n limitados a 17 columnas internas. <br><br>  Adem√°s, de las 19 formas posibles de construir plataformas sobre Tetramino T, solo se muestran 10 arriba. <br><br><h2>  Matrices Empaquetadas </h2><br>  Como se indic√≥ anteriormente, un subconjunto de los patrones de creaci√≥n de 6 cuadrados implica borrar solo dos l√≠neas.  Todos los dem√°s patrones requieren 6 l√≠neas.  Para entender por qu√© este es el caso, considere el siguiente patr√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/9bf/3aa/3709bf3aa8fd860b3dbcc04014dfef8b.gif"></div><br>  Estos tetramino son intercambiables con tetramino J y L, y cada uno de ellos agrega 3 cuadrados adyacentes a la fila com√∫n.  Las filas a completar est√°n representadas por la matriz que se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ed/532/67a/3ed53267a1b216691289f68439470301.gif"></div><br>  Ahora todo est√° empacando el espacio vac√≠o con tetramino.  Comenzando por la izquierda, la √∫nica opci√≥n es usar la secuencia de tetramino I. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/b54/9f5/779b549f51bef09e54217790f2110eb5.gif"></div><br>  La √∫nica forma de llenar el espacio restante es usar J y O o I y L. Ambas opciones se muestran a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/08e/33a/de808e33aa8f69d807c60b798e8ed0c1.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/a24/be8/aeca24be817f0cc88dc0ef3175ada63c.gif"></div><br>  Desafortunadamente, el tetramino O y L no son compatibles con las matrices que se muestran arriba.  Este patr√≥n de 6 cuadrados requiere una matriz m√°s grande. <br><br>  Un problema similar surge en dos patrones de crear un cuadrado.  Considere la matriz a continuaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fba/ec4/6ad/fbaec46ad778d94b5844c22d35ebc4ed.gif"></div><br>  La √∫nica forma de llenar la l√≠nea inferior a la derecha es encadenar la secuencia Z. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/3e1/5b2/5e83e15b210424010966f17b2ee1b72c.gif"></div><br>  Del mismo modo, la √∫nica forma de obtener 3 cuadrados vac√≠os en la esquina inferior izquierda es tetramino S. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/297/9ae/b51/2979aeb51a67c1c0a51c7e5105890744.gif"></div><br>  En la l√≠nea media hay un cuadrado vac√≠o entre S y Z y la √∫nica forma de llenarlo es usando tetramino J, T o L, como se muestra en las siguientes figuras. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a0/364/433/2a036443351a7c1ec90fe0d534c38049.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/f88/7e8/8f3f887e84bcdbd7176b530af8757666.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3c/dc1/a0a/e3cdc1a0a243388524f4e5ffb8ac13d8.gif"></div><br>  Insertar cualquiera de estas formas divide el espacio en blanco.  El √°rea vac√≠a a la izquierda contiene 5, 6 y 7 huecos, respectivamente.  Como ninguno de estos valores es divisible por 4, es imposible continuar.  Se requiere una matriz m√°s grande para este patr√≥n cuadrado √∫nico. <br><br>  Lo mismo se aplica a otro patr√≥n para crear un cuadrado, que se muestra en la matriz a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd3/c11/c6c/fd3c11c6ce8d7e4b60a257486caef4e2.gif"></div><br>  Despu√©s de usar tetramino S y Z para llenar la mayor parte de la l√≠nea inferior, hay un espacio vac√≠o entre ellos en la l√≠nea media. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a6/e39/49c/3a6e3949c8f9f0849921a11ccf54596a.gif"></div><br>  Como se muestra en las im√°genes a continuaci√≥n, el inserto del agujero divide el espacio vac√≠o, y el √°rea vac√≠a de la izquierda contiene 9, 10 u 11 cuadrados, respectivamente;  ninguno de los n√∫meros es divisible por 4. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15d/d8b/9b2/15dd8b9b24d8054598665cbff061344e.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d6/928/f4d/6d6928f4d884b746af74059ec210b96d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c5/269/800/0c5269800d3ebdcb62e1131c03e32db0.gif"></div><br>  Pero empacar matrices no es la √∫nica forma de generar un patr√≥n de cuadrados.  Por ejemplo, eche un vistazo al creador de 4 cuadrados a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fc/22b/653/4fc22b6538117dca3baff88c595337e4.gif"></div><br>  El siguiente es un intento de representar el patr√≥n como un conjunto de tetraminos empaquetados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f5/53f/bfc/3f553fbfc96ecfbbef8f7304c80a80fe.gif"></div><br>  La √∫ltima L se omite, porque el espacio para ella se forma solo despu√©s de completar y eliminar la tercera fila. <br><br>  Pero despu√©s de una b√∫squeda exhaustiva, se descubri√≥ que esta t√©cnica no proporciona los patrones de un cuadrado antes mencionados con la capacidad de trabajar con solo 3 l√≠neas.  Adem√°s, no le permite implementar ning√∫n patr√≥n nuevo de 6 cuadrados en dos l√≠neas.  No es necesario buscar los patrones restantes fuera de las matrices empaquetadas, porque ya usan la menor cantidad posible de tetramino.  Y limit√°ndonos a las matrices empaquetadas, encontraremos todos los patrones necesarios mucho m√°s r√°pido. <br><br><h2>  B√∫squeda de patrones </h2><br>  Para simplificar la salida de datos, el algoritmo de impresora Tetris se limita a crear tetramino en el punto central superior del campo de juego, girarlo, moverlo horizontalmente y bajarlo.  Nunca tiene que mover la figura horizontalmente despu√©s de pasar cierta distancia.  Esta restricci√≥n reduce en gran medida el espacio de b√∫squeda, ya que no permite la formaci√≥n de espacios debajo de las cifras agregadas a la matriz.  Como ejemplo, veamos la siguiente matriz de 3 cuadrados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/466/4d1/250/4664d1250708c9d9daeb800eb2ac7f47.gif"></div><br>  Si arrojamos J en el centro de la matriz, como se muestra arriba, obtenemos un espacio de 2 cuadrados vac√≠os, que no se pueden llenar con las figuras posteriores.  Por lo tanto, la b√∫squeda no seguir√° este camino. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/934/866/56293486665cf1557d513f63fa700622.gif"></div><br>  Como los espacios cubiertos no est√°n permitidos, cada columna de la matriz se puede considerar como una pila de cuadrados rellenos y la altura de estas pilas describe completamente el contenido de toda la matriz.  Independientemente del n√∫mero de filas, una matriz entera unidimensional con 21 elementos ser√° suficiente para describir una matriz bidimensional. <br><br>  Cuando una figura cae en la matriz, las alturas de las pilas de las columnas correspondientes aumentan.  Para acelerar este proceso, todas las tetraminas se analizan por adelantado.  Hay 19 giros de tetramino, y la b√∫squeda considera que cada uno de ellos es una figura √∫nica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/d13/9e0/40ed139e0a5612cac1f5d074a0093d96.png"></div><br>  El tetramino J en la esquina superior izquierda de la imagen ocupa 3 columnas.  Al bajar a la matriz, las alturas de 3 pilas adyacentes aumentan en 1, 1 y 2 casillas, respectivamente.  Pero antes de que se pueda bajar la figura, el perfil inferior de la figura debe corresponder al perfil superior de las pilas respectivas.  Si este J estuviera en el piso del campo de juego, debajo de cada una de estas columnas deber√≠a haber espacios de 1, 1 y 0 cuadrados vac√≠os.  Dado que los espacios libres est√°n prohibidos, las alturas relativas de 3 pilas tendr√°n que coincidir completamente con el patr√≥n. <br><br>  Otra consecuencia de la falta de espacios fue que cuando las figuras caen en la matriz, las filas se llenan de abajo hacia arriba.  No es posible llenar una fila en el medio de una matriz antes o simult√°neamente no completar todas las filas debajo de ella.  En el proceso de llenar la matriz, su l√≠mite inferior se mueve realmente hacia arriba.  Por lo tanto, una pila de columnas de matriz puede proporcionar soporte solo si su altura menos el n√∫mero de filas completadas es mayor que 0. Cuando se agrega una forma a la matriz, al menos una de las columnas correspondientes debe proporcionar soporte. <br><br>  La b√∫squeda almacena una segunda matriz unidimensional que contiene el n√∫mero de cuadrados rellenos en cada fila.  La J anterior contiene en las l√≠neas correspondientes 3 y 1 un cuadrado.  Cuando lo inserta en la matriz, estos valores se agregan a los elementos correspondientes de la matriz.  El n√∫mero de l√≠neas completadas es el n√∫mero de elementos con un valor de 21. <br><br>  Como se indic√≥ en la secci√≥n anterior, si la figura agregada divide la matriz, entonces los tama√±os de las √°reas resultantes deben dividirse entre 4. Por ejemplo, en la imagen a continuaci√≥n, al agregar I crea 2 √°reas, cada una de las cuales contiene 46 cuadrados vac√≠os.  Dado que 46 no es divisible por 4, ya no hay forma de completar el resto de la matriz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/c1e/91a/c0dc1e91a707d5b2fea279dd5c370ec4.gif"></div><br>  La separaci√≥n aparece cuando la altura de la pila es igual a la altura de la matriz.  Despu√©s de insertar la figura incrementando las alturas de las pilas respectivas, las dimensiones de todas las √°reas divididas de espacio vac√≠o se pueden determinar escaneando la matriz de alturas y sumando el espacio restante en cada pila.  Este n√∫mero se verifica y restablece cuando se detecta una divisi√≥n. <br><br>  La b√∫squeda utilizada para generar todos los patrones utiliza una construcci√≥n incremental aleatoria, un algoritmo de retroceso que verifica sistem√°ticamente todas las combinaciones en orden aleatorio.  La construcci√≥n incremental de una soluci√≥n al insertar formas al azar hace que crezca como un cristal.  La aleatoriedad proporciona una irregularidad que contiene caras rotas que sirven de base para las formas agregadas posteriores.  La mayor parte de la matriz se empaqueta aleatoriamente muy r√°pidamente, y cuando el espacio vac√≠o se vuelve escaso, el retroceso entra en juego. <br><br>  Antes de realizar la b√∫squeda, se realizan permutaciones aleatorias de 371 formas de agregar una figura a la matriz.  El pseudoc√≥digo de la funci√≥n de b√∫squeda se muestra a continuaci√≥n. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Matrix matrix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remaining)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION } attempts := attempts + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attempts &gt;= MAX_ATTEMPTS) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (     S  Z) {        S  Z <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (  ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } }          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(   ,    ) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (   ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NO_SOLUTION }</code> </pre> <br>  La matriz original pasada a la funci√≥n de b√∫squeda est√° vac√≠a, excepto por la fila inferior que contiene bloques de 3 cuadrados adyacentes.  Se transmite junto con el n√∫mero de cifras restantes que deben agregarse.  Si el <code>remaining</code> es 0, la matriz contiene la soluci√≥n y la funci√≥n vuelve.  Cada llamada recursiva incrementa el n√∫mero global de intentos de <code>attempts</code> .  Si supera <code>MAX_ATTEMPTS</code> , que tiene un valor de 1000, la b√∫squeda comienza nuevamente. <br><br>  La tercera <code>if</code> intenta agregar tetramino S o Z al fondo de la matriz si el espacio lo permite.  El significado de esto es evitar situaciones como la que se muestra a continuaci√≥n, cuando el algoritmo pasa tiempo llenando parte de la matriz, no pudiendo llenar el resto debido a la falta de soporte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/3f9/b81/36d3f9b81275718dccb5d40e70d7843b.gif"></div><br>  Gracias a la <code>if</code> forma r√°pidamente una plataforma sobre la cual construir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/aa1/ed7/1d0aa1ed7c08ed07b3f31e22ab92ea42.gif"></div><br>  Para intentar agregar una figura a la matriz, se requieren las verificaciones anteriores.  El algoritmo verifica si la figura tendr√° soporte, dadas las l√≠neas completadas.  Tambi√©n comprueba si divide entre 4 el tama√±o de cada espacio vac√≠o individual creado por la inserci√≥n de la forma. <br><br><h2>  Conversi√≥n de imagen </h2><br>  El algoritmo de impresora Tetris convierte cada l√≠nea del mapa de bits en una serie de pasadas.  Movi√©ndose de izquierda a derecha, cada pasaje de una manera "codiciosa" inserta tetramino J, T y L donde se colocan.  Por ejemplo, la imagen a continuaci√≥n muestra una fila de 16 p√≠xeles de un mapa de bits. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/4c5/b69/9c14c5b69ae9a4599ee0856a250256a8.gif"></div><br>  La imagen a continuaci√≥n muestra los 5 pases necesarios para cubrir estos 16 p√≠xeles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/f7d/760/989f7d76010dd0d7e523361148e0e323.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/920/25a/4c492025a6033a3eda85fd240118b657.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/44f/373/0f144f3734988b25dd231a1a445c52fd.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c1/e37/392/6c1e373927f4842ad379ff2b6c42b123.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/64b/222/a9a64b222baaf24ed13674bdac9b8d01.gif"></div><br>  La secuencia de formas que el algoritmo intenta insertar est√° determinada por los colores de los p√≠xeles.  Para que las formas no se superpongan, se utiliza una matriz unidimensional de valores booleanos.  Para insertar una figura, deben estar presentes 3 elementos cero en la matriz.  Tras la inserci√≥n exitosa de la figura 3, los elementos de la matriz correspondientes toman el valor 1. <br><br>  Para rastrear p√≠xeles completados entre m√∫ltiples pasadas, se utiliza una segunda matriz unidimensional de valores booleanos.  Cuando cada elemento es 1, la l√≠nea est√° completa. <br><br>  Al final de cada pasada, el convertidor de im√°genes busca en la tabla todos los patrones para crear uno o m√°s cuadrados.  A la salida, pasa el patr√≥n correspondiente con el tetramino J, T y L insertados en la parte inferior. Por ejemplo, el primer paso que se muestra arriba se muestra como el siguiente patr√≥n de creaci√≥n de 5 cuadrados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/b1b/377/c67b1b3778a37bf7008438052679942e.gif"></div><br><h2>  B√∫squeda en tiempo real </h2><br>  El convertidor de im√°genes descrito en la secci√≥n anterior es extremadamente r√°pido porque utiliza una tabla constante que contiene todos los patrones para crear cuadrados y no los busca en tiempo real.  Sin embargo, la b√∫squeda en tiempo real puede usar patrones que no est√°n en la tabla y, por lo tanto, reducir en gran medida la cantidad de tetramino necesaria para generar la imagen.  Utiliza los cuadrados creados en pasajes anteriores, utiliz√°ndolos como soportes adicionales.  Por ejemplo, como se mencion√≥ anteriormente, el siguiente patr√≥n para crear un cuadrado requiere 7 l√≠neas completas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br>  Pero un cuadrado rojo creado en el pasaje anterior en la esquina inferior izquierda de la imagen a continuaci√≥n proporciona soporte adicional, reduciendo el n√∫mero de l√≠neas rellenas a 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/d3e/271/dfad3e271c5623daedc462821b82b8af.gif"></div><br>  Adem√°s, una b√∫squeda en tiempo real puede cubrir 3 p√≠xeles adyacentes del mismo color volteando tetramino J, T o L. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/e09/776/a31e097766437cb13ebde1e35ee66453.gif"></div><br>  De hecho, puede combinar tetramino invertido e invertido, cubriendo una gran cantidad de p√≠xeles en una pasada.  Por ejemplo, los 5 pases anteriores necesarios para cubrir 16 p√≠xeles se pueden reducir al pase √∫nico que se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/653/c31/64c653c31d38daeef85189e3b2eacaa8.gif"></div><br>  Para obtener este patr√≥n, el convertidor de im√°genes comienza empacando ansiosamente tetramino J, T y L. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/e98/67e/e7ae9867e1419492f6f19f6816d18f04.gif"></div><br>  Luego, intenta con entusiasmo agregar las versiones sin girar, y en este caso se las arregla para agregar otra J. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/4f3/1d4/ba24f31d49baa855fc449c3cf98f09ca.gif"></div><br>  En principio, una tabla de b√∫squeda precalculada tambi√©n se puede utilizar en este proceso, pero el gran tama√±o de dicha tabla la hace inaplicable en la pr√°ctica. <br><br>  En este ejemplo, se agregan 8 cuadrados en una fila sobre la fila que se crear√° a la fila inferior de la matriz vac√≠a.  Para <i>n</i> cuadrados en un campo de juego de 21 cuadrados de ancho, la altura de la matriz <i>h</i> es el n√∫mero entero positivo m√°s peque√±o, de modo que <i>21h - n</i> es divisible por 4. En este caso, se requiere una matriz de altura 4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/c2e/d2b/b2ac2ed2bc3a422d0d94fff2b10bf9e0.gif"></div><br>  La b√∫squeda en tiempo real funciona exactamente de la misma manera que el algoritmo de b√∫squeda descrito anteriormente, pero tiene mejoras menores.  Como antes, la pila de columnas de la matriz proporciona soporte solo si la altura de la columna menos el n√∫mero de filas completadas es mayor que cero.  Cuando la diferencia es cero, la pila de columnas no debe proporcionar soporte.  Sin embargo, en esta versi√≥n, si es igual a cero, verifica los cuadrados en la l√≠nea creada generada por los pases anteriores.  Es decir, cualquier cuadrado en la fila debajo de la fila inferior de la matriz proporciona soporte para columnas vac√≠as. <br><br>  Adem√°s, dado que la b√∫squeda se realiza en tiempo real, no ser√° pr√°ctico hacerla exhaustiva.  Si no encuentra una soluci√≥n despu√©s de un n√∫mero determinado de intentos, agrega 4 filas m√°s en la parte superior de la matriz y luego lo intenta nuevamente.  Despu√©s de eso, si a√∫n no pudo encontrar una soluci√≥n despu√©s de un n√∫mero dado de intentos, en el pasaje actual regresa al m√©todo con tablas de b√∫squeda precalculadas y conversi√≥n de im√°genes descritas en la secci√≥n anterior del art√≠culo. <br><br><h2>  Imprimir </h2><br>  Para imprimir, debe seguir las instrucciones que muestra el convertidor de im√°genes en el campo de juego de Tetris.  La impresora crea un tetramino espec√≠fico en el punto central superior del campo de juego en una orientaci√≥n est√°ndar.  Luego la impresora lo gira, lo mueve horizontalmente y lo baja.  Este proceso se muestra en el video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PJkHwulsac4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  C√≥digo fuente </h2><br>  El c√≥digo fuente para el proyecto Java 7 est√° disponible <a href="">aqu√≠</a> . <br><br>  Los algoritmos de b√∫squeda para tablas preparadas y en tiempo real se encuentran en los paquetes <code>search.precomputed</code> y <code>search.realtime</code> .  Utilizan algunas clases comunes ubicadas en el paquete de <code>search</code> .  Los resultados de una b√∫squeda calculada previamente se almacenan en el paquete de <code>patterns</code> como una secuencia de archivos de texto.  Los archivos de texto almacenan matrices empaquetadas como caracteres ASCII, comenzando con <code>A</code>  Por ejemplo, las primeras 3 matrices en <code>emitters1.txt</code> (el conjunto de patrones para crear un cuadrado) se ven as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/yo/mo/lvyomov6ld5rle3bqj1jnjegic4.png"></div><br>  Como se indica repetidamente en el art√≠culo, 3 s√≠mbolos <code>A</code> adyacentes en las matrices anteriores se pueden reemplazar con tetramino J, T o L. Los s√≠mbolos <code>B</code> , <code>C</code> , <code>D</code> y as√≠ sucesivamente representan la secuencia de tetramino que necesita crear. <br><br>  La clase <code>imageconverter.ImageConverter</code> contiene el m√©todo <code>main</code> , que recibe un √∫nico argumento de l√≠nea de comando: el nombre del archivo sprite de imagen.  Una imagen no puede tener m√°s de 17 √ó 32 p√≠xeles y no puede contener m√°s de 3 colores opacos.  Todos los dem√°s p√≠xeles deben ser transparentes. <br><br>  Curiosamente, en los videojuegos antiguos, los desarrolladores a menudo usaban el fondo para obtener m√°s color.  Por ejemplo, alumnos y boca de Bubble from Bubble bobble, alumnos de Donkey Kong de Donkey Kong y cejas con el lunar de Miss Pakman de Ms.  Pac-Man es en realidad transparente.  El negro se obtiene de un fondo s√≥lido. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fe/67d/330/3fe67d330fce92bff0b4595902e5f5bb.png"></div><br>  El fondo del campo de juego de Tetris se puede utilizar de manera similar. <br><br>  <code>ImageConverter</code> resultado de <code>ImageConverter</code> se parece a este fragmento: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rs/vt/ms/rsvtmsq6olz9bm1huiqbqgbouj4.png"></div><br>  Los 3 valores hexadecimales en la primera l√≠nea son 3 colores opacos extra√≠dos del archivo de imagen de sprite.  Corresponden a los colores de tetramino J, T y L. Los colores de otros tetramino no afectan la imagen.  Los bloques restantes son patrones empaquetados ejecutados en el campo de juego (para los caracteres despu√©s de <code>Z</code> y hasta a <code>a</code> vea la <a href="">tabla de caracteres ASCII</a> ).  Los bloques amarillos resaltados forman la plataforma.  El primer bloque agrega la plataforma, el segundo la elimina. <br><br>  La clase <code>printer.Printer</code> recibe un archivo de texto en este formato y genera un archivo de imagen al jugar Tetris. <br><br>  El algoritmo de la impresora utilizado para generar un video parecido a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n NES de Tetris</a> define cada tipo de tetramino en cada bloque de un archivo de texto.  Luego se mueve en el orden opuesto desde el punto de partida y la orientaci√≥n inicial hacia el √°ngulo de rotaci√≥n y las coordenadas de la reducci√≥n de la figura indicada en el archivo.  Nota: debido a la velocidad extremadamente alta de las figuras que caen, es imposible ir m√°s all√° del nivel 30 en la versi√≥n NES real de Tetris.  Se supone que la impresora transmite todos sus comandos al campo de juego lo suficientemente r√°pido.  para compensar esto. <br><br>  Para regenerar archivos de patrones, use <code>search.precomputed.PatternSearcher</code> .  Se puede personalizar cambiando las constantes al comienzo del archivo de c√≥digo fuente. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_WIDTH = <span class="hljs-number"><span class="hljs-number">21</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_HEIGHT = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EMITTED_SQUARES = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RANDOM_SETS = <span class="hljs-number"><span class="hljs-number">100000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX_ATTEMPTS = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br>  <code>RANDOM_SETS</code> es el n√∫mero de permutaciones aleatorias de 371 formas de agregar una figura a la matriz.  Cuando se establece en <code>100000</code> , lleva varios segundos inicializar las permutaciones al inicio.  Adem√°s, su almacenamiento requiere m√°s de un gigabyte de memoria. <br><br>  <code>MAX_ATTEMPTS</code> controla el tiempo de ejecuci√≥n de una b√∫squeda.  Un valor relativamente peque√±o de <code>1000</code> permite que la b√∫squeda descarte r√°pidamente los comienzos aleatorios que no se muestran bien.  Sin embargo, para demostrar que para un tama√±o de matriz espec√≠fico y el n√∫mero de cuadrados creados no hay soluci√≥n, es necesario explorar completamente todo el espacio de b√∫squeda.  Para hacer esto, puede establecer <code>MAX_ATTEMPTS</code> en <code>Integer.MAX_VALUE</code> . <br><br>  Constantes similares se encuentran en <code>search.realtime.RealtimeSearcher</code> , que utiliza el convertidor de im√°genes.  Como se mencion√≥ anteriormente, un valor <code>RANDOM_SETS</code> grande requiere un aumento en la memoria m√°xima y conduce a un inicio m√°s largo.  <code>MAX_RETRIES</code> controla el n√∫mero de intentos, despu√©s de los cuales la b√∫squeda en tiempo real se rinde y vuelve a la b√∫squeda con una tabla calculada previamente. <br><br>  Tenga en cuenta que ambos algoritmos de b√∫squeda utilizan el 100% de la CPU, creando muchos subprocesos paralelos que tienen el mismo tama√±o que la cantidad de procesadores disponibles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/8b9/bd5/c2d8b9bd50fd64a3a7e739d51201c880.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474848/">https://habr.com/ru/post/474848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474838/index.html">SIBUR Challenge 2019 - Competencia de an√°lisis de datos industriales</a></li>
<li><a href="../474840/index.html">¬øQu√© estudian en la especialidad de Data Science en universidades extranjeras?</a></li>
<li><a href="../474842/index.html">Caso: servicio de coche. Desarrollo de campa√±as publicitarias e implementaci√≥n de Bitrix24</a></li>
<li><a href="../474844/index.html">Dell XPS 13 7390: una computadora port√°til muy compacta para quienes a menudo trabajan fuera de la oficina</a></li>
<li><a href="../474846/index.html">El programa de limpieza de los r√≠os del mundo de la basura.</a></li>
<li><a href="../474850/index.html">La apuesta cu√°ntica de Google en IA, y lo que significa para toda la humanidad</a></li>
<li><a href="../474852/index.html">Entorno y cierres l√©xicos en EcmaScript</a></li>
<li><a href="../474854/index.html">Desencadenar correos electr√≥nicos: c√≥mo atraer a su audiencia</a></li>
<li><a href="../474856/index.html">Estrategias de localizaci√≥n de contenido</a></li>
<li><a href="../474858/index.html">Lo que necesita saber sobre Red Hat OpenShift Service Mesh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>