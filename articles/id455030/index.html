<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄºÔ∏è üîπ üë©üèº‚Äçüè≠ Spesifikasi PHP ‚òØÔ∏è üåÆ üëê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Secara singkat tentang spesifikasi: 
 Spesifikasi adalah pola desain yang dengannya Anda dapat mencerminkan aturan logika bisnis dalam bentuk rantai o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spesifikasi PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455030/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/4f/oc/jy/4focjyd0nzj8tpdc_evzhlt4zx4.png" alt="Spesifikasi Doktrin Happyr"></div><br><p>  Secara singkat tentang spesifikasi: </p><br><blockquote>  Spesifikasi adalah pola desain yang dengannya Anda dapat mencerminkan aturan logika bisnis dalam bentuk rantai objek yang dihubungkan oleh operasi logika Boolean.  Spesifikasi memungkinkan Anda untuk menghapus duplikat, metode serupa dalam repositori dan duplikasi logika bisnis. </blockquote><p>  Hari ini ada dua <em>(jika Anda tahu proyek lain, silakan tulis di komentar)</em> proyek PHP yang sukses dan populer yang memungkinkan Anda untuk menggambarkan aturan bisnis dalam spesifikasi dan memfilter kumpulan data.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi RulerZ</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Happyr Doctrine</a> .  Kedua proyek adalah alat yang kuat dengan kelebihan dan kekurangan mereka.  Membandingkan proyek-proyek ini akan menarik seluruh artikel.  Di sini saya ingin memberi tahu Anda apa yang dibawa oleh rilis baru dalam Spesifikasi Ajaran kepada kami. </p><a name="habracut"></a><br><h1 id="kratko-o-doctrine-specification">  Secara singkat tentang Spesifikasi Ajaran </h1><br><p> <em>Mereka yang kurang lebih akrab dengan proyek, dapat dengan aman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melewati</a> bagian ini.</em> </p><br><p>  Dengan bantuan proyek ini, Anda dapat mendeskripsikan spesifikasi dalam bentuk objek, menyusunnya dari komposisi dan, dengan demikian, membuat aturan bisnis yang kompleks.  Komposisi yang dihasilkan dapat digunakan kembali secara bebas, dan digabungkan menjadi komposisi yang lebih kompleks yang mudah diuji.  Spesifikasi Ajaran digunakan untuk membangun kueri Ajaran.  Pada dasarnya, Spesifikasi Doktrin adalah tingkat abstraksi atas QueryBuilder dan Ajaran ORM Doctrine. </p><br><p>  Spesifikasi berlaku melalui Gudang Doktrin: </p><br><pre><code class="php hljs">$result = $em-&gt;getRepository(MyEntity::class)-&gt;match($spec);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Spesifikasi dapat diterapkan secara manual, tetapi tidak terlalu nyaman dan, dalam jangka panjang, tidak ada gunanya.</b> <div class="spoiler_text"><pre> <code class="php hljs">$spec = ... $alias = <span class="hljs-string"><span class="hljs-string">'e'</span></span>; $qb = $em-&gt;getRepository(MyEntity::class)-&gt;createQueryBuilder($alias); $spec-&gt;modify($qb, $alias); $filter = (string) $spec-&gt;getFilter($qb, $alias); $qb-&gt;andWhere($filter); $result = $qb-&gt;getQuery()-&gt;execute();</code> </pre> </div></div><br><p>  Ada beberapa metode dalam repositori: </p><br><ul><li>  <code>match</code> - mendapatkan semua hasil yang sesuai dengan spesifikasi; </li><li>  <code>matchSingleResult</code> - setara dengan <code>Query::getSingleResult()</code> ; </li><li>  <code>matchOneOrNullResult</code> - setara dengan <code>matchSingleResult</code> , tetapi memungkinkan <code>null</code> ; </li><li>  <code>getQuery</code> - membuat QueryBuilder dengan menerapkan spesifikasi padanya dan mengembalikan objek Query darinya. </li></ul><br><p>  Baru-baru ini, metode <code>getQueryBuilder</code> telah ditambahkan ke mereka, yang menciptakan QueryBuilder dan, menerapkan spesifikasi padanya, mengembalikannya. </p><br><p>  Proyek mengidentifikasi beberapa jenis spesifikasi: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi Logis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi Filter</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengubah kueri</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengubah Hasil</a> </li></ul><br><h2 id="logicheskie-specifikacii">  Spesifikasi Logis </h2><br><p>  Spesifikasi <code>andX</code> dan <code>orX</code> juga berfungsi sebagai kumpulan spesifikasi. </p><br><ul><li> <code>Spec::andX()</code> </li> <li> <code>Spec::orX()</code> </li> <li> <code>Spec::not()</code> </li> </ul><br><p>  Merupakan kebiasaan untuk menginstal objek spesifikasi perpustakaan melalui fasad <code>Spec</code> , tetapi ini tidak perlu.  Anda dapat secara eksplisit instantiate objek spesifikasi: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AndX(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrX(): <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Not();</code> </pre> <br><h2 id="filtruyuschie-specifikacii">  Spesifikasi Filter </h2><br><p>  Spesifikasi penyaringan, pada kenyataannya, membuat aturan logika bisnis dan digunakan dalam permintaan <code>WHERE</code> .  Ini termasuk operasi perbandingan: </p><br><ul><li>  <code>isNull</code> - SQL <code>IS NULL</code> setara </li><li>  <code>isNotNull</code> - SQL <code>IS NOT NULL</code> setara </li><li>  <code>in</code> - setara dengan <code>IN ()</code> </li><li>  <code>notIn</code> <code>NOT IN ()</code> - <code>NOT IN ()</code> </li><li>  <code>eq</code> - uji kesetaraan <code>=</code> </li><li>  <code>neq</code> - periksa ketimpangan <code>!=</code> </li><li>  <code>lt</code> - kurang dari <code>&lt;</code> </li><li>  <code>lte</code> - kurang dari atau sama dengan <code>&lt;=</code> </li><li>  <code>gt</code> - lebih dari <code>&gt;</code> </li><li>  <code>gte</code> - lebih besar dari atau sama dengan <code>&gt;=</code> </li><li>  <code>like</code> - SQL <code>LIKE</code> setara </li><li>  <code>instanceOfX</code> - setara dengan DQL <code>INSTANCE OF</code> </li></ul><br><p>  Contoh menggunakan spesifikasi pemfilteran: </p><br><pre> <code class="php hljs">$spec = Spec::andX( Spec::eq(<span class="hljs-string"><span class="hljs-string">'ended'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), Spec::orX( Spec::lt(<span class="hljs-string"><span class="hljs-string">'endDate'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTime()), Spec::andX( Spec::isNull(<span class="hljs-string"><span class="hljs-string">'endDate'</span></span>), Spec::lt(<span class="hljs-string"><span class="hljs-string">'startDate'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTime(<span class="hljs-string"><span class="hljs-string">'-4 weeks'</span></span>)) ) ) );</code> </pre> <br><h2 id="modifikatory-zaprosa">  Pengubah kueri </h2><br><p>  Pengubah kueri tidak ada hubungannya dengan logika bisnis dan aturan bisnis.  Sesuai namanya, mereka hanya memodifikasi QueryBuilder.  Nama dan tujuan pengubah standar sesuai dengan metode serupa di QueryBuilder. </p><br><ul><li> <code>join</code> </li> <li> <code>leftJoin</code> </li> <li> <code>innerJoin</code> </li> <li> <code>limit</code> </li> <li> <code>offset</code> </li> <li> <code>orderBy</code> </li> <li> <code>groupBy</code> </li> <li> <code>having</code> </li> </ul><br><p>  Saya ingin mencatat pengubah <code>slice</code> secara terpisah.  Ini menggabungkan <code>limit</code> fungsi dan <code>offset</code> dan menghitung offset berdasarkan ukuran slice dan nomor seri.  Dalam implementasi pengubah ini, kami tidak setuju dengan penulis proyek.  Membuat pengubah, saya mengejar tujuan menyederhanakan konfigurasi spesifikasi selama pagination.  Dalam konteks ini, halaman pertama dengan nomor seri 1 seharusnya setara dengan irisan pertama dengan nomor seri 1. Tetapi penulis proyek menganggapnya tepat untuk memulai hitung mundur dalam gaya pemrograman, yaitu, dari 0. Oleh karena itu, perlu diingat bahwa jika Anda memerlukan irisan pertama, Anda perlu menentukan 0 sebagai nomor seri. </p><br><h2 id="modifikatory-rezultata">  Pengubah Hasil </h2><br><p>  Pengubah hasil ada sedikit terpisah dari spesifikasi.  Itu berlaku untuk Pertanyaan Ajaran.  Pengubah berikut mengontrol hidrasi data ( <code>Query::setHydrationMode()</code> ): </p><br><ul><li> <code>asArray</code> </li> <li> <code>asSingleScalar</code> </li> <li> <code>asScalar</code> </li> </ul><br><p>  Pengubah <code>cache</code> mengontrol caching hasil kueri. </p><br><p>  Kita juga harus menyebutkan <code>roundDateTimeParams</code> modifier.  Ini membantu menyelesaikan masalah caching ketika Anda perlu bekerja dengan aturan bisnis yang mengharuskan membandingkan beberapa nilai dengan waktu saat ini.  Ini adalah aturan bisnis normal, tetapi karena kenyataan bahwa waktu tidak konstan, caching selama lebih dari satu detik tidak akan bekerja untuk Anda.  Pengubah <code>roundDateTimeParams</code> dirancang untuk mengatasi masalah ini.  Itu melewati semua parameter permintaan, mencari tanggal di dalamnya dan membulatkannya ke nilai yang ditentukan, yang memberi kita nilai tanggal yang selalu kelipatan satu nilai dan kami tidak akan mendapatkan tanggal di masa mendatang.  Artinya, jika kami ingin men-cache permintaan selama 10 menit, kami menggunakan <code>Spec::cache(600)</code> dan <code>Spec::roundDateTimeParams(600)</code> .  Awalnya, diusulkan untuk menggabungkan kedua pengubah ini untuk kenyamanan, tetapi diputuskan untuk memisahkan mereka untuk SRP. </p><br><h1 id="vstroennye-specifikacii">  Spesifikasi Tertanam </h1><br><p>  Spesifikasi Happyr Doctrine memiliki antarmuka terpisah untuk spesifikasi yang menggabungkan filter dan pengubah permintaan.  Satu-satunya spesifikasi yang ditentukan adalah <code>countOf</code> yang memungkinkan Anda untuk mendapatkan jumlah entitas yang sesuai dengan spesifikasi tersebut.  Untuk membuat spesifikasi Anda sendiri, biasanya untuk memperluas kelas <code>BaseSpecification</code> abstrak. </p><br><h1 id="novovvedeniya">  Inovasi </h1><br><p>  Metode baru telah ditambahkan ke repositori: </p><br><ul><li>  <code>matchSingleScalarResult</code> - setara dengan <code>Query::getSingleScalarResult()</code> ; </li><li>  <code>matchScalarResult</code> - setara dengan <code>Query::getScalarResult()</code> ; </li><li>  <code>iterate</code> adalah setara dengan <code>Query::iterate()</code> . </li></ul><br><p>  Spesifikasi <code>MemberOfX</code> - DQL yang setara dengan <code>MEMBER OF</code> dan pengubah query <code>indexBy</code> - setara dengan <code>QueryBuilder::indexBy()</code> . </p><br><h2 id="operandy">  Operan </h2><br><p>  Rilis baru ini memperkenalkan konsep <strong>Operand</strong> .  Semua kondisi dalam filter terdiri dari operan kiri dan kanan dan operator di antaranya. </p><br><pre> <code class="plaintext hljs">&lt;left_operand&gt; &lt;operator&gt; &lt;right_operand&gt;</code> </pre> <br><p>  Dalam versi sebelumnya, operan kiri hanya bisa menjadi bidang entitas, dan operan kanan hanya bisa menjadi nilai.  Ini adalah mekanisme sederhana dan efektif yang cukup untuk sebagian besar tugas.  Pada saat yang sama, ia memberlakukan batasan tertentu: </p><br><ul><li>  Tidak dapat menggunakan fungsi; </li><li>  Tidak dapat menggunakan alias untuk bidang; </li><li>  Tidak mungkin membandingkan dua bidang; </li><li>  Tidak mungkin membandingkan dua nilai; </li><li>  Tidak dapat menggunakan operasi aritmatika; </li><li>  Tidak dapat menentukan tipe data untuk nilai. </li></ul><br><p>  Dalam versi baru, objek operan diteruskan ke filter dalam argumen dan transformasi mereka dalam DQL didelegasikan ke operan itu sendiri.  Ini membuka banyak kemungkinan dan membuat filter lebih mudah. </p><br><h3 id="pole-i-znachenie">  Bidang dan nilai </h3><br><p>  Untuk mempertahankan kompatibilitas ke belakang, argumen pertama dalam filter dikonversi ke operan bidang jika bukan operan, dan argumen terakhir juga dikonversi ke operan nilai.  Karena itu, Anda seharusnya tidak memiliki masalah dalam memperbarui. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: e.day &gt; :day Spec::gt('day', $day); // or Spec::gt(Spec::field('day'), $day); // or Spec::gt(Spec::field('day', $dqlAlias), $day);</span></span></code> </pre> <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: e.day &gt; :day Spec::gt('day', $day); // or Spec::gt('day', Spec::value($day)); // or Spec::gt('day', Spec::value($day, Type::DATE));</span></span></code> </pre> <br><p>  Anda dapat membandingkan 2 bidang: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: e.price_current &lt; e.price_old Spec::lt(Spec::field('price_current'), Spec::field('price_old'));</span></span></code> </pre> <br><p>  Anda dapat membandingkan 2 bidang entitas yang berbeda: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: a.email = u.email Spec::eq(Spec::field('email', 'a'), Spec::field('email', 'u'));</span></span></code> </pre> <br><h3 id="arifmeticheskie-operacii">  Operasi aritmatika </h3><br><p>  Dukungan tambahan untuk operasi aritmatika standar <code>-</code> , <code>+</code> , <code>*</code> , <code>/</code> , <code>%</code> .  Sebagai contoh, perhatikan perhitungan poin pengguna: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: e.posts_count + e.likes_count &gt; :user_score Spec::gt( Spec::add(Spec::field('posts_count'), Spec::field('likes_count')), $user_score );</span></span></code> </pre> <br><p>  Operasi aritmatika dapat disarangkan satu dengan yang lain: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: ((e.price_old - e.price_current) / (e.price_current / 100)) &gt; :discount Spec::gt( Spec::div( Spec::sub(Spec::field('price_old'), Spec::field('price_current')), Spec::div(Spec::field('price_current'), Spec::value(100)) ), Spec::value($discount) );</span></span></code> </pre> <br><h3 id="funkcii">  Fungsi </h3><br><p>  Rilis baru menambahkan operan dengan fungsi.  Mereka dapat digunakan sebagai metode statis dari kelas <code>Spec</code> , atau melalui metode <code>Spec::fun()</code> . </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: size(e.products) &gt; 2 Spec::gt(Spec::size('products'), 2); // or Spec::gt(Spec::fun('size', 'products'), 2); // or Spec::gt(Spec::fun('size', Spec::field('products')), 2);</span></span></code> </pre> <br><p>  Fungsi dapat bersarang satu sama lain: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: trim(lower(e.email)) = :email Spec::eq(Spec::trim(Spec::lower('email')), trim(strtolower($email))); // or Spec::eq( Spec::fun('trim', Spec::fun('lower', Spec::field('email'))), trim(strtolower($email)) );</span></span></code> </pre> <br><p>  Argumen untuk fungsi dapat dikirimkan sebagai argumen terpisah, atau dengan meneruskannya dalam array: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: DATE_DIFF(e.create_at, :date) Spec::DATE_DIFF('create_at', $date); // or Spec::DATE_DIFF(['create_at', $date]); // or Spec::fun('DATE_DIFF', 'create_at', $date); // or Spec::fun('DATE_DIFF', ['create_at', $date]);</span></span></code> </pre> <br><h2 id="upravlenie-vyborkoy">  Manajemen pengambilan sampel </h2><br><p>  Terkadang Anda perlu mengelola daftar nilai pengembalian.  Sebagai contoh: </p><br><ul><li>  Tambahkan entitas lain ke hasilnya agar tidak membuat subqueries untuk mendapatkan tautan; </li><li>  Untuk mengembalikan bukan seluruh entitas, tetapi hanya satu set bidang yang terpisah; </li><li>  Gunakan alias; </li><li>  Gunakan alias tersembunyi dengan syarat untuk menyortir (itu membutuhkan Doktrin, tetapi mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berjanji untuk memperbaikinya</a> ). </li></ul><br><p>  Sebelum versi 0.8.0, tugas ini membutuhkan pembuatan spesifikasi untuk kebutuhan ini.  Dimulai dengan versi 0.8.0, Anda dapat menggunakan metode <code>getQueryBuilder()</code> dan mengelola seleksi melalui antarmuka QueryBuilder. </p><br><p>  Rilis baru 1.0.0 menambahkan <code>select</code> dan <code>addSelect</code> permintaan.  <code>select</code> sepenuhnya menggantikan daftar nilai yang dapat dipilih, dan <code>addSelect</code> menambahkan nilai baru ke daftar.  Sebagai nilai, Anda bisa menggunakan objek yang mengimplementasikan antarmuka <code>Selection</code> atau filter.  Dengan demikian, Anda dapat memperluas kemampuan perpustakaan agar sesuai dengan kebutuhan Anda.  Pertimbangkan peluang yang sudah ada. </p><br><p>  Anda dapat memilih satu bidang: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: SELECT e.email FROM ... Spec::select('email') // or Spec::select(Spec::field('email'))</span></span></code> </pre> <br><p>  Anda dapat menambahkan satu bidang ke pilihan: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: SELECT e, u.email FROM ... Spec::addSelect(Spec::field('email', $dqlAlias))</span></span></code> </pre> <br><p>  Anda dapat memilih beberapa bidang: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: SELECT e.title, e.cover, u.name, u.avatar FROM ... Spec::andX( Spec::select('title', 'cover'), Spec::addSelect(Spec::field('name', $dqlAlias), Spec::field('avatar', $dqlAlias)) )</span></span></code> </pre> <br><p>  Anda dapat menambahkan entitas ke nilai yang dikembalikan: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: SELECT e, u FROM ... Spec::addSelect(Spec::selectEntity($dqlAlias))</span></span></code> </pre> <br><p>  Anda dapat menggunakan alias untuk bidang yang dapat dipilih: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: SELECT e.name AS author FROM ... Spec::select(Spec::selectAs(Spec::field('name'), 'author'))</span></span></code> </pre> <br><p>  Anda dapat menambahkan bidang tersembunyi ke pilihan: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: SELECT e, u.name AS HIDDEN author FROM ... Spec::addSelect(Spec::selectHiddenAs(Spec::field('email', $dqlAlias), 'author')))</span></span></code> </pre> <br><p>  Anda dapat menggunakan ekspresi, misalnya, untuk mendapatkan diskon pada suatu produk: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: SELECT (e.price_old is not null and e.price_current &lt; e.price_old) AS discount FROM ... Spec::select(Spec::selectAs( Spec::andX( Spec::isNotNull('price_old'), Spec::lt(Spec::field('price_current'), Spec::field('price_old')) ), 'discount' ))</span></span></code> </pre> <br><p>  Anda dapat menggunakan alias dalam spesifikasi: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// DQL: SELECT e.price_current AS price FROM ... WHERE price &lt; :low_cost_limit Spec::andX( Spec::select(Spec::selectAs('price_current', 'price')), Spec::lt(Spec::alias('price'), $low_cost_limit) )</span></span></code> </pre> <br><p>  Pada dasarnya itu saja.  Di sinilah inovasi berakhir.  Rilis baru telah membawa banyak fitur menarik dan bermanfaat.  Saya harap mereka membuat Anda tertarik. </p><br><p>  <em>PS: Saya bisa menggunakan contoh untuk menganalisis penggunaan spesifikasi dan menunjukkan kelebihan dan kekurangan dari penggunaannya.</em>  <em>Jika ini menarik bagi Anda, tulis di komentar atau di PM.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455030/">https://habr.com/ru/post/id455030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455012/index.html">FAQ Intersepsi Seluler: Apa itu Interceptors / SCAT IMSI dan Dapatkah Saya Melindungi Mereka?</a></li>
<li><a href="../id455016/index.html">Kami membuat situs yang paling sulit diakses dengan peringkat ideal Mercusuar</a></li>
<li><a href="../id455020/index.html">Keuntungan dan Kerugian Menggunakan Flutter untuk Pengembangan Seluler</a></li>
<li><a href="../id455022/index.html">Bagaimana menjalankan Scrum secara efisien pada tahun 2019? Panduan cepat untuk pemula</a></li>
<li><a href="../id455024/index.html">5 prinsip akal sehat untuk membuat aplikasi cloud-asli</a></li>
<li><a href="../id455038/index.html">Tentang bagaimana Plesk mengunjungi KubeCon</a></li>
<li><a href="../id455040/index.html">Meningkatkan kerja Wi-Fi. Bagian 2. Fitur Peralatan</a></li>
<li><a href="../id455042/index.html">Kotlin DSL, Jadwal dan tes UI yang elegan di Android</a></li>
<li><a href="../id455048/index.html">Implementasi teknis dari metode potensi termal untuk analisis wilayah</a></li>
<li><a href="../id455050/index.html">Menggunakan Database Oracle untuk Analisis Pasar Teknis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>