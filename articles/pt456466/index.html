<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥊 🕴🏾 🧑🏾‍🤝‍🧑🏾 Genéricos PHP hoje (bem, quase) 👩🏽‍🤝‍👨🏻 👲🏾 ⛴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se você perguntar aos desenvolvedores de PHP que tipo de oportunidade eles desejam ver no PHP, a maioria chamará genéricos. 


 Suporte genérico no ní...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Genéricos PHP hoje (bem, quase)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456466/"><p>  Se você perguntar aos desenvolvedores de PHP que tipo de oportunidade eles desejam ver no PHP, a maioria chamará genéricos. </p><br><p>  Suporte genérico no nível do idioma seria a melhor solução.  Mas, percebê-los é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">difícil</a> .  Esperamos que um dia o suporte nativo se torne parte do idioma, mas provavelmente levará vários anos para esperar. </p><br><p>  Este artigo mostrará como, usando as ferramentas existentes, em alguns casos com modificações mínimas, podemos obter o poder dos genéricos no PHP agora. </p><a name="habracut"></a><br><blockquote>  De um tradutor: uso deliberadamente papel vegetal dos "genéricos" ingleses, porque  Nunca ouvi na comunicação que alguém a chamasse de "programação generalizada". </blockquote><br><h2 id="soderzhanie">  Conteúdo: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que são genéricos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como implementar genéricos sem suporte ao idioma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Padronização</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suporte de ferramenta</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suporte de código de terceiros</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Passos adicionais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Limitações</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Por que você não adiciona genéricos à língua?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">E se eu não precisar de genéricos?</a> </li></ul><br><h2 id="anchorwhat-are-genericsanchorchto-takoe-dzheneriki"><a name="what-are-generics"></a>  O que são genéricos </h2><br><p>  Esta seção cobre uma breve introdução aos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">genéricos</a> . </p><br><p>  Lendo links: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">RFC</a> para adicionar genéricos PHP </li><li>  Suporte genérico em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Phan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Modelos</a> e genéricos de salmo </li></ul><br><h3 id="prosteyshiy-primer">  Exemplo mais simples </h3><br><p>  Como atualmente não é possível definir genéricos no nível do idioma, teremos que usar outra grande oportunidade - defini-los nos blocos de encaixe. </p><br><p>  Já estamos usando esta opção em muitos projetos.  Veja este exemplo: </p><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string[] $names * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(iterable $names)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  No código acima, fazemos o que é possível no nível do idioma.  Definimos o parâmetro <code>$names</code> como algo que poderia ser listado.  Também indicamos que a função retornará uma matriz.  O PHP lançará um <code>TypeError</code> se os tipos de parâmetro e o valor de retorno não corresponderem. </p><br><p>  Docblock melhora a compreensão do código.  <code>$names</code> devem ser cadeias de caracteres e a função deve retornar uma matriz de objetos <code>User</code> .  O próprio PHP não faz essas verificações.  Porém, IDEs como o PhpStorm entendem essa notação e alertam o desenvolvedor que o contrato adicional não foi respeitado.  Além disso, ferramentas de análise estática, como Psalm, PHPStan e Phan, podem validar a correção dos dados transferidos para e da função. </p><br><h3 id="dzheneriki-dlya-opredeleniya-klyuchey-i-znacheniy-perechislyaemyh-tipov">  Genéricos para determinar chaves e valores de tipos enumerados </h3><br><p>  Acima está o exemplo mais simples de um genérico.  Métodos mais complexos incluem a capacidade de especificar o tipo de suas chaves, juntamente com o tipo de valores.  Abaixo está uma maneira de descrever isso: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Diz aqui que a matriz retornada por <code>getUsers</code> possui chaves e valores de string do tipo <code>User</code> . </p><br><p>  Analisadores estáticos, como Psalm, PHPStan e Phan, entendem essa anotação e a levam em consideração na verificação. </p><br><p>  Considere o seguinte código: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $age)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(getUsers() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $user) { showAge($name); }</code> </pre> <br><p>  Os analisadores estáticos <code>showAge</code> um aviso na chamada <code>showAge</code> com um erro como este: O <code>Argument 1 of showAge expects int, string provided</code> . </p><br><p>  Infelizmente, no momento da redação, o PhpStorm não sabe como. </p><br><h3 id="bolee-slozhnye-dzheneriki">  Genéricos mais sofisticados </h3><br><p>  Continuamos a nos aprofundar no tópico dos genéricos.  Considere um objeto que é uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">pilha</a> : </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  A pilha pode aceitar qualquer tipo de objeto.  Mas e se quisermos restringir a pilha apenas aos objetos do tipo <code>User</code> ? </p><br><p>  Salmo e Phan suportam as seguintes anotações: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> T $item */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  O docblock é usado para transmitir informações de tipo adicionais, por exemplo: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Stack&lt;User&gt; $userStack */</span></span> $stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack(); Means that $userStack must only contain Users.</code> </pre> <br><p>  Salmo, ao analisar o seguinte código: </p><br><pre> <code class="php hljs">$userStack-&gt;push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User()); $userStack-&gt;push(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>);</code> </pre> <br><p>  Irá reclamar da linha 2 com o erro <code>Argument 1 of Stack::push expects User, string(hello) provided.</code> </p><br><p>  Atualmente, o PhpStorm não suporta esta anotação. </p><br><p>  De fato, cobrimos apenas parte das informações sobre genéricos, mas no momento isso é suficiente. </p><br><h2 id="anchorhow-to-implement-generics-without-language-level-supportanchorkak-vnedrit-dzheneriki-bez-podderzhki-yazyka"><a name="how-to-implement-generics-without-language-level-support"></a>  Como implementar genéricos sem suporte ao idioma </h2><br><p>  Você deve concluir as seguintes etapas: </p><br><ul><li>  No nível da comunidade, defina padrões genéricos em blocos de encaixe (por exemplo, novo PSR ou volte ao PSR-5) </li><li>  Adicione anotações do dockblock ao seu código </li><li>  Use IDEs que entendam essas convenções para realizar análises estáticas em tempo real e encontrar inconsistências. </li><li>  Use ferramentas de análise estática (como o Salmo) como uma das etapas do IC para detectar erros. </li><li>  Defina um método para passar informações de tipo para bibliotecas de terceiros. </li></ul><br><h2 id="anchoragreeing-on-a-standardanchorstandartizaciya"><a name="agreeing-on-a-standard"></a>  Padronização </h2><br><p>  No momento, a comunidade PHP adotou oficialmente este formato genérico (eles são suportados pela maioria das ferramentas e seu significado é claro para a maioria): </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  No entanto, temos problemas com exemplos simples como este: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  O Salmo entende e sabe qual o tipo da chave e os valores da matriz retornada. </p><br><p>  No momento da redação deste artigo, o PhpStorm não entende isso.  Usando esta entrada, sinto falta do poder da análise estática em tempo real oferecida pelo PhpStorm. </p><br><p>  Considere o código abaixo.  O PhpStorm não entende que <code>$user</code> é do tipo <code>User</code> e <code>$name</code> é do tipo string: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(getUsers() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $user) { ... }</code> </pre> <br><p>  Se eu escolhesse o Salmo como uma ferramenta de análise estática, poderia escrever o seguinte: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  O salmo entende tudo isso. </p><br><p>  PhpStorm sabe que a variável <code>$user</code> é do tipo <code>User</code> .  Mas ele ainda não entende que a chave da matriz se refere a uma string.  Phan e PHPStan não entendem as anotações específicas do salmo.  O máximo que eles entendem neste código é o mesmo que no PhpStorm: o tipo de <code>$user</code> </p><br><p>  Você poderia argumentar que o PhpStorm deveria apenas aceitar a <code>array&lt;keyType, valueType&gt;</code> acordos <code>array&lt;keyType, valueType&gt;</code> .  Eu não concordo com você, porque  Acredito que esse ditado de padrões é tarefa da língua e da comunidade, e as ferramentas devem apenas segui-los. </p><br><p>  Suponho que o contrato descrito acima será recebido calorosamente pela maioria da comunidade PHP.  Um interessado em genéricos.  No entanto, as coisas ficam muito mais complicadas quando se trata de padrões.  No momento, nem o PHPStan nem o PhpStorm suportam modelos.  Ao contrário do Salmo e Phan.  O objetivo deles é semelhante, mas se você se aprofundar, perceberá que as implementações são um pouco diferentes. </p><br><p>  Cada uma das opções apresentadas é uma espécie de compromisso. </p><br><p>  Simplificando, é necessário um acordo sobre o formato de registro genérico: </p><br><ul><li>  Eles melhoram a vida dos desenvolvedores.  Os desenvolvedores podem adicionar genéricos ao seu código e se beneficiar dele. </li><li>  Os desenvolvedores podem usar as ferramentas de que mais gostam e alternar entre elas (ferramentas) conforme necessário. </li><li>  Os fabricantes de ferramentas podem criar essas mesmas ferramentas, entendendo os benefícios para a comunidade e não temendo que algo mude ou que sejam acusados ​​de uma "abordagem incorreta". </li></ul><br><h2 id="anchortool-supportanchorpodderzhka-instrumentami"><a name="tool-support"></a>  Suporte de ferramenta </h2><br><p>  O Salmo tem toda a funcionalidade necessária para verificar os genéricos.  Phan também gosta disso. </p><br><p>  Tenho certeza de que o PhpStorm apresentará genéricos assim que a comunidade criar um contrato de formato único. </p><br><h2 id="anchorthird-party-code-supportanchorpodderzhka-storonnego-koda"><a name="third-party-code-support"></a>  Suporte de código de terceiros </h2><br><p>  A parte final do quebra-cabeça genérico é adicionar suporte para bibliotecas de terceiros. </p><br><p>  Felizmente, assim que o padrão de definição genérica aparecer, a maioria das bibliotecas o implementará.  No entanto, isso não acontecerá imediatamente.  Algumas bibliotecas são usadas, mas não têm suporte ativo.  Ao usar analisadores estáticos para validar tipos em genéricos, é importante que todas as funções que esses genéricos aceitem ou retornem sejam definidas. </p><br><p>  O que acontece se o seu projeto depende de bibliotecas de terceiros que não têm suporte genérico? </p><br><p>  Felizmente, esse problema já foi resolvido e as funções de stub são a solução.  Salmos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Phan</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">PhpStorm</a> suportam stubs. </p><br><p>  Os stubs são arquivos comuns que contêm assinaturas de funções e métodos, mas não os implementam.  Ao adicionar blocos de encaixe aos stubs, as ferramentas de análise estática obtêm as informações adicionais necessárias.  Por exemplo, se você tiver uma classe de pilha sem dicas de tipo e genéricos como este. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* some implementation */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* some implementation */</span></span> } }</code> </pre> <br><p>  Você pode criar um arquivo stub que possua métodos idênticos, mas com a adição de blocos de encaixe e sem a implementação de funções. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> T $item * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> void */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Quando o analisador estático vê a classe de pilha, recebe informações de tipo do stub, não do código real. </p><br><p>  A capacidade de simplesmente compartilhar o código de stubs (por exemplo, através do compositor) seria extremamente útil, porque  permitiria compartilhar o trabalho realizado. </p><br><h2 id="anchornext-stepsanchordalneyshie-shagi"><a name="next-steps"></a>  Passos adicionais </h2><br><p>  A comunidade precisa se afastar de acordos e estabelecer padrões. </p><br><p>  Talvez a melhor opção seja um PSR genérico? </p><br><p>  Ou talvez os criadores dos principais analisadores estáticos, PhpStorm, outros IDEs e qualquer pessoa envolvida no desenvolvimento de PHP (para controle) possam desenvolver um padrão que todos usariam. </p><br><p>  Assim que o padrão aparecer, todos poderão ajudar com a adição de genéricos às bibliotecas e projetos existentes, criando solicitações de recebimento.  E onde isso não for possível, os desenvolvedores podem escrever e compartilhar stubs. </p><br><p>  Quando tudo estiver pronto, podemos usar ferramentas como o PhpStorm para verificar os genéricos em tempo real enquanto escrevemos o código.  Podemos usar ferramentas de análise estática como parte do nosso IC como garantia de segurança. </p><br><p>  Os genéricos também podem ser implementados em PHP (bem, quase). </p><br><h2 id="anchorlimitationsanchorogranicheniya"><a name="limitations"></a>  Limitações </h2><br><p>  Existem várias limitações.  PHP é uma linguagem dinâmica que permite fazer muitas coisas "mágicas", como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">essas</a> .  Se você usa muita mágica do PHP, pode acontecer que os analisadores estáticos não consigam extrair com precisão todos os tipos no sistema.  Se algum tipo for desconhecido, as ferramentas não poderão usar os genéricos corretamente em todos os casos. </p><br><p>  No entanto, a principal aplicação dessa análise é validar sua lógica de negócios.  Se você escreve um código limpo, não deve usar muita mágica. </p><br><h2 id="anchorwhy-dont-you-just-add-generics-to-the-languageanchorpochemu-by-vam-prosto-ne-dobavit-dzheneriki-v-yazyk"><a name="why-dont-you-just-add-generics-to-the-language"></a>  Por que você não adiciona genéricos à língua? </h2><br><p>  Essa seria a melhor opção.  O PHP possui código-fonte aberto e ninguém incomoda você clonar os fontes e implementar genéricos! </p><br><h2 id="anchorwhat-if-i-dont-want-genericsanchorchto-esli-mne-ne-nuzhny-dzheneriki"><a name="what-if-i-dont-want-generics"></a>  E se eu não precisar de genéricos? </h2><br><p>  Apenas ignore todos os itens acima.  Uma das principais vantagens do PHP é que ele é flexível na escolha do nível apropriado de complexidade da implementação, dependendo do que você cria.  Com um código único, você não precisa pensar em coisas como digitar dicas.  Mas em grandes projetos vale a pena usar essas oportunidades. </p><br><blockquote>  Obrigado a todos que leram para este lugar.  Ficarei feliz em seus comentários no PM. <br><br>  <strong>UPD</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">ghost404</a> nos comentários observou que o <em>PHPStan da versão 0.12.x compreende anotações de salmos e suporta genéricos</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456466/">https://habr.com/ru/post/pt456466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456442/index.html">Admissão no programa de graduação da Universidade Estadual de São Petersburgo, com o apoio do Yandex e JetBrains</a></li>
<li><a href="../pt456446/index.html">Ceph - de "no joelho" para "produção"</a></li>
<li><a href="../pt456448/index.html">Regras para escolher uma estrutura JS</a></li>
<li><a href="../pt456450/index.html">DO-RA.Avia para monitorar a radiação cósmica na aviação</a></li>
<li><a href="../pt456452/index.html">Exemplos de código C ++ antes e depois de intervalos</a></li>
<li><a href="../pt456470/index.html">Armadilhas do Publicador de Pacotes do WSUS</a></li>
<li><a href="../pt456472/index.html">Apresentando o Go e o Mggo Framework</a></li>
<li><a href="../pt456476/index.html">Modificações da pilha Bluetooth para melhorar a qualidade do áudio em fones de ouvido sem codecs AAC, aptX ou LDAC</a></li>
<li><a href="../pt456482/index.html">Me pegue se puder. King Version</a></li>
<li><a href="../pt456486/index.html">Interface e Escolha (2014)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>