<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏽 🤖 🔰 Bagaimana kami menempatkan manajemen infrastruktur di Terraform - dan mulai hidup 🤙🏻 🍚 ↘️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami memiliki 4 akun Amazon, 9 VPC dan 30 lingkungan pengembangan paling kuat, tahapan, regresi - total lebih dari 1000 EC2 contoh dari semua warna da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami menempatkan manajemen infrastruktur di Terraform - dan mulai hidup</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/470543/"><img src="https://habrastorage.org/webt/os/gu/yk/osguyk_s9ckyitafq3rayiqhxw0.png" alt="gambar"><br>  Kami memiliki 4 akun Amazon, 9 VPC dan 30 lingkungan pengembangan paling kuat, tahapan, regresi - total lebih dari 1000 EC2 contoh dari semua warna dan nuansa.  Sejak saya mulai mengumpulkan solusi cloud untuk bisnis, saya harus menjalani hobi saya sampai akhir dan berpikir tentang cara mengotomatisasi semua ini. <br><br>  Hai  Nama saya Kirill Kazarin, saya bekerja sebagai insinyur di DINS.  Kami sedang mengembangkan solusi komunikasi bisnis berbasis cloud.  Dalam pekerjaan kami, kami secara aktif menggunakan Terraform, yang dengannya kami secara fleksibel mengelola infrastruktur kami.  Saya akan membagikan pengalaman saya dengan solusi ini. <br><br>  Artikel ini panjang, jadi siapkan teh <s>popcorn</s> dan pergi! <br><br>  Dan satu lagi nuansa - artikel ditulis berdasarkan versi 0.11, segar 0.12 banyak yang telah berubah tetapi praktik utama dan tips masih relevan.  Masalah migrasi dari 0,11 ke 0,12 layak mendapatkan artikel terpisah! <br><a name="habracut"></a><br><h3>  Apa itu Terraform? </h3><br>  <b>Terraform</b> adalah alat Hashicorp populer yang muncul pada tahun 2014. <br><br>  Utilitas ini memungkinkan Anda untuk mengelola infrastruktur cloud Anda dalam <i>Infrastruktur sebagai</i> paradigma <i>Kode</i> dalam bahasa deklaratif yang sangat ramah dan mudah dibaca.  Aplikasinya memberi Anda jenis sumber daya terpadu dan penerapan praktik kode untuk manajemen infrastruktur, yang telah lama dikembangkan oleh komunitas pengembang.  Terraform mendukung semua platform cloud modern, memungkinkan Anda mengubah infrastruktur dengan aman dan dapat diprediksi. <br><br>  Saat diluncurkan, Terraform membaca kode dan, menggunakan plug-in yang disediakan oleh penyedia layanan cloud, membawa infrastruktur Anda ke keadaan yang dijelaskan dengan melakukan panggilan API yang diperlukan. <br><br>  Proyek kami sepenuhnya terletak di Amazon, dikerahkan berdasarkan layanan AWS, dan oleh karena itu saya menulis tentang penggunaan Terraform dalam nada ini.  Secara terpisah, saya perhatikan bahwa itu dapat digunakan tidak hanya untuk Amazon.  Ini memungkinkan Anda untuk mengelola semua yang memiliki API. <br><br>  Selain itu, kami mengelola pengaturan VPC, kebijakan IAM, dan peran.  Kami mengelola tabel routing, sertifikat, ACL jaringan.  Kami mengelola pengaturan firewall aplikasi web kami, S3-bucket, antrian SQS - semua yang dapat digunakan layanan kami di Amazon.  Saya belum melihat fitur dengan Amazon yang Terraform tidak dapat menggambarkan dalam hal infrastruktur. <br><br>  Ternyata infrastrukturnya agak besar, dengan tangan Anda mudah untuk didukung.  Tetapi dengan Terraform itu mudah dan sederhana. <br><br><h3>  Terbuat dari apa Terraform </h3><br>  <b>Penyedia</b> adalah pengaya untuk bekerja dengan API suatu layanan.  Saya menghitungnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih dari 100</a> .  Diantaranya adalah penyedia untuk Amazon, Google, DigitalOcean, VMware Vsphere, Docker.  Saya bahkan menemukan penyedia di daftar resmi ini yang memungkinkan Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengelola aturan untuk Cisco ASA</a> ! <br><br>  Antara lain, Anda dapat mengontrol: <br><br><ul><li>  Dasbor, sumber data, dan peringatan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grafana</a> . </li><li>  Proyek di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitLab</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RabbitMQ</a> . </li><li>  Basis data, pengguna, dan hak di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MySQL</a> . </li></ul><br>  Dan ini hanya penyedia resmi, bahkan ada lebih banyak penyedia tidak resmi.  Selama percobaan, saya menemukan di GitHub pihak ketiga, tidak termasuk dalam penyedia daftar resmi, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memungkinkan bekerja dengan DNS dari GoDaddy</a> , serta dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber daya Proxmox</a> . <br><br>  Dalam satu proyek Terraform, Anda dapat menggunakan penyedia yang berbeda dan, dengan demikian, sumber daya dari penyedia layanan atau teknologi yang berbeda.  Misalnya, Anda dapat mengelola infrastruktur Anda di AWS, dengan DNS eksternal dari GoDaddy.  Dan besok, perusahaan Anda membeli startup yang dihosting di DO atau Azure.  Dan sementara Anda memutuskan untuk memigrasi ini ke AWS atau tidak, Anda juga dapat mendukung ini dengan alat yang sama! <br><br>  <b>Sumber daya.</b>  Ini adalah entitas cloud yang dapat Anda buat menggunakan Terraform.  Daftar, sintaks, dan properti mereka bergantung pada penyedia yang digunakan, pada kenyataannya - pada cloud yang digunakan.  Atau bukan hanya awan. <br><br>  <b>Modul</b>  Ini adalah entitas yang memungkinkan Terraform Anda untuk membuat templat konfigurasi Anda.  Dengan demikian, template memungkinkan Anda untuk membuat kode Anda lebih kecil, memungkinkan Anda untuk menggunakannya kembali.  Ya, mereka membantu bekerja dengan nyaman bersamanya. <br><br><h3>  Mengapa kami memilih Terraform </h3><br>  Bagi kami sendiri, kami mengidentifikasi 5 alasan utama.  Mungkin dari sudut pandang Anda, tidak semuanya akan tampak signifikan: <br><br><ul><li>  <b>Terraform adalah utilitas dukungan cloud beberapa <s>Agnostik Cloud</s> (terima kasih atas komentar berharga dalam komentar)</b> .  Ketika kami memilih alat ini, kami berpikir: - Dan apa yang akan terjadi jika manajemen besok atau seminggu mendatangi kami dan berkata: "Teman-teman <i>, kami pikir - jangan hanya menyebarkan ke Amazon. Kami memiliki beberapa jenis proyek, di mana kita perlu mendapatkan infrastruktur di Google Cloud. Atau di Azure - yah, Anda tidak pernah tahu</i> . "  Kami memutuskan bahwa kami ingin memiliki alat yang tidak akan terikat secara kaku dengan layanan cloud apa pun. </li><li>  <b>Sumber terbuka</b> .  Terraform adalah solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open source</a> .  Repositori proyek memiliki peringkat lebih dari 16 ribu bintang, ini adalah konfirmasi yang baik tentang reputasi proyek. <br><br>  Kami telah menemukan lebih dari sekali atau dua kali fakta bahwa dalam beberapa versi ada bug atau perilaku yang tidak terlalu dimengerti.  Memiliki repositori terbuka memungkinkan Anda untuk memastikan bahwa ini benar-benar bug, dan kami dapat menyelesaikan masalah hanya dengan memperbarui mesin atau versi plugin.  Atau ini bug, tapi "Guys, tunggu, dua hari kemudian versi baru akan dirilis dan kami akan memperbaikinya."  Atau: "Ya, ini adalah sesuatu yang tidak dapat dimengerti, aneh, mereka mengatasinya, tetapi ada yang bisa diatasi."  Sangat nyaman. </li><li>  <b>Kontrol</b> .  Terraform sebagai utilitas sepenuhnya di bawah kendali Anda.  Ini dapat diinstal pada laptop, pada server, dapat dengan mudah diintegrasikan ke dalam pipa Anda, yang dapat dilakukan berdasarkan alat apa pun.  Sebagai contoh, kami menggunakannya di GitLab CI. </li><li>  <b>Memeriksa status infrastruktur</b> .  Terraform dapat dan melakukan pemeriksaan yang baik pada kondisi infrastruktur Anda. <br><br>  Misalkan Anda mulai menggunakan Terraform di tim Anda.  Anda membuat deskripsi beberapa sumber daya di Amazon, misalnya, Grup Keamanan, menerapkannya - itu dibuat untuk Anda, semuanya baik-baik saja.  Dan di sini - bam!  Kolega Anda yang kembali dari liburan kemarin dan belum menyadari bahwa Anda telah mengatur semuanya dengan sangat indah di sini, atau bahkan seorang kolega dari departemen lain masuk dan mengubah pengaturan untuk Grup Keamanan ini dengan menggunakan pegangan. <br><br>  Dan tanpa bertemu dengannya, tanpa berbicara, atau tanpa mengasumsikan masalah tertentu nanti, Anda tidak akan pernah tahu tentang ini dalam situasi normal.  Tetapi, jika Anda menggunakan Terraform, bahkan menjalankan rencana idle pada sumber daya ini akan menunjukkan kepada Anda bahwa ada perubahan di lingkungan kerja. <br><br>  Ketika Terraform melihat kode Anda, ia secara bersamaan memanggil API penyedia cloud, menerima status objek dari itu dan membandingkan: "Dan sekarang ada hal yang sama yang saya lakukan sebelumnya, apa yang saya ingat?"  Kemudian dia membandingkannya dengan kode, melihat apa lagi yang perlu diubah.  Dan, misalnya, jika semuanya sama dalam ceritanya, dalam ingatannya, dan dalam kode Anda, tetapi ada perubahan di sana, dia akan menunjukkan kepada Anda dan menawarkan untuk mengembalikannya.  Menurut pendapat saya, properti juga sangat bagus.  Jadi, ini adalah langkah lain, secara pribadi bagi kami, untuk memastikan bahwa kami memiliki infrastruktur yang tidak dapat diubah. </li><li>  Fitur lain yang sangat penting adalah <b>modul yang</b> saya sebutkan, dan penting.  Saya akan membicarakannya nanti.  Kapan saya akan membandingkan dengan alat. </li></ul><br>  Dan juga ceri pada kue: Terraform memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar fungsi</a> bawaan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">agak besar</a> .  Fungsi-fungsi ini, terlepas dari bahasa deklaratif, memungkinkan kami untuk mengimplementasikan beberapa, tidak untuk mengatakan program, tetapi logika. <br><br>  Misalnya, beberapa kalkulasi otomatis, garis terbagi, casting ke huruf kecil dan besar, menghapus karakter dari baris ini.  Kami cukup aktif menggunakannya.  Mereka membuat hidup jauh lebih mudah, terutama ketika Anda menulis modul yang nantinya akan digunakan kembali di lingkungan yang berbeda. <br><br><h3>  Terraform vs CloudFormation </h3><br>  Jaringan sering membandingkan Terraform dengan CloudFormation.  Kami juga menanyakan pertanyaan ini ketika memilihnya.  Dan inilah hasil perbandingan kami. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Perbandingan </th><th>  Bentuk Terra </th><th>  Cloudformation </th></tr><tr><td>  Dukungan cloud berganda </td><td>  Melalui penggunaan berbagai penyedia, plug-in dapat berfungsi dengan penyedia cloud besar apa pun. <br></td><td>  Tertempel kuat di Amazon. </td></tr><tr><td>  Ubah pelacakan </td><td>  Jika Anda memiliki perubahan <br>  bukan dalam kode TF, tetapi pada sumber daya yang ia buat, TF akan dapat mendeteksi ini dan memungkinkan Anda untuk memperbaiki situasi <br></td><td>  Fungsi serupa muncul <br>  hanya pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bulan November 2018</a> . <br></td></tr><tr><td>  Ketentuan </td><td>  Tidak ada dukungan untuk kondisi (hanya <br>  dalam bentuk operator ternary). </td><td>  Ketentuan didukung. </td></tr><tr><td>  Penyimpanan <br>  menyatakan </td><td>  Memungkinkan Anda memilih beberapa jenis backend, misalnya, secara lokal <br>  pada mesin Anda (ini adalah perilaku default), pada berbagi file, <br>  dalam S3 dan di tempat lain. <br><br>  Ini kadang-kadang berguna karena tfstate Terraform disajikan sebagai file teks besar dengan struktur mirip JSON.  Dan kadang-kadang kadang berguna untuk membacanya, membacanya - dan setidaknya bisa membuatnya cadangan, karena Anda tidak pernah tahu apa.  Secara pribadi, misalnya, saya lebih tenang dari kenyataan bahwa ini ada di suatu tempat yang dikendalikan oleh saya. <br></td><td>  Menyimpan status hanya di suatu tempat di dalam AWS </td></tr><tr><td>  Impor Sumber Daya </td><td>  Terraform memudahkan pengimporan sumber daya.  Anda dapat mengambil semua sumber daya di bawah kendali Anda.  Anda cukup menulis kode yang akan mencirikan objek ini, atau menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terraforming</a> . <br>  Dia pergi ke Amazon yang sama, mengambil informasi tentang lingkungan dari sana, dan kemudian membuangnya dalam bentuk kode. <br>  Ini dibuat oleh mesin, tidak dioptimalkan, tetapi ini adalah langkah pertama yang baik untuk memulai migrasi.  Dan kemudian Anda hanya memberikan perintah impor.  Terraform membandingkan, membawa lingkungan ini ke dalam keadaannya - dan sekarang ia mengendalikannya. <br></td><td>  CloudFormation tidak tahu caranya.  Jika <br>  Anda telah melakukan sesuatu dengan tangan Anda sebelumnya, Anda membenturkannya dan membuatnya kembali dengan CloudFormation, atau hidup terus.  Sayangnya, tidak ada opsi. </td></tr></tbody></table></div><br><h3>  Bagaimana cara memulai dengan Terraform </h3><br>  Secara umum, memulai cukup sederhana.  Inilah langkah-langkah pertama secara singkat: <br><br><ol><li>  Pertama-tama, buat repositori Git dan segera mulai menyimpan semua perubahan, percobaan, dan semuanya. </li><li>  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan Memulai</a> .  Ini kecil, sederhana, cukup rinci, dan menjelaskan dengan baik bagaimana memulai dengan utilitas ini. </li><li>  Tulis beberapa demo, kode kerja.  Anda bahkan dapat menyalin beberapa contoh untuk dimainkan nanti. </li></ol><br><h3>  Latihan kami dengan Terraform </h3><br><h4>  Kode sumber </h4><br>  Anda memulai proyek pertama Anda dan menyimpan semuanya dalam satu file main.tf besar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah contoh khas</a> (saya jujur ​​mengambil yang pertama saya dapatkan dari GitHub). <br><br>  Tidak ada yang salah, tetapi ukuran basis kode cenderung bertambah seiring waktu.  Ketergantungan antara sumber daya juga meningkat.  Setelah beberapa waktu, file menjadi besar, kompleks, tidak dapat dibaca, tidak dirawat dengan baik - dan perubahan yang ceroboh di satu tempat dapat menyebabkan masalah. <br><br>  Hal pertama yang saya sarankan adalah untuk menyoroti apa yang disebut repositori inti, atau keadaan inti dari proyek Anda, lingkungan Anda.  Segera setelah Anda mulai membuat infrastruktur menggunakan Terraform, atau mengimpornya, Anda akan segera menemukan kenyataan bahwa Anda memiliki beberapa entitas yang, setelah digunakan, dikonfigurasikan, jarang berubah.  Misalnya, ini adalah pengaturan VPC, atau VPC itu sendiri.  Ini adalah jaringan, kelompok keamanan dasar, umum seperti akses SSH - Anda dapat menyusun daftar yang cukup besar. <br><br>  Tidak masuk akal untuk menyimpan ini di repositori yang sama dengan layanan yang sering Anda ubah.  Pilih mereka dalam repositori yang terpisah dan dokkan melalui fitur Terraform seperti keadaan jauh. <br><br><ul><li>  Anda mengurangi basis kode bagian proyek yang sering Anda kerjakan secara langsung. </li><li>  Alih-alih satu file besar yang berisi deskripsi kondisi infrastruktur Anda, dua file lebih kecil, dan pada titik waktu tertentu Anda bekerja dengan salah satunya. </li></ul><br>  Apa masalahnya?  Ketika Terraform membangun sebuah rencana, yaitu menghitung, menghitung apa yang harus diubah, menerapkan - itu sepenuhnya menceritakan keadaan ini, memeriksa terhadap kode, memeriksa terhadap status dalam AWS.  Semakin besar status Anda, semakin lama rencananya. <br><br>  Kami sampai pada praktik ini ketika kami membutuhkan waktu 20 menit untuk membangun rencana untuk seluruh lingkungan dalam produksi.  Karena fakta bahwa kami menarik ke dalam inti yang terpisah segala sesuatu yang kami tidak dapat sering berubah, kami mengurangi waktu untuk membangun rencana hingga setengahnya.  Kami memiliki ide bagaimana hal itu dapat dikurangi lebih lanjut, tidak hanya memecah menjadi inti dan non-inti, tetapi juga oleh subsistem, karena kami memiliki mereka terhubung dan biasanya berubah bersama.  Jadi, kita katakan, kita akan mengubah 10 menit menjadi 3. Tetapi kita masih dalam proses menerapkan solusi seperti itu. <br><br><h4>  Lebih sedikit kode - lebih mudah dibaca </h4><br>  Kode kecil lebih mudah dipahami dan lebih nyaman digunakan.  Jika Anda memiliki tim besar dan ada orang-orang dengan tingkat pengalaman berbeda di dalamnya - keluarkan apa yang jarang Anda ubah, tetapi secara global, dalam lobak terpisah, dan sediakan akses yang lebih sempit untuknya. <br><br>  Katakanlah Anda memiliki junior di tim Anda dan Anda tidak memberi mereka akses ke repositori global yang menjelaskan pengaturan VPC - dengan cara ini Anda memastikan diri Anda dari kesalahan.  Jika seorang insinyur membuat kesalahan dalam menulis contoh, dan sesuatu dibuat salah - itu tidak menakutkan.  Dan jika dia membuat kesalahan dalam opsi yang diinstal pada semua mesin, istirahat, atau melakukan sesuatu dengan pengaturan subnet, dengan routing - ini jauh lebih menyakitkan. <br><br>  Pemilihan repositori inti dilakukan dalam beberapa langkah. <br><br>  <b>Tahap 1</b> .  Buat repositori terpisah.  Simpan semua kode di dalamnya, secara terpisah - dan jelaskan entitas yang harus digunakan kembali dalam repositori pihak ketiga menggunakan output ini.  Katakanlah kita membuat sumber daya subnet AWS di mana kita menggambarkan di mana ia berada, zona ketersediaan mana, ruang alamat. <br><br><pre><code class="go hljs">resource <span class="hljs-string"><span class="hljs-string">"aws_subnet"</span></span> <span class="hljs-string"><span class="hljs-string">"lab_pub1a"</span></span> { vpc_id = <span class="hljs-string"><span class="hljs-string">"${aws_vpc.lab.id}"</span></span> cidr_block = <span class="hljs-string"><span class="hljs-string">"10.10.10.0/24"</span></span> Availability_zone = <span class="hljs-string"><span class="hljs-string">"us-east-1a"</span></span> ... } output <span class="hljs-string"><span class="hljs-string">"sn_lab_pub1a-id"</span></span> { value = <span class="hljs-string"><span class="hljs-string">"${aws_subnet.lab_pub1a.id}"</span></span> }</code> </pre> <br>  Dan kemudian kita mengatakan bahwa kita mengirim id dari objek ini ke output.  Anda dapat melakukan output untuk setiap parameter yang Anda butuhkan. <br><br>  Apa masalahnya di sini?  Saat Anda menggambarkan nilai, Terraform menyimpannya secara terpisah di inti tfstate.  Dan ketika Anda menoleh padanya, dia tidak perlu menyinkronkan, menceritakan kembali - dia akan dapat segera memberikan masalah ini kepada Anda dari keadaan ini.  Lebih jauh, dalam repositori, yang bukan-inti, Anda menggambarkan koneksi seperti itu dengan keadaan jauh: Anda memiliki keadaan jauh ini dan itu, itu terletak di bucket S3 ini dan itu, kunci ini dan itu serta kunci dan wilayah. <br><br>  <b>Tahap 2</b> .  Dalam proyek non-inti, kami membuat tautan ke status proyek inti, sehingga kami dapat merujuk ke parameter yang diekspor melalui output. <br><br><pre> <code class="go hljs">data <span class="hljs-string"><span class="hljs-string">"terraform_remote_state"</span></span> <span class="hljs-string"><span class="hljs-string">"lab_core"</span></span> { backend = <span class="hljs-string"><span class="hljs-string">"s3"</span></span> config { bucket = <span class="hljs-string"><span class="hljs-string">"lab-core-terraform-state"</span></span> key = <span class="hljs-string"><span class="hljs-string">"terraform.tfstate"</span></span> region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span> } }</code> </pre><br>  <b>Tahap 3</b> .  Mulai!  Ketika saya perlu menggunakan antarmuka jaringan baru untuk contoh di subnet tertentu, saya katakan: di sini adalah negara data jarak jauh, cari nama negara ini di dalamnya, cari parameter ini di dalamnya, yang, pada kenyataannya, cocok dengan nama ini. <br><br><pre> <code class="go hljs">resource <span class="hljs-string"><span class="hljs-string">"aws_network_interface"</span></span> <span class="hljs-string"><span class="hljs-string">"fwl01"</span></span> { ... subnet_id = <span class="hljs-string"><span class="hljs-string">"${data.terraform_remote_state.lab_core.sn_lab_pub1a-id}"</span></span> }</code> </pre><br>  Dan ketika saya membangun rencana perubahan di repositori non-inti saya, nilai untuk Terraform ini akan menjadi konstan untuk itu.  Jika Anda ingin mengubahnya, Anda harus melakukannya di repositori ini, tentu saja, inti.  Tetapi karena ini jarang berubah, itu tidak mengganggu Anda. <br><br><h4>  Modul </h4><br>  Biarkan saya mengingatkan Anda bahwa modul adalah konfigurasi mandiri yang terdiri dari satu atau lebih sumber daya terkait.  Itu dikelola sebagai grup: <br><br>  Modul adalah hal yang sangat nyaman karena Anda jarang membuat satu sumber daya begitu saja, dalam ruang hampa, biasanya itu terhubung secara logis dengan sesuatu. <br><br><pre> <code class="go hljs">module <span class="hljs-string"><span class="hljs-string">"AAA"</span></span> { source = <span class="hljs-string"><span class="hljs-string">"..."</span></span> count = <span class="hljs-string"><span class="hljs-string">"3"</span></span> count_offset = <span class="hljs-string"><span class="hljs-string">"0"</span></span> host_name_prefix = <span class="hljs-string"><span class="hljs-string">"XXX-YYY-AAA"</span></span> ami_id = <span class="hljs-string"><span class="hljs-string">"${data.terraform_remote_state.lab_core.ami-base-ami_XXXX-id}"</span></span> subnet_ids = [<span class="hljs-string"><span class="hljs-string">"${data.terraform_remote_state.lab_core.sn_lab_pub1a-id}"</span></span>, <span class="hljs-string"><span class="hljs-string">"${data.terraform_remote_state.lab_core.sn_lab_pub1b-id}"</span></span>] instance_type = <span class="hljs-string"><span class="hljs-string">"t2.large"</span></span> sgs_ids = [ <span class="hljs-string"><span class="hljs-string">"${data.terraform_remote_state.lab_core.sg_ssh_lab-id}"</span></span>, <span class="hljs-string"><span class="hljs-string">"${aws_security_group.XXX_lab.id}"</span></span> ] boot_device = {volume_size = <span class="hljs-string"><span class="hljs-string">"50"</span></span> volume_type = <span class="hljs-string"><span class="hljs-string">"gp2"</span></span>} root_device = {device_name = <span class="hljs-string"><span class="hljs-string">"/dev/sdb"</span></span> volume_size = <span class="hljs-string"><span class="hljs-string">"50"</span></span> volume_type = <span class="hljs-string"><span class="hljs-string">"gp2"</span></span> encrypted = <span class="hljs-string"><span class="hljs-string">"true"</span></span>} tags = <span class="hljs-string"><span class="hljs-string">"${var.gas_tags}"</span></span> }</code> </pre><br>  Sebagai contoh: ketika kita menggunakan instance EC2 baru, kita membuat antarmuka jaringan dan lampiran untuk itu, kita sering membuat alamat IP elastis untuk itu, kita membuat catatan rute-53, dan sesuatu yang lain.  Artinya, kita mendapatkan setidaknya 4 entitas. <br><br>  Setiap kali, menggambarkannya dalam empat potong kode tidak nyaman.  Apalagi mereka cukup khas.  Itu memohon - membuat templat, dan kemudian hanya merujuk ke templat ini, memberikan parameter padanya: beberapa nama, ke dalam kotak mana yang akan didorong, grup keamanan mana yang akan digantung.  Sangat nyaman. <br><br>  Terraform memiliki fitur Hitung, yang memungkinkan Anda untuk lebih mengurangi kondisi Anda.  Anda dapat menggambarkan sekumpulan besar instance dengan sepotong kode.  Katakanlah saya perlu menggunakan 20 mesin dari jenis yang sama.  Saya tidak akan menulis 20 lembar kode bahkan dari template, saya akan menulis 1 lembar kode, saya akan menunjukkan Hitung dan nomor di dalamnya - berapa banyak yang harus saya lakukan. <br><br>  Misalnya, ada beberapa modul yang mereferensikan templat.  Saya hanya melewati parameter spesifik: ID subnet;  AMI untuk digunakan bersama;  jenis contoh;  pengaturan grup keamanan;  hal lain, dan tunjukkan berapa banyak dari hal-hal ini yang harus saya lakukan.  Hebat, bawa mereka dan balikkan! <br><br>  Besok, pengembang mendatangi saya dan berkata: "Dengar, kami ingin bereksperimen dengan muatan, tolong beri kami dua lagi."  Yang perlu saya lakukan: Saya mengubah satu digit menjadi 5. Jumlah kode tetap sama persis. <br><br>  Secara konvensional, modul dapat dibagi menjadi dua jenis - sumber daya dan infrastruktur.  Dari sudut pandang kode, tidak ada perbedaan, melainkan konsep tingkat tinggi yang diperkenalkan oleh operator. <br>  Modul sumber daya menyediakan kumpulan sumber daya yang terstandarisasi dan parameter, terkait secara logis.  Contoh di atas adalah modul sumber daya yang khas.  Cara bekerja dengan mereka: <br><br><ul><li>  Kami menunjukkan jalur ke modul - sumber konfigurasinya, melalui arahan Sumber. </li><li>  Kami menunjukkan versi - ya, dan operasi pada prinsip "terbaru dan terhebat" bukanlah pilihan terbaik di sini.  Anda tidak memasukkan versi terbaru perpustakaan setiap kali dalam proyek Anda?  Tetapi lebih lanjut tentang itu nanti. </li><li>  Kami memberikan argumen padanya. </li></ul><br>  Kami dilampirkan ke versi modul, dan kami hanya mengambil yang terakhir - infrastruktur harus diversiasikan (sumber daya tidak dapat diversiasikan, tetapi kode dapat).  Sumber daya dapat dibuat dihapus atau diciptakan kembali.  Itu saja!  Kita juga harus tahu dengan jelas versi mana yang telah kita buat masing-masing infrastruktur. <br><br>  Modul infrastruktur cukup sederhana.  Mereka terdiri dari sumber daya, dan termasuk standar perusahaan (misalnya, tag, daftar nilai standar, standar yang diterima, dan sebagainya). <br><br>  Mengenai proyek dan pengalaman kami, kami telah lama dan dengan tegas beralih ke penggunaan modul sumber daya untuk segala sesuatu yang mungkin dengan proses pembuatan versi dan peninjauan yang sangat ketat.  Dan sekarang kami secara aktif memperkenalkan praktik modul infrastruktur di tingkat laboratorium dan pementasan. <br><br>  Rekomendasi untuk menggunakan modul <br><br><ol><li>  Jika Anda tidak bisa menulis, tetapi gunakan yang sudah jadi, jangan menulis.  Apalagi jika Anda baru dalam hal ini.  Percayai modul yang sudah jadi, atau setidaknya lihat bagaimana mereka melakukannya untuk Anda.  Namun, jika Anda masih perlu menulis sendiri, jangan gunakan panggilan ke penyedia secara internal dan berhati-hatilah dengan penyedia layanan. </li><li>  Periksa bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terraform Registry</a> tidak mengandung modul sumber daya yang sudah jadi. </li><li>  Jika Anda menulis modul Anda, sembunyikan spesifik di bawah tenda.  Pengguna akhir tidak perlu khawatir tentang apa dan bagaimana Anda menerapkannya secara internal. </li><li>  Lakukan parameter input dan nilai output dari modul Anda.  Dan lebih baik jika mereka file terpisah.  Sangat nyaman. </li><li>  Jika Anda menulis modul, simpan dalam repositori dan versi.  Lebih baik repositori terpisah untuk modul. </li><li>  Jangan menggunakan modul lokal - mereka tidak diversi atau digunakan kembali. </li><li>  Hindari menggunakan deskripsi penyedia dalam modul, karena kredensial koneksi dapat dikonfigurasi dan diterapkan secara berbeda untuk orang yang berbeda.  Seseorang menggunakan variabel lingkungan untuk ini, dan seseorang menyiratkan menyimpan kunci dan rahasia mereka dalam file dengan jalur yang ditentukan untuk mereka.  Ini harus ditunjukkan pada tingkat yang lebih tinggi. </li><li>  Gunakan penyedia lokal dengan hati-hati.  Itu dijalankan secara lokal, pada mesin yang menjalankan Terraform, tetapi lingkungan eksekusi untuk pengguna yang berbeda mungkin berbeda.  Sampai Anda menanamkannya di CI, Anda dapat menemukan berbagai artefak: misalnya eksekutif lokal dan menjalankan yang mungkin.  Dan seseorang memiliki distribusi yang berbeda, shell yang lain, versi yang berbeda dari yang dimungkinkan, atau bahkan Windows. </li></ol><br>  Tanda-tanda modul yang baik (di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sedikit lebih rinci</a> ): <br><br><ul><li>  Modul yang baik memiliki dokumentasi dan contoh.  Jika masing-masing dirancang sebagai repositori terpisah, ini lebih mudah dilakukan. </li><li>  Mereka tidak memiliki pengaturan hardcoded (misalnya, wilayah AWS). </li><li>  Gunakan standar wajar, dirancang sebagai standar.  Sebagai contoh, modul untuk instance EC2 secara default tidak akan membuat mesin virtual bertipe m5d.24xlarge untuk Anda, ia menggunakan salah satu dari jenis t2 atau t3 minimum untuk ini. </li><li>  Kode ini "bersih" - terstruktur, disediakan dengan komentar, tidak perlu bingung, dirancang dengan gaya yang sama. </li><li>  Sangat diinginkan untuk dilengkapi dengan tes, meskipun sulit.  Sayangnya, kami belum sampai pada hal ini. </li></ul><br><h4>  Memberi tag </h4><br>  Tag itu penting. <br><br>  Tagging adalah penagihan.  AWS memiliki alat yang memungkinkan Anda melihat berapa banyak uang yang Anda habiskan untuk infrastruktur Anda.  Dan manajemen kami benar-benar ingin memiliki alat di mana mereka dapat melihatnya secara deterministik.  Misalnya, berapa banyak uang yang dikonsumsi komponen ini dan itu, atau subsistem ini dan itu, tim ini dan itu, lingkungan ini dan itu <br><br><img src="https://habrastorage.org/webt/3q/mn/9e/3qmn9ej1ao0cmn8irggvgl8ztj4.png" alt="gambar"><br><br>  Pemberian tag adalah dokumentasi sistem Anda.  Dengan itu, Anda menyederhanakan pencarian Anda.  Bahkan hanya di konsol AWS, di mana tag ini ditampilkan dengan rapi di layar Anda, menjadi lebih mudah bagi Anda untuk memahami apa yang dimaksud dengan jenis ini atau itu.  Jika kolega baru datang, lebih mudah bagi Anda untuk menjelaskan ini dengan menunjukkan: "Lihat, ini dia - ini."  Kami mulai membuat tag sebagai berikut - kami membuat array tag untuk setiap jenis sumber daya. <br><br>  Contoh: <br><br><pre> <code class="go hljs">variable <span class="hljs-string"><span class="hljs-string">"XXX_tags"</span></span> { description = <span class="hljs-string"><span class="hljs-string">"The set of XXX tags."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-string"><span class="hljs-string">"map"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> = { <span class="hljs-string"><span class="hljs-string">"TerminationDate"</span></span> = <span class="hljs-string"><span class="hljs-string">"03.23.2018"</span></span>, <span class="hljs-string"><span class="hljs-string">"Environment"</span></span> = <span class="hljs-string"><span class="hljs-string">"env_name_here"</span></span>, <span class="hljs-string"><span class="hljs-string">"Department"</span></span> = <span class="hljs-string"><span class="hljs-string">"dev"</span></span>, <span class="hljs-string"><span class="hljs-string">"Subsystem"</span></span> = <span class="hljs-string"><span class="hljs-string">"subsystem_name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Component"</span></span> = <span class="hljs-string"><span class="hljs-string">"XXX"</span></span>, <span class="hljs-string"><span class="hljs-string">"Type"</span></span> = <span class="hljs-string"><span class="hljs-string">"application"</span></span>, <span class="hljs-string"><span class="hljs-string">"Team"</span></span> = <span class="hljs-string"><span class="hljs-string">"team_name"</span></span> } }</code> </pre><br>  Kebetulan di perusahaan kami lebih dari satu tim kami menggunakan AWS, dan ada beberapa daftar tag yang diperlukan. <br><br><ol><li>  Tim - tim mana yang menggunakan berapa banyak sumber daya. </li><li>  Departemen - mirip dengan departemen. </li><li>  Lingkungan - sumber daya mengalahkan dalam "lingkungan", tetapi Anda, misalnya, dapat menggantinya dengan proyek atau sesuatu seperti itu. </li><li>  Subsistem - subsistem tempat komponen berada.  Komponen dapat dimiliki oleh satu subsistem.  Sebagai contoh, kami ingin melihat seberapa banyak subsistem yang kami miliki dan entitasnya mulai konsumsi.  Tiba-tiba, misalnya, untuk bulan sebelumnya, itu telah tumbuh secara signifikan.  Kita harus pergi ke pengembang dan berkata: "Guys, itu mahal.  Anggaran sudah dekat satu sama lain, mari kita optimalkan logikanya. ” </li><li>  Jenis - jenis komponen: penyeimbang, penyimpanan, aplikasi atau database. </li><li>  Komponen - komponen itu sendiri, namanya dalam notasi internal. </li><li>  Tanggal pengakhiran - waktu kapan harus dihapus, dalam format tanggal.  Jika penghapusannya tidak diharapkan, setel ke "Permanen".  Kami memperkenalkannya karena di lingkungan pengembangan, dan bahkan di beberapa lingkungan panggung, kami memiliki tahap pengujian stres yang meningkat selama sesi stres, yaitu, kami tidak menjaga mesin ini secara teratur.  Kami menunjukkan tanggal kapan sumber daya harus dihancurkan.  Selanjutnya, Anda dapat mempercepat otomatisasi berdasarkan lambda, beberapa skrip eksternal yang bekerja melalui AWS Command Line Interface, yang akan menghancurkan sumber daya ini secara otomatis. </li></ol><br>  Sekarang - cara memberi tag. <br><br>  Kami memutuskan bahwa kami akan melakukan tag-map kami sendiri untuk setiap komponen, di mana kami akan mencantumkan semua tag yang ditentukan: kapan harus menghentikannya, apa yang dimaksud.  Mereka dengan cepat menyadari bahwa itu tidak nyaman.  Karena basis kode bertambah, karena kami memiliki lebih dari 30 komponen, dan 30 keping kode seperti itu tidak nyaman.  Jika Anda perlu mengubah sesuatu, maka Anda jalankan dan ubah. <br><br>  Untuk memberi tag dengan baik, kami menggunakan entitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lokal</a> . <br><br><pre> <code class="go hljs">locals { common_tags = {<span class="hljs-string"><span class="hljs-string">"TerminationDate"</span></span> = <span class="hljs-string"><span class="hljs-string">"XX.XX.XXXX"</span></span>, <span class="hljs-string"><span class="hljs-string">"Environment"</span></span> = <span class="hljs-string"><span class="hljs-string">"env_name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Department"</span></span> = <span class="hljs-string"><span class="hljs-string">"dev"</span></span>, <span class="hljs-string"><span class="hljs-string">"Team"</span></span> = <span class="hljs-string"><span class="hljs-string">"team_name"</span></span>} subsystem_1_tags = <span class="hljs-string"><span class="hljs-string">"${merge(local.common_tags, map("</span></span>Subsystem<span class="hljs-string"><span class="hljs-string">", "</span></span>subsystem_1_name<span class="hljs-string"><span class="hljs-string">"))}"</span></span> subsystem_2_tags = <span class="hljs-string"><span class="hljs-string">"${merge(local.common_tags, map("</span></span>Subsystem<span class="hljs-string"><span class="hljs-string">", "</span></span>subsystem_2_name<span class="hljs-string"><span class="hljs-string">"))}"</span></span> }</code> </pre><br>  Di dalamnya Anda dapat membuat daftar subset, dan kemudian menggunakannya satu sama lain. <br><br>  Sebagai contoh, kami menghapus beberapa tag umum ke dalam struktur seperti itu, dan kemudian yang spesifik dengan subsistem.  Kami mengatakan: "Ambil blok ini dan tambahkan, misalnya, subsistem 1. Dan untuk subsistem 2, tambahkan subsistem 2".  Kami mengatakan: "Tag, tolong, ambil yang umum dan tambahkan jenis, aplikasi, nama, komponen, dan siapa yang memilikinya."  Ternyata perubahannya sangat singkat, jelas dan tersentralisasi, jika tiba-tiba diperlukan. <br><br><pre> <code class="go hljs">module <span class="hljs-string"><span class="hljs-string">"ZZZ02"</span></span> { count = <span class="hljs-number"><span class="hljs-number">1</span></span> count_offset = <span class="hljs-number"><span class="hljs-number">1</span></span> name = <span class="hljs-string"><span class="hljs-string">"XXX-YYY-ZZZ"</span></span> ... tags = <span class="hljs-string"><span class="hljs-string">"${merge(local.core_tags, map("</span></span>Type<span class="hljs-string"><span class="hljs-string">", "</span></span>application<span class="hljs-string"><span class="hljs-string">", "</span></span>Component<span class="hljs-string"><span class="hljs-string">", "</span></span>XXX<span class="hljs-string"><span class="hljs-string">"))}"</span></span> }</code> </pre><br><img src="https://habrastorage.org/webt/ka/sq/4o/kasq4ocxxl3hht59z9p6o5bzjfs.png" alt="gambar"><br><br><h4>  Kontrol versi </h4><br>  Modul template Anda, jika Anda menggunakannya, harus disimpan di suatu tempat.  Cara termudah yang paling mungkin dilakukan setiap orang adalah penyimpanan lokal.  Hanya di direktori yang sama, hanya beberapa subdirektori di mana Anda menggambarkan, misalnya, templat untuk beberapa jenis layanan.  Ini bukan cara yang baik.  Ini nyaman, dapat dengan cepat diperbaiki dan diuji dengan cepat, tetapi sulit untuk menggunakannya kembali nanti dan sulit untuk dikendalikan <br><br><pre> <code class="go hljs">module <span class="hljs-string"><span class="hljs-string">"ZZZ02"</span></span> { source = <span class="hljs-string"><span class="hljs-string">"./modules/srvroles/ZZZ"</span></span> name = <span class="hljs-string"><span class="hljs-string">"XXX-YYY-ZZZ"</span></span> }</code> </pre><br>  Misalkan pengembang mendatangi Anda dan berkata: "Jadi, kami membutuhkan entitas ini dan itu dalam konfigurasi ini dan itu, dalam infrastruktur kami."  Anda menulisnya, membuatnya dalam bentuk modul lokal di repositori proyek mereka.  Dikerahkan - sangat baik.  Mereka menguji, mengatakan: "Itu akan!  Dalam produksi. "  Kami datang ke panggung, pengujian stres, produksi.  Setiap kali Ctrl-C, Ctrl-V;  Ctrl-C, Ctrl-V.  Ketika kami sampai di penjualan, rekan kami mengambilnya, menyalin kode dari lingkungan laboratorium, memindahkannya ke tempat lain dan mengubahnya di sana.  Dan kita mendapatkan kondisi yang sudah tidak konsisten.  Dengan penskalaan horizontal, ketika Anda memiliki lingkungan laboratorium sebanyak yang kami miliki, itu hanya adish. <br><br>  Oleh karena itu, cara yang baik adalah membuat repositori Git yang terpisah untuk masing-masing modul Anda, dan kemudian rujuk saja.  Kami mengubah segalanya di satu tempat - baik, nyaman, terkontrol. <br><br><pre> <code class="go hljs">module <span class="hljs-string"><span class="hljs-string">"ZZZ"</span></span> { source = <span class="hljs-string"><span class="hljs-string">"git::ssh://git@GIT_SERVER_FQDN/terraform/modules/general-vm/2-disks.git"</span></span> host_name_prefix = <span class="hljs-string"><span class="hljs-string">"XXX-YYY-ZZZ"</span></span></code> </pre><br>  Mengantisipasi pertanyaan, bagaimana kode Anda mencapai produksi.  Untuk ini, proyek terpisah dibuat yang menggunakan kembali modul yang disiapkan dan diuji. <br><br>  Hebat, kami memiliki satu sumber kode yang berubah secara terpusat.  Saya mengambil, menulis, menyiapkan, dan mengatur diri sendiri bahwa besok pagi saya akan menyebarkan produksi.  Buat rencana, teruji - hebat, ayo pergi.  Pada saat ini, kolega saya, dibimbing secara eksklusif oleh niat baik, pergi dan mengoptimalkan sesuatu, ditambahkan ke modul ini.  Dan kebetulan bahwa perubahan ini merusak kompatibilitas. <br><br>  Misalnya, dia menambahkan parameter yang diperlukan, yang harus dia lewati, jika tidak, modul tidak akan berkumpul.  Atau dia mengubah nama parameter ini.  Saya datang di pagi hari, saya benar-benar membatasi waktu untuk perubahan, mulai membangun rencana, dan Terraform mengeluarkan modul negara dari Git, mulai membangun rencana dan berkata: "Ups, saya tidak bisa.  Tidak cukup untuk Anda, Anda berganti nama. "  Saya terkejut: "Tapi saya tidak melakukannya, bagaimana menghadapinya?"  Dan jika ini adalah sumber daya yang dibuat sejak lama, maka setelah perubahan seperti itu Anda harus menjalankan semua lingkungan, entah bagaimana berubah dan mengarah ke satu tampilan.  Ini tidak nyaman. <br><br>  Ini dapat diperbaiki menggunakan tag Git.  Kami memutuskan sendiri bahwa kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">notasi SemVer</a> dan menyusun aturan sederhana: segera setelah konfigurasi modul kami mencapai kondisi stabil tertentu, yaitu, kami dapat menggunakannya, kami memberi tag pada komit ini.  Jika kami melakukan perubahan dan tidak merusak kompatibilitas, kami mengubah nomor minor pada tag, jika rusak, kami mengubah nomor utama. <br><br>  Jadi, di alamat sumber, lampirkan ke tag tertentu dan jika setidaknya memberikan sesuatu yang Anda miliki sebelumnya, itu akan selalu dikumpulkan.  Biarkan versi modul berjalan, tetapi pada saat yang tepat kita akan datang, dan ketika kita benar-benar membutuhkannya, kita akan mengubahnya.  Dan apa yang berhasil sebelum itu, setidaknya tidak akan rusak.  Ini nyaman.  Ini seperti apa yang terlihat di GitLab kami. <br><br><img src="https://habrastorage.org/webt/qb/vc/yh/qbvcyhrhgdblv8ewvwlr1gkxsmc.png" alt="gambar"><br><br><h4>  Bercabang </h4><br>  Menggunakan percabangan adalah praktik penting lainnya.  Kami telah mengembangkan aturan untuk diri kami sendiri bahwa Anda harus membuat perubahan hanya dari master.  Tetapi untuk setiap perubahan yang ingin Anda buat dan uji, silakan buat cabang terpisah, bermain dengannya, bereksperimen, buat rencana, dan lihat bagaimana hasilnya.  Dan kemudian lakukan permintaan gabungan, dan biarkan seorang rekan melihat kode dan bantuan. <br><br><img src="https://habrastorage.org/webt/ty/vf/je/tyvfjel4g_uhzcrf7ifnkdxd230.png" alt="gambar"><br><br><h4>  Tempat menyimpan tfstate </h4><br>  Anda tidak boleh menyimpan negara Anda secara lokal.  Anda seharusnya tidak menyimpan status Anda di Git. <br><br>  Kita terbakar pada ini ketika seseorang, ketika meluncurkan cabang-cabang non-master, mendapatkan statusnya, di mana negara diselamatkan - kemudian dia menyalakannya melalui penggabungan, seseorang menambahkan miliknya, ternyata menggabungkan konflik.  Atau ternyata tanpa mereka, tetapi keadaan yang tidak konsisten, karena "dia sudah memilikinya, saya belum memilikinya," dan kemudian memperbaikinya semua adalah praktik yang tidak menyenangkan.  Oleh karena itu, kami memutuskan bahwa kami akan menyimpannya di tempat yang aman, versi, tetapi itu akan berada di luar Git. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">S3</a> sangat cocok di bawah ini: ini tersedia, memiliki HA, sejauh yang saya ingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">empat sembilan tepat, mungkin lima</a> .  Ini memberi versi keluar dari kotak, bahkan jika Anda memecahkan tfstate Anda, Anda selalu dapat memutar kembali.  Dan dia juga memberikan hal yang sangat penting dalam kombinasi dengan DynamoDB, yang, menurut pendapat saya, telah mempelajari Terraform ini sejak versi 0.8.  Di DynamoDB, Anda memiliki papan nama di mana Terraform mencatat bahwa itu memblokir negara. <br><br>  Yaitu, misalkan saya ingin membuat beberapa perubahan.  Saya mulai membangun rencana atau mulai menerapkannya, Terraform pergi ke DynamoDB dan mengatakan bahwa itu membuat informasi dalam pelat ini bahwa keadaan ini diblokir;  pengguna, komputer, waktu.  Pada saat ini, kolega saya, yang bekerja dari jarak jauh atau mungkin beberapa meja dari saya, tetapi fokus pada pekerjaan dan tidak melihat apa yang saya lakukan, juga memutuskan bahwa sesuatu perlu diubah.  Dia membuat rencana, tetapi meluncurkannya sedikit kemudian. <br><br>  Terraform masuk ke dinamika, lihat - Kunci, terputus, memberi tahu pengguna: "Maaf, tfstate diblokir oleh sesuatu."  Seorang kolega melihat bahwa saya sedang bekerja sekarang, dia dapat mendatangi saya dan berkata, "Dengar, changer saya lebih penting, tolong beri saya."  Saya berkata: "Bagus", saya membatalkan paket, menghapus blok, lebih tepatnya, bahkan secara otomatis dihapus jika Anda melakukannya dengan benar, tanpa mengganggu Ctrl-C.  Seorang kolega pergi dan melakukannya.  Jadi, kami memastikan diri kami terhadap situasi ketika Anda berdua mengubah sesuatu. <br><br><h4>  Gabungkan permintaan </h4><br>  Kami menggunakan percabangan di Git.  Kami memberikan permintaan penggabungan kepada kolega.  Selain itu, di Gitlab kami menggunakan hampir semua alat yang tersedia bagi kami untuk bekerja bersama, untuk menggabungkan permintaan atau bahkan hanya beberapa kumpulan: mendiskusikan kode Anda, meninjaunya, menetapkan sedang dalam proses atau masalah, hal lain seperti itu.  Ini sangat berguna, sangat membantu dalam pekerjaan. <br><br>  Plus, dalam hal ini, rollback juga lebih mudah, Anda dapat kembali ke komit sebelumnya atau, jika Anda, katakanlah, memutuskan bahwa Anda tidak hanya akan menerapkan perubahan dari wizard, Anda cukup beralih ke cabang stabil.  Misalnya, Anda membuat cabang fitur dan memutuskan bahwa Anda akan melakukan perubahan terlebih dahulu dari cabang fitur.  Dan kemudian perubahan, setelah semuanya bekerja dengan baik, lakukan pada master.  Anda menerapkan perubahan di cabang Anda, menyadari bahwa ada sesuatu yang salah, beralih ke master - tidak ada perubahan, kata mereka berlaku - dia kembali. <br><br><h4>  Jaringan pipa </h4><br><img src="https://habrastorage.org/webt/qx/g1/ex/qxg1exw6vesornrgdhc7ynmjg80.png" alt="gambar"><br><br>  Kami memutuskan bahwa kami perlu menggunakan proses CI untuk menerapkan perubahan kami.  Untuk melakukan ini, berdasarkan Gitlab CI, kami sedang menulis saluran pipa yang mengotomatiskan aplikasi perubahan.  Sejauh ini, kami memiliki dua jenis: <br><br><ul><li>  Pipa untuk cabang utama (pipa induk) </li><li>  Pipa untuk semua cabang lainnya (pipa cabang) </li></ul><br>  Apa yang dilakukan pipa brunch?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu mulai verifikasi kode otomatis (bodoh memeriksa untuk kesalahan ketik, misalnya). Dan kemudian mulai membangun rencana. Dan kolega yang akan menonton permintaan gabungan Anda dapat segera membuka paket yang telah dibuat dan tidak hanya melihat kode - tetapi juga apa yang Anda tambahkan. Dia juga akan melihat bagaimana itu akan jatuh pada infrastruktur Anda. Jelas dan bermanfaat.</font></font><br><br><img src="https://habrastorage.org/webt/vt/0_/hq/vt0_hqcdpurvppbglcxwgwtqiyi.png" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di wisaya, satu langkah lagi ditambahkan di sini. </font><font style="vertical-align: inherit;">Perbedaannya adalah bahwa rencana Anda tidak hanya dihasilkan, tetapi juga disimpan sebagai artefak. </font><font style="vertical-align: inherit;">Fitur lain yang sangat berguna dari Terraform adalah paket dapat disimpan sebagai file, dan kemudian menerapkannya. </font><font style="vertical-align: inherit;">Katakanlah Anda membuat permintaan gabungan dan mengesampingkannya. </font><font style="vertical-align: inherit;">Sebulan kemudian mereka mengingatnya dan memutuskan untuk kembali. </font><font style="vertical-align: inherit;">Kode Anda sudah jauh di depan. </font><font style="vertical-align: inherit;">Karena kenyataan bahwa Anda menyimpan artefak rencana tersebut, Anda dapat menerapkannya pada apa yang Anda inginkan pada saat itu. </font></font><br><br><img src="https://habrastorage.org/webt/67/9z/ub/679zubdsyvuldaiwzcpimtbvjmu.png" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus kami, artefak ini kemudian ditransfer ke langkah berikutnya, yang dilakukan dengan tangan. </font><font style="vertical-align: inherit;">Artinya, kita mendapat satu poin penerapan perubahan kita.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kekurangan dari Terraform </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terlepas dari kenyataan bahwa Terraform memiliki sejumlah fungsi bawaan yang cukup besar, tidak semuanya berfungsi sebaik yang ingin kita pikirkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memiliki fungsi tidak nyaman di dalamnya, misalnya, "Elemen" - dalam beberapa situasi, dengan kurangnya pengalaman, perilakunya mungkin tidak persis seperti yang Anda harapkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, Anda menggunakan modul, hitungan diteruskan ke modul - berapa banyak instance untuk digunakan, dan, katakanlah, daftar subnet yang dikelompokkan berdasarkan zona ketersediaan ditransmisikan. Ditransfer, diterapkan, tambah hitungan, masih diterapkan. Dan sekarang Anda memutuskan untuk mentransfer daftar subnet yang lebih banyak ke sana. Anda punya kotak, Anda memutuskan untuk menggunakan satu lagi AZ. Anda memiliki bagian kedua dari daftar yang berubah, dan hitungan dipetakan ke daftar ini melalui elemen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Katakanlah Anda memiliki 4 AZ sebelum ini dan 5 kali, dan kemudian Anda menambahkan AZ lain - itu akan meninggalkan 4 AZ pertama, yang sudah dalam urutan. Dan sekitar yang kelima ia akan berkata: "Dan sekarang aku akan membuatnya kembali." Dan kamu tidak mau! Anda hanya menginginkan yang baru datang. Bug semacam itu datang dari sifat karya Terraform dengan daftar. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator ternary.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suatu kondisi hanyalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator ternary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kami benar-benar kekurangan kondisi. Tetap saja, saya ingin If dan Else yang lebih akrab. Sayang sekali bahwa mereka tidak - mungkin mereka akan memberikan tumpangan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tantangan kerja tim</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika Anda memiliki tim besar, atau proyek besar, untuk sejumlah besar lingkungan, atau keduanya, Terraform akan menjadi sulit bagi Anda untuk digunakan tanpa menggunakan beberapa CI.</font></font><br><br>  CI           .       ,      , ,    —    merge,   .  . <br><br> ,         .        .     ,   , Terraform  , ,   tfstate   Terraform   : «,  ,  ».        ,   ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika Anda memiliki CI, ada beberapa entitas tunggal, misalnya, dalam wadah pipa Anda - Anda memastikan sendiri bahwa Anda tidak akan memiliki versi seperti itu di sekitar utilitas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan akhirnya, kode yang rusak atau tidak terpakai dapat menumpuk di wizard. Setiap kali Anda akan terlalu malas dari tempat Anda untuk menunggu sampai rencana untuk seluruh lingkungan dibangun. Anda akan sampai pada titik mencoba membangun melalui opsi target aplikasi hanya pada apa yang Anda ubah. Misalnya, Anda menambahkan beberapa instance dan berkata: "Terraform apply target instance", atau grup keamanan. Tetapi dalam kasus ini, jika sesuatu rusak (misalnya, beberapa konfigurasi sudah usang), Anda akan melihatnya ketika membangun paket lengkap.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda harus menghabiskan banyak usaha dan waktu untuk memperbarui ini. </font><font style="vertical-align: inherit;">Tidak perlu membahas ini. </font><font style="vertical-align: inherit;">Jika ada CI - di dalamnya kami hanya dengan paksa mengatakan bahwa Terraform akan membangun rencana sepenuhnya, Anda mendorong perubahan. </font><font style="vertical-align: inherit;">Dan biarkan dia membangun rencananya, Anda pergi dan melakukan sesuatu yang lain. </font><font style="vertical-align: inherit;">Dia membangunnya, Anda melihatnya, Anda memilikinya dalam bentuk artefak, dan Anda pergi untuk menerapkannya. </font><font style="vertical-align: inherit;">Itu disiplin.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terraform bukan peluru perak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang tidak akan dia izinkan Anda lakukan: </font></font><br><br><ul><li> Terraform       ,      .  , ,  .    ,        ,   ,   .       ,    ,  ,         . <br><br>  ,      —       Tfstate,       ,        .         .   «   ,    » —  . <br><br>                 , -,  ,  - —   .      ,          .     ,               —    . </li><li> Terraform    ,      .  Terraform    .  Mengapa           ,    .     . ,   ,    AZ    - -. ,   North Virginia,     6  .          .    ,   ,  : «,   ».       — .   —      ,  , Terraform     . </li><li> Terraform        . ,    — 200 ,    198 ,    5.    .       ,         API .  Sayang </li><li>     ,      . ,    S3 bucket.     ,              —  ,     - .         Terraform –    ,   ,   : «,  -   ».     .      -  ,      . </li></ul><br>   , Terraform — ,   .     ,     . <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470543/">https://habr.com/ru/post/id470543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470529/index.html">Bagaimana kami menerjemahkan proyek lawas ke GraphQL</a></li>
<li><a href="../id470531/index.html">Neurofisiologis membahas proyek Neuralink dan berbicara tentang kerja otak “dengan jari”</a></li>
<li><a href="../id470535/index.html">Cara Membuat Grafik Batang Menggunakan Python</a></li>
<li><a href="../id470537/index.html">Paket validasi baru untuk Bereaksi pada Mobx @ quantumart / mobx-form-validation-kit</a></li>
<li><a href="../id470541/index.html">Dasar-dasar bekerja dengan Neo4j di browser</a></li>
<li><a href="../id470547/index.html">Taskcls seledri: dekorator baru, fitur baru</a></li>
<li><a href="../id470549/index.html">TSMC berharap untuk mengikuti hukum Moore selama beberapa dekade mendatang</a></li>
<li><a href="../id470553/index.html">Euler-Poisson terpisahkan. Detail tentang metode perhitungan</a></li>
<li><a href="../id470555/index.html">Ulasan Joker 2019: parade planet, atau apa yang menanti kita</a></li>
<li><a href="../id470557/index.html">Kontrol cahaya: tipe baru elemen optik berdasarkan metamaterial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>