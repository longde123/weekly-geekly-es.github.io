<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏿 ☀️ ⚓️ Jadi semua RAML atau OAS (Swagger) yang sama? 👩🏾‍🤝‍👩🏽 🤰🏻 🌺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam dunia dinamis layanan-mikro, apa pun dapat berubah - komponen apa pun dapat ditulis ulang dalam bahasa lain menggunakan kerangka kerja dan arsit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jadi semua RAML atau OAS (Swagger) yang sama?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/466691/">  Dalam dunia dinamis layanan-mikro, apa pun dapat berubah - komponen apa pun dapat ditulis ulang dalam bahasa lain menggunakan kerangka kerja dan arsitektur yang berbeda.  Hanya kontrak yang harus tetap tidak berubah, sehingga dimungkinkan untuk berinteraksi dengan layanan mikro dari luar secara konstan, terlepas dari metamorfosis internal.  Dan hari ini kita akan berbicara tentang masalah kita memilih format untuk menggambarkan kontrak dan berbagi artefak yang ditemukan. <br><br><img src="https://habrastorage.org/webt/x2/vf/ry/x2vfryzr_9r4fmxsm1ggh7xsskg.jpeg"><br><a name="habracut"></a><br>  Pos disiapkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anna Melekhova</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vladimir Lapatin</a> <br><br>  <b>Layanan microser.</b>  Saat mengembangkan Acronis Cyber ​​Cloud, kami menyadari bahwa kami tidak dapat menghindarinya.  Dan merancang sebuah layanan mikro tidak mungkin tanpa memformalkan kontrak, yang merupakan antarmuka dari layanan mikro. <br><br>  Tetapi ketika suatu produk mengandung lebih dari satu komponen, dan pengembangan kontrak menjadi kegiatan rutin, Anda tanpa sadar mulai berpikir untuk mengoptimalkan proses.  Menjadi jelas bahwa antarmuka (kontrak) dan implementasi (layanan mikro) harus saling berhubungan, bahwa komponen yang berbeda harus melakukan hal yang sama, dan bahwa tanpa adopsi terpusat dari semua keputusan ini, masing-masing tim akan dipaksa menghabiskan waktu untuk mendapatkannya lagi dan lagi . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58e/abe/9a0/58eabe9a07a07742389fbc3de927d6a5.jpg" alt="gambar"><br>  <i>Tata letak microservice Amazon dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tweet</a> Werner Vogelis, Amazon CTO</i> <br>  Apa dilema itu?  Secara de facto, ada dua cara microservices berinteraksi - HTTP Rest dan gRPC dari Google.  Tidak ingin terlibat dalam tumpukan teknologi Google, kami memilih HTTP Rest.  Penjelasan untuk kontrak HTTP REST paling sering dijelaskan dalam salah satu dari dua format: RAML dan OAS, sebelumnya dikenal sebagai Swagger. Oleh karena itu, setiap tim pengembangan dihadapkan dengan kebutuhan untuk memilih salah satu standar.  Tapi, ternyata, membuat pilihan ini bisa sangat sulit. <br><br><h3>  Mengapa penjelasan? </h3><br>  Anotasi diperlukan agar pengguna eksternal dapat dengan mudah mengetahui apa yang dapat dilakukan dengan layanan Anda melalui antarmuka HTTP-nya.  Yaitu, pada tingkat dasar, anotasi harus mengandung setidaknya daftar sumber daya yang tersedia, metode HTTP mereka, badan permintaan, enumerasi parameter, indikasi header yang diperlukan dan didukung, serta kode pengembalian dan format respons.  Elemen yang sangat penting dari anotasi kontrak adalah uraian verbal mereka ("apa yang terjadi jika Anda menambahkan parameter kueri ini ke permintaan?", "Dalam hal apa 400 kode akan kembali?") <br><br>  Namun demikian, ketika datang untuk mengembangkan sejumlah besar layanan-mikro, saya ingin memperoleh manfaat tambahan dari anotasi tertulis.  Misalnya, berdasarkan RAML / Swagger, Anda dapat menghasilkan kode klien dan server dalam sejumlah besar bahasa pemrograman.  Anda juga dapat secara otomatis menerima dokumentasi untuk layanan microser dan mengunggahnya ke portal pengembang Anda :). <br><br><img src="https://habrastorage.org/webt/l2/b1/lt/l2b1ltgjao7oeoqqvvrpkv0hnhg.png"><br>  <i>Contoh deskripsi kontrak terstruktur</i> <br><br>  Yang kurang umum adalah praktik pengujian layanan mikro berdasarkan pada deskripsi kontrak.  Jika Anda menulis anotasi dan komponen, maka Anda dapat membuat autotest yang memeriksa kecukupan layanan dengan berbagai jenis data input.  Apakah layanan mengembalikan kode respons yang tidak dijelaskan dalam anotasi?  Apakah ini dapat memproses data yang salah secara sengaja dan salah? <br><br>  Selain itu, implementasi berkualitas tinggi tidak hanya pada kontrak itu sendiri, tetapi juga alat untuk memvisualisasikan anotasi membuatnya lebih mudah untuk bekerja dengan layanan mikro.  Artinya, jika arsitek menggambarkan kontrak secara kualitatif, atas dasar perancang dan pengembang akan menerapkan layanan dalam produk lain tanpa biaya waktu tambahan. <br><br>  Untuk pengoperasian alat tambahan, baik RAML dan OAS memiliki kemampuan untuk menambahkan metadata yang tidak disediakan oleh standar ( <a href="">misalnya, ini dilakukan dalam OAS</a> ). <br><br>  Secara umum, bidang kreativitas dalam penerapan kontrak untuk layanan mikro sangat besar ... setidaknya secara teoritis <br><br><h3>  Perbandingan landak dengan ular </h3><br>  Saat ini, area pengembangan prioritas Acronis adalah pengembangan Acronis Cyber ​​Platform.  Acronis Cyber ​​Platform - ini adalah poin baru integrasi layanan pihak ketiga dengan Acronis Cyber ​​Cloud dan bagian agen.  Meskipun API internal kami yang dijelaskan dalam RAML baik-baik saja dengan kami, kebutuhan untuk menerbitkan API kembali menimbulkan pertanyaan tentang pilihan: standar anotasi mana yang lebih baik digunakan untuk pekerjaan kami? <br><br>  Pada awalnya, tampaknya ada dua solusi - ini adalah pengembangan RAML dan Swagger (atau OAS) yang paling umum.  Namun ternyata ternyata alternatifnya paling tidak bukan 2, melainkan 3 atau lebih. <br><br>  Di satu sisi ada RAML - bahasa yang kuat dan efektif.  Ini mengimplementasikan hierarki dan warisan dengan baik, jadi format ini lebih cocok untuk perusahaan besar yang membutuhkan banyak deskripsi - yaitu, bukan satu produk, tetapi banyak layanan mikro yang memiliki bagian kontrak yang umum - skema otentikasi, tipe data yang sama, badan kesalahan. <br><br>  Tetapi pengembang RAML, Mulesoft, telah bergabung dengan konsorsium Open API yang mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.google.com/url%3Fq%3D">Swagger</a> .  Karena itu, RAML menghentikan pengembangannya.  Untuk membayangkan format acara, bayangkan bahwa pengelola komponen Linux utama mulai bekerja di Microsoft.  Situasi ini menciptakan prasyarat untuk menggunakan Swagger, yang berkembang secara dinamis dan dalam versi terbaru - ketiga - praktis mengejar RAML dalam hal fleksibilitas dan fungsionalitas. <br><br><h3>  Jika bukan karena satu tapi ... </h3><br>  Ternyata, tidak semua utilitas open-source telah diperbarui ke versi OAS 3.0.  Untuk microservices on Go, yang paling penting adalah kurangnya adaptasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-sombong</a> ke versi standar terbaru.  Namun, perbedaan antara Swagger 2 dan Swagger 3 sangat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">besar</a> .  Misalnya, dalam versi ketiga, pengembang: <br><br><ul><li>  deskripsi skema otentikasi yang ditingkatkan </li><li>  dukungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lengkap</a> untuk Skema JSON </li><li>  memompa kemampuan untuk menambahkan contoh </li></ul><br>  Situasinya lucu: ketika memilih standar, Anda perlu mempertimbangkan RAML, Swagger 2 dan Swagger 3 sebagai alternatif yang terpisah.  Namun, hanya Swagger 2 yang memiliki dukungan yang baik untuk toolkit OpenSource.  RAML sangat fleksibel ... dan rumit, dan Swagger 3 kurang didukung oleh komunitas, jadi Anda harus menggunakan alat berpemilik atau solusi komersial, yang biasanya sangat mahal. <br><br>  Pada saat yang sama, jika ada banyak fitur bagus di Swagger, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">editor</a> portal siap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pakai.swagger.io</a> , di mana Anda dapat mengunduh anotasi dan mendapatkan visualisasinya dengan deskripsi, tautan, dan tautan terperinci, maka tidak ada kemungkinan untuk RAML yang lebih mendasar dan kurang ramah.  Ya, Anda dapat mencari sesuatu di antara proyek-proyek di GitHub, menemukan analog di sana dan menyebarkannya sendiri.  Namun, dalam hal apa pun, seseorang harus mendukung portal, yang tidak begitu nyaman untuk penggunaan dasar atau kebutuhan pengujian.  Selain itu, kesombongan lebih "tidak berprinsip", baik, atau liberal - itu dapat dihasilkan dari komentar dalam kode, yang, tentu saja, bertentangan dengan prinsip API terlebih dahulu dan tidak didukung oleh salah satu utilitas RAML, <br><br>  Pada suatu waktu, kami mulai bekerja dengan RAML sebagai bahasa yang lebih fleksibel, dan sebagai hasilnya, kami harus melakukan banyak hal dengan tangan kami sendiri.  Sebagai contoh, salah satu proyek menggunakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ramlfications</a> dalam pengujian unit, yang hanya mendukung RAML 0.8.  Jadi saya harus menambahkan kruk sehingga utilitas bisa "memakan" RAML versi 1.0. <br><br><h3>  Apakah saya perlu memilih? </h3><br>  Setelah terlibat dalam menambahkan ekosistem solusi untuk RAML, kami sampai pada kesimpulan bahwa kami perlu mengkonversi RAML ke Swagger 2 dan sudah melakukan semua otomatisasi, verifikasi, pengujian, dan optimasi selanjutnya di dalamnya.  Ini adalah cara yang baik untuk memanfaatkan fleksibilitas RAML dan dukungan alat komunitas dari Swagger. <br><br>  Untuk mengatasi masalah ini, ada dua alat OpenSource yang harus memastikan konversi kontrak: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oas-raml-converter</a> sekarang menjadi utilitas yang tidak didukung.  Dalam proses bekerja dengannya, kami menemukan bahwa ia memiliki sejumlah masalah dengan RAML kompleks yang "tersebar" di sejumlah besar file.  Program ini ditulis dalam JavaScript dan melakukan traversal rekursif dari pohon sintaks.  Karena pengetikan dinamis, menjadi sulit untuk memahami kode ini, jadi kami memutuskan untuk tidak membuang waktu menulis tambalan untuk utilitas yang sekarat. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webapi-parser</a> adalah alat dari perusahaan yang sama, yang mengklaim siap untuk mengubah segalanya dan segalanya, dan ke segala arah.  Sampai saat ini, dukungan untuk RAML 0.8, RAML 1.0, dan Swagger 2.0 telah diumumkan.  Namun, pada saat penelitian kami, utilitas itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SANGAT</a> kasar dan tidak dapat digunakan.  Pengembang membuat semacam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IR</a> , yang akan memungkinkan mereka untuk dengan cepat menambah standar baru di masa depan.  Tetapi untuk sekarang, semua ini tidak berhasil. </li></ol><br>  Dan ini bukan semua kesulitan yang kita hadapi.  Salah satu langkah dalam saluran kami adalah untuk memverifikasi bahwa RAML dari repositori sudah benar sehubungan dengan spesifikasi.  Kami mencoba beberapa utilitas.  Yang mengejutkan, mereka semua memaki-maki anotasi kami di tempat berbeda dan dengan kata-kata buruk yang sama sekali berbeda.  Dan tidak selalu demikian :). <br><br>  Pada akhirnya, kami memutuskan pada proyek yang sekarang usang, yang juga memiliki sejumlah masalah (kadang-kadang jatuh tiba-tiba, memiliki masalah ketika bekerja dengan ekspresi reguler).  Jadi, kami tidak menemukan cara untuk menyelesaikan tugas validasi dan konversi berdasarkan alat gratis, dan memutuskan untuk menggunakan utilitas komersial.  Di masa depan, ketika alat OpenSource menjadi lebih berkembang, menyelesaikan masalah ini mungkin menjadi lebih mudah.  Sementara itu, waktu dan tenaga yang terlibat dalam "penyelesaian" bagi kami tampaknya lebih signifikan daripada biaya layanan komersial. <br><br><h3>  Kesimpulan </h3><br>  Setelah semua ini, kami ingin berbagi pengalaman kami dan perhatikan bahwa sebelum memilih alat untuk menggambarkan kontrak, Anda perlu menentukan dengan jelas apa yang Anda inginkan darinya dan anggaran apa yang siap Anda investasikan.  Jika Anda lupa tentang OpenSource, sekarang ada sejumlah besar layanan dan produk yang akan membantu Anda memeriksa, mengubah, memvalidasi.  Tetapi mereka mahal, dan terkadang sangat mahal.  Untuk perusahaan besar, biaya seperti itu bisa ditoleransi, tetapi untuk startup, itu bisa menjadi beban besar. <br><br>  Tentukan seperangkat alat yang akan Anda gunakan nanti.  Misalnya, jika Anda hanya perlu menampilkan kontrak, akan lebih mudah menggunakan Swagger 2, yang memiliki API yang indah, karena dalam RAML Anda harus mengangkat dan mengelola layanan sendiri. <br>  Semakin banyak tugas yang Anda miliki, semakin luas kebutuhan alat, dan mereka akan berbeda untuk platform yang berbeda, dan lebih baik segera membiasakan diri dengan versi yang tersedia untuk membuat pilihan yang meminimalkan biaya Anda di masa depan. <br><br>  Tetapi perlu diakui bahwa semua ekosistem yang ada saat ini tidak sempurna.  Karena itu, jika perusahaan memiliki penggemar yang suka bekerja di RAML, karena "itu memungkinkan Anda untuk mengekspresikan pikiran Anda lebih fleksibel", atau, sebaliknya, lebih suka Swagger, karena "itu lebih dimengerti", yang terbaik adalah membiarkan mereka bekerja dalam apa yang mereka inginkan. mereka terbiasa dan ingin, karena toolkit dari format apa pun perlu diselesaikan dengan file. <br><br>  Mengenai pengalaman kami, dalam posting berikut ini kami akan berbicara tentang pemeriksaan statis dan dinamis seperti apa yang kami lakukan berdasarkan arsitektur RAML-Swagger kami, serta dokumentasi apa yang kami hasilkan dari kontrak, dan bagaimana semuanya bekerja. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466691/">https://habr.com/ru/post/id466691/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466679/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari ke 49. Pengantar EIGRP</a></li>
<li><a href="../id466681/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 50. Mengkonfigurasi EIGRP</a></li>
<li><a href="../id466683/index.html">Acara digital di Moskow 9-15 September</a></li>
<li><a href="../id466685/index.html">Melihat uang</a></li>
<li><a href="../id466689/index.html">Cara membuat kelas karakter di MMO Action seluler</a></li>
<li><a href="../id466693/index.html">Jika Anda masuk bukan di IT</a></li>
<li><a href="../id466697/index.html">Monad di Erlang</a></li>
<li><a href="../id466699/index.html">Menjinakkan protokol kepercayaan - OAuth otentikasi dengan InterSystems IRIS</a></li>
<li><a href="../id466701/index.html">Let's Encrypt melayani hampir 30% domain</a></li>
<li><a href="../id466705/index.html">Vivaldi Beta untuk Android - Browser Asli</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>