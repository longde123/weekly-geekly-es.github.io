<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏼 🏩 🏿 C ++ 14中的咖喱和部分应用 🚶🏿 😚 🍴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将向您介绍我个人最喜欢的C ++函数的一些可变选项和部分应用。 我还将展示我自己对此事的初步实现，并解释了无需复杂数学公式即可进行计算的关键点，这对您来说真的很简单。 我们还将看到kari.hpp库的内幕 ，该库将用于currying函数。 无论如何，里面有很多有趣的东西，欢迎您！ 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ 14中的咖喱和部分应用</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436488/"><p> 在本文中，我将向您介绍我个人最喜欢的C ++函数的一些可变选项和部分应用。 我还将展示我自己对此事的初步实现，并解释了无需复杂数学公式即可进行计算的关键点，这对您来说真的很简单。 我们还将看到<a href="" title="kari.hpp">kari.hpp</a>库的<a href="" title="kari.hpp">内幕</a> ，该库将用于currying函数。 无论如何，里面有很多有趣的东西，欢迎您！ </p><a name="habracut"></a><br><h2 id="currying"> 咖喱 </h2><br><p> 那么，这是什么？ 我猜这是您一直从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="哈斯克尔">Haskell</a>程序员那里听到的那些话之一（当然，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="莫纳德">monad</a>之后）。 从本质上讲，该术语的定义非常简单，因此，那些已经使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="ML">ML</a>类型语言或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="哈斯克尔">Haskell</a>编写过代码的读者，或者从其他地方知道其含义的读者，可以随时跳过此部分。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="咖喱">Currying-</a>是将一个函数转换为一个函数，该函数将N个参数转换为一个函数，该函数将单个参数转换为下一个参数的函数，然后继续执行，直到返回最后一个参数的函数为止。总体结果。 我向您展示示例对我有帮助： </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rhs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }</code> </pre> <br><p> 这里我们有一个二进制加法函数。 如果我们想将其变成单变量函数呢？ 实际上非常简单： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curried_sum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lhs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum2(lhs, rhs); }; }</code> </pre> <br><p> 不，我们做了什么？ 我们基于一个称为lambda的参数获取了一个值，该参数又接受了第二个参数并自行执行加法。 结果，我们可以将咖喱函数<strong><code>curried_sum2</code></strong>应用于我们的参数： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; sum2(40, 2) &lt;&lt; std::endl; std::cout &lt;&lt; curried_sum2(40)(2) &lt;&lt; std::endl;</span></span></code> </pre> <br><p> 实际上，这就是所有操作的重点。 当然，可以使用任何工具的功能来实现它-它的工作方式完全相同。 每当我们从另一个参数中获取值时，我们将返回一个N-1个参数的咖喱函数： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curried_sum3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v2){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v3){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum3(v1, v2, v3); }; }; } <span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; sum3(38, 3, 1) &lt;&lt; std::endl; std::cout &lt;&lt; curried_sum3(38)(3)(1) &lt;&lt; std::endl;</span></span></code> </pre> <br><h2 id="partial-application"> 部分申请 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="部分申请">部分应用程序</a> -一种调用N个参数的函数的方法，当它们仅接收一部分参数并返回其余参数的另一个函数时。 </p><br><p> 在这方面，应该注意的是，在类似Haskell的语言中，此过程在程序员的支持下自动运行。 我们在这里要做的是显式地执行它， <strong><code>sum3</code></strong>像这样调用<strong><code>sum3</code></strong>函数： <strong><code>sum3(38,3)(1)</code></strong>或也许这样： <strong><code>sum3(38)(3,1)</code></strong> 。 最重要的是，如果一个函数返回了另一个已被管理的函数，则也可以使用第一个函数的参数列表来调用它。 让我们来看一个例子： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> kari::curry(boo, v1 + v2); } <span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; kari::curry(foo)(38,3,1) &lt;&lt; std::endl; std::cout &lt;&lt; kari::curry(foo)(38,3)(1) &lt;&lt; std::endl; std::cout &lt;&lt; kari::curry(foo)(38)(3,1) &lt;&lt; std::endl;</span></span></code> </pre> <br><p> 实际上，我们在这里展示了<a href="" title="kari.hpp">kari.hpp</a>用法的示例，因此它确实<a href="" title="kari.hpp">领先一步</a> 。 </p><br><h2 id="setting-the-goals"> 设定目标 </h2><br><p> 在我们写点东西之前，有必要（或希望）理解我们最终想要拥有的东西。 而且我们希望有一个机会来咖喱和部分应用可以在C ++中调用的任何函数。 分别是： </p><br><ul><li>  Lambda（包括通用Lambda） </li><li> 功能对象（功能部件） </li><li> 任何工具的功能（包括模板） </li><li> 可变函数 </li><li> 一类的方法 </li></ul><br><p> 可变参数函数可以通过指定我们想要使用的参数的确切数目来使用。 与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="std ::绑定">std :: bind</a>及其结果的标准交互也是可取的。 当然，我们需要一个机会来应用多个变量函数并调用嵌套函数，这样看来我们一直在使用一个库里函数。 </p><br><p> 我们也不能忘记性能。 我们需要最小化包装程序，参数传递及其存储的计算成本。 这意味着我们必须移动而不是复制，仅存储我们真正需要的东西，并尽可能快地返回（进一步删除）数据。 </p><br><h3 id="author-youve-been-trying-to-invent-stdbind-one-again"> 作者，您一直在尝试发明<strong><code>std::bind</code></strong>再次<strong><code>std::bind</code></strong>一个！ </h3><br><p> 是的，没有。  <strong><code>std::bind</code></strong>无疑是一个功能强大且久经考验的工具，我无意编写其杀手or或其他替代品。 是的，它可以用于周期性和显式的局部应用（确切指定我们要应用的参数，应用的位置和数量）。 但这肯定不是最方便的方法，更不用说它并不总是适用，因为我们必须了解功能的多样性并据此编写特定的绑定。 例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3 + v4; } <span class="hljs-comment"><span class="hljs-comment">// std::bind auto c0 = std::bind(foo, _1, _2, _3, _4); auto c1 = std::bind(c0, 15, _1, _2, _3); auto c2 = std::bind(c1, 20, 2, _1); auto rr = c2(5); std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42 // kari.hpp auto c0 = kari::curry(foo); auto c1 = c0(15); auto c2 = c1(20, 2); auto rr = c2(5); std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42</span></span></code> </pre> <br><h2 id="api">  API </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_curried</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_curried_v = is_curried&lt;F&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... As &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(As&amp;&amp;... as)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; }</code> </pre> <br><hr><br><p> <strong><code>kari::curry(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p> 返回具有<strong><code>curry_t</code></strong>类型的函数对象（一个<strong><code>curry_t</code></strong>函数），该函数对象应用了可选参数<strong><code>args</code></strong>或将参数应用于给定函数<strong><code>f</code></strong> （该函数为空值，或者所传递的参数足以调用它）。 </p><br><p> 如果<strong><code>f</code></strong>参数包含已被调用的函数，则它将返回其副本并应用参数<strong><code>args</code></strong> 。 </p><br><hr><br><p> <strong><code>kari::curryV(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p> 允许使用可变数量的参数来处理函数。 之后，可以使用不带参数的<strong><code>()</code></strong>运算符来调用这些函数。 例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curryV(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c2 = c1(<span class="hljs-number"><span class="hljs-number">42</span></span>); c2(); <span class="hljs-comment"><span class="hljs-comment">// output: 37 + 5 = 42</span></span></code> </pre> <br><p> 如果<strong><code>f</code></strong>参数包含已被调用的函数，则它将为应用了<strong><code>args</code></strong>参数的可变数量的参数返回其副本，该副本的应用程序类型已更改。 </p><br><hr><br><p> <strong><code>kari::curryN(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p> 通过指定我们要应用的确切数量<strong><code>N</code></strong>的参数（ <strong><code>args</code></strong>给出的<strong><code>args</code></strong>除外），允许使用可变数量的参数来处理函数。 例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">256</span></span>] = {<span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = kari::curryN&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>, buffer, <span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); c(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; buffer &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output: 37 + 5 = 42</span></span></code> </pre> <br><p> 如果<strong><code>f</code></strong>参数包含已被调用的函数，则它将返回其副本，其中应用了<strong><code>args</code></strong> N个参数的应用程序类型已更改。 </p><br><hr><br><p> <strong><code>kari::is_curried&lt;F&gt;, kari::is_curried_v&lt;F&gt;</code></strong> </p> <br><p> 一些辅助功能，用于检查功能是否已被处理。 例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> l = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v1, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v2){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = curry(l); <span class="hljs-comment"><span class="hljs-comment">// output: is `l` curried? no std::cout &lt;&lt; "is `l` curried? " &lt;&lt; (is_curried&lt;decltype(l)&gt;::value ? "yes" : "no") &lt;&lt; std::endl; // output: is `c` curried? yes std::cout &lt;&lt; "is `c` curried? " &lt;&lt; (is_curried_v&lt;decltype(c)&gt; ? "yes" : "no") &lt;&lt; std::endl;</span></span></code> </pre> <br><hr><br><p> <strong><code>kari::curry_t::operator()(As&amp;&amp;... as)</code></strong> </p> <br><p> 允许全部或部分应用咖喱函数的操作员。 返回初始函数<strong><code>F</code></strong>的剩余参数的curried函数，或者返回该函数在旧参数和新参数的积压后由其应用获得的值。 例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3 + v4; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curry(foo); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">// partial application auto rr = c1(2, 5); // function call - foo(15,20,2,5) std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42</span></span></code> </pre> <br><p> 如果使用<strong><code>curryV</code></strong>或<strong><code>curryN</code></strong>调用不带任何参数的<strong><code>curryV</code></strong> <strong><code>curryN</code></strong> ，则在有足够的参数时将调用该函数。 否则，它将返回部分应用的函数。 例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curryV(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c2 = c1(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// force call variadic function std::printf c2(); // output: 37 + 5 = 42</span></span></code> </pre> <br><h2 id="details-of-implementation"> 实施细节 </h2><br><p> 在向您提供实现的详细信息时，我将使用C ++ 17，以使文章简短，避免不必要的解释和堆积的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="FINAE">SFINAE</a> ，以及我必须在C ++中添加的实现示例。 14标准。 您可以在项目<a href="" title="kari.hpp">存储库中</a>找到所有这些文件，也可以将它们添加到收藏夹中：) </p><br><hr><br><p> <strong><code>make_curry(F&amp;&amp; f, std::tuple&lt;Args...&gt;&amp;&amp; args)</code></strong> </p> <br><p> 创建函数对象<strong><code>curry_t</code></strong>或将给定函数<strong><code>f</code></strong>应用于参数<strong><code>args</code></strong>的辅助函数。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;Args...&gt;&amp;&amp; args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( N == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_invocable_v&lt;F, Args...&gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(args)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">curry_t</span></span>&lt; N, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;F&gt;, Args... &gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(args)); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_curry&lt;N&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple()); }</code> </pre> <br><p> 现在，关于此函数有两个有趣的事情： </p><br><ul><li> 仅当可调用这些参数并且应用程序计数器<strong><code>N</code></strong>为零时，我们才将其应用于参数 </li><li> 如果该函数不可调用，则将该调用视为部分应用程序，并创建一个包含该函数和参数的函数对象<strong><code>curry_t</code></strong> </li></ul><br><hr><br><p> <strong><code>struct curry_t</code></strong> </p> <br><p> 应该存储该函数的待办事项的函数对象以及最终应用该函数时将调用的函数。 这个对象就是我们将要调用并部分应用的对象。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry_t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U&amp;&amp; u, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;Args...&gt;&amp;&amp; args)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;U&gt;(u))</span></span></span><span class="hljs-function"> , </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(args))</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: F f_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args...&gt; args_; };</code> </pre> <br><p> 我们将参数<strong><code>args_</code></strong>的积压存储在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="性病::元组">std :: tuple中</a>有很多原因： </p><br><p>  1）带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="std ::参考">std :: ref的情况</a>会在需要时自动处理以存储引用，默认情况下基于值 <br>  2）根据函数的参数方便地应用函数（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="性病::适用">std :: apply</a> ） <br>  3）它是现成的，所以您不必从头开始编写它:) </p><br><p> 我们还存储了我们调用的对象和函数<strong><code>f_</code></strong>的值，并在创建一个对象（在下面的问题中对此进行扩展），移动或使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="通用参考">通用引用</a>复制时选择类型时要小心。构造函数。 </p><br><p> 模板参数<strong><code>N</code></strong>用作可变函数的应用计数器。 </p><br><hr><br><p> <strong><code>curry_t::operator()(const As&amp;...)</code></strong> </p> <br><p> 当然，使之全部起作用的是-调用函数对象的运算符。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1 constexpr decltype(auto) operator()() &amp;&amp; { return detail::make_curry&lt;0&gt;( std::move(f_), std::move(args_)); } // 2 template &lt; typename A &gt; constexpr decltype(auto) operator()(A&amp;&amp; a) &amp;&amp; { return detail::make_curry&lt;(N &gt; 0 ? N - 1 : 0)&gt;( std::move(f_), std::tuple_cat( std::move(args_), std::make_tuple(std::forward&lt;A&gt;(a)))); } // 3 template &lt; typename A, typename... As &gt; constexpr decltype(auto) operator()(A&amp;&amp; a, As&amp;&amp;... as) &amp;&amp; { return std::move(*this)(std::forward&lt;A&gt;(a))(std::forward&lt;As&gt;(as)...); } // 4 template &lt; typename... As &gt; constexpr decltype(auto) operator()(As&amp;&amp;... as) const &amp; { auto self_copy = *this; return std::move(self_copy)(std::forward&lt;As&gt;(as)...); } }</span></span></code> </pre> <br><p> 调用操作员有四个功能已重载。 </p><br><ol><li><p> 没有参数的函数不允许开始应用可变函数（由<strong><code>curryV</code></strong>或<strong><code>curryN</code></strong>创建）。 在这里，我们将应用程序计数器递减为零，以明确表明该函数已准备就绪，可以应用了，然后将<strong><code>make_curry</code></strong>函数所需的所有内容提供给了该函数。 </p><br></li><li><p> 单个参数的功能，将应用程序计数器减1（如果不为零），并将我们的新参数<strong><code>a</code></strong>放入参数<strong><code>args_</code></strong>的积压中，并将所有这些都传递给<strong><code>make_curry</code></strong> 。 </p><br></li><li><p> 可变参数函数，实际上是部分应用各种参数的技巧。 它的作用是将它们递归地一对一地应用。 现在，有两个原因导致无法一次全部应用它们： </p><br><ul><li> 在没有剩余参数之前，应用程序计数器可以降为零 </li><li> 可以更早地调用函数<strong><code>f_</code></strong>并返回另一个咖喱函数，因此所有下一个参数都将用于该函数 </li></ul><br></li><li><p> 最后一个函数充当使用<em>lvalue</em>调用<strong><code>curry_t</code></strong>和使用<em>rvalue</em>调用函数之间的桥梁。 </p><br></li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Ref合格">带有ref限定</a>功能的标签使整个过程几乎神奇。 简而言之，在他们的帮助下，我们知道使用<em>右值</em>引用调用了一个对象，我们可以移动参数，而不必在最终调用函数<strong><code>make_curry</code></strong> 。 否则，我们将不得不复制参数，以便仍然有机会再次调用此函数，确保参数仍然存在。 </p><br><h2 id="bonuses"> 红利 </h2><br><p> 在得出结论之前，我想向您展示他们在<a href="" title="kari.hpp">kari.hpp</a>中具有的语法糖的几个示例，这些示例可以作为奖励。 </p><br><h3 id="operator-sections"> 操作员部分 </h3><br><p> 已经与Haskell进行过合作的程序员应该熟悉运算符部分，以便对所使用的运算符进行简短描述。 例如，结构<strong><code>(*2)</code></strong>生成一个单参数函数，返回该参数乘以2的结果。因此，我想要的是尝试用C ++编写类似的东西。 快说不做！ </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari::underscore; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::accumulate(v.begin(), v.end(), <span class="hljs-number"><span class="hljs-number">0</span></span>, _+_); <span class="hljs-comment"><span class="hljs-comment">// result: 15 std::transform(v.begin(), v.end(), v.begin(), _*2); // v = 2, 3, 6, 8, 10 std::transform(v.begin(), v.end(), v.begin(), -_); // v = -2,-3,-6,-8,-10</span></span></code> </pre> <br><h3 id="function-composition"> 功能组成 </h3><br><p> 当然，如果我没有尝试写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="功能组成">函数组合的</a>话，我也不会是一个完整的人。 作为合成运算符，我选择了<strong><code>operator *</code></strong>作为该合成符号在数学中可用的所有符号中最接近的符号（从外观看）。 我也使用它来将结果函数应用于参数。 所以，这就是我得到的： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari::underscore; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; (_*2) * (_+2) * 4 &lt;&lt; std::endl; // output: 12 // 2 std::cout &lt;&lt; 4 * (_*2) * (_+2) &lt;&lt; std::endl; // output: 10</span></span></code> </pre> <br><ol><li> 函数<strong><code>(*2)</code></strong>和<strong><code>(+2)</code></strong>的组合应用于<strong><code>4</code></strong> 。 <strong><code>(4 + 2) * 2 = 12</code></strong> </li><li> 函数<strong><code>(*2)</code></strong>应用于<strong><code>4</code></strong> ，然后我们将<strong><code>(+2)</code></strong>应用于结果。 <strong><code>(4 * 2 + 2) = 10</code></strong> </li></ol><br><p> 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="无点风格">无点样式</a>构建非常复杂的合成的相同方法，但请记住，只有Haskell程序员才能理解这些内容：) </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// (. (+2)) (*2) $ 10 == 24 // haskell analog std::cout &lt;&lt; (_*(_+2))(_*2) * 10 &lt;&lt; std::endl; // output: 24 // ((+2) .) (*2) $ 10 == 22 // haskell analog std::cout &lt;&lt; ((_+2)*_)(_*2) * 10 &lt;&lt; std::endl; // output: 22</span></span></code> </pre> <br><h2 id="conclusion"> 结论 </h2><br><p> 我认为很明显，在实际项目中无需使用这些技术。 但是，我必须提一下。 毕竟，我的目标是证明自己并检查新的C ++标准。 我可以这样做吗？ 而C ++吗？ 好吧，我想，您刚刚看到我们俩都做到了。 我真的很感谢阅读整本书的所有人。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436488/">https://habr.com/ru/post/zh-CN436488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436476/index.html">保险云</a></li>
<li><a href="../zh-CN436480/index.html">我为自己制作了一个与招聘人员交流的机器人，我很喜欢</a></li>
<li><a href="../zh-CN436482/index.html">高级Three.js：着色器材质和后处理</a></li>
<li><a href="../zh-CN436484/index.html">在MacOS上哪里可以找到DNS设置</a></li>
<li><a href="../zh-CN436486/index.html">音频播客市场正在发生什么</a></li>
<li><a href="../zh-CN436490/index.html">摩托罗拉计划推出Razr v3版本</a></li>
<li><a href="../zh-CN436492/index.html">我们正在寻找第十届DIY Mitap的演讲者2019年2月17日</a></li>
<li><a href="../zh-CN436494/index.html">更换磁盘同时保持CEPH中的正确编号</a></li>
<li><a href="../zh-CN436496/index.html">PVS-Studio for Java</a></li>
<li><a href="../zh-CN436498/index.html">Software AG：不仅是ARIS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>