<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗻 👨🏾‍🎤 ❗️ Tampilan dan optimalisasi output terminal di web 👸🏻 🤴🏽 👆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Belum lama ini, saya menemukan tugas yang agak sederhana dan sekaligus menarik: mengimplementasikan terminal read-only dalam aplikasi web. Ketertarika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tampilan dan optimalisasi output terminal di web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448030/"><p>  Belum lama ini, saya menemukan tugas yang agak sederhana dan sekaligus menarik: mengimplementasikan terminal read-only dalam aplikasi web.  Ketertarikan pada tugas diberikan oleh tiga aspek penting: </p><br><ul><li>  dukungan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">urutan pelarian</a> dasar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ANSI</a> </li><li>  mendukung setidaknya 50.000 jalur data </li><li>  menampilkan data begitu tersedia. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ku/fa/rk/kufarkakkmxskpfqqokeixh_ste.png"></div><br><p>  Pada artikel ini saya akan berbicara tentang bagaimana ini diterapkan dan bagaimana kemudian dioptimalkan semuanya. </p><a name="habracut"></a><br><p>  <em>Penafian: Saya bukan pengembang web yang berpengalaman, jadi beberapa hal mungkin terlihat jelas bagi Anda, dan kesimpulan atau keputusannya salah.</em>  <em>Untuk koreksi dan klarifikasi, saya akan berterima kasih.</em> </p><br><h2 id="dlya-chego-eto-zatevalos">  Kenapa terserah </h2><br><p>  Seluruh tugas adalah sebagai berikut: skrip berjalan di server (bash, python, dll) dan menulis sesuatu ke stdout.  Dan kesimpulan ini harus ditampilkan di halaman web saat diterima.  Pada saat yang sama, seharusnya akan terlihat seperti di terminal (dengan pemformatan, transfer kursor, dll.) <br>  Saya tidak mengontrol skrip itu sendiri dan hasilnya dengan cara apa pun dan menampilkannya dalam bentuk murni. </p><br><p>  Tentu saja, antara antarmuka web dan skrip harus ada perantara - server web.  Dan jika tidak untuk menyembunyikan - Saya sudah punya aplikasi web dan server, dan entah bagaimana berfungsi.  Skemanya terlihat seperti ini: <br><img src="https://habrastorage.org/webt/ww/kb/ei/wwkbei13_tv9n6w6vcw_6c4e5dm.png"></p><br><p>  Namun sebelumnya, server bertanggung jawab atas pemrosesan dan pemformatan.  Dan saya ingin memperbaikinya karena sejumlah alasan: </p><br><ul><li>  pemrosesan data ganda - parsing pertama di server, kemudian transformasi menjadi komponen html pada klien </li><li>  algoritma tidak optimal karena persiapan data untuk klien </li><li>  beban berat di server - pemrosesan output dari satu skrip bisa sepenuhnya memuat utas tunggal di server </li><li>  dukungan yang tidak lengkap untuk urutan Escape ANSI </li><li>  bug halus </li><li>  klien melakukannya dengan sangat buruk dengan menampilkan bahkan 10k garis diformat </li></ul><br><p>  Oleh karena itu, diputuskan untuk mentransfer seluruh logika parsing ke aplikasi web, dan hanya menyiarkan data mentah yang mengalir ke server </p><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  Sebagian dari teks tersebut datang ke klien.  Klien harus menguraikannya menjadi komponen: teks biasa, umpan baris, carriage return, dan perintah ANSI khusus.  Tidak ada jaminan dalam integritas bagian - satu perintah atau kata dapat datang dalam paket yang berbeda. </p><br><p>  Perintah ANSI dapat memengaruhi format teks (warna, latar belakang, gaya), posisi kursor (tempat teks selanjutnya akan ditampilkan), atau untuk menghapus bagian layar. <br>  Contoh tampilannya: <br><img src="https://habrastorage.org/webt/5u/3c/tt/5u3cttwmep44kv8c9gysh5bn9ig.png"></p><br><p>  Selain itu, mungkin ada URL di antara teks yang juga perlu dikenali dan disorot. </p><br><h2 id="beryom-gotovuyu-biblioteku-i-">  Kami mengambil perpustakaan yang sudah jadi dan ... </h2><br><p>  Saya mengerti bahwa pemrosesan semua perintah yang benar dan cepat bukanlah tugas yang mudah.  Karena itu, saya memutuskan untuk mencari perpustakaan yang sudah jadi.  Dan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihatlah</a> , aku segera menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xterm.js</a> .  Komponen terminal siap pakai, yang sudah digunakan di banyak tempat dan, di samping itu, <em>"sangat cepat, bahkan termasuk renderer berakselerasi GPU"</em> .  Yang terakhir adalah yang paling penting bagi saya, karena  Saya akhirnya ingin mendapatkan klien yang sangat cepat. </p><br><p>  Terlepas dari kenyataan bahwa saya suka menulis sepeda motor sendiri, saya sangat senang bahwa saya tidak hanya dapat menghemat waktu, tetapi juga mendapatkan banyak fungsi yang berguna secara gratis. </p><br><p>  Butuh jam 2 siang untuk mencoba menghubungkan terminal dan saya <strong>tidak bisa</strong> mengatasinya.  Tentu saja <br>  Ketinggian garis yang berbeda, pemilihan bengkok, ukuran terminal yang adaptif, API yang sangat aneh, kurangnya dokumentasi waras ... </p><br><p>  Tetapi saya masih memiliki sedikit inspirasi dan saya percaya bahwa saya dapat mengatasi masalah ini. <br>  Sampai saya memberi makan garis uji 10k ke terminal ... Dia meninggal.  Dan mengubur sisa-sisa harapan saya. </p><br><h2 id="opisanie-itogovogo-algoritma">  Deskripsi algoritma akhir </h2><br><p>  Pertama-tama, saya menyalin algoritma saat ini diimplementasikan dalam python dan mengadaptasinya untuk javascript (hanya menghapus kurung kurawal dan satu lagi untuk sintaks). </p><br><p>  Saya tahu semua pro dan kontra utama dari algoritma lama, jadi saya hanya perlu meningkatkan tempat yang tidak efektif di dalamnya. </p><br><p>  Setelah musyawarah, coba-coba, saya menetapkan pilihan berikut: kami membagi algoritma menjadi 2 komponen: </p><br><ul><li>  model untuk mem-parsing teks dan menyimpan status "terminal" saat ini </li><li>  pemetaan yang menerjemahkan model ke dalam HTML </li></ul><br><h4 id="model-struktura-i-algoritm">  Model (struktur dan algoritma) </h4><br><ul><li>  Semua baris disimpan dalam array (nomor baris = indeks dalam array) </li><li>  Gaya teks disimpan dalam array yang terpisah. </li><li>  Posisi kursor saat ini disimpan dan dapat diubah dengan perintah </li><li>  Algoritme itu sendiri memeriksa input data karakter dengan karakter: <br><ul><li>  Jika ini hanya teks, tambahkan ke baris saat ini </li><li>  Jika garis terputus, maka tambah indeks baris saat ini </li><li>  Jika ini adalah salah satu karakter perintah, maka kita memasukkannya ke dalam buffer perintah dan menunggu karakter berikutnya </li><li>  Jika buffer perintah sudah benar, maka jalankan perintah ini, jika tidak kita tulis buffer ini sebagai teks </li></ul></li><li>  Model ini memberi tahu pendengar tentang baris mana yang telah berubah setelah pemrosesan teks yang masuk </li></ul><br><p>  Dalam implementasi saya, kompleksitas algoritma adalah O ( <em>n</em> log <em>n</em> ), di mana log <em>n</em> adalah persiapan baris yang diubah untuk pemberitahuan (keunikan dan penyortiran).  Pada saat penulisan ini, saya menyadari bahwa untuk kasus khusus, Anda dapat menghilangkan log <em>n</em> , karena garis paling sering ditambahkan ke akhir. </p><br><h4 id="otobrazhenie">  Tampilan </h4><br><ul><li>  Menampilkan teks sebagai elemen HTML </li><li>  Jika string telah berubah, ganti sepenuhnya semua elemen string </li><li>  Memecah setiap baris berdasarkan gaya: setiap segmen yang bergaya memiliki elemennya sendiri </li></ul><br><p>  Dengan struktur seperti itu, pengujian adalah tugas yang cukup sederhana - kami mentransfer teks ke model (dalam satu paket atau bagian) dan hanya memeriksa keadaan saat ini dari semua baris dan gaya di dalamnya.  Dan untuk menampilkan hanya beberapa tes, karena  selalu menggambar ulang garis yang diubah. </p><br><p>  Keuntungan penting juga kemalasan tampilan tertentu.  Jika dalam satu bagian teks kita menimpa baris yang sama (misalnya, progress bar), maka setelah model bekerja, untuk tampilan akan terlihat seperti satu baris yang diubah. </p><br><h4 id="dom-vs-canvas">  DOM vs Kanvas </h4><br><p>  Saya ingin sedikit membahas mengapa saya memilih DOM, meskipun tujuannya adalah kinerja.  Jawabannya sederhana - kemalasan.  Bagi saya, merender semua yang ada di Canvas sendiri sepertinya tugas yang cukup menakutkan.  Sambil mempertahankan kegunaan: menyoroti, menyalin, mengubah ukuran layar, tampak rapi, dll.  Contoh xterm.js dengan jelas menunjukkan kepada saya bahwa ini tidak mudah sama sekali.  Render mereka di kanvas jauh dari ideal. </p><br><p>  Selain itu, men-debug pohon DOM di browser dan kemampuan untuk menutupi tes unit merupakan keuntungan penting. </p><br><p>  Pada akhirnya, tujuan saya adalah 50k baris, dan saya tahu bahwa DOM harus berurusan dengan ini, berdasarkan karya algoritma lama. </p><br><h2 id="optimizacii">  Optimalisasi </h2><br><p>  Algoritma sudah siap, debugged, dan perlahan tapi pasti berhasil.  Sudah waktunya untuk membuka profiler dan mengoptimalkan.  Ke depan, saya akan mengatakan bahwa sebagian besar optimasi adalah kejutan bagi saya (seperti biasanya terjadi). </p><br><p>  Pembuatan profil dilakukan pada garis 10k, yang masing-masing berisi elemen bergaya.  Jumlah total elemen DOM adalah sekitar 100rb. </p><br><p>  Tidak ada pendekatan dan alat khusus yang digunakan.  Hanya Alat Dev Chrome dan beberapa peluncuran untuk setiap pengukuran.  Dalam praktiknya, hanya nilai pengukuran absolut (berapa detik untuk menyelesaikan) berbeda dalam peluncuran, tetapi tidak rasio persentase antara metode.  Karena itu, saya menganggap teknik ini cukup kondisional. </p><br><p>  Di bawah ini saya ingin membahas lebih rinci tentang peningkatan yang paling menarik.  Dan sebagai permulaan, grafik dari apa yang sebelumnya: <br><img src="https://habrastorage.org/webt/me/xk/ot/mexkotdhezc4pwxhw4xczkzv9ie.png"></p><br><p>  <em>Semua gambar profil dibuat setelah implementasi, dengan deoptimisasi kode dari memori.</em> </p><br><h4 id="stringtrim">  string.trim </h4><br><p>  Pertama-tama, saya menemukan string.trim yang tidak dapat dimengerti yang menghabiskan jumlah CPU yang sangat nyata (menurut saya ini sekitar 10-20%) <br><img src="https://habrastorage.org/webt/ue/nq/6b/uenq6brmlm8fxzxxjklulp7ccly.png"></p><br><p>  trim () adalah fungsi dasar bahasa.  Mengapa menggunakan semacam perpustakaan?  Dan bahkan jika itu semacam polyfill, lalu mengapa itu menghidupkan versi terbaru dari chrome? </p><br><p> Sedikit googling dan jawabannya ditemukan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://babeljs.io/docs/en/babel-preset-env</a> .  Secara default, ini memungkinkan polyfill untuk sejumlah besar browser, dan melakukan ini pada tahap kompilasi.  Solusi bagi saya adalah menentukan <code>'targets': '&gt; 0.25%, not dead'</code> <br>  Tetapi pada akhirnya, saya menghapus panggilan trim sepenuhnya, karena tidak perlu. </p><br><h4 id="vuejs">  Vue.js </h4><br><p>  Tahun lalu, saya mentransfer komponen terminal ke Vue.js.  Sekarang saya harus mentransfernya kembali ke vanilla, alasannya ada di tangkapan layar di bawah ini (lihat jumlah baris yang melibatkan Vue.js): </p><br><p><img src="https://habrastorage.org/webt/ll/oq/i8/lloqi8k2igkme2q616eooswyogg.png"></p><br><p>  Saya hanya menyisakan pembungkus, gaya, dan pemrosesan mouse di komponen Vue.  Semua yang berhubungan dengan pembuatan elemen DOM telah menjadi JS murni, yang terhubung ke komponen Vue sebagai bidang normal (yang tidak dipantau oleh kerangka kerja). </p><br><pre> <code class="plaintext hljs">created() { this.terminalModel = new TerminalModel(); this.terminal = new Terminal(this.terminalModel); },</code> </pre> <br><p>  Saya tidak menganggap ini minus atau cacat pada Vue.js.  Hanya saja kerangka kerja dan kinerjanya sendiri tidak tercampur dengan baik.  Nah, ketika Anda menjatuhkan puluhan dan ratusan ribu objek ke dalam kerangka kerja reaktif, sangat sulit untuk mengharapkan pemrosesan darinya dalam beberapa milidetik.  Dan sejujurnya, saya bahkan terkejut bahwa Vue.js melakukannya dengan cukup baik. </p><br><h4 id="dobavlenie-novyh-elementov">  Menambahkan Item Baru </h4><br><p>  Semuanya sederhana di sini - jika Anda memiliki beberapa ribu elemen baru dan Anda ingin menambahkannya ke komponen induk, melakukan appendChild bukanlah ide yang baik.  Browser harus melakukan pemrosesan sedikit lebih sering dan menghabiskan lebih banyak waktu untuk rendering.  Salah satu efek samping dalam kasus saya adalah perlambatan autoscroll, seperti  itu memaksa penghitungan ulang semua komponen yang ditambahkan. </p><br><p><img src="https://habrastorage.org/webt/v_/5k/uj/v_5kujs_plen-j5zoxhq0ixv9um.png"></p><br><p>  Untuk mengatasi masalah, ada DocumentFragment.  Pertama, kita menambahkan semua elemen ke dalamnya, dan kemudian kita menambahkannya ke komponen induk.  Browser akan menangani inline dari komponen yang masuk. </p><br><p>  Pendekatan ini mengurangi jumlah waktu yang dihabiskan browser untuk merender dan mengatur elemen. <br>  Saya juga mencoba cara lain untuk mempercepat penambahan item.  Tak satu pun dari mereka yang dapat menambahkan apa pun di atas DocumentFragment. </p><br><h4 id="span-vs-div">  span vs div </h4><br><p>  Bahkan, ini bisa disebut <code>display:inline</code> (span) vs <code>display:block</code> (div). </p><br><p>  Awalnya, saya memiliki setiap baris dalam rentang dan berakhir dengan karakter baris istirahat.  Namun, dalam hal kinerja, ini tidak terlalu efektif: browser harus mencari tahu di mana elemen dimulai dan berakhir.  Dengan tampilan: blok, perhitungan seperti itu jauh lebih sederhana. </p><br><p>  Mengganti dengan div mempercepat rendering hampir 2 kali. </p><br><p>  Sayangnya, dalam hal <code>display:block</code> menyoroti beberapa baris teks terlihat lebih buruk: </p><br><p><img src="https://habrastorage.org/webt/dm/kj/nq/dmkjnq9up61pc-ic0jalnfi3jw8.png"></p><br><p>  Untuk waktu yang lama saya tidak bisa memutuskan mana yang lebih baik - render 2 detik tambahan atau seleksi manusia.  Akibatnya, kepraktisan mengalahkan kecantikan. </p><br><h4 id="master-css-10-go-urovnya">  Level 10 CSS Wizard </h4><br><p>  Lain ~ 10% dari waktu rendering terputus oleh CSS "optimasi", yang saya gunakan untuk memformat teks. </p><br><p>  Pengalaman dalam pengembangan web dan pemahaman tentang dasar-dasar bermain melawan saya.  Saya berpikir bahwa semakin akurat penyeleksi, semakin baik, tetapi khusus dalam kasus saya, ini tidak begitu. </p><br><p>  Untuk memformat teks di terminal, saya menggunakan pemilih berikut: </p><br><pre> <code class="plaintext hljs">#script-panel-container .log-content &gt; div &gt; span.text_color_green,</code> </pre> <br><p>  Namun (dalam chrome), opsi berikut ini sedikit lebih cepat: </p><br><pre> <code class="plaintext hljs">span.text_color_green</code> </pre> <br><p>  Saya tidak terlalu suka pemilih ini, karena  terlalu global, tetapi kinerjanya lebih mahal. </p><br><h4 id="stringsplit">  string.split </h4><br><p>  Jika Anda memiliki deja vu karena salah satu poin sebelumnya, maka itu salah.  Kali ini bukan tentang polyfill, tetapi tentang implementasi standar di chrome: </p><br><p><img src="https://habrastorage.org/webt/i8/jk/lh/i8jklht2lc0hhc9h6p1la3zuk6o.png"></p><br><p>  <em>(Saya membungkus string.split di defSplit sehingga fungsinya muncul di profiler)</em> </p><br><p>  1% adalah hal sepele.  Tetapi pengendara sepeda idealis dalam diriku dihantui.  Dalam kasus saya, split selalu dilakukan satu karakter pada satu waktu dan tanpa pelanggan tetap.  Oleh karena itu, saya menerapkan opsi sederhana.  Inilah hasilnya: </p><br><p><img src="https://habrastorage.org/webt/hu/fd/_r/hufd_rbij0khcfqcudcnpfkjisa.png"></p><br><div class="spoiler">  <b class="spoiler_title">Buka cepat</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">function fastSplit(str, separatorChar) { if (str === '') { return ['']; } let result = []; let lastIndex = 0; for (let i = 0; i &lt; str.length; i++) { const char = str[i]; if (char === separatorChar) { const chunk = str.substr(lastIndex, i - lastIndex); lastIndex = i + 1; result.push(chunk); } } if (lastIndex &lt; str.length) { const lastChunk = str.substr(lastIndex, str.length - lastIndex); result.push(lastChunk); } return result; }</code> </pre> </div></div><br><p>  Saya percaya bahwa setelah ini, mereka diwajibkan untuk membawa saya ke tim Google Chrome tanpa wawancara. </p><br><h4 id="optimizaciya-posleslovie">  Optimasi, kata penutup </h4><br><p>  Optimasi adalah proses tanpa akhir dan sesuatu dapat ditingkatkan tanpa batas.  Terutama mengingat bahwa kasus penggunaan yang berbeda memerlukan optimisasi yang berbeda (dan saling bertentangan). </p><br><p>  Untuk kasus saya, saya memilih use case utama dan mengoptimalkan waktu operasinya dari 15 detik hingga 5 detik.  Tentang ini saya memutuskan untuk berhenti. <br><img src="https://habrastorage.org/webt/ol/ri/j3/olrij3u8nfgpdrbm5-0db4vkpra.png"></p><br><p>  Masih ada beberapa tempat yang saya rencanakan untuk ditingkatkan, tetapi ini berkat pengalaman yang didapat. </p><br><h2 id="bonus-mutacionnoe-testirovanie">  Bonus  Pengujian mutasi. </h2><br><p>  Kebetulan selama beberapa bulan terakhir saya sering menemukan istilah "pengujian mutasional."  Dan saya memutuskan bahwa tugas ini adalah cara yang bagus untuk mencoba binatang ini.  Apalagi setelah saya tidak mendapatkan cakupan kode di Webstorm, untuk tes pada karma. </p><br><p>  Karena teknik dan perpustakaan itu baru bagi saya, saya memutuskan untuk bertahan dengan sedikit darah: untuk menguji hanya satu komponen - model.  Dalam hal ini, Anda dapat dengan jelas menunjukkan file mana yang kami uji, dan suite pengujian mana yang ditujukan untuknya. </p><br><p>  Tetapi apa pun yang dikatakan orang, saya harus mengotak-atik banyak untuk mencapai integrasi dengan karma dan webpack. </p><br><p>  Pada akhirnya, semuanya dimulai dan setelah setengah jam saya melihat hasil yang menyedihkan: sekitar setengah dari mutan bertahan.  Saya membunuh sebagian dengan segera, sebagian lagi untuk masa depan (ketika saya mengimplementasikan perintah ANSI yang hilang). </p><br><p>  Setelah itu, kemalasan menang, dan saat ini hasilnya adalah sebagai berikut (untuk 128 tes): </p><br><pre> <code class="plaintext hljs">Ran 79.04 tests per mutant on average. ------------------|---------|----------|-----------|------------|---------| File | % score | # killed | # timeout | # survived | # error | ------------------|---------|----------|-----------|------------|---------| terminal_model.js | 73.10 | 312 | 25 | 124 | 1 | ------------------|---------|----------|-----------|------------|---------| 23:01:08 (18212) INFO Stryker Done in 26 minutes 32 seconds.</code> </pre> <br><p>  Secara umum, pendekatan ini tampak sangat berguna bagi saya (jelas lebih baik daripada cakupan kode) dan lucu.  Satu-satunya negatif adalah waktu yang sangat lama - 30 menit per kelas terlalu banyak. </p><br><p>  Dan yang paling penting, pendekatan ini membuat saya berpikir lagi tentang cakupan 100% dan apakah itu layak mencakup semuanya dengan tes: sekarang pendapat saya bahkan lebih dekat dengan "ya" ketika menjawab pertanyaan ini. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Optimalisasi kinerja, menurut saya, adalah cara yang baik untuk mempelajari sesuatu yang lebih dalam.  Ini juga merupakan latihan yang baik untuk otak.  Dan sangat disayangkan bahwa ini jarang benar-benar diperlukan (setidaknya dalam proyek saya). </p><br><p>  Dan seperti biasa, pendekatan "profil pertama, kemudian optimasi" bekerja jauh lebih baik daripada intuisi. </p><br><h4 id="ssylki">  Referensi </h4><br><p>  Implementasi lama: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terminal_formatter.py</a> </li><li>  <a href="">log_panel.vue</a> </li></ul><br><p>  Implementasi baru: </p><br><ul><li>  <a href="">terminal_model.js</a> </li><li>  <a href="">terminal_view.js</a> </li></ul><br><p>  Sayangnya, tidak ada demo komponen web, jadi Anda tidak akan dapat menusuknya.  Jadi saya minta maaf sebelumnya </p><br><p>  Terima kasih atas waktu Anda, saya akan dengan senang hati memberikan komentar, saran, dan kritik yang masuk akal! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448030/">https://habr.com/ru/post/id448030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448016/index.html">Analisis klinis urin di rumah pada strip tes: pro dan kontra</a></li>
<li><a href="../id448018/index.html">Acara digital di Moskow dari 15 April hingga 21 April</a></li>
<li><a href="../id448022/index.html">Kompilator sudut 200-garis</a></li>
<li><a href="../id448024/index.html">Regulator Eropa menentang spanduk kue</a></li>
<li><a href="../id448026/index.html">Proyek Perangkat Lunak dan Evolusi OOP</a></li>
<li><a href="../id448032/index.html">Lebih banyak robot: Walmart memperkenalkan ribuan mesin untuk beroperasi di tokonya</a></li>
<li><a href="../id448034/index.html">Cari tugas dalam JIRA (bahasa sederhana). Bagian 1: Pencarian Cepat dan Dasar</a></li>
<li><a href="../id448036/index.html">Impor ke J. Connect dari file daftar pengguna melalui API</a></li>
<li><a href="../id448038/index.html">Fitur baru untuk penulis ekstensi di Visual Studio 2019 v.16.1</a></li>
<li><a href="../id448040/index.html">Intisari materi menarik untuk pengembang ponsel # 294 (pada 8-14 April)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>