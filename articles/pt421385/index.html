<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚯 👩🏿‍🤝‍👩🏼 👰🏾 Aprenda o OpenGL. Lição 5.10 - Oclusão ambiental do espaço na tela 😸 🍢 👩🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SSAO 
 O tópico iluminação de fundo foi abordado por nós em uma lição sobre os princípios básicos da iluminação , mas apenas de passagem. Deixe-me lem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprenda o OpenGL. Lição 5.10 - Oclusão ambiental do espaço na tela</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421385/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  SSAO </h2><br>  O tópico iluminação de fundo foi abordado por nós em uma lição sobre os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">princípios básicos da iluminação</a> , mas apenas de passagem.  Deixe-me lembrá-lo: o componente de fundo da iluminação é essencialmente um valor constante que é adicionado a todos os cálculos da iluminação da cena para simular o processo <i>de dispersão da luz</i> .  No mundo real, a luz sofre muitas reflexões com graus variados de intensidade, o que leva a uma iluminação igualmente desigual de partes da cena iluminadas indiretamente.  Obviamente, flare com intensidade constante não é muito plausível. <br><br>  Um tipo de cálculo aproximado do sombreamento da iluminação indireta é o algoritmo de <i>oclusão ambiental (AO</i> ), que simula a atenuação da iluminação indireta nas proximidades de cantos, rugas e outras irregularidades da superfície.  Tais elementos, em geral, são significativamente sobrepostos pela geometria adjacente e, portanto, deixam menos raios de luz escaparem do lado de fora, obscurecendo essas áreas. <br><br>  Abaixo está uma comparação da renderização sem e usando o algoritmo AO.  Preste atenção em como a intensidade da iluminação de fundo diminui nas proximidades dos cantos das paredes e em outras quebras acentuadas na superfície: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6s/8z/kv/6s8zkvpob8nbgaails8mtfutgw8.png"></div><br>  Embora o efeito não seja muito perceptível, a presença do efeito em toda a cena lhe adiciona realismo devido à ilusão adicional de profundidade criada por pequenos detalhes do efeito de sombreamento automático. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Conteúdo</b> <div class="spoiler_text">  Parte 1. Introdução <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criação de janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Olá janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Olá triângulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transformações</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camera</a> </li></ol><br>  Parte 2. Iluminação básica <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Noções básicas de iluminação</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Materiais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Várias fontes de iluminação</a> </li></ol><br>  Parte 3. Baixe modelos 3D <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe de polígono de malha</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe do modelo 3D</a> </li></ol><br>  Parte 4. Recursos avançados do OpenGL <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de profundidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de estêncil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mistura de cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Faces de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buffer de quadros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cartões cúbicos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manipulação avançada de dados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GLSL avançado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shader geométrico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instanciamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suavização</a> </li></ol><br>  Parte 5. Iluminação Avançada <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Iluminação avançada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelo Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Correção gama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cartões de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de sombra omnidirecionais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento de paralaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderização adiada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSAO</a> </li></ol><br>  Parte 6. PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz analítica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Irradiação difusa.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exposição no espelho.</a> </li></ol><br></div></div><br>  Vale a pena notar que os algoritmos para calcular a AO são bastante intensivos em recursos, pois requerem análise da geometria circundante.  Em uma implementação ingênua, seria possível simplesmente emitir muitos raios em cada ponto da superfície e determinar o grau de sua sombra, mas essa abordagem atinge rapidamente o limite de uso intensivo de recursos aceitável para aplicativos interativos.  Felizmente, em 2007, a Crytek publicou um artigo descrevendo sua própria abordagem para implementar o algoritmo de <i>oclusão ambiental de espaço de tela (SSAO</i> ) usado na versão de lançamento do Crysis.  A abordagem calculou o grau de sombreamento no espaço da tela, usando apenas o buffer de profundidade atual em vez de dados reais sobre a geometria circundante.  Essa otimização acelerou radicalmente o algoritmo em comparação com a implementação de referência e, ao mesmo tempo, deu resultados quase plausíveis, o que tornou essa abordagem de cálculo aproximado do sombreamento de segundo plano uma indústria de fato padrão. <br><br>  O princípio no qual o algoritmo se baseia é bastante simples: para cada fragmento de um quad de tela cheia, o <i>fator de oclusão é</i> calculado com base nos valores de profundidade dos fragmentos circundantes.  O coeficiente de sombreamento calculado é então usado para reduzir a intensidade da iluminação de fundo (até a exclusão completa).  A obtenção de um coeficiente requer a coleta de dados de profundidade de uma pluralidade de amostras da região esférica ao redor do fragmento em questão e a comparação desses valores de profundidade com a profundidade do fragmento em questão.  O número de amostras com profundidade maior que o fragmento atual determina diretamente o coeficiente de sombreamento.  Veja este diagrama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y5/yh/8o/y5yh8oeqvguchqopeu7nz0g-tsy.png"></div><br>  Aqui, cada ponto cinza fica dentro de um determinado objeto geométrico e, portanto, contribui para o valor do coeficiente de sombreamento.  Quanto mais amostras estiverem dentro da geometria dos objetos circundantes, menor será a intensidade residual do sombreamento de fundo nessa área. <br><br>  Obviamente, a qualidade e o realismo do efeito dependem diretamente do número de amostras colhidas.  Com um pequeno número de amostras, a precisão do algoritmo diminui e leva ao aparecimento de um artefato de <i>faixas</i> ou " <i>faixas</i> " devido a transições abruptas entre regiões com coeficientes de sombreamento muito diferentes.  Um grande número de amostras simplesmente mata o desempenho.  A randomização do núcleo das amostras permite resultados um pouco semelhantes para reduzir levemente o número de amostras necessárias.  Reorientação por rotação para um ângulo aleatório de um conjunto de vetores de amostra está implícita.  No entanto, a introdução da aleatoriedade traz imediatamente um novo problema na forma de um padrão de ruído perceptível, que requer o uso de filtros de desfoque para suavizar o resultado.  Abaixo está um exemplo do algoritmo (autor - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">John Chapman</a> ) e seus problemas típicos: padrão de faixas e ruído. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r_/ay/l3/r_ayl3jjozsa6fyuni69ejkwpei.jpeg"></div><br>  Como pode ser visto, uma banda perceptível devido ao pequeno número de amostras é bem removida através da introdução de randomização da orientação das amostras. <br><br>  A implementação específica do SSAO da Crytek tinha um estilo visual reconhecível.  Como os especialistas da Crytek usavam um núcleo esférico da amostra, isso afetava até superfícies planas, como paredes, tornando-as sombreadas - porque metade do volume do núcleo da amostra estava submersa sob a geometria.  Abaixo está uma captura de tela de uma cena do Crysis mostrada em escala de cinza com base no valor do fator de sombreamento.  Aqui o efeito de "cinza" é claramente visível: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j9/zr/r8/j9zrr81dluj-5eobuqcgst48om8.jpeg"></div><br>  Para evitar esse efeito, passaremos do núcleo esférico da amostra para um hemisfério orientado ao longo do normal para a superfície: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br>  Ao coletar amostras desse <i>hemisfério hemisfério de orientação normal,</i> não precisamos levar em consideração os fragmentos que estão sob a superfície da superfície adjacente no cálculo do coeficiente de sombreamento.  Essa abordagem remove sombreamentos desnecessários, em geral, fornece resultados mais realistas.  Esta lição usará a abordagem do hemisfério e um código um pouco mais refinado da brilhante lição da SSAO de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">John Chapman</a> . <br><br><h2>  Buffer de dados brutos </h2><br>  O processo de cálculo do fator de sombreamento em cada fragmento requer a disponibilidade de dados sobre a geometria circundante.  Especificamente, precisamos dos seguintes dados: <br><br><ul><li>  Vetor de posição para cada fragmento; </li><li>  Vetor normal para cada fragmento; </li><li>  Cor difusa para cada fragmento; </li><li>  O núcleo da amostra </li><li>  Um vetor de rotação aleatória para cada fragmento usado na reorientação do núcleo da amostra. </li></ul><br>  Usando dados sobre as coordenadas do fragmento no espaço de espécies, podemos orientar o hemisfério do núcleo da amostra ao longo do vetor normal especificado no espaço de espécies para o fragmento atual.  Em seguida, o núcleo resultante é usado para fazer amostras com várias compensações de uma textura que armazena dados nas coordenadas dos fragmentos.  Fazemos muitas amostras em cada fragmento e, para cada amostra que fazemos, comparamos seu valor de profundidade com o valor de profundidade do buffer de coordenadas do fragmento para estimar a quantidade de sombreamento.  O valor resultante é então usado para limitar a contribuição do componente de plano de fundo no cálculo final da iluminação.  Usando um vetor de rotação aleatória fragmentada, podemos reduzir significativamente o número necessário de amostras para obter um resultado decente, e isso será demonstrado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/xo/aj/wvxoajroexwvjgq77n81-fjhats.png"></div><br>  Como o SSAO é um efeito realizado no espaço da tela, é possível realizar um cálculo direto renderizando um quad em tela cheia.  Mas então não teremos dados sobre a geometria da cena.  Para contornar essa restrição, renderizaremos todas as informações necessárias na textura, que serão posteriormente usadas no shader SSAO para acessar informações geométricas e outras informações sobre a cena.  Se você seguiu cuidadosamente essas lições, já deve saber, na abordagem descrita, a aparência do algoritmo de sombreamento atrasado.  É por isso que o efeito SSAO como nativo aparece na renderização com sombreamento adiado - afinal, as texturas que armazenam coordenadas e normais já estão disponíveis no buffer G. <br><br><blockquote>  Nesta lição, o efeito é implementado em cima de uma versão ligeiramente simplificada do código da lição sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">iluminação adiada</a> .  Se você ainda não se familiarizou com os princípios da iluminação diferida, recomendo fortemente que você volte para esta lição. <br></blockquote><br>  Como o acesso a informações sobre fragmentos sobre coordenadas e normais já deve estar disponível devido ao buffer G, o sombreador de fragmentos do estágio de processamento da geometria é bastante simples: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 gPosition; layout (location = 1) out vec3 gNormal; layout (location = 2) out vec4 gAlbedoSpec; in vec2 TexCoords; in vec3 FragPos; in vec3 Normal; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//        gPosition = FragPos; //       gNormal = normalize(Normal); //    -   gAlbedoSpec.rgb = vec3(0.95); }</span></span></span></span></code> </pre> <br>  Como o algoritmo SSAO é um efeito no espaço da tela e o fator de sombreamento é calculado com base na área visível da cena, faz sentido realizar cálculos no espaço de visualização.  Nesse caso, a variável <i>FragPos</i> obtida do sombreador de vértice armazena a posição exatamente na viewport.  Vale a pena garantir que as coordenadas e normais sejam armazenadas no buffer G no espaço de visualização, pois todos os cálculos adicionais serão realizados nele. <br><br><blockquote>  Existe a possibilidade de restaurar o vetor de posição com base apenas em uma profundidade de fragmento conhecida e em uma certa quantidade de mágica matemática, que é descrita, por exemplo, no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog de</a> Matt Pettineo.  Obviamente, isso exige um grande custo de cálculo, mas elimina a necessidade de armazenar dados de posição no buffer G, que consome muita memória de vídeo.  No entanto, por uma questão de simplicidade, o código de exemplo deixará essa abordagem para estudo pessoal. </blockquote><br>  A textura do buffer de cores <i>gPosition</i> está configurada da seguinte maneira: <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;gPosition); glBindTexture(GL_TEXTURE_2D, gPosition); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</code> </pre> <br>  Essa textura armazena as coordenadas dos fragmentos e pode ser usada para obter dados de profundidade de cada ponto do núcleo das amostras.  Observo que a textura usa um formato de dados de ponto flutuante - isso permitirá que as coordenadas dos fragmentos não sejam reduzidas ao intervalo [0., 1.].  Preste atenção também ao modo de repetição - <i>GL_CLAMP_TO_EDGE</i> está definido.  Isso é necessário para eliminar a possibilidade de não amostrar demais no espaço da tela de propósito.  Ir além do intervalo principal de coordenadas de textura nos fornecerá dados incorretos de posição e profundidade. <br><br>  A seguir, nos envolveremos na formação de um núcleo hemisférico das amostras e na criação de um método de orientação aleatória. <br><br><h2>  Criando um hemisfério de orientação normal </h2><br>  Portanto, a tarefa é criar um conjunto de pontos de amostra localizados dentro de um hemisfério orientado ao longo do normal para a superfície.  Como a criação de um núcleo de amostra para todas as direções possíveis do normal é computacionalmente inatingível, usamos a transição para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">espaço tangente</a> , onde o normal é sempre representado como um vetor na direção da semiaxe positiva <i>Z.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br>  Assumindo que o raio do hemisfério seja um processo único, a formação de um núcleo de uma amostra de 64 pontos se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      0.0 - 1.0 std::uniform_real_distribution&lt;float&gt; randomFloats(0.0, 1.0); std::default_random_engine generator; std::vector&lt;glm::vec3&gt; ssaoKernel; for (unsigned int i = 0; i &lt; 64; ++i) { glm::vec3 sample( randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) ); sample = glm::normalize(sample); sample *= randomFloats(generator); float scale = (float)i / 64.0; ssaoKernel.push_back(sample); }</span></span></code> </pre> <br>  Aqui, selecionamos aleatoriamente as coordenadas <i>x</i> e <i>y</i> no intervalo [-1., 1.] e a coordenada <i>z</i> no intervalo [0., 1.] (se o intervalo for o mesmo que para <i>x</i> e <i>y</i> , obteríamos um núcleo esférico amostragem).  Os vetores de amostra resultantes serão limitados aos hemisférios, uma vez que o núcleo da amostra será orientado ao longo do normal para a superfície. <br><br>  No momento, todos os pontos da amostra são distribuídos aleatoriamente no interior do núcleo, mas, para garantir a qualidade do efeito, as amostras mais próximas da origem do núcleo devem dar uma contribuição maior ao cálculo do coeficiente de sombreamento.  Isso pode ser realizado alterando a distribuição dos pontos de amostra formados, aumentando sua densidade perto da origem.  Esta tarefa é facilmente realizada usando a função de interpolação de aceleração: <br><br><pre> <code class="cpp hljs">scale = lerp(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, scale * scale); sample *= scale; ssaoKernel.push_back(sample); }</code> </pre> <br>  A função <i>lerp ()</i> é definida como: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + f * (b - a); }</code> </pre> <br>  Esse truque nos dá uma distribuição modificada, onde a maioria dos pontos de amostra fica perto da origem do kernel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h7/dy/xm/h7dyxm-1zerxg1krzbxszp7kzqi.png"></div><br>  Cada um dos vetores de amostra obtidos será usado para alterar a coordenada do fragmento no espaço de espécies para obter dados sobre a geometria circundante.  Para obter resultados decentes ao trabalhar na viewport, você pode precisar de um número impressionante de amostras, o que inevitavelmente afetará o desempenho.  No entanto, a introdução de ruído pseudo-aleatório ou rotação dos vetores de amostra em cada fragmento processado reduzirá significativamente o número necessário de amostras com qualidade comparável. <br><br><h2>  Rotação aleatória do núcleo da amostra </h2><br>  Portanto, a introdução da aleatoriedade na distribuição de pontos no núcleo da amostra pode reduzir significativamente a necessidade de o número desses pontos obter um efeito de qualidade decente.  Seria possível criar um vetor de rotação aleatória para cada fragmento da cena, mas é muito caro de memória.  É mais eficiente criar uma textura pequena contendo um conjunto de vetores de rotação aleatória e usá-la com o modo de repetição <i>GL_REPEAT definido</i> . <br><br>  Crie uma matriz 4x4 e preencha-a com vetores de rotação aleatória orientados ao longo do vetor normal no espaço tangente: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;glm::vec3&gt; ssaoNoise; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ssaoNoise.push_back(noise); }</code> </pre> <br>  Como o núcleo está alinhado ao longo da semiaxe positiva <i>Z</i> no espaço tangente, deixamos o componente <i>z</i> igual a zero - isso garantirá a rotação apenas em torno do eixo <i>Z.</i> <br><br>  Em seguida, crie uma textura 4x4 e preencha-a com nossa matriz de vetores de rotação.  Certifique-se de usar o <i>modo de</i> reprodução <i>GL_REPEAT</i> para texturizar lado a lado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> noiseTexture; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;noiseTexture); glBindTexture(GL_TEXTURE_2D, noiseTexture); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, &amp;ssaoNoise[<span class="hljs-number"><span class="hljs-number">0</span></span>]); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</code> </pre> <br>  Bem, agora temos todos os dados necessários para a implementação direta do algoritmo SSAO! <br><br><h2>  Shader SSAO </h2><br>  Um sombreador de efeito será executado para cada fragmento de um quad de tela cheia, calculando o coeficiente de sombreamento em cada um deles.  Como os resultados serão usados ​​em outro estágio de renderização que cria a iluminação final, precisamos criar outro objeto buffer de estrutura para armazenar o resultado do shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoFBO; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoColorBuffer; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBuffer); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Como o resultado do algoritmo é o único número real dentro de [0., 1.], para armazenamento, será suficiente criar uma textura com o único componente disponível.  É por isso que <i>GL_RED</i> é definido como o formato interno para o buffer de cores. <br><br>  Em geral, o processo de renderização do estágio SSAO se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  :  G- glBindFramebuffer(GL_FRAMEBUFFER, gBuffer); [...] glBindFramebuffer(GL_FRAMEBUFFER, 0); //  G-      SSAO glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); glClear(GL_COLOR_BUFFER_BIT); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, gPosition); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, gNormal); glActiveTexture(GL_TEXTURE2); glBindTexture(GL_TEXTURE_2D, noiseTexture); shaderSSAO.use(); SendKernelSamplesToShader(); shaderSSAO.setMat4("projection", projection); RenderQuad(); glBindFramebuffer(GL_FRAMEBUFFER, 0); //  :    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); shaderLightingPass.use(); [...] glActiveTexture(GL_TEXTURE3); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); [...] RenderQuad();</span></span></code> </pre> <br>  O <i>shaderSSAO</i> aceita as texturas de buffer G necessárias como entrada, assim como a textura do ruído e o núcleo da amostra: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D texNoise; uniform vec3 samples[64]; uniform mat4 projection; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//             //      1280x720 const vec2 noiseScale = vec2(1280.0/4.0, 720.0/4.0); void main() { [...] }</span></span></span></span></code> </pre> <br>  Observe a variável <i>noiseScale</i> .  Nossa pequena textura com ruído deve estar lado a lado em toda a superfície da tela, mas como as coordenadas da <i>TexCoords estão</i> dentro de [0., 1.], isso não acontecerá sem a nossa intervenção.  Para esses fins, calculamos o fator para as coordenadas da textura, que é encontrado como a proporção do tamanho da tela e o tamanho da textura do ruído: <br><br><pre> <code class="cpp hljs">vec3 fragPos = texture(gPosition, TexCoords).xyz; vec3 normal = texture(gNormal, TexCoords).rgb; vec3 randomVec = texture(texNoise, TexCoords * noiseScale).xyz;</code> </pre> <br>  Como ao criar a textura de ruído <i>texNoise</i> , definimos o modo de repetição como <i>GL_REPEAT</i> , agora ele será repetido várias vezes na superfície da tela.  Com <i>randomVec</i> , <i>fragPos</i> e valores <i>normais</i> disponíveis, podemos criar uma matriz de transformação TBN do tangente para o espaço da espécie: <br><br><pre> <code class="cpp hljs">vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal)); vec3 bitangent = cross(normal, tangent); mat3 TBN = mat3(tangent, bitangent, normal);</code> </pre> <br>  Usando o processo de Gram-Schmidt, criamos uma base ortogonal aleatoriamente inclinada em cada fragmento com base no valor aleatório <i>randomVec</i> .  Um ponto importante: como nesse caso, não importa para nós que a matriz TBN esteja exatamente orientada ao longo da superfície do triângulo (como no caso do mapeamento de paralaxe, aprox. <br><br>  Em seguida, examinamos a matriz do núcleo da amostra, convertemos cada vetor de amostra do espaço tangente para o espaço da espécie e obtemos sua soma com a posição atual do fragmento.  Em seguida, comparamos o valor da profundidade da quantidade resultante com o valor da profundidade obtido por amostragem da textura do buffer G correspondente. <br><br>  Embora pareça confuso, vamos seguir as etapas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> occlusion = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; kernelSize; ++i) { <span class="hljs-comment"><span class="hljs-comment">//     vec3 sample = TBN * samples[i]; //      - sample = fragPos + sample * radius; [...] }</span></span></code> </pre> <br>  Aqui, <i>kernelSize</i> e <i>radius</i> são variáveis ​​que controlam as características do efeito.  Nesse caso, eles são 64 e 0,5, respectivamente.  A cada iteração, traduzimos o vetor principal da amostra no espaço de espécies.  Em seguida, adicionamos ao valor obtido o deslocamento da amostra no espaço de espécies o valor da posição do fragmento no espaço de espécies.  Nesse caso, o valor do deslocamento é multiplicado pela variável radius, que controla o raio do núcleo da amostra de efeito SSAO. <br><br>  Após essas etapas, devemos converter o vetor de <i>amostra</i> resultante no espaço da tela, para que possamos selecionar a textura do buffer G que armazena as posições e profundidades dos fragmentos usando o valor projetado obtido.  Como a <i>amostra</i> está na viewport, precisamos da matriz de <i>projeção</i> : <br><br><pre> <code class="cpp hljs">vec4 offset = vec4(sample, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); offset = projection * offset; <span class="hljs-comment"><span class="hljs-comment">//     offset.xyz /= offset.w; //   offset.xyz = offset.xyz * 0.5 + 0.5; //    [0., 1.]</span></span></code> </pre> <br>  Após a conversão no espaço do clipe, executamos manualmente a divisão da perspectiva, simplesmente dividindo os componentes <i>xyz</i> pelo componente <i>w</i> .  O vetor resultante em coordenadas de dispositivo normalizadas ( <i>NDC</i> ) é convertido no intervalo de valores [0., 1.] para que possa ser usado como coordenadas de textura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sampleDepth = texture(gPosition, offset.xy).z;</code> </pre> <br>  Utilizamos os componentes <i>xy</i> do vetor de <i>amostra</i> para selecionar a partir da textura as posições do buffer G.  Obtemos o valor de profundidade (componentes <i>z</i> ) correspondente ao vetor de amostra quando visto da posição do observador (este é o primeiro fragmento visível não blindado).  Se ao mesmo tempo a profundidade de amostragem obtida for maior que a profundidade armazenada, aumentamos o coeficiente de sombreamento: <br><br><pre> <code class="cpp hljs">occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>);</code> </pre> <br>  Observe o deslocamento da <i>polarização</i> , que é adicionado à profundidade do fragmento original (definido no exemplo como 0,025).  Esse deslocamento nem sempre é necessário, mas a presença de uma variável permite controlar a aparência do efeito SSAO e também, em determinadas situações, remove problemas com ondulações nas áreas sombreadas. <br><br>  Mas isso não é tudo, pois essa implementação leva a artefatos visíveis.  Ela se manifesta nos casos em que é considerado um fragmento próximo à borda de uma determinada superfície.  Em tais situações, ao comparar as profundidades, o algoritmo captura inevitavelmente as profundidades das superfícies, que podem estar muito atrás do considerado.  Nesses locais, o algoritmo aumenta erroneamente o grau de sombreamento, o que criará halos escuros perceptíveis nas bordas dos objetos.  O artefato é tratado introduzindo uma verificação de distância adicional (um exemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">John Chapman</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/yv/eq/zvyveqh3zc_rjcy6fo-z8d76eme.png"></div><br>  A verificação limitará a contribuição ao coeficiente de sombreamento apenas para valores de profundidade dentro do raio da amostra: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rangeCheck = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, radius / <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(fragPos.z - sampleDepth)); occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * rangeCheck;</code> </pre> <br>  Também usamos a função GLSL <i>smoothstep ()</i> , que implementa a interpolação suave do terceiro parâmetro entre o primeiro e o segundo.  Nesse caso, retorne 0 se o terceiro parâmetro for menor ou igual ao primeiro ou 1 se o terceiro parâmetro for maior que ou igual ao segundo.  Se a diferença de profundidade estiver dentro do <i>raio</i> , seu valor será suavizado no intervalo [0., 1.] de acordo com esta curva: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jq/9h/p4/jq9hp4-yun_sc277m6pslbjyin0.png"></div><br>  Se usássemos limites claros nas condições de verificação da profundidade, isso adicionaria artefatos na forma de limites nítidos nos locais em que os valores da diferença nas profundidades estão fora dos limites do <i>raio</i> . <br><br>  Com o toque final, normalizamos o valor do coeficiente de sombreamento usando o tamanho do núcleo da amostra e registramos o resultado.  Também invertemos o valor final subtraindo-o da unidade, para que você possa usar o valor final diretamente para modular o componente de fundo da iluminação sem etapas adicionais: <br><br><pre> <code class="cpp hljs">} occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = occlusion;</code> </pre> <br>  Para uma cena com um nanossuit mentiroso familiar para nós, executar o shader SSAO fornece a seguinte textura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-z/a4/fx/-za4fxhsbref6easc-cgxnsp94q.png"></div><br>  Como você pode ver, o efeito do sombreamento de fundo cria uma boa ilusão de profundidade.  Somente a imagem de saída do shader já permite distinguir os detalhes da roupa e garantir que ela realmente fique no chão e não levite a alguma distância dela. <br><br>  No entanto, o efeito está longe de ser ideal, uma vez que o padrão de ruído introduzido pela textura dos vetores de rotação aleatória é facilmente perceptível.  Para suavizar o resultado do cálculo do SSAO, aplicamos um filtro de desfoque. <br><br><h2>  Desfocar sombreamento de fundo </h2><br>  Depois de criar o resultado do SSAO e antes da mistura final da iluminação, é necessário desfocar a textura que armazena dados no coeficiente de sombreamento.  Para fazer isso, teremos outro buffer de quadro: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoBlurFBO, ssaoColorBufferBlur; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoBlurFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoBlurFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBufferBlur); glBindTexture(GL_TEXTURE_2D, ssaoColorBufferBlur); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBufferBlur, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  A colocação de uma textura de ruído no espaço da tela fornece uma característica de aleatoriedade bem definida que você pode usar para sua vantagem ao criar um filtro de desfoque: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D ssaoInput; void main() { vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0)); float result = 0.0; for (int x = -2; x &lt; 2; ++x) { for (int y = -2; y &lt; 2; ++y) { vec2 offset = vec2(float(x), float(y)) * texelSize; result += texture(ssaoInput, TexCoords + offset).r; } } FragColor = result / (4.0 * 4.0); }</span></span></code> </pre> <br>  O sombreador simplesmente transita texels da textura SSAO com um deslocamento de -2 para +2, o que corresponde ao tamanho real da textura de ruído.  O deslocamento é igual ao tamanho exato de um texel: a função textureSize <i>()</i> é usada para o cálculo, que retorna <i>vec2</i> com as dimensões da textura especificada.  T.O.  O sombreador calcula a média dos resultados armazenados na textura, o que fornece um desfoque rápido e bastante eficaz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/0g/i7/5p0gi7qn_v5w738uyindxexally.png"></div><br>  No total, temos uma textura com dados de sombreamento de fundo para cada fragmento na tela - tudo está pronto para o estágio de redução final da imagem! <br><br><h2>  Aplicar sombreamento em segundo plano </h2><br>  A etapa de aplicação do coeficiente de sombreamento no cálculo final da iluminação é surpreendentemente simples: para cada fragmento, basta multiplicar o valor do componente de fundo da fonte de luz pelo coeficiente de sombreamento da textura preparada.  Você pode pegar um shader pronto com o modelo Blinn-Fong da lição sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sombreamento adiado</a> e corrigi-lo um pouco: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D gAlbedo; uniform sampler2D ssao; struct Light { vec3 Position; vec3 Color; float Linear; float Quadratic; float Radius; }; uniform Light light; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    G- vec3 FragPos = texture(gPosition, TexCoords).rgb; vec3 Normal = texture(gNormal, TexCoords).rgb; vec3 Diffuse = texture(gAlbedo, TexCoords).rgb; float AmbientOcclusion = texture(ssao, TexCoords).r; //   -    //   :   -  vec3 ambient = vec3(0.3 * Diffuse * AmbientOcclusion); vec3 lighting = ambient; //    (0, 0, 0)   - vec3 viewDir = normalize(-FragPos); //   vec3 lightDir = normalize(light.Position - FragPos); vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * light.Color; //   vec3 halfwayDir = normalize(lightDir + viewDir); float spec = pow(max(dot(Normal, halfwayDir), 0.0), 8.0); vec3 specular = light.Color * spec; //   float dist = length(light.Position - FragPos); float attenuation = 1.0 / (1.0 + light.Linear * dist + light.Quadratic * dist * dist); diffuse *= attenuation; specular *= attenuation; lighting += diffuse + specular; FragColor = vec4(lighting, 1.0); }</span></span></span></span></code> </pre> <br>  Existem apenas duas mudanças principais: a transição para os cálculos na viewport e a multiplicação do componente de iluminação de fundo pelo valor de <i>AmbientOcclusion</i> .  Um exemplo de cena com um único ponto de luz azul: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/8_/1i/bz8_1in-othscilg_udfyscghg0.png"></div><br>  O código fonte completo está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  A manifestação do efeito SSAO depende fortemente de parâmetros como <i>kernelSize</i> , <i>raio</i> e <i>viés</i> , geralmente é necessário que você faça o ajuste fino deles para que o artista <i>elabore</i> um local / cena específico.  Não há combinações "melhores" e universais de parâmetros: para algumas cenas, um pequeno raio do núcleo da amostra é bom, enquanto outras se beneficiam do aumento do raio e do número de amostras.  O exemplo usa 64 pontos de amostra, o que, francamente, é redundante, mas você sempre pode editar o código e ver o que acontece com um número menor de amostras. <br><br>  Além dos uniformes listados, responsáveis ​​por definir o efeito, existe a possibilidade de controlar explicitamente a gravidade do efeito de sombreamento em segundo plano.  Para isso, basta elevar o coeficiente para um grau controlado por outro uniforme: <br><br><pre> <code class="cpp hljs">occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(occlusion, power);</code> </pre> <br>  Aconselho que você gaste algum tempo no jogo com as configurações, pois isso dará uma melhor compreensão da natureza das alterações na imagem final. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resumir, vale a pena dizer que, embora o efeito visual da aplicação do SSAO seja bastante sutil, em cenas com iluminação bem posicionada, inegavelmente acrescenta uma fração notável do realismo. </font><font style="vertical-align: inherit;">Ter essa ferramenta em seu arsenal é certamente valioso.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recursos Adicionais </font></font></h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial do SSAO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Um excelente artigo de lição de John Chapman, com base no qual o código para esta lição é criado.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conheça os artefatos do SSAO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : um artigo muito valioso mostrando lucidamente não apenas os problemas mais prementes com a qualidade do SSAO, mas também maneiras de resolvê-los. </font><font style="vertical-align: inherit;">Leitura recomendada.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSAO com reconstrução de profundidade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Adendo à lição principal do SSAO do OGLDev sobre uma técnica comumente usada para restaurar coordenadas de fragmentos com base na profundidade. </font><font style="vertical-align: inherit;">A importância dessa abordagem se deve à economia significativa de memória devido à falta de necessidade de armazenar posições no buffer G. </font><font style="vertical-align: inherit;">A abordagem é tão universal que se aplica ao SSAO na medida em que.</font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Temos um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telegrama conf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para coordenação de transferências. </font><font style="vertical-align: inherit;">Se você tem um desejo sério de ajudar com a tradução, é bem-vindo!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421385/">https://habr.com/ru/post/pt421385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421375/index.html">Como a incerteza mata o comércio</a></li>
<li><a href="../pt421377/index.html">7 equívocos de um gerente de projeto iniciante no gamedev</a></li>
<li><a href="../pt421379/index.html">Cultura tóxica da Intel</a></li>
<li><a href="../pt421381/index.html">Curso Gratuito Cisco Administrator ASA</a></li>
<li><a href="../pt421383/index.html">Epic Growth Conference Autumn 2018 - conferência de marketing de produto em Moscou</a></li>
<li><a href="../pt421387/index.html">Entrevista com Lennart Pottering no Linux Piter sobre mudanças no Linux, sobre systemd e por que participar de conferências</a></li>
<li><a href="../pt421389/index.html">Separação de poderes administrativos em Zimbra</a></li>
<li><a href="../pt421391/index.html">HackThings - um grande hackathon na Internet das coisas de 7 a 9 de setembro na Skoltech</a></li>
<li><a href="../pt421393/index.html">Cesta de Mailchimp abandonada: um guia para os preguiçosos</a></li>
<li><a href="../pt421395/index.html">Relatório do Clube de Roma 2018, capítulo 3.7: “Clima: boas notícias, mas grandes problemas”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>