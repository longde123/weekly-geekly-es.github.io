<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöØ üë©üèø‚Äçü§ù‚Äçüë©üèº üë∞üèæ Aprenda o OpenGL. Li√ß√£o 5.10 - Oclus√£o ambiental do espa√ßo na tela üò∏ üç¢ üë©üèΩ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SSAO 
 O t√≥pico ilumina√ß√£o de fundo foi abordado por n√≥s em uma li√ß√£o sobre os princ√≠pios b√°sicos da ilumina√ß√£o , mas apenas de passagem. Deixe-me lem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprenda o OpenGL. Li√ß√£o 5.10 - Oclus√£o ambiental do espa√ßo na tela</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421385/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  SSAO </h2><br>  O t√≥pico ilumina√ß√£o de fundo foi abordado por n√≥s em uma li√ß√£o sobre os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">princ√≠pios b√°sicos da ilumina√ß√£o</a> , mas apenas de passagem.  Deixe-me lembr√°-lo: o componente de fundo da ilumina√ß√£o √© essencialmente um valor constante que √© adicionado a todos os c√°lculos da ilumina√ß√£o da cena para simular o processo <i>de dispers√£o da luz</i> .  No mundo real, a luz sofre muitas reflex√µes com graus variados de intensidade, o que leva a uma ilumina√ß√£o igualmente desigual de partes da cena iluminadas indiretamente.  Obviamente, flare com intensidade constante n√£o √© muito plaus√≠vel. <br><br>  Um tipo de c√°lculo aproximado do sombreamento da ilumina√ß√£o indireta √© o algoritmo de <i>oclus√£o ambiental (AO</i> ), que simula a atenua√ß√£o da ilumina√ß√£o indireta nas proximidades de cantos, rugas e outras irregularidades da superf√≠cie.  Tais elementos, em geral, s√£o significativamente sobrepostos pela geometria adjacente e, portanto, deixam menos raios de luz escaparem do lado de fora, obscurecendo essas √°reas. <br><br>  Abaixo est√° uma compara√ß√£o da renderiza√ß√£o sem e usando o algoritmo AO.  Preste aten√ß√£o em como a intensidade da ilumina√ß√£o de fundo diminui nas proximidades dos cantos das paredes e em outras quebras acentuadas na superf√≠cie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6s/8z/kv/6s8zkvpob8nbgaails8mtfutgw8.png"></div><br>  Embora o efeito n√£o seja muito percept√≠vel, a presen√ßa do efeito em toda a cena lhe adiciona realismo devido √† ilus√£o adicional de profundidade criada por pequenos detalhes do efeito de sombreamento autom√°tico. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Conte√∫do</b> <div class="spoiler_text">  Parte 1. Introdu√ß√£o <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cria√ß√£o de janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ol√° janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ol√° tri√¢ngulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transforma√ß√µes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camera</a> </li></ol><br>  Parte 2. Ilumina√ß√£o b√°sica <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">No√ß√µes b√°sicas de ilumina√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Materiais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V√°rias fontes de ilumina√ß√£o</a> </li></ol><br>  Parte 3. Baixe modelos 3D <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe de pol√≠gono de malha</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe do modelo 3D</a> </li></ol><br>  Parte 4. Recursos avan√ßados do OpenGL <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de profundidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de est√™ncil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mistura de cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Faces de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buffer de quadros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cart√µes c√∫bicos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manipula√ß√£o avan√ßada de dados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GLSL avan√ßado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shader geom√©trico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instanciamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suaviza√ß√£o</a> </li></ol><br>  Parte 5. Ilumina√ß√£o Avan√ßada <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ilumina√ß√£o avan√ßada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelo Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Corre√ß√£o gama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cart√µes de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de sombra omnidirecionais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento de paralaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderiza√ß√£o adiada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSAO</a> </li></ol><br>  Parte 6. PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz anal√≠tica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Irradia√ß√£o difusa.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exposi√ß√£o no espelho.</a> </li></ol><br></div></div><br>  Vale a pena notar que os algoritmos para calcular a AO s√£o bastante intensivos em recursos, pois requerem an√°lise da geometria circundante.  Em uma implementa√ß√£o ing√™nua, seria poss√≠vel simplesmente emitir muitos raios em cada ponto da superf√≠cie e determinar o grau de sua sombra, mas essa abordagem atinge rapidamente o limite de uso intensivo de recursos aceit√°vel para aplicativos interativos.  Felizmente, em 2007, a Crytek publicou um artigo descrevendo sua pr√≥pria abordagem para implementar o algoritmo de <i>oclus√£o ambiental de espa√ßo de tela (SSAO</i> ) usado na vers√£o de lan√ßamento do Crysis.  A abordagem calculou o grau de sombreamento no espa√ßo da tela, usando apenas o buffer de profundidade atual em vez de dados reais sobre a geometria circundante.  Essa otimiza√ß√£o acelerou radicalmente o algoritmo em compara√ß√£o com a implementa√ß√£o de refer√™ncia e, ao mesmo tempo, deu resultados quase plaus√≠veis, o que tornou essa abordagem de c√°lculo aproximado do sombreamento de segundo plano uma ind√∫stria de fato padr√£o. <br><br>  O princ√≠pio no qual o algoritmo se baseia √© bastante simples: para cada fragmento de um quad de tela cheia, o <i>fator de oclus√£o √©</i> calculado com base nos valores de profundidade dos fragmentos circundantes.  O coeficiente de sombreamento calculado √© ent√£o usado para reduzir a intensidade da ilumina√ß√£o de fundo (at√© a exclus√£o completa).  A obten√ß√£o de um coeficiente requer a coleta de dados de profundidade de uma pluralidade de amostras da regi√£o esf√©rica ao redor do fragmento em quest√£o e a compara√ß√£o desses valores de profundidade com a profundidade do fragmento em quest√£o.  O n√∫mero de amostras com profundidade maior que o fragmento atual determina diretamente o coeficiente de sombreamento.  Veja este diagrama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y5/yh/8o/y5yh8oeqvguchqopeu7nz0g-tsy.png"></div><br>  Aqui, cada ponto cinza fica dentro de um determinado objeto geom√©trico e, portanto, contribui para o valor do coeficiente de sombreamento.  Quanto mais amostras estiverem dentro da geometria dos objetos circundantes, menor ser√° a intensidade residual do sombreamento de fundo nessa √°rea. <br><br>  Obviamente, a qualidade e o realismo do efeito dependem diretamente do n√∫mero de amostras colhidas.  Com um pequeno n√∫mero de amostras, a precis√£o do algoritmo diminui e leva ao aparecimento de um artefato de <i>faixas</i> ou " <i>faixas</i> " devido a transi√ß√µes abruptas entre regi√µes com coeficientes de sombreamento muito diferentes.  Um grande n√∫mero de amostras simplesmente mata o desempenho.  A randomiza√ß√£o do n√∫cleo das amostras permite resultados um pouco semelhantes para reduzir levemente o n√∫mero de amostras necess√°rias.  Reorienta√ß√£o por rota√ß√£o para um √¢ngulo aleat√≥rio de um conjunto de vetores de amostra est√° impl√≠cita.  No entanto, a introdu√ß√£o da aleatoriedade traz imediatamente um novo problema na forma de um padr√£o de ru√≠do percept√≠vel, que requer o uso de filtros de desfoque para suavizar o resultado.  Abaixo est√° um exemplo do algoritmo (autor - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">John Chapman</a> ) e seus problemas t√≠picos: padr√£o de faixas e ru√≠do. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r_/ay/l3/r_ayl3jjozsa6fyuni69ejkwpei.jpeg"></div><br>  Como pode ser visto, uma banda percept√≠vel devido ao pequeno n√∫mero de amostras √© bem removida atrav√©s da introdu√ß√£o de randomiza√ß√£o da orienta√ß√£o das amostras. <br><br>  A implementa√ß√£o espec√≠fica do SSAO da Crytek tinha um estilo visual reconhec√≠vel.  Como os especialistas da Crytek usavam um n√∫cleo esf√©rico da amostra, isso afetava at√© superf√≠cies planas, como paredes, tornando-as sombreadas - porque metade do volume do n√∫cleo da amostra estava submersa sob a geometria.  Abaixo est√° uma captura de tela de uma cena do Crysis mostrada em escala de cinza com base no valor do fator de sombreamento.  Aqui o efeito de "cinza" √© claramente vis√≠vel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j9/zr/r8/j9zrr81dluj-5eobuqcgst48om8.jpeg"></div><br>  Para evitar esse efeito, passaremos do n√∫cleo esf√©rico da amostra para um hemisf√©rio orientado ao longo do normal para a superf√≠cie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br>  Ao coletar amostras desse <i>hemisf√©rio hemisf√©rio de orienta√ß√£o normal,</i> n√£o precisamos levar em considera√ß√£o os fragmentos que est√£o sob a superf√≠cie da superf√≠cie adjacente no c√°lculo do coeficiente de sombreamento.  Essa abordagem remove sombreamentos desnecess√°rios, em geral, fornece resultados mais realistas.  Esta li√ß√£o usar√° a abordagem do hemisf√©rio e um c√≥digo um pouco mais refinado da brilhante li√ß√£o da SSAO de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">John Chapman</a> . <br><br><h2>  Buffer de dados brutos </h2><br>  O processo de c√°lculo do fator de sombreamento em cada fragmento requer a disponibilidade de dados sobre a geometria circundante.  Especificamente, precisamos dos seguintes dados: <br><br><ul><li>  Vetor de posi√ß√£o para cada fragmento; </li><li>  Vetor normal para cada fragmento; </li><li>  Cor difusa para cada fragmento; </li><li>  O n√∫cleo da amostra </li><li>  Um vetor de rota√ß√£o aleat√≥ria para cada fragmento usado na reorienta√ß√£o do n√∫cleo da amostra. </li></ul><br>  Usando dados sobre as coordenadas do fragmento no espa√ßo de esp√©cies, podemos orientar o hemisf√©rio do n√∫cleo da amostra ao longo do vetor normal especificado no espa√ßo de esp√©cies para o fragmento atual.  Em seguida, o n√∫cleo resultante √© usado para fazer amostras com v√°rias compensa√ß√µes de uma textura que armazena dados nas coordenadas dos fragmentos.  Fazemos muitas amostras em cada fragmento e, para cada amostra que fazemos, comparamos seu valor de profundidade com o valor de profundidade do buffer de coordenadas do fragmento para estimar a quantidade de sombreamento.  O valor resultante √© ent√£o usado para limitar a contribui√ß√£o do componente de plano de fundo no c√°lculo final da ilumina√ß√£o.  Usando um vetor de rota√ß√£o aleat√≥ria fragmentada, podemos reduzir significativamente o n√∫mero necess√°rio de amostras para obter um resultado decente, e isso ser√° demonstrado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/xo/aj/wvxoajroexwvjgq77n81-fjhats.png"></div><br>  Como o SSAO √© um efeito realizado no espa√ßo da tela, √© poss√≠vel realizar um c√°lculo direto renderizando um quad em tela cheia.  Mas ent√£o n√£o teremos dados sobre a geometria da cena.  Para contornar essa restri√ß√£o, renderizaremos todas as informa√ß√µes necess√°rias na textura, que ser√£o posteriormente usadas no shader SSAO para acessar informa√ß√µes geom√©tricas e outras informa√ß√µes sobre a cena.  Se voc√™ seguiu cuidadosamente essas li√ß√µes, j√° deve saber, na abordagem descrita, a apar√™ncia do algoritmo de sombreamento atrasado.  √â por isso que o efeito SSAO como nativo aparece na renderiza√ß√£o com sombreamento adiado - afinal, as texturas que armazenam coordenadas e normais j√° est√£o dispon√≠veis no buffer G. <br><br><blockquote>  Nesta li√ß√£o, o efeito √© implementado em cima de uma vers√£o ligeiramente simplificada do c√≥digo da li√ß√£o sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ilumina√ß√£o adiada</a> .  Se voc√™ ainda n√£o se familiarizou com os princ√≠pios da ilumina√ß√£o diferida, recomendo fortemente que voc√™ volte para esta li√ß√£o. <br></blockquote><br>  Como o acesso a informa√ß√µes sobre fragmentos sobre coordenadas e normais j√° deve estar dispon√≠vel devido ao buffer G, o sombreador de fragmentos do est√°gio de processamento da geometria √© bastante simples: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 gPosition; layout (location = 1) out vec3 gNormal; layout (location = 2) out vec4 gAlbedoSpec; in vec2 TexCoords; in vec3 FragPos; in vec3 Normal; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//        gPosition = FragPos; //       gNormal = normalize(Normal); //    -   gAlbedoSpec.rgb = vec3(0.95); }</span></span></span></span></code> </pre> <br>  Como o algoritmo SSAO √© um efeito no espa√ßo da tela e o fator de sombreamento √© calculado com base na √°rea vis√≠vel da cena, faz sentido realizar c√°lculos no espa√ßo de visualiza√ß√£o.  Nesse caso, a vari√°vel <i>FragPos</i> obtida do sombreador de v√©rtice armazena a posi√ß√£o exatamente na viewport.  Vale a pena garantir que as coordenadas e normais sejam armazenadas no buffer G no espa√ßo de visualiza√ß√£o, pois todos os c√°lculos adicionais ser√£o realizados nele. <br><br><blockquote>  Existe a possibilidade de restaurar o vetor de posi√ß√£o com base apenas em uma profundidade de fragmento conhecida e em uma certa quantidade de m√°gica matem√°tica, que √© descrita, por exemplo, no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog de</a> Matt Pettineo.  Obviamente, isso exige um grande custo de c√°lculo, mas elimina a necessidade de armazenar dados de posi√ß√£o no buffer G, que consome muita mem√≥ria de v√≠deo.  No entanto, por uma quest√£o de simplicidade, o c√≥digo de exemplo deixar√° essa abordagem para estudo pessoal. </blockquote><br>  A textura do buffer de cores <i>gPosition</i> est√° configurada da seguinte maneira: <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;gPosition); glBindTexture(GL_TEXTURE_2D, gPosition); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</code> </pre> <br>  Essa textura armazena as coordenadas dos fragmentos e pode ser usada para obter dados de profundidade de cada ponto do n√∫cleo das amostras.  Observo que a textura usa um formato de dados de ponto flutuante - isso permitir√° que as coordenadas dos fragmentos n√£o sejam reduzidas ao intervalo [0., 1.].  Preste aten√ß√£o tamb√©m ao modo de repeti√ß√£o - <i>GL_CLAMP_TO_EDGE</i> est√° definido.  Isso √© necess√°rio para eliminar a possibilidade de n√£o amostrar demais no espa√ßo da tela de prop√≥sito.  Ir al√©m do intervalo principal de coordenadas de textura nos fornecer√° dados incorretos de posi√ß√£o e profundidade. <br><br>  A seguir, nos envolveremos na forma√ß√£o de um n√∫cleo hemisf√©rico das amostras e na cria√ß√£o de um m√©todo de orienta√ß√£o aleat√≥ria. <br><br><h2>  Criando um hemisf√©rio de orienta√ß√£o normal </h2><br>  Portanto, a tarefa √© criar um conjunto de pontos de amostra localizados dentro de um hemisf√©rio orientado ao longo do normal para a superf√≠cie.  Como a cria√ß√£o de um n√∫cleo de amostra para todas as dire√ß√µes poss√≠veis do normal √© computacionalmente inating√≠vel, usamos a transi√ß√£o para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">espa√ßo tangente</a> , onde o normal √© sempre representado como um vetor na dire√ß√£o da semiaxe positiva <i>Z.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pf/3v/brpf3vfbmzd9pmna58ub5x7-age.png"></div><br>  Assumindo que o raio do hemisf√©rio seja um processo √∫nico, a forma√ß√£o de um n√∫cleo de uma amostra de 64 pontos se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      0.0 - 1.0 std::uniform_real_distribution&lt;float&gt; randomFloats(0.0, 1.0); std::default_random_engine generator; std::vector&lt;glm::vec3&gt; ssaoKernel; for (unsigned int i = 0; i &lt; 64; ++i) { glm::vec3 sample( randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) * 2.0 - 1.0, randomFloats(generator) ); sample = glm::normalize(sample); sample *= randomFloats(generator); float scale = (float)i / 64.0; ssaoKernel.push_back(sample); }</span></span></code> </pre> <br>  Aqui, selecionamos aleatoriamente as coordenadas <i>x</i> e <i>y</i> no intervalo [-1., 1.] e a coordenada <i>z</i> no intervalo [0., 1.] (se o intervalo for o mesmo que para <i>x</i> e <i>y</i> , obter√≠amos um n√∫cleo esf√©rico amostragem).  Os vetores de amostra resultantes ser√£o limitados aos hemisf√©rios, uma vez que o n√∫cleo da amostra ser√° orientado ao longo do normal para a superf√≠cie. <br><br>  No momento, todos os pontos da amostra s√£o distribu√≠dos aleatoriamente no interior do n√∫cleo, mas, para garantir a qualidade do efeito, as amostras mais pr√≥ximas da origem do n√∫cleo devem dar uma contribui√ß√£o maior ao c√°lculo do coeficiente de sombreamento.  Isso pode ser realizado alterando a distribui√ß√£o dos pontos de amostra formados, aumentando sua densidade perto da origem.  Esta tarefa √© facilmente realizada usando a fun√ß√£o de interpola√ß√£o de acelera√ß√£o: <br><br><pre> <code class="cpp hljs">scale = lerp(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, scale * scale); sample *= scale; ssaoKernel.push_back(sample); }</code> </pre> <br>  A fun√ß√£o <i>lerp ()</i> √© definida como: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + f * (b - a); }</code> </pre> <br>  Esse truque nos d√° uma distribui√ß√£o modificada, onde a maioria dos pontos de amostra fica perto da origem do kernel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h7/dy/xm/h7dyxm-1zerxg1krzbxszp7kzqi.png"></div><br>  Cada um dos vetores de amostra obtidos ser√° usado para alterar a coordenada do fragmento no espa√ßo de esp√©cies para obter dados sobre a geometria circundante.  Para obter resultados decentes ao trabalhar na viewport, voc√™ pode precisar de um n√∫mero impressionante de amostras, o que inevitavelmente afetar√° o desempenho.  No entanto, a introdu√ß√£o de ru√≠do pseudo-aleat√≥rio ou rota√ß√£o dos vetores de amostra em cada fragmento processado reduzir√° significativamente o n√∫mero necess√°rio de amostras com qualidade compar√°vel. <br><br><h2>  Rota√ß√£o aleat√≥ria do n√∫cleo da amostra </h2><br>  Portanto, a introdu√ß√£o da aleatoriedade na distribui√ß√£o de pontos no n√∫cleo da amostra pode reduzir significativamente a necessidade de o n√∫mero desses pontos obter um efeito de qualidade decente.  Seria poss√≠vel criar um vetor de rota√ß√£o aleat√≥ria para cada fragmento da cena, mas √© muito caro de mem√≥ria.  √â mais eficiente criar uma textura pequena contendo um conjunto de vetores de rota√ß√£o aleat√≥ria e us√°-la com o modo de repeti√ß√£o <i>GL_REPEAT definido</i> . <br><br>  Crie uma matriz 4x4 e preencha-a com vetores de rota√ß√£o aleat√≥ria orientados ao longo do vetor normal no espa√ßo tangente: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;glm::vec3&gt; ssaoNoise; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { glm::<span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, randomFloats(generator) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ssaoNoise.push_back(noise); }</code> </pre> <br>  Como o n√∫cleo est√° alinhado ao longo da semiaxe positiva <i>Z</i> no espa√ßo tangente, deixamos o componente <i>z</i> igual a zero - isso garantir√° a rota√ß√£o apenas em torno do eixo <i>Z.</i> <br><br>  Em seguida, crie uma textura 4x4 e preencha-a com nossa matriz de vetores de rota√ß√£o.  Certifique-se de usar o <i>modo de</i> reprodu√ß√£o <i>GL_REPEAT</i> para texturizar lado a lado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> noiseTexture; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;noiseTexture); glBindTexture(GL_TEXTURE_2D, noiseTexture); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, &amp;ssaoNoise[<span class="hljs-number"><span class="hljs-number">0</span></span>]); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</code> </pre> <br>  Bem, agora temos todos os dados necess√°rios para a implementa√ß√£o direta do algoritmo SSAO! <br><br><h2>  Shader SSAO </h2><br>  Um sombreador de efeito ser√° executado para cada fragmento de um quad de tela cheia, calculando o coeficiente de sombreamento em cada um deles.  Como os resultados ser√£o usados ‚Äã‚Äãem outro est√°gio de renderiza√ß√£o que cria a ilumina√ß√£o final, precisamos criar outro objeto buffer de estrutura para armazenar o resultado do shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoFBO; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoColorBuffer; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBuffer); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Como o resultado do algoritmo √© o √∫nico n√∫mero real dentro de [0., 1.], para armazenamento, ser√° suficiente criar uma textura com o √∫nico componente dispon√≠vel.  √â por isso que <i>GL_RED</i> √© definido como o formato interno para o buffer de cores. <br><br>  Em geral, o processo de renderiza√ß√£o do est√°gio SSAO se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  :  G- glBindFramebuffer(GL_FRAMEBUFFER, gBuffer); [...] glBindFramebuffer(GL_FRAMEBUFFER, 0); //  G-      SSAO glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO); glClear(GL_COLOR_BUFFER_BIT); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, gPosition); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, gNormal); glActiveTexture(GL_TEXTURE2); glBindTexture(GL_TEXTURE_2D, noiseTexture); shaderSSAO.use(); SendKernelSamplesToShader(); shaderSSAO.setMat4("projection", projection); RenderQuad(); glBindFramebuffer(GL_FRAMEBUFFER, 0); //  :    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); shaderLightingPass.use(); [...] glActiveTexture(GL_TEXTURE3); glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer); [...] RenderQuad();</span></span></code> </pre> <br>  O <i>shaderSSAO</i> aceita as texturas de buffer G necess√°rias como entrada, assim como a textura do ru√≠do e o n√∫cleo da amostra: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D texNoise; uniform vec3 samples[64]; uniform mat4 projection; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//             //      1280x720 const vec2 noiseScale = vec2(1280.0/4.0, 720.0/4.0); void main() { [...] }</span></span></span></span></code> </pre> <br>  Observe a vari√°vel <i>noiseScale</i> .  Nossa pequena textura com ru√≠do deve estar lado a lado em toda a superf√≠cie da tela, mas como as coordenadas da <i>TexCoords est√£o</i> dentro de [0., 1.], isso n√£o acontecer√° sem a nossa interven√ß√£o.  Para esses fins, calculamos o fator para as coordenadas da textura, que √© encontrado como a propor√ß√£o do tamanho da tela e o tamanho da textura do ru√≠do: <br><br><pre> <code class="cpp hljs">vec3 fragPos = texture(gPosition, TexCoords).xyz; vec3 normal = texture(gNormal, TexCoords).rgb; vec3 randomVec = texture(texNoise, TexCoords * noiseScale).xyz;</code> </pre> <br>  Como ao criar a textura de ru√≠do <i>texNoise</i> , definimos o modo de repeti√ß√£o como <i>GL_REPEAT</i> , agora ele ser√° repetido v√°rias vezes na superf√≠cie da tela.  Com <i>randomVec</i> , <i>fragPos</i> e valores <i>normais</i> dispon√≠veis, podemos criar uma matriz de transforma√ß√£o TBN do tangente para o espa√ßo da esp√©cie: <br><br><pre> <code class="cpp hljs">vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal)); vec3 bitangent = cross(normal, tangent); mat3 TBN = mat3(tangent, bitangent, normal);</code> </pre> <br>  Usando o processo de Gram-Schmidt, criamos uma base ortogonal aleatoriamente inclinada em cada fragmento com base no valor aleat√≥rio <i>randomVec</i> .  Um ponto importante: como nesse caso, n√£o importa para n√≥s que a matriz TBN esteja exatamente orientada ao longo da superf√≠cie do tri√¢ngulo (como no caso do mapeamento de paralaxe, aprox. <br><br>  Em seguida, examinamos a matriz do n√∫cleo da amostra, convertemos cada vetor de amostra do espa√ßo tangente para o espa√ßo da esp√©cie e obtemos sua soma com a posi√ß√£o atual do fragmento.  Em seguida, comparamos o valor da profundidade da quantidade resultante com o valor da profundidade obtido por amostragem da textura do buffer G correspondente. <br><br>  Embora pare√ßa confuso, vamos seguir as etapas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> occlusion = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; kernelSize; ++i) { <span class="hljs-comment"><span class="hljs-comment">//     vec3 sample = TBN * samples[i]; //      - sample = fragPos + sample * radius; [...] }</span></span></code> </pre> <br>  Aqui, <i>kernelSize</i> e <i>radius</i> s√£o vari√°veis ‚Äã‚Äãque controlam as caracter√≠sticas do efeito.  Nesse caso, eles s√£o 64 e 0,5, respectivamente.  A cada itera√ß√£o, traduzimos o vetor principal da amostra no espa√ßo de esp√©cies.  Em seguida, adicionamos ao valor obtido o deslocamento da amostra no espa√ßo de esp√©cies o valor da posi√ß√£o do fragmento no espa√ßo de esp√©cies.  Nesse caso, o valor do deslocamento √© multiplicado pela vari√°vel radius, que controla o raio do n√∫cleo da amostra de efeito SSAO. <br><br>  Ap√≥s essas etapas, devemos converter o vetor de <i>amostra</i> resultante no espa√ßo da tela, para que possamos selecionar a textura do buffer G que armazena as posi√ß√µes e profundidades dos fragmentos usando o valor projetado obtido.  Como a <i>amostra</i> est√° na viewport, precisamos da matriz de <i>proje√ß√£o</i> : <br><br><pre> <code class="cpp hljs">vec4 offset = vec4(sample, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); offset = projection * offset; <span class="hljs-comment"><span class="hljs-comment">//     offset.xyz /= offset.w; //   offset.xyz = offset.xyz * 0.5 + 0.5; //    [0., 1.]</span></span></code> </pre> <br>  Ap√≥s a convers√£o no espa√ßo do clipe, executamos manualmente a divis√£o da perspectiva, simplesmente dividindo os componentes <i>xyz</i> pelo componente <i>w</i> .  O vetor resultante em coordenadas de dispositivo normalizadas ( <i>NDC</i> ) √© convertido no intervalo de valores [0., 1.] para que possa ser usado como coordenadas de textura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sampleDepth = texture(gPosition, offset.xy).z;</code> </pre> <br>  Utilizamos os componentes <i>xy</i> do vetor de <i>amostra</i> para selecionar a partir da textura as posi√ß√µes do buffer G.  Obtemos o valor de profundidade (componentes <i>z</i> ) correspondente ao vetor de amostra quando visto da posi√ß√£o do observador (este √© o primeiro fragmento vis√≠vel n√£o blindado).  Se ao mesmo tempo a profundidade de amostragem obtida for maior que a profundidade armazenada, aumentamos o coeficiente de sombreamento: <br><br><pre> <code class="cpp hljs">occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>);</code> </pre> <br>  Observe o deslocamento da <i>polariza√ß√£o</i> , que √© adicionado √† profundidade do fragmento original (definido no exemplo como 0,025).  Esse deslocamento nem sempre √© necess√°rio, mas a presen√ßa de uma vari√°vel permite controlar a apar√™ncia do efeito SSAO e tamb√©m, em determinadas situa√ß√µes, remove problemas com ondula√ß√µes nas √°reas sombreadas. <br><br>  Mas isso n√£o √© tudo, pois essa implementa√ß√£o leva a artefatos vis√≠veis.  Ela se manifesta nos casos em que √© considerado um fragmento pr√≥ximo √† borda de uma determinada superf√≠cie.  Em tais situa√ß√µes, ao comparar as profundidades, o algoritmo captura inevitavelmente as profundidades das superf√≠cies, que podem estar muito atr√°s do considerado.  Nesses locais, o algoritmo aumenta erroneamente o grau de sombreamento, o que criar√° halos escuros percept√≠veis nas bordas dos objetos.  O artefato √© tratado introduzindo uma verifica√ß√£o de dist√¢ncia adicional (um exemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">John Chapman</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/yv/eq/zvyveqh3zc_rjcy6fo-z8d76eme.png"></div><br>  A verifica√ß√£o limitar√° a contribui√ß√£o ao coeficiente de sombreamento apenas para valores de profundidade dentro do raio da amostra: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rangeCheck = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, radius / <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(fragPos.z - sampleDepth)); occlusion += (sampleDepth &gt;= sample.z + bias ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * rangeCheck;</code> </pre> <br>  Tamb√©m usamos a fun√ß√£o GLSL <i>smoothstep ()</i> , que implementa a interpola√ß√£o suave do terceiro par√¢metro entre o primeiro e o segundo.  Nesse caso, retorne 0 se o terceiro par√¢metro for menor ou igual ao primeiro ou 1 se o terceiro par√¢metro for maior que ou igual ao segundo.  Se a diferen√ßa de profundidade estiver dentro do <i>raio</i> , seu valor ser√° suavizado no intervalo [0., 1.] de acordo com esta curva: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jq/9h/p4/jq9hp4-yun_sc277m6pslbjyin0.png"></div><br>  Se us√°ssemos limites claros nas condi√ß√µes de verifica√ß√£o da profundidade, isso adicionaria artefatos na forma de limites n√≠tidos nos locais em que os valores da diferen√ßa nas profundidades est√£o fora dos limites do <i>raio</i> . <br><br>  Com o toque final, normalizamos o valor do coeficiente de sombreamento usando o tamanho do n√∫cleo da amostra e registramos o resultado.  Tamb√©m invertemos o valor final subtraindo-o da unidade, para que voc√™ possa usar o valor final diretamente para modular o componente de fundo da ilumina√ß√£o sem etapas adicionais: <br><br><pre> <code class="cpp hljs">} occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = occlusion;</code> </pre> <br>  Para uma cena com um nanossuit mentiroso familiar para n√≥s, executar o shader SSAO fornece a seguinte textura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-z/a4/fx/-za4fxhsbref6easc-cgxnsp94q.png"></div><br>  Como voc√™ pode ver, o efeito do sombreamento de fundo cria uma boa ilus√£o de profundidade.  Somente a imagem de sa√≠da do shader j√° permite distinguir os detalhes da roupa e garantir que ela realmente fique no ch√£o e n√£o levite a alguma dist√¢ncia dela. <br><br>  No entanto, o efeito est√° longe de ser ideal, uma vez que o padr√£o de ru√≠do introduzido pela textura dos vetores de rota√ß√£o aleat√≥ria √© facilmente percept√≠vel.  Para suavizar o resultado do c√°lculo do SSAO, aplicamos um filtro de desfoque. <br><br><h2>  Desfocar sombreamento de fundo </h2><br>  Depois de criar o resultado do SSAO e antes da mistura final da ilumina√ß√£o, √© necess√°rio desfocar a textura que armazena dados no coeficiente de sombreamento.  Para fazer isso, teremos outro buffer de quadro: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ssaoBlurFBO, ssaoColorBufferBlur; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoBlurFBO); glBindFramebuffer(GL_FRAMEBUFFER, ssaoBlurFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;ssaoColorBufferBlur); glBindTexture(GL_TEXTURE_2D, ssaoColorBufferBlur); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBufferBlur, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  A coloca√ß√£o de uma textura de ru√≠do no espa√ßo da tela fornece uma caracter√≠stica de aleatoriedade bem definida que voc√™ pode usar para sua vantagem ao criar um filtro de desfoque: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out float FragColor; in vec2 TexCoords; uniform sampler2D ssaoInput; void main() { vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0)); float result = 0.0; for (int x = -2; x &lt; 2; ++x) { for (int y = -2; y &lt; 2; ++y) { vec2 offset = vec2(float(x), float(y)) * texelSize; result += texture(ssaoInput, TexCoords + offset).r; } } FragColor = result / (4.0 * 4.0); }</span></span></code> </pre> <br>  O sombreador simplesmente transita texels da textura SSAO com um deslocamento de -2 para +2, o que corresponde ao tamanho real da textura de ru√≠do.  O deslocamento √© igual ao tamanho exato de um texel: a fun√ß√£o textureSize <i>()</i> √© usada para o c√°lculo, que retorna <i>vec2</i> com as dimens√µes da textura especificada.  T.O.  O sombreador calcula a m√©dia dos resultados armazenados na textura, o que fornece um desfoque r√°pido e bastante eficaz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/0g/i7/5p0gi7qn_v5w738uyindxexally.png"></div><br>  No total, temos uma textura com dados de sombreamento de fundo para cada fragmento na tela - tudo est√° pronto para o est√°gio de redu√ß√£o final da imagem! <br><br><h2>  Aplicar sombreamento em segundo plano </h2><br>  A etapa de aplica√ß√£o do coeficiente de sombreamento no c√°lculo final da ilumina√ß√£o √© surpreendentemente simples: para cada fragmento, basta multiplicar o valor do componente de fundo da fonte de luz pelo coeficiente de sombreamento da textura preparada.  Voc√™ pode pegar um shader pronto com o modelo Blinn-Fong da li√ß√£o sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sombreamento adiado</a> e corrigi-lo um pouco: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D gPosition; uniform sampler2D gNormal; uniform sampler2D gAlbedo; uniform sampler2D ssao; struct Light { vec3 Position; vec3 Color; float Linear; float Quadratic; float Radius; }; uniform Light light; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    G- vec3 FragPos = texture(gPosition, TexCoords).rgb; vec3 Normal = texture(gNormal, TexCoords).rgb; vec3 Diffuse = texture(gAlbedo, TexCoords).rgb; float AmbientOcclusion = texture(ssao, TexCoords).r; //   -    //   :   -  vec3 ambient = vec3(0.3 * Diffuse * AmbientOcclusion); vec3 lighting = ambient; //    (0, 0, 0)   - vec3 viewDir = normalize(-FragPos); //   vec3 lightDir = normalize(light.Position - FragPos); vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * light.Color; //   vec3 halfwayDir = normalize(lightDir + viewDir); float spec = pow(max(dot(Normal, halfwayDir), 0.0), 8.0); vec3 specular = light.Color * spec; //   float dist = length(light.Position - FragPos); float attenuation = 1.0 / (1.0 + light.Linear * dist + light.Quadratic * dist * dist); diffuse *= attenuation; specular *= attenuation; lighting += diffuse + specular; FragColor = vec4(lighting, 1.0); }</span></span></span></span></code> </pre> <br>  Existem apenas duas mudan√ßas principais: a transi√ß√£o para os c√°lculos na viewport e a multiplica√ß√£o do componente de ilumina√ß√£o de fundo pelo valor de <i>AmbientOcclusion</i> .  Um exemplo de cena com um √∫nico ponto de luz azul: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/8_/1i/bz8_1in-othscilg_udfyscghg0.png"></div><br>  O c√≥digo fonte completo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  A manifesta√ß√£o do efeito SSAO depende fortemente de par√¢metros como <i>kernelSize</i> , <i>raio</i> e <i>vi√©s</i> , geralmente √© necess√°rio que voc√™ fa√ßa o ajuste fino deles para que o artista <i>elabore</i> um local / cena espec√≠fico.  N√£o h√° combina√ß√µes "melhores" e universais de par√¢metros: para algumas cenas, um pequeno raio do n√∫cleo da amostra √© bom, enquanto outras se beneficiam do aumento do raio e do n√∫mero de amostras.  O exemplo usa 64 pontos de amostra, o que, francamente, √© redundante, mas voc√™ sempre pode editar o c√≥digo e ver o que acontece com um n√∫mero menor de amostras. <br><br>  Al√©m dos uniformes listados, respons√°veis ‚Äã‚Äãpor definir o efeito, existe a possibilidade de controlar explicitamente a gravidade do efeito de sombreamento em segundo plano.  Para isso, basta elevar o coeficiente para um grau controlado por outro uniforme: <br><br><pre> <code class="cpp hljs">occlusion = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (occlusion / kernelSize); FragColor = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(occlusion, power);</code> </pre> <br>  Aconselho que voc√™ gaste algum tempo no jogo com as configura√ß√µes, pois isso dar√° uma melhor compreens√£o da natureza das altera√ß√µes na imagem final. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resumir, vale a pena dizer que, embora o efeito visual da aplica√ß√£o do SSAO seja bastante sutil, em cenas com ilumina√ß√£o bem posicionada, inegavelmente acrescenta uma fra√ß√£o not√°vel do realismo. </font><font style="vertical-align: inherit;">Ter essa ferramenta em seu arsenal √© certamente valioso.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recursos Adicionais </font></font></h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial do SSAO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Um excelente artigo de li√ß√£o de John Chapman, com base no qual o c√≥digo para esta li√ß√£o √© criado.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conhe√ßa os artefatos do SSAO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : um artigo muito valioso mostrando lucidamente n√£o apenas os problemas mais prementes com a qualidade do SSAO, mas tamb√©m maneiras de resolv√™-los. </font><font style="vertical-align: inherit;">Leitura recomendada.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSAO com reconstru√ß√£o de profundidade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Adendo √† li√ß√£o principal do SSAO do OGLDev sobre uma t√©cnica comumente usada para restaurar coordenadas de fragmentos com base na profundidade. </font><font style="vertical-align: inherit;">A import√¢ncia dessa abordagem se deve √† economia significativa de mem√≥ria devido √† falta de necessidade de armazenar posi√ß√µes no buffer G. </font><font style="vertical-align: inherit;">A abordagem √© t√£o universal que se aplica ao SSAO na medida em que.</font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Temos um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telegrama conf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para coordena√ß√£o de transfer√™ncias. </font><font style="vertical-align: inherit;">Se voc√™ tem um desejo s√©rio de ajudar com a tradu√ß√£o, √© bem-vindo!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421385/">https://habr.com/ru/post/pt421385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421375/index.html">Como a incerteza mata o com√©rcio</a></li>
<li><a href="../pt421377/index.html">7 equ√≠vocos de um gerente de projeto iniciante no gamedev</a></li>
<li><a href="../pt421379/index.html">Cultura t√≥xica da Intel</a></li>
<li><a href="../pt421381/index.html">Curso Gratuito Cisco Administrator ASA</a></li>
<li><a href="../pt421383/index.html">Epic Growth Conference Autumn 2018 - confer√™ncia de marketing de produto em Moscou</a></li>
<li><a href="../pt421387/index.html">Entrevista com Lennart Pottering no Linux Piter sobre mudan√ßas no Linux, sobre systemd e por que participar de confer√™ncias</a></li>
<li><a href="../pt421389/index.html">Separa√ß√£o de poderes administrativos em Zimbra</a></li>
<li><a href="../pt421391/index.html">HackThings - um grande hackathon na Internet das coisas de 7 a 9 de setembro na Skoltech</a></li>
<li><a href="../pt421393/index.html">Cesta de Mailchimp abandonada: um guia para os pregui√ßosos</a></li>
<li><a href="../pt421395/index.html">Relat√≥rio do Clube de Roma 2018, cap√≠tulo 3.7: ‚ÄúClima: boas not√≠cias, mas grandes problemas‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>