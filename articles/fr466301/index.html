<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏭 🛃 👤 Autre chose: des packages d'application Haiku? 💪🏽 👩🏿‍🚀 🍠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR : Haiku peut-il obtenir un support approprié pour les packages d'application, tels que les répertoires d'application (comme .app sur Mac) et / ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Autre chose: des packages d'application Haiku?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/466301/"><p><img src="https://habrastorage.org/webt/9x/n3/tt/9xn3tthtqlazwuhk6ow9mr8hq_s.png"></p><br><p> <strong>TL; DR</strong> : Haiku peut-il obtenir un support approprié pour les packages d'application, tels que les répertoires d'application (comme <code>.app</code> sur Mac) et / ou les images d'application (Linux <code>AppImage</code> )?  Il me semble que ce sera un ajout digne, qui est plus facile à mettre en œuvre correctement que dans d'autres systèmes, car la plupart des infrastructures sont déjà là. </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il y a une semaine,</a> j'ai découvert Haiku, un système étonnamment bon.  Eh bien, depuis que je m'intéresse depuis longtemps aux catalogues et aux images d'application (inspirés de la simplicité du Macintosh), il n'est pas surprenant qu'une idée m'est venue à l'esprit ... </p><br><p>  Pour une compréhension complète: Je suis le créateur et l'auteur d'AppImage, un format de distribution d'applications Linux visant à la simplicité Mac et offrant un contrôle complet aux auteurs d'applications et aux utilisateurs finaux (voulez en savoir plus - voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> ). </p><br><h2 id="chto-esli-my-sdelaem-appimage-dlya-haiku">  Et si nous faisons une AppImage pour Haiku? </h2><br><p>  Réfléchissons un peu, purement théoriquement: que faut-il faire pour obtenir une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppImage</a> , ou quelque chose de similaire, sur Haiku?  Il n'est pas nécessaire de créer quelque chose en ce moment, car le système qui est déjà dans Haiku fonctionne de manière incroyable, mais une expérience imaginaire se révélerait agréable.  Il démontre également la sophistication de Haiku, par rapport aux environnements de bureau Linux où de telles choses sont terriblement difficiles (j'ai le droit de le dire: je débogue depuis 10 ans maintenant). </p><br><p><img src="https://habrastorage.org/webt/zg/jj/jx/zgjjjxz_1kt8tzdf4r8_1yfmtsu.png"><br>  <em>Sur Macintosh System 1, chaque application était un fichier distinct qui était «géré» dans le Finder.</em>  <em>En utilisant AppImage, j'essaie de recréer la même expérience utilisateur sous Linux.</em> </p><br><p>  Tout d'abord, qu'est-ce que AppImage?  Il s'agit d'un système de libération d'applications tierces (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ultimaker Cura</a> ) qui vous permet de libérer des applications quand et comment elles chassent: vous n'avez pas besoin de connaître les fonctionnalités de diverses distributions, de construire des politiques ou de construire une infrastructure, elles n'ont pas besoin de l'assistance de mainteneurs et elles ne disent pas aux utilisateurs quoi (non) peut être installé sur les ordinateurs.  AppImage doit être compris comme quelque chose comme un package pour Mac au format <code>.app</code> intérieur d'une image disque <code>.dmg</code> .  La principale différence est que les applications ne sont pas copiées, mais restent toujours dans AppImage, tout comme les packages Haiku <code>.hpkg</code> sont installés et ne sont jamais installés dans le sens habituel. </p><br><p>  Pendant plus de 10 ans de son existence, AppImage a gagné en attrait et en popularité: Linus Torvalds lui-même l'a approuvé publiquement, et des projets répandus (par exemple, LibreOffice, Krita, Inkscape, Scribus, ImageMagick) l'ont accepté comme principal moyen de distribuer des assemblages continus ou nocturnes, non interférer avec les applications utilisateur installées ou non installées.  Cependant, les bureaux et les distributions Linux s'accrochent le plus souvent au modèle de distribution centralisé traditionnel basé sur les mainteneurs et / ou promeuvent leurs propres programmes d'entreprise et / ou d'ingénierie basés sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flatpak</a> (RedHat, Fedora, GNOME) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Snappy</a> (Canonical, Ubuntu) .  Vient <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">à drôle</a> . </p><br><h3 id="kak-vse-rabotaet">  Comment ça marche </h3><br><ul><li>  Chaque AppImage contient 2 parties: un petit ELF exécutable à double-clic (le soi-disant. <code>runtime.c</code> ), suivi de l'image du système de fichiers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SquashFS</a> . </li></ul><br><p><img src="https://habrastorage.org/webt/mj/ry/_u/mjry_uymqpffrzpljadx3vflzbm.png"></p><br><ul><li>  Le système de fichiers SquashFS contient une charge utile sous la forme d'une application et tout ce dont vous avez besoin pour l'exécuter, ce qui, dans votre bon sens, ne peut pas être considéré comme faisant partie de l'installation par défaut pour chaque système cible assez récent (distribution Linux).  Il contient également des métadonnées, par exemple, le nom de l'application, des icônes, des types MIME, etc., etc. </li></ul><br><p><img src="https://habrastorage.org/webt/7v/16/zx/7v16zxiadfjhqaeqrkbb9ctdfm4.png"></p><br><ul><li>  Lorsqu'il est lancé par l'utilisateur, le runtime utilise FUSE et squashfuse pour monter le système de fichiers, après quoi il traite le lancement d'un point d'entrée (le soi-disant AppRun) à l'intérieur de l'AppImage monté. <br>  Le système de fichiers est démonté une fois le processus terminé. </li></ul><br><p>  Il semble que tout soit simple. </p><br><p>  Et ces choses compliquent les choses: </p><br><ul><li>  avec une telle variété de distributions Linux, il n'y a rien «dans leur bon sens» que vous pouvez appeler «une partie de l'installation par défaut pour chaque nouveau système cible».  Nous contournons ce problème en assemblant une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exclusion</a> , ce qui nous permet de déterminer ce qui sera empaqueté dans AppImage et ce qui doit être pris ailleurs.  Dans le même temps, nous manquons parfois, malgré le fait qu'en général, tout fonctionne bien.  Pour cette raison, nous recommandons aux créateurs de packages de vérifier AppImages sur tous les systèmes cibles (distributions). </li><li>  Les applications sous forme de charge utile doivent être itinérantes dans le système de fichiers.  Malheureusement, dans de nombreuses applications, les chemins absolus vers, par exemple, les ressources dans <code>/usr/share</code> codés en dur.  Cela doit être corrigé d'une manière ou d'une autre.  De plus, vous devez soit exporter <code>LD_LIBRARY_PATH</code> , soit corriger <code>rpath</code> pour que le chargeur puisse trouver les bibliothèques associées.  La première méthode a ses inconvénients (qui sont gérés de manière complexe), et la seconde est tout simplement lourde. </li><li>  Le plus grand piège UX pour les utilisateurs consiste à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">définir le bit exécutable</a> dans le fichier AppImage après le téléchargement.  Croyez-le ou non, pour certains, c'est une véritable barrière.  La nécessité de définir un bit exécutable est lourde même pour les utilisateurs avancés.  Comme solution de contournement, nous avons proposé d'installer un petit service qui surveille les fichiers AppImage et définit le bit exécutable pour eux.  Dans sa forme pure, pas la meilleure solution, car cela ne fonctionnera pas hors de la boîte.  Les distributions Linux ne fournissent pas ce service, par conséquent, les utilisateurs prêts à l'emploi ne se portent pas bien. </li><li>  Les utilisateurs de Linux s'attendent à ce que la nouvelle application ait une icône dans le menu de lancement.  Vous ne pouvez pas dire au système: "Regardez, il y a une nouvelle application, travaillons." Au lieu de cela, selon la spécification XDG, vous devez copier le fichier <code>.desktop</code> à l'emplacement souhaité dans <code>/usr</code> pour une installation à l'échelle du système ou dans <code>$HOME</code> pour une installation individuelle. Icônes de certaines tailles, selon la spécification XDG, vous devez le placer à certains endroits dans <code>usr</code> ou <code>$HOME</code> , puis exécuter des commandes dans l'environnement de travail pour mettre à jour le cache des icônes, ou espérer que le gestionnaire de l'environnement de travail le découvrira et détectera automatiquement tout. De même avec les types MIME. Comme solution de contournement, il propose  Pour utiliser le même service, qui, en plus de définir l'indicateur d'exécution, copiera, s'il y a des icônes, etc. dans AppImage, d'AppImage vers les emplacements corrects selon le XDG, il est supposé que le service effacera tout lors de la suppression ou du déplacement. Bien sûr, il existe des différences de comportement pour chacun environnement de travail, dans les formats de fichiers graphiques, leurs tailles, les emplacements de stockage et les moyens de mettre à jour les caches, ce qui crée un problème. En bref, cette méthode est une béquille. </li><li>  Si ce qui précède ne suffit pas, il n'y a pas d'icône AppImage dans le gestionnaire de fichiers.  Dans le monde Linux, ils n'ont toujours pas décidé d'implémenter elficon (malgré la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discussion</a> et l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">implémentation</a> ), il est donc impossible d'incorporer l'icône directement dans l'application.  Il s'avère donc que les applications dans le gestionnaire de fichiers n'ont pas leurs propres icônes (pas de différence, AppImage ou autre), elles ne sont que dans le menu Démarrer.  Comme solution de contournement, nous utilisons des miniatures - un mécanisme qui a été développé à l'origine pour que les gestionnaires de bureau puissent afficher des miniatures pour prévisualiser les fichiers graphiques sous forme d'icônes.  Par conséquent, le service de définition du bit exécutable fonctionne également comme un «miniaturiseur», créant et enregistrant des miniatures d'icônes aux endroits correspondants <code>/usr</code> et <code>$HOME</code> .  Ce service effectue également la suppression si AppImage est supprimé ou déplacé.  Étant donné que chaque gestionnaire de bureau se comporte un peu différemment, par exemple, dans quels formats il accepte les icônes, dans quelles tailles ou à quels endroits, tout cela est vraiment douloureux. </li><li>  L'application se bloque simplement au moment de l'exécution si des erreurs se produisent (par exemple, il existe une bibliothèque qui ne fait pas partie du système de base et n'est pas fournie dans AppImage), et personne ne dit à l'utilisateur dans l'interface graphique ce qui se passe exactement.  Nous avons commencé à contourner ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème en</a> utilisant des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notifications</a> sur le bureau, ce qui signifie que nous devons détecter les erreurs dans la ligne de commande, les convertir en messages compréhensibles par l'utilisateur, qui doivent ensuite être affichés sur le bureau.  Et bien sûr, chaque environnement de travail les traite un peu différemment. </li><li>  Pour le moment (septembre 2019, traducteur environ), je n'ai pas trouvé de moyen simple de dire au système que le fichier <code>1.png</code> être ouvert en utilisant Krita et <code>2.png</code> - en utilisant GIMP. </li></ul><br><p><img src="https://habrastorage.org/webt/hi/vm/wf/hivmwfnwibvtqftyv9re6qqcscc.png"><br>  <em>L'emplacement de stockage pour les spécifications multi-bureaux utilisées par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GNOME</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KDE</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Xfce</a> est freedesktop.org</em> </p><br><p>  Il est difficile, voire impossible, d'atteindre un niveau de sophistication profondément ancré dans l'environnement de travail de Haiku, en raison des spécifications <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">XDG de freedesktop.org</a> pour le cross-desktop, ainsi que des implémentations de gestionnaires de bureau basées sur ces spécifications.  À titre d'exemple, nous pouvons citer une icône Firefox à l'échelle du système: apparemment, les auteurs de XDG ne pensaient même pas que l'utilisateur pouvait avoir plusieurs versions de la même application. </p><br><p><img src="https://habrastorage.org/webt/q7/ru/ul/q7ruul0hbp0pcgpc0wa5qubwwz8.png"><br>  <em>Icônes de différentes versions de Firefox</em> </p><br><p>  Je me demandais ce que le monde Linux pouvait apprendre de Mac OS X, afin de ne pas gâcher l'intégration du système.  Si vous avez le temps et que vous le faites, assurez-vous de lire ce qu'Arno Gourdol, l'un des premiers ingénieurs de Mac OS X, a déclaré: </p><br><blockquote>  Nous voulions installer l'application aussi facilement que faire glisser l'icône de l'application depuis un endroit (serveur, lecteur externe) sur le disque de votre ordinateur.  Pour ce faire, toutes les informations sont stockées dans le package d'application, y compris les icônes, la version, le type de fichier en cours de traitement, le type de schémas d'URL que le système doit connaître pour traiter l'application.  Cela inclut également des informations sur le «stockage centralisé» dans la base de données Icon Services et Launch Services.  Pour maintenir les performances, les applications sont `` découvertes '' à plusieurs endroits `` bien connus '': dans le répertoire système et utilisateur Applications, ainsi que dans certains autres, automatiquement si l'utilisateur est passé au Finder dans le répertoire contenant l'application.  En pratique, cela a très bien fonctionné. </blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://youtu.be/qQsnqWJ8D2c</a> <br>  <em>Apple WWDC 2000 Session 144 - Mac OS X: empaquetage d'applications et impression de documents.</em> </p><br><p>  Il n'y a rien de similaire à cette infrastructure sur les bureaux Linux, nous recherchons donc des solutions de contournement autour des contraintes structurelles dans le projet AppImage. </p><br><p><img src="https://habrastorage.org/webt/4f/cv/te/4fcvtehvp1ftttgg6ebjfb5t0qu.png"><br>  <em>Haiku est-il pressé d'aider?</em> </p><br><p>  Et encore une chose: les plates-formes Linux comme base des environnements de travail, en règle générale, sont si peu spécifiées que de nombreuses choses très simples dans un système cohérent avec une pile complète déçoivent la fragmentation et la complexité de Linux.  J'ai consacré tout un rapport aux problèmes liés à la plate-forme Linux pour les environnements de travail (des développeurs avertis l'ont confirmé: tout restera ainsi très longtemps). </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SQ8OXf7o6UA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Mon rapport sur les environnements de bureau Linux en 2018</em> </p><br><p>  Même Linus Torvalds a admis que c'était à cause de la fragmentation que l'idée d'environnements de travail avait échoué. </p><br><p>  Ravi de voir Haiku! </p><br><h2 id="s-haiku-vse-stanovitsya-potryasayusche-prostym">  Avec Haiku, tout est incroyablement simple. </h2><br><p>  Bien que l'approche naïve du portage d'AppImage vers Haiku consiste simplement à essayer de construire (principalement runtime.c et service) ses composants (ce qui peut même être possible!), Cela n'apportera pas beaucoup d'avantages à Haiku.  Parce qu'en fait, la plupart de ces problèmes ont été résolus par Haiku et conceptuellement justifiés.  Haiku fournit exactement ces briques pour l'infrastructure système que je cherchais depuis si longtemps dans les environnements de bureau Linux et je ne pouvais pas croire qu'elles n'étaient pas là.  À savoir: </p><br><p><img src="https://habrastorage.org/webt/g1/gb/ur/g1gbur48coofaseihxmf3qntdao.gif"><br>  <em>Croyez-le ou non, de nombreux utilisateurs de Linux ne peuvent pas surmonter cela.</em>  <em>Chez Haiku, tout se fait automatiquement!</em> </p><br><ul><li>  Les fichiers ELF qui n'ont pas de bit exécutable le reçoivent automatiquement lorsque vous double-cliquez dans le gestionnaire de fichiers. </li><li>  Les applications peuvent avoir des ressources intégrées, par exemple, des icônes qui apparaissent dans le gestionnaire de fichiers.  Vous n'avez pas besoin de copier un groupe d'images dans des répertoires d'icônes spéciaux et, par conséquent, vous n'avez pas besoin de les nettoyer après avoir supprimé ou déplacé l'application. </li><li>  Il existe une base de données pour lier les applications aux documents, il n'est pas nécessaire de copier de fichiers pour cela. </li><li>  Dans le répertoire lib / à côté de l'exécutable, les bibliothèques sont recherchées par défaut. </li><li>  Il n'y a pas de nombreuses distributions et environnements de bureau, tout cela fonctionne - fonctionne partout. </li><li>  Il n'y a pas de module de lancement distinct qui diffère du répertoire Applications. </li><li>  Les applications n'ont pas de chemin absolu intégré vers leurs ressources; il existe des fonctions spéciales pour déterminer l'emplacement au moment de l'exécution. </li><li>  L'idée d'images compressées du système de fichiers a été introduite: il s'agit de n'importe quel package hpkg.  Tous sont montés par le noyau. </li><li>  Chaque fichier est ouvert par l'application qui l'a créé, sauf si vous spécifiez explicitement autre chose.  Comme c'est génial! </li></ul><br><p><img src="https://habrastorage.org/webt/l8/ur/av/l8uravftyfwibziifquz7o7mg5g.png"><br>  <em>Deux fichiers png.</em>  <em>Faites attention aux différentes icônes montrant qu'elles seront ouvertes par différentes applications en double-cliquant.</em>  <em>Faites également attention au menu déroulant "Ouvrir avec:", où l'utilisateur peut sélectionner une application distincte.</em>  <em>Comme c'est facile!</em> </p><br><p>  Il semble que de nombreuses béquilles et solutions de contournement nécessaires à AppImage sur Linux deviennent inutiles sur Haiku, qui est basé sur la simplicité et la sophistication, grâce auxquelles il répond à la plupart de nos besoins. </p><br><h2 id="nuzhny-li-haiku-pakety-prilozheniy-v-konce-koncov">  Haiku a-t-il finalement besoin de packages d'application? </h2><br><p>  Cela mène à une grande question.  Si ce serait un ordre de grandeur plus facile de créer un système comme AppImage sur Haiku que sur Linux, cela en vaudrait-il la peine?  Ou Haiku avec son système de paquets hpkg a-t-il pratiquement éliminé la nécessité de développer une telle idée?  Eh bien, pour la réponse, vous devez examiner la motivation de l'existence d'AppImages. </p><br><h3 id="vzglyad-so-storony-polzovatelya">  Vue de l'utilisateur </h3><br><p>  Jetez un œil à notre utilisateur final: </p><br><ul><li>  Je souhaite installer l'application sans demander le mot de passe administrateur (root).  <em>Sur Haiku, il n'y a pas de concept d'administrateur, l'utilisateur a le contrôle total, car il s'agit d'un système personnel!</em>  (En principe, vous pouvez imaginer cela en mode multi-utilisateurs, j'espère que les développeurs garderont la simplicité) </li><li>  Je veux obtenir les dernières et meilleures versions des applications, ne pas attendre qu'elles apparaissent dans ma distribution (le plus souvent cela signifie "jamais", du moins si vous ne mettez pas à jour l'intégralité du système d'exploitation).  <em>Sur Haiku, cela est "résolu" avec des versions flottantes.</em>  <em>Cela signifie qu'il est possible d'obtenir les dernières et meilleures versions d'applications, mais pour cela, vous devez constamment mettre à jour le reste du système, en le transformant en une "cible mobile"</em> . </li><li>  Je veux plusieurs versions de la même application à proximité, car vous ne pouvez pas savoir ce qui a été cassé dans la dernière version, ou, en tant que développeur Web, je dois vérifier mon travail sous différentes versions du navigateur.  <em>Haiku a résolu le premier, mais pas le deuxième problème.</em>  <em>Les mises à jour sont annulées, mais uniquement pour l'ensemble du système, il est impossible (comme je le sais) de lancer, par exemple, plusieurs versions de WebPositive ou LibreOffice en même temps.</em> </li></ul><br><p>  L'un des développeurs écrit: </p><br><blockquote>  En substance, la justification est la suivante: le cas d'utilisation est si rare que l'optimisation n'a pas de sens pour lui;  le traiter comme un cas particulier chez HaikuPorts semble plus qu'acceptable. </blockquote><br><ul><li>  Je dois enregistrer les applications où je veux, et non sur le disque de démarrage.  Je manque souvent d'espace sur les disques, j'ai donc besoin de connecter un lecteur externe ou un répertoire réseau pour stocker les applications (toutes les versions que j'ai téléchargées).  Si je connecte un tel lecteur, j'ai besoin que les applications soient lancées en double-cliquant.  <em>Haiku enregistre les anciennes versions des packages, mais je ne sais pas comment les déplacer vers un disque externe, ni comment appeler des applications à partir de là plus tard.</em> </li></ul><br><p>  Commentaire du développeur: </p><br><blockquote>  Techniquement, cela est déjà possible avec la commande mount.  Bien sûr, nous créerons une interface graphique pour cela dès que suffisamment d'utilisateurs intéressés seront réunis. </blockquote><br><ul><li>  Je n'ai pas besoin de millions de fichiers dispersés dans le système de fichiers que je ne peux pas gérer moi-même manuellement.  Je veux un fichier par application, que je peux facilement télécharger, déplacer, supprimer.  <em>Sur Haiku, ce problème a été résolu à l'aide de packages <code>.hpkg</code> , qui transfèrent, par exemple python, de milliers de fichiers à un.</em>  <em>Mais s'il y a, par exemple, Scribus utilisant python, alors je dois gérer au moins deux fichiers.</em>  <em>Et je dois faire attention à ce que leurs versions fonctionnent ensemble.</em> </li></ul><br><p><img src="https://habrastorage.org/webt/38/4b/qi/384bqiagnw7mg50rjdaaceoggpo.jpeg"><br>  <em>De nombreuses versions d'AppImages fonctionnant côte à côte sur un seul Linux</em> </p><br><h3 id="vzglyad-so-storony-razrabotchika-prilozheniy">  Vue du côté du développeur d'application </h3><br><p>  Regardons du point de vue du développeur de l'application: </p><br><ul><li>  Je souhaite gérer l'ensemble de l'expérience utilisateur.  Je ne veux pas dépendre du système d'exploitation, qui me dira quand et comment je devrais publier les applications.  <em>Chez Haiku, les développeurs peuvent travailler avec leurs propres référentiels hpkg, mais cela signifie que les utilisateurs devront les configurer manuellement, ce qui rend cette idée moins attrayante.</em> </li><li>  J'ai une page de téléchargement sur mon site Web où je distribue <code>.exe</code> pour Windows, <code>.dmg</code> pour Mac et <code>.AppImage</code> pour Linux.  Ou peut-être que je veux monétiser l'accès à cette page, est-ce possible?  De quoi ai-je besoin pour publier sur Haiku?  <em>Assez de fichier <code>.hpkg</code> avec les dépendances de <code>.hpkg</code> uniquement</em> </li><li>  Mon logiciel a besoin de certaines versions d'autres logiciels.  Par exemple, il est connu que Krita a besoin d'une version fixe de Qt, ou Qt, qui est affinée à une version spécifique de Krita, au moins jusqu'à ce que les corrections reviennent à Qt.  <em>Vous pouvez emballer votre propre Qt pour l'application dans le package <code>.hpkg</code> , mais ce n'est probablement pas le bienvenu.</em> </li></ul><br><p><img src="https://habrastorage.org/webt/wv/-3/hy/wv-3hy_nmufyuir2fsgcttwbu0q.png"><br>  <em>Page de téléchargement normal des applications.</em>  <em>Que placer ici pour Haiku?</em> </p><br><p>  Les bundles (existants en tant que répertoires d'application comme AppDir ou <code>.app</code> dans le style Apple) et / ou les images (en tant qu'AppImages ou <code>.dmg</code> Apple fortement modifiés) seront-ils des ajouts utiles à l'environnement de travail Haiku?  Ou va-t-il diluer le tableau dans son ensemble et entraîner une fragmentation, et donc ajouter de la complexité?  Je suis déchiré: d'une part, la beauté et la sophistication du Haiku sont basées sur le fait qu'il y a généralement une façon de faire quelque chose, pas beaucoup.   ,      /     ,     ,         . </p><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mr. waddlesplash</a> </p><br><blockquote>  Linux  ( <em>   , — . </em> )       .  Haiku      . </blockquote><br><h2 id="a-vy-chto-dumaete">    ? </h2><br><h3 id="prezhde-chem-otvetite">   ... </h3><br><p> ,     :   <em> </em> —   Haiku: </p><br><p><img src="https://habrastorage.org/webt/vh/fl/i3/vhfli3p-el8xxez6xruqbsdiocm.png"><br> <em>     Haiku,       </em> </p><br><p>      , , ,  Macintosh Finder.    ,    QtCreator          "QtCreator",     ? </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> : </p><br><blockquote>  ,       ,             ?  ,  -         ? </blockquote><p>       Haiku,        ?  , . </p><br><p>  mr. waddlesplash: </p><br><blockquote> ,      :       ,  ,  -              .      BeOS R5  Haiku —   ... </blockquote><p>  ! </p><br><h3 id="kakoy-plan-deystviy-dolzhna-prinyat-haiku">      Haiku? </h3><br><p>      hpkg,    : </p><br><ul><li>    <code>.hpkg</code> </li><li>      (  ,     )  <code>.hpkg</code> ( 80%  ) </li><li> ,   <code>.hpkg</code> ,          ( , QtCreator):      <code>.hpkg</code> ,   . </li></ul><br><p> mr. waddlesplash : </p><br><blockquote>  ,  ,  —    <code>/system/apps</code> ,       Deskbar    ,  <code>/system/apps</code>    ,        (   MacOS).     Haiku  ,   ,  , . </blockquote><br><ul><li> Haiku      , ,     ,    ,     "  ",     ,      ( 20%  ).         <code>.hpkg</code> ,   ,     — . (,       <code>.hpkg</code>   ,      — ,          .    !    — .)   ,          <code>.hpkg</code> ,         ,       HaikuDepot…    ). </li></ul><br><p>   mr. waddlesplash: </p><br><blockquote>            .       ""  pkgman    . </blockquote><p>      hpkg,    .     ,    . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Haiku  ,        ,      ,       Linux.   <code>.hpkg</code> —    ,       .   ,        Haiku  .      —    ,  Haiku,      ,  .      Haiku   .    ,  ,       ,    Haiku.   ,       «-».    10           Linux,         Haiku,   ,   ,   .           ,   ,    Haiku   ,  , —     .  ,     ,    <code>hpkg</code>   ,     . ,  Haiku          ,   , ( )    "".  ,    ? </p><br><p>  !   Haiku      DVD  USB,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br>  ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">telegram-</a> . </p><br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">      C  C++.   Haiku OS</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> :       Haiku. </p><br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466301/">https://habr.com/ru/post/fr466301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466287/index.html">Rapport et recherche sur la fiabilité des segments Internet nationaux 2019</a></li>
<li><a href="../fr466289/index.html">Initiatives législatives. Étrange, mais présenté à la Douma d'État</a></li>
<li><a href="../fr466291/index.html">Enquête de durabilité des segments Internet nationaux pour 2019</a></li>
<li><a href="../fr466295/index.html">Cache de secours indolore sur Scala</a></li>
<li><a href="../fr466299/index.html">Des sociologues russes ont mené le premier sondage mondial sur les chatbots</a></li>
<li><a href="../fr466305/index.html">Takashi Kokubun: comment accélérer l'exécution des applications Ruby</a></li>
<li><a href="../fr466307/index.html">Comment concevoir SCS</a></li>
<li><a href="../fr466311/index.html">Atelier SLS 6 septembre</a></li>
<li><a href="../fr466315/index.html">@Pythonetc compilation, août 2019</a></li>
<li><a href="../fr466317/index.html">Trucs et astuces de ma chaîne Telegram @pythonetc, août 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>