<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚨 ⛹🏽 💼 OOP dalam gambar 💻 🎥 🤞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OOP (Pemrograman Berorientasi Objek) telah menjadi bagian integral dari pengembangan banyak proyek modern, tetapi meskipun populer, paradigma ini jauh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP dalam gambar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463125/"> OOP (Pemrograman Berorientasi Objek) telah menjadi bagian integral dari pengembangan banyak proyek modern, tetapi meskipun populer, paradigma ini jauh dari satu-satunya.  Jika Anda sudah tahu cara bekerja dengan paradigma lain dan ingin membiasakan diri Anda dengan okultisme OOP, maka di depan Anda ada gambar dan animasi yang agak panjang dan dua megabita.  Transformer akan berfungsi sebagai contoh. <br><br><img src="https://habrastorage.org/webt/uz/6p/vj/uz6pvjyue0ifmhkhy-h6bpflgwk.jpeg"><br><a name="habracut"></a><br>  Hal pertama yang harus dijawab adalah mengapa?  Ideologi berorientasi objek dikembangkan sebagai upaya untuk menghubungkan perilaku entitas dengan data dan proyek objek dunia nyata dan proses bisnis ke dalam kode program.  Diperkirakan bahwa kode semacam itu lebih mudah dibaca dan dipahami oleh seseorang, karena sudah lazim bagi orang untuk memandang dunia sekitar sebagai banyak objek yang saling berinteraksi, yang dapat menerima klasifikasi tertentu.  Apakah mungkin bagi para ideolog untuk mencapai tujuan, sulit untuk menjawab dengan tegas, tetapi secara de facto kami memiliki banyak proyek di mana programmer akan membutuhkan OOP. <br><br>  Anda seharusnya tidak berpikir bahwa OOP entah bagaimana akan secara ajaib mempercepat penulisan program, dan mengharapkan situasi di mana penduduk Villaribo telah meluncurkan proyek OOP untuk bekerja, dan penduduk Villabaggio masih mencuci kode spageti yang tebal.  Dalam kebanyakan kasus, ini tidak demikian, dan waktu disimpan bukan pada tahap pengembangan, tetapi pada tahap dukungan (ekspansi, modifikasi, debugging dan pengujian), yaitu, dalam jangka panjang.  Jika Anda perlu menulis skrip satu kali yang tidak memerlukan dukungan berikutnya, maka OOP dalam tugas ini kemungkinan besar tidak berguna.  Namun, bagian penting dari siklus hidup sebagian besar proyek modern adalah tepatnya dukungan dan ekspansi.  Memiliki OOP sendiri tidak membuat arsitektur Anda sempurna, dan sebaliknya dapat menyebabkan komplikasi yang tidak perlu. <br><br>  Terkadang Anda mungkin menghadapi kritik terhadap kinerja program OOP.  Memang benar bahwa ada sedikit overhead, tetapi begitu tidak signifikan sehingga dalam kebanyakan kasus dapat diabaikan demi keuntungan.  Namun demikian, dalam kemacetan di mana jutaan objek per detik harus dibuat atau diproses dalam satu utas, ada baiknya setidaknya merevisi kebutuhan OOP, karena bahkan biaya minimum dalam jumlah seperti itu dapat secara signifikan mempengaruhi kinerja.  Profiling akan membantu Anda menangkap perbedaan dan membuat keputusan.  Dalam kasus lain, katakanlah, di mana bagian terbesar dari kecepatan terletak pada IO, pengabaian objek akan menjadi optimasi prematur. <br><br>  Sesuai sifatnya, pemrograman berorientasi objek paling baik dijelaskan dengan contoh-contoh.  Seperti yang dijanjikan, pasien kami akan menjadi transformer.  Saya bukan transformator, dan saya belum membaca komik, oleh karena itu, dalam contoh saya akan dibimbing oleh Wikipedia dan fantasi. <br><br><h2>  Kelas dan Objek </h2><br>  Penyimpangan liris segera: pendekatan berorientasi objek dimungkinkan tanpa kelas, tetapi kami akan mempertimbangkan, saya minta maaf atas permainan kata-kata, skema klasik, di mana kelas adalah segalanya bagi kami. <br><br>  Penjelasan paling sederhana: kelas adalah gambar transformator, dan instance kelas ini adalah transformer spesifik, misalnya, Optimus Prime atau Oleg.  Dan meskipun mereka berkumpul menurut satu gambar, mereka dapat berjalan, mengubah dan menembak dengan cara yang sama, mereka berdua memiliki kondisi unik mereka sendiri.  Status adalah serangkaian sifat yang berubah.  Oleh karena itu, dalam dua objek berbeda dari kelas yang sama, kita dapat mengamati nama, umur, lokasi, tingkat muatan, jumlah amunisi, dan sebagainya yang berbeda. Keberadaan properti ini dan tipenya dijelaskan di dalam kelas. <br><br>  Dengan demikian, kelas adalah deskripsi properti dan perilaku apa yang akan dimiliki suatu objek.  Dan sebuah objek adalah instance dengan keadaan sendiri dari properti ini. <br><br>  Kami mengatakan "properti dan perilaku", tetapi entah bagaimana itu terdengar abstrak dan tidak dapat dipahami.  Akan lebih akrab bagi seorang programmer terdengar seperti ini: "variabel dan fungsi".  Bahkan, "properti" adalah variabel biasa yang sama, mereka hanya atribut dari beberapa objek (mereka disebut bidang objek).  Demikian pula, "perilaku" adalah fungsi dari suatu objek (mereka disebut metode), yang juga merupakan atribut dari objek.  Perbedaan antara metode objek dan fungsi biasa hanya bahwa metode memiliki akses ke keadaannya sendiri melalui bidang. <br><br>  Secara total, kami memiliki metode dan properti yang merupakan atribut.  Bagaimana cara bekerja dengan atribut?  Dalam kebanyakan PL, operator referensi atribut adalah intinya (kecuali untuk PHP dan Perl).  Itu terlihat seperti ini (pseudo-code): <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//       class class Transformer(){ //   x int x //    (     0) function constructor(int x){ //   x // (  0    ) this.x = x } //   run function run(){ //      this this.x += 1 } } //    : //        0 optimus = new Transformer(0) optimus.run() //    print optimus.x //  1 optimus.run() //      print optimus.x //  2</span></span></code> </pre> <br>  Dalam gambar saya akan menggunakan notasi berikut: <br><br><img src="https://habrastorage.org/webt/wi/hf/qk/wihfqkqpsbaalsirv7f_a3qyig0.png"><br><br>  Saya tidak menggunakan diagram UML, menganggapnya tidak cukup visual, meskipun lebih fleksibel. <br><br><img src="https://habrastorage.org/webt/vi/uy/h2/viuyh29qu7ln_eq4eqyn5slkk0a.gif"><br>  <a href=""><i>Animasi nomor 1</i></a> <br><br>  Apa yang kita lihat dari kode? <br><br>  1. <b>ini</b> adalah variabel lokal khusus (metode dalam) yang memungkinkan objek mengakses atributnya sendiri dari metodenya.  Saya menarik perhatian Anda bahwa hanya untuk Anda sendiri, yaitu, ketika transformator memanggil metode sendiri, atau mengubah kondisinya sendiri.  Jika panggilan terlihat seperti <b>optimus.x</b> dari <b>luar</b> , kemudian dari dalam, jika Optimus ingin merujuk ke bidangnya x sendiri, dalam metodenya panggilan akan terlihat seperti <b>ini.x</b> , yaitu, " <i>Saya (Optimus) merujuk ke atribut saya x</i> ".  Di sebagian besar bahasa, variabel ini disebut ini, tetapi ada pengecualian (mis. Sendiri) <br><br>  2. <b>konstruktor</b> adalah metode khusus yang secara otomatis dipanggil ketika suatu objek dibuat.  Konstruktor dapat menerima argumen apa pun, seperti metode lainnya.  Dalam setiap bahasa, sebuah konstruktor ditandai dengan namanya.  Di suatu tempat ini adalah nama-nama yang khusus disediakan seperti __construct atau __init__, dan di suatu tempat nama konstruktor harus cocok dengan nama kelas.  Tujuan konstruktor adalah untuk menginisialisasi objek, mengisi bidang yang diperlukan. <br><br>  3. <b>new</b> adalah kata kunci yang harus digunakan untuk membuat instance kelas baru.  Pada titik ini, sebuah objek dibuat dan konstruktor dipanggil.  Dalam contoh kita, 0 dilewatkan ke konstruktor sebagai posisi awal transformator (ini adalah inisialisasi di atas).  Kata kunci baru hilang dalam beberapa bahasa, dan konstruktor dipanggil secara otomatis ketika mencoba memanggil kelas sebagai fungsi, misalnya: Transformer (). <br><br>  4. Konstruktor dan menjalankan <b>metode</b> <b>bekerja dengan keadaan internal, tetapi dalam semua hal lainnya tidak berbeda dari fungsi biasa</b> .  Bahkan sintaksis dari deklarasi cocok. <br><br>  5. Kelas mungkin memiliki metode yang tidak memerlukan status dan, sebagai akibatnya, membuat objek.  Dalam hal ini, metode ini dibuat <b>statis</b> . <br><br><h3>  Srp </h3><br>  (Prinsip Tanggung Jawab Tunggal / Prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SOLID</a> Pertama).  Anda mungkin sudah terbiasa dengan itu dari paradigma lain: "satu fungsi harus melakukan hanya satu tindakan yang selesai".  Prinsip ini juga berlaku untuk kelas: "Satu kelas harus bertanggung jawab atas satu tugas."  Sayangnya dengan kelas, lebih sulit untuk menentukan garis yang harus dilintasi sehingga prinsip dilanggar. <br><br>  Ada upaya untuk memformalkan prinsip ini dengan menggambarkan tujuan kelas dengan satu kalimat tanpa serikat, tetapi ini adalah teknik yang sangat kontroversial, jadi percayalah pada intuisi Anda dan jangan terburu-buru ke ekstrem.  Anda tidak perlu membuat pisau Swiss dari kelas, tetapi menghasilkan sejuta kelas dengan satu metode di dalamnya juga bodoh. <br><br><h2>  Asosiasi </h2><br>  Secara tradisional, di bidang objek tidak hanya variabel biasa dari tipe standar dapat disimpan, tetapi juga objek lain.  Dan benda-benda ini pada gilirannya dapat menyimpan beberapa benda lain dan seterusnya, membentuk pohon (kadang-kadang grafik) benda.  Hubungan ini disebut asosiasi. <br><br>  Misalkan trafo kita dilengkapi dengan pistol.  Meski tidak, lebih baik dengan dua senjata.  Di masing-masing tangan.  Senjatanya sama (mereka milik kelas yang sama, atau, jika Anda suka, dibuat menurut satu gambar), keduanya dapat menembak dan memuat ulang secara merata, tetapi masing-masing memiliki penyimpanan amunisi sendiri (negara bagian).  Bagaimana sekarang menggambarkannya dalam OOP?  Menurut asosiasi: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Gun</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//    int ammo_count //    function constructor(){ //  this.reload() //    "" } function fire(){ //    "" this.ammo_count -= 1 //      } function reload(){ //   "" this.ammo_count = 10 //     } } class Transformer(){ //    Gun gun_left //   " "   Gun gun_right //   " "    /*            ,    */ function constructor(Gun gun_left, Gun gun_right){ this.gun_left = gun_left //      this.gun_right = gun_right //      } //    "",   ... function fire(){ //  ,    "" this.gun_left.fire() //    ,     "" this.gun_right.fire() } } gun1 = new Gun() //    gun2 = new Gun() //    optimus = new Transformer(gun1, gun2) //  ,    </span></span></code> </pre><br><img src="https://habrastorage.org/webt/-t/cv/aa/-tcvaa8gtnipg_ridjunpf9b1tu.gif"><br>  <a href=""><i>Animasi nomor 2</i></a> <br><br>  this.gun_left.fire () dan this.gun_right.fire () adalah panggilan ke objek anak yang juga terjadi melalui titik-titik.  Pada titik pertama, kita beralih ke atribut diri kita sendiri (this.gun_right), mendapatkan objek gun, dan pada poin kedua, kita beralih ke metode objek gun (this.gun_right.fire ()). <br><br>  Intinya: robot itu dibuat, senjata dinas dikeluarkan, sekarang kita akan mencari tahu apa yang terjadi di sini.  Dalam kode ini, satu objek telah menjadi bagian integral dari objek lain.  Ini asosiasi.  Pada gilirannya, ada dua jenis: <br><br>  1. <b>Komposisi</b> - kasus ketika, di pabrik transformator, mengumpulkan Optimus, kedua senjata ditempelkan erat ke tangannya dengan paku, dan setelah kematian Optimus, senjata mati bersamanya.  Dengan kata lain, siklus hidup anak sama dengan siklus hidup orang tua. <br><br>  2. <b>Agregasi</b> - kasus ketika senjata dikeluarkan sebagai senjata di tangannya, dan setelah kematian Optimus, senjata ini dapat diambil oleh rekannya Oleg, dan kemudian dibawa ke tangannya sendiri, atau diserahkan ke pegadaian.  Artinya, siklus hidup objek anak tidak tergantung pada siklus hidup orang tua, dan dapat digunakan oleh objek lain. <br><br>  Gereja OOP ortodoks memberitakan kepada kita trinitas mendasar - <b>enkapsulasi, polimorfisme, dan warisan</b> , yang menjadi dasar seluruh pendekatan berorientasi objek.  Mari kita mengurutkannya. <br><br><img src="https://habrastorage.org/webt/9s/gq/ch/9sgqchcuzrso9iesrjn7vkw9opw.png"><br><br><h2>  Warisan </h2><br>  Warisan adalah suatu mekanisme sistem yang memungkinkan, betapapun paradoksnya mungkin terdengar, mewarisi sifat-sifat dan perilaku kelas-kelas lain oleh beberapa kelas untuk perluasan atau modifikasi lebih lanjut. <br><br>  Bagaimana jika, kami tidak ingin memberi cap pada transformator yang sama, tetapi ingin membuat kerangka yang sama, tetapi dengan body kit yang berbeda?  OOP memungkinkan kita melakukan lelucon seperti itu dengan membagi logika menjadi persamaan dan perbedaan, diikuti dengan penghapusan persamaan di kelas induk, dan perbedaan dalam kelas turunan.  Seperti apa bentuknya? <br><br>  Optimus Prime dan Megatron keduanya adalah transformator, tetapi yang satu adalah Autobot dan yang lainnya adalah Decepticon.  Misalkan perbedaan antara Autobots dan Decepticons hanya akan terdiri dari kenyataan bahwa Autobots ditransformasikan menjadi mobil, dan Decepticons - menjadi penerbangan.  Semua properti dan perilaku lainnya tidak akan membuat perbedaan.  Dalam hal ini, sistem pewarisan dapat dirancang sebagai berikut: fitur-fitur umum (berlari, menembak) akan dijelaskan dalam kelas dasar Transformer, dan perbedaan (transformasi) di dua kelas tambahan Autobot dan Decepticon. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Transformer</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//   function run(){ // ,    } function fire(){ // ,    } } class Autobot(Transformer){ //  ,   Transformer function transform(){ // ,      } } class Decepticon(Transformer){ //  ,   Transformer function transform(){ // ,      } } optimus = new Autobot() megatron = new Decepticon()</span></span></code> </pre><br><img src="https://habrastorage.org/webt/qj/jo/mg/qjjomgocinjckd5kxjmubl1gzqc.gif"><br>  <a href=""><i>Animasi nomor 3</i></a> <br><br>  Contoh ini menggambarkan bagaimana pewarisan menjadi salah satu cara untuk mendeduplikasi kode ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip KERING</a> ) menggunakan kelas induk, dan pada saat yang sama memberikan peluang untuk mutasi di kelas turunan. <br><br><h3>  Kelebihan </h3><br>  Jika Anda mengganti metode yang ada di kelas induk di kelas induk, overload akan berfungsi.  Ini memungkinkan kami untuk tidak menambah perilaku kelas induk, tetapi untuk memodifikasinya.  Pada saat memanggil metode atau mengakses bidang objek, pencarian atribut terjadi dari turunan ke akar - induknya.  Yaitu, jika metode api () dipanggil pada autobot, metode pertama kali dicari di kelas turunan - Autobot, dan karena tidak ada, pencarian naik satu langkah lebih tinggi - ke kelas Transformer, di mana ia akan dideteksi dan dipanggil. <br><br><h3>  Penggunaan yang tidak pantas </h3><br>  Sangat mengherankan bahwa hierarki warisan yang sangat dalam dapat menyebabkan efek sebaliknya - komplikasi ketika mencoba untuk mencari tahu siapa yang diwarisi dari siapa, dan metode apa yang disebut dalam hal ini.  Selain itu, tidak semua persyaratan arsitektur dapat diimplementasikan menggunakan pewarisan.  Karena itu, pewarisan harus diterapkan tanpa fanatisme.  Ada rekomendasi yang menyerukan komposisi yang lebih disukai daripada warisan, jika sesuai.  Setiap kritik terhadap warisan yang saya temui diperkuat oleh contoh-contoh yang tidak berhasil ketika warisan digunakan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">palu emas</a> .  Tetapi ini tidak berarti bahwa warisan pada prinsipnya selalu berbahaya.  Narcologist saya mengatakan bahwa langkah pertama adalah mengakui bahwa Anda bergantung pada warisan. <br><br>  Ketika menggambarkan hubungan dua entitas, bagaimana mungkin menentukan kapan pewarisan sesuai dan kapan komposisinya tepat?  Anda dapat menggunakan lembar contekan yang populer: tanyakan pada diri Anda, <b>entitas A adalah entitas B</b> ?  Jika demikian, maka kemungkinan besar warisan adalah tepat.  Jika <b>entitas A adalah bagian dari entitas B</b> , maka pilihan kita adalah komposisi. <br><br>  Sehubungan dengan situasi kita, akan terdengar seperti ini: <br><br><ol><li>  Apakah Autobot Transformer?  Ya, maka kami memilih warisan. </li><li>  Apakah pistol bagian dari Transformer?  Ya, itu artinya komposisi. </li></ol><br>  Untuk swa-uji, coba kombinasi terbalik, Anda mendapat sampah.  Lembar cheat ini membantu dalam banyak kasus, tetapi ada faktor-faktor lain yang harus Anda andalkan ketika memilih antara komposisi dan warisan.  Selain itu, metode ini dapat dikombinasikan untuk menyelesaikan berbagai jenis masalah. <br><br><h3>  Warisan bersifat Statis </h3><br>  Perbedaan penting lainnya antara pewarisan dan komposisi adalah bahwa pewarisan sifatnya statis dan membangun hubungan kelas hanya pada tahap interpretasi / kompilasi.  Komposisi, seperti yang kita lihat dalam contoh, memungkinkan Anda untuk mengubah hubungan entitas dengan cepat saat runtime - kadang-kadang ini sangat penting, jadi Anda perlu mengingat ini saat memilih hubungan (kecuali tentu saja ada keinginan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metaprogramming</a> ). <br><br><h3>  Warisan berganda </h3><br>  Kami memeriksa situasi di mana dua kelas diwarisi dari keturunan bersama.  Tetapi dalam beberapa bahasa Anda dapat melakukan yang sebaliknya - mewarisi satu kelas dari dua orang tua atau lebih, menggabungkan sifat dan perilaku mereka.  Kemampuan untuk mewarisi dari beberapa kelas bukan satu adalah warisan ganda. <br><br><img src="https://habrastorage.org/webt/aq/xd/5e/aqxd5e1n1bauunzhp0necdbsws4.png"><br><br>  Secara umum, di kalangan Illuminati ada pendapat bahwa pewarisan berganda adalah dosa, ia membawa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah berbentuk berlian</a> dan kebingungan dengan para desainer.  Selain itu, tugas yang dapat diselesaikan dengan pewarisan berganda dapat diselesaikan dengan mekanisme lain, misalnya mekanisme antarmuka (yang juga akan kita bicarakan).  Tetapi dalam keadilan, harus dicatat bahwa pewarisan berganda nyaman digunakan untuk penerapan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengotor</a> . <br><br><h3>  Kelas abstrak </h3><br>  Selain kelas biasa, bahasa abstrak ada di beberapa bahasa.  Mereka berbeda dari kelas biasa karena Anda tidak dapat membuat objek dari kelas semacam itu.  Mengapa kita membutuhkan kelas seperti itu, pembaca akan bertanya?  Diperlukan agar keturunan dapat diwarisi darinya - kelas biasa yang objeknya sudah dapat dibuat. <br><br>  Kelas abstrak, bersama dengan metode biasa, berisi metode abstrak tanpa implementasi (dengan tanda tangan, tetapi tanpa kode), yang harus diimplementasikan oleh programmer yang berencana membuat kelas turunan.  Kelas abstrak tidak diperlukan, tetapi mereka membantu untuk membuat kontrak yang membutuhkan implementasi dari serangkaian metode tertentu untuk melindungi seorang programmer dengan memori yang buruk dari kesalahan implementasi. <br><br><h2>  Polimorfisme </h2><br>  Polimorfisme adalah properti sistem yang memungkinkan Anda memiliki banyak implementasi satu antarmuka.  Tidak ada yang jelas.  Mari kita beralih ke transformer. <br><br>  Misalkan kita memiliki tiga transformer: Optimus, Megatron, dan Oleg.  Transformer adalah pertempuran, sehingga mereka memiliki metode serangan ().  Pemain, dengan menekan tombol “fight” pada joystick-nya, memberi tahu game untuk memanggil metode attack () pada transformator yang dimainkan pemain.  Tetapi karena transformernya berbeda, dan permainannya menarik, masing-masing dari mereka akan menyerang dengan cara tertentu.  Katakanlah Optimus adalah objek dari kelas Autobot, dan Autobots dilengkapi dengan meriam dengan hulu ledak plutonium (ya, penggemar transformer tidak marah).  Megatron adalah Decepticon, dan menembak dari senjata plasma.  Oleg adalah pemain bass, dan dia memanggilnya nama.  Dan apa gunanya? <br><br>  Penggunaan polimorfisme dalam contoh ini adalah bahwa kode permainan tidak tahu apa-apa tentang implementasi permintaannya, siapa yang harus menyerang caranya, tugasnya hanya memanggil metode serangan (), yang tanda tangannya sama untuk semua kelas karakter.  Ini memungkinkan Anda untuk menambahkan kelas karakter baru, atau mengubah metode yang ada tanpa mengubah kode game.  Ini nyaman. <br><br><h2>  Enkapsulasi </h2><br>  Enkapsulasi adalah kontrol akses ke bidang dan metode suatu objek.  Kontrol akses menyiratkan tidak hanya mungkin / tidak penting, tetapi juga berbagai validasi, memuat, perhitungan, dan perilaku dinamis lainnya. <br><br>  Dalam banyak bahasa, enkripsi data adalah bagian dari enkapsulasi.  Untuk ini, ada pengubah akses (kami gambarkan mereka yang ada di hampir semua bahasa OOP): <br><br><ul><li>  publi - siapa pun dapat mengakses atribut </li><li>  metode pribadi - hanya dari kelas ini dapat mengakses atribut </li><li>  dilindungi - sama seperti pribadi, hanya ahli waris kelas yang mendapatkan akses, termasuk </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Transformer</span></span>(){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ } }</code> </pre><br>  Bagaimana memilih pengubah akses?  Dalam kasus paling sederhana seperti ini: jika metode ini harus dapat diakses oleh kode eksternal, pilih publik.  Kalau tidak, pribadi.  Jika ada warisan, maka dilindungi mungkin diperlukan jika metode ini tidak boleh disebut eksternal, tetapi harus dipanggil oleh keturunan. <br><br><h2>  Accessor (getter dan setter) </h2><br>  Getters dan setters adalah metode yang tugasnya mengontrol akses ke bidang.  Sang pengambil rajin membaca dan mengembalikan nilai field, dan setter, sebaliknya, mengambil nilai sebagai argumen dan menuliskannya ke field.  Ini memungkinkan untuk memberikan metode semacam itu dengan perawatan tambahan.  Misalnya, seorang penyetel, saat menulis nilai ke bidang objek, dapat memeriksa jenisnya atau apakah nilainya dalam kisaran nilai yang valid (validasi).  Di rajin rajin, Anda dapat menambahkan inisialisasi malas atau caching jika nilai aktual sebenarnya terletak di database.  Ada banyak aplikasi. <br><br>  Beberapa bahasa memiliki gula sintaksis yang memungkinkan pengakses seperti itu untuk disamarkan sebagai properti, yang membuat akses transparan ke kode eksternal, yang tidak menduga bahwa itu tidak bekerja dengan bidang, tetapi dengan metode yang mengeksekusi query SQL atau membaca dari file di bawah tenda.  Beginilah cara abstraksi dan transparansi dicapai. <br><br><h2>  Antarmuka </h2><br>  Tugas antarmuka adalah untuk mengurangi tingkat ketergantungan entitas satu sama lain, menambahkan lebih banyak abstraksi. <br><br>  Tidak semua bahasa memiliki mekanisme ini, tetapi dalam bahasa OOP dengan mengetik statis tanpa mereka akan sangat buruk.  Di atas, kami mempertimbangkan kelas abstrak, menyentuh pada topik kontrak yang berkewajiban mengimplementasikan beberapa metode abstrak.  Jadi antarmuka terlihat sangat mirip kelas abstrak, tetapi ini bukan kelas, tetapi hanya tiruan dengan enumerasi metode abstrak (tanpa implementasi).  Dengan kata lain, antarmuka bersifat deklaratif, yaitu, kontrak bersih tanpa sedikit kode. <br><br>  Biasanya, bahasa yang memiliki antarmuka tidak memiliki banyak kelas pewarisan, tetapi ada banyak antarmuka yang berbeda.  Ini memungkinkan kelas untuk membuat daftar antarmuka yang harus diimplementasikan. <br><br>  Kelas dengan antarmuka terdiri dari hubungan banyak ke banyak: satu kelas dapat mengimplementasikan beberapa antarmuka, dan setiap antarmuka, pada gilirannya, dapat diimplementasikan oleh banyak kelas. <br><br>  Antarmuka memiliki penggunaan dua sisi: <br><br><ol><li>  Di satu sisi antarmuka adalah kelas yang mengimplementasikan antarmuka ini. </li><li>  Di sisi lain adalah konsumen yang menggunakan antarmuka ini sebagai deskripsi dari jenis data yang mereka bekerja (konsumen). </li></ol><br>  Misalnya, jika objek selain dari perilaku dasar dapat diserialisasi, maka biarkan ia mengimplementasikan antarmuka Serializable.  Dan jika objek dapat dikloning, maka biarkan mengimplementasikan antarmuka lain - "Kloning".  Dan jika kita memiliki semacam modul transport yang mentransmisikan objek melalui jaringan, itu akan menerima objek yang mengimplementasikan antarmuka Serializable. <br><br>  Bayangkan bahwa kerangka transformator dilengkapi dengan tiga slot: slot untuk senjata, untuk generator energi dan untuk beberapa jenis pemindai.  Slot ini memiliki antarmuka tertentu: hanya peralatan yang sesuai yang dapat dipasang di setiap slot.  Di slot untuk senjata, Anda dapat memasang peluncur roket atau senjata laser, di slot untuk generator listrik - reaktor nuklir atau RTG (generator termoelektrik radioisotop), dan di slot untuk pemindai - radar atau lidar.  Intinya adalah bahwa setiap slot memiliki antarmuka koneksi universal, dan perangkat tertentu harus sesuai dengan antarmuka ini.  Sebagai contoh, beberapa jenis slot digunakan pada motherboard: slot prosesor memungkinkan Anda untuk menghubungkan berbagai prosesor yang cocok untuk soket ini, dan slot SATA memungkinkan Anda untuk menghubungkan drive SSD atau HDD atau bahkan CD / DVD. <br><br>  Saya menarik perhatian Anda pada fakta bahwa sistem slot yang dihasilkan untuk transformer adalah contoh penggunaan komposisi.  Jika peralatan dalam slot akan diganti selama umur transformator, maka ini sudah merupakan agregasi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk kejelasan, kami akan memanggil antarmuka, seperti biasa dalam beberapa bahasa, menambahkan huruf kapital "Dan" sebelum nama: IWeapon, IEnergyGenerator, IScanner. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  : interface IWeapon{ function fire() {} //    .   } interface IEnergyGenerator{ //    ,     : function generate_energy() {} //  function load_fuel() {} //  } interface IScanner{ function scan() {} } // ,  : class RocketLauncher() : IWeapon { function fire(){ //    } } class LaserGun() : IWeapon { function fire(){ //    } } class NuclearReactor() : IEnergyGenerator { function generate_energy(){ //      } function load_fuel(){ //     } } class RITEG() : IEnergyGenerator { function generate_energy(){ //     } function load_fuel(){ //   - } } class Radar() : IScanner { function scan(){ //    } } class Lidar() : IScanner { function scan(){ //     } } //  - : class Transformer() { // , : IWeapon slot_weapon //      . IEnergyGenerator slot_energy_generator //     , IScanner slot_scanner //     /*         ,      ,   : */ function install_weapon(IWeapon weapon){ this.slot_weapon = weapon } function install_energy_generator(IEnergyGenerator energy_generator){ this.slot_energy_generator = energy_generator } function install_scanner(IScanner scanner){ this.slot_scanner = scanner } } //   class TransformerFactory(){ function build_some_transformer() { transformer = new Transformer() laser_gun = new LaserGun() nuclear_reactor = new NuclearReactor() radar = new Radar() transformer.install_weapon(laser_gun) transformer.install_energy_generator(nuclear_reactor) transformer.install_scanner(radar) return transformer } } //  transformer_factory = new TransformerFactory() oleg = transformer_factory.build_some_transformer()</span></span></code> </pre><br><img src="https://habrastorage.org/webt/0a/q0/lw/0aq0lwydujaw7eofdnbgi5e52ka.gif"><br> <a href=""><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animasi No. 4</font></font></i></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sayangnya, pabrik tidak sesuai dengan gambar, tetapi masih opsional, transformator juga dapat dirakit di halaman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lapisan abstraksi yang ditunjukkan dalam gambar dalam bentuk antarmuka antara lapisan implementasi dan lapisan konsumen memungkinkan untuk abstrak satu dari yang lain. </font><font style="vertical-align: inherit;">Anda dapat mengamati ini dengan melihat setiap lapisan secara terpisah: di lapisan implementasi (di sebelah kiri) tidak ada sepatah kata pun tentang kelas Transformer, dan di lapisan konsumen (di sebelah kanan) tidak ada sepatah kata pun tentang implementasi spesifik (tidak ada kata Radar, RocketLauncher, NuclearReactor, dll. d.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kode ini, kita dapat membuat komponen baru untuk transformer tanpa memengaruhi gambar transformator itu sendiri. </font><font style="vertical-align: inherit;">Pada saat yang sama dan sebaliknya, kita dapat membuat transformator baru dengan menggabungkan komponen yang ada, atau menambahkan komponen baru tanpa mengubah yang sudah ada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengetik bebek </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenomena yang kita amati dalam arsitektur yang dihasilkan disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bebek mengetik</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika sesuatu dukun seperti bebek, berenang seperti bebek, dan terlihat seperti bebek, maka kemungkinan besar itu adalah bebek</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menerjemahkan ini ke dalam bahasa transformer, akan terdengar seperti ini: jika sesuatu menembak seperti meriam, dan memuat kembali seperti meriam, kemungkinan besar itu adalah meriam. </font><font style="vertical-align: inherit;">Jika perangkat menghasilkan energi, kemungkinan besar pembangkit listrik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbeda dengan tipifikasi pewarisan secara hierarkis, dengan pengetikan bebek, transformator tidak peduli kelas apa yang diberikan senjata kepadanya, dan apakah itu senjata sama sekali. </font><font style="vertical-align: inherit;">Yang utama adalah benda ini bisa menembak! </font><font style="vertical-align: inherit;">Ini bukan keutamaan mengetik bebek, melainkan kompromi. </font><font style="vertical-align: inherit;">Mungkin ada situasi sebaliknya, seperti pada gambar di bawah ini:</font></font><br><br><img src="https://habrastorage.org/webt/5_/lx/fd/5_lxfdoifgzwg4oy1rurh3bmc-m.png"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ISP </font></font></h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Prinsip Segregasi Antarmuka / Prinsip SOLID Keempat) mendorong untuk tidak membuat antarmuka universal yang berani. </font><font style="vertical-align: inherit;">Sebaliknya, antarmuka harus dibagi menjadi yang lebih kecil dan khusus, ini akan membantu untuk menggabungkan mereka lebih fleksibel dalam mengimplementasikan kelas, tanpa memaksa untuk menerapkan metode yang tidak perlu.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abstraksi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam OOP, semuanya berputar di sekitar abstraksi. </font><font style="vertical-align: inherit;">Ada fanatik yang mengklaim bahwa abstraksi harus menjadi bagian dari trinitas OOP (enkapsulasi, polimorfisme, pewarisan). </font><font style="vertical-align: inherit;">Dan inspektur saya untuk pengujian pembebasan bersyarat mengatakan sebaliknya: abstraksi melekat dalam pemrograman apa pun, dan bukan hanya OOP, jadi harus terpisah. </font><font style="vertical-align: inherit;">Di sisi lain, hal yang sama dapat dikatakan tentang prinsip-prinsip lainnya, tetapi Anda tidak akan menghapus kata-kata dari sebuah lagu. </font><font style="vertical-align: inherit;">Dengan satu atau lain cara, abstraksi diperlukan, dan terutama dalam OOP.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tingkat abstraksi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini orang tidak dapat gagal mengutip satu lelucon terkenal: </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- masalah arsitektur apa pun dapat diselesaikan dengan menambahkan lapisan abstraksi tambahan, kecuali untuk masalah sejumlah besar abstraksi.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam contoh kami dengan antarmuka, kami menerapkan lapisan abstraksi antara transformer dan komponen, membuat arsitektur lebih fleksibel. Tetapi berapa biayanya? Kami harus memperumit arsitekturnya. Psikoterapis saya mengatakan bahwa kemampuan untuk menyeimbangkan antara kesederhanaan arsitektur dan fleksibilitas aplikasi adalah seni. Memilih jalan tengah, seseorang harus mengandalkan tidak hanya pada pengalaman dan intuisi sendiri, tetapi juga pada konteks proyek saat ini. Karena orang tersebut belum belajar untuk melihat masa depan, maka perlu secara analitik memperkirakan tingkat abstraksi apa dan dengan tingkat probabilitas apa yang dapat berguna dalam proyek ini, berapa banyak waktu yang diperlukan untuk mengembangkan arsitektur yang fleksibel, dan apakah waktu yang dihabiskan akan terbayar di masa depan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan tingkat abstraksi yang salah mengarah ke salah satu dari dua masalah:</font></font><br><br><ol><li>   ,        ,        ,     (         ) </li><li>     ,         ,   ,   ,       .                 (        ) </li></ol><br><img src="https://habrastorage.org/webt/2t/on/h4/2tonh4egj4xfp4gcovpyb2xa6dq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting juga dipahami bahwa tingkat abstraksi ditentukan bukan untuk keseluruhan proyek secara keseluruhan, tetapi secara terpisah untuk komponen yang berbeda. Di beberapa tempat, sistem abstraksi mungkin tidak cukup, tetapi di suatu tempat sebaliknya - gagal. Namun, pilihan tingkat abstraksi yang salah dapat dikoreksi dengan refactoring yang tepat waktu. Kata kunci </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tepat waktu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Penundaan refactoring bermasalah ketika banyak mekanisme sudah dilaksanakan pada tingkat abstraksi ini. Melakukan ritual refactoring dalam menjalankan sistem dapat melibatkan rasa sakit akut di tempat-tempat yang sulit dijangkau seorang programmer. Ini tentang bagaimana mengubah fondasi di rumah - lebih murah untuk membangun rumah di sebelah dari awal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat definisi tingkat abstraksi dari opsi yang memungkinkan pada contoh permainan hipotetis "transformers-online." Dalam hal ini, level abstraksi akan bertindak sebagai lapisan, setiap lapisan berikutnya yang dipertimbangkan akan berada di atas yang sebelumnya, mengambil bagian dari fungsional dari padanya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lapisan pertama.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permainan memiliki satu kelas transformator, semua properti dan perilaku dijelaskan di dalamnya. Ini adalah tingkat abstraksi yang sepenuhnya kayu, cocok untuk permainan kasual, yang tidak menyiratkan fleksibilitas khusus. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkat kedua.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gim ini memiliki trafo dasar dengan kemampuan dasar dan kelas trafo dengan spesialisasi mereka sendiri (seperti scout, pesawat serang, dukungan), yang dijelaskan dengan metode tambahan. Dengan demikian, pemain diberi kesempatan untuk memilih, dan pengembangan kelas baru disederhanakan untuk pengembang. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkat ketiga</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain klasifikasi transformator, agregasi diperkenalkan menggunakan sistem slot dan komponen (seperti dalam contoh kami dengan reaktor, senjata dan radar). Sekarang bagian dari perilaku akan ditentukan oleh staf yang dipasang oleh pemain di transformernya. Ini memberi pemain lebih banyak pilihan untuk menyesuaikan mekanika permainan karakter, dan memberi pengembang kesempatan untuk menambahkan modul ekspansi yang sama ini, yang pada gilirannya menyederhanakan pekerjaan desainer game untuk merilis konten baru.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkat keempat.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda juga dapat memasukkan agregasi Anda sendiri dalam komponen, yang memungkinkan Anda memilih bahan dan bagian dari mana komponen ini dirakit. Pendekatan ini akan memberikan pemain kesempatan tidak hanya untuk mengisi transformator dengan komponen yang diperlukan, tetapi juga untuk secara mandiri menghasilkan komponen-komponen ini dari berbagai bagian. Terus terang, saya belum pernah bertemu tingkat abstraksi sedemikian dalam permainan, dan bukan tanpa alasan! Lagi pula, ini disertai dengan komplikasi arsitektur yang signifikan, dan penyesuaian keseimbangan dalam permainan seperti itu berubah menjadi neraka. Tapi saya tidak mengesampingkan bahwa permainan seperti itu ada.</font></font><br><br><img src="https://habrastorage.org/webt/2y/7d/vs/2y7dvslc6nx6_yki11hngnuzu5k.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, setiap lapisan yang dijelaskan, pada prinsipnya, memiliki hak untuk hidup. </font><font style="vertical-align: inherit;">Itu semua tergantung pada kelenturan seperti apa yang kita inginkan dalam proyek. </font><font style="vertical-align: inherit;">Jika kerangka acuan tidak mengatakan apa-apa tentang hal ini, atau penulis proyek sendiri tidak tahu apa yang dibutuhkan oleh bisnis, Anda dapat melihat proyek serupa di area ini dan fokus pada mereka.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pola desain </font></font></h2><br><img src="https://habrastorage.org/webt/gl/gq/3d/glgq3d_bze334go7ml8ffxmvvvc.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dekade pembangunan telah mengarah pada pembentukan daftar solusi arsitektur yang paling umum digunakan, yang dari waktu ke waktu telah diklasifikasikan oleh masyarakat, dan disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pola desain</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Itulah sebabnya ketika saya pertama kali membaca tentang pola, saya terkejut menemukan bahwa ternyata saya sudah menggunakan banyak dari mereka dalam praktik, saya hanya tidak tahu bahwa solusi ini memiliki nama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola desain, seperti abstraksi, adalah karakteristik tidak hanya dari pengembangan OOP, tetapi juga dari paradigma lain. Secara umum, topik pola berada di luar cakupan artikel ini, tetapi saya ingin memperingatkan pengembang muda yang hanya ingin berkenalan dengan pola. Ini jebakan! Sekarang saya akan menjelaskan alasannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tujuan dari pola adalah untuk membantu menyelesaikan masalah arsitektur yang sudah ditemukan, atau kemungkinan besar akan ditemukan selama pengembangan proyek. Jadi, setelah membaca tentang pola, seorang pemula mungkin memiliki godaan yang tak tertahankan untuk menggunakan pola bukan untuk memecahkan masalah, tetapi untuk menghasilkan mereka. Dan karena pengembang tidak terkendali dalam keinginannya, ia mungkin tidak mulai menyelesaikan masalah dengan bantuan pola, tetapi dapat menyesuaikan tugas apa pun dengan solusi dengan bantuan pola. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai lain dari pola adalah formalisasi terminologi. Jauh lebih mudah bagi seorang kolega untuk mengatakan bahwa "rantai tugas" digunakan di tempat ini daripada menggambar perilaku dan hubungan objek pada selembar kertas selama setengah jam.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kondisi modern, keberadaan kelas kata dalam kode Anda tidak menjadikan Anda seorang programmer OOP. Karena jika Anda tidak menggunakan mekanisme yang dijelaskan dalam artikel (polimorfisme, komposisi, pewarisan, dll.), Dan alih-alih menggunakan kelas hanya untuk mengelompokkan fungsi dan data, maka ini bukan OOP. Hal yang sama dapat dipecahkan oleh beberapa ruang nama dan struktur data. Jangan bingung, kalau tidak Anda akan malu saat wawancara. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin menyelesaikan lagu saya dengan kata-kata penting. Setiap mekanisme, prinsip, dan pola yang diuraikan, serta OOP secara keseluruhan, tidak boleh diterapkan di tempat yang tidak ada gunanya atau bisa berbahaya. Ini mengarah ke artikel dengan tajuk berita aneh seperti "Warisan adalah penyebab penuaan dini" atau "Singleton dapat menyebabkan kanker."</font></font><br><br>  Saya serius.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita mempertimbangkan kasus singleton, maka penggunaannya yang luas tanpa sepengetahuan kasus tersebut, telah menyebabkan masalah arsitektur yang serius di banyak proyek. </font><font style="vertical-align: inherit;">Dan para pecinta palu palu dengan mikroskop berbaik hati memanggilnya antipattern. </font><font style="vertical-align: inherit;">Berhati-hatilah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, dalam mendesain tidak ada resep yang jelas untuk semua kesempatan, di mana yang sesuai dan di mana yang tidak pantas. </font><font style="vertical-align: inherit;">Ini secara bertahap akan cocok dengan kepala Anda dengan pengalaman.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463125/">https://habr.com/ru/post/id463125/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463113/index.html">Kontrol Data dan Model Versi dalam pertemuan Visi Komputer</a></li>
<li><a href="../id463115/index.html">Masalah pintu dalam desain penembak</a></li>
<li><a href="../id463117/index.html">Preloading dalam PHP 7.4</a></li>
<li><a href="../id463121/index.html">Kami makan gajah di beberapa bagian. Contoh Aplikasi Strategi Pemantauan Kesehatan</a></li>
<li><a href="../id463123/index.html">Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 3</a></li>
<li><a href="../id463127/index.html">Pemantauan UPS. Bagian Dua - Analisis Otomatis</a></li>
<li><a href="../id463135/index.html">Di negara mana yang menguntungkan untuk mendaftarkan perusahaan IT pada 2019?</a></li>
<li><a href="../id463137/index.html">Bahkan jika Anda ingin menjadi perancang permainan, tidak ada yang akan mengajari Anda caranya</a></li>
<li><a href="../id463141/index.html">Habr Weekly # 13 / Di bawah ancaman 1,5 juta pengguna layanan kencan, investigasi Medusa, deanon Rusia</a></li>
<li><a href="../id463143/index.html">Memulai dengan Google Analytics: App + Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>