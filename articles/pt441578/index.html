<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏲️ 👨🏻‍🎨 ✍🏿 Tutorial Reagir Parte 19: Métodos do Ciclo de Vida dos Componentes 🍗 🤘🏻 👴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na parte atual da tradução do tutorial do React, você verá uma visão geral dos métodos do ciclo de vida dos componentes. 

  

 → Parte 1: visão geral...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tutorial Reagir Parte 19: Métodos do Ciclo de Vida dos Componentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441578/">  Na parte atual da tradução do tutorial do React, você verá uma visão geral dos métodos do ciclo de vida dos componentes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/kv/3m/yg/kv3mygzwigixivdzbagb80fvlvi.png" alt="imagem"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: visão geral do curso, razões para a popularidade do React, ReactDOM e JSX</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: componentes funcionais</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: arquivos de componentes, estrutura do projeto</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4: componentes pai e filho</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5: início do trabalho em um aplicativo TODO, noções básicas de estilo</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 6: sobre alguns recursos do curso, JSX e JavaScript</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 7: estilos embutidos</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 8: trabalho contínuo na aplicação TODO, familiaridade com as propriedades dos componentes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 9: propriedades do componente</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 10: Workshop sobre como trabalhar com propriedades e estilo de componentes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 11: geração dinâmica de marcação e método de matrizes de mapas</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 12: workshop, terceira etapa do trabalho em uma aplicação TODO</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 13: componentes baseados em classe</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 14: workshop sobre componentes baseados em classe, status dos componentes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 15: oficinas de saúde componentes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 16: a quarta etapa do trabalho em um aplicativo TODO, manipulação de eventos</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 17: quinta etapa do trabalho em um aplicativo TODO, modificando o estado dos componentes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 18: a sexta etapa do trabalho em um aplicativo TODO</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 19: métodos do ciclo de vida dos componentes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 20: a primeira lição sobre renderização condicional</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 21: segunda lição e workshop sobre renderização condicional</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 22: sétima etapa do trabalho em um aplicativo TODO, baixando dados de fontes externas</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 23: primeira lição sobre como trabalhar com formulários</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 24: Segunda lição sobre formulários</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 25: Workshop sobre como trabalhar com formulários</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 26: arquitetura do aplicativo, padrão Container / Component</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 27: projeto do curso</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Lição 34. Métodos do Ciclo de Vida dos Componentes, Parte 1</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Original</a> <br><br>  Um dos recursos do desenvolvimento de aplicativos React é o fato de escrevermos um código JavaScript bastante simples que aciona os mecanismos internos do React e, assim, nos oferece grandes oportunidades para desenvolver interfaces de aplicativos e trabalhar com dados.  Ao mesmo tempo, os componentes que usamos durante seu ciclo de vida passam por certos estágios.  Freqüentemente, o que acontece com um componente em um aplicativo é comparado à vida de uma pessoa.  As pessoas nascem, vivem, em sua vida acontecem alguns eventos significativos, após o que morrem.  Os componentes do React nisso são semelhantes às pessoas, pois também "nascem", "vivem" e "morrem".  Trabalhando com componentes, podemos reagir ao que acontece com eles, graças aos métodos de seu ciclo de vida que são chamados em momentos especiais de sua “vida”. <br><br>  Recentemente, a equipe de desenvolvimento do React desatualizou três métodos de ciclo de vida de componentes.  No entanto, consideraremos esses métodos, pois eles ainda podem ser usados ​​e como podem ser encontrados no código existente.  Além disso, dois novos métodos de ciclo de vida dos componentes foram adicionados ao React, que discutiremos na próxima lição. <br><br>  Consideraremos apenas os métodos mais importantes que são mais relevantes para aqueles que começaram a estudar o React.  Ao continuar a dominar esta biblioteca, você poderá experimentar outros métodos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está</a> um bom material sobre os métodos de ciclo de vida dos componentes do React que eram relevantes antes do React 16.3.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> , em uma publicação do blog oficial do desenvolvedor do React, você pode descobrir as mudanças que ocorreram no React 16.3. <br><br>  Agora, vamos começar a discussão sobre os métodos de ciclo de vida dos componentes do React que você encontrará com mais frequência. <br><br>  Como sempre, usaremos o projeto de demonstração aqui.  Nesse caso, começamos com um projeto padrão criado usando create- <code>App.js</code> -app, no arquivo <code>App.js</code> que contém o seguinte código: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     render() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (           <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">               Code goes here           </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>       )   } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App</code> </pre> <br>  Para começar, vamos dar uma olhada no método que você já usou com componentes baseados em classe.  Este é o método <code>render()</code> . <br><br>  Freqüentemente, ele não é mencionado ao falar sobre os métodos do ciclo de vida dos componentes.  Eu acho que esse método, ao comparar um componente com uma pessoa, pode ser comparado ao vestir antes de sair.  O objetivo deste método é determinar o que será exibido na tela, ou seja, como o componente será exibido.  O método <code>render()</code> pode ser chamado várias vezes durante a vida de um componente.  Portanto, quando o React determina que algo relacionado a um componente mudou, como um estado ou propriedades, ou seja, algo que pode afetar a aparência de um componente, o React pode chamar esse método.  Isso pode ser comparado, se continuarmos a analogia com as pessoas, para que uma pessoa possa decidir trocar de roupa.  Por exemplo, para, depois de um dia útil, se preparar para algum tipo de evento de feriado. <br><br>  Agora, vejamos outro método de ciclo de vida do <code>componentDidMount()</code> - <code>componentDidMount()</code> .  Este método é declarado, assim como qualquer outro método de componente baseado em classe, no corpo de uma classe de componente: <br><br><pre> <code class="javascript hljs">componentDidMount() { }</code> </pre> <br>  Esse método é chamado no momento do ciclo de vida do componente, que pode ser comparado com o "nascimento" desse componente.  Este método é acionado uma vez depois que o componente é montado (inserido) na árvore DOM.  Ao mesmo tempo, por exemplo, se após alterar alguns dados que afetam a aparência do componente, eles serão renderizados novamente, o método <code>componentDidMount()</code> não será chamado.  Isso ocorre devido ao fato de que, ao executar essas operações, o componente não é removido da árvore DOM e, em seguida, incluído novamente na árvore. <br><br>  O método <code>componentDidMount()</code> geralmente é usado para fazer chamadas para determinadas APIs nos casos em que o desenvolvedor precisa de dados de fontes externas.  Suponha que o componente que estamos considerando aqui seja realmente chamado <code>TodoList</code> e seja um componente que forma uma lista de tarefas em um aplicativo Todo.  O método <code>componentDidMount()</code> desse componente pode carregar materiais do banco de dados do servidor, necessários para a exibição correta da lista de tarefas pendentes armazenada no servidor.  Como resultado, após a conclusão da instalação do componente, nós, no método <code>componentDidMount()</code> , podemos carregar os dados necessários para que o componente seja exibido corretamente na página.  Também falaremos sobre o carregamento de dados necessários aos componentes, mas, por enquanto, você se lembra de que este é o caso de uso mais comum para <code>componentDidMount()</code> . <br><br>  O próximo método de ciclo de vida do componente que discutimos é chamado <code>componentWillReceiveProps()</code> .  Este método pode ser comparado ao que acontece quando alguém recebe um presente de alguém.  Portanto, um componente pode receber propriedades de um componente pai.  Cada vez que um componente obtém propriedades, esse método é chamado.  Ao mesmo tempo, esse método é chamado toda vez que o componente pai passa as propriedades para o componente filho, e não apenas quando isso acontece pela primeira vez.  Por exemplo, se o componente pai decide alterar as propriedades passadas para o componente filho, no método <code>componentWillReceiveProps()</code> , podemos, por exemplo, verificar se as novas propriedades diferem daquelas que já foram passadas para o componente.  O fato é que, se as novas propriedades não diferem das antigas, isso significa que o recebimento delas não altera nada, o que significa que, depois de descobrir, não podemos fazer mais nada.  Se as novas propriedades forem diferentes das antigas, podemos executar determinadas ações.  Normalmente, esse método é declarado no corpo da classe de componentes da seguinte maneira: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) { }</code> </pre> <br>  Aqui é geralmente usado, como o nome do parâmetro, <code>nextProps</code> , mas você pode nomear esse parâmetro como desejar.  Para comparar alguma propriedade específica que já foi transferida para o componente com o que já foi passado anteriormente e decidir sobre outras ações, você pode usar esta construção: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextProps.whatever !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.whatever) {       <span class="hljs-comment"><span class="hljs-comment">//   -    } }</span></span></code> </pre> <br>  Geralmente esse método é usado dessa maneira. <br><br>  No entanto, como já mencionado, após o lançamento do React 16.3, alguns métodos do ciclo de vida do componente foram descontinuados e <code>componentWillReceiveProps()</code> é um desses métodos. <br><br>  Até a Reação 17, esses métodos herdados ainda podem ser usados, embora seja melhor não.  Se você não pode ficar sem o método em questão, precisará chamá-lo de <code>UNSAFE_componentWillReceiveProps()</code> .  Após a reação 17, o nome do método <code>componentWillReceiveProps()</code> não significará nada de especial. <br><br>  É útil conhecer esse método para entender o código desatualizado, mas ele não será usado no desenvolvimento de aplicativos React modernos. <br><br>  Outro método interessante do ciclo de vida do componente é chamado <code>shouldComponentUpdate()</code> .  Ele, se continuarmos a comparar o componente com uma pessoa, lembra o momento em que uma pessoa está pensando se precisa trocar de roupa ou não.  Sob condições normais, se o React não tiver certeza absoluta da possibilidade de renderizar novamente um componente, ele será renderizado apenas por precaução.  Não importa se isso é necessário, de acordo com a lógica do aplicativo ou não. <br><br>  Isso faz com que o React renderize novamente os componentes, mesmo quando nada relacionado ao componente é alterado.  Isso pode atrasar o aplicativo, porque, por esse princípio, o React processa todos os componentes que compõem o aplicativo.  O método <code>shouldComponentUpdate()</code> permite que o desenvolvedor otimize o aplicativo.  Aqui você pode implementar alguma lógica que ajuda a descobrir a necessidade de atualizar o componente.  Este método é geralmente declarado assim: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) {   <span class="hljs-comment"><span class="hljs-comment">//  true        //  false    }</span></span></code> </pre> <br>  Além disso, a partir desse método, se o componente precisar ser renderizado novamente, levando em consideração novas propriedades e estado, você precisará retornar <code>true</code> .  Caso contrário, <code>false</code> deve ser retornado dele.  Na verdade, retornar <code>false</code> desse método leva ao fato de que o componente não é atualizado e o aplicativo é executado mais rapidamente, mas, ao fazer isso, você precisa ter certeza de que o componente não precisa realmente ser renderizado novamente.  Se o componente precisar ser atualizado e esse método retornar <code>false</code> , isso levará a erros difíceis de lidar. <br><br>  Outro método de ciclo de vida do componente sobre o qual falaremos é chamado <code>componentWillUnmount()</code> .  Este método marca o fim da "vida" do componente - o momento em que é removido da árvore DOM e desaparece da tela. <br><br>  Esse método é usado principalmente para liberar recursos ocupados por um componente e colocar as coisas em ordem antes de excluí-lo.  Por exemplo, se o método <code>componentDidMount()</code> foi configurado com algo como um ouvinte de evento, devido ao qual, quando o usuário rola a página, algum código é executado, é no <code>componentWillUnmount()</code> você pode excluir esse ouvinte de evento.  De fato, esse método possui muitos aplicativos que visam remover do aplicativo tudo o que se torna desnecessário após o desaparecimento do componente. <br><br>  Aqui está o código completo do nosso componente <code>App</code> , no qual os métodos do ciclo de vida são adicionados: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     componentDidMount() {       <span class="hljs-comment"><span class="hljs-comment">//  ,        }     componentWillReceiveProps(nextProps) {       if (nextProps.whatever !== this.props.whatever) {           //   -        }   }     shouldComponentUpdate(nextProps, nextState) {       //  true            //  false      }     componentWillUnmount() {       //            // ( -   )   }     render() {       return (           &lt;div&gt;               Code goes here           &lt;/div&gt;       )   } } export default App</span></span></code> </pre> <br>  Isso conclui esta lição, embora se deva observar que os métodos de ciclo de vida dos componentes do React não estão limitados aos que analisamos hoje. <br><br><h2>  <font color="#3AC1EF">Lição 35. Métodos do Ciclo de Vida dos Componentes, Parte 2</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Original</a> <br><br>  Como já mencionado na lição anterior, quando o React 16.3 foi lançado, foi relatado que os três métodos de ciclo de vida dos componentes estavam desatualizados.  Esses métodos são <code>componentWillMount()</code> , <code>componentWillReceiveProps()</code> e <code>componentWillUpdate()</code> .  Dois novos métodos também foram relatados.  Este é o método estático <code>getDerivedStateFromProps()</code> e o método <code>getSnapshotBeforeUpdate()</code> .  Não se pode dizer que esses métodos desempenharão um papel importante nas aulas futuras deste curso, mas, apesar disso, vamos conhecê-los aqui. <br><br>  Vamos experimentar o mesmo projeto que usamos na última vez. <br><br>  Aqui está a <code>getDerivedStateFromProps()</code> da declaração do método <code>getDerivedStateFromProps()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getDerivedStateFromProps(props, state) { }</code> </pre> <br>  Observe a <code>static</code> antes do nome do método.  Ele, com base nas propriedades aceitas por ele, deve retornar um estado atualizado.  É usado nesses casos em que um determinado componente deve aceitar as propriedades recebidas do componente pai e configurar seu estado com base nessas propriedades.  Detalhes sobre esse método podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Este material, publicado no blog React, diz que o uso desse método está longe de ser justificado em todas as situações em que parece útil.  Seu uso inadequado pode levar a vários erros, a uma queda no desempenho do aplicativo, portanto, use-o com cuidado.  Você não deve tentar resolver problemas com sua ajuda, cuja solução não se destina.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está a</a> documentação para este método. <br><br>  Agora vamos falar sobre o método <code>getSnapshotBeforeUpdate()</code> .  Aqui está como é a declaração dele no corpo da classe: <br><br><pre> <code class="javascript hljs">getSnapshotBeforeUpdate() { }</code> </pre> <br>  Ele pode ser considerado como um método de ciclo de vida que permite criar algo como um backup do que está no componente antes de atualizá-lo.  Assemelha-se a uma captura instantânea do estado de um aplicativo.  Note-se que os desenvolvedores do React dizem que o escopo deste método é limitado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está a</a> documentação para isso. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Hoje falamos sobre métodos de ciclo de vida de componentes.  Quando você avança no desenvolvimento de aplicativos React, eles certamente serão úteis.  Nas outras classes deste curso, encontraremos esses métodos, em particular com <code>componentDidMount()</code> .  Da próxima vez, falaremos sobre renderização condicional. <br><br>  <b>Caros leitores!</b>  Se você estiver desenvolvendo aplicativos React profissionalmente, conte-nos como você usa os métodos do ciclo de vida dos componentes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441578/">https://habr.com/ru/post/pt441578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441568/index.html">Gerenciamento de memória Python</a></li>
<li><a href="../pt441570/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 353 (17 a 24 de fevereiro de 2019)</a></li>
<li><a href="../pt441572/index.html">Frontend Weekly Digest (18 a 24 de fevereiro de 2019)</a></li>
<li><a href="../pt441574/index.html">Docker de aprendizagem Parte 6: Trabalhando com dados</a></li>
<li><a href="../pt441576/index.html">Redes Kubernetes: Pods</a></li>
<li><a href="../pt441580/index.html">Tutorial Reagir Parte 20: Primeira lição de renderização condicional</a></li>
<li><a href="../pt441582/index.html">Otimização do sistema de controle LQR</a></li>
<li><a href="../pt441584/index.html">PHP Digest No. 150 (11 a 25 de fevereiro de 2019)</a></li>
<li><a href="../pt441586/index.html">Como recomendar músicas que quase ninguém ouviu. Relatório Yandex</a></li>
<li><a href="../pt441590/index.html">A evolução da interação de cluster. Como implementamos o ActiveMQ e o Hazelcast</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>