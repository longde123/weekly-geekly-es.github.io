<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤺 🤶🏾 🔇 Desarrollo de un servidor TELNET basado en W5500 y ATMEGA8 👄 🤘🏼 🕦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, el complejo de software y hardware Arduino se ha vuelto muy popular, y está diseñado para desarrollar varios diseños electrónicos inter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de un servidor TELNET basado en W5500 y ATMEGA8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414211/">  Recientemente, el complejo de software y hardware Arduino se ha vuelto muy popular, y está diseñado para desarrollar varios diseños electrónicos interesantes.  Los diseños se realizan conectando la placa base Arduino con los módulos adicionales necesarios.  En la placa base Arduino hay un microcontrolador, cuyo firmware está escrito en un entorno de desarrollo especial para Arduino utilizando, por regla general, bibliotecas preparadas para uno u otro módulo. <br><br>  Uno de los módulos, el W5500, está destinado a la fabricación de estructuras electrónicas que se conectarán a Internet.  En este caso, con mayor frecuencia, implica el control remoto de su estructura.  Por ejemplo, puede ser una "casa inteligente", un robot y similares.  El proyecto más trivial (excepto Hello world) es la inclusión remota de LED a través de un navegador web (Fig. 1).  Si, en lugar de los LED, se conectan interruptores de transistor y relés, se pueden conmutar cargas más potentes.  Por lo tanto, en esencia, el programa (firmware) de este diseño es un servidor web que procesa las solicitudes http de un usuario remoto. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qj/xj/w5/qjxjw5zozlcgxty2zaxpld3tfow.jpeg"></div>  <i>Fig.</i>  <i>1. Gestión de LED a través de un navegador.</i> <br><br>  El módulo W5500 se basa en el propio chip W5500 con su kit de cuerpo, así como un conector BLS para MK a través de SPI, un conector RJ-45 para conectarse a una red informática y un regulador de voltaje lineal para 3.3 V (Fig.2). <br><br><img src="https://habrastorage.org/webt/ta/sd/nz/tasdnz169igf5gzmdd6geetdsc4.jpeg" width="375" height="375"><br><br>  <i>Fig.</i>  <i>2. El módulo W5500.</i> <br><br>  El chip W5500 es un controlador completo con procesamiento integrado de una pila completa de protocolos de red, desde Ethernet hasta TCP (Fig. 3).  Al implementar un diseño basado en este chip, el programador no necesita escribir el código de procesamiento del protocolo TCP / IP, es suficiente implementar solo el protocolo de capa de aplicación, que se integrará en TCP.  En el ejemplo anterior (en Arduino), http se utiliza como protocolo de aplicación. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5n/a0/dx/5na0dx-_xgs06can1rxipmlul7y.jpeg"></div>  <i>Fig.</i>  <i>3. La estructura del chip W5500.</i> <br><br>  Sin hacer Arduino, decidí estudiar la documentación del chip W5500 en detalle e implementar independientemente el programa basado en el microcontrolador Atmega8.  Este programa no incluirá un controlador http.  Se requiere implementar el intercambio de datos más simple (RAW) a través del protocolo TCP utilizando un terminal remoto.  No es del todo exacto hablar sobre el protocolo Telnet, como dice el título de este artículo.  Tiene sus propias características específicas basadas en el intercambio de información adicional sobre los parámetros de los terminales.  Sin embargo, la mayoría de los clientes de telnet admiten RAW y no requieren lo anterior.  Por lo tanto, el programa Atmega8 MK no incluirá un controlador de protocolo de nivel de aplicación.  Solo se ocupará de la inicialización del W5500, la gestión de socket, la recepción y transmisión de datos. <br><br>  La aplicación principal de este diseño es la gestión de dispositivos a través de un terminal remoto.  En este caso, el diseño se conecta al dispositivo administrado a través de la interfaz UART (tres cables GND, TxD, RxD).  La gestión a través del terminal es un enfoque profesional clásico en un área particular en ausencia de una interfaz gráfica.  Por ejemplo, una línea de comandos de Windows o Linux, o una forma de configurar un enrutador a través de un terminal utilizando el protocolo Telnet.  El último ejemplo es en realidad equivalente a la idea discutida en este artículo. <br><br>  Al desarrollar este o aquel dispositivo, si es necesario, preveo controlarlo con comandos de texto a través de un terminal conectado a través de la interfaz UART.  Esto puede ser una conexión a una PC normal al puerto COM RS-232 a través del chip adaptador MAX232, o al USB (puerto COM virtual) a través del chip PL2303.  Puede usar el programa HyperTerminal estándar como terminal.  Con la expansión de los teléfonos inteligentes Android, se hizo conveniente conectarse a través de Bluetooth: un módulo Bluetooth (por ejemplo, HC-06) está conectado a la interfaz UART del dispositivo, y un teléfono inteligente está conectado al módulo de forma inalámbrica.  Existen muchas aplicaciones en Internet que implementan el terminal a través de Bluetooth.  Por lo tanto, puede controlar el dispositivo a través del terminal desde un teléfono móvil a través de Bluetooth en un rango corto.  El diseño discutido en este artículo le permite implementar el control a través del terminal usando Internet.  El terminal puede ser el HyperTerminal estándar, que viene con Windows XP, o puede ejecutar la utilidad telnet desde la línea de comandos de Windows y trabajar en ella.  Si hablamos de un teléfono inteligente, puede elegir una de las aplicaciones en Android (también hay una gran cantidad de ellas) (Fig. 4). <br><br><img src="https://habrastorage.org/webt/4g/ia/x7/4giax7dezsah7q-pjb5eso6tftm.jpeg" width="400" height="640"><br><br>  <i>Fig.</i>  <i>4. Aplicaciones para "terminal TCP" en Google Play.</i> <br><br>  El chip W5500 tiene 8 zócalos independientes, cada uno de los cuales tiene una memoria para recibir y transmitir información de más de 2 KB.  Total, la memoria total es de 16 KB para recibir y 16 KB para transmitir información.  Estos parámetros se usan por defecto, pero si es necesario, en la etapa de inicialización del chip, la memoria se puede reasignar a través de sockets.  La aplicación que se describe aquí utilizará la configuración de memoria predeterminada y los 8 sockets están involucrados.  A cada socket en la etapa de su inicialización se le asignan muchos parámetros, el principal de los cuales es su modo de operación y puerto TCP.  El modo de operación de los ocho sockets que necesitamos es el modo del servidor TCP.  Debe asignar diferentes puertos a cada socket.  Tomé ocho puertos consecutivos, comenzando, por ejemplo, desde 4000. En la etapa de inicialización del módulo W5500, se le asignan parámetros de red conectados al programa Atmega8 MK: dirección IP, máscara de subred, dirección IP de la puerta de enlace e incluso la dirección MAC física.  La configuración de red del W5500 debe coincidir con la configuración de la red doméstica a la que se conecta.  Cuando se conecta de forma remota a nuestro dispositivo descrito, la configuración del terminal indica la dirección del host (dirección IP o nombre de dominio) y el puerto.  La dirección del host se refiere al dispositivo W5500, y el puerto se refiere al zócalo en el dispositivo.  Un socket puede funcionar con una sola conexión.  Por lo tanto, es posible hacer ocho conexiones simultáneas independientes.  La Figura 5 muestra los parámetros de conexión en el programa HyperTerminal estándar al W5500 con la dirección IP 192.168.0.111 al zócalo 0 (puerto 4000).  Para conectarse a Internet global (desde el exterior), debe configurar correctamente su enrutador doméstico. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gl/xf/dt/glxfdtxvfstq3pbj0_bguqpusm8.jpeg"></div>  <i>Fig.</i>  <i>5. Conexión a través de TCP / IP en HyperTerminal.</i> <br><br>  Probé muchas aplicaciones de terminal TCP diferentes, cada una tiene sus propias ventajas y desventajas.  En primer lugar, por el método de empaquetar un paquete TCP, se pueden distinguir dos casos.  En el primer caso, se genera un paquete TCP y se envía al servidor inmediatamente cuando se ingresa un carácter en el terminal.  Por lo tanto, el campo de datos de cada paquete toma 1 byte y contiene el carácter ingresado por el usuario.  El programa HyperTerminal funciona solo en este modo.  En el segundo caso, el juego de caracteres (comando) se ingresa en un campo de texto separado, y cuando hace clic en el botón "Enviar", solo se forma un paquete con un campo de datos, cuyo contenido es un juego de caracteres ingresado por el usuario.  El tamaño del campo de datos de dicho paquete en bytes coincide con el número de caracteres ingresados.  El segundo caso es el más preferible y conveniente, además de económico en el tráfico.  Nuestro diseño funciona con ambos casos, transfiriendo a la salida (TxD) del UART MK Atmega8 todos los caracteres ingresados ​​por el usuario remoto desde cualquier socket. <br><br>  En cuanto a la organización de la transferencia de información del servidor al cliente, aquí también tienen sus propias características.  Es posible hacer que el programa MK genere un paquete TCP de un solo byte también directamente, al recibir un byte (carácter) en el tramo RxD UART MK.  Puede crear un paquete TCP a partir de un conjunto de bytes entrantes al MK mediante la presencia de una señal adicional especial, que solo está presente durante la transmisión de la secuencia desde el dispositivo conectado (señal de empaque).  Por cierto, esta señal se usa para cambiar el MAX485 a transmisión en el caso de convertir RS-232 a interfaz RS-485 semidúplex.  Sin embargo, como estaba convencido, es más conveniente usar un temporizador, es decir  un pequeño retraso durante el cual se realizará la recepción de caracteres y la formación del paquete TCP.  Este es el método que implementé en la construcción descrita.  Funciona de la siguiente manera.  El temporizador (el tiempo se establece aproximadamente 0.3 segundos) Comienza cuando llega el primer personaje y se reinicia cuando llega el siguiente personaje en el UART MK.  Si no llegaron caracteres en un tiempo específico, se forma un paquete con los caracteres recibidos y se envía al cliente, y el temporizador se detiene.  En mi caso particular, hay un correo masivo en todos los sockets a los que están conectados los clientes. <br><br>  Ahora será sobre la privacidad.  El terminal remoto descrito no está protegido contra escuchas usando analizadores de tráfico.  Incluso el protocolo Telnet en sí no proporciona autenticación y cifrado de contraseña.  Para esto, hay otros protocolos modernos de terminal remota.  Y en el caso de Telnet, así como en el caso de RAW (sin un protocolo de aplicación), puede implementar un método indirecto de autenticación de contraseña, que solo será ineficaz con una intervención intencional intencional.  Sin embargo, este método de autorización protegerá contra el tráfico "izquierdo" no controlado.  Puede provenir de spyware, que, clasificando el rango de direcciones IP de proveedores conocidos y el rango de puertos, puede conectarse repentinamente a nuestro dispositivo (si "escucha" las conexiones de Internet).  En mi firmware, implementé una página de bienvenida del cliente, si estaba conectada al servidor, es decir.  al diseño basado en el módulo W5500. <br><br>  La página de bienvenida contiene información sobre la dirección IP del cliente, el número de socket (para monitoreo) y una solicitud para ingresar una contraseña (Fig. 6). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ea/nw/2q/eanw2qiq7wtm974w7brndgscqja.jpeg"></div>  <i>Fig.</i>  <i>6. Página de bienvenida para el servidor W5500.</i> <br><br>  Después de conectarse dentro del programa MK, se inicia un temporizador (durante aproximadamente 18 segundos), durante el cual el usuario debe tener tiempo para ingresar una contraseña específica (la misma en todos los enchufes).  Si la contraseña se ingresa de manera incorrecta, una vez transcurrido el tiempo establecido, el usuario informa el mensaje correspondiente y el servidor se desconecta (Fig. 7). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/i5/rh/qii5rh4vsutckz8oyinxlurdsv8.jpeg"></div>  <i>Fig.</i>  <i>7. Informar una contraseña incorrecta.</i> <br><br>  En el caso de una contraseña ingresada correctamente, al usuario también se le muestra el mensaje correspondiente (Fig. 8).  Después de eso, se establece un puente "transparente" entre el terminal remoto y la interfaz UART del MK, al que se conecta el módulo W5500 a través de SPI.  El funcionamiento de dicho puente se probó solo a nivel de equipos de usuarios.  Es posible que no se garantice un intercambio de datos de alta velocidad completo si, en algunos casos, la aplicación del cliente no es un terminal de usuario, sino algún otro programa.  Y aún más, el diseño descrito no garantiza (más precisamente, no está previsto) el intercambio de datos full-duplex. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9j/lx/4c/9jlx4c2o2sjavhkdq2gut43oo7m.jpeg"></div>  <i>Fig.</i>  <i>8. Mensaje sobre la contraseña correcta.</i> <br><br>  Cuando se ingresa una contraseña, el usuario no devuelve los caracteres que ingresa al terminal, y tampoco funciona "Retroceso" (retroceder con un carácter ingresado incorrectamente).  La longitud de la contraseña es de 8 caracteres.  El programa MK escanea los primeros 8 caracteres recibidos del cliente, independientemente de su distribución a través de paquetes TCP.  Pero cualquier paquete no debe exceder los 10 bytes.  Por cierto, la función "Enviar archivo de texto" en HyperTerminal funciona de manera bastante interesante.  Como se verificó utilizando un analizador de tráfico, cuando se realiza esta función, se forman dos paquetes TCP: el primer paquete con datos de 1 byte contiene el primer carácter del archivo de texto transmitido, y el segundo paquete contiene el resto del contenido. <br><br>  El servidor proporciona dos contraseñas diferentes.  Una contraseña se usa para establecer el puente TCP-UART (uso normal), como se describió anteriormente, y la segunda contraseña se usa para controlar el módulo W5500 u otros parámetros de diseño.  Si se ingresa esta contraseña, se muestra al usuario otra página de bienvenida y se ingresa al modo de control.  Proporcioné intencionalmente que este modo solo era posible en uno de los zócalos libres.  Si un socket con este modo está ocupado y se intenta iniciar sesión en este modo en otro socket, el servidor desconectará inmediatamente la conexión.  Antes del descanso, se mostrará un mensaje sobre el número de socket que ya está funcionando (ocupado) en el modo de control (Fig. 9). <br><br>  El modo de control proporciona los comandos que he definido, una lista de los cuales se puede ver ingresando el comando de ayuda.  El comando debe terminar con un carácter de nueva línea (tecla Intro).  Además, si el modo de control está activo, el servidor W5500 envía mensajes de servicio al terminal, por ejemplo, sobre la conexión de clientes a otros zócalos con sus direcciones IP o sobre un zócalo libre.  La figura 10 muestra lo anterior.  La lista de equipos aún no está completa, se repondrá con el tiempo. <br><br><img src="https://habrastorage.org/webt/mb/bu/v_/mbbuv_bfry1kuj83z8wgwzxwbqm.jpeg" width="400" height="340"><br><br>  <i>Fig.</i>  <i>9. Un mensaje sobre un socket ocupado cuando ingresa la contraseña del modo de control.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/es/dk/sn/esdksn_il5ajj_btzatrxlaxeb4.jpeg"></div>  <i>Fig.</i>  <i>10. Modo de control W5500.</i> <br><br>  El comando echo deshabilita o habilita el retorno del carácter impreso al terminal (autocontrol).  Los siguientes dos comandos son para leer y escribir el registro de dirección del chip W5500.  Los valores de los registros para las direcciones se indican en la documentación del chip W5500.  Introduje estos comandos universales, principalmente para la depuración.  El comando rl reinicia inmediatamente el número de socket indicado después.  Del mismo modo, el comando sr lee el estado del socket, dando su valor como un número HEX.  El comando "ens" proporciona una tabla de estados para cada socket: estado "0": el socket está libre, esperando al cliente, estado "1": el socket en uso normal, estado "2": el socket en modo de control.  Puede ingresar una cantidad mucho mayor de comandos.  Será útil cambiar los parámetros que se ajustan al chip en la etapa de inicialización cuando se enciende el dispositivo (por ejemplo, parámetros de red), almacenándolos en la memoria no volátil del MK.  También puede ser útil ingresar comandos especiales que controlarán pines MK libres adicionales.  Por ejemplo, "PC0 = 1", "PC2 = 0", etc.  Asegúrese de necesitar el comando de configuración UART interface MK. <br><br>  Considere los detalles más sutiles del trabajo del programa MK.  Además de los temporizadores mencionados anteriormente, se activa un temporizador, gracias al cual, cada aproximadamente medio minuto, se denomina  Paquetes de control TCP "keep-alive".  Esto es necesario para verificar la conexión en ausencia de intercambio de datos del usuario.  Si por alguna razón no hay confirmación del cliente dentro de un cierto tiempo establecido dentro del W5500, el llamado  tiempo de espera y el zócalo se reiniciará.  La conexión puede perderse repentinamente, por ejemplo, debido a una interrupción en el enlace de datos o la capa física: desconectaron un cable Ethernet, desconectaron Internet o perdieron una conexión Wi-Fi, etc. <br><br>  Según la documentación del chip W5500 (hoja de datos), las siguientes funciones se implementan en el código del programa.  En primer lugar, las funciones básicas de escribir y leer registros W5500 en direcciones.  Funciones de nivel superior: reinicio de hardware, inicialización de chip, inicialización de socket, abrir un socket, escuchar socket, desconectar y cerrar el socket, enviar el comando "keep_alive", reiniciar el socket.  La última función es una composición de las funciones anteriores: cierre, apertura, escucha.  La mayoría de las funciones devuelven un valor de estado de socket después de que se ejecutan.  Finalmente, las funciones más básicas son procesar la información recibida (lectura del búfer RX) y procesar la información enviada (escribir en el búfer TX).  Tomé recomendaciones sobre la implementación de estas funciones del sitio web oficial del fabricante de chips W5500 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> ).  La función de recepción sobrescribe los datos recibidos del búfer RX en su propio búfer sin anillo de 128 bytes.  Este tamaño es suficiente para aplicaciones simples, y no puede obtener mucho del microcontrolador Atmega8.  El búfer TX del W5500 también transfiere datos del búfer intermedio, que también es de tamaño pequeño.  Y a su vez, los datos del búfer de anillo UART entran en él.  Este último se implementa automáticamente en el entorno de desarrollo CVAVR utilizando la utilidad CodeWizardAVR en la etapa de creación del proyecto. <br><br>  El W5500 está conectado a la interfaz MKI SPI (MOSI, MISO, SCK, SCLK).  Además, el pin RST (reinicio de hardware) está conectado a una salida MK específica, y el pin INT correspondiente está conectado a la entrada de interrupción externa INT0.  Este último se utiliza para su propósito previsto: cuando ocurre un evento en el módulo W5500, genera un pulso en el pin INT, que es procesado por el controlador en el cuerpo de la interrupción externa.  MK aprende en qué sockets se produjo el evento, luego reescribe los códigos de evento para cada socket en una matriz específica.  El procesamiento adicional de la interrupción ocurre dentro del ciclo principal del programa.  En total, se documentaron cinco eventos: el cliente se conectó, el cliente se desconectó (más precisamente, presentó una solicitud de desconexión), se recibieron datos del cliente, se agotó el tiempo de espera, los datos se enviaron con éxito.  En el bucle principal, se procesan todos los eventos excepto el último.  La declaración de cambio de caso se coloca en este proceso.  La mayor parte del código C se encuentra en la sección de procesamiento del tercer evento (recepción de datos).  En él, después de la función de procesar la información recibida, también se coloca el operador de caja de conmutación, pero en este caso este "interruptor" está asociado con una variable responsable del estado del socket mencionado anteriormente (valores 0, 1, 2).  La primera sección es responsable del procedimiento de reconocimiento de contraseña.  Los caracteres recibidos se sobrescriben en un búfer de contraseña separado.  Bajo ciertas condiciones, las funciones de comparar la cadena recibida con cadenas constantes que contienen contraseñas funcionan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En caso de coincidencia, se asigna el estado correspondiente. La segunda sección es la más simple: el contenido de su propio búfer de información recibida se redirige al UART del microcontrolador. Este es un modo de uso normal. La tercera sección (la más grande) se encarga de procesar los comandos: modo de control del dispositivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además de la continuación del controlador de interrupciones, el bucle principal del programa contiene controladores de temporizador virtual: un tiempo de espera para desconectarse cuando la contraseña no tiene éxito, envíe periódicamente "keep-alive" y envíe un paquete formado por el temporizador TCP al cliente. La función de lectura de UART también se coloca en el cuerpo del bucle principal, dentro del cual los caracteres recibidos por el controlador se transfieren a su propio búfer de transmisión (intermedio) y se reinicia el temporizador, que es responsable de la formación del paquete TCP.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los procedimientos de socket se colocan en un ciclo de 0 a 7, cuyo iterador está vinculado al número de socket. Por lo tanto, se produce el procesamiento secuencial de todos los sockets. Inicialmente, quise decir que si asigna el mismo número de puerto a cada uno de los ocho sockets, puede conectar hasta ocho usuarios en el mismo puerto. Sin embargo, esta configuración no funcionó y este problema se pospuso para el futuro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al diseñar el diseño de la placa de circuito, proporcioné un reloj en tiempo real (RTC) en el chip DS1307. El Atmega8 MK, cuarzo para la frecuencia de 11.0592 MHz (frecuencia seleccionada para precisión UART), un conector para el módulo W5500, conectores de puerto MK (incluido SPI para firmware, UART), RTC con su propio compartimento de batería de cuarzo y CR2032 están ubicados en una placa de circuito impreso de dos lados , Regulador lineal de 5 V (7805), conector de alimentación y más. El boceto de la placa de circuito impreso en el programa Sprint Layout se muestra en la Figura 11. El único elemento que se muestra en rojo está soldado en la parte posterior, pero lo solté en la parte frontal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/po/fd/zapofdoavvxgcamlagyghd_zkae.jpeg"></div>  <i>Fig.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Boceto de la placa de circuito.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las fotos de la construcción terminada se presentan en la Figura 12. Se usará un reloj en esta construcción para marcar la hora durante varios eventos de los enchufes W5500, y esta vez se asignará al usuario en el terminal al lado del mensaje si el usuario está conectado en modo de control. Y también, el reloj será útil para el futuro para experimentos con el protocolo de tiempo NTP o para cualquier otro propósito.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hf/fv/_r/hffv_rfjm1svqdgzmvmauahrmw0.jpeg"></div>  <i>Fig.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Fotos de la estructura terminada.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En conclusión, vale la pena señalar que el diseño interno en su mayor parte justifica dispositivos similares a nivel industrial. La principal ventaja es el precio. Resultó ser mucho más barato de fabricar que el precio de un dispositivo similar terminado. Y una desventaja como la funcionalidad limitada es inevitable. En este caso, se utilizó un controlador Atmega8 simplificado, ya que se estableció el objetivo simplificado correspondiente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hy/ko/fx/hykofxdictcvxijma6idea8hczq.jpeg"></div>  <i>Fig.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13. Convertidor industrial TCP / IP - RS-232.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La Figura 13 muestra un ejemplo de un convertidor industrial TCP / IP a RS-232 basado en el chip W5100, muy similar al W5500. Además de su interfaz de administración flexible, tiene una ventaja más. Además de trabajar con un terminal TCP / IP, es posible utilizar un controlador especial que viene con el dispositivo para instalar un puerto COM virtual en el lado del cliente. A través de él, puede conectarse usando un terminal normal que no tiene modo de conexión TCP / IP. Además, el dispositivo puede admitir el intercambio de datos RS-232 completo si algún programa está conectado en lugar del terminal a través de un puerto COM virtual. Es decir, el dispositivo representado en la Figura 13 es un puente RS-232 completo a través de la infraestructura de red.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414211/">https://habr.com/ru/post/es414211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414199/index.html">Skynet, hola: la inteligencia artificial ha aprendido a ver a las personas a través de las paredes</a></li>
<li><a href="../es414201/index.html">Código Divino (código de DIOS)</a></li>
<li><a href="../es414203/index.html">Estafa o no estafa? Verificamos ICO por cinco métodos</a></li>
<li><a href="../es414207/index.html">El problema del innovador, o por qué necesita recurrir a la experiencia de otras personas.</a></li>
<li><a href="../es414209/index.html">IGNG - Algoritmo incremental de gas neuronal incremental</a></li>
<li><a href="../es414213/index.html">¡Uno, dos, tres! Chatbot de Google Sheets usando el ejemplo de un juego PvP para Alice</a></li>
<li><a href="../es414215/index.html">Bloques personalizados en chips (Silicon IP): cómo funciona</a></li>
<li><a href="../es414217/index.html">Smartphones locales Vertex: primero en calidad, primero en chips, primero en diseño</a></li>
<li><a href="../es414219/index.html">La experiencia del uso de la energía solar en la región de Moscú: a favor, en contra y quién la necesita</a></li>
<li><a href="../es414221/index.html">Analizando y trabajando con Codificable en Swift 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>