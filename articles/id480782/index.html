<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐸 🏴󠁧󠁢󠁳󠁣󠁴󠁿 💧 5 hal yang ingin saya ketahui ketika saya mulai menggunakan Angular 🚟 🔽 👨🏻‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern Angular adalah kerangka kerja yang kuat dengan banyak fitur, bersamaan dengan itu sekilas konsep dan mekanisme kompleks muncul. Ini terutama te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 hal yang ingin saya ketahui ketika saya mulai menggunakan Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/480782/"><p>  Modern Angular adalah kerangka kerja yang kuat dengan banyak fitur, bersamaan dengan itu sekilas konsep dan mekanisme kompleks muncul.  Ini terutama terlihat bagi mereka yang baru saja mulai bekerja di front-end pada prinsipnya, dan dengan Angular pada khususnya. </p><br><p>  Saya juga menghadapi masalah yang sama ketika saya datang ke Tinkoff ke posisi Junior Frontend Developer sekitar dua tahun yang lalu dan terjun ke dunia Angular.  Karena itu, saya menawarkan kepada Anda sebuah cerita pendek tentang lima hal, yang pengertiannya akan sangat memudahkan pekerjaan saya pada awalnya. </p><br><p><img src="https://habrastorage.org/webt/er/qq/op/erqqope6skve-m43vun9ivrjyda.png"></p><a name="habracut"></a><br><h2 id="dependency-injection-di">  Ketergantungan Injeksi (DI) </h2><br><p>  Awalnya saya masuk ke komponen dan melihat ada beberapa argumen di konstruktor kelas.  Saya melakukan sedikit analisis tentang pekerjaan metode kelas, dan menjadi jelas bahwa ini adalah beberapa dependensi eksternal.  Tapi bagaimana mereka masuk kelas?  Di mana konstruktor dipanggil? </p><br><p>  Saya sarankan segera untuk memahami contoh, tetapi untuk ini kita perlu kelas.  Jika dalam OOP JavaScript "normal" hadir dengan "peretasan" tertentu, maka bersama dengan ES6 ada sintaks "nyata".  Angular menggunakan TypeScript langsung dari kotak, di mana sintaksnya hampir sama.  Karena itu, saya mengusulkan untuk menggunakannya lebih lanjut. </p><br><p> Bayangkan bahwa ada kelas <code>JokerService</code> di aplikasi kita yang mengelola lelucon.  Metode <code>getJokes()</code> mengembalikan daftar lelucon.  Misalkan kita menggunakannya di tiga tempat.  Bagaimana cara membuat lelucon di tiga tempat berbeda dalam kode?  Ada beberapa cara: </p><br><ol><li>  Buat instance kelas di setiap tempat.  Tetapi mengapa kita perlu menyumbat memori dan membuat begitu banyak layanan yang identik?  Dan apakah ada 100 kursi? </li><li>  Jadikan metode statis dan ambil data menggunakan JokerService.getJokes (). </li><li>  Terapkan salah satu pola desain.  Jika kita membutuhkan layanan untuk menjadi satu untuk seluruh aplikasi, maka ini akan menjadi Singleton.  Tetapi untuk ini, Anda perlu menulis logika baru di kelas. </li></ol><br><p>  Jadi, kami memiliki tiga opsi yang cukup berhasil.  Yang pertama tidak cocok untuk kita - dalam hal ini tidak efektif.  Kami tidak ingin membuat salinan tambahan, karena mereka akan sepenuhnya identik.  Masih ada dua opsi. </p><br><p>  Mari menyulitkan tugas untuk memahami metode mana yang paling cocok untuk kita.  Misalkan, di tempat ketiga, kita perlu untuk beberapa alasan untuk membuat layanan kita sendiri dengan parameter tertentu.  Ini mungkin penulis tertentu, panjang lelucon, bahasa, dan banyak lagi.  Apa yang akan kita lakukan? </p><br><p>  Dalam hal metode statis, Anda harus melewati pengaturan dengan setiap panggilan, karena kelas umum untuk semua tempat.  Artinya, dalam setiap panggilan ke <code>getJokes()</code> kami akan meneruskan semua parameter unik ke tempat ini.  Tentu saja, lebih baik untuk meneruskannya ketika Anda instantiate dan kemudian panggil saja metode <code>getJokes()</code> . </p><br><p>  Ternyata opsi kedua tidak cocok untuk kita: itu akan membuat kita selalu menduplikasi banyak kode di setiap tempat.  Tetap hanya Singleton, yang lagi-lagi perlu memperbarui logika, tetapi dengan variasi.  Tetapi bagaimana cara memahami opsi mana yang kita butuhkan? </p><br><p>  Jika Anda berpikir bahwa Anda hanya dapat membuat objek dan menggunakan kunci untuk mengambil layanan yang diinginkan, saya dapat memberi selamat kepada Anda: Anda baru menyadari bagaimana <em>Dependency Injection</em> bekerja secara umum.  Tapi mari kita sedikit lebih dalam. </p><br><p>  Untuk memastikan bahwa suatu mekanisme diperlukan untuk membantu kami mendapatkan contoh yang diperlukan, bayangkan bahwa JokerService membutuhkan dua layanan lain, salah satunya adalah opsional, dan yang kedua harus memberikan hasil khusus di tempat tertentu.  Itu tidak sulit. </p><br><h3 id="dependency-injection-v-angular">  Ketergantungan Injeksi dalam Sudut </h3><br><p>  Seperti yang dikatakan dalam <a href="https://angular.io/guide/dependency-injection">dokumentasi</a> , DI adalah pola desain yang penting untuk suatu aplikasi.  Angular memiliki kerangka kerja dependensi sendiri, yang digunakan dalam Angular sendiri untuk meningkatkan efisiensi dan modularitas. </p><br><p>  Secara umum, <em>Injeksi Ketergantungan</em> adalah mekanisme yang kuat di mana kelas menerima dependensi yang diperlukan dari suatu tempat di luar, daripada membuat instance sendiri. </p><br><p>  Biarkan sintaks dan file dengan ekstensi <code>html</code> tidak membingungkan Anda.  Setiap komponen dalam Angular adalah objek JavaScript biasa, turunan dari sebuah kelas.  Secara umum: ketika Anda memasukkan komponen ke dalam templat, turunan dari kelas komponen dibuat.  Dengan demikian, pada saat ini, Anda dapat meneruskan dependensi yang diperlukan ke konstruktor.  Sekarang pertimbangkan sebuah contoh: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'jokes', template: './jokes.template.html', }) export class JokesComponent { private jokes: Observable&lt;IJoke[]&gt;; constructor(private jokerService: JokerService) { this.jokes = this.jokerService.getJokes(); } }</code> </pre> <br><p>  Dalam konstruktor komponen, kami cukup menunjukkan bahwa kami membutuhkan <code>JokerService</code> .  Kami tidak membuatnya sendiri.  Jika ada lima komponen lagi yang menggunakannya, maka mereka semua akan merujuk ke contoh yang sama.  Semua ini memungkinkan kita menghemat waktu, menghilangkan pelat tungku dan menulis aplikasi yang sangat produktif. </p><br><h3 id="providers">  Penyedia </h3><br><p>  Dan sekarang saya mengusulkan untuk menangani kasus ini ketika Anda perlu mendapatkan contoh layanan yang berbeda.  Pertama, lihatlah layanan itu sendiri: </p><br><pre> <code class="plaintext hljs">@Injectable({ providedIn: 'root', //   ,   «»  }) export class JokerService { getJokes(): Observable&lt;IJoke[]&gt; { //     } }</code> </pre> <br><p>  Ketika layanan adalah satu untuk seluruh aplikasi, opsi ini akan cukup.  Tetapi bagaimana jika kita memiliki, katakanlah, dua implementasi <code>JokerService</code> ?  Atau apakah hanya karena alasan tertentu bahwa komponen tertentu memerlukan instance layanannya sendiri?  Jawabannya sederhana: <a href="https://angular.io/guide/providers"><code>provider</code></a> . </p><br><p>  Untuk kenyamanan, saya akan memanggil <code>provider</code> <em>penyedia</em> , dan proses penggantian nilai ke dalam kelas akan <em>diperiksa</em> .  Jadi, kami dapat menyediakan layanan dengan cara dan tempat yang berbeda.  Mari kita mulai dengan yang terakhir.  Ada tiga opsi yang tersedia: </p><br><ul><li>  Ke seluruh aplikasi - tentukan <code>provideIn: 'root'</code> di dekorator layanan itu sendiri. </li><li>  Dalam modul - tentukan penyedia di dekorator layanan sebagai <code>provideIn: JokesModule</code> atau di dekorator modul <code>@NgModule  providers: [JokerService]</code> . </li><li>  Dalam komponen - tentukan penyedia di dekorator komponen, seperti dalam modul. </li></ul><br><p>  Tempat ini dipilih tergantung kebutuhan Anda.  Kami menemukan tempat itu, mari beralih ke mekanisme itu sendiri.  Jika kita hanya menetapkan <code>provideIn: root</code> di layanan, ini akan setara dengan entri berikut dalam modul: </p><br><pre> <code class="plaintext hljs">@NgModule({ // ...     providers: [{provide: JokerService, useClass: JokerService}], }) //  </code> </pre> <br><p>  Ini bisa dibaca seperti ini: "Jika <code>JokerService</code> diminta, maka berikan instance dari kelas <code>JokerService»</code>  Dari sini Anda bisa mendapatkan contoh spesifik dengan berbagai cara: </p><br><ul><li><p>  Dengan token - Anda harus menentukan <code>InjectionToken</code> dan mendapatkan layanannya.  Perhatikan bahwa dalam contoh di bawah ini, Anda dapat melewati token yang sama: </p><br><pre> <code class="plaintext hljs">const JOKER_SERVICE_TOKEN = new InjectionToken&lt;string&gt;('JokerService'); // ...     [{provide: JOKER_SERVICE_TOKEN, useClass: JokerService}];</code> </pre> <br></li><li><p>  Berdasarkan kelas - Anda dapat mengganti kelas.  Misalnya, kami akan meminta <code>JokerService</code> , dan memberikan - <code>JokerHappyService</code> : </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useClass: JokerHappyService}];</code> </pre> <br></li><li><p>  Berdasarkan nilai - Anda dapat segera mengembalikan instance yang diinginkan: </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useValue: jokerService}];</code> </pre> <br></li><li><p>  Dengan pabrik - Anda dapat mengganti kelas dengan pabrik yang akan membuat instance yang diinginkan ketika diakses: </p><br><pre> <code class="plaintext hljs">[{provide: JokerService, useFactory: jokerServiceFactory}];</code> </pre> <br></li></ul><br><p>  Itu saja.  Yaitu, untuk memecahkan contoh dengan contoh khusus, Anda dapat menggunakan salah satu metode di atas.  Pilih yang paling cocok untuk kebutuhan Anda. </p><br><p>  Omong-omong, DI bekerja tidak hanya untuk layanan, tetapi secara umum untuk entitas apa pun yang Anda dapatkan di konstruktor komponen.  Ini adalah mekanisme yang sangat kuat yang harus digunakan secara maksimal. </p><br><h3 id="nebolshoy-itog">  Ringkasan kecil </h3><br><p>  Untuk pemahaman yang lengkap, saya mengusulkan untuk mempertimbangkan mekanisme Injeksi Ketergantungan yang disederhanakan dalam Angular dalam langkah-langkah menggunakan contoh layanan: </p><br><ol><li>  Saat menginisialisasi aplikasi, layanan memiliki token.  Jika kami tidak menentukannya secara khusus di penyedia, maka ini adalah JokerService. </li><li>  Ketika suatu layanan diminta dalam suatu komponen, mekanisme DI memeriksa apakah token yang ditransfer ada. </li><li>  Jika token tidak ada, maka DI akan melempar kesalahan.  Dalam kasus kami, token ada dan JokerService terletak di sana. </li><li>  Ketika komponen dibuat, turunan dari JokerService diteruskan ke konstruktor sebagai argumen. </li></ol><br><h2 id="change-detection">  Ubah deteksi </h2><br><p>  Kita sering mendengar, sebagai argumen untuk menggunakan kerangka kerja, sesuatu seperti “Kerangka kerja akan melakukan segalanya untuk Anda - lebih cepat dan lebih efisien.  Anda tidak perlu memikirkan apa pun.  Kelola saja datanya. ”  Mungkin ini benar dengan aplikasi yang sangat sederhana.  Tetapi jika Anda harus bekerja dengan input pengguna dan terus beroperasi pada data, maka Anda hanya perlu tahu bagaimana proses mendeteksi perubahan dan rendering bekerja. </p><br><p>  Di Angular, <em>Change Detection</em> bertanggung jawab untuk memeriksa perubahan.  Sebagai hasil dari berbagai operasi - mengubah nilai properti kelas, menyelesaikan operasi asinkron, menanggapi permintaan HTTP, dan sebagainya - proses verifikasi dimulai di seluruh pohon komponen. </p><br><p>  Karena tujuan utama dari proses ini adalah untuk memahami cara merender ulang suatu komponen, intinya adalah memverifikasi data yang digunakan dalam templat.  Jika berbeda, maka templat ditandai sebagai "diubah" dan akan digambar ulang. </p><br><h3 id="zonejs">  Zone.js </h3><br><p>  Memahami bagaimana Angular melacak properti kelas dan operasi sinkron sangat sederhana.  Tapi bagaimana cara melacak asinkron?  Perpustakaan Zone.js, yang dibuat oleh salah satu pengembang Angular, bertanggung jawab untuk ini. </p><br><p>  Inilah dia.  Zona itu sendiri adalah "konteks eksekusi," untuk membuatnya terus terang, tempat dan negara di mana kode dieksekusi.  Setelah operasi asinkron selesai, fungsi panggilan balik dieksekusi di zona yang sama tempat terdaftarnya.  Jadi Angular mencari tahu di mana perubahan itu terjadi dan apa yang harus diperiksa. </p><br><p>  Zone.js menggantikan dengan implementasinya hampir semua fungsi dan metode asinkron asli.  Oleh karena itu, ia dapat melacak kapan <code>callback</code> fungsi asinkron akan dipanggil.  Yaitu, Zone memberi tahu Angular kapan dan di mana untuk memulai proses validasi perubahan. </p><br><h3 id="strategii-obnaruzheniya-izmeneniy">  Ubah Strategi Deteksi </h3><br><p>  Kami menemukan bagaimana Angular memonitor komponen dan menjalankan pemeriksaan perubahan.  Sekarang bayangkan Anda memiliki aplikasi besar dengan banyak komponen.  Dan untuk setiap klik, setiap operasi yang tidak sinkron, setiap permintaan yang berhasil dieksekusi, sebuah cek diluncurkan di seluruh pohon komponen.  Kemungkinan besar, aplikasi semacam itu akan memiliki masalah kinerja yang serius. </p><br><p>  Pengembang sudut memikirkan hal ini dan memberi kami kesempatan untuk membangun strategi deteksi perubahan, pilihan yang tepat yang dapat secara signifikan meningkatkan produktivitas. </p><br><p>  Ada dua opsi untuk dipilih: </p><br><ul><li>  Default - seperti namanya, ini adalah strategi default ketika CD diluncurkan untuk setiap tindakan. </li><li>  OnPush adalah strategi di mana CD diluncurkan hanya dalam beberapa kasus: <br><ul><li>  jika nilai <code>@Input()</code> telah berubah; </li><li>  jika suatu peristiwa telah terjadi di dalam komponen atau turunannya; </li><li>  jika pemeriksaan dimulai secara manual; </li><li>  jika acara baru tiba di Async Pipe. </li></ul></li></ul><br><p>  Berdasarkan pengalaman pengembangan saya sendiri pada Angular, serta pengalaman rekan-rekan saya, saya dapat mengatakan dengan pasti bahwa selalu lebih baik untuk menentukan strategi <code>OnPush</code> , kecuali jika <code>default</code> benar-benar diperlukan.  Ini akan memberi Anda beberapa keuntungan: </p><br><ul><li>  Pemahaman yang jelas tentang bagaimana proses CD bekerja. </li><li>  Rapi bekerja dengan properti <code>@Input()</code> . </li><li>  Keuntungan kinerja. </li></ul><br><h2 id="rabota-s-input">  Bekerja dengan <code>@Input()</code> </h2><br><p>  Seperti kerangka kerja populer lainnya, Angular menggunakan aliran data hilir.  Komponen menerima parameter input yang ditandai dengan dekorator <code>@Input()</code> .  Pertimbangkan sebuah contoh: </p><br><pre> <code class="plaintext hljs">interface IJoke { author: string; text: string; } @Component({ selector: 'joke', template: './joke.template.html', }) export class JokeComponent { @Input() joke: IJoke; }</code> </pre> <br><p>  Misalkan ada komponen yang dijelaskan di atas yang menampilkan teks lelucon dan penulis.  Masalah dengan penulisan ini adalah bahwa Anda dapat secara tidak sengaja atau secara khusus mengubah objek yang ditransfer.  Misalnya, menimpa teks atau penulis. </p><br><pre> <code class="plaintext hljs">setAuthorNameOnly() { const name = this.joke.author.split(' ')[0]; this.joke.author = name; }</code> </pre> <br><p>  Saya segera mencatat bahwa ini adalah contoh yang buruk, tetapi jelas menunjukkan apa yang mungkin terjadi.  Untuk melindungi dari kesalahan tersebut, Anda perlu membuat parameter input hanya-baca.  Berkat ini, Anda akan memiliki pemahaman tentang cara bekerja dengan data dengan benar dan membuat CD.  Berdasarkan ini, cara terbaik untuk menulis kelas akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'joke', template: './joke.template.html', changeDetection: ChangeDetectionStrategy.OnPush, }) export class JokeComponent { @Input() readonly joke: IJoke; @Output() updateName = new EventEmitter&lt;string&gt;(); setAuthorNameOnly() { const name = this.joke.author.split(' ')[0]; this.updateName.emit(name); } }</code> </pre> <br><p>  Pendekatan yang dijelaskan bukan aturan, tetapi hanya rekomendasi.  Ada banyak situasi di mana pendekatan ini tidak nyaman dan tidak efektif.  Seiring waktu, Anda akan belajar untuk memahami dalam hal mana Anda dapat menolak metode yang diusulkan untuk bekerja dengan input. </p><br><h2 id="rxjs">  Rxjs </h2><br><p>  Tentu saja, saya bisa saja salah, tetapi sepertinya ReactiveX dan pemrograman reaktif secara umum adalah tren baru.  Angular menyerah pada tren ini (atau mungkin membuatnya) dan menggunakan RxJS secara default.  Logika dasar dari seluruh kerangka berjalan di perpustakaan ini, sehingga sangat penting untuk memahami prinsip-prinsip pemrograman reaktif. </p><br><p>  Tapi apa itu RxJS?  Ini menggabungkan tiga ide yang akan saya ungkapkan dalam bahasa yang cukup sederhana dengan beberapa kelalaian: </p><br><ul><li>  <em>Pola "Pengamat"</em> adalah entitas yang menghasilkan peristiwa, dan ada pendengar yang menerima informasi tentang peristiwa ini. </li><li>  <em>Pola Iterator</em> - memungkinkan Anda untuk mendapatkan akses berurutan ke elemen-elemen objek tanpa mengungkapkan struktur internalnya. </li><li>  <em>Pemrograman fungsional dengan koleksi</em> adalah pola di mana logika berdetak menjadi komponen kecil dan sangat sederhana, yang masing-masing memecahkan hanya satu masalah. </li></ul><br><p>  Menggabungkan pola-pola ini memungkinkan kita untuk secara sederhana menggambarkan algoritma yang kompleks pada pandangan pertama, misalnya: </p><br><pre> <code class="plaintext hljs">private loadUnreadJokes() { this.showLoader(); //   fromEvent(document, 'load') .pipe( switchMap( () =&gt; this.http .get('/api/v1/jokes') //   .pipe(map((jokes: any[]) =&gt; jokes.filter(joke =&gt; joke.unread))), //   ), ) .subscribe( (jokes: any[]) =&gt; (this.jokes = jokes), //   error =&gt; { /*   */ }, () =&gt; this.hideLoader(), //       ); }</code> </pre> <br><p>  Hanya 18 baris dengan semua lekukan yang indah.  Sekarang cobalah menulis ulang contoh ini pada Vanilla atau setidaknya jQuery.  Hampir 100% dari ini akan membawa Anda setidaknya dua kali lebih banyak ruang dan tidak akan begitu ekspresif.  Di sini Anda cukup mengikuti garis dengan mata Anda dan membaca kode seperti buku. </p><br><h3 id="observable">  Diamati </h3><br><p>  Memahami bahwa data apa pun dapat direpresentasikan sebagai aliran tidak datang dengan segera.  Karena itu, saya mengusulkan untuk pindah ke analogi sederhana.  Bayangkan aliran adalah array data yang diurutkan berdasarkan waktu.  Misalnya, dalam perwujudan ini: </p><br><pre> <code class="plaintext hljs">const observable = []; let counter = 0; const intervalId = setInterval(() =&gt; { observable.push(counter++); }, 1000); setTimeout(() =&gt; { clearInterval(intervalId); }, 6000);</code> </pre> <br><p>  Kami akan menganggap nilai terakhir dalam array relevan.  Setiap detik angka akan ditambahkan ke array.  Bagaimana kita bisa mengetahui di tempat lain dalam aplikasi bahwa elemen telah ditambahkan ke array?  Dalam situasi normal, kita akan memanggil semacam <code>callback</code> dan memperbarui nilai array di atasnya, dan kemudian mengambil elemen terakhir. </p><br><p>  Berkat pemrograman reaktif, tidak perlu tidak hanya menulis banyak logika baru, tetapi juga berpikir tentang memperbarui informasi.  Ini dapat dibandingkan dengan pendengar sederhana: </p><br><pre> <code class="plaintext hljs">document.addEventListener('click', event =&gt; {});</code> </pre> <br><p>  Anda dapat menempatkan banyak <code>EventListener</code> di seluruh aplikasi, dan mereka akan berhasil, kecuali, tentu saja, Anda menangani hal yang berlawanan dengan sengaja. </p><br><p>  Pemrograman reaktif juga berfungsi.  Di satu tempat, kami cukup membuat aliran data dan secara berkala menjatuhkan nilai-nilai baru di sana, dan di tempat lain, kami berlangganan aliran ini dan hanya mendengarkan nilai-nilai ini.  Artinya, kami selalu belajar tentang pembaruan dan dapat mengatasinya. </p><br><p>  Sekarang mari kita lihat contoh nyata: </p><br><pre> <code class="plaintext hljs">export class JokesListComponent implements OnInit { jokes$: Observable&lt;IJoke&gt;; authors$ = new Subject&lt;string[]&gt;(); unread$ = new Subject&lt;number&gt;(); constructor(private jokerService: JokerService) {} ngOnInit() { //  ,    subscribe()    this.jokes$ = this.jokerService.getJokes(); this.jokes$.subscribe(jokes =&gt; { this.authors$.next(jokes.map(joke =&gt; joke.author)); this.unread$.next(jokes.filter(joke =&gt; joke.unread).length); }); } }</code> </pre> <br><p>  Berkat logika ini, ketika mengubah data dalam <code>jokes</code> , kami secara otomatis memperbarui data pada jumlah lelucon yang belum dibaca dan daftar penulis.  Jika Anda memiliki beberapa komponen lagi, salah satunya mengumpulkan statistik tentang jumlah lelucon yang dibaca oleh seorang penulis, dan yang kedua menghitung panjang rata-rata lelucon, maka keuntungannya menjadi jelas. </p><br><h2 id="testbed">  Diuji </h2><br><p>  Cepat atau lambat, pengembang mengerti bahwa jika proyek tersebut bukan MVP, maka Anda perlu menulis tes.  Dan semakin banyak tes yang akan ditulis, semakin jelas dan lebih rinci uraiannya, semakin mudah, lebih cepat, dan lebih dapat diandalkan untuk melakukan perubahan dan menerapkan fungsi baru. </p><br><p>  Angular mungkin meramalkan ini dan memberi kami alat pengujian yang kuat.  Banyak pengembang pada awalnya mencoba untuk menguasai beberapa jenis teknologi "dari awal" tanpa masuk ke dokumentasi.  Saya melakukan hal yang sama, itulah sebabnya saya menyadari sangat terlambat semua kemampuan pengujian tersedia “out of the box”. </p><br><p>  Anda dapat menguji apa pun dalam Angular, tetapi jika Anda hanya perlu instantiate dan mulai memanggil metode untuk menguji kelas atau layanan reguler, situasi dengan komponen benar-benar berbeda. </p><br><p>  Seperti yang sudah kita ketahui, terima kasih kepada dependensi DI yang diambil di luar komponen.  Di satu sisi, ini sedikit menyulitkan seluruh sistem, di sisi lain, ini memberi kita peluang besar untuk melakukan tes dan memeriksa banyak kasus.  Saya mengusulkan untuk memahami contoh komponen: </p><br><pre> <code class="plaintext hljs">@Component({ selector: 'app-joker', template: '&lt;some-dependency&gt;&lt;/some-dependency&gt;', styleUrls: ['./joker.component.less'], }) export class JokerComponent { constructor( private jokesService: JokesService, @Inject(PARTY_TOKEN) private partyService: PartyService, @Optional() private sleepService: SleepService, ) {} makeNewFriend(): IFriend { if (this.sleepService &amp;&amp; this.sleepService.isSleeping) { this.sleepService.wakeUp(); } const joke = this.jokesService.generateNewJoke(); this.partyService.goToParty('Pacha'); this.partyService.toSay(joke.text); const laughingPeople = this.partyService.getPeopleByReaction('laughing'); const girl = laughingPeople.find(human =&gt; human.sex === 'female'); const friend = this.partyService.makeFriend(girl); return friend; } }</code> </pre> <br><p>  Jadi, dalam contoh saat ini ada tiga layanan.  Satu diimpor dengan cara biasa, satu dengan token dan layanan lain bersifat opsional.  Bagaimana cara mengkonfigurasi modul tes?  Saya akan segera menampilkan tampilan yang sudah selesai: </p><br><pre> <code class="plaintext hljs">beforeEach(async(() =&gt; { TestBed.configureTestingModule({ imports: [SomeDependencyModule], declarations: [JokerComponent], //  ,    providers: [{provide: PARTY_TOKEN, useClass: PartyService}], }).compileComponents(); fixture = TestBed.createComponent(JokerComponent); component = fixture.componentInstance; fixture.detectChanges(); //    ,     }));</code> </pre> <br><p>  <code>TestBed</code> memungkinkan kita untuk membuat simulasi lengkap dari modul yang diperlukan.  Anda dapat menghubungkan ke dalamnya layanan apa pun, mengganti modul, mendapatkan instance kelas dari suatu komponen, dan banyak lagi.  Sekarang kita sudah memiliki modul yang sudah dikonfigurasi, mari kita beralih ke kemungkinan. </p><br><h3 id="mozhno-izbegat-lishnih-zavisimostey">  Ketergantungan yang tidak perlu dapat dihindari </h3><br><p>  Aplikasi Angular terdiri dari modul, yang dapat mencakup modul lain, layanan, arahan, dan banyak lagi.  Dalam pengujian, kita perlu, pada kenyataannya, untuk menciptakan kembali operasi modul.  Jika dalam contoh kami, kami menggunakan <code>&lt;some-dependency&gt;&lt;/some-dependency&gt;</code> dalam templat, ini berarti bahwa kami juga harus mengimpor <code>SomeDependencyModule</code> ke dalam pengujian.  Dan apakah ada kecanduan di sana?  Jadi, mereka juga perlu diimpor. <br>  Jika aplikasi ini rumit, akan ada banyak dependensi seperti itu.  Mengimpor semua dependensi akan mengarah pada fakta bahwa dalam setiap pengujian seluruh aplikasi akan ditemukan dan semua metode akan dipanggil.  Mungkin ini tidak cocok untuk kita. </p><br><p>  Setidaknya ada satu cara untuk menghilangkan dependensi yang diperlukan - cukup tulis ulang template.  Misalkan Anda memiliki pengujian tangkapan layar atau pengujian integrasi dan tidak perlu menguji penampilan komponen.  Maka itu cukup dengan hanya memeriksa metode.  Dalam hal ini, Anda dapat menulis konfigurasi sebagai berikut: </p><br><pre> <code class="plaintext hljs">TestBed.configureTestingModule({ declarations: [JokerComponent], providers: [{provide: PARTY_TOKEN, useClass: PartyService}], }) .overrideTemplate(JokerComponent, '') //   ,   .compileComponents();</code> </pre> <br><p> ,    .           ,      . ,          .    ,       , ,    ,     .        —    . </p><br><h3 id="mozhno-mokirovat-vse-zavisimosti-iz-konstruktora">       </h3><br><p>     <em>Injection Token</em> ,      .           .      ,       ,   . </p><br><p>        <code>ts-mockito</code> ,     ,    . Angular    « ». </p><br><pre> <code class="plaintext hljs">//    export class MockPartyService extends PartyService { meetFriend(): IFriend { return {} as IFriend; } goToParty() {} toSay(some: string) { console.log(some); } } // ... TestBed.configureTestingModule({ declarations: [JokerComponent, MockComponent], providers: [{provide: PARTY_TOKEN, useClass: MockPartyService}], //    }).compileComponents();</code> </pre> <br><p>  Itu saja.         . </p><br><h3 id="mnozhestvo-keysov">   </h3><br><p>       .    ,  —  ,   — . ,              : </p><br><ul><li>          . </li><li>      — ,      .    —    . </li></ul><br><p>  —       .          ,          .   —     . </p><br><h2 id="itog">  Ringkasan </h2><br><p>       Angular,           .     ,   ,        «». </p><br><p>      , Angular       - .    HTTP-, , lazy-loading  .            <a href="https://angular.io/docs"> Angular</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480782/">https://habr.com/ru/post/id480782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480772/index.html">Alasan sederhana untuk tidak terhindarkannya hutang teknis</a></li>
<li><a href="../id480774/index.html">Tidak nginx bersatu: Ayhor hosting - dash-scratch live</a></li>
<li><a href="../id480776/index.html">Kami menggunakan Active Directory dengan semua metode yang memungkinkan.</a></li>
<li><a href="../id480778/index.html">Manajemen gerakan: Menangani overlay visual. Bagian 2</a></li>
<li><a href="../id480780/index.html">Cara menyusun ilustrasi dari kubus dan piktogram</a></li>
<li><a href="../id480786/index.html">Kloning objek independen dalam JavaScript</a></li>
<li><a href="../id480788/index.html">Pohon Natal di baris perintah</a></li>
<li><a href="../id480790/index.html">"Efisiensi pabrik". Menemukan hambatan dan menerapkan sistem tarikan untuk meningkatkan produktivitas</a></li>
<li><a href="../id480792/index.html">Rekayasa Hadiah</a></li>
<li><a href="../id480794/index.html">Sedikit tentang kasus khusus implementasi algoritma pencarian pintu terbuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>