<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏿 👈🏾 👨🏾‍🤝‍👨🏽 L'informatique quantique dans les jeux, ou devenir fou au sérieux 🤽🏿 ✨ 🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous vivez parmi les fous, vous devez apprendre à être fou vous-même 

 Avez-vous déjà essayé "d'apprendre à être fou"? Tâche non triviale. Vous ne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'informatique quantique dans les jeux, ou devenir fou au sérieux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437352/">  <i>Si vous vivez parmi les fous, vous devez apprendre à être fou vous-même</i> <br><br>  Avez-vous déjà essayé "d'apprendre à être fou"?  Tâche non triviale.  Vous ne trouverez même pas une technique normale, car tout le monde devient fou à sa manière.  Ma première tentative: la théorie du complot.  La théorie n'implique pas la pratique, ce qui signifie que vous n'avez pas à travailler dur.  Encore une fois, dans n'importe quelle situation, personne ne souffrira. <br><br><div class="spoiler">  <b class="spoiler_title">Comment créer des théories du complot?</b> <div class="spoiler_text">  Créer une théorie du complot est relativement simple.  Nous avons besoin d'une idée suffisamment simple pour être acceptée par 90% de la population.  Cela devrait être controversé pour que 5% de la population puisse expliquer à 90% quels idiots ils sont.  Enfin, nous avons besoin de recherches que ces 95% de personnes ne comprennent pas, mais qui sont utilisées par 90% comme argument "les gens se sont montrés plus intelligents que nous ...". <br><br>  L'informatique quantique est un grand domaine pour une telle étude.  Vous pouvez regrouper un schéma simple, mais le mot «quantique» ajoutera du poids aux résultats. <br><br>  L'objet d'étude est un jeu, car l'objet est dû à la jeunesse simple et familière.  Qui est impliqué dans l'informatique quantique et les jeux?  Google <br></div></div><br>  Donc, théorie hérétique: après 5 ans, Page et Green décideront qui sera l'élément principal de Google, et ils le feront à l'aide du jeu.  Chacun d'eux a un groupe de chercheurs.  L'équipe AlphaGo avec ses réseaux de neurones de <s>combat a</s> attiré des rivaux à Go.  Les opposants ont été contraints de chercher de nouvelles méthodes et ont tout de même trouvé un instrument de supériorité <s>totale</s> : l'informatique quantique. <br><br>  Puis-je utiliser l'informatique quantique pour les jeux?  C'est facile.  Montrons par exemple que le jeu "fox hunter" peut être "résolu" en 6 coups.  Pour des raisons de crédibilité, nous nous limitons à 15 qubits (l'éditeur en ligne quirk n'émule pas plus de quinze), pour des raisons de simplicité, nous ignorons les limites de l'architecture du processeur et la correction des erreurs. <br><a name="habracut"></a><br><h3>  Les règles </h3><br>  Extrêmement simple.  <i>Il y a cinq trous disposés dans une rangée (nous les numérotons comme 0-1-2-3-4).</i>  <i>Dans l'un d'eux est un renard.</i>  <i>Chaque nuit, le renard se déplace vers le vison suivant à gauche ou à droite.</i>  <i>Chaque matin, le chasseur peut cocher un trou au choix.</i>  <i>La tâche du chasseur est d'attraper le renard.</i>  <i>La tâche du renard est de survivre.</i>  En théorie, un renard peut fuir un chasseur pour toujours.  En pratique, il y a une stratégie gagnante: vérifier les trous 1-2-3-1-2-3.  Seule cette stratégie sera testée. <br><br><h3>  Construire un schéma </h3><br>  Commençons par l'initiation des qubits 0-1-2-3-4 (5 trous).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici vous pouvez éditer</a> <br><img src="https://habrastorage.org/webt/jc/o3/-g/jco3-geebiz5bpjtpur3gvcctxm.png"><br><br>  En fait, après l'initiation, nous avons un système dans lequel, après la mesure, strictement un qubit sera unique.  Les probabilités d '«unité» diffèrent pour chaque qubit, mais dans notre cas, ce n'est pas critique.  Nous devons laisser la place à la discussion du schéma (et de notre théorie en même temps). <br><br>  Sur Q #, nous obtenons un code comme celui-ci: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history InitFoxHoles(qubits); ResetAll(qubits); // ALWAYS clean after yourself } return Zero; } // Inits fox holes, with almost equal probabilities operation InitFoxHoles(register: Qubit[]) : Unit { body { ResetAll(register); // Step 1 H(register[0]); H(register[2]); // Step 2 (Controlled (X))([register[0],register[2]], register[3]); // Step 3 X(register[0]); X(register[2]); (Controlled (X))([register[0],register[2]], register[3]); X(register[0]); X(register[2]); // Step 4 CNOT(register[3], register[0]); CNOT(register[3], register[2]); // Step 5 (Controlled (H))([register[3]], register[4]); // Step 6 CNOT(register[4], register[3]); } }</span></span></code> </pre> <br>  TestStrategy testera notre stratégie 1-2-3-1-2-3, InitFoxHoles () est uniquement responsable de l'initiation des trous de renard.  Vérifions l'initiation.  Copiez TestStrategy, démarrez l'initiation, mesurez les 5 premiers qubits et renvoyez leurs valeurs. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result, Result, Result, Result, Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history InitFoxHoles(qubits); set res0 = M(qubits[0]); set res1 = M(qubits[1]); set res2 = M(qubits[2]); set res3 = M(qubits[3]); set res4 = M(qubits[4]); ResetAll(qubits); // ALWAYS clean after yourself } return (res0, res1, res2, res3, res4); } }</span></span></code> </pre> <br>  Nous exécuterons le test mille fois (plusieurs exécutions sont typiques des algorithmes quantiques, parfois même nécessaires).  Code d'appel - sous le spoiler, résultats: sur l'écran ci-dessous. <br><br><div class="spoiler">  <b class="spoiler_title">Tester rapidement l'initiation</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInitiation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initedQubitsValues = Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .ToDictionary(qubitIndex =&gt; qubitIndex, oneMesaured =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result) result = TestInit.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">0</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">1</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">2</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">3</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">4</span></span>]++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-0 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-1 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-2 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-3 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-4 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">4</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/fb/oa/bs/fboabsw9fsu64gh7bl9a8mofh_y.png"><br><br>  Quelque chose a mal tourné.  Une distribution presque uniforme était attendue.  La raison est simple: à l'étape 3, j'ai inversé le troisième qubit, au lieu du premier: (Contrôlé (X)) ([registre [0], registre [2]], registre [3]);  <s>pas</s> bon vieux copier-coller. <br><br>  Nous corrigeons le code, exécutons le test: <br><br><div class="spoiler">  <b class="spoiler_title">Initiation corrigée</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Inits fox holes, with almost equal probabilities operation InitFoxHoles(register: Qubit[]) : Unit { body { ResetAll(register); // Step 1 H(register[0]); H(register[2]); // Step 2 (Controlled (X))([register[0],register[2]], register[3]); // Step 3 X(register[0]); X(register[2]); (Controlled (X))([register[0],register[2]], register[1]); X(register[0]); X(register[2]); // Step 4 CNOT(register[3], register[0]); CNOT(register[3], register[2]); // Step 5 (Controlled (H))([register[3]], register[4]); // Step 6 CNOT(register[4], register[3]); } } }</span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/06/q2/7b/06q27bfcca3-udvpnaarut9zmhi.png"><br><br>  Déjà mieux.  Le code peut être vu dans le navet, version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Commit 1</a> . <br><br><h3>  Où faire courir le renard? </h3><br>  Sélectionnez le cinquième qubit (la numérotation commence par le haut) sous la direction actuelle du renard.  Nous convenons que zéro signifie un mouvement vers le bas, une unité signifie un mouvement vers le haut.  Évidemment, si le renard est déjà dans le trou zéro - il devrait descendre.  Si le renard est dans le quatrième trou, il remonte.  Dans d'autres cas, le renard peut monter et descendre.  Selon ces règles simples, nous pouvons définir le «qubit de la direction actuelle» à 0, 1, ou une superposition de zéro et un.  Nous regardons le code dans le référentiel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Commit 2</a> . <br><br><img src="https://habrastorage.org/webt/dr/tg/zd/drtgzd1c2y9jyb0n7zwrxp5qg2c.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Schéma dans l'éditeur.</a> <br><br><div class="spoiler">  <b class="spoiler_title">Code et test</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Select next Fox movement direction, updating qubit 5 // 1 means go up (4 -&gt; 3, 3 -&gt; 2, ... 1 -&gt; 0) // 0 means go down (0 -&gt; 1, 1 -&gt; 2, ... 3 -&gt; 4) operation SetupMovementDirection(qubits: Qubit[]) : Unit { body { // Step 1 CNOT(qubits[4], qubits[5]); // Step 2 (Controlled (H))([qubits[3]], qubits[5]); // Step 3 (Controlled (H))([qubits[2]], qubits[5]); // Step 4 (Controlled (H))([qubits[1]], qubits[5]); } } operation TestMovementDirectionSetup(): (Result, Result, Result, Result, Result, Result) { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; mutable res5 = Zero; using(qubits=Qubit[16]) { InitFoxHoles(qubits); SetupMovementDirection(qubits); set res0 = M(qubits[0]); set res1 = M(qubits[1]); set res2 = M(qubits[2]); set res3 = M(qubits[3]); set res4 = M(qubits[4]); set res5 = M(qubits[5]); ResetAll(qubits); // ALWAYS clean after yourself } return (res0, res1, res2, res3, res4, res5); } }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMovementDirectionSetup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> initedCubit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> moveDirection = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result, Result) result = Quantum.FoxHunter.TestMovementDirectionSetup.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"2"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"3"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"4"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item6 == Result.One) { moveDirection = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveDirection = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } results.Add(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedCubit}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{moveDirection}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results .GroupBy(result =&gt; result) .OrderBy(<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>.Key)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">group</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.Key}</span></span></span><span class="hljs-string"> was measured </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">group</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.Count()}</span></span></span><span class="hljs-string"> times"</span></span>); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"\r\nTotal measures: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{results.Count()}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre><br><br><img src="https://habrastorage.org/webt/1a/oa/vm/1aoavmvs9hscf8gywpbgfpbdpiq.png"><br></div></div><br><br><h3>  Mouvement </h3>  Implémenté par SWAP contrôlé.  Si le qubit de contrôle est unique, permutez vers le bas.  Si le qubit de contrôle est nul, nous échangeons. <br><br><img src="https://habrastorage.org/webt/zs/n8/os/zsn8osjcozts2nip6lbunqjcg_w.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Schéma dans l'éditeur</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Opérateur Q #</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Makes a movement based on the 5'th qubit value // 1 means go up (4 -&gt; 3, 3 -&gt; 2, ... 1 -&gt; 0) // 0 means go down (0 -&gt; 1, 1 -&gt; 2, ... 3 -&gt; 4) operation MakeMovement(qubits: Qubit[]) : Unit { body { // Code movement Up // Step 1 mutable qubitsToSwap = [qubits[0], qubits[1]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 2 set qubitsToSwap = [qubits[1], qubits[2]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 3 set qubitsToSwap = [qubits[2], qubits[3]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 4 set qubitsToSwap = [qubits[3], qubits[4]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // COde movement down X(qubits[5]); // Invert direction qubit for the ZeroControlled operations // Step 5 set qubitsToSwap = [qubits[3], qubits[4]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 6 set qubitsToSwap = [qubits[2], qubits[3]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 7 set qubitsToSwap = [qubits[1], qubits[2]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 8 set qubitsToSwap = [qubits[0], qubits[1]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); X(qubits[5]); // Back-invert for the direction qubit } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Q #: instruction pour les tests</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFirstMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result, Result, Result, Result, Result, Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; mutable res5 = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { InitFoxHoles(qubits); SetupMovementDirection(qubits); MakeMovement(qubits); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res0 = M(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res1 = M(qubits[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res2 = M(qubits[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res3 = M(qubits[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res4 = M(qubits[<span class="hljs-number"><span class="hljs-number">4</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res5 = M(qubits[<span class="hljs-number"><span class="hljs-number">5</span></span>]); ResetAll(qubits); <span class="hljs-comment"><span class="hljs-comment">// ALWAYS clean after yourself } return (res0, res1, res2, res3, res4, res5); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Code C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFirstMove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> initedCubit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> moveDirection = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result, Result) result = Quantum.FoxHunter.TestFirstMovement.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"2"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"3"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"4"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item6 == Result.One) { moveDirection = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveDirection = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } results.Add(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedCubit}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{moveDirection}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// Holes measurements foreach (var group in results .GroupBy(result =&gt; result[0]) .OrderBy(group =&gt; group.Key)) { Console.WriteLine($"{group.Key} hole was measured {group.Count()} times"); } // Directions measuremetns foreach (var group in results .GroupBy(result =&gt; result[1]) .OrderBy(group =&gt; group.Key)) { Console.WriteLine($"{group.Key} direction was measured {group.Count()} times"); } Console.WriteLine($"\r\nTotal measures: {results.Count()}"); } }</span></span></code> </pre> <br></div></div><br>  Le code peut être consulté dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Commit 3</a> . <br><br><h3>  Nous faisons 6 mouvements </h3><br>  Enfin, nous sélectionnons le sixième qubit pour l'état du jeu (le renard est libre / le renard n'est pas libre).  L'unité correspond à un renard libre.  Nous n'effectuerons de nouveaux déplacements qu'avec un seul qubit de statut. <br><br>  Les qubits 7,8,9,10,11 conserveront un historique des mouvements.  Après chaque mouvement, nous allons échanger l'un d'eux avec un qubit de la direction actuelle (cela nous permettra de stocker l'historique des mouvements et de réinitialiser le qubit de la direction actuelle avant chaque mouvement). <br><img src="https://habrastorage.org/webt/a0/1t/_t/a01t_t8jo_9nt9w1nimamxrd-i0.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Schéma ci-joint</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Opérateur Q #</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Make 6 movements. Every movement is controlled by the 6'th qubit. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> After the every qubit we check if the fox has been captured and invert the 6'th qubit </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Reminder: 6'th qubit equal to One means "Fox is free, go further" operation MakeSixMovements(qubits: Qubit[]) : Unit { body { // Move 1 (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Reverse Fox State if it's shot // Move 2 SwapReverseRegister([qubits[5], qubits[7]]); // Move the first move direction to the qubit 7, qubit 5 is Zero again (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 3 SwapReverseRegister([qubits[5], qubits[8]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); // Move 4 SwapReverseRegister([qubits[5], qubits[9]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Move 5 SwapReverseRegister([qubits[5], qubits[10]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 6 SwapReverseRegister([qubits[5], qubits[11]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Q #: instruction pour les tests</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSixMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { ResetAll(qubits); InitFoxHoles(qubits); X(qubits[<span class="hljs-number"><span class="hljs-number">6</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// At the beginning of the game our fox is alive MakeSixMovements(qubits); set res = M(qubits[6]); ResetAll(qubits); // ALWAYS clean after yourself } return (res); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C #: test</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zerosCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { Result result = Quantum.FoxHunter.TestSixMovements.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result == Result.Zero) { zerosCount++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"\r\nTotal zeroes: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{zerosCount}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br></div></div><br>  Nous regardons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Commit 4</a> . <br><br><h3>  Touche finale </h3><br>  Nous avons une erreur dans le circuit.  Puisque nous testons la stratégie 1-2-3-1-2-3, nous vérifions chaque trou deux fois.  En conséquence, après avoir attrapé le renard au premier mouvement, nous allons passer par le qubit de statut deux fois (au premier mouvement et au quatrième). <br><br>  Pour éviter cette situation, nous utilisons 12 qubits pour corriger l'état après les mouvements 4-5-6.  De plus, nous ajoutons la définition de la victoire: si au moins l'un des qubits de statut devient nul, nous gagnons. <br><img src="https://habrastorage.org/webt/cs/pc/ug/cspcugcnyqdranjm_lifypt2evc.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le schéma final</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Q #: correction de l'opérateur 6 mouvements</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeSixMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">qubits: Qubit[]</span></span></span><span class="hljs-function">) : Unit</span></span> { body { <span class="hljs-comment"><span class="hljs-comment">// Move 1 (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Reverse Fox State if it's shot // Move 2 SwapReverseRegister([qubits[5], qubits[7]]); // Move the first move direction to the qubit 7, qubit 5 is Zero again (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 3 SwapReverseRegister([qubits[5], qubits[8]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); // Move 4 SwapReverseRegister([qubits[5], qubits[9]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[1], qubits[12]); // Move 5 SwapReverseRegister([qubits[5], qubits[10]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[2], qubits[12]); // Move 6 SwapReverseRegister([qubits[5], qubits[11]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[3], qubits[12]); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Q #: correction de la stratégie de test des opérateurs 1-2-3-1-2-3</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history // 12 - another qubit of the fox live. 1 means "fox is still free, go further" // 13 Result qubit. If it's zero, the fox is alive body { mutable res = Zero; using(qubits=Qubit[14]) { ResetAll(qubits); // Init fox positions and the fox' live InitFoxHoles(qubits); X(qubits[6]); // At the beginning of the game our fox is alive X(qubits[12]); // The second qubit of the fox live. If it's one - the fox is alive. // Make moves MakeSixMovements(qubits); // Measure results. If the 13'th qubit is zero the fox is alive X(qubits[6]); X(qubits[12]); CNOT(qubits[6], qubits[13]); CNOT(qubits[12], qubits[13]); CCNOT(qubits[6], qubits[12], qubits[13]); set res = M(qubits[13]); ResetAll(qubits); // ALWAYS clean after yourself } return (res); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C #: exécuter la vérification finale</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunFoxHunt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foxSurvives = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hunterWins = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = (Result)(TestStrategy.Run(sim).Result); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == Result.Zero) { foxSurvives++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hunterWins++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Fox survives: \t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{foxSurvives}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Hunter wins: \t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{hunterWins}</span></span></span><span class="hljs-string">"</span></span>); } sw.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Experiment finished. "</span></span> + <span class="hljs-string"><span class="hljs-string">$"Time spent: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1000</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> seconds"</span></span>); }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/qm/pr/a3/qmpra3x-ticzuunfcmlsl_8atnk.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Valider 5</a> . <br><br><h3>  Ce qui en découle </h3><br>  En principe, le schéma peut être optimisé à la fois en nombre de qubits et en nombre d'opérations.  L'optimisation triviale du nombre de qubits consiste à se débarrasser de qubit-13, renvoyant seulement 6 et 12. Optimisation par opérations - pour faire le premier tir immédiatement après l'initiation.  Cependant, laissons ce travail aux ingénieurs de Google. <br><br>  Comme vous pouvez le voir, quiconque est superficiellement familier avec l'informatique quantique peut jouer en toute sécurité le "chasseur de renards".  Si nous avions un peu plus de qubits, nous pourrions trouver la solution optimale et ne pas vérifier la solution existante.  Il est tout à fait possible que le tic-tac-toe (et leur version quantique), les dames, les échecs, Go tombent ensuite. <br><br>  Dans le même temps, la question de la «solvabilité» de jeux comme DotA, Starcraft et Doom reste ouverte.  L'informatique quantique se caractérise par le stockage de l'historique complet des clics.  Nous prenons APM (Actions par minute) de 500, multiplions par le nombre de joueurs, multiplions par le nombre de minutes, ajoutons le caractère aléatoire du jeu lui-même - le nombre de qubits requis pour stocker toutes les informations augmente trop rapidement. <br><br>  Ainsi, choisir un jeu dans une petite compétition entre Brin et Page peut jouer un rôle décisif.  Cependant, la génération d'un jeu «tout aussi difficile» pour les ordinateurs classiques et quantiques mérite sa propre théorie. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437352/">https://habr.com/ru/post/fr437352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437342/index.html">Comment choisir une plateforme de vidéosurveillance: Cloud vs DVR / NVR / VMS</a></li>
<li><a href="../fr437344/index.html">Cas d'utilisation des solutions de visibilité réseau</a></li>
<li><a href="../fr437346/index.html">Un jeu (pas) pour les imbéciles. Nous écrivons l'IA pour "The Fool" (partie 1)</a></li>
<li><a href="../fr437348/index.html">Augmentez la productivité sur GitHub: conseils pour les débutants et plus</a></li>
<li><a href="../fr437350/index.html">Une voiture à l'ère de la multifonctionnalité. Quelles conversions sont possibles?</a></li>
<li><a href="../fr437354/index.html">Affaiblir les noix, partie 2: la période de vote pour les publications et autres changements</a></li>
<li><a href="../fr437356/index.html">Qu'est-il arrivé au SSD en 2018</a></li>
<li><a href="../fr437358/index.html">Gestion de la compatibilité des produits</a></li>
<li><a href="../fr437360/index.html">Téléchargement de contrôleurs sans utiliser de console Arduino IDE</a></li>
<li><a href="../fr437364/index.html">Le contrôle de Tele2 coûtera à Rostelecom 240 milliards de roubles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>