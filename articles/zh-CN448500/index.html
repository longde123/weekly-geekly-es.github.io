<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤺 👭 🆖 为Sega Mega Drive解决一个简单的Crackme 🙏🏼 👩🏽 🧗🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好 





尽管我在Sega Mega Drive倒车游戏方面拥有丰富的经验，但我从未决定要破解它，并且它们并没有在Internet上出现。 但是，前几天有一个有趣的饼干想解决。 我同意你的决定... 
 内容描述 


 任务说明和朗姆酒本身可以在此处下载 。 


 尽管资源清单上有Hy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>为Sega Mega Drive解决一个简单的Crackme</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448500/"><p> 大家好 </p><br><p><img src="https://habrastorage.org/webt/nk/ln/db/nklndblpn-preue7wy68pyj3c98.gif"></p><br><p>尽管我在<code>Sega Mega Drive</code>倒车游戏方面拥有丰富的经验，但我从未决定要破解它，并且它们并没有在Internet上出现。 但是，前几天有一个有趣的饼干想解决。 我同意你的决定... <a name="habracut"></a></p><br><h2 id="opisanie"> 内容描述 </h2><br><p> 任务说明和朗姆酒本身可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">此处下载</a> 。 </p><br><p> 尽管资源清单上有Hydra的事实，但<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Sega Ida Tools</a>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Sega</a>上用于调试和反转游戏的工具中的标准事实。 它具有解决此奶油所需的一切： </p><br><ul><li> 朗达朗姆酒装载机 </li><li> 调试器 </li><li> 查看和更改RAM / VDP内存 </li><li> 在VDP上显示几乎完整的信息 </li></ul><br><p> 我们将最新版本放到Ide的插件中，然后开始看看我们拥有什么。 </p><br><h2 id="reshenie"> 解决方案 </h2><br><p> 任何Shogi游戏的发布都始于执行<code>Reset</code>向量。 从朗姆酒开头的第二个DWORD中可以找到指向它的指针。 </p><br><p><img src="https://habrastorage.org/webt/fa/6z/9i/fa6z9iin5fkmohq7xh8v8drs9vy.png"></p><br><p><img src="https://habrastorage.org/webt/hx/p-/g1/hxp-g1qdzxt0dgiw52xmngr4two.png"></p><br><p> 我们看到了一些从地址<code>0x27A</code>开始的身份不明的函数。 让我们看看那里有什么。 </p><br><h3 id="sub_2ea">  sub_2EA（） </h3><br><p><img src="https://habrastorage.org/webt/uq/jb/on/uqjbonknltijbascror2nutymey.png"></p><br><p> 根据我自己的经验，我会说这通常看起来像等待<code>VBLANK</code>中断完成的功能。 让我们看看在哪里还有对<code>byte_FF0026</code>变量的调用： </p><br><p><img src="https://habrastorage.org/webt/-l/vf/fk/-lvffkgtxhng4fqfudhrquvrple.png"></p><br><p> 我们看到零位只是在<code>VBLANK</code>中断中设置的。 因此，我们将变量<code>vblank_ready</code> ，检查该变量的函数为<code>wait_for_vblank</code> 。 </p><br><h3 id="sub_60e">  sub_60E（） </h3><br><p> 接下来，通过代码调用<code>sub_60E</code>函数。 让我们看看那里是什么： </p><br><p><img src="https://habrastorage.org/webt/75/ly/-t/75ly-ttb7wf5tmesip19y13lsdm.png"></p><br><p> 第一条命令写入<code>VDP_CTRL</code>就是<code>VDP</code>控制命令。 要了解她在做什么，我们站在此命令上并按<code>J</code>键： </p><br><p><img src="https://habrastorage.org/webt/5i/k9/vx/5ik9vx8gfpxa3l1v6z30y8qvjbg.png"></p><br><p> 我们看到<code>CRAM</code> （存储调色板的位置）中的条目已初始化。 这意味着所有后续功能代码都仅设置了某种初始调色板。 因此，该函数可以称为<code>init_cram</code> 。 </p><br><h3 id="sub_71a">  sub_71A（） </h3><br><p><img src="https://habrastorage.org/webt/bn/q4/8l/bnq48l58l4kkamx9q_14q2fpvke.png"></p><br><p> 我们看到一些命令再次传输到<code>VDP_CTRL</code> ，然后再次按<code>J</code>并发现此命令初始化了视频内存中的记录： </p><br><p><img src="https://habrastorage.org/webt/ta/no/y-/tanoy-xupd7d8e_tc3hcyvsveqw.png"></p><br><p> 此外，要了解在那里传输到视频存储器的内容没有任何意义。 因此，我们只需调用函数<code>load_vdp_data</code> 。 </p><br><h3 id="sub_c60">  sub_C60（） </h3><br><p> 这里几乎发生与上一个函数相同的事情，因此，在不赘述的情况下，我们仅调用<code>load_vdp_data2</code>函数。 </p><br><h3 id="sub_8da">  sub_8DA（） </h3><br><p> 已经有更多的代码。 此外，该函数还调用了另一个函数。 让我们看一下-在<code>sub_D08</code> 。 </p><br><h4 id="sub_d08">  sub_D08（） </h4><br><p><img src="https://habrastorage.org/webt/5a/y3/du/5ay3du514ne0gmrqxhns5em-z9g.png"></p><br><p> 我们看到在寄存器<code>D0</code>了<code>VDP_CTRL</code> <code>D0</code>命令，在<code>D1</code> <code>VDP_CTRL</code>将填充的值，在<code>D2</code>和<code>D3</code> -填充的宽度和高度（因为结果是两个周期：内部和外部）。 调用fill_vram_by_addr函数。 </p><br><h3 id="sub_8da-1">  sub_8DA（） </h3><br><p> 我们返回上一个功能。 将<code>D0</code>寄存器中的值作为<code>VDP_CTRL</code>的命令发送<code>VDP_CTRL</code> ，请按该值上的<code>J</code>键。 我们得到： </p><br><p><img src="https://habrastorage.org/webt/hf/7s/rv/hf7srvlttesquvkffg504tnagpm.png"></p><br><p> 再次，从将游戏转换为Sega的经验来看，我可以说此命令初始化了映射图块的记录。 在90％的情况下， <code>$Dxxx</code> <code>$Fxxx</code> ， <code>$Exxx</code> ， <code>$Dxxx</code> ， <code>$Dxxx</code>地址将是具有这些相同映射的区域的地址。 什么是映射： <br> 这些是您可以指定在屏幕上的何处显示或该图块的值（图块是<code>8x8</code>像素的正方形）。 </p><br><p> 因此该函数可以称为<code>init_tile_mappings</code> 。 </p><br><h3 id="sub_cdc">  sub_CDC（） </h3><br><p><img src="https://habrastorage.org/webt/yj/qn/xd/yjqnxdamdbrodnxbxpwfnhwun6k.png"></p><br><p> 第一条命令在地址<code>$F000</code>处初始化记录。 一个注意事项：在“ <em>映射</em> ”的地址中，仍然存在一个存储精灵表的区域（这些区域是它们的位置，它们指向的图块等）。找出哪个区域负责可调试的内容。 但是现在，我们不需要此功能，因此我们只需调用函数<code>init_other_mappings</code> 。 </p><br><p> 此外，我们看到在此函数中初始化了两个变量： <code>word_FF000A</code>和<code>word_FF000C</code> 。 根据我的经验（是的，他决定），我会说，如果在地址空间中有两个变量与映射相关联，那么在大多数情况下，它们将是某个对象（例如，精灵）的坐标。 因此，我建议称它们为<code>sprite_pos_x</code>和<code>sprite_pos_y</code> 。  <code>x</code>和<code>y</code>的误差<code>y</code>允许的，因为 进一步调试，将很容易修复。 </p><br><h2 id="vblank">  VBLANK </h2><br><p> 由于循环在代码中进行得更远，因此我们可以假设我们已经完成了基本初始化。 现在您可以查看<code>VBLANK</code>中断。 </p><br><p><img src="https://habrastorage.org/webt/of/vd/3a/ofvd3ajtvedulgj6neviw_ynidw.png"></p><br><p> 我们看到两个变量正在递增（这很奇怪，在每个变量的链接列表中，它绝对是空的）。 但是，由于它们每帧更新一次，因此可以将它们称为<code>timer1</code>和<code>timer2</code> 。 </p><br><p> 接下来， <code>sub_2FE</code>函数。 让我们看看那里是什么： </p><br><h3 id="sub_2fe">  sub_2FE（） </h3><br><p><img src="https://habrastorage.org/webt/dl/i0/zn/dli0zn0zzns8ue4t9632kszcbca.png"></p><br><p> 在那里-使用<code>IO_CT1_DATA</code>端口（负责第一个操纵杆）。 端口地址被加载到寄存器<code>A0</code> ，并传递给<code>sub_310</code>函数。 我们去那里： </p><br><h4 id="sub_310">  sub_310（） </h4><br><p><img src="https://habrastorage.org/webt/do/n9/jl/don9jltuiqzuw-xg1klhngrmcbg.png"></p><br><p> 我的经验再次帮助了我。 如果您看到适用于操纵杆的代码以及内存中的两个变量，则其中一个会存储<code>pressed keys</code> ，第二个会存储<code>held keys</code> ，即 只需按住键即可。 因此，我们将这些变量称为： <code>pressed_keys</code>和<code>held_keys</code> 。 然后该函数可以称为<code>update_joypad_state</code> 。 </p><br><h3 id="sub_2fe-1">  sub_2FE（） </h3><br><p> 将该函数称为<code>read_joypad</code> 。 </p><br><h2 id="cikl-obrabotchika"> 处理程序循环 </h2><br><p> 现在，一切看起来都更加清晰了： </p><br><p><img src="https://habrastorage.org/webt/zy/tv/9k/zytv9kt67reri1ncyx2ic62vdoe.png"></p><br><p> 因此，此循环响应所按下的键，并执行相应的操作。 让我们遍历循环中调用的每个函数。 </p><br><h3 id="sub_4d4">  sub_4D4（） </h3><br><p><img src="https://habrastorage.org/webt/w4/8j/le/w48jlep4xhckziprf9-lxhpy36s.png"></p><br><p> 有很多代码。 让我们从第一个函数<code>sub_60C</code> 。 </p><br><h4 id="sub_60c">  sub_60C（） </h4><br><p> 她什么也没做-乍看起来似乎是这样。 只是从当前函数返回的是<code>rts</code> 。 但是，因为 仅在其上发生跳转（ <code>bsr</code> ），这意味着<code>rts</code>将使我们返回到处理程序循环。 我将此函数称为<code>retn_to_loop</code> 。 </p><br><h3 id="sub_4d4-1">  sub_4D4（） </h3><br><p> 接下来，我们看到对<code>word_FF000E</code>变量的调用。 除了当前功能以外，没有在其他任何地方使用它，起初，我的目的并不明确。 但是，如果您仔细观察，我们可以假设仅在按键处理之间有很小的延迟才需要此变量。  （ <em>在本次朗姆酒中，它的实施效果很差，但是，我认为，如果没有此变量，情况将会更糟</em> ）。 </p><br><p><img src="https://habrastorage.org/webt/uz/s9/vz/uzs9vzbt_i6qy-fudyxdmrac-am.png"></p><br><p> 接下来，我们有大量的代码以某种方式处理<code>sprite_pos_x</code>和<code>sprite_pos_y</code> ，这些<code>sprite_pos_y</code>只能说一句话-这对于在字母中所选字符周围显示选择精灵是必须的。 </p><br><p> 因此，现在您可以安全地将函数命名为<code>update_selection</code> 。 让我们继续前进。 </p><br><p><img src="https://habrastorage.org/webt/xd/ng/lv/xdnglvnasqphjlqa02sf35kwsse.png"></p><br><p> 该代码检查某些按键的位是否已设置，并调用某些功能。 让我们看看它们。 </p><br><h4 id="sub_d28">  sub_D28（） </h4><br><p><img src="https://habrastorage.org/webt/ct/os/xa/ctosxa-j_4h-pqzqh0sqrqzywek.png"></p><br><p> 某种萨满魔术。 首先，从<code>word_FF0018</code>变量中提取<code>WORD</code> ，然后执行一条有趣的指令： </p><br><pre> <code class="dos hljs">bsr.w *+<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p> 该命令只是跳转到其后的指令。 </p><br><p> 接下来是另一个魔术： </p><br><pre> <code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">move</span></span>.l d0,(sp) rts</code> </pre> <br><p> 寄存器<code>D0</code>的值位于堆栈的顶部。 值得注意的是，对于Shogi以及某些<code>x86</code> ，函数调用时的返回地址都放在堆栈的顶部。 因此，第一个指令将某个地址放在顶部，第二个指令将其从堆栈中移出并沿其过渡。  <u>好招</u> 。 </p><br><p> 现在，您需要了解此值在变量中的含义，然后进行检查。 但是首先，我们将其称为<code>jmp_addr</code>变量。 </p><br><p> 这些函数将称为： </p><br><ul><li>  <code>sub_D38</code> ： <code>goto_to_d0</code> </li><li>  <code>sub_D28</code> ： <code>jump_to_var_addr</code> </li></ul><br><h3 id="jmp_addr">  jmp_addr </h3><br><p> 找出该变量的填充位置。 我们看一下参考文献清单： </p><br><p><img src="https://habrastorage.org/webt/hn/uo/jl/hnuojlnhvgflvbd369lwlnhwlr0.png"></p><br><p> 只有一个地方可以写入此变量。 让我们看看他。 </p><br><h4 id="sub_3a4">  sub_3A4（） </h4><br><p><img src="https://habrastorage.org/webt/tw/bv/oe/twbvoexaffcrvzhk4vxrhrumtem.png"></p><br><p> 在此，根据子画面的坐标（请记住，这很可能是所选字符的地址），将输入该值或该值。 我们看到以下代码部分： </p><br><p><img src="https://habrastorage.org/webt/sy/lz/pk/sylzpkcjv9ietp31t1j0itpol7g.png"></p><br><p> 现有值向右移动4位，新值放入低字节，然后将结果再次输入到变量中。 从理论上讲，我们的<code>jmp_addr</code>变量存储可以在键输入屏幕上输入的字符。 另请注意，变量的大小为<code>WORD</code> 。 </p><br><p> 实际上， <code>sub_3A4</code>函数可以称为<code>update_jmp_addr</code> 。 </p><br><h3 id="sub_414">  sub_414（） </h3><br><p> 现在，循环中只剩下一个函数，该函数无法识别。 它被称为<code>sub_414</code> 。 </p><br><p><img src="https://habrastorage.org/webt/yz/ik/7r/yzik7r22zmhp2u-5hk0-0busyjy.png"></p><br><p> 它的代码类似于<code>update_jmp_addr</code>函数的代码，仅在最后我们有一个<code>sub_45E</code>函数<code>sub_45E</code> 。 让我们看看那里。 </p><br><h4 id="sub_45e">  sub_45E（） </h4><br><p><img src="https://habrastorage.org/webt/u4/-b/yl/u4-bylf_dl1ewl1ajhhtkqsqgn0.png"></p><br><p> 我们看到在<code>D0</code>寄存器中输入了数字<code>#$4B1E2003</code> ，然后将其发送到<code>VDP_CTRL</code> ，这意味着我们正在处理另一个<code>VDP</code>控制命令。 我们按<code>J</code> ，我们会收到一个映射<code>$Cxxx</code>区域中的记录命令。 </p><br><p> 接下来，代码使用变量<code>byte_FF0014</code> ，除了当前函数外，该变量未在其他任何地方使用。 如果仔细看一下它的用法，您会注意到它可以安装的最大数量为<code>4</code> 。 我假设这是输入密钥的当前长度。 让我们来看看。 </p><br><h4 id="zapuskaem-otladchik"> 运行调试器 </h4><br><p> 我将使用<code>Smd Ida Tools</code>的调试器，但实际上，某些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Gens KMod</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Gens ReRecording</a>就足够了。 最主要的是，有一个功能可以在内存中显示地址。 </p><br><p><img src="https://habrastorage.org/webt/bx/p2/j9/bxp2j9ejyp85pohlubxrdda4c5a.png"></p><br><p> 我的理论已经得到证实。 因此，变量<code>byte_FF0014</code>现在可以<code>key_length</code> 。 </p><br><p> 还有另一个变量： <code>dword_FF0010</code> ，它也仅在当前函数中使用，并且其内容在添加到<code>D0</code>的初始命令（回想起来，它是编号<code>#$4B1E2003</code> ）之后，被发送到<code>VDP_CTRL</code> 。 我<code>add_to_vdp_cmd</code> ，将其命名为变量<code>add_to_vdp_cmd</code> 。 </p><br><p> 那么这个功能做什么呢？ 我假设她会绘制输入的字符。 检查这很简单-通过启动调试器并在调用<code>sub_45E</code>函数之前和之后比较状态： </p><br><p> 至： </p><br><p><img src="https://habrastorage.org/webt/av/dl/et/avdletevo4p-evvc7gy6_e87djm.png"></p><br><p> 之后： </p><br><p><img src="https://habrastorage.org/webt/hf/ot/pi/hfotpiwid000obmkv6fnni67eqy.png"></p><br><p> 我是对的-此函数绘制输入的字符。 我们称它为<code>do_draw_input_char</code> ，调用它的函数（ <code>sub_414</code> ）为<code>draw_input_char</code> 。 </p><br><h2 id="chto-teper"> 现在呢 </h2><br><p> 现在让我们检查一下我们称为<code>jmp_addr</code>的变量<code>jmp_addr</code>确实存储了输入的密钥。 我们将使用相同的<code>Memory Watch</code> ： </p><br><p><img src="https://habrastorage.org/webt/zy/vv/iq/zyvviqmu_r_ewas7ks1jhdj8w3o.png"></p><br><p> 如您所见，这个猜想是正确的。 这给了我们什么？ 我们可以跳转到任何地址。 但是哪一个呢？ 在功能列表中，所有内容归根到底是： </p><br><p><img src="https://habrastorage.org/webt/fd/wb/_7/fdwb_7otp3ztohkcacuoooyv5xw.png"></p><br><p> 然后，我开始滚动浏览代码，直到找到： </p><br><p><img src="https://habrastorage.org/webt/wo/r5/4n/wor54nhofpzrmlsz4dils09j62s.png"></p><br><p> 训练有素的眼睛看到了<code>$4E, $75</code>的序列<code>$4E, $75</code>在未分配字节的末尾。 这是<code>rts</code>指令的操作码，即 从函数返回。 因此，这些未分配的字节可以是某些功能的代码。 让我们尝试将它们指定为代码，按<code>C</code> ： </p><br><p><img src="https://habrastorage.org/webt/bd/vz/2i/bdvz2imlo3ifuxfkdizq0sxstxu.png"></p><br><p> 显然，这是一个功能代码。 您也可以按其上的<code>P</code>以使代码起作用。 记住这个名字： <code>sub_D3C</code> 。 </p><br><p> 然后想到了：如果您跳到<code>sub_D3C</code>怎么<code>sub_D3C</code> ？ 听起来不错，尽管在这里单跳显然是不够的，因为 没有更多到<code>word_FF0020</code>变量的链接。 </p><br><p> 然后另一个想法浮现在我头：如果我们寻找另一个这样的未分配代码怎么办？ 打开<code>Binary search</code>对话框（Alt + B），在其中输入序列<code>4E 75</code> ，选中“ <code>Find all occurrences</code> ”框： </p><br><p><img src="https://habrastorage.org/webt/qy/tv/t3/qytvt3-qvf6eu1dpdsqs-senvaw.png"></p><br><p> 单击<code></code>开始搜索，我们得到以下结果。 </p><br><p><img src="https://habrastorage.org/webt/ne/xp/y4/nexpy4fvlcfvberh_eyjof2jvf8.png"></p><br><p> 朗姆酒中至少还有两个地方可能包含功能代码，您需要检查它们。 我们单击第一个选项，向上滚动一点，然后再次看到一系列未定义的字节。 将它们表示为功能吗？ 是的 在字节开始处打<code>P</code> ： </p><br><p><img src="https://habrastorage.org/webt/h-/as/yb/h-asybpa2wcjjtm1ry1cnqrc8iq.png"></p><br><p> 好酷！ 现在我们有了<code>sub_34C</code>函数。 我们尝试对找到的最后一个选项重复同样的事情，并且...我们感到非常遗憾。  <code>4E 75</code>之前有太多字节，因此不清楚函数从何处开始。 而且，显然，并非以上所有这些字节都是代码，因为 很多重复的字节。 </p><br><h3 id="opredelyaem-nachalo-funkcii"> 确定函数的开始 </h3><br><p> 如果我们找到数据的结束位置，那么最容易找到函数的开始。 怎么做？ 实际上一点也不复杂： </p><br><ol><li> 我们在数据开始之前进行扭曲（代码中将存在指向它们的链接） </li><li> 我们点击链接并寻找一个循环，在该循环中应显示此数据的大小 </li><li> 标记阵列 </li></ol><br><p> 因此，我们执行第一段...： </p><br><p><img src="https://habrastorage.org/webt/qn/ks/hu/qnkshuhax6mtxdttfgdtgzxoxuw.png"></p><br><p>  ...，我们立即看到，在一个循环中，从数组中一次将4个字节的数据（由于<code>move.l</code> ）复制到了<code>VDP_DATA</code> 。 接下来，我们看到数字<code>2047</code> 。 起初，似乎数组的最终大小为<code>2047 * 4</code> ，但是基于<code>dbf</code>的循环执行的次数更多，而<code>+1</code>迭代 最后比较的值不是<code>0</code> ，而是<code>-1</code> 。 </p><br><p> 总计：数组的大小为<code>2048 * 4 = 8192</code> 。 将字节表示为数组。 为此，请单击<code>*</code>并指定大小： </p><br><p><img src="https://habrastorage.org/webt/yg/7n/cs/yg7ncsvz4ehn1vo3v_hbnnmhkj8.png"></p><br><p> 我们扭曲到数组的末尾，然后看到字节，它们恰好是代码的字节： </p><br><p><img src="https://habrastorage.org/webt/fl/jg/we/fljgwe4yhiykcwtks1stu4p2zoa.png"></p><br><p><img src="https://habrastorage.org/webt/wv/lz/ok/wvlzokzal1zgivxim4rwzmzu9i8.png"></p><br><p> 现在我们有了<code>sub_2D86</code>函数，并且我们拥有解决此<code>sub_2D86</code>一切！ 让我们看看新创建的函数的作用。 </p><br><h3 id="sub_2d86">  sub_2D86（） </h3><br><p> 它将值<code>#$4147</code>放入寄存器<code>D1</code>并调用<code>sub_34C</code>函数。 看看她。 </p><br><h4 id="sub_34c">  sub_34C（） </h4><br><p><img src="https://habrastorage.org/webt/gh/t1/pq/ght1pqqu3aazeufyhrdc88d46my.png"></p><br><p> 我们看到这里<code>word_FF0020</code>变量的值被<code>word_FF0020</code> 。 如果查看它的链接，我们将看到在此变量中进行记录的另一个地方，而这正是我要跳过<code>jmp_addr</code>变量的地方。 这确认了<code>sub_D3C</code>肯定需要跳转到<code>sub_D3C</code> 。 </p><br><p> 但是接下来发生的事情让我无法理解，因此我把朗姆酒扔进了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">GHIDRA</a> ，找到了这个功能，然后看了反编译的代码： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ushort in_D1w; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,in_D1w ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p> 我们看到使用了具有奇怪名称<code>in_D1w</code>的变量，还使用了变量<code>DAT_00ff0020</code> ，其地址类似于<code>word_FF0020</code>提到的<code>word_FF0020</code> 。 </p><br><p>  <code>in_D1w</code>告诉我们，该值是从寄存器<code>D1</code>或<code>in_D1w</code>的WORD一半中获取的，并将寄存器<code>D1</code>设置为传递该值<code>D1</code>函数。 还记得<code>#$4147</code>吗？ 因此，您需要将此寄存器指定为函数的输入参数。 </p><br><p> 为此，在带有反编译代码的窗口中，右键单击函数名称，然后选择“ <code>Edit Function Signature</code>菜单项： </p><br><p><img src="https://habrastorage.org/webt/qg/ee/nn/qgeenn-klxvb-utqj3fphg6woi8.png"></p><br><p> 为了指示该函数通过特定的寄存器（而不是通过当前调用约定的标准方法）接受参数，您需要选中<code>Use Custom Storage</code> ，然后单击带有<u>绿色加号</u>的图标： </p><br><p><img src="https://habrastorage.org/webt/zj/b0/kv/zjb0kvz41lnxumb9dqr5zqutmje.png"></p><br><p> 出现新输入参数的位置。 双击它，将出现一个对话框，指示参数的类型和媒介： </p><br><p><img src="https://habrastorage.org/webt/7r/sl/n-/7rsln-dem8qbsqt4zh5bi2xaukc.png"></p><br><p> 在反编译的代码中，我们看到<code>in_D1w</code>是<code>ushort</code>类型，这意味着我们将在type字段中指定它。 然后单击<code>Add</code>按钮： </p><br><p><img src="https://habrastorage.org/webt/5v/vn/2h/5vvn2hkjpomj4fwk4bjxj5bxj_q.png"></p><br><p> 将出现一个位置来指示参数的<code>D1w</code> <code>Location</code> ，我们需要在<code>Location</code>指定<code>D1w</code>寄存器，然后单击<code>OK</code> ： </p><br><p><img src="https://habrastorage.org/webt/cj/3a/za/cj3azab2pkoqgcasbeh1o7vw5tk.png"></p><br><p> 反编译的代码将采用以下形式： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ushort param_1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,param_1 ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p> 我们<code>param_1</code>我们的<code>param_1</code>值是常量，由调用函数传递，并且等于<code>#$4147</code> 。 那么<code>DAT_00ff0020</code>的值应该是<code>DAT_00ff0020</code> ？ 我们考虑： </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> = <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> = <span class="hljs-number"><span class="hljs-number">0x4e50</span></span></code> </pre> <br><p> 因为  <code>xor</code>该操作是可逆的，所有常数可以相互争吵，并获得变量<code>DAT_00ff0020</code>的所需值。 </p><br><pre> <code class="cpp hljs">DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span> DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4e50</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span></code> </pre> <br><p> 事实证明，变量的值应为<code>0x4553</code> 。 看来我已经看到了设置了这样一个值的地方... </p><br><p><img src="https://habrastorage.org/webt/p_/mq/go/p_mqgo48sih6pijb1ks6aiq1fpy.png"></p><br><h2 id="vyvody-i-reshenie"> 结论与决定 </h2><br><p> 我们得出以下结果： </p><br><ol><li> 首先，您需要跳转到地址<code>0x0D3C</code> ，为此，您需要输入代码<code>0D3C</code> </li><li> 跳转到函数<code>0x2D86</code> ，该函数将<code>D1</code>的值设置为寄存器<code>#$4147</code> ，为此，您需要输入代码<code>2D86</code> </li></ol><br><p> 通过实验，我们找出需要按下的键来检查输入的键： <code>B</code> 我们尝试： </p><br><p><img src="https://habrastorage.org/webt/x9/6o/tf/x96otfmozj0tgnjmc6_hs6glcpi.png"></p><br><p> 谢谢你 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448500/">https://habr.com/ru/post/zh-CN448500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448488/index.html">恐惧与厌恶DevSecOps</a></li>
<li><a href="../zh-CN448490/index.html">如何开始DevOps转换</a></li>
<li><a href="../zh-CN448492/index.html">什么是DevOps</a></li>
<li><a href="../zh-CN448496/index.html">Linux上的.NET Core，骑马上的DevOps</a></li>
<li><a href="../zh-CN448498/index.html">“俄罗斯404”：还剩多少免费互联网可供使用</a></li>
<li><a href="../zh-CN448504/index.html">他们为每个人“ Habrom”收集了护照的参考书“由谁发行……”。 下载到健康</a></li>
<li><a href="../zh-CN448506/index.html">黑客帝国已有20年历史：沃卓斯基如何制作朋克，这决定了整个一代人的议程</a></li>
<li><a href="../zh-CN448510/index.html">宏cer（Acer）2019年：如果从游戏笔记本电脑中清除所有苍蝇该怎么办</a></li>
<li><a href="../zh-CN448516/index.html">在ARDUINO平台上进化或为机器人奠定基础，我们通过智能手机将传感器和视频驱动到计算机</a></li>
<li><a href="../zh-CN448518/index.html">如何看到黑洞？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>