<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úíÔ∏è üíΩ üå®Ô∏è Essayons de parler des machines √† √©tats hi√©rarchiques en g√©n√©ral et de leur support dans SObjectizer-5 en particulier üë®üèΩ‚Äç‚öñÔ∏è üë©üèø‚Äçü§ù‚Äçüë©üèæ üèÇüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les machines √† √©tats finis sont peut-√™tre l'un des concepts les plus fondamentaux et les plus largement utilis√©s en programmation. Les machines √† √©tat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Essayons de parler des machines √† √©tats hi√©rarchiques en g√©n√©ral et de leur support dans SObjectizer-5 en particulier</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423497/">  Les machines √† √©tats finis sont peut-√™tre l'un des concepts les plus fondamentaux et les plus largement utilis√©s en programmation.  Les machines √† √©tats finis (KA) sont activement utilis√©es dans de nombreuses niches appliqu√©es.  En particulier, dans des cr√©neaux tels que l'APCS et les t√©l√©communications, avec lesquels il √©tait possible de faire face, les engins spatiaux se retrouvent un peu moins souvent qu'√† chaque √©tape. <br><br>  Par cons√©quent, dans cet article, nous essaierons de parler des engins spatiaux, principalement des machines √† √©tats finis hi√©rarchiques et de leurs capacit√©s avanc√©es.  Et parlez un peu de la prise en charge des vaisseaux spatiaux dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer-5</a> , le framework ¬´acteur¬ª pour C ++.  Un de ces <s>deux</s> rares qui sont ouverts, gratuits, multiplateformes et encore en vie. <br><br>  M√™me si vous n'√™tes pas int√©ress√© par SObjectizer, mais que vous n'avez jamais entendu parler de machines √† √©tats finis hi√©rarchiques ou de l'utilit√© des fonctionnalit√©s avanc√©es d'un vaisseau spatial comme les gestionnaires d'entr√©e / sortie pour les √©tats ou l'historique des √©tats, alors vous pourriez √™tre int√©ress√© √† regarder sous le chat et lire au moins la premi√®re partie de l'article. <br><a name="habracut"></a><br><h1>  Mots g√©n√©raux sur les machines √† √©tats finis </h1><br>  Nous n'essaierons pas de mener un programme √©ducatif complet dans l'article sur le sujet des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">automates</a> et une telle vari√©t√© que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les machines √† √©tats finis</a> .  Le lecteur doit avoir au moins une compr√©hension de base de ces types d'entit√©s. <br><br><h2>  Machines avanc√©es √† √©tats finis et leurs capacit√©s </h2><br>  Le vaisseau spatial a plusieurs fonctionnalit√©s "avanc√©es" qui augmentent consid√©rablement l'utilisabilit√© du vaisseau spatial dans le programme.  Jetons un coup d'≈ìil √† ces fonctionnalit√©s ¬´avanc√©es¬ª. <br><br>  Avertissement: si le lecteur conna√Æt bien les diagrammes d'√©tat d'UML, il ne trouvera rien de nouveau pour lui ici. <br><br><h3>  Machines √† √©tats hi√©rarchiques </h3><br>  L'opportunit√© peut-√™tre la plus importante et la plus pr√©cieuse est l'organisation d'une hi√©rarchie / imbrication d'√©tats.  √âtant donn√© que c'est pr√©cis√©ment la capacit√© de mettre des √©tats les uns dans les autres qui √©limine ¬´l'explosion¬ª du nombre de transitions d'un √©tat √† l'autre √† mesure que la complexit√© de l'engin spatial augmente. <br><br>  Il est plus difficile d'expliquer cela avec des mots que de montrer par l'exemple.  Par cons√©quent, imaginons que nous ayons un infokiosque sur l'√©cran dont un message de bienvenue est d'abord affich√©.  L'utilisateur peut s√©lectionner l'√©l√©ment ¬´Services¬ª et aller √† la section pour s√©lectionner les services dont il a besoin.  Ou il peut s√©lectionner l'√©l√©ment ¬´Compte personnel¬ª et aller √† la section sur l'utilisation de ses donn√©es et services personnels.  Ou il peut s√©lectionner la section Aide.  Jusqu'√† pr√©sent, tout semble simple et peut √™tre repr√©sent√© par le diagramme d'√©tat suivant (aussi simplifi√© que possible): <br><br><img src="https://habrastorage.org/webt/6e/lv/bm/6elvbm4wcsbmfbjaasp8zynjmtw.png"><br><br>  Mais essayons de nous assurer qu'en cliquant sur le bouton "Annuler", l'utilisateur peut revenir de n'importe quelle section √† la page de d√©marrage avec un message de bienvenue: <br><br><img src="https://habrastorage.org/webt/ok/hn/u3/okhnu3xrsjiss8u1fl1gygirn9u.png"><br><br>  Le sch√©ma devient compliqu√©, mais toujours sous contr√¥le.  Cependant, rappelons que dans la section ¬´Services¬ª, nous pouvons avoir plusieurs sous-sections suppl√©mentaires, par exemple, ¬´Services populaires¬ª, ¬´Nouveaux services¬ª et ¬´Liste compl√®te¬ª.  Et √† partir de chacune de ces sections, vous devez √©galement revenir √† la page de d√©marrage.  Notre vaisseau spatial simple devient de plus en plus difficile: <br><br><img src="https://habrastorage.org/webt/ic/zx/hu/iczxhus-j_5ohrzwdxpbdf5n2qi.png"><br><br>  Mais c'est loin d'√™tre tout.  Nous n'avons pas encore pris en compte le bouton "Retour", par lequel nous devons revenir √† la section pr√©c√©dente.  Ajoutons une r√©action au bouton "Retour" et voyons ce que nous obtenons: <br><br><img src="https://habrastorage.org/webt/mn/rq/t7/mnrqt7zjk8kyq6e3i1-jb9fgwya.png"><br><br>  Oui, nous voyons maintenant le chemin du vrai plaisir.  Mais nous n'avons m√™me pas consid√©r√© les sous-sections dans les sections "Mon compte" et "Aide" ... Si nous commen√ßons, alors presque imm√©diatement notre vaisseau spatial simple, au d√©but, se transformera en quelque chose d'inimaginable. <br><br>  Ici l'imbrication des √âtats vient √† notre secours.  Imaginons que nous n'avons que deux √©tats de niveau sup√©rieur: WelcomeScreen et UserSelection.  Toutes nos sections (c'est-√†-dire ¬´Services¬ª, ¬´Mon compte¬ª et ¬´Aide¬ª) seront ¬´imbriqu√©es¬ª dans l'√©tat UserSelection.  Vous pouvez dire que les √©tats ServicesScreen, ProfileScreen et HelpScreen seront des enfants de UserSelection.  Et comme ils sont enfants, ils h√©riteront de la r√©action √† certains signaux de leur √©tat parental.  Par cons√©quent, nous pouvons d√©finir la r√©ponse au bouton Annuler dans UserSelection.  Mais nous n'avons pas besoin de d√©terminer cette r√©action dans tous les sous-√©tats subsidiaires.  Ce qui rend notre vaisseau spatial plus concis et compr√©hensible: <br><br><img src="https://habrastorage.org/webt/lx/nb/qn/lxnbqn3kqv9rst-fbebmx1kxhi8.png"><br><br>  Ici, vous pouvez noter que la r√©action pour "Annuler" et "Retour" nous avons d√©fini dans UserSelection.  Et cette r√©action au bouton Annuler fonctionne pour tous sans exception les sous-√©tats UserSelection (y compris un autre sous-√©tat composite ServicesSelection).  Mais dans le sous-√©tat ServicesSelection, la r√©action au bouton Retour est d√©j√† diff√©rente - le retour n'est pas dans WelcomScreen, mais dans ServicesScreen. <br><br>  Les autorit√©s de certification qui utilisent une hi√©rarchie / imbrication d'√©tats sont appel√©es machines √† √©tats finis hi√©rarchiques (ICA). <br><br><h3>  R√©action √† l'entr√©e / sortie vers / depuis l'√âtat </h3><br>  Une caract√©ristique tr√®s utile est la capacit√© d'attribuer une r√©ponse √† l'entr√©e dans un √©tat particulier, ainsi qu'une r√©action √† la sortie d'un √©tat.  Ainsi, dans l'exemple ci-dessus avec un infokiosque, un gestionnaire peut √™tre raccroch√© pour entrer dans chacun des √©tats, ce qui changera le contenu de l'√©cran de l'infokiosque. <br><br>  L'exemple pr√©c√©dent peut √™tre d√©velopp√© un peu.  Supposons que nous avons deux sous-√©tats dans WelcomScreen: BrightWelcomScreen, dans lequel l'√©cran sera mis en surbrillance normalement, et DarkWelcomScreen, dans lequel la luminosit√© de l'√©cran sera r√©duite.  Nous pouvons cr√©er un gestionnaire d'entr√©e DarkWelcomScreen qui att√©nuera l'√©cran.  Et un gestionnaire de sortie DarkWelcomScreen qui r√©tablira une luminosit√© normale. <br><br><img src="https://habrastorage.org/webt/qm/n0/2y/qmn02yrt9xxxmmawcpzufiexrpg.png"><br><br><h3>  Changement d'√©tat automatique apr√®s un temps d√©fini </h3><br>  Parfois, il peut √™tre n√©cessaire de limiter le s√©jour du vaisseau spatial dans un √©tat particulier.  Ainsi, dans l'exemple ci-dessus, nous pouvons limiter le temps que notre ICA reste √† l'√©tat BrightWelcomScreen √† une minute.  D√®s que la minute expire, l'ICA passe automatiquement √† l'√©tat DarkWelcomScreen. <br><br><h3>  Histoire du vaisseau spatial </h3><br>  Une autre caract√©ristique tr√®s utile de l'ICA est l'histoire de l'√©tat du vaisseau spatial. <br><br>  Imaginons que nous ayons une sorte d'ICA abstraite de ce type: <br><br><img src="https://habrastorage.org/webt/6i/6n/bl/6i6nblfh7l89fzaulpzsa3mo4a4.png"><br><br>  Notre ICA peut aller de TopLevelState1 √† TopLevelState2 et vice versa.  Mais √† l'int√©rieur de TopLevelState1, il existe plusieurs √©tats imbriqu√©s.  Si l'ICA passe simplement de TopLevelState2 √† TopLevelState1, alors deux √©tats sont imm√©diatement activ√©s: TopLevelState1 et NestedState1.  NestedState1 est activ√© car il s'agit du sous-√©tat initial de l'√©tat TopLevelState1. <br><br>  Imaginez maintenant que notre ICA change son √©tat de NestedState1 √† NestedState2.  Dans NestedState2, le SubState InternalState1 a √©t√© activ√© (car il s'agit du sous-√©tat initial pour NestedState2).  Et de InternalState1, nous sommes all√©s √† InternalState2.  Ainsi, nous avons simultan√©ment les √©tats suivants actifs: TopLevelState1, NestedState2 et InternalState2.  Et ici, nous allons √† TopLevelState2 (c'est-√†-dire que nous avons g√©n√©ralement quitt√© TopLevelState1). <br><br>  Active devient TopLevelState2.  Apr√®s quoi, nous voulons revenir √† TopLevelState1.  Il se trouve dans TopLevelState1 et non dans un sous-√©tat particulier de TopLevelState1. <br><br>  Donc, de TopLevelState2, nous allons √† TopLevelState1 et o√π allons-nous? <br><br>  Si TopLevelState1 n'a pas d'historique, nous arriverons √† TopLevelState1 et NestedState1 (puisque NestedState1 est le sous-√©tat initial de TopLevelState1).  C'est-√†-dire  toute l'histoire des transitions √† l'int√©rieur de TopLevelState1, qui a eu lieu avant de quitter TopLevelState2, a √©t√© compl√®tement perdue. <br><br>  Si TopLevelState1 a un soi-disant  historique peu profond, puis lors du retour de TopLevelState2 √† TopLevelState1, nous entrons dans NestedState2 et InternalState1.  Nous entrons dans NestedState2 car il est enregistr√© dans l'historique de statut de TopLevelState1.  Et nous arrivons √† InternalState1 parce que c'est celui de d√©part pour NestedState2.  Il s'av√®re que dans l'historique superficiel de TopLevelState1, les informations ne sont stock√©es que sur les sous-√©tats du tout premier niveau.  L'historique des √©tats int√©gr√©s dans ces sous-√©tats n'est pas conserv√©. <br><br>  Mais si TopLevelState1 a une histoire profonde, alors lorsque nous revenons de TopLevelState2 √† TopLevelState1, nous entrons dans NestedState2 et InternalState2.  Parce que dans une histoire profonde, des informations compl√®tes sur les sous-√©tats actifs sont stock√©es, quelle que soit leur profondeur. <br><br><h3>  √âtats orthogonaux </h3><br>  Jusqu'√† pr√©sent, nous avons examin√© l'ICA dans lequel un seul des sous-√©tats pouvait √™tre actif √† l'int√©rieur de l'√âtat.  Mais parfois, il peut y avoir des situations o√π, dans un √©tat particulier de l'ICA, il devrait y avoir plusieurs sous-√©tats simultan√©ment actifs.  Ces sous-√©tats sont appel√©s √©tats orthogonaux. <br><br>  Un exemple classique qui illustre des √©tats orthogonaux est le clavier d'ordinateur familier et ses modes NumLock, CapsLock et ScrollLock.  Nous pouvons dire que travailler avec NumLock / CapsLock / ScrollLock est d√©crit par des sous-√©tats orthogonaux √† l'int√©rieur de l'√©tat Actif: <br><br><img src="https://habrastorage.org/webt/hv/kf/8p/hvkf8p_gqijakghmndndhlileag.png"><br><br><h3>  Tout ce que vous vouliez savoir sur les machines √† √©tats finis, mais ... </h3><br>  En g√©n√©ral, il existe un article fondamental sur la notation formelle pour les diagrammes d'√©tat de David Harel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Statecharts: A Visual Formalism For Complex Systems (1987)</a> . <br><br>  L√†, diverses situations qui peuvent √™tre rencontr√©es lorsque l'on travaille avec des machines √† √©tats finis sont examin√©es en utilisant l'exemple de la commande d'une horloge √©lectronique ordinaire.  Si quelqu'un ne l'a pas lu, je le recommande vivement.  Fondamentalement, tout ce que Harel a d√©crit est ensuite entr√© dans la notation UML.  Mais lorsque vous lisez la description des diagrammes d'√©tat de l'UML, vous ne comprenez pas toujours quoi, pourquoi et quand vous en avez besoin.  Mais dans l'article de Harel, la pr√©sentation passe de situations simples √† des situations plus complexes.  Et vous √™tes mieux conscient de tout le pouvoir que les machines √† √©tats finis cachent en elles-m√™mes. <br><br><h1>  Machines √† √©tats finis dans SObjectizer </h1><br>  Plus loin, nous parlerons de SObjectizer et de ses sp√©cificit√©s.  Si vous ne comprenez pas bien les exemples ci-dessous, il peut √™tre judicieux d'en savoir plus sur SObjectizer.  Par exemple, √† partir de notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de synth√®se sur SObjecizer</a> et de plusieurs autres qui introduisent les lecteurs √† SObjectizer, passant du simple au complexe ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier</a> article, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">troisi√®me</a> ). <br><br><h2>  Les agents dans SObjectizer sont des machines √† √©tats </h2><br>  Les agents de SObjectizer depuis le d√©but √©taient des machines √† √©tats avec des √©tats explicites.  M√™me si le d√©veloppeur de l'agent n'a d√©crit aucun de ses propres √©tats dans sa classe d'agent, l'agent avait toujours un √©tat par d√©faut, qui √©tait utilis√© par d√©faut.  Par exemple, si un d√©veloppeur a cr√©√© un agent aussi trivial: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;how_are_you&gt;([]{ std::cout &lt;&lt; "I'm fine!" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); } };</span></span></code> </pre> <br>  alors il peut m√™me ne pas soup√ßonner qu'en r√©alit√© tous les abonnements qu'il a faits sont faits pour l'√©tat par d√©faut.  Mais si le d√©veloppeur ajoute ses propres √©tats √† l'agent, vous devez d√©j√† penser √† signer correctement l'agent dans l'√©tat correct.  Ici, disons, une modification simple (et, comme d'habitude) incorrecte de l'agent montr√© ci-dessus: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,  ,   . state_t st_free{this}; // ,  ,   . state_t st_busy{this}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  Nous avons d√©fini deux gestionnaires diff√©rents pour le signal how_are_you, chacun pour son propre √©tat. <br><br>  Et l'erreur dans cette modification d'agent simple_demo est qu'√©tant en st_free ou st_busy, l'agent ne r√©pondra pas du tout pour quitter, car  nous avons laiss√© l'abonnement de sortie dans l'√©tat par d√©faut, mais n'avons pas effectu√© les abonnements correspondants pour st_free et st_busy.  Un moyen simple et √©vident de r√©soudre ce probl√®me consiste √† ajouter les abonnements appropri√©s √† st_free et st_busy: <br><pre> <code class="cpp hljs"> simple_demo(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { <span class="hljs-comment"><span class="hljs-comment">//   how_are_you   ,    . st_free .event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); st_busy .event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //     st_free. this &gt;&gt;= st_free; }</span></span></code> </pre> <br>  Certes, cette m√©thode sent le copier-coller, ce qui n'est pas bon.  Vous pouvez vous d√©barrasser du copier-coller en entrant un √©tat parent commun pour st_free et st_busy: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      . state_t st_basic{this}; // ,  ,   . //      st_basic. state_t st_free{initial_substate_of{st_basic}}; // ,  ,   . //     st_basic. state_t st_busy{substate_of{st_basic}}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { //   quit   st_basic    //  ""  . st_basic.event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  Par souci de justice, il convient d'ajouter qu'au d√©part, dans SObjectizer, les agents ne pouvaient √™tre que de simples machines √† √©tats.  La prise en charge des engins spatiaux hi√©rarchiques est apparue relativement r√©cemment, en janvier 2016. <br><br><h2>  Pourquoi les agents SObjectizer sont-ils des machines √† √©tats finis? </h2><br>  Cette question a une r√©ponse tr√®s simple: il <s>se trouve que les</s> racines de SObjectizer se d√©veloppent dans le monde des syst√®mes de contr√¥le de processus, et que des machines √† √©tats finis sont utilis√©es tr√®s souvent.  Par cons√©quent, nous avons jug√© n√©cessaire que les agents dans SObjectizer soient √©galement des machines √† √©tats.  Ceci est tr√®s pratique si dans l'application pour quel SObjectizer ils essaient d'appliquer, des autorit√©s de certification sont utilis√©es.  Et l'√©tat par d√©faut, que tous les agents ont, nous permet de ne pas penser aux vaisseaux spatiaux si l'utilisation de vaisseaux spatiaux n'est pas requise. <br><br>  En principe, si vous regardez le mod√®le des acteurs lui-m√™me et les principes sur lesquels ce mod√®le est construit: <br><br><ul><li>  un acteur est une entit√© avec un comportement; </li><li>  les acteurs r√©pondent aux messages entrants; </li><li>  Apr√®s avoir re√ßu le message, l'acteur peut: <br><ul><li>  envoyer un certain nombre de messages √† d'autres acteurs; </li><li>  cr√©er un certain nombre de nouveaux acteurs; </li><li>  D√©finissez un nouveau comportement pour le traitement des messages suivants. </li></ul></li></ul><br>  On peut trouver une forte similitude entre un vaisseau spatial simple et des acteurs.  On pourrait m√™me dire que les acteurs sont de simples machines √† √©tats finis. <br><br><h2>  Quelles sont les fonctionnalit√©s des machines √† √©tats avanc√©es prises en charge par SObjectizer? </h2><br>  Parmi les fonctionnalit√©s ci-dessus des machines avanc√©es √† √©tats finis, SObjectizer prend en charge tout sauf les √©tats orthogonaux.  D'autres avantages, tels que les √©tats imbriqu√©s, les gestionnaires d'entr√©e / sortie, les restrictions sur le temps pass√© dans l'√©tat, l'historique des √©tats, sont pris en charge. <br><br>  Avec le soutien des √©tats orthogonaux, la premi√®re fois n'a pas grandi ensemble.  D'une part, l'architecture interne de SObjectizer n'√©tait pas destin√©e √† prendre en charge plusieurs √©tats ind√©pendants et simultan√©ment actifs de l'agent.  D'un autre c√¥t√©, il existe des questions id√©ologiques sur le comportement d'un agent qui a des √©tats orthogonaux.  L'enchev√™trement de ces questions s'est av√©r√© trop compliqu√© et l'√©chappement utile √©tait trop petit pour r√©soudre ce probl√®me.  Oui, et dans notre pratique, il n'y a pas encore eu de situations o√π des √©tats orthogonaux auraient √©t√© requis, mais cela n'aurait pas √©t√© possible, par exemple, en divisant le travail entre plusieurs agents li√©s √† un contexte de travail commun. <br><br>  Cependant, si quelqu'un a besoin d'une fonctionnalit√© telle que des √©tats orthogonaux et que vous avez des exemples concrets de t√¢ches o√π cela est demand√©, parlons-en.  Peut-√™tre, ayant des exemples concrets sous nos yeux, nous pouvons ajouter cette fonctionnalit√© √† SObjectizer. <br><br><h2>  A quoi ressemble la prise en charge des fonctionnalit√©s avanc√©es d'ICA dans le code </h2><br>  Dans cette partie de l'histoire, nous allons essayer de passer rapidement en revue l'API SObjectizer-5 pour travailler avec ICA.  Sans entrer dans les d√©tails, juste pour que le lecteur ait une id√©e de ce qu'est et √† quoi il ressemble.  Des informations plus d√©taill√©es, si vous le souhaitez, peuvent √™tre trouv√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la documentation officielle</a> . <br><br><h3>  √âtats imbriqu√©s </h3><br>  Pour d√©clarer un √©tat imbriqu√©, vous devez transmettre l'expression initial_substate_of ou substate_of au constructeur de l'objet state_t correspondant: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_parent{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  . state_t st_first_child{initial_substate_of{st_parent}}; //   . //    . state_t st_second_child{substate_of{st_parent}}; //   . state_t st_third_child{substate_of{st_parent}}; //   . state_t st_first_grandchild{initial_substate_of{st_third_child}}; //    . state_t st_second_grandchild{substate_of{st_third_child]}; ... };</span></span></code> </pre> <br>  Si l'√©tat S a plusieurs sous-√©tats C1, C2, ..., Cn, alors l'un d'entre eux (et un seul) doit √™tre marqu√© comme initial_substate_of.  La violation de cette r√®gle est diagnostiqu√©e au moment de l'ex√©cution. <br><br>  La profondeur d'√©tat maximale imbriqu√©e dans SObjectizer-5 est limit√©e.  Dans les versions 5.5, ce sont 16 niveaux.  La violation de cette r√®gle est diagnostiqu√©e au moment de l'ex√©cution. <br><br>  L'astuce la plus importante avec les √©tats imbriqu√©s est que lorsqu'un √©tat qui a des √©tats imbriqu√©s est activ√©, plusieurs √©tats sont activ√©s √† la fois.  Supposons qu'il existe un √©tat A qui a les sous-√©tats B et C, et dans le sous-√©tat B qu'il y ait des sous-√©tats D et E: <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Lorsque l'√©tat A est activ√©, alors, en fait, trois √©tats sont activ√©s imm√©diatement: A, AB et ABD <br><br>  Le fait que plusieurs √©tats puissent √™tre actifs √† la fois a l'effet le plus grave sur deux choses d'archives.  Tout d'abord, pour rechercher un gestionnaire pour le prochain message entrant.  Ainsi, dans l'exemple qui vient d'√™tre montr√©, le gestionnaire de messages sera d'abord recherch√© dans l'√©tat ABD. S'il n'y a pas de gestionnaire appropri√©, la recherche continuera dans son √©tat parent, c'est-√†-dire  en AB Et d√©j√† bless√©, si n√©cessaire, la recherche se poursuivra dans l'√©tat A. <br><br>  Deuxi√®mement, la pr√©sence de plusieurs √©tats actifs affecte l'ordre d'invocation des gestionnaires d'entr√©e / sortie pour les √©tats.  Mais cela sera discut√© ci-dessous. <br><br><h3>  Gestionnaires d'E / S d'√©tat </h3><br>  Pour un √©tat, des gestionnaires d'√©tat d'entr√©e et de sortie d'√©tat peuvent √™tre sp√©cifi√©s.  Cela se fait √† l'aide des m√©thodes state_t :: on_enter et state_t :: on_exit.  En r√®gle g√©n√©rale, ces m√©thodes sont appel√©es dans la m√©thode so_define_agent () (ou directement dans le constructeur de l'agent si l'agent est trivial et que l'h√©ritage n'est pas fourni). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_busy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// :       , //     . st_free.on_enter([]{ ... }); st_busy.on_exit([]{ ...}); ... this &gt;&gt;= st_free; } ... };</span></span></code> </pre> <br>  Le moment le plus difficile avec les gestionnaires on_enter / on_exit est probablement de les utiliser pour les √©tats imbriqu√©s.  Revenons √† l'exemple avec les √©tats A, B, C, D et E. <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Supposons que chaque √©tat poss√®de un gestionnaire on_enter et on_exit. <br><br>  Soit A. devenir l'√©tat actuel de l'agent.  les √©tats A, AB et ABD sont activ√©s Lors du changement d'√©tat d'un agent, A.on_enter, ABon_enter et ABDon_enter seront appel√©s.  Et dans cet ordre. <br><br>  Supposons alors qu'il y ait une transition vers ABE. ABDon_exit et ABEon_enter seront appel√©s. <br><br>  Si nous mettons alors l'agent en √©tat AC, alors ABEon_exit, ABon_exit, ACon_enter seront appel√©s. <br><br>  Si l'agent, √©tant √† l'√©tat AC, est radi√©, imm√©diatement apr√®s la fin de la m√©thode so_evt_finish (), les gestionnaires ACon_exit et A.on_exit seront appel√©s. <br><br><h3>  D√©lais </h3><br>  La limite de temps pour que l'agent reste dans un √©tat particulier est d√©finie √† l'aide de la m√©thode state_t :: time_limit.  Comme avec on_enter / on_exit, les m√©thodes time_limit sont g√©n√©ralement appel√©es lorsque l'agent est configur√© pour fonctionner √† l'int√©rieur de SObjectizer: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">led_indicator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> inactive{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> active{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        15s. //        inactive. active.time_limit(15s, inactive); ... } ... };</span></span></code> </pre> <br>  Si la limite de temps pour l'√©tat est d√©finie, d√®s que l'agent entre dans cet √©tat, SObjectizer commence √† compter le temps pass√© dans l'√©tat.  Si l'agent quitte l'√©tat, puis revient √† cet √©tat, le compte √† rebours recommence. <br><br>  Si des d√©lais sont d√©finis pour les √©tats int√©gr√©s, vous devez √™tre prudent, car  des trucs curieux sont possibles: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   . state_t A{this}, B{this}; //   first . state_t C{initial_substate_of{A}}, st_D{substate_of{A}}; ... void so_define_agent() override { A.time_limit(15s, B); C.time_limit(10s, D); D.time_limit(20s, C); ... } ... };</span></span></code> </pre> <br>  Supposons qu'un agent entre dans l'√©tat A. I.e.  les √©tats A et C sont activ√©s pour A et C.  Auparavant, il se terminait pour l'√©tat C et l'agent passait √† l'√©tat D. Cela commencerait le compte √† rebours pour rester dans l'√©tat D. Mais le compte √† rebours continuera pour rester dans A!  √âtant donn√© que pendant la transition de C √† D, l'agent est rest√© dans l'√©tat A. Et cinq secondes apr√®s la transition forc√©e de C √† D, l'agent passe √† l'√©tat B. <br><br><h3>  Histoire de fortune </h3><br>  Par d√©faut, les √©tats d'agent n'ont pas d'historique.  Pour activer la sauvegarde de l'historique d'un √©tat, transmettez la constante shallow_history (l'√©tat aura un historique superficiel) ou deep_history (l'√©tat aura un historique profond) au constructeur state_t.  Par exemple: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> A{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, shallow_history}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> B{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, deep_history}; ... };</code> </pre> <br>  L'histoire des √©tats est un sujet difficile, surtout lorsqu'une profondeur d'imbrication d√©cente des √©tats est utilis√©e et que les sous-√©tats ont leur propre histoire.  Par cons√©quent, pour des informations plus compl√®tes sur ce sujet, il est pr√©f√©rable de se r√©f√©rer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√† la documentation</a> , pour exp√©rimenter.  Eh bien, pour nous demander si vous ne pouvez pas le d√©couvrir vous-m√™me <br><br><h3>  just_switch_to, transfer_to_state, supprimer </h3><br>  La classe state_t poss√®de un certain nombre des m√©thodes les plus couramment utilis√©es qui ont d√©j√† √©t√© pr√©sent√©es ci-dessus: event () pour abonner des √©v√©nements √† un message, on_enter () et on_exit () pour d√©finir les gestionnaires d'entr√©e / sortie, time_limit () pour d√©finir une limite pour le temps pass√© dans un √©tat. <br><br>  Parall√®lement √† ces m√©thodes, lorsque vous travaillez avec ICA, les m√©thodes suivantes de la classe state_t sont tr√®s utiles: <br><br>  M√©thode just_switch_to (), con√ßue pour le cas o√π la seule r√©action √† un message entrant est de transf√©rer l'agent dans un nouvel √©tat.  Vous pouvez √©crire: <br><pre> <code class="cpp hljs">some_state.just_switch_to&lt;some_msg&gt;(another_state);</code> </pre> <br>  au lieu de: <br><pre> <code class="cpp hljs">some_state.event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_msg&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= another_state; });</code> </pre> <br>  La m√©thode transfer_to_state () est tr√®s utile lorsque nous avons un message M trait√© de la m√™me mani√®re dans deux ou plusieurs √©tats S1, S2, ..., Sn.  Mais, si nous sommes dans les √©tats S2, ..., Sn, alors nous devons d'abord revenir √† S1, et ensuite seulement faire le traitement M. <br><br>  Si cela semble d√©licat, alors peut-√™tre que dans un exemple de code, cette situation sera mieux comprise: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); ... //      . Sn.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); } ... };</span></span></code> </pre> <br>  Mais au lieu de d√©finir des gestionnaires d'√©v√©nements tr√®s similaires pour S2, ..., Sn, utilisez transfer_to_state: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.transfer_to_state&lt;M&gt;(S1); ... //      . Sn.transfer_to_state&lt;M&gt;(Sn); } ... };</span></span></code> </pre> <br>  La m√©thode suppress () supprime une recherche de gestionnaire d'√©v√©nements pour le sous-√©tat actuel et tous ses sous-√©tats parents.  Supposons que nous ayons un √©tat parent A dans lequel std :: abort () est appel√© sur le message M.  Et il y a un √©tat enfant de B dans lequel M peut √™tre ignor√© en toute s√©curit√©.  Nous devons d√©terminer la r√©action √† M dans le sous-√©tat B, car si nous ne le faisons pas, le gestionnaire de B se trouvera dans A. Par cons√©quent, nous devrons √©crire quelque chose comme: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) {}); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br>  La m√©thode suppress () vous permet d'√©crire cette situation dans le code de mani√®re plus explicite et graphique: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.suppress&lt;M&gt;(); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br><h2>  Exemple tr√®s simple </h2><br>  Les exemples standard de SObjectizer v.5.5 incluent un exemple simple, <a href="">blinking_led</a> , qui simule le fonctionnement d'un indicateur LED clignotant.  Le diagramme d'√©tat de l'agent de cet exemple est le suivant: <br><br><img src="https://habrastorage.org/webt/9d/yt/ms/9dytmskalbsypsg9xjjzkwupl5k.png"><br><br>  Et voici le code d'agent complet de cet exemple: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  Ici, tout le travail r√©el est effectu√© √† l'int√©rieur des gestionnaires d'E / S pour le sous-√©tat blink_on.  De plus, les limites de la dur√©e de s√©jour dans les sous-√©tats blink_on et blink_off fonctionnent. <br><br><h2>  Pas un exemple tr√®s simple </h2><br>  Les exemples standard de SObjectizer v.5.5 incluent √©galement un exemple beaucoup plus complexe, <a href="">intercom_statechart</a> , qui imite le comportement du panneau d'interphone.  Et le diagramme d'√©tat de l'agent principal dans cet exemple ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/o-/i6/7d/o-i67dswwms9rkutntnvd-hrx7e.jpeg"><br><br>  Tout est si dur car cette imitation permet non seulement d'appeler un appartement par num√©ro, mais aussi des choses comme un code secret unique pour chaque appartement, ainsi qu'un code de service sp√©cial.  Ces codes vous permettent d'ouvrir la serrure de porte sans composer de num√©ro. <br><br>  Il y a encore des choses int√©ressantes dans cet exemple.  Mais il est trop volumineux pour √™tre d√©crit en d√©tail (m√™me un article s√©par√© peut ne pas √™tre suffisant pour cela).  Donc, si vous √™tes int√©ress√© par l'apparence vraiment complexe des ICA dans SObjectizer, vous pouvez le voir dans cet exemple.  Et si quelque chose n'est pas clair, vous pouvez nous poser une question.  Par exemple, dans les commentaires de cet article. <br><br><h1>  Est-il possible de ne pas utiliser le support de vaisseau spatial int√©gr√© √† SObjectizer-5? </h1><br>  Ainsi, SObjectizer-5 a un support int√©gr√© pour ICA avec une tr√®s large gamme de fonctionnalit√©s prises en charge.  Ce support est fait, bien s√ªr, pour l'utiliser.  En particulier, les m√©canismes de d√©bogage de SObjectizer, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le tra√ßage de remise des messages</a> , connaissent l'√©tat de l'agent et affichent l'√©tat actuel dans leurs messages de d√©bogage respectifs. <br><br>  N√©anmoins, si le d√©veloppeur ne souhaite pas, pour une raison quelconque, utiliser les outils int√©gr√©s de SObjectizer-5, il peut ne pas le faire. <br><br>  Par exemple, vous pouvez refuser d'utiliser SObjectizer state_t et d'autres comme √ßa parce que state_t est un objet assez lourd avec √† l'int√©rieur std :: string, quelques std :: function, plusieurs compteurs comme std :: size_t, cinq pointeurs vers divers objets et quelques autres bagatelles.  Ensemble, cela sur Linux 64 bits et GCC-5.5, par exemple, donne 160 octets par state_t (√† part ce qui peut √™tre allou√© dans la m√©moire dynamique). <br><br>  Si vous avez besoin, par exemple, d'un million d'agents dans l'application, dont chacun aura 10 √©tats, la surcharge de SObjectizer state_t peut ne pas √™tre acceptable.  Dans ce cas, vous pouvez utiliser un autre m√©canisme pour travailler avec des machines d'√©tat, en d√©l√©guant manuellement le traitement des messages √† ce m√©canisme.  Quelque chose comme: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">external_fsm_demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { some_fsm_type my_fsm_; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe_self() .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_one&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_two&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_three&gt; cmd) { my_fsm_.handle(*cmd); }); ... } ... };</code> </pre> <br>  Dans ce cas, vous payez pour l'efficacit√© en augmentant la quantit√© de travail manuel et le manque d'aide des m√©canismes de d√©bogage de SObjectizer.  Mais ici, c'est au d√©veloppeur de d√©cider. <br><br><h1>  Conclusion </h1><br>  L'article s'est av√©r√© volumineux, bien plus que pr√©vu initialement.  Merci √† tous ceux qui ont lu cet endroit.  Si l'un des lecteurs estime possible de laisser vos commentaires dans les commentaires de l'article, ce sera parfait. <br><br>  Si quelque chose n'est pas clair, posez des questions, nous vous r√©pondrons avec plaisir. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aussi, saisissant cette opportunit√©, je veux attirer l'attention de ceux qui sont int√©ress√©s par SObjectizer, que les travaux ont commenc√© sur la prochaine version de SObjectizer dans le cadre de la branche 5.5. </font><font style="vertical-align: inherit;">Bri√®vement sur ce qui est envisag√© pour l'impl√©mentation dans 5.5.23, d√©crit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Plus compl√®tement, mais en anglais, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous pouvez laisser votre avis sur l'une des fonctionnalit√©s propos√©es pour la mise en ≈ìuvre, ou proposer autre chose.</font></font> C'est-√†-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il existe une r√©elle opportunit√© d'influencer le d√©veloppement de SObjectizer. </font><font style="vertical-align: inherit;">De plus, apr√®s la sortie de la v.5.5.23, il pourrait y avoir une pause dans le travail sur le SObjectizer et la prochaine opportunit√© d'inclure quelque chose d'utile dans le SObjectizer 2018 pourrait ne pas √™tre possible.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423497/">https://habr.com/ru/post/fr423497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423487/index.html">Node.js sans node_modules</a></li>
<li><a href="../fr423489/index.html">Je suis m√©decin urgentiste et je veux parler du nouvel √©lectrocardiogramme Apple Watch</a></li>
<li><a href="../fr423491/index.html">PHP Digest n ¬∞ 139 (du 3 au 17 septembre 2018)</a></li>
<li><a href="../fr423493/index.html">Android Go est le futur milliard d'appareils et une limite de 50 Mo. Conf√©rence Yandex</a></li>
<li><a href="../fr423495/index.html">Que contient XGBoost et qu'est-ce que Go a √† voir avec cela?</a></li>
<li><a href="../fr423499/index.html">DevBoy - comment j'ai cr√©√© un projet d'appareil open source et lanc√© un projet sur Kickstarter</a></li>
<li><a href="../fr423501/index.html">Recherche et cr√©ation de style visuel pour un projet de design</a></li>
<li><a href="../fr423503/index.html">Mon exp√©rience de d√©m√©nagement, de vie et d'√©tudes en Allemagne</a></li>
<li><a href="../fr423505/index.html">Zuckerberg vend des actions Facebook pour 13 milliards de dollars afin que ¬´nos enfants ne tombent jamais malades¬ª</a></li>
<li><a href="../fr423507/index.html">Comment √©conomiser de la m√©moire sur les onglets du navigateur, mais ne pas perdre leur contenu. L'exp√©rience de l'√©quipe Yandex.Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>