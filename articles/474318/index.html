<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌸 🤶🏾 👩‍💻 ¿Qué es una mesa de mesa virtual? 👲🏽 🛬 🙊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una vez en Slack, me encontré con un nuevo acrónimo para mi glosario de acrónimos C ++ : "VTT". Godbolt : 



test.o: In function `MyClass': test.cc:3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿Qué es una mesa de mesa virtual?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474318/">  Una vez en Slack, me encontré con un nuevo acrónimo para mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">glosario de acrónimos C ++</a> : "VTT".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Godbolt</a> : <br><br><pre><code class="plaintext hljs">test.o: In function `MyClass': test.cc:3: undefined reference to `VTT for MyClass'</code> </pre> <br>  "VTT" en este contexto significa "tabla de tabla virtual".  Esta es una estructura de datos auxiliar utilizada (en Itanium C ++ ABI) al crear algunas clases base que se heredan de las clases base virtuales.  Los VTT siguen las mismas reglas de diseño que las tablas virtuales (vtable) y escriben información (typeinfo), por lo que si obtiene el error anterior, puede sustituir mentalmente "vtable" por "VTT" y comenzar la depuración.  (Lo más probable es que haya dejado la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">función clave de la</a> clase sin definir).  Para ver por qué es necesario VTT, o una estructura similar, comencemos con lo básico. <br><a name="habracut"></a><br><h3>  Orden de diseño para herencia no virtual </h3><br>  Cuando tenemos una jerarquía de herencia, las clases base se construyen a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">partir de las más básicas</a> .  Para construir Charlie, primero debemos construir sus clases para padres MrsBucket y MrBucket, recursivamente, para construir MrBucket, primero debemos construir sus clases para padres GrandmaJosephine y GrandpaJoe. <br><br>  Así: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ABCDE</span></span></code> </pre> <br><h3>  Orden de diseño para clases base virtuales </h3><br>  ¡Pero la herencia virtual confunde todas las cartas!  Con la herencia virtual, podemos tener una jerarquía en forma de diamante en la que dos clases principales diferentes pueden compartir un ancestro común. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">G</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> M, F {}; <span class="hljs-comment"><span class="hljs-comment">//     // GMFE</span></span></code> </pre> <br>  En la última sección, cada constructor fue responsable de llamar al constructor de su clase base.  Pero ahora tenemos herencia virtual, y los constructores M y F deben saber de alguna manera que no es necesario construir G, porque es común.  Si M y F fueran responsables de construir los objetos base en este caso, el objeto base común se construiría dos veces, lo que no es muy bueno. <br><br>  Para trabajar con subobjetos de herencia virtual, Itanium C ++ ABI divide cada constructor en dos partes: el constructor de objetos base y el constructor de objetos completos.  El constructor del objeto base es responsable de construir todos los subobjetos de herencia no virtuales (y sus subobjetos, e instalar su vptr en su vtable, y ejecutar el código entre llaves en código C ++).  El constructor del objeto completo, que se llama cada vez que crea el objeto C ++ completo, es responsable de construir todos los subobjetos de la herencia virtual del objeto derivado y luego hace el resto. <br><br>  Considere la diferencia entre nuestro ejemplo ABCDE de la sección anterior y el siguiente ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ACBDE</span></span></code> </pre> <br>  El constructor del objeto completo E primero llama a los constructores del objeto base de los subobjetos virtuales A y C;  entonces se llama a los constructores del objeto de herencia no virtual base B y D. B y D ya no son responsables de construir A y C, respectivamente. <br><br><h3>  Diseñando tablas vtable </h3><br>  Supongamos que tenemos una clase con algunos métodos virtuales, por ejemplo, ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> {</span></span> Cat() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"meow"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> roar = <span class="hljs-string"><span class="hljs-string">"roar"</span></span>; Lion() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ roar += <span class="hljs-string"><span class="hljs-string">'!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(roar.c_str()); } };</code> </pre> <br>  Cuando construimos Lion, comenzamos construyendo el subobjeto básico de Cat.  El constructor de Cat llama poke ().  En este punto, solo tenemos un objeto Cat: aún no hemos inicializado los datos de miembros que se necesitan para hacer el objeto Lion.  Si el constructor Cat llama a Lion :: poke (), puede intentar cambiar el miembro no inicializado de std :: string roar y obtenemos UB.  Entonces, el estándar C ++ nos obliga a hacer esto en el constructor Cat, ¡una llamada al método virtual poke () debería llamar a Cat :: poke (), no a Lion :: poke ()! <br><br>  No hay problema  El compilador simplemente hace que Cat :: Cat () (tanto la versión para el objeto base como la versión para el objeto completo) comience configurando el vptr del objeto en la vtable del objeto Cat.  Lion :: Lion () llamará a Cat :: Cat (), y luego restablecerá vptr al puntero a la tabla vtable para el objeto Cat dentro de Lion, antes de ejecutar el código entre paréntesis.  No hay problema! <br><br><h3>  Compensación de herencia virtual </h3><br>  Deje que Cat virtualmente herede de Animal.  Luego, la tabla vtable para Cat almacena no solo los punteros de función para las funciones de miembro virtual de Cat, sino también el desplazamiento del subobjeto Animal dentro de Cat.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Godbolt</a> .) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data = <span class="hljs-string"><span class="hljs-string">"hi"</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Animal { Cat() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(data); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nermal</span></span></span><span class="hljs-class"> :</span></span> Cat {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Garfield</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; };</code> </pre> <br>  El constructor Cat consulta al miembro Animal :: data.  Si este objeto Cat es el subobjeto base del objeto Nermal, entonces sus datos de miembro están en el desplazamiento 8, justo detrás de vptr.  Pero si el objeto Cat es el subobjeto subyacente del objeto Garfield, entonces los datos del miembro están en el desplazamiento 16, detrás de vptr y Garfield :: padding.  Para hacer frente, Itanium ABI almacena los desplazamientos de los objetos de base virtuales en la tabla virtual del objeto Cat.  La tabla para Cat-in-Nermal conserva el hecho de que Animal, el subobjeto de Cat subyacente, se almacena en el desplazamiento 8;  La tabla para Cat-in-Garfield conserva el hecho de que Animal, el subobjeto de Cat subyacente, se almacena en el desplazamiento 16. <br><br>  Ahora combine esto con la sección anterior.  El compilador debe verificar que Cat :: Cat () (tanto la versión del objeto base como la versión del objeto completo) comience instalando vptr en la vtable para Cat-in-Nermal o en la vtable para Cat-in-Garfield, según el tipo ¡la más derivada facilidad!  ¿Pero cómo funciona? <br><br>  El constructor del objeto completo para el objeto más derivado debe precalcular a qué tabla vtable desea que haga referencia el vptr del subobjeto base durante el tiempo de construcción del objeto, y luego el constructor del objeto completo para el objeto más derivado debe pasar esta información al constructor del objeto base del subobjeto base como un parámetro oculto!  Veamos el código generado para Cat :: Cat () ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs">_ZN3CatC1Ev: #    Cat movq $_ZTV3Cat+<span class="hljs-number"><span class="hljs-number">24</span></span>, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = &amp;vtable-for-Cat; retq _ZN3CatC2Ev: #     Cat movq (%rsi), %rax # fetch a value from rsi movq %rax, (%rdi) # this-&gt;vptr = *rsi; retq</span></span></code> </pre> <br>  ¡El constructor del objeto base acepta no solo este parámetro oculto en% rdi, sino también el parámetro VTT oculto en% rsi!  El constructor del objeto base carga la dirección desde (% rsi) y almacena la dirección en la tabla v del objeto Cat. <br><br>  Quien llame al constructor del objeto base Cat es responsable de predecir qué dirección Cat :: Cat () debe escribirse en vptr y de establecer el puntero en (% rsi) en esa dirección. <br><br><h3>  ¿Por qué necesitamos otro nivel de identidad? </h3><br>  Considere el constructor de un objeto Nermal completo. <br><br><pre> <code class="cpp hljs">_ZN3CatC2Ev: #    <span class="hljs-function"><span class="hljs-function">Cat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movq</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rax #    rsi movq %rax, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function"> </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta"># this-&gt;vptr = *rsi; retq _ZN6NermalC1Ev: #    Nermal pushq %rbx movq %rdi, %rbx movl $_ZTT6Nermal+8, %esi # %rsi = &amp;VTT-for-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq _ZTT6Nermal: .quad _ZTV6Nermal+24 # vtable-for-Nermal .quad _ZTC6Nermal0_3Cat+24 # construction-vtable-for-Cat-in-Nermal</span></span></span></span></code> </pre> <br>  ¿Por qué se encuentra _ZTC6Nermal0_3Cat + 24 en la sección de datos y su dirección se pasa a% rsi, en lugar de simplemente pasar directamente a _ZTC6Nermal0_3Cat + 24? <br><br><pre> <code class="cpp hljs">#   ? _ZN3CatC2Ev: #     Cat movq %rsi, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = rsi; retq _ZN6NermalC1Ev: #     Nermal pushq %rbx movq %rdi, %rbx movl $_ZTC6Nermal0_3Cat+24, %esi # %rsi = &amp;construction-vtable-for-Cat-in-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq</span></span></code> </pre> <br>  ¡Esto se debe a que podemos tener varios niveles de herencia!  En cada nivel de herencia, el constructor del objeto base debe establecer vptr y luego, posiblemente, pasar el control más abajo en la cadena al siguiente constructor base, que puede establecer vptrs en algún otro valor.  Esto implica una lista o una tabla de punteros a vtable. <br><br>  Aquí hay un ejemplo concreto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VB</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> member_of_vb = <span class="hljs-number"><span class="hljs-number">42</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Grandparent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> VB { Grandparent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> :</span></span> Grandparent { Parent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gretel</span></span></span><span class="hljs-class"> :</span></span> Parent { Gretel() : VB{<span class="hljs-number"><span class="hljs-number">1000</span></span>} {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hansel</span></span></span><span class="hljs-class"> :</span></span> Parent { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; Hansel() : VB{<span class="hljs-number"><span class="hljs-number">2000</span></span>} {} };</code> </pre> <br>  El objeto constructor base Grandparent debe establecer su vptr en Grandparent, algo más, que es la clase más derivada.  El constructor del objeto base Parent primero debe llamar a Grandparent :: Grandparent () con el% rsi apropiado y luego establecer vptr en Parent, algo más, que es la clase más derivada.  Una forma de implementar esto para Gretel: <br><br><pre> <code class="cpp hljs">Gretel::Gretel() [  ]: pushq %rbx movq %rdi, %rbx movl $<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) <span class="hljs-meta"><span class="hljs-meta"># imm = 0x3E8 movl $VTT for Gretel+8, %esi callq Parent::Parent() [  ] movq $vtable for Gretel+24, (%rbx) popq %rbx retq VTT for Gretel: .quad vtable for Gretel+24 .quad construction vtable for Parent-in-Gretel+24 .quad construction vtable for Grandparent-in-Gretel+24</span></span></code> </pre> <br>  Puede ver en Godbolt que el constructor del objeto base de la clase Parent primero llama a Grandparent :: Grandparent () con% rsi + 8, luego establece su propio vptr en (% rsi).  Entonces, aquí estamos usando el hecho de que Gretel, por así decirlo, estableció cuidadosamente un camino de migas de pan a lo largo del cual todas sus clases base siguieron durante la construcción. <br><br>  El mismo VTT se usa en el destructor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Godbolt</a> ).  Hasta donde yo sé, la fila nula de la tabla VTT nunca se usa.  El constructor de Gretel carga la tabla vtable para Gretel + 24 en vptr, pero sabe que esta dirección es estática, nunca necesita cargarse desde VTT.  Creo que la fila cero de la tabla se conservó simplemente por razones históricas.  (Y, por supuesto, el compilador no puede simplemente tirarlo, porque será una violación de Itanium ABI y será imposible vincularlo a un código antiguo que se adhiere a Itanium-ABI). <br><br>  Eso es todo, miramos una tabla de tablas virtuales, o VTT. <br><br><h3>  Más información </h3><br>  Puede encontrar información de VTT en estos lugares: <br><br>  StackOverflow: “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Cuál es el VTT para una clase?</a>  " <br>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=http://web.archive.org/web/20190930143149/">Notas de VTable sobre herencia múltiple en el compilador GCC C ++ v4.0.1</a> " (Morgan Deters, 2005) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El Itanium C ++ ABI</a> , sección "Orden VTT" <br><br>  Finalmente, tengo que reiterar que VTT es una característica de Itanium C ++ ABI, y se usa en Linux, OSX, etc.  El MSVC ABI utilizado en Windows no tiene VTT y utiliza un mecanismo completamente diferente para la herencia virtual.  (Hasta ahora) no sé casi nada sobre MSVC ABI, pero tal vez algún día lo descubra todo y escriba una publicación al respecto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474318/">https://habr.com/ru/post/474318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474306/index.html">Haga que los estilos de apuntar, enfocar y estado activo sean diferentes.</a></li>
<li><a href="../474308/index.html">Tipos de API HTTP escritas en Python: experiencia de Instagram</a></li>
<li><a href="../474310/index.html">¿Hay números aleatorios en CSS?</a></li>
<li><a href="../474312/index.html">Instalación de la GUI en Windows Server Core</a></li>
<li><a href="../474316/index.html">Coche eléctrico hecho en casa, parte 1. Cómo comenzó todo y cómo obtuve 1,000,000 de visitas en youtube</a></li>
<li><a href="../474320/index.html">DDD Crisis comunitaria</a></li>
<li><a href="../474322/index.html">ScalaConf 2019 - John Preacher, Holy Grail y Professor Haskell</a></li>
<li><a href="../474324/index.html">¿Por qué gira el sol alrededor de la tierra?</a></li>
<li><a href="../474326/index.html">Comprender la diferencia entre CI y CD: "si algo causa dolor, hágalo con más frecuencia"</a></li>
<li><a href="../474330/index.html">El resumen de materiales interesantes para el desarrollador móvil # 320 (28 de octubre - 3 de noviembre)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>