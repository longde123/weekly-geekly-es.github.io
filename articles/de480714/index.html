<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåø ü¶Ö ‚úäüèª So f√ºgen Sie FFmpeg einen Codec hinzu üöΩ üîá üè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FFmpeg ist ein gro√üartiges Open Source-Projekt, eine Art Multimedia-Enzyklop√§die. Mit FFmpeg k√∂nnen Sie eine Vielzahl von Computer-Multimedia-Aufgaben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So f√ºgen Sie FFmpeg einen Codec hinzu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480714/"><hr><p>  FFmpeg ist ein gro√üartiges Open Source-Projekt, eine Art Multimedia-Enzyklop√§die.  Mit FFmpeg k√∂nnen Sie eine Vielzahl von Computer-Multimedia-Aufgaben l√∂sen.  Trotzdem besteht manchmal die Notwendigkeit, FFmpeg zu erweitern.  Die Standardmethode besteht darin, √Ñnderungen am Projektcode vorzunehmen und anschlie√üend die neue Version zu kompilieren.  Der Artikel beschreibt, wie ein neuer Codec hinzugef√ºgt wird.  Einige Funktionen zum Anschlie√üen externer Funktionen an FFmpeg werden ebenfalls ber√ºcksichtigt.  Wenn Sie keinen Codec hinzuf√ºgen m√ºssen, kann der Artikel hilfreich sein, um die Architektur von FFmpeg-Codecs und ihre Einstellungen besser zu verstehen.  Es wird davon ausgegangen, dass der Leser mit der Architektur von FFmpeg, dem Kompilierungsprozess von FFmpeg, vertraut ist und √ºber Programmiererfahrung mit der FFmpeg-API verf√ºgt.  Die Beschreibung gilt f√ºr FFmpeg 4.2 "Ada", August 2019. <br></p><hr><a name="habracut"></a><br><h1>  Inhaltsverzeichnis </h1><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><p> <a href="https://habr.com/ru/post/480714/">Einleitung</a> <br>  <a href="https://habr.com/ru/post/480714/">1. Codec-Identifikation</a> <br>  <a href="https://habr.com/ru/post/480714/">1.1.</a>  <a href="https://habr.com/ru/post/480714/">Codec-ID</a> <br>  <a href="https://habr.com/ru/post/480714/">1.2.</a>  <a href="https://habr.com/ru/post/480714/">Codec</a> <br>  <a href="https://habr.com/ru/post/480714/">2. Hinzuf√ºgen eines neuen Codecs zu FFmpeg</a> <br>  <a href="https://habr.com/ru/post/480714/">3. Detaillierte Beschreibung des Kontexts und der erforderlichen Funktionen</a> <br>  <a href="https://habr.com/ru/post/480714/">3.1.</a>  <a href="https://habr.com/ru/post/480714/">Codec-Kontext</a> <br>  <a href="https://habr.com/ru/post/480714/">3.2.</a>  <a href="https://habr.com/ru/post/480714/">Funktionen</a> <br>  <a href="https://habr.com/ru/post/480714/">3.3.</a>  <a href="https://habr.com/ru/post/480714/">Zeitstempel</a> <br>  <a href="https://habr.com/ru/post/480714/">3.4.</a>  <a href="https://habr.com/ru/post/480714/">Andere vom Codec verwendete Funktionen</a> <br>  <a href="https://habr.com/ru/post/480714/">4. Externe Implementierung des Codecs</a> <br>  <a href="https://habr.com/ru/post/480714/">4.1.</a>  <a href="https://habr.com/ru/post/480714/">Externer Funktionsanschluss</a> <br>  <a href="https://habr.com/ru/post/480714/">4.2.</a>  <a href="https://habr.com/ru/post/480714/">Externer Decoder</a> <br>  <a href="https://habr.com/ru/post/480714/">Fazit</a> <br>  <a href="https://habr.com/ru/post/480714/">Ressourcen</a> <br></p><br></div></div><br><a name="id-introdaction"></a><h1>  Einleitung </h1><br><p>  Der Codec (Codec, stammt aus der Kombination der Begriffe COder und DECoder) ist ein sehr gebr√§uchlicher Begriff und seine Bedeutung variiert, wie in solchen F√§llen h√§ufig, je nach Kontext etwas.  Die prim√§re Bedeutung ist Software oder Hardware zum Komprimieren / Dekomprimieren von Mediendaten.  Anstelle der Begriffe Komprimierung / Dekomprimierung werden h√§ufig die Begriffe Kodierung / Dekodierung verwendet.  In einigen F√§llen wird unter einem Codec jedoch normalerweise einfach ein Komprimierungsformat verstanden (sie bezeichnen auch das Codec-Format), unabh√§ngig von den f√ºr die Komprimierung / Dekomprimierung verwendeten Mitteln.  Mal sehen, wie der Begriff Codec in FFmpeg verwendet wird. <br></p><br><a name="id-1"></a><br><h1>  1. Codec-Identifikation </h1><br><p>  FFmpeg-Codecs werden in der <b>libavcodec-</b> Bibliothek kompiliert. <br></p><br><a name="id-1-1"></a><br><h2>  1.1.  Codec-ID </h2><br><p> Die <code>enum AVCodecID</code> in der <code>enum AVCodecID</code> <code>libavcodec/avcodec.h</code> definiert.  Jedes Element dieser Aufz√§hlung gibt das Komprimierungsformat an.  Elemente dieser Aufz√§hlung m√ºssen die Form <code>AV_CODEC_ID_XXX</code> , wobei <code>XXX</code> eindeutige Codec- <code>AV_CODEC_ID_XXX</code> Name in Gro√übuchstaben ist.  Hier sind Beispiele f√ºr Codec- <code>AV_CODEC_ID_H264</code> : <code>AV_CODEC_ID_H264</code> , <code>AV_CODEC_ID_AAC</code> .  F√ºr eine detailliertere Beschreibung der Codec- <code>AVCodecDescriptor</code> verwenden Sie die <code>AVCodecDescriptor</code> Struktur (deklariert in <code>libavcodec/avcodec.h</code> , abgek√ºrzt): <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodecDescriptor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVCodecID id; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVMediaType type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *long_name; <span class="hljs-comment"><span class="hljs-comment">// ... } AVCodecDescriptor;</span></span></code> </pre> <br><p>  Das Schl√ºsselelement dieser Struktur ist <code>id</code> . Die √ºbrigen Elemente enthalten zus√§tzliche Informationen zur Codec- <code>id</code> .  Jeder Codec-Bezeichner ist eindeutig einem Medientyp ( <code>type</code> ) zugeordnet und verf√ºgt √ºber einen eindeutigen Namen ( <code>name</code> ), der in Kleinbuchstaben geschrieben ist.  Ein Array vom Typ <code>AVCodecDescriptor</code> in der Datei <code>libavcodec/codec_desc.c</code> <code>AVCodecDescriptor</code> .  F√ºr jede Codec-ID gibt es ein entsprechendes Array-Element.  Elemente dieses Arrays sollten nach <code>id</code> Werten sortiert werden, da die bin√§re Suche f√ºr die Suche nach Elementen verwendet wird.  Um Informationen √ºber die Codec-ID zu erhalten, k√∂nnen Sie die folgenden Funktionen verwenden: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVCodecDescriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_descriptor_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVCodecDescriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_descriptor_get_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">enum</span></span></span><span class="hljs-function"> AVMediaType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_get_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID codec_id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>;</code> </pre> <br><a name="id-1-2"></a><br><h2>  1.2.  Codec </h2><br><p>  Der Codec selbst - eine Reihe von Tools, die zum Codieren / Decodieren von Mediendaten erforderlich sind, kombiniert die <code>AVCodec</code> Struktur (deklariert in <code>libavcodec/avcodec.h</code> ).  Hier ist seine gek√ºrzte Version, die weiter unten noch ausf√ºhrlicher besprochen wird. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *long_name; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVMediaType type; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVCodecID id; <span class="hljs-comment"><span class="hljs-comment">// ... } AVCodec;</span></span></code> </pre> <br><p>  Das wichtigste Mitglied dieser Struktur ist <code>id</code> , die Codec- <code>id</code> Es gibt auch ein Mitglied, das den Medientyp ( <code>type</code> ) definiert, dessen Wert jedoch mit dem Wert desselben Mitglieds aus <code>AVCodecDescriptor</code> .  Codecs werden in zwei Kategorien unterteilt: Codierer, die Medien komprimieren oder codieren, und Decodierer, die den umgekehrten Vorgang ausf√ºhren - Dekomprimieren oder Decodieren.  (In russischen Texten verwendet der Encoder manchmal anstelle des Begriffs <code>AVCodec</code> aus dem Englischen - dem Encoder.) In <code>AVCodec</code> gibt es kein spezielles <code>AVCodec</code> , das die Codec-Kategorie definiert (obwohl die Kategorie indirekt mit den Funktionen <code>av_codec_is_encoder()</code> und <code>av_codec_is_decoder()</code> , wird diese Kategorie bei der Registrierung festgelegt. Wie dies gemacht wird, wird im Folgenden gezeigt: Mehrere Codecs k√∂nnen dieselbe Codec-ID haben. Wenn sie dieselbe Kategorie haben, m√ºssen sie sich nach dem Namen (Mitgliedsnamen) unterscheiden. Ein Codierer und ein Decodierer, die dieselbe Codec-ID haben, k√∂nnen dies einen haben  Derselbe Name, der auch mit dem Namen der Codec-ID √ºbereinstimmen kann (diese √úbereinstimmungen sind jedoch optional.) In einer solchen Situation kann es zu Verwirrung kommen, aber es ist nichts zu tun, Sie m√ºssen klar verstehen, zu welcher Entit√§t der Name geh√∂rt Der Codec muss eindeutig sein. Um nach registrierten Codecs zu suchen, gibt es Funktionen: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_encoder_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_decoder_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_encoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_decoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>;</code> </pre> <br><p>  Da mehrere Codecs denselben Bezeichner haben k√∂nnen, geben die letzten beiden Funktionen einen von ihnen zur√ºck, der als Standard-Codec f√ºr einen bestimmten Codec-Bezeichner angesehen werden kann. <br></p><br><p>  Mit dem Befehl kann eine Liste aller registrierten Codecs angefordert werden <br></p><br><p> <code>ffmpeg -codecs &gt;codecs.txt</code> <br> </p><br><p>  Nach dem Ausf√ºhren des Befehls enth√§lt die Datei <code>codecs.txt</code> diese Liste.  Jede Codec-ID wird durch einen separaten Datensatz (Zeile) dargestellt.  Hier zum Beispiel der Eintrag f√ºr die Codec-Kennung <code>AV_CODEC_ID_H264</code> : <br></p><br><p> <code>DEV.LS <br> h264 <br> H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 <br> (decoders: h264 h264_qsv h264_cuvid) <br> (encoders: libx264 libx264rgb h264_amf h264_nvenc h264_qsv nvenc nvenc_h264) <br></code> <br></p><br><p>  Zu Beginn der Aufnahme stehen spezielle Zeichen zur Verf√ºgung, die die gemeinsamen Merkmale dieser Codec-Kennung bestimmen: <code>D</code> - registrierte Decoder, <code>E</code> - registrierte Encoder, <code>V</code> - f√ºr Video verwendet, <code>L</code> - M√∂glichkeit einer verlustbehafteten Komprimierung, <code>S</code> - M√∂glichkeit einer verlustfreien Komprimierung.  Als n√§chstes folgt der Name der Codec- <code>h264</code> ( <code>h264</code> ), gefolgt von einem langen Namen der Codec- <code>h264</code> ( <code>H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10</code> ) und einer Liste der Namen registrierter Decoder und Encoder. <br></p><br><a name="id-2"></a><br><h1>  2. Hinzuf√ºgen eines neuen Codecs zu FFmpeg </h1><br><p>  Wir werden die Prozedur zum Hinzuf√ºgen eines neuen Codecs zu FFmpeg am Beispiel eines Audio-Codecs betrachten, den wir <code>FROX</code> nennen. <br></p><br><p>  <b>Schritt 1. F√ºgen Sie der <code>enum AVCodecID</code> ein neues Element <code>enum AVCodecID</code> .</b> <br></p><br><p>  Diese Auflistung befindet sich in der <code>libavcodec/avcodec.h</code> .  Beim Hinzuf√ºgen m√ºssen Sie die folgenden Regeln beachten: <br></p><br><ol><li>  Der Wert eines Elements darf nicht mit den Werten vorhandener Aufz√§hlungselemente √ºbereinstimmen. </li><li>  √Ñndern Sie nicht die Werte vorhandener Aufz√§hlungselemente. </li><li>  Ver√∂ffentlichen Sie einen neuen Wert in einer Gruppe √§hnlicher Codecs. </li></ol><br><p>  Gem√§√ü der Vorlage sollte der Bezeichner dieses Elements <code>AV_CODEC_ID_FROX</code> .  <code>AV_CODEC_ID_PCM_S64LE</code> es vor <code>AV_CODEC_ID_PCM_S64LE</code> und geben Sie den Wert <code>0x10700</code> . <br></p><br><p>  <b>Schritt 2. F√ºgen Sie das Element dem Array <code>codec_descriptors</code> (Datei <code>libavcodec/codec_desc.c</code> ).</b> <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodecDescriptor codec_descriptors[] = { <span class="hljs-comment"><span class="hljs-comment">// ... { .id = AV_CODEC_ID_FROX, .type = AVMEDIA_TYPE_AUDIO, .name = "frox", .long_name = NULL_IF_CONFIG_SMALL("FROX audio"), .props = AV_CODEC_PROP_LOSSLESS, }, // ... };</span></span></code> </pre> <br><p>  Sie m√ºssen das Element an der richtigen Stelle einf√ºgen. Die Monotonie der Array-Elemente durch den <code>id</code> Wert sollte nicht verletzt werden. <br></p><br><p>  <b>Schritt 3. Definieren Sie die Instanzen von <code>AVCodec</code> separat f√ºr den Encoder und den Decoder.</b> <br></p><br><p>  Dazu m√ºssen Sie zun√§chst die Struktur f√ºr den Kontext des Codecs und mehrere Funktionen festlegen, mit denen die eigentliche Codierung / Decodierung und einige andere erforderliche Vorg√§nge ausgef√ºhrt werden.  In diesem Abschnitt werden diese Definitionen √§u√üerst schematisch vorgenommen, eine detailliertere Beschreibung erfolgt sp√§ter.  Wir werden den Code in die Datei <code>libavcodec/frox.c</code> <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"avcodec.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// context typedef struct FroxContext { // ... } FroxContext; // decoder static int frox_decode_init(AVCodecContext *codec_ctx) { return -1; } static int frox_decode_close(AVCodecContext *codec_ctx) { return -1; } static int frox_decode(AVCodecContext *codec_ctx, void* outdata, int *outdata_size, AVPacket *pkt) { return -1; } AVCodec ff_frox_decoder = { .name = "frox_dec", .long_name = NULL_IF_CONFIG_SMALL("FROX audio decoder"), .type = AVMEDIA_TYPE_AUDIO, .id = AV_CODEC_ID_FROX, .priv_data_size = sizeof(FroxContext), .init = frox_decode_init, .close = frox_decode_close, .decode = frox_decode, .capabilities = AV_CODEC_CAP_LOSSLESS, .sample_fmts = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_FLT, AV_SAMPLE_FMT_NONE}, .channel_layouts = (const int64_t[]) {AV_CH_LAYOUT_MONO, 0 }, }; // encoder static int frox_encode_init(AVCodecContext *codec_ctx) { return -1; } static int frox_encode_close(AVCodecContext *codec_ctx) { return -1; } static int frox_encode(AVCodecContext *codec_ctx, AVPacket *pkt, const AVFrame *frame, int *got_pkt_ptr) { return -1; } AVCodec ff_frox_encoder = { .name = "frox_enc", .long_name = NULL_IF_CONFIG_SMALL("FROX audio encoder"), .type = AVMEDIA_TYPE_AUDIO, .id = AV_CODEC_ID_FROX, .priv_data_size = sizeof(FroxContext), .init = frox_encode_init, .close = frox_encode_close, .encode2 = frox_encode, .sample_fmts = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE}, .channel_layouts = (const int64_t[]) {AV_CH_LAYOUT_MONO, 0 }, };</span></span></span></span></code> </pre> <br><p>  Der Einfachheit halber haben in diesem Beispiel der Codierer und der Decodierer denselben Kontext - <code>FroxContext</code> , aber meistens haben der Codierer und der Decodierer unterschiedliche Kontexte.  Beachten Sie auch, dass <code>AVCodec</code> einem speziellen Muster folgen m√ºssen. <br></p><br><p>  <b>Schritt 4. F√ºgen <code>AVCodec</code> der Registrierungsliste Instanzen von <code>AVCodec</code> .</b> <br></p><br><p>  Gehen Sie zur Datei <code>libavcodec/allcodecs.c</code> .  Am Anfang dieser Datei befindet sich eine Liste der Deklarationen aller registrierten Codecs.  F√ºgen Sie unsere Codecs zu dieser Liste hinzu: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> AVCodec ff_frox_decoder; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> AVCodec ff_frox_encoder;</code> </pre> <br><p>  W√§hrend der Ausf√ºhrung findet das <code>configure</code> Skript alle derartigen Deklarationen und generiert die <code>libavcodec/codec_list.c</code> , die ein Array von Zeigern auf die in <code>libavcodec/allcodecs.c</code> deklarierten Codecs <code>libavcodec/allcodecs.c</code> .  Nach dem Ausf√ºhren des Skripts in der Datei <code>libavcodec/codec_list.c</code> wir: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodec * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> codec_list[] = { <span class="hljs-comment"><span class="hljs-comment">// ... &amp;ff_frox_encoder, // ... &amp;ff_frox_decoder, // ... NULL };</span></span></code> </pre> <br><p>  W√§hrend der Ausf√ºhrung des <code>configure</code> Skripts wird auch die <code>config.h</code> Datei <code>config.h</code> , in der sich die Deklarationen befinden <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONFIG_FROX_DECODER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONFIG_FROX_ENCODER 1</span></span></code> </pre> <br><p>  <b>Schritt 5. Bearbeiten Sie <code>libavcodec/Makefile</code></b> <br></p><br><p>  √ñffnen Sie <code>libavcodec/Makefile</code> .  Wir finden den Abschnitt <code># decoders/encoders</code> und f√ºgen dort hinzu <br></p><br><pre> <code class="cpp hljs">OBJS-$(CONFIG_FROX_DECODER) += frox.o OBJS-$(CONFIG_FROX_ENCODER) += frox.o</code> </pre> <br><p>  <b>Schritt 6. Bearbeiten Sie den Code des Multiplexers und Demultiplexers.</b> <br></p><br><p>  Der Multiplexer (Muxer) und der Demultiplexer (Demuxer) m√ºssen den neuen Codec ‚Äûkennen‚Äú.  Beim Aufzeichnen ist es erforderlich, die Identifizierungsinformationen f√ºr diesen Codec aufzuzeichnen, w√§hrend beim Lesen die Kennung des Codec aus den Identifizierungsinformationen ermittelt wird.  <code>matroska</code> m√ºssen Sie f√ºr das <code>matroska</code> Format ( <code>*.mkv</code> ) tun. <br></p><br><p>  1. <code>libavformat/matroska.c</code> in der Datei <code>libavformat/matroska.c</code> dem Array <code>libavformat/matroska.c</code> ein Element f√ºr den neuen Codec <code>libavformat/matroska.c</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CodecTags ff_mkv_codec_tags[] = { <span class="hljs-comment"><span class="hljs-comment">// ... {"A_FROX", AV_CODEC_ID_FROX}, // ... };</span></span></code> </pre> <br><p>  String <code>"A_FROX"</code> und wird vom Multiplexer als Identifikationsinformation in die Datei geschrieben.  In diesem Array ist es der Codec-Kennung zugeordnet, daher kann der Demultiplexer sie beim Lesen leicht ermitteln.  Der Demultiplexer schreibt die Codec- <code>codec_id</code> Mitglied <code>codec_id</code> Struktur <code>codec_id</code> .  Ein Zeiger auf diese Struktur ist ein Mitglied der <code>AVStream</code> Struktur. <br></p><br><p>  2. <code>libavformat/matroskaenc.c</code> in der Datei <code>libavformat/matroskaenc.c</code> das Element zum Array <code>additional_audio_tags</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodecTag additional_audio_tags[] = { <span class="hljs-comment"><span class="hljs-comment">// ... { AV_CODEC_ID_FROX, 0XFFFFFFFF }, // ... };</span></span></code> </pre> <br><p>  Also ist alles fertig.  F√ºhren Sie zuerst das <code>configure</code> .  Danach m√ºssen Sie sicherstellen, dass die oben beschriebenen √Ñnderungen in den Dateien <code>libavcodec/codec_list.c</code> und <code>config.h</code> vorgenommen werden.  Dann k√∂nnen Sie die Kompilierung ausf√ºhren: <br></p><br><p> <code>make clean <br> make <br></code> <br></p><br><p>  Wenn die Kompilierung <code>ffmpeg.exe</code> , wird die ausf√ºhrbare Datei <code>ffmpeg</code> (oder <code>ffmpeg.exe</code> , wenn das <code>ffmpeg.exe</code> Windows ist) angezeigt.  F√ºhren Sie den Befehl aus <br></p><br><p> <code>./ffmpeg -codecs &gt;codecs.txt <br></code> <br></p><br><p>  und stellen Sie sicher, dass FFmpeg unsere neuen Codecs "sieht", wir finden den Eintrag in der Datei <code>codecs.txt</code> <br></p><br><p> <code>DEA..S frox FROX audio (decoders: frox_dec) (encoders: frox_enc) <br></code> <br></p><br><a name="id-3"></a><br><h1>  3. Detaillierte Beschreibung des Kontexts und der erforderlichen Funktionen </h1><br><p>  In diesem Abschnitt beschreiben wir detaillierter, wie die Struktur des Codec-Kontexts und die erforderlichen Funktionen aussehen k√∂nnen. <br></p><br><a name="id-3-1"></a><br><h2>  3.1.  Codec-Kontext </h2><br><p>  Der Codec-Kontext unterst√ºtzt m√∂glicherweise die Installation von Optionen.  Bei Encodern wird diese Unterst√ºtzung h√§ufig genug verwendet, bei Decodern seltener.  Die Struktur, die die Installation von Optionen unterst√ºtzt, sollte als erstes Mitglied einen Zeiger auf die <code>AVClass</code> Struktur und dann auf die Optionen selbst haben. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libavutil/opt.h"</span></span></span><span class="hljs-meta"> typedef struct FroxContext { const AVClass *av_class; int frox_int; char *frox_str; uint8_t *frox_bin; int bin_size; } FroxContext;</span></span></code> </pre> <br><p>  Als n√§chstes m√ºssen Sie ein Array vom Typ <code>AVOption</code> , von dem jedes Element eine bestimmte Option beschreibt. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVOption frox_options[] = { { <span class="hljs-string"><span class="hljs-string">"frox_int"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of int type."</span></span>, offsetof(FroxContext, frox_int), AV_OPT_TYPE_INT, { .i64 = <span class="hljs-number"><span class="hljs-number">-1</span></span> }, <span class="hljs-number"><span class="hljs-number">1</span></span>, SHRT_MAX }, { <span class="hljs-string"><span class="hljs-string">"frox_str"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of string type."</span></span>, offsetof(FroxContext, frox_str), AV_OPT_TYPE_STRING }, { <span class="hljs-string"><span class="hljs-string">"frox_bin"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of binary type."</span></span>, offsetof(FroxContext, frox_bin), AV_OPT_TYPE_BINARY }, { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }, };</code> </pre> <br><p>  F√ºr jede Option m√ºssen Sie einen Namen, eine Beschreibung, einen Versatz in der Struktur und einen Typ definieren.  Sie k√∂nnen auch einen Standardwert und f√ºr Ganzzahloptionen einen Bereich g√ºltiger Werte definieren. <br></p><br><p>  Als N√§chstes m√ºssen Sie eine Instanz vom Typ <code>AVClass</code> . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVClass frox_class = { .class_name = <span class="hljs-string"><span class="hljs-string">"FroxContext"</span></span>, .item_name = av_default_item_name, .option = frox_options, .version = LIBAVUTIL_VERSION_INT, };</code> </pre> <br><p>  Ein Zeiger auf diese Instanz muss verwendet werden, um das entsprechende <code>AVCodec</code> Mitglied zu initialisieren. <br></p><br><pre> <code class="cpp hljs">AVCodec ff_frox_decoder = { <span class="hljs-comment"><span class="hljs-comment">// ... .priv_data_size = sizeof(FroxContext), .priv_class = &amp;frox_class, // ... }; AVCodec ff_frox_encoder = { // ... .priv_data_size = sizeof(FroxContext), .priv_class = &amp;frox_class, // ... };</span></span></code> </pre> <br><p>  Jetzt beim Ausf√ºhren der Funktion <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AVCodecContext *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_alloc_context3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodec *codec)</span></span></span></span>;</code> </pre> <br><p>  Eine Instanz der <code>AVCodecContext</code> Struktur wird <code>AVCodecContext</code> und das <code>codec</code> Mitglied wird initialisiert.  Als n√§chstes wird basierend auf dem Wert <code>codec-&gt;priv_data_size</code> der erforderliche Speicher f√ºr die <code>FroxContext</code> Instanz zugewiesen, wobei der Wert <code>codec-&gt;priv_class</code> erste Mitglied dieser Instanz wird initialisiert und anschlie√üend die Funktion <code>av_opt_set_defaults()</code> aufgerufen, mit der die Standardwerte f√ºr die Optionen festgelegt werden.  Ein Zeiger auf eine Instanz von <code>FroxContext</code> ist √ºber das Mitglied <code>priv_data</code> Struktur <code>FroxContext</code> verf√ºgbar. <br></p><br><p>  Bei der Arbeit mit der FFmpeg-API k√∂nnen Werte f√ºr Optionen direkt festgelegt werden. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodec *codec; <span class="hljs-comment"><span class="hljs-comment">// ... AVCodecContext *codec_ctx = avcodec_alloc_context3(codec); // ... av_opt_set(codec_ctx-&gt;priv_data, "frox_str", "meow", 0); av_opt_set_int(codec_ctx-&gt;priv_data, "frox_int", 42, 0);</span></span></code> </pre> <br><p>  Eine andere M√∂glichkeit ist die Verwendung des <code>avcodec_open2()</code> , das beim Aufruf von <code>avcodec_open2()</code> als drittes Argument <code>avcodec_open2()</code> (siehe unten). <br></p><br><p>  Funktion verwenden <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVOption* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_opt_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVOption* prev)</span></span></span></span>;</code> </pre> <br><p>  Sie k√∂nnen eine Liste aller vom Codec-Kontext unterst√ºtzten Optionen abrufen.  Dies ist n√ºtzlich, wenn Sie einen Codec untersuchen.  Vorher m√ºssen Sie jedoch sicherstellen, dass <code>codec_ctx-&gt;codec-&gt;priv_class</code> auf einen Wert ungleich Null gesetzt ist, da der Kontext sonst keine Optionen unterst√ºtzt und jede Operation mit Optionen das Programm zum Absturz bringt. <br></p><br><a name="id-3-2"></a><br><h2>  3.2.  Funktionen </h2><br><p>  Lassen Sie uns nun genauer untersuchen, wie die Funktionen, die bei der Initialisierung des Codecs und der tats√§chlichen Codierung / Decodierung verwendet werden, angeordnet sind.  Normalerweise m√ºssen sie immer einen Zeiger auf einen <code>FroxContext</code> . <br></p><br><pre> <code class="cpp hljs">AVCodecContext *codec_ctx; <span class="hljs-comment"><span class="hljs-comment">// ... FroxContext* frox_ctx = codec_ctx-&gt;priv_data;</span></span></code> </pre> <br><p>  Die Funktionen <code>frox_decode_init()</code> und <code>frox_encode_init()</code> werden aufgerufen, wenn die Funktion ausgef√ºhrt wird <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_open2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodec *codec, AVDictionary **options)</span></span></span></span>;</code> </pre> <br><p>  Sie m√ºssen die erforderlichen Ressourcen zuweisen, damit der Codec funktioniert, und bei Bedarf einige Mitglieder der <code>AVCodecContext</code> Struktur initialisieren, z. B. <code>frame_size</code> f√ºr einen Audio- <code>frame_size</code> . <br></p><br><p>  Die Funktionen <code>frox_decode_close()</code> und <code>frox_encode_close()</code> werden bei der Ausf√ºhrung aufgerufen <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span></span>;</code> </pre> <br><p>  Sie m√ºssen die zugewiesenen Ressourcen freigeben. <br></p><br><p>  Betrachten Sie eine Funktion zum Implementieren der Decodierung <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata_size, AVPacket *pkt)</span></span></span></span>;</code> </pre> <br><p>  Sie sollte die folgenden Operationen implementieren: <br></p><br><ol><li>  Tats√§chliche Dekodierung; </li><li>  Zuweisung des notwendigen Puffers f√ºr den Ausgaberahmen; </li><li>  Kopieren Sie dekodierte Daten in den Bildspeicher. </li></ol><br><p>  √úberlegen Sie, wie Sie den erforderlichen Puffer f√ºr den Ausgaberahmen zuweisen.  Der Parameter <code>outdata</code> verweist tats√§chlich auf einen <code>AVFrame</code> . Sie m√ºssen also zuerst eine Typkonvertierung durchf√ºhren: <br></p><br><pre> <code class="cpp hljs">AVFrame* frm = outdata;</code> </pre> <br><p>  Als n√§chstes m√ºssen Sie einen Puffer zum Speichern von Rahmendaten zuweisen.  Initialisieren Sie dazu die <code>AVFrame</code> Mitglieder, die die <code>AVFrame</code> bestimmen.  F√ºr Audio ist dies <code>nb_samples</code> , <code>channel_layout</code> , <code>format</code> (f√ºr <code>nb_samples</code> , <code>nb_samples</code> und <code>channel_layout</code> ). <br></p><br><p>  Danach m√ºssen Sie die Funktion aufrufen <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_frame_get_buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVFrame* frm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alignment)</span></span></span></span>;</code> </pre> <br><p>  Der Zeiger auf den Frame, bei dem es sich um den konvertierten <code>outdata</code> Parameter handelt, wird als erstes Argument verwendet, und es wird empfohlen, als zweites Argument Null zu √ºbergeben.  Nach Verwendung des Frames (dies geschieht bereits au√üerhalb des Codecs) wird der von dieser Funktion zugewiesene Puffer von der Funktion freigegeben <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_frame_unref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVFrame* frm)</span></span></span></span>;</code> </pre> <br><p>  Die Funktion <code>frox_decode()</code> sollte die Anzahl der zum Dekodieren verwendeten Bytes aus dem Paket zur√ºckgeben, auf das <code>pkt</code> .  Wenn die Rahmenbildung abgeschlossen ist, wird der Variablen, auf die <code>outdata_size</code> , ein Wert ungleich Null zugewiesen, andernfalls erh√§lt diese Variable den Wert <code>0</code> . <br></p><br><p>  Betrachten Sie eine Funktion zum Implementieren der Codierung <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, AVPacket *pkt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVFrame *frame, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *got_pkt_ptr)</span></span></span></span>;</code> </pre> <br><p>  Sie sollte die folgenden Operationen implementieren: <br></p><br><ol><li>  Tats√§chliche Kodierung; </li><li>  Zuweisung des notwendigen Puffers f√ºr das Ausgabepaket; </li><li>  Kopieren Sie verschl√ºsselte Daten in den Paketpuffer. </li></ol><br><p>  Verwenden Sie die Funktion, um den gew√ºnschten Puffer auszuw√§hlen <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_new_packet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVPacket *pkt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pack_size)</span></span></span></span>;</code> </pre> <br><p>  Der Parameter <code>pkt</code> als erstes Argument verwendet, und die Gr√∂√üe der codierten Daten ist das zweite.  Nach der Verwendung des Pakets (dies geschieht bereits au√üerhalb des Codecs) werden die von dieser Funktion zugewiesenen Puffer von der Funktion freigegeben <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_packet_unref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVPacket *pkt)</span></span></span></span>;</code> </pre> <br><p>  Wenn das Paket abgeschlossen ist, wird der Variablen, auf die <code>got_pkt_ptr</code> , ein Wert ungleich Null zugewiesen, andernfalls erh√§lt diese Variable den Wert <code>0</code> .  Liegt kein Fehler vor, gibt die Funktion Null zur√ºck, andernfalls einen Fehlercode. <br></p><br><p>  Bei der Implementierung des Codecs wird normalerweise die Protokollierung verwendet (bei Fehlern kann dies als obligatorische Anforderung angesehen werden).  Hier ist ein Beispiel: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span><span class="hljs-function"> </span></span>{ av_log(codec_ctx, AV_LOG_INFO, <span class="hljs-string"><span class="hljs-string">"FROX decode close\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  In diesem Fall wird bei der Ausgabe in das Protokoll der Codec-Name als Kontextname verwendet. <br></p><br><a name="id-3-3"></a><br><h2>  3.3.  Zeitstempel </h2><br><p>  Zum Einstellen der Zeit in FFmpeg wird eine Zeitbasis verwendet, die in Sekunden unter Verwendung der durch den <code>AVRational</code> Typ dargestellten rationalen Zahl <code>AVRational</code> .  (Ein √§hnlicher Ansatz wird in C ++ 11 verwendet. 1/1000 setzt beispielsweise die Millisekunde.) Frames und Pakete haben Zeitstempel vom Typ <code>int64_t</code> , deren Werte die Zeit in den entsprechenden Zeiteinheiten enthalten.  Ein Frame, <code>AVFrame</code> eine <code>AVFrame</code> Struktur, verf√ºgt √ºber einen Member <code>pts</code> (Pr√§sentationszeitstempel), dessen Wert die relative Zeit der im Frame erfassten Szene bestimmt.  Ein Paket, <code>AVPacket</code> eine <code>AVPacket</code> Struktur, enth√§lt die Member <code>AVPacket</code> (Pr√§sentationszeitstempel) und <code>dts</code> (Dekomprimierungszeitstempel).  Der Wert <code>dts</code> bestimmt die relative √úbertragungszeit des zu decodierenden Pakets.  F√ºr einfache Codecs ist es dasselbe wie f√ºr <code>h264</code> , aber f√ºr komplexe Codecs kann es anders sein (z. B. f√ºr <code>h264</code> bei Verwendung von B-Frames), <code>h264</code> , Pakete k√∂nnen in der falschen Reihenfolge decodiert werden, in der Frames verwendet werden sollen. <br></p><br><p>  Die Zeiteinheit ist f√ºr den Stream und den Codec definiert, die <code>AVStream</code> Struktur hat ein entsprechendes Member - <code>time_base</code> , dasselbe Member hat die <code>AVCodecContext</code> Struktur. <br></p><br><p>  Die Zeitstempel des mit <code>av_read_frame()</code> aus dem Stream extrahierten Pakets werden in Zeiteinheiten dieses Streams angegeben.  Bei der Dekodierung wird die Zeiteinheit des Codecs nicht verwendet.  F√ºr einen Videodecoder ist dies normalerweise einfach nicht festgelegt, f√ºr einen Audiodecoder hat dies einen Standardwert - die Inverse der Abtastfrequenz.  Der Decoder sollte einen Zeitstempel f√ºr den Ausgaberahmen basierend auf dem Zeitstempel des Pakets festlegen.  FFmpeg definiert ein solches Label unabh√§ngig und schreibt es in das <code>best_effort_timestamp</code> der <code>best_effort_timestamp</code> Struktur.  Alle diese Zeitstempel verwenden die Zeiteinheit des Streams, aus dem das Paket extrahiert wird. <br></p><br><p>  F√ºr den Encoder m√ºssen Sie die Zeiteinheit angeben.  In dem Clientcode, der die Dekodierung organisiert, m√ºssen Sie den Wert f√ºr das <code>time_base</code> Struktur <code>avcodec_open2()</code> <code>time_base</code> , bevor Sie <code>avcodec_open2()</code> aufrufen.  Verwenden Sie normalerweise die Zeiteinheit, die f√ºr Zeitstempel des codierten Frames verwendet wird.  Geschieht dies nicht, geben Video-Encoder normalerweise einen Fehler aus, Audio-Encoder setzen den Standardwert - die Inverse der Abtastfrequenz.  Ob ein Codec eine bestimmte Zeiteinheit √§ndern kann, ist nicht ganz klar.  F√ºr alle F√§lle ist es besser, nach dem Aufruf von <code>avcodec_open2()</code> immer den Wert von <code>avcodec_open2()</code> zu √ºberpr√ºfen und, falls er sich ge√§ndert hat, die Zeitstempel der Eingaberahmen pro Zeiteinheit des Codecs neu zu berechnen.  <code>dts</code> Kodierungsprozesses m√ºssen Sie die <code>pts</code> und <code>pts</code> <code>dts</code> Pakets installieren.  Nach dem Codieren muss vor dem Schreiben eines Pakets in den Ausgabestream der Paketzeitstempel von der Codec-Zeiteinheit in die Stream-Zeiteinheit neu berechnet werden.  Verwenden Sie dazu die Funktion <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_packet_rescale_ts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVPacket *pkt, AVRational tb_src, AVRational tb_dst)</span></span></span></span>;</code> </pre> <br><p>  Beim Schreiben von Paketen in den Stream ist darauf zu achten, dass die <code>dts</code> Werte strikt ansteigen, da sonst der Multiplexer einen Fehler ausl√∂st.  (Weitere Informationen finden Sie in der Dokumentation zur Funktion <code>av_interleaved_write_frame()</code> .) <br></p><br><a name="id-3-4"></a><br><h2>  3.4.  Andere vom Codec verwendete Funktionen </h2><br><p>  Wenn Sie eine <code>AVCodec</code> Instanz initialisieren, k√∂nnen zwei weitere Funktionen registriert werden.  Hier sind die relevanten Mitglieder von <code>AVCodec</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... void (*init_static_data)(AVCodec *codec); void (*flush)(AVCodecContext *codec_ctx); // ... } AVCodec;</span></span></code> </pre> <br><p>  Der erste von ihnen wird einmalig bei der Registrierung des Codecs aufgerufen. <br></p><br><p>  Der zweite setzt den internen Zustand des Codecs zur√ºck, der w√§hrend der Ausf√ºhrung der Funktion aufgerufen wird <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_flush_buffers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span></span>;</code> </pre> <br><p>  Dieser Aufruf ist beispielsweise erforderlich, wenn die aktuelle Wiedergabeposition gewaltsam ge√§ndert wird. <br></p><br><a name="id-4"></a><br><h1>  4. Externe Implementierung des Codecs </h1><br><a name="id-4-1"></a><br><h2>  4.1.  Externer Funktionsanschluss </h2><br><p>  Betrachten Sie die folgende Codec-Organisation: Der in FFmpeg registrierte Codec spielt die Rolle eines Frameworks und delegiert die eigentliche Codierungs- / Decodierungsprozedur an externe Funktionen (eine Art von Plugins), die au√üerhalb von FFmpeg implementiert sind. <br></p><br><p>  Eine solche L√∂sung kann aus vielen Gr√ºnden w√ºnschenswert sein.  Hier sind einige von ihnen: <br></p><br><ol><li>       ,   FFmpeg    ; </li><li>     C,    ,   C++; </li><li>     framework,     FFmpeg. </li></ol><br><p>    ,   FFmpeg       ¬´¬ª,         FFmpeg API.             ¬´¬ª FFmpeg       (  ,     ),     .    ‚Äî     .         . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dec_extern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext* codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* outdata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata_size, AVPacket* pkt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* out_buff; <span class="hljs-comment"><span class="hljs-comment">//      out_buff FroxContext *fc = codec_ctx-&gt;priv_data; if (fc-&gt;bin_size &gt; 0) { if (fc-&gt;bin_size == sizeof(dec_extern_t)) { dec_extern_t edec; memcpy(&amp;edec, fc-&gt;frox_bin, fc-&gt;bin_size); ret = (*edec)(pkt-&gt;data, pkt-&gt;size, out_buff); if (ret &gt;= 0) { //     out_buff   } } else { /*  */ } } else { /*    */ } // ... return ret; }</span></span></code> </pre> <br><p>    FFmpeg API (     C++)    . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeFroxData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* outBuff)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dec_extern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt; #include &lt;libavutil/opt.h&gt; } // ... AVCodecContext* ctx; // ... dec_extern_t dec = DecodeFroxData; void* pv = &amp;dec; auto pb = static_cast&lt;const uint8_t*&gt;(pv); auto sz = sizeof(dec); av_opt_set_bin(ctx-&gt;priv_data, "frox_bin", pb, sz, 0);</span></span></span></span></code> </pre> <br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><p>       ‚Äî     .        ,   . ,      .  ,   ,  FFmpeg     ,   ¬´¬ª ,        .         .     ,   .   FFmpeg API  -       ,   ,      .     .        ,        .     PC (Windows)      DirectShow  AVI .  PC             -   DirectShow.     32- FourCC. (   <code>biCompression</code>  <code>BITMAPINFOHEADER</code> .)  ,      DirectShow   ,   PC    -.        FFmpeg  , ,   ,   <code>codec_tag</code>  <code>AVCodecParameters</code>   FourCC,     .       FFmpeg API    ,    .             FFmpeg   FFmpeg API. <br></p><br><p>          ,   <code>*.mkv</code>  FFmpeg     ( <code>ENCODER</code> ). <br></p><br><a name="id-concl"></a><br><h1>  Fazit </h1><br><p>        ,   ,       FFmpeg: , changelog,     ..     ¬´¬ª  FFmpeg,     ,     . <br></p><br><a name="id-refs"></a><br><h1>  Ressourcen </h1><br><p> <b>   FFmpeg</b> </p><br><p> [1] <a href="https://ffmpeg.org/" rel="nofollow">FFmpeg ‚Äî  </a> <br> [2] <a href="https://ffmpeg.org/documentation.html" rel="nofollow">FFmpeg ‚Äî </a> <br> [3] <a href="https://ru.wikipedia.org/wiki/FFmpeg" rel="nofollow">FFmpeg ‚Äî </a> <br> [4] <a href="https://help.ubuntu.ru/wiki/ffmpeg" rel="nofollow">FFmpeg ‚Äî    Ubuntu</a> <br></p><br><p> <b></b> </p><br><p> [5] <a href="https://trac.ffmpeg.org/wiki/CompilationGuide" rel="nofollow">FFmpeg Compilation Guide</a> <br> [6] Compilation of FFmpeg 4.0 in Windows 10 <br></p><br><p> <b>   FFmpeg API</b> </p><br><p> [7] <a href="https://habr.com/ru/post/137793/">   ffmpeg</a> <br></p><br><p> <b> </b> </p><br><p> [8] <a href="https://wiki.multimedia.cx/index.php/FFmpeg_codec_HOWTO" rel="nofollow">FFmpeg codec HOWTO</a> <br> [9] <a href="http://ogorkis.net/ffmpeg" rel="nofollow">FFmpeg video codec tutorial</a> <br></p><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480714/">https://habr.com/ru/post/de480714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480700/index.html">Wir verwenden console.log () in Chrome vollst√§ndig</a></li>
<li><a href="../de480702/index.html">HR und Talente, Experten und Kreative: Wie war das achte Habraseminar?</a></li>
<li><a href="../de480704/index.html">Reaktionsf√§higes Laden von Inhalten auf der Website</a></li>
<li><a href="../de480710/index.html">Refactoring von SFML-Spielen</a></li>
<li><a href="../de480712/index.html">Der Flug mit einem Dosimeter in der Tasche</a></li>
<li><a href="../de480716/index.html">Matlab vs. Julia vs. Python</a></li>
<li><a href="../de480718/index.html">6 Tipps f√ºr eine erfolgreiche Code√ºberpr√ºfung</a></li>
<li><a href="../de480724/index.html">Transkompilierte Sprachen: Code-zu-Code-Konvertierungsprojekte</a></li>
<li><a href="../de480730/index.html">Auto-Moto-Entwicklung und Nginx</a></li>
<li><a href="../de480734/index.html">Als TestMace ist besser als Postman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>