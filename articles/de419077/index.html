<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèø üêÅ ü§∏üèæ Lokalisierung von Anwendungen in iOS. Teil 1. Was haben wir? üßîüèΩ üèà ‚òÆÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lokalisierung von Anwendungen in iOS 
 Teil 1. Was haben wir? 


 Handbuch f√ºr lokalisierte Zeichenfolgenressourcen 
 Einf√ºhrung 


 Vor einigen Jahre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lokalisierung von Anwendungen in iOS. Teil 1. Was haben wir?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419077/"><h1 id="lokalizaciya-prilozheniy-v-ios">  Lokalisierung von Anwendungen in iOS </h1><br><h2 id="chast-1-chto-my-imeem">  Teil 1. Was haben wir? </h2><br><p>  <strong><em>Handbuch f√ºr lokalisierte Zeichenfolgenressourcen</em></strong> </p><br><h3 id="vvedenie">  Einf√ºhrung </h3><br><p>  Vor einigen Jahren tauchte ich in die magische Welt der iOS-Entwicklung ein, die mir mit all ihrer Essenz eine gl√ºckliche Zukunft im Bereich der IT versprach.  Als ich mich jedoch eingehend mit den Funktionen der Plattform und der Entwicklungsumgebung befasste, hatte ich viele Schwierigkeiten und Unannehmlichkeiten bei der L√∂sung scheinbar sehr trivialer Aufgaben: Apples ‚Äûinnovativer Konservatismus‚Äú macht Entwickler manchmal sehr anspruchsvoll, um den ungez√ºgelten ‚ÄûI WANT‚Äú -Kunden zufrieden zu stellen. </p><br><p>  Eines dieser Probleme ist das Problem der Lokalisierung der Zeichenfolgenressourcen der Anwendung.  Ich m√∂chte diesem Problem einige meiner ersten Ver√∂ffentlichungen √ºber die Weiten von Habr widmen. </p><a name="habracut"></a><br><p>  Anfangs hatte ich gehofft, meine Gedanken in einen Artikel zu integrieren, aber die Menge an Informationen, die ich pr√§sentieren m√∂chte, war ziemlich gro√ü.  In diesem Artikel werde ich versuchen, die Essenz von Standardmechanismen f√ºr die Arbeit mit lokalisierten Ressourcen aufzudecken, wobei einige Aspekte im Vordergrund stehen, die von den meisten Handb√ºchern und Tutorials vernachl√§ssigt werden.  Das Material richtet sich in erster Linie an Anf√§nger (oder diejenigen, die auf solche Aufgaben nicht gesto√üen sind).  F√ºr erfahrene Entwickler sind diese Informationen m√∂glicherweise nicht besonders wertvoll.  Aber √ºber die Unannehmlichkeiten und Nachteile, die in der Praxis auftreten k√∂nnen, werde ich in Zukunft berichten ... </p><br><h3 id="iz-pod-korobki-kak-organizovano-hranenie-strokovyh-resursov-v-ios-prilozheniyah">  Out of the Box.  Wie die Speicherung von Zeichenfolgenressourcen in iOS-Anwendungen organisiert ist </h3><br><p>  Zun√§chst stellen wir fest, dass das Vorhandensein von Lokalisierungsmechanismen in der Plattform bereits ein gro√ües Plus ist, weil  Spart dem Programmierer zus√§tzliche Entwicklung und legt ein einziges Format f√ºr die Arbeit mit Daten fest.  Und oft reichen die grundlegenden Mechanismen f√ºr die Umsetzung relativ kleiner Projekte aus. </p><br><p>  Welche M√∂glichkeiten bietet uns Xcode "out of the box"?  Schauen wir uns zun√§chst den Standard zum Speichern von Zeichenfolgenressourcen in einem Projekt an. </p><br><p> In Projekten mit statischem Inhalt k√∂nnen Zeichenfolgendaten direkt in der Benutzeroberfl√§che ( <em><code>.storyboard</code></em> und <em><code>.xib</code></em> Markup-Dateien, die wiederum XML-Dateien sind, die mit <em>Interface Builder-</em> Tools gerendert werden) oder im Code gespeichert werden.  Der erste Ansatz erm√∂glicht es uns, den Prozess des Markierens von Bildschirmen und einzelnen Anzeigen zu vereinfachen und zu beschleunigen  Der Entwickler kann den gr√∂√üten Teil der √Ñnderung beobachten, ohne die Anwendung zu erstellen.  In diesem Fall ist es jedoch nicht schwierig, auf Datenredundanz zu sto√üen (wenn derselbe Text von mehreren Elementen verwendet wird, werden Anzeigen angezeigt).  Der zweite Ansatz beseitigt lediglich das Problem der Datenredundanz, f√ºhrt jedoch dazu, dass Bildschirme manuell <em><code>IBOutlet</code></em> werden m√ºssen (indem zus√§tzliche <em><code>IBOutlet</code></em> und ihnen entsprechende <em><code>IBOutlet</code></em> werden), was wiederum zu Code-Redundanz f√ºhrt (nat√ºrlich in F√§llen, in denen der Text dies <em><code>IBOutlet</code></em> sollte) direkt durch den Anwendungscode installiert werden). </p><br><p>  Dar√ºber hinaus bietet Apple eine Standard-Dateierweiterung <em><code>.strings</code></em> .  Dieser Standard regelt das Format zum Speichern von Zeichenfolgendaten in Form eines assoziativen Arrays ( <code>"-"</code> ): </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"key"</span></span> = <span class="hljs-string"><span class="hljs-string">"value"</span></span>;</code> </pre> <br><p>  Der Schl√ºssel unterscheidet zwischen Gro√ü- und Kleinschreibung und erm√∂glicht die Verwendung von Leerzeichen, Unterstrichen, Satzzeichen und Sonderzeichen. </p><br><p>  Es ist wichtig zu beachten, dass <em>Strings-</em> Dateien trotz der einfachen Syntax regelm√§√üige Fehlerquellen beim Kompilieren, Zusammenstellen oder Betreiben einer Anwendung sind.  Daf√ºr gibt es mehrere Gr√ºnde. </p><br><p>  Erstens Syntaxfehler.  Fehlende Semikolons, Gleichheitszeichen, zus√§tzliche oder nicht angef√ºhrte Anf√ºhrungszeichen f√ºhren unweigerlich zu einem Compilerfehler.  Dar√ºber hinaus zeigt Xcode auf die Datei mit dem Fehler, hebt jedoch nicht die Zeile hervor, in der etwas nicht stimmt.  Das Auffinden eines solchen Tippfehlers kann einige Zeit in Anspruch nehmen, insbesondere wenn die Datei eine erhebliche Datenmenge enth√§lt. </p><br><p>  Zweitens die Vervielf√§ltigung von Schl√ºsseln.  Die Anwendung st√ºrzt nat√ºrlich nicht ab, aber dem Benutzer werden m√∂glicherweise falsche Daten angezeigt.  Die Sache ist, dass beim Zugriff auf eine Zeile f√ºr Schl√ºssel der Wert, der dem letzten Vorkommen des Schl√ºssels in der Datei entspricht, abgerufen wird. </p><br><p>  Ein einfaches Design erfordert daher, dass der Programmierer beim F√ºllen von Dateien mit Daten sehr gr√ºndlich und aufmerksam ist. </p><br><p><del>  Sachkundig </del>  Entwickler k√∂nnen sofort ausrufen: <em>"Aber was ist mit JSON und PLIST? Was haben sie nicht gefallen?"</em>  Erstens sind <em><code>JSON</code></em> und <em><code>PLIST</code></em> (in der Tat gew√∂hnliches <em><code>XML</code></em> ) universelle Standards, mit denen sowohl Zeichenfolgen als auch numerische, logische ( <em><code>BOOL</code></em> ), bin√§re Daten, Uhrzeit und Datum sowie Sammlungen gespeichert werden k√∂nnen - indiziert ( <em><code>Array</code></em> ) und assoziativ ( <em><code>Dictionary</code></em> ) Arrays.  Dementsprechend ist die Syntax dieser Standards ges√§ttigter und daher leichter zu knabbern.  Zweitens ist die Verarbeitungsgeschwindigkeit solcher Dateien aufgrund der komplexeren Syntax etwas niedriger als die der Strings-Dateien.  Dies ist nicht zu erw√§hnen, dass Sie eine Reihe von Manipulationen im Code vornehmen m√ºssen, um mit ihnen zu arbeiten. </p><br><h3 id="lokalizovali-lokalizovali-da-ne-vylokalizovali-lokalizaciya-polzovatelskogo-interfeysa">  Lokalisiert, lokalisiert, aber nicht lokalisiert.  Lokalisierung der Benutzeroberfl√§che </h3><br><p>  Nachdem die Standards herausgefunden wurden, wollen wir nun herausfinden, wie man alles benutzt. </p><br><p>  Lass uns in Ordnung gehen.  Erstellen Sie zun√§chst eine einfache <em>Einzelansicht-</em> <em>Anwendung</em> und f√ºgen Sie dem <em>Main.storyboard</em> auf dem <em>ViewController</em> einige Textkomponenten <em>hinzu</em> . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/310/a0b/c0d/310a0bc0df4192cd2ab87ad46407666a.png" width="50%" height="50%"><br><br><p>  Der Inhalt wird in diesem Fall direkt in der Schnittstelle gespeichert.  Um es zu lokalisieren, m√ºssen Sie Folgendes tun: </p><br><p>  1) Gehen Sie zu den Projekteinstellungen </p><br><img src="https://habrastorage.org/getpro/habr/post_images/b9e/0bb/f6e/b9e0bbf6eb66b5d8acb88ee3b29fd45c.png" width="50%" height="50%"><br><br><p>  2) Dann - vom <strong><em>Ziel</em></strong> zum <strong><em>Projekt</em></strong> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/bf0/334/bb5bf033410cedeb98e3e46399637d7b.png" width="50%" height="50%"><br><br><p>  3) √ñffnen Sie die Registerkarte <strong><em>Info</em></strong> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/324/5bd/cdd/3245bdcdd605153e52668fd795f65720.png" width="50%" height="50%"><br><br><p>  Im Bereich <strong><em>Lokalisierungen sehen</em></strong> wir sofort, dass wir bereits den Eintrag <em>"Englisch - Entwicklungssprache" haben</em> .  Dies bedeutet, dass Englisch als Entwicklungssprache (oder Standard) festgelegt ist. </p><br><p>  F√ºgen wir jetzt eine weitere Sprache hinzu.  Klicken Sie dazu auf " <strong>+</strong> " und w√§hlen Sie die gew√ºnschte Sprache aus (zum Beispiel habe ich Russisch gew√§hlt).  Caring Xcode bietet uns sofort die M√∂glichkeit, die zu lokalisierenden Dateien f√ºr die hinzugef√ºgte Sprache auszuw√§hlen. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/781/801/3ae/7818013aee9b0574048779957404bb31.png" width="50%" height="50%"><br><br><p>  Klicken Sie auf <strong>Fertig stellen</strong> , um zu sehen, was passiert ist.  Im Projektnavigator wurden Schaltfl√§chen zum Anzeigen der Verschachtelung in der N√§he der ausgew√§hlten Dateien angezeigt.  Wenn Sie darauf klicken, sehen Sie, dass die zuvor ausgew√§hlten Dateien die erstellten Lokalisierungsdateien enthalten. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/5b0/882/089/5b0882089822427b954eb7ce5e497048.png" width="35%" height="35%"><br><br><p>  Beispielsweise ist <strong><em><code>Main.storyboard (Base)</code></em></strong> die Standard-Schnittstellen-Markup-Datei in der <strong><em><code>Main.storyboard (Base)</code></em></strong> , und beim Bilden der Lokalisierung wurde die zugeh√∂rige <strong><em><code>Main.strings (Russian)</code></em></strong> paarweise erstellt - eine Zeichenfolgendatei f√ºr die russische Lokalisierung.  Wenn Sie es √∂ffnen, sehen Sie Folgendes: </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UITextField"</span></span>; placeholder = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N.placeholder"</span></span> = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UIButton"</span></span>; normalTitle = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2.normalTitle"</span></span> = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>;</code> </pre> <br><p>  Hier ist im Allgemeinen alles einfach, aber der Klarheit halber werden wir dies genauer betrachten und dabei auf die Kommentare achten, die durch den f√ºrsorglichen Xcode generiert werden: </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>;</code> </pre> <br><p>  Hier ist eine Instanz der <strong><em><code>UILabel</code></em></strong> Klasse mit dem Wert <strong><em><code>"Label"</code></em></strong> f√ºr den <strong><em><code>UILabel</code></em></strong> .  <strong><em><code>ObjectID</code></em></strong> - die Kennung des Objekts in der Markup-Datei - Dies ist eine eindeutige Zeile, die jeder Komponente zum Zeitpunkt der Platzierung auf dem <em><code>Storyboard/Xib</code></em> zugewiesen wird.  Aus der <em><code>ObjectID</code></em> und dem Parameternamen des Objekts (in diesem Fall <em><code>text</code></em> ) wird der Schl√ºssel gebildet, und der Datensatz selbst kann formal wie folgt interpretiert werden: </p><br><p>  Setzen Sie den Textparameter des tQe-tG-eeo-Objekts auf Label. </p><br><p>  In diesem Datensatz kann sich nur der ‚Äû <em>Wert</em> ‚Äú √§ndern.  Ersetzen Sie " <em>Label</em> " durch " <em>Label</em> ".  Wir werden dasselbe mit anderen Objekten machen. </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UITextField"</span></span>; placeholder = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N.placeholder"</span></span> = <span class="hljs-string"><span class="hljs-string">" "</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UIButton"</span></span>; normalTitle = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2.normalTitle"</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> <br><p>  Wir starten unsere Anwendung. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/9e7/85a/332/9e785a3328aff1923329541d31447672.png" width="50%" height="50%"><br><br><p>  Aber was sehen wir?  Die Anwendung verwendet die grundlegende Lokalisierung.  Wie kann ich √ºberpr√ºfen, ob wir die √úberweisung korrekt durchgef√ºhrt haben? </p><br><p>  Hier lohnt es sich, einen kleinen Exkurs zu machen und ein wenig in Richtung der Funktionen der iOS-Plattform und der Anwendungsstruktur zu graben. </p><br><p>  Ziehen Sie zun√§chst in Betracht, die Struktur des Projekts beim Hinzuf√ºgen der Lokalisierung zu √§ndern.  So sieht das Projektverzeichnis aus, bevor die russische Lokalisierung hinzugef√ºgt wird: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bb3/0b2/f07/bb30b2f0799f2c7ce2433aa7ec2350fc.png" width="50%" height="50%"><br><br><p>  Und so danach: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ae7/a10/b14/ae7a10b14491da04c89ce8e456cf5ac1.png" width="50%" height="50%"><br><br><p>  Wie wir sehen k√∂nnen, hat Xcode ein neues Verzeichnis <em><code>ru.lproj</code></em> , in dem die erstellten lokalisierten Zeichenfolgen abgelegt wurden. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ceb/ca2/ff5/cebca2ff5edaae9d6a1398f9e41e7652.png" width="50%" height="50%"><br><br><p>  Und wo ist die Struktur des Xcode-Projekts f√ºr die fertige iOS-Anwendung?  Und trotz der Tatsache, dass dies hilft, die Funktionen der Plattform sowie die Prinzipien der Verteilung und Speicherung von Ressourcen direkt in der fertigen Anwendung besser zu verstehen.  Unter dem Strich √ºbertr√§gt die Umgebung beim Zusammenstellen eines Xcode-Projekts zus√§tzlich zum Generieren einer ausf√ºhrbaren Datei Ressourcen (Layoutdateien der <em>Storyboard / Xib-</em> Schnittstelle, Bilder, Zeilendateien usw.) an die fertige Anwendung, wobei die in der Entwicklungsphase angegebene Hierarchie beibehalten wird. </p><br><p>  Um mit dieser Hierarchie arbeiten zu k√∂nnen, stellt Apple die <em><code>Bundle(NSBundle)</code></em> Klasse <em><code>Bundle(NSBundle)</code></em> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlose √úbersetzung</a> ) zur Verf√ºgung: </p><br><blockquote>  Apple verwendet das <strong><code>Bundle</code></strong> , um Zugriff auf Anwendungen, Frameworks, Plugins und viele andere Arten von Inhalten zu gew√§hren.  Bundles organisieren Ressourcen in klar definierten Unterverzeichnissen, und Bundle-Strukturen variieren je nach Plattform und Typ.  Mit dem <em><code>bundle</code></em> k√∂nnen Sie auf die Ressourcen eines Pakets zugreifen, ohne dessen Struktur zu kennen.  <em><code>Bundle</code></em> ist eine einzige Schnittstelle f√ºr die Suche nach Elementen unter Ber√ºcksichtigung der Paketstruktur, der Benutzeranforderungen, der verf√ºgbaren Lokalisierungen und anderer relevanter Faktoren. <br>  <strong>Suche und Entdeckung einer Ressource</strong> <br>  Bevor Sie mit einer Ressource arbeiten, m√ºssen Sie deren <em><code>bundle</code></em> angeben.  Die <strong><code>Bundle</code></strong> Klasse hat viele Konstruktoren, aber <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">main wird</a></strong> am h√§ufigsten verwendet.  <em><code>Bundle.main</code></em> bietet einen Pfad zu Verzeichnissen, die den aktuellen ausf√ºhrbaren Code enthalten.  Auf diese Weise bietet <em><code>Bundle.main</code></em> Zugriff auf die von der aktuellen Anwendung verwendeten Ressourcen. </blockquote><p>  Betrachten Sie die <em><code>Bundle.main</code></em> Struktur mithilfe der <strong><em><code>FileManager</code></em></strong> Klasse: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/60f/e0f/8b3/60fe0f8b3bb62a0db757f06f999e8065.png" width="65%" height="65%"><br><br><p>  Basierend auf dem Vorstehenden k√∂nnen wir schlie√üen: Wenn die Anwendung geladen wird, wird ihre <em><code>Bundle.main</code></em> gebildet, die aktuelle <em><code>Bundle.main</code></em> (Systemsprache), Anwendungslokalisierung und lokalisierte Ressourcen werden analysiert.  Anschlie√üend w√§hlt die Anwendung aus allen verf√ºgbaren Lokalisierungen diejenige aus, die der aktuellen Sprache des Systems entspricht, und ruft die entsprechenden lokalisierten Ressourcen auf.  Wenn keine √úbereinstimmungen vorliegen, werden Ressourcen aus dem Standardverzeichnis verwendet (in unserem Fall die englische Lokalisierung, da Englisch als Entwicklungssprache definiert wurde und die Notwendigkeit einer zus√§tzlichen Lokalisierung von Ressourcen vernachl√§ssigt werden kann).  Wenn Sie die Ger√§tesprache in Russisch √§ndern und die Anwendung neu starten, entspricht die Schnittstelle bereits der russischen Lokalisierung. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/47e/e24/6fe/47ee246fec532a890503019af1bfc91c.png" width="50%" height="50%"><br><br><p>  Bevor Sie jedoch das Thema der Lokalisierung der Benutzeroberfl√§che √ºber den <em>Interface Builder schlie√üen</em> , sollten Sie einen anderen bemerkenswerten Weg beachten.  Beim Erstellen von Lokalisierungsdateien (durch Hinzuf√ºgen einer neuen Sprache zum Projekt oder im Inspektor f√ºr lokalisierte Dateien) ist leicht zu erkennen, dass Xcode die M√∂glichkeit bietet, den zu erstellenden Dateityp auszuw√§hlen: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/272/aa5/cb3/272aa5cb38ea6b2a4178edc911296982.png" width="35%" height="35%"><br><br><p>  Anstelle einer Zeilendatei k√∂nnen Sie problemlos ein lokalisiertes <em><code>Storyboard/Xib</code></em> erstellen, in dem alle Markups der Basisdatei gespeichert werden.  Ein gro√ües Plus dieses Ansatzes besteht darin, dass der Entwickler sofort sehen kann, wie der Inhalt in einer bestimmten Sprache angezeigt wird, und das Layout des Bildschirms sofort korrigieren kann, insbesondere wenn die Textmenge unterschiedlich ist oder eine andere Richtung des Textes verwendet wird (z. B. auf Arabisch, Hebr√§isch) und so weiter .  Gleichzeitig erh√∂ht das Erstellen zus√§tzlicher <em>Storyboard / Xib-</em> Dateien die Gr√∂√üe der Anwendung selbst erheblich (String-Dateien ben√∂tigen jedoch viel weniger Speicherplatz). </p><br><p>  Daher sollte bei der Auswahl der einen oder anderen Methode zur Schnittstellenlokalisierung ber√ºcksichtigt werden, welcher Ansatz in einer bestimmten Situation geeigneter und praktischer ist. </p><br><h3 id="do-it-yourself-rabota-s-lokalizovannymi-strokovymi-resursami-v-kode">  Mach es selbst.  Arbeiten mit lokalisierten Zeichenfolgenressourcen im Code </h3><br><p>  Hoffentlich ist bei statischen Inhalten alles mehr oder weniger klar.  Aber was ist mit dem Text, der direkt im Code festgelegt ist? </p><br><p>  Die Entwickler des iOS-Betriebssystems haben sich darum gek√ºmmert. </p><br><p>  Um mit lokalisierten <strong><em><code>NSLocalizedStrings</code></em></strong> arbeiten zu k√∂nnen, stellt das Foundation-Framework die Methodenfamilie <strong><em><code>NSLocalizedStrings</code></em></strong> in <strong><em>Swift</em></strong> <strong><em><code>NSLocalizedStrings</code></em></strong> </p><br><pre> <code class="hljs sql">NSLocalizedString(_ key: String, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) NSLocalizedString(_ <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, tableName: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>?, bundle: Bundle, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>)</code> </pre> <br><p>  und Makros in <strong><em>Objective-C</em></strong> </p><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedString</span></span>(key, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringFromTable</span></span>(key, tbl, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringFromTableInBundle</span></span>(key, tbl, bundle, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringWithDefaultValue</span></span>(key, tbl, bundle, val, comment)</code> </pre> <br><p>  Beginnen wir mit dem Offensichtlichen.  Der <strong><em><code>key</code></em></strong> ist der Zeichenfolgenschl√ºssel in der Zeichenfolgendatei.  <strong><em><code>val</code></em></strong> (Standardwert) - Der Standardwert, der verwendet wird, wenn sich der angegebene Schl√ºssel nicht in der Datei befindet.  <strong><em><code>comment</code></em></strong> - (weniger offensichtlich) eine kurze Beschreibung der lokalisierten Zeichenfolge (tats√§chlich enth√§lt sie keine n√ºtzliche Funktionalit√§t und soll den Zweck der Verwendung einer bestimmten Zeichenfolge erl√§utern). </p><br><p>  Die Parameter <em><code>tableName</code></em> ( <em><code>tbl</code></em> ) und <em><code>bunble</code></em> sollten genauer betrachtet werden. </p><br><p>  <strong><em><code>tableName</code></em></strong> ( <strong><em><code>tbl</code></em></strong> ) ist der Name der String-Datei (um ehrlich zu sein, ich wei√ü nicht, warum Apple sie als Tabelle bezeichnet), die die Zeile enth√§lt, die wir f√ºr den angegebenen Schl√ºssel ben√∂tigen.  Bei der √úbertragung wird die Erweiterung <em><code>.string</code></em> nicht angegeben.  Durch die M√∂glichkeit, zwischen Tabellen zu navigieren, k√∂nnen Sie Zeichenfolgenressourcen nicht in einer Datei speichern, sondern nach eigenem Ermessen verteilen.  Auf diese Weise k√∂nnen Sie die √úberlastung von Dateien beseitigen, die Bearbeitung vereinfachen und das Risiko von Fehlern minimieren. </p><br><p>  Der <strong><em><code>bundle</code></em></strong> Parameter erweitert die Ressourcennavigation noch weiter.  Wie bereits erw√§hnt, ist <em>Bundle</em> ein Mechanismus f√ºr den Zugriff auf Anwendungsressourcen, dh wir k√∂nnen die Ressourcenquelle unabh√§ngig bestimmen. </p><br><p>  Ein bisschen mehr.  Wir werden direkt zur <strong><em>Stiftung gehen</em></strong> und die Deklaration von Methoden (Makros) f√ºr ein klareres Bild betrachten, weil  Die √ºberwiegende Mehrheit der Tutorials ignoriert diesen Punkt einfach.  Das <em>Swift-</em> Framework ist nicht sehr informativ: </p><br><pre> <code class="hljs vhdl">/// Returns a localized <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, using the main bundle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> one <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> specified. public func NSLocalizedString(_ key: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, tableName: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>? = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, bundle: Bundle = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, value: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, comment: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br><p>  <em>"Das Hauptpaket gibt eine lokalisierte Zeichenfolge zur√ºck"</em> - alles, was wir haben.  <em>Objective-C</em> ist etwas anders. </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define NSLocalizedString(key, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:nil] #define NSLocalizedStringFromTable(key, tbl, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:(tbl)] #define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \ [bundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:(tbl)] #define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \ [bundle localizedStringForKey:(key) value:(val) table:(tbl)]</span></span></code> </pre> <br><p>  Hier k√∂nnen Sie bereits deutlich sehen, dass kein anderes als <strong><em><code>bundle</code></em></strong> (in den ersten beiden F√§llen <em><code>mainBundle</code></em> ) mit String-Ressourcendateien funktioniert - genau wie bei der Schnittstellenlokalisierung.  Nat√ºrlich k√∂nnte ich dies sofort sagen, wenn man die <em><code>Bundle</code></em> Klasse ( <em><code>NSBundle</code></em> ) im vorherigen Absatz betrachtet, aber zu diesem Zeitpunkt waren diese Informationen nicht von besonderem praktischem Wert.  Im Zusammenhang mit der Arbeit mit Zeilen im Code kann dies jedoch nicht gesagt werden.  Tats√§chlich sind die von der <strong><em>Foundation</em></strong> bereitgestellten globalen Funktionen nur Wrapper f√ºr die Standard-Bundle-Methoden, deren Hauptaufgabe darin besteht, den Code pr√§ziser und sicherer zu gestalten.  Niemand verbietet es, das <em><code>bundle</code></em> manuell zu initialisieren und in seinem Namen direkt auf Ressourcen zuzugreifen, aber auf diese Weise scheint (wenn auch eine sehr, sehr geringe) Wahrscheinlichkeit der Bildung von Zirkelverbindungen und Speicherlecks zu bestehen. </p><br><p>  In den folgenden Beispielen wird beschrieben, wie Sie mit globalen Funktionen und Makros arbeiten. </p><br><p>  Mal sehen, wie das alles funktioniert. <br>  Erstellen Sie zun√§chst eine String-Datei, die unsere String-Ressourcen enth√§lt.  Nennen Sie es Localizable.strings * und f√ºgen Sie es hinzu. </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"testKey"</span></span> = <span class="hljs-string"><span class="hljs-string">"testValue"</span></span>;</code> </pre> <br><p>  (Die <em>Lokalisierung von String-Dateien erfolgt genauso wie bei</em> Storyboard / Xib <em>, daher werde ich diesen Prozess nicht beschreiben. Wir werden "</em> testValue <em>" in der</em> <em>russischen Lokalisierungsdatei</em> <em>durch "</em> test value *" <em>ersetzen</em> .) </p><br><p>  <strong>Wichtig!</strong>  In iOS ist eine Datei mit diesem Namen die Standard-String-Ressourcendatei, d. H.  Wenn Sie den Tabellennamen <em><code>tableName</code></em> ( <em><code>tbl</code></em> ) nicht angeben, <em><code>tableName</code></em> die Anwendung automatisch auf <strong><em><code>Localizable.strings</code></em></strong> . </p><br><p>  F√ºgen Sie unserem Projekt den folgenden Code hinzu </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'testKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"testKey"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'testKey': %@", NSLocalizedString(@"testKey", @""));</span></span></code> </pre> <br><p>  und f√ºhren Sie das Projekt aus.  Nach dem Ausf√ºhren des Codes wird eine Zeile in der Konsole angezeigt </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'testKey'</span></span>: testValue</code> </pre> <br><p>  Alles funktioniert richtig! </p><br><p>  √Ñndern Sie in √§hnlicher Weise am Beispiel der Lokalisierung der Schnittstelle die Lokalisierung und f√ºhren Sie die Anwendung aus.  Das Ergebnis der Codeausf√ºhrung ist </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'testKey'</span></span>:  </code> </pre> <br><p>  Versuchen wir nun, den Wert √ºber den Schl√ºssel abzurufen, der sich nicht in der Datei <em><code>Localizable.strings</code></em> : </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'unknownKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"unknownKey"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'unknownKey': %@", NSLocalizedString(@"unknownKey", @""));</span></span></code> </pre> <br><p>  Das Ergebnis der Ausf√ºhrung eines solchen Codes wird sein </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'unknownKey'</span></span>: unknownKey</code> </pre> <br><p>  Da die Datei keinen Schl√ºssel enth√§lt, gibt die Methode den Schl√ºssel selbst als Ergebnis zur√ºck.  Wenn ein solches Ergebnis nicht akzeptabel ist, ist es besser, die Methode zu verwenden </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'testKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"unknownKey"</span></span>, tableName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: Bundle.main, value: <span class="hljs-string"><span class="hljs-string">"noValue"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'testKey': %@", NSLocalizedStringWithDefaultValue(@"unknownKey", nil, NSBundle.mainBundle, @"noValue", @""));</span></span></code> </pre> <br><p>  wo es einen Wertparameter gibt ( <em>Standardwert</em> ).  In diesem Fall m√ºssen Sie jedoch die Quelle der Ressourcen angeben - <em><code>bundle</code></em> . </p><br><p>  Lokalisierte Zeichenfolgen unterst√ºtzen den Interpolationsmechanismus, √§hnlich wie Standard-iOS-Zeichenfolgen.  F√ºgen Sie dazu der Zeichenfolgendatei einen Datensatz mit Zeichenfolgenliteralen ( <em><code>%@</code></em> , <em><code>%li</code></em> , <em><code>%f</code></em> usw.) hinzu, zum Beispiel: </p><br><pre> <code class="hljs perl"><span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span> = <span class="hljs-string"><span class="hljs-string">"String with %@: %li, %f"</span></span>;</code> </pre> <br><p>  Um eine solche Zeile auszugeben, m√ºssen Sie einen Code des Formulars hinzuf√ºgen </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"some"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"some", 123, 123.098]);</span></span></code> </pre> <br><p>  Aber wenn Sie solche Designs verwenden, m√ºssen Sie sehr vorsichtig sein!  Tatsache ist, dass iOS die Anzahl, Reihenfolge der Argumente und die Entsprechung ihrer Typen zu den angegebenen Literalen streng √ºberwacht.  Wenn Sie beispielsweise die Zeichenfolge anstelle des ganzzahligen Werts als zweites Argument einsetzen </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"some"</span></span>, <span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"some", @"123", 123.098]);</span></span></code> </pre> <br><p>  dann ersetzt die Anwendung den Ganzzahlcode der Zeichenfolge <strong><em>"123"</em></strong> anstelle der Nicht√ºbereinstimmung </p><br><pre> <code class="hljs sql">"String <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span>: <span class="hljs-number"><span class="hljs-number">4307341664</span></span>, <span class="hljs-number"><span class="hljs-number">123.089000</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p>  Wenn Sie es √ºberspringen, bekommen wir </p><br><pre> <code class="hljs sql">"String <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">123.089000</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p>  Wenn Sie jedoch das Objekt √ºberspringen, das <strong><em><code>%@</code></em></strong> in der Argumentliste entspricht </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"123", 123.098]);</span></span></code> </pre> <br><p>  Dann st√ºrzt die Anwendung zum Zeitpunkt der Codeausf√ºhrung einfach ab. </p><br><h3 id="push-me-baby-lokalizaciya-uvedomleniy">  Dr√ºck mich, Baby!  Lokalisierung von Benachrichtigungen </h3><br><p>  Eine weitere wichtige Aufgabe bei der Arbeit mit lokalisierten Zeichenfolgenressourcen, √ºber die ich kurz sprechen m√∂chte, ist die Lokalisierung von Benachrichtigungen.  Das Fazit ist, dass die meisten Tutorials (sowohl zu <em><code>Push Notifications</code></em> als auch zu <em><code>Localizable Strings</code></em> ) dieses Problem h√§ufig vernachl√§ssigen und solche Aufgaben nicht so selten sind.  Wenn der Entwickler zum ersten Mal damit konfrontiert wird, kann er daher eine vern√ºnftige Frage haben: <em>Ist dies im Prinzip m√∂glich?</em>  Ich werde den <em><code>Apple Push Notification Service</code></em> des <em><code>Apple Push Notification Service</code></em> hier nicht ber√ºcksichtigen, insbesondere da ab iOS 10.0 <strong><code>UserNotifications</code></strong> und lokale Benachrichtigungen √ºber dasselbe Framework implementiert werden - <strong><code>UserNotifications</code></strong> . </p><br><p>  Bei der Entwicklung mehrsprachiger Client-Server-Anwendungen muss ein √§hnliches Problem auftreten.  Als mich eine solche Aufgabe zum ersten Mal konfrontierte, fiel mir als erstes ein, das Problem der Nachrichtenlokalisierung auf der Serverseite zu beseitigen.  Die Idee war sehr einfach: Die Anwendung sendet die aktuelle Lokalisierung beim Start an das <em>Backend</em> , und der Server w√§hlt beim Senden des <em>Push</em> die entsprechende Nachricht aus.  Das Problem trat jedoch sofort auf: Wenn sich die Lokalisierung des Ger√§ts ge√§ndert hat und die Anwendung nicht neu gestartet wurde (die Daten in der Datenbank wurden nicht aktualisiert), hat der Server den Text gesendet, der der letzten "registrierten" Lokalisierung entspricht.  Und wenn die Anwendung auf mehreren Ger√§ten mit unterschiedlichen Systemsprachen gleichzeitig installiert ist, funktioniert die gesamte Implementierung wie die H√∂lle, wei√ü was.  Da mir eine solche L√∂sung sofort als die wildeste Kr√ºcke erschien, suchte ich sofort nach geeigneten L√∂sungen (lustig, aber in vielen Foren rieten die "Entwickler", die Pushies genau im <em>Backend</em> zu lokalisieren). </p><br><p>  Die richtige Entscheidung war schrecklich einfach, wenn auch nicht ganz offensichtlich.  Anstelle des vom Server auf <em>APNS</em> gesendeten Standard- <em>JSON</em> </p><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"body"</span></span> : <span class="hljs-string"><span class="hljs-string">"some message"</span></span>; }; };</code> </pre> <br><p>  m√ºssen <em>JSON des</em> Formulars senden </p><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"message localized key"</span></span>; }; };</code> </pre> <br><p>  Dabei wird der <strong><em><code>loc-key</code></em></strong> verwendet, um den lokalisierten String-Schl√ºssel aus der Datei <strong><em><code>Localizable.strings</code></em></strong> .  Dementsprechend wird die Push-Nachricht entsprechend der aktuellen Lokalisierung des Ger√§ts angezeigt. </p><br><p>  Der Mechanismus zum Interpolieren lokalisierter Zeichenfolgen in <em>Push-</em> Benachrichtigungen funktioniert auf √§hnliche Weise: </p><br><pre> <code class="hljs powershell"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"message localized key"</span></span>; <span class="hljs-string"><span class="hljs-string">"loc-args"</span></span> : [ <span class="hljs-string"><span class="hljs-string">"First argument"</span></span>, <span class="hljs-string"><span class="hljs-string">"Second argument"</span></span> ]; }; };</code> </pre> <br><p>  Der Schl√ºssel <strong><em><code>loc-args</code></em></strong> √ºbergibt ein Array von Argumenten, die in den lokalisierten Benachrichtigungstext eingebettet werden m√ºssen. </p><br><h3 id="podytozhim">  Zusammenfassend ... </h3><br><p>  Und was haben wir am Ende: </p><br><ul><li>  Standard zum Speichern von String-Daten in speziellen <strong><em><code>.string</code></em></strong> Dateien mit einfacher und zug√§nglicher Syntax; </li><li>  die F√§higkeit, die Schnittstelle ohne zus√§tzliche Manipulationen im Code zu lokalisieren; </li><li>  schneller Zugriff auf lokalisierte Ressourcen √ºber Code; </li><li>  automatische Generierung von Lokalisierungsdateien und Strukturierung der Ressourcen des Projektverzeichnisses (Anwendung) mithilfe von Xcode-Tools; </li><li>  die M√∂glichkeit, den Benachrichtigungstext zu lokalisieren. </li></ul><br><p>  , Xcode           ,          . </p><br><p>               . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419077/">https://habr.com/ru/post/de419077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419065/index.html">Virtuelle Welt Intel. √úbe</a></li>
<li><a href="../de419067/index.html">Wie man personenbezogene Daten verkauft oder warum es schwierig ist, Informationen mit einem Preisschild zu versehen</a></li>
<li><a href="../de419069/index.html">Die globale Erw√§rmung wird unsere Welt gr√ºner machen, aber freuen Sie sich nicht</a></li>
<li><a href="../de419071/index.html">Nach dem TP-Link-Hack</a></li>
<li><a href="../de419075/index.html">Zur Bildung von Sequenzen in der Collatz-Hypothese (3n + 1)</a></li>
<li><a href="../de419085/index.html">Die Idee der Singularit√§t vor dem Urknall ist veraltet</a></li>
<li><a href="../de419087/index.html">Den Verstand eines anderen zu verstehen, ist ein Mythos</a></li>
<li><a href="../de419091/index.html">Radioaktive Objekte unter uns</a></li>
<li><a href="../de419095/index.html">Wir schreiben CSS besser und sch√∂ner</a></li>
<li><a href="../de419097/index.html">Mambot - ein Bot im Telegramm f√ºr schwangere Frauen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>