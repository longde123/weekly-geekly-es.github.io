<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏼 🤜🏾 👩🏾‍🤝‍👨🏼 CUBA 7的新功能 🙎🏾 🚵🏾 🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CUBA 7的新功能 


 三年前，我们宣布了该框架的第二个主要公开版本。 CUBA 6是改变游戏规则的版本-许可从专有转变为Apache 2.0。 那些日子，我们甚至无法猜测从长远来看它将把框架带到哪里。 CUBA社区开始呈指数级增长，因此我们了解了开发人员如何使用框架的许多可能（有时甚至是不可...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CUBA 7的新功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/444558/"><h1 id="whats-new-in-cuba-7">  CUBA 7的新功能 </h1><br><p> 三年前，我们宣布了该框架的第二个主要公开版本。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA 6</a>是改变游戏规则的版本-许可从专有转变为Apache 2.0。 那些日子，我们甚至无法猜测从长远来看它将把框架带到哪里。  CUBA社区开始呈指数级增长，因此我们了解了开发人员如何使用框架的许多可能（有时甚至是不可能的）方法。 现在，我们很高兴地宣布<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA 7</a> ，我们希望这将使所有社区成员（从刚开始CUBA和Java之旅的人，到熟练的企业开发人员和Java专家）的开发工作都更加协调和愉快。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d60/280/788/d602807880920f1c89cc34aa4c944f11.png" alt="古巴"></p><a name="habracut"></a><br><h2 id="development-tools"> 开发工具 </h2><br><p> 显然，我们在很大程度上要归功于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA Studio</a> 。 它显着简化了过度使用的Java企业例程，在许多地方使它可以在可视化设计器中进行微不足道的配置：无需了解Persistence API或Gradle甚至Spring即可开发完整的功能丰富的CRUD应用程序-Studio会做到的为你。 </p><br><p>  Studio是一个单独的Web应用程序，这个事实引起了一些重大限制： </p><br><ul><li> 首先，Studio不是功能齐全的IDE，因此开发人员必须在Studio和IntelliJ IDEA或Eclipse之间切换才能开发业务逻辑，并从便利的导航，代码完成和其他必要的事情中受益，这很烦人。 </li><li> 其次，这种神奇的简单性是建立在大量源代码解析和生成之上的。 改进代码生成功能将意味着朝着开发功能齐全的IDE的方向迈进。 </li></ul><br><p> 我们决定靠另一巨头的肩膀克服这些限制。  Studio由JetBrains合并到IntelliJ IDEA中。 现在，您可以将其作为IntelliJ IDEA的插件安装，也可以作为单独的独立捆绑包下载。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eba/91f/e64/eba91fe64a5025522853a054d2e6d720.png" alt="古巴1"></p><br><p> 这开辟了新的视野： </p><br><ul><li> 其他JVM语言支持（首先是Kotlin） </li><li> 改进的热部署 </li><li> 整个项目的直观导航 </li><li> 更智能的提示和代码生成器 </li></ul><br><p> 目前，新Studio正在积极开发中：我们正在移植旧版本中的功能。 短期计划还计划使用本地IntelliJ UI重新实现基于Web的设计师，并改善项目导航体验。 </p><br><h2 id="stack-upgrade"> 堆叠升级 </h2><br><p> 传统上，基础堆栈也已进行了重大升级，例如Java 8/11，Vaadin 8，Spring 5。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fb4/f9a/5f9/fb4f9a5f937e543e339dfba51e637f2e.png" alt="古巴2"></p><br><p> 默认情况下，新项目使用Java 8，但是您可以通过在build.gradle文件中添加以下子句来指定Java版本： </p><br><pre><code class="plaintext hljs">subprojects { sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11 }</code> </pre> <br><p> 由于Vaadin数据绑定API的重大突破性变化，升级到Vaadin 8是一个巨大的挑战。 幸运的是，CUBA通过将Vaadin内部包装到其自己的API层中，使开发人员从Vaadin内部抽象出来。  CUBA团队在重新实现内部结构方面做得很出色，保持了自己的API不变。 这意味着完全可以保存兼容性，并且可以在将项目迁移到CUBA 7之后立即使用Vaadin 8，而无需进行任何重构。 </p><br><p> 官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发行说明中</a>提供了更新后的依赖项的完整列表。 </p><br><h2 id="new-screens-api"> 新屏幕API </h2><br><p> 此部分也可以称为“第一个屏幕API”，因为CUBA从未在Web客户端层中有任何正式声明的API。 它来自框架的历史以及在第一阶段做出的某些假设： </p><br><ul><li> 以声明为中心的方法-可以以声明方式描述的所有内容，都应该在屏幕描述符中声明，而不是在其控制器中进行编码 </li><li> 标准屏幕（浏览器和编辑器）提供了具体的通用功能，因此无需对其进行修改 </li></ul><br><p> 自从第一千名成员加入我们的社区以来，我们意识到“标准” CRUD屏幕的要求范围之广-远远超出了最初设计的功能集。 尽管如此，很长时间以来，即使没有API层，我们也能够处理自定义行为的请求-这要归功于另一个第一阶段的假设-开放继承。 有效地，“开放继承”意味着您可以覆盖基础类的任何公共或受保护方法，以根据需要调整其行为。 这听起来似乎可以治愈所有疾病，但是实际上，它甚至无法给您带来短期合同：如果重写的方法将被重命名，删除或在框架的未来版本中根本不使用怎么办？ </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4ed/043/150/4ed0431505177eab85281d6f583f4bc4.png" alt="古巴3"></p><br><p> 因此，为了响应社区不断增长的需求，我们决定引入新的屏幕API。 该API提供了清晰而长期的扩展点，没有隐藏的声明性魔术，灵活且易于使用。 </p><br><h3 id="screen-declaration"> 屏幕声明 </h3><br><p> 在CUBA 7中，屏幕声明非常简单： </p><br><pre> <code class="plaintext hljs">@UiController("new-screen") // screen id public class NewScreen extends Screen { }</code> </pre> <br><p> 从上面的示例中，我们可以看到屏幕标识符已在控制器类的上方明确定义。 换句话说，屏幕ID和控制器类现在彼此唯一对应。 因此，好消息是，现在可以通过其控制器类以安全的方式直接处理屏幕： </p><br><pre> <code class="plaintext hljs">@Inject private ScreenBuilders screenBuilders; @Subscribe private void onBeforeClose(BeforeCloseEvent event) { screenBuilders.screen(this) .withScreenClass(SomeConfirmationScreen.class) .build() .show(); }</code> </pre> <br><p> 屏幕描述符成为补充部分，而不是强制性的。 可以通过编程方式创建布局，也可以将其声明为xml屏幕描述符，该描述符由控制器类上的@UiDescriptor批注定义。 这使得控制器和布局更易于阅读和理解-这种方法与Android开发中使用的方法非常相似。 </p><br><p> 在此之前，还需要在web-screens.xml文件中注册屏幕描述符并为其分配标识符。 在CUBA 7中，由于兼容性原因而保留了该文件，但是，以新的方式创建屏幕不需要这种注册。 </p><br><h3 id="screens-lifecycle"> 屏幕生命周期 </h3><br><p> 新的API引入了清晰明了的屏幕生命周期事件： </p><br><ul><li> 初始化 </li><li> 后初始化 </li><li> 放映前 </li><li> 放映后 </li><li> 收盘前 </li><li> 收盘后 </li></ul><br><p> 可以按以下方式订阅CUBA 7中所有与屏幕相关的事件： </p><br><pre> <code class="plaintext hljs">@UiController("new-screen") public class NewScreen extends Screen { @Subscribe private void onInit(InitEvent event) { } @Subscribe private void onBeforeShow(BeforeShowEvent event) { } }</code> </pre> <br><p> 将新的API与旧的方法进行比较，您可以看到我们没有覆盖钩子方法，在父类的层次结构中模糊地调用了钩子方法，而是在屏幕生命周期的明确预定义点中定义了逻辑。 </p><br><h3 id="event-handling-and-functional-delegates"> 事件处理和功能代表 </h3><br><p> 在上一节中，我们学习了如何订阅生命周期事件，那么其他组件呢？ 我们是否应该像6.x版本中那样将所有必需的侦听器分散在屏幕初始化上？ 新的API非常统一，因此订阅其他事件与生命周期绝对相似。 </p><br><p> 让我们以包含两个UI元素的简单示例为例：一个按钮和一个Currency字段，因此其xml描述符如下所示： </p><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt; &lt;window xmlns="http://schemas.haulmont.com/cuba/screen/window.xsd" caption="msg://caption" messagesPack="com.company.demo.web"&gt; &lt;layout&gt; &lt;hbox spacing="true"&gt; &lt;currencyField id="currencyField" currency="$" currencyLabelPosition="LEFT"/&gt; &lt;button id="calcPriceBtn" caption="Calculate Price"/&gt; &lt;/hbox&gt; &lt;/layout&gt; &lt;/window&gt;</code> </pre> <br><p> 通过单击按钮，我们称为中间件服务，返回一个数字，该数字将转到货币字段。 货币字段应根据价格值更改其样式。 </p><br><pre> <code class="plaintext hljs">@UiController("demo_MyFirstScreen") @UiDescriptor("my-first-screen.xml") public class MyFirstScreen extends Screen { @Inject private PricingService pricingService; @Inject private CurrencyField&lt;BigDecimal&gt; currencyField; @Subscribe("calcPriceBtn") private void onCalcPriceBtnClick(Button.ClickEvent event) { currencyField.setValue(pricingService.calculatePrice()); } @Subscribe("currencyField") private void onPriceChange(HasValue.ValueChangeEvent&lt;BigDecimal&gt; event) { BigDecimal price = pricingService.calculatePrice(); currencyField.setStyleName(getStyleNameByPrice(price)); } private String getStyleNameByPrice(BigDecimal price) { ... } }</code> </pre> <br><p> 在上面的示例中，我们可以看到两个事件处理程序：一个事件处理程序在单击按钮时被调用，另一个在货币字段更改其值时被执行-就这么简单。 </p><br><p> 现在，让我们想象一下，我们需要验证价格并检查其价格是否为正。 直接的方法是在屏幕初始化时添加验证器： </p><br><pre> <code class="plaintext hljs">@UiController("demo_MyFirstScreen") @UiDescriptor("my-first-screen.xml") public class MyFirstScreen extends Screen { @Inject private CurrencyField&lt;BigDecimal&gt; currencyField; @Subscribe private void onInit(InitEvent event) { currencyField.addValidator(value -&gt; { if (value.compareTo(BigDecimal.ZERO) &lt;= 0) throw new ValidationException("Price should be greater than zero"); }); } }</code> </pre> <br><p> 在现实世界的应用程序中，屏幕入口点通常会被此类屏幕元素初始化程序所丢弃。 为了解决此问题，CUBA提供了有用的注释<code>@Install</code> 。 让我们看看它对我们的案例有何帮助： </p><br><pre> <code class="plaintext hljs">@UiController("demo_MyFirstScreen") @UiDescriptor("my-first-screen.xml") public class MyFirstScreen extends Screen { @Inject private CurrencyField&lt;BigDecimal&gt; currencyField; @Install(to = "currencyField", subject = "validator") private void currencyFieldValidator(BigDecimal value) { if (value.compareTo(BigDecimal.ZERO) &lt;= 0) throw new ValidationException("Price should be greater than zero"); } }</code> </pre> <br><p> 实际上，我们将验证逻辑从货币字段委派给屏幕中的<em>currencyFieldValidator</em>方法。 这可能看起来有些复杂，但是，开发人员以惊人的速度采用了此功能。 </p><br><h3 id="screen-builders--notifications--dialogs"> 屏幕构建器/通知/对话框 </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7b/b4b/83a/d7bb4b83a2ac4b60988f0a7e59b91dae.png" alt="古巴4"></p><br><p>  CUBA 7还通过流畅的API引入了一组有用的组件： </p><br><ul><li><p>  <strong>ScreenBuilders</strong>结合了流利的工厂，以生成标准的查找，编辑器和自定义屏幕。 以下示例显示了如何从另一个屏幕打开一个屏幕。 请注意， <em>build（）</em>方法返回正确类型的屏幕实例，而无需不安全地对其进行强制转换。 </p><br><p>  CurrencyConversions currencyConversions = screenBuilders.screen（此） <br>  .withScreenClass（CurrencyConversions.class） <br>  .withLaunchMode（OpenMode.DIALOG） <br>  .build（）; <br>  currencyConversions.setBaseCurrency（Currency.EUR）; <br>  currencyConversions.show（）; </p><br></li><li><p>  <strong>屏幕</strong>组件为创建和显示屏幕提供了较低层次的抽象，而不是<em>ScreenBuilders</em> 。 如果需要迭代它们，它还提供对CUBA应用程序中所有打开的屏幕（ <em>Screens＃getOpenedScreens</em> ）的信息的访问。 </p><br></li><li><p>  <strong>通知</strong>和<strong>对话框</strong>组件都引入了方便的自说明界面。 这是创建和显示对话框和通知的示例： </p><br><p>  dialogs.createOptionDialog（） <br>  .withCaption（“我的第一个对话框”） <br>  .withMessage（“您要感谢CUBA团队吗？”） <br>  .withActions（ <br> 新的DialogAction（DialogAction.Type.YES）.withHandler（e-&gt; <br>  notifications.create（） <br>  .withCaption（“谢谢！”） <br>  .withDescription（“我们感谢所有社区成员”） <br>  .withPosition（Notifications.Position.MIDDLE_CENTER） <br>  .withHideDelayMs（3000） <br>  .show（））， <br> 新的DialogAction（DialogAction.Type.CANCEL） <br>  ） <br>  .show（）; </p><br></li></ul><br><h3 id="data-binding"> 资料绑定 </h3><br><p>  CUBA不仅可以通过提供具有广泛代码生成功能的高级可视化工具，还可以通过立即可用的丰富的数据感知组件集，来快速开发后台UI。 这些组件只需要知道它们使用什么数据，其余的将自动进行管理，例如查找列表，选择器字段，具有CRUD操作的各种网格等。 </p><br><p> 在版本7之前，数据绑定是通过所谓的数据源实现的-数据对象包装单个实体或实体集合，以将其与数据感知组件进行反应性绑定。 这种方法效果很好，但是在实现方面却是一个整体。 整体架构通常会导致其自定义问题，因此在CUBA 7中，此坚固的巨石分为3个数据组件： </p><br><ul><li>  <strong>数据加载器</strong>是数据容器的数据提供者。 数据加载器不保留数据，它们只是将所有必需的查询参数传递到数据存储区，并使用结果数据集提供数据容器。 </li><li>  <strong>数据容器</strong>保留加载的数据（单个实体或多个实体），并以反应方式将其提供给数据感知组件：包装实体的所有更改都暴露于相应的UI组件，反之亦然，所有更改UI组件将导致其数据容器中的相应更改。 </li><li>  <strong>数据上下文</strong>是功能强大的数据修改管理器，可跟踪更改并提交所有修改的实体。 实体可以合并到数据上下文中，因此它将提供原始实体的副本，但唯一但非常重要的区别是：将跟踪，存储和结果实体的所有修改及其引用的所有实体（包括集合）作出相应的承诺。 </li></ul><br><p> 数据组件可以在屏幕描述符中声明，也可以使用专门的工厂<em>DataComponents以</em>编程方式实例化。 </p><br><h3 id="miscellaneous"> 杂项 </h3><br><p> 介绍了Ufff，它是新屏幕API的最重要部分，因此让我简要列出Web客户端层中的其他重要功能： </p><br><ul><li>  <strong>URL历史记录和导航</strong> 。 此功能使用Web浏览器中的“返回”按钮解决了SPA的一个非常普遍的问题，提供了一种将路由分配给应用程序屏幕的简便方法，并使API能够在其URL中反映屏幕的当前状态。 </li><li>  <strong>用Form代替FieldGroup</strong> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FieldGroup</a>是一个数据感知组件，用于显示和修改单个实体的字段。 它推断运行时为字段显示的实际UI。 换句话说，如果您的实体中有一个<em>Date</em>字段，它将显示为<em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DateField</a></em> 。 但是，如果您希望通过编程方式使用此字段，则需要将该字段注入到屏幕控制器，然后手动将其<em>强制</em>转换为正确的类型（ <em>在我们的示例中为DateField</em> ）。 稍后，我们将字段类型更改为其他类型，并且应用程序在运行时崩溃... Form通过显式字段类型声明解决了此问题。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>找到有关此新组件的更多信息。 </li><li>  <strong>第三方JavaScript组件的集成</strong>已大大简化，请按照<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>将自定义JavaScript组件嵌入到CUBA应用程序中。 </li><li> 现在，可以直接从xml屏幕描述符中定义<strong>HTML / CSS</strong>属性，也可以通过编程方式对其进行设置。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>查找更多信息。 </li></ul><br><h2 id="middleware-features"> 中间件功能 </h2><br><p> 之前有关新屏幕API的内容比我预期的要大，因此在本节中，我将力求简洁！ </p><br><h3 id="entity-changed-event"> 实体变更事件 </h3><br><p> 实体更改事件是Spring应用程序事件，当您的实体进入数据存储区，被物理插入并距离提交一英寸以内时，将触发该事件。 在这里，您可以提供一些附加检查（例如，在确认订单之前检查库存中的产品可用性），并在其他交易将其可见之前（当然，已读取提交的隔离级别）对其进行修改（例如，重新计算总计）。 您还可以将此事件用作通过抛出异常来中断提交事务的最后机会-这在某些特殊情况下可能很有用。 </p><br><p> 还有一种在提交发生后立即捕获Entity Changed Event的方法。 </p><br><p> 请遵循文档的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本章</a>以查看示例。 </p><br><h3 id="transactional-data-manager"> 交易数据管理器 </h3><br><p> 在开发应用程序时，我们通常使用分离的实体-不受任何事务管理的实体。 但是，并非总是可以使用分离的实体，尤其是在尝试满足ACID要求时-可以使用事务数据管理器时就是这种情况。 它看起来与普通的数据管理器非常相似，但是在以下方面有所不同： </p><br><ul><li> 它可以加入现有事务（如果在事务上下文中被调用）或创建自己的事务。 </li><li> 它没有<em>提交</em>方法，但是有保存方法，它不会导致立即提交，但是要等到附加的事务被提交后再进行。 </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>找到使用它的示例。 </p><br><h3 id="jpa-lifecycle-callbacks">  JPA生命周期回调 </h3><br><p> 最后，CUBA 7支持JPA生命周期回调。 为了不复制有关这些回调可用于什么用途的写得很好的信息，让我只分享<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此链接</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该链接</a>完全涵盖了该主题。 </p><br><h2 id="what-about-compatibility"> 兼容性呢？ </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d41/044/292/d410442925950409df8fdab04102dd95.png" alt="古巴5"></p><br><p> 对于任何主要发行版，这都是一个公平的问题，尤其是当有太多看似重大的更改时！ 我们在设计所有这些新功能和API时都考虑了向后兼容性： </p><br><ul><li>  CUBA 7支持旧的屏幕API，并通过幕后的新屏幕API实现：) </li><li> 我们还提供了用于旧数据绑定的适配器，这些适配器可继续用于旧屏幕。 </li></ul><br><p> 因此，好消息是，从版本6到版本7的迁移路径应该非常简单。 </p><br><h2 id="conclusion"> 结论 </h2><br><p> 在结束本技术概述时，我要提到还有其他重要的创新，尤其是在许可方面： </p><br><ul><li>  Studio的10个实体限制现已消失 </li><li> 现在免费提供报告，BPM，图表和地图以及全文搜索插件。 </li><li>  Studio的商业版本为实体，屏幕，菜单和其他平台元素的可视化设计师带来了额外的开发舒适度，而免费版本则专注于使用代码 </li><li> 请注意，对于6.x以及更低版本的Platform和Studio许可条款，请保持不变！ </li></ul><br><p> 最后，让我再次感谢社区成员的所有支持和反馈。 希望您会喜欢版本7！ 更改的完整列表通常在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发行说明中提供</a> 。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444558/">https://habr.com/ru/post/zh-CN444558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444548/index.html">个人经验：我们如何在拉丁美洲进行西班牙裔创业推广</a></li>
<li><a href="../zh-CN444550/index.html">关于划分的问题</a></li>
<li><a href="../zh-CN444552/index.html">TDMS航道。 与专业知识一起工作</a></li>
<li><a href="../zh-CN444554/index.html">Elixir上最简单的JSON RESTful API</a></li>
<li><a href="../zh-CN444556/index.html">太空中月亮和太阳的颜色的RGB和色温值</a></li>
<li><a href="../zh-CN444560/index.html">我们邀请您参加“云。 Fashion Trends” 2019年3月26日</a></li>
<li><a href="../zh-CN444562/index.html">GHIDRA的现代化。 朗姆Sega Mega Drive装载机</a></li>
<li><a href="../zh-CN444564/index.html">具有心理模型的数字产品开发</a></li>
<li><a href="../zh-CN444566/index.html">西科斯基与一名男子一起进行了无人直升机的演示</a></li>
<li><a href="../zh-CN444568/index.html">2018年发现的C ++项目的十大bug</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>