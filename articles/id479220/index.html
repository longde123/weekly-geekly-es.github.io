<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤩 👩🏿‍💼 🐼 Nano-neuron - 7 fungsi JavaScript sederhana yang menunjukkan bagaimana mesin dapat "belajar" 🚶🏿 👵🏻 🧖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nano-neuron adalah versi neuron yang disederhanakan dari konsep jaringan saraf. Nano-neuron melakukan tugas yang paling sederhana dan dilatih untuk me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nano-neuron - 7 fungsi JavaScript sederhana yang menunjukkan bagaimana mesin dapat "belajar"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479220/"><p>  <a href="https://github.com/trekhleb/nano-neuron" rel="nofollow"><strong>Nano-neuron</strong></a> adalah versi <a href="https://github.com/trekhleb/nano-neuron" rel="nofollow"><strong>neuron</strong></a> yang <em>disederhanakan</em> dari konsep jaringan saraf.  Nano-neuron melakukan tugas yang paling sederhana dan dilatih untuk mengubah suhu dari derajat Celsius ke derajat Fahrenheit. </p><br><p>  Kode <a href="" rel="nofollow"><strong>NanoNeuron.js</strong></a> terdiri dari 7 fungsi JavaScript sederhana yang melibatkan pembelajaran, pelatihan, prediksi, dan propagasi sinyal model secara langsung dan mundur.  Tujuan penulisan fungsi-fungsi ini adalah untuk memberikan pembaca sebuah penjelasan yang minimal dan mendasar (intuisi) tentang bagaimana, bagaimanapun, sebuah mesin dapat "belajar".  Kode tidak menggunakan pustaka pihak ketiga.  Seperti kata pepatah, hanya fungsi JavaScript "vanilla" yang sederhana. </p><br><p>  Fungsi-fungsi ini <strong>sama sekali</strong> bukan panduan lengkap untuk pembelajaran mesin.  Banyak konsep pembelajaran mesin hilang atau disederhanakan!  Penyederhanaan ini diperbolehkan untuk tujuan tunggal - untuk memberikan pembaca pemahaman dan intuisi paling <strong>mendasar</strong> tentang bagaimana sebuah mesin dapat, pada prinsipnya, "belajar", sehingga, sebagai akibatnya, "MAGIC pembelajaran mesin" terdengar lebih dan lebih kepada pembaca sebagai "MATEMATIKA pembelajaran mesin". </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/98d/6c4/69e/98d6c469e1facbf97154fe29f698cd12.png" alt="Nanoneuron"></p><a name="habracut"></a><br><h2 id="chto-vyuchit-nash-nano-neyron">  Apa yang akan dipelajari oleh nano-neuron kami </h2><br><p>  Anda mungkin pernah mendengar tentang neuron dalam konteks <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D0%25BA%25D1%2583%25D1%2581%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25B5%25D0%25B9%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B5%25D1%2582%25D1%258C" rel="nofollow">jaringan saraf</a> .  Nano-neuron adalah versi yang disederhanakan dari neuron yang sama.  Dalam contoh ini, kita akan menulis implementasinya dari awal.  Untuk kesederhanaan, kami tidak akan membangun jaringan nano-neuron.  Kami akan fokus pada pembuatan satu nano-neuron dan mencoba mengajarinya cara mengubah suhu dari derajat Celsius ke derajat Fahrenheit.  Dengan kata lain, kami akan mengajarinya untuk <strong>memprediksi</strong> suhu dalam derajat Fahrenheit berdasarkan suhu dalam derajat Celsius. </p><br><p>  Omong-omong, rumus untuk mengubah derajat Celcius ke derajat Fahrenheit adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9fa/2e8/8b5/9fa2e88b5a7324c8b9fc359b274ba091.png" alt="Celsius ke fahrenheit"></p><br><p>  Tetapi saat ini, nano-neuron kami tidak tahu apa-apa tentang formula ini ... </p><br><h3 id="model-nano-neyrona">  Model nano-neuron </h3><br><p> Mari kita mulai dengan membuat fungsi yang menggambarkan model nano-neuron kita.  Model ini adalah hubungan linear sederhana antara <code>x</code> dan <code>y</code> , yang terlihat seperti ini: <code>y = w * x + b</code> .  Sederhananya, nano-neuron kami adalah anak yang dapat menggambar garis lurus dalam sistem koordinat <code>XY</code> . </p><br><p>  Variabel <code>w</code> dan <code>b</code> adalah <strong>parameter</strong> model.  Sebuah nano-neuron hanya tahu dua parameter fungsi linear ini.  Parameter-parameter ini adalah apa yang akan dipelajari oleh nano-neuron kami selama proses pelatihan. </p><br><p>  Satu-satunya hal yang dapat dilakukan oleh nano-neuron pada tahap ini adalah untuk mensimulasikan hubungan linier.  Dia melakukan ini dalam metode <code>predict()</code> , yang mengambil variabel <code>x</code> pada input dan memprediksi variabel <code>y</code> pada output.  Tanpa sihir. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NanoNeuron</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.w = w; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = b; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.predict = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.w + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } }</code> </pre> <br><p>  _ (... tunggu ... <a href="https://en.wikipedia.org/wiki/Linear_regression" rel="nofollow">regresi linier</a> adalah Anda, atau apa?) _ </p><br><h3 id="konvertaciya-gradusov-celsiya-v-gradusy-farengeyta">  Konversi derajat Celcius ke derajat Fahrenheit </h3><br><p>  Suhu dalam derajat Celsius dapat dikonversi ke derajat Fahrenheit sesuai dengan rumus: <code>f = 1.8 * c + 32</code> , di mana <code>c</code> adalah suhu dalam derajat Celsius dan <code>f</code> adalah suhu dalam derajat Fahrenheit. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">celsiusToFahrenheit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w = <span class="hljs-number"><span class="hljs-number">1.8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = c * w + b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f; };</code> </pre> <br><p>  Sebagai hasilnya, kami ingin nano-neuron kami dapat mensimulasikan fungsi khusus ini.  Dia harus menebak (mengetahui) bahwa parameter <code>w = 1.8</code> dan <code>b = 32</code> tanpa mengetahuinya terlebih dahulu. </p><br><p>  Beginilah tampilan fungsi konversi pada bagan.  Itulah yang harus dipelajari "bayi" nano-saraf kami untuk "menggambar": </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/68b/0d6/8bc/68b0d68bcc7be00ec9526867b2fcecf3.png" alt="Konversi Celsius ke fahrenheit"></p><br><h3 id="generirovanie-dannyh">  Pembuatan data </h3><br><p>  Dalam pemrograman klasik, kita tahu input data ( <code>x</code> ) dan algoritma untuk mengkonversi data ini (parameter <code>w</code> dan <code>b</code> ), tetapi data output ( <code>y</code> ) tidak diketahui.  Output dihitung berdasarkan input menggunakan algoritma yang dikenal.  Dalam pembelajaran mesin, sebaliknya, hanya data input dan output ( <code>x</code> dan <code>y</code> ) yang diketahui, tetapi algoritma untuk beralih dari <code>x</code> ke <code>y</code> diketahui (parameter <code>w</code> dan <code>b</code> ). </p><br><p>  Ini adalah generasi input dan output yang akan kita lakukan sekarang.  Kita perlu menghasilkan data untuk <strong>melatih</strong> model kita dan data untuk <strong>menguji</strong> model.  Fungsi pembantu <code>celsiusToFahrenheit()</code> akan membantu kami dalam hal ini.  Masing-masing set data pelatihan dan tes adalah satu set pasangan <code>x</code> dan <code>y</code> .  Misalnya, jika <code>x = 2</code> , maka <code>y = 35,6</code> dan seterusnya. </p><br><blockquote>  Di dunia nyata, sebagian besar data kemungkinan <em>dikumpulkan</em> , bukan <em>dihasilkan</em> .  Misalnya, data yang dikumpulkan tersebut dapat berupa serangkaian "foto wajah" -&gt; "nama orang". </blockquote><p>  Kami akan menggunakan dataset PELATIHAN untuk melatih nano-neuron kami.  Sebelum dia tumbuh dan mampu mengambil keputusan sendiri, kita harus mengajarinya apa yang "benar" dan apa yang "salah" menggunakan data "benar" dari set pelatihan. </p><br><blockquote>  Omong-omong, di sini prinsip kehidupan "sampah di pintu masuk - sampah di pintu keluar" jelas ditelusuri.  Jika nano-neuron melemparkan "kebohongan" ke dalam kit pelatihan bahwa 5 ° C dikonversi menjadi 1000 ° F, maka setelah banyak iterasi pelatihan, ia akan percaya ini dan akan dengan benar mengkonversi semua nilai suhu <strong>kecuali</strong> 5 ° C.  Kita harus sangat berhati-hati dengan data pelatihan yang kita muat setiap hari ke dalam jaringan saraf otak kita. </blockquote><p>  Terganggu.  Mari kita lanjutkan. </p><br><p>  Kami akan menggunakan set data TEST untuk menilai seberapa baik nano-neuron kami telah dilatih dan dapat membuat prediksi yang benar pada data baru yang tidak dia lihat selama pelatihannya. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDataSets</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// xTrain -&gt; [0, 1, 2, ...], // yTrain -&gt; [32, 33.8, 35.6, ...] const xTrain = []; const yTrain = []; for (let x = 0; x &lt; 100; x += 1) { const y = celsiusToFahrenheit(x); xTrain.push(x); yTrain.push(y); } // xTest -&gt; [0.5, 1.5, 2.5, ...] // yTest -&gt; [32.9, 34.7, 36.5, ...] const xTest = []; const yTest = []; //   0.5    1,       //   ,       . for (let x = 0.5; x &lt; 100; x += 1) { const y = celsiusToFahrenheit(x); xTest.push(x); yTest.push(y); } return [xTrain, yTrain, xTest, yTest]; }</span></span></code> </pre> <br><h3 id="ocenka-pogreshnosti-predskazaniy">  Estimasi kesalahan prediksi </h3><br><p>  Kita membutuhkan metrik tertentu (pengukuran, jumlah, peringkat) yang akan menunjukkan seberapa dekat prediksi nano-neuron dengan true.  Dengan kata lain, angka / metrik / fungsi ini harus menunjukkan seberapa benar atau salahnya neuron nano.  Seperti di sekolah, seorang siswa bisa mendapat nilai <code>5</code> atau <code>2</code> untuk kendalinya. </p><br><p>  Dalam kasus nano-neuron, kesalahannya (kesalahan) antara nilai sebenarnya dari <code>y</code> dan nilai <code>prediction</code> akan dihasilkan oleh rumus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8d8/e50/ac1/8d8e50ac12d03614e65975f7b5d36931.png" alt="Biaya prediksi"></p><br><p>  Seperti dapat dilihat dari rumus, kita akan menganggap kesalahan sebagai perbedaan sederhana antara kedua nilai.  Semakin dekat nilainya satu sama lain, semakin kecil perbedaannya.  Kami menggunakan kuadrat di sini untuk menyingkirkan tanda, sehingga pada akhirnya <code>(1 - 2) ^ 2</code> setara dengan <code>(2 - 1) ^ 2</code> .  Pembagian dengan <code>2</code> terjadi semata-mata untuk menyederhanakan makna turunan dari fungsi ini dalam rumus untuk propagasi kembali sinyal (lebih lanjut tentang ini di bawah). </p><br><p>  Fungsi kesalahan dalam hal ini akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predictionCost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y, prediction</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (y - prediction) ** <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 235.6 }</span></span></code> </pre> <br><h3 id="pryamoe-rasprostranenie-signala">  Perambatan sinyal langsung </h3><br><p>  Perambatan sinyal langsung melalui model kami berarti membuat prediksi untuk semua pasangan dari <code>yTrain</code> data pelatihan <code>yTrain</code> dan <code>yTrain</code> dan menghitung rata-rata kesalahan (error) dari prediksi ini. </p><br><p>  Kami hanya membiarkan nano-neuron kami "berbicara", memungkinkannya untuk membuat prediksi (mengkonversi suhu).  Pada saat yang sama, nano-neuron pada tahap ini bisa sangat salah.  Nilai rata-rata kesalahan prediksi akan menunjukkan kepada kita seberapa jauh model kita / mendekati kebenaran saat ini.  Nilai kesalahan sangat penting di sini, karena dengan mengubah parameter <code>w</code> dan <code>b</code> dan propagasi sinyal langsung lagi, kita dapat mengevaluasi apakah nano-neuron kita telah menjadi "lebih pintar" dengan parameter baru atau tidak. </p><br><p>  Kesalahan prediksi rata-rata nano-neuron akan dilakukan menggunakan rumus berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/575/db3/e0a/575db3e0a0c872b29582147e41231344.png" alt="Biaya rata-rata"></p><br><p>  Di mana <code>m</code> adalah jumlah salinan pelatihan (dalam kasus kami, kami memiliki <code>100</code> pasangan data). </p><br><p>  Inilah cara kami dapat menerapkan ini dalam kode: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forwardPropagation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">model, xTrain, yTrain</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m = xTrain.length; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = []; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cost = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prediction = nanoNeuron.predict(xTrain[i]); cost += predictionCost(yTrain[i], prediction); predictions.push(prediction); } <span class="hljs-comment"><span class="hljs-comment">//     . cost /= m; return [predictions, cost]; }</span></span></code> </pre> <br><h3 id="obratnoe-rasprostranenie-signala">  Propagasi Balik Sinyal </h3><br><p>  Sekarang kita tahu bagaimana nano-neuron kita benar atau salah dalam prediksi (berdasarkan nilai rata-rata kesalahan), bagaimana kita bisa membuat prediksi lebih akurat? </p><br><p>  Perambatan sinyal terbalik akan membantu kita dalam hal ini.  Perambatan kembali sinyal adalah proses mengevaluasi kesalahan dari nano-neuron dan kemudian menyesuaikan parameternya <code>w</code> dan <code>b</code> sehingga prediksi nano-neuron berikutnya untuk seluruh rangkaian data pelatihan menjadi sedikit lebih akurat. </p><br><p>  Di sinilah pembelajaran mesin menjadi seperti sihir.  Konsep kunci di sini adalah <strong>turunan dari fungsi</strong> , yang menunjukkan ukuran langkah apa dan ke arah mana kita perlu mengambil untuk mendekati minimum fungsi (dalam kasus kami, minimum fungsi kesalahan). </p><br><p>  Tujuan akhir pelatihan nano-neuron adalah untuk menemukan minimum fungsi kesalahan (lihat fungsi di atas).  Jika kita dapat menemukan nilai <code>w</code> dan <code>b</code> di mana nilai rata-rata dari fungsi kesalahan kecil, maka ini berarti nano-neuron kita dapat mengatasi prediksi suhu dalam derajat Fahrenheit dengan baik. </p><br><p>  Derivatif adalah topik besar dan terpisah yang tidak akan kita bahas dalam artikel ini.  <a href="https://www.mathsisfun.com/calculus/derivatives-introduction.html" rel="nofollow">MathIsFun</a> adalah sumber yang bagus yang dapat memberikan pemahaman dasar tentang turunan. </p><br><p>  Satu hal yang harus kita pelajari dari esensi derivatif dan yang akan membantu kita memahami bagaimana backpropagation sinyal bekerja adalah bahwa turunan dari suatu fungsi pada titik <code>x</code> dan <code>y</code> , menurut definisi, adalah garis singgung pada kurva fungsi ini di <code>x</code> dan <code>y</code> dan <em>menunjukkan kita arah ke minimum fungsi</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66d/bfd/49a/66dbfd49aaf1ced48d7f6b5917fddb12.svg" alt="Kemiringan turunan"></p><br><p>  <em>Gambar diambil dari <a href="https://www.mathsisfun.com/calculus/derivatives-introduction.html" rel="nofollow">MathIsFun</a></em> </p><br><p>  Misalnya, dalam grafik di atas, Anda melihat bahwa pada titik <code>(x=2, y=4)</code> kemiringan garis singgung menunjukkan kepada kita bahwa kita perlu bergerak ke <code></code> dan ke <code></code> untuk mencapai minimum fungsi.  Juga perhatikan bahwa semakin besar kemiringan garis singgung, semakin cepat kita harus bergerak ke titik minimum. </p><br><p>  Turunan dari fungsi rata-rata kesalahan rata-rata <code>averageCost</code> dengan parameter <code>w</code> dan <code>b</code> akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4cc/bda/ba1/4ccbdaba120c399c1528e2bc38cf0efd.png" alt="dW"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e02/0cb/125/e020cb125449849009a9f565a32ff46f.png" alt="dB"></p><br><p>  Di mana <code>m</code> adalah jumlah salinan pelatihan (dalam kasus kami, kami memiliki <code>100</code> pasangan data). </p><br><p>  <em>Anda dapat membaca lebih detail tentang cara mengambil turunan dari fungsi kompleks di <a href="https://www.mathsisfun.com/calculus/derivatives-rules.html" rel="nofollow">sini</a> .</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backwardPropagation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">predictions, xTrain, yTrain</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m = xTrain.length; <span class="hljs-comment"><span class="hljs-comment">//           'w'  'b'. //      0. let dW = 0; let dB = 0; for (let i = 0; i &lt; m; i += 1) { dW += (yTrain[i] - predictions[i]) * xTrain[i]; dB += yTrain[i] - predictions[i]; } //    . dW /= m; dB /= m; return [dW, dB]; }</span></span></code> </pre> <br><h3 id="trenirovka-modeli">  Pelatihan model </h3><br><p>  Sekarang kita tahu bagaimana memperkirakan kesalahan / kesalahan prediksi model nano-neuron kami untuk semua data pelatihan (propagasi sinyal langsung).  Kita juga tahu bagaimana menyesuaikan parameter <code>w</code> dan <code>b</code> model nano-neuron (propagasi balik sinyal) untuk meningkatkan akurasi prediksi.  Masalahnya adalah jika kita melakukan propagasi sinyal maju dan mundur hanya sekali, maka ini tidak akan cukup bagi model kita untuk mengidentifikasi dan mempelajari dependensi dan hukum dalam data pelatihan.  Anda dapat membandingkan ini dengan kunjungan sekolah satu hari siswa.  Dia harus pergi ke sekolah secara teratur, hari demi hari, tahun demi tahun, untuk mempelajari semua materi. </p><br><p>  Jadi, kita harus <em>mengulangi</em> propagasi maju dan mundur sinyal berkali-kali.  Inilah yang dilakukan <code>trainModel()</code> .  Dia seperti "guru" untuk model nano-neuron kami: </p><br><ul><li>  dia akan menghabiskan waktu ( <code>epochs</code> ) dengan nano-neuron kita yang masih konyol, mencoba untuk melatihnya, </li><li>  dia akan menggunakan buku-buku khusus ( <code>yTrain</code> data <code>yTrain</code> dan <code>yTrain</code> ) untuk pelatihan, </li><li>  itu mendorong "siswa" kami untuk belajar lebih rajin (lebih cepat) menggunakan parameter <code>alpha</code> , yang pada dasarnya mengendalikan kecepatan belajar. </li></ul><br><p>  Beberapa kata tentang parameter <code>alpha</code> .  Ini hanya koefisien (pengganda) untuk nilai-nilai variabel <code>dW</code> dan <code>dB</code> , yang kami hitung selama propagasi belakang sinyal.  Jadi, turunannya menunjukkan kepada kita arah ke minimum fungsi kesalahan (tanda-tanda nilai <code>dW</code> dan <code>dB</code> memberi tahu kita tentang hal ini).  Derivatif juga menunjukkan kepada kita seberapa cepat kita perlu bergerak menuju minimum fungsi (nilai absolut <code>dW</code> dan <code>dB</code> memberi tahu kita tentang hal ini).  Sekarang kita perlu mengalikan ukuran langkah dengan <code>alpha</code> untuk menyesuaikan kecepatan pendekatan kita ke minimum (ukuran langkah total).  Kadang-kadang, jika kita menggunakan nilai besar untuk <code>alpha</code> , kita bisa melakukan langkah besar sehingga kita hanya bisa <em>melangkahi</em> minimum dari fungsi, sehingga melewatkannya. </p><br><p>  Dengan analogi dengan "guru", semakin kuat dia akan memaksa "siswa-nano" kita untuk belajar, semakin cepat dia akan belajar, TETAPI, jika Anda memaksakan dan menekannya dengan sangat keras, "siswa-nano" kita mungkin mengalami gangguan saraf dan sepenuhnya apatis dan dia tidak akan belajar apa pun. </p><br><p>  Kami akan memperbarui parameter model kami <code>w</code> dan <code>b</code> sebagai berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c7b/db8/84f/c7bdb884f2a940d62332246cdbcb44bc.png" alt="w"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b57/622/0ab/b576220ab6515d44255ef56699077bab.png" alt="b"></p><br><p>  Dan inilah bagaimana pelatihan itu sendiri terlihat: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trainModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{model, epochs, alpha, xTrain, yTrain}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     -.  . const costHistory = []; //    ()  for (let epoch = 0; epoch &lt; epochs; epoch += 1) { //   . const [predictions, cost] = forwardPropagation(model, xTrain, yTrain); costHistory.push(cost); //   . const [dW, dB] = backwardPropagation(predictions, xTrain, yTrain); //    -,    . nanoNeuron.w += alpha * dW; nanoNeuron.b += alpha * dB; } return costHistory; }</span></span></code> </pre> <br><h3 id="soberem-vse-funkcii-vmeste">  Menyatukan semua fitur </h3><br><p>  Waktu untuk menggunakan semua fungsi yang dibuat sebelumnya bersama-sama. </p><br><p>  Buat instance dari model nano-neuron.  Saat ini, nano-neuron tidak tahu apa-apa tentang parameter <code>w</code> dan <code>b</code> .  Jadi mari kita atur <code>w</code> dan <code>b</code> secara acak. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 0.9492 const b = Math.random(); // ie -&gt; 0.4570 const nanoNeuron = new NanoNeuron(w, b);</span></span></code> </pre> <br><p>  Kami menghasilkan set pelatihan dan data uji. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [xTrain, yTrain, xTest, yTest] = generateDataSets();</code> </pre> <br><p>  Sekarang mari kita coba latih model kita menggunakan langkah-langkah kecil ( <code>0.0005</code> ) untuk <code>70000</code> era.  Anda dapat bereksperimen dengan parameter ini, mereka ditentukan secara empiris. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> epochs = <span class="hljs-number"><span class="hljs-number">70000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.0005</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trainingCostHistory = trainModel({<span class="hljs-attr"><span class="hljs-attr">model</span></span>: nanoNeuron, epochs, alpha, xTrain, yTrain});</code> </pre> <br><p>  Mari kita periksa bagaimana nilai kesalahan model kami berubah selama pelatihan.  Kami berharap bahwa nilai kesalahan setelah pelatihan harus jauh lebih sedikit daripada sebelum pelatihan.  Ini berarti nano-neuron kita lebih bijaksana.  Pilihan sebaliknya juga dimungkinkan, ketika setelah pelatihan, kesalahan prediksi hanya meningkat (misalnya, nilai besar dari langkah <code>alpha</code> pembelajaran). </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'  :'</span></span>, trainingCostHistory[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 4694.3335043 console.log('  :', trainingCostHistory[epochs - 1]); // ie -&gt; 0.0000024</span></span></code> </pre> <br><p>  Dan di sini adalah bagaimana nilai kesalahan model berubah selama pelatihan.  Pada sumbu <code>x</code> adalah zaman (dalam ribuan).  Kami berharap grafik akan menurun. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/191/860/d6f/191860d6f0cd8cf7d24127f04f779462.png" alt="Proses pelatihan"></p><br><p>  Mari kita lihat parameter apa yang dipelajari nano-neuron kita.  Kami berharap bahwa parameter <code>w</code> dan <code>b</code> akan mirip dengan parameter dengan nama yang sama dari fungsi <code>celsiusToFahrenheit()</code> ( <code>w = 1.8</code> dan <code>b = 32</code> ), karena itu adalah nano-neuron yang saya coba simulasikan. </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' -:'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">w</span></span>: nanoNeuron.w, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: nanoNeuron.b}); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; {w: 1.8, b: 31.99}</span></span></code> </pre> <br><p>  Seperti yang Anda lihat, nano-neuron sangat dekat dengan fungsi <code>celsiusToFahrenheit()</code> . </p><br><p>  Sekarang mari kita lihat seberapa akurat prediksi nano-neuron kita untuk data uji yang tidak dia lihat selama pelatihan.  Kesalahan prediksi untuk data uji harus dekat dengan kesalahan prediksi untuk data pelatihan.  Ini berarti bahwa nano-neuron telah mempelajari dependensi yang benar dan dapat dengan benar mengabstraksikan pengalamannya dari data yang sebelumnya tidak diketahui (ini adalah nilai keseluruhan model). </p><br><pre> <code class="javascript hljs">[testPredictions, testCost] = forwardPropagation(nanoNeuron, xTest, yTest); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'   :'</span></span>, testCost); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 0.0000023</span></span></code> </pre> <br><p>  Sekarang, karena "nano-baby" kami terlatih dengan baik di "sekolah" dan sekarang tahu bagaimana mengkonversi derajat Celsius ke derajat Fahrenheit secara akurat bahkan untuk data yang tidak dia lihat, kita dapat memanggilnya "cukup pintar".  Sekarang kita bahkan bisa meminta saran padanya tentang konversi suhu, dan itulah tujuan dari seluruh pelatihan. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tempInCelsius = <span class="hljs-number"><span class="hljs-number">70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customPrediction = nanoNeuron.predict(tempInCelsius); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`- "",  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${tempInCelsius}</span></span></span><span class="hljs-string">°C   :`</span></span>, customPrediction); <span class="hljs-comment"><span class="hljs-comment">// -&gt; 158.0002 console.log('  :', celsiusToFahrenheit(tempInCelsius)); // -&gt; 158</span></span></code> </pre> <br><p>  Sangat dekat!  Seperti orang lain, nano-neuron kami baik, tetapi tidak sempurna :) </p><br><p>  Pengodean yang berhasil! </p><br><h2 id="kak-zapustit-i-protestirovat-nano-neyron">  Cara menjalankan dan menguji nano-neuron </h2><br><p>  Anda dapat mengkloning repositori dan menjalankan nano neuron secara lokal: </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/trekhleb/nano-neuron.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> nano-neuron</code> </pre> <br><pre> <code class="bash hljs">node ./NanoNeuron.js</code> </pre> <br><h2 id="upuschennye-koncepcii">  Konsep yang terlewatkan </h2><br><p>  Konsep pembelajaran mesin berikut telah dihilangkan atau disederhanakan untuk kemudahan penjelasan. </p><br><p>  <strong>Pemisahan set pelatihan dan data uji</strong> </p><br><p>  Biasanya Anda memiliki satu set data besar.  Bergantung pada jumlah salinan dalam set ini, pembagiannya ke dalam set pelatihan dan tes dapat dilakukan dalam proporsi 70/30.  Data di set harus dicampur secara acak sebelum dipisah.  Jika jumlah data besar (misalnya, jutaan), maka pembagian ke dalam set tes dan pelatihan dapat dilakukan dalam proporsi mendekati 90/10 atau 95/5. </p><br><p>  <strong>Kekuatan online</strong> </p><br><p>  Biasanya Anda tidak akan menemukan kasus ketika hanya satu neuron yang digunakan.  Kekuatan ada di <a href="https://en.wikipedia.org/wiki/Neural_network" rel="nofollow">jaringan</a> neuron semacam itu.  Jaringan saraf dapat mempelajari ketergantungan yang jauh lebih kompleks. </p><br><p>  Juga dalam contoh di atas, nano-neuron kami mungkin terlihat lebih seperti <a href="https://en.wikipedia.org/wiki/Linear_regression" rel="nofollow">regresi linier sederhana</a> daripada jaringan saraf. </p><br><p>  <strong>Input Normalisasi</strong> </p><br><p>  Sebelum pelatihan, biasanya untuk <a href="https://www.jeremyjordan.me/batch-normalization/" rel="nofollow">menormalkan data input</a> . </p><br><p>  <strong>Implementasi vektor</strong> </p><br><p>  Untuk jaringan saraf, perhitungan vektor (matriks) jauh lebih cepat daripada perhitungan <code>for</code> loop.  Biasanya propagasi sinyal langsung dan mundur dilakukan menggunakan operasi matriks menggunakan, misalnya, perpustakaan Python <a href="https://numpy.org/" rel="nofollow">Numpy</a> . </p><br><p>  <strong>Fungsi Kesalahan Minimum</strong> </p><br><p>  Fungsi kesalahan yang kami gunakan untuk neuron nano sangat sederhana.  Itu harus mengandung <a href="https://stackoverflow.com/questions/32986123/why-the-cost-function-of-logistic-regression-has-a-logarithmic-expression/32998675" rel="nofollow">komponen logaritmik</a> .  Suatu perubahan dalam rumus untuk fungsi kesalahan juga akan memerlukan perubahan dalam formula untuk perambatan sinyal maju dan mundur. </p><br><p>  <strong>Fungsi aktivasi</strong> </p><br><p>  Biasanya nilai output neuron melewati fungsi aktivasi.  Untuk aktivasi, fungsi-fungsi seperti <a href="https://en.wikipedia.org/wiki/Sigmoid_function" rel="nofollow">Sigmoid</a> , <a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)" rel="nofollow">ReLU</a> dan lainnya dapat digunakan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479220/">https://habr.com/ru/post/id479220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479202/index.html">C ++ dan Metode Numerik: Perkiraan Integrasi Newton-Cotes</a></li>
<li><a href="../id479210/index.html">Apa yang akan terjadi pada pembelian di toko online asing mulai 1 Januari 2020</a></li>
<li><a href="../id479214/index.html">Pilihan acara gratis mendatang untuk pengembang di Moskow # 2</a></li>
<li><a href="../id479216/index.html">Angin kedua Pandora DXL 3000 atau bagaimana saya mengacaukan telemetri saya sendiri</a></li>
<li><a href="../id479218/index.html">Cara membuat bot yang mengubah foto menjadi buku komik: petunjuk langkah demi langkah untuk boneka</a></li>
<li><a href="../id479222/index.html">Intisari materi menarik untuk pengembang ponsel # 325 (pada 2 - 8 Desember)</a></li>
<li><a href="../id479226/index.html">Analisis Habr: apa yang dipesan pengguna sebagai hadiah dari Habr</a></li>
<li><a href="../id479230/index.html">Dokumentasikan API ekspres Anda dengan anotasi sombong</a></li>
<li><a href="../id479232/index.html">Pengembangan aplikasi MQ JMS di Spring Boot</a></li>
<li><a href="../id479234/index.html">Berita dari dunia OpenStreetMap No. 488 (19/11/2019 - 25.11.2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>