<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📙 🧥 🔃 Analisis pendekatan pengikatan modul di Node.js 💌 ♈️ 🎄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak pengembang Node.js menggunakan modul (khusus) dependensi keras menggunakan memerlukan () untuk mengikat modul, tetapi ada pendekatan lain denga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis pendekatan pengikatan modul di Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438546/"> Banyak pengembang Node.js menggunakan modul (khusus) dependensi keras menggunakan memerlukan () untuk mengikat modul, tetapi ada pendekatan lain dengan pro dan kontra mereka.  Saya akan membicarakannya di artikel ini.  Empat pendekatan akan dipertimbangkan: <br><br><ul><li>  Ketergantungan keras (membutuhkan ()) </li><li>  Injeksi Ketergantungan </li><li>  Pencari Lokasi Layanan </li><li>  Kontainer Dependensi Tertanam (DI Container) </li></ul><a name="habracut"></a><br><h4>  Sedikit tentang modul </h4><br>  Modul dan arsitektur modular adalah dasar dari Node.js.  Modul menyediakan enkapsulasi (menyembunyikan detail implementasi dan hanya membuka antarmuka menggunakan module.exports), penggunaan kembali kode, pemecahan kode logis menjadi file.  Hampir semua aplikasi Node.js terdiri dari banyak modul yang entah bagaimana harus berinteraksi.  Jika Anda salah mengikat modul atau bahkan membiarkan interaksi modul melayang, maka Anda dapat dengan cepat menemukan bahwa aplikasi mulai "berantakan": perubahan kode di satu tempat menyebabkan kerusakan di tempat lain, dan unit testing menjadi sangat mustahil.  Idealnya, modul harus memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konektivitas</a> tinggi, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kopling</a> rendah. <br><br><h2>  Kecanduan keras </h2><br>  Ketergantungan yang kuat dari satu modul pada modul lainnya terjadi ketika membutuhkan () digunakan.  Ini adalah pendekatan yang efektif, sederhana dan umum.  Misalnya, kami hanya ingin menghubungkan modul yang bertanggung jawab untuk berinteraksi dengan database: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js const db = require('db'); //    ...</span></span></code> </pre> <br><h4>  Pro: </h4><br><ul><li>  Kesederhanaan </li><li>  Organisasi visual modul </li><li>  Debugging mudah </li></ul><br><h4>  Cons: </h4><br><ul><li>  Kesulitan untuk menggunakan kembali modul (misalnya, jika kita ingin menggunakan modul kita berulang kali, tetapi dengan contoh database yang berbeda) </li><li>  Kesulitan untuk pengujian unit (Anda harus membuat contoh database dummy dan entah bagaimana meneruskannya ke modul) </li></ul><br><h4>  Ringkasan: </h4><br>  Pendekatan ini baik untuk aplikasi kecil atau prototipe, serta untuk menghubungkan modul stateless: pabrik, perancang dan set fitur. <br><br><h2>  Injeksi Ketergantungan </h2><br>  Gagasan utama injeksi ketergantungan adalah untuk mentransfer dependensi dari komponen eksternal ke modul.  Dengan demikian, ketergantungan keras pada modul dihilangkan dan menjadi mungkin untuk menggunakannya kembali dalam konteks yang berbeda (misalnya, dengan contoh database yang berbeda). <br><br>  Injeksi ketergantungan dapat diimplementasikan dengan melewatkan dependensi dalam argumen konstruktor atau dengan mengatur properti modul, tetapi dalam praktiknya lebih baik menggunakan metode pertama.  Mari kita terapkan implementasi dependensi dalam praktik dengan membuat instance database menggunakan pabrik dan meneruskannya ke modul kami: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { //       ... };</span></span></code> </pre> <br>  Modul eksternal: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbFactory = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OurModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./ourModule.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbInstance = dbFactory.createInstance(<span class="hljs-string"><span class="hljs-string">'instance1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = OurModule(dbInstance);</code> </pre> <br>  Sekarang kita tidak hanya dapat menggunakan kembali modul kita, tetapi juga dengan mudah menulis unit test untuknya: cukup buat objek tiruan untuk instance basis data dan berikan ke modul. <br><br><h4>  Pro: </h4><br><ul><li>  Kemudahan tes unit menulis </li><li>  Meningkatkan penggunaan kembali modul </li><li>  Keterlibatan menurun, konektivitas meningkat </li><li>  Mengalihkan tanggung jawab untuk menciptakan dependensi ke level yang lebih tinggi - seringkali ini meningkatkan keterbacaan program, karena dependensi penting dikumpulkan di satu tempat, dan tidak disebarkan oleh modul </li></ul><br><h4>  Cons: </h4><br><ul><li>  Kebutuhan untuk desain dependensi yang lebih menyeluruh: misalnya, urutan inisialisasi modul tertentu harus diikuti </li><li>  Kompleksitas manajemen ketergantungan, terutama ketika ada banyak </li><li>  Kemunduran dalam kelengkapan kode modul: menulis kode modul ketika ketergantungan datang dari luar lebih sulit karena kita tidak bisa langsung melihat ketergantungan ini. </li></ul><br><h4>  Ringkasan: </h4><br>  Ketergantungan injeksi meningkatkan kompleksitas dan ukuran aplikasi, tetapi sebagai imbalannya memungkinkan penggunaan kembali dan membuat pengujian lebih mudah.  Pengembang harus memutuskan apa yang lebih penting baginya dalam kasus tertentu - kesederhanaan dari ketergantungan yang sulit atau kemungkinan yang lebih luas untuk memperkenalkan ketergantungan. <br><br><h2>  Pencari Lokasi Layanan </h2><br>  Idenya adalah untuk memiliki registry dependensi yang bertindak sebagai perantara ketika memuat dependensi dengan modul apa pun.  Alih-alih mengikat dengan keras, dependensi diminta oleh modul dari pencari layanan.  Jelas, modul memiliki ketergantungan baru - pelacak layanan itu sendiri.  Contoh dari pelacak layanan adalah sistem modul Node.js: modul meminta dependensi menggunakan require ().  Dalam contoh berikut, kami akan membuat pencari lokasi layanan, mendaftarkan instance basis data, dan modul kami di dalamnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// serviceLocator.js const dependencies = {}; const factories = {}; const serviceLocator = {}; serviceLocator.register = (name, instance) =&gt; { //[2] dependencies[name] = instance; }; serviceLocator.factory = (name, factory) =&gt; { //[1] factories[name] = factory; }; serviceLocator.get = (name) =&gt; { //[3] if(!dependencies[name]) { const factory = factories[name]; dependencies[name] = factory &amp;&amp; factory(serviceLocator); if(!dependencies[name]) { throw new Error('Cannot find module: ' + name); } } return dependencies[name]; };</span></span></code> </pre> <br>  Modul eksternal: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> serviceLocator = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./serviceLocator.js'</span></span>)(); serviceLocator.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = serviceLocator.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Modul kami: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (serviceLocator) =&gt; { const db = serviceLocator.get('db'); const someValue = serviceLocator.get('someParameter'); const ourModule = {}; //  ,   ... return ourModule; };</span></span></code> </pre> <br>  Perlu dicatat bahwa pelacak layanan menyimpan pabrik layanan alih-alih instance, dan itu masuk akal.  Kami mendapat manfaat dari inisialisasi malas, dan sekarang kami tidak perlu khawatir tentang urutan inisialisasi modul - semua modul akan diinisialisasi saat dibutuhkan.  Plus, kami mendapat kesempatan untuk menyimpan parameter di pencari layanan (lihat "someParameter"). <br><br><h4>  Pro: </h4><br><ul><li>  Kemudahan tes unit menulis </li><li>  Menggunakan kembali modul lebih mudah daripada dengan kecanduan yang keras </li><li>  Mengurangi keterlibatan, meningkatkan konektivitas dibandingkan dengan kecanduan keras </li><li>  Mengalihkan tanggung jawab untuk menciptakan ketergantungan ke tingkat yang lebih tinggi </li><li>  Tidak perlu mengikuti urutan inisialisasi modul </li></ul><br><h4>  Cons: </h4><br><ul><li>  Menggunakan kembali modul lebih sulit daripada menerapkan dependensi (karena ketergantungan tambahan dari pencari lokasi) </li><li>  Keterbacaan: Lebih sulit untuk memahami apa ketergantungan yang diperlukan oleh pencari layanan </li><li>  Keterlibatan meningkat dibandingkan dengan injeksi ketergantungan </li></ul><br><h4>  Ringkasan </h4><br>  Secara umum, pelacak layanan mirip dengan injeksi ketergantungan, dalam beberapa hal lebih mudah (tidak ada urutan inisialisasi), dalam beberapa kasus lebih sulit (kurang dari kemungkinan menggunakan kembali kode). <br><br><h2>  Kontainer Dependensi Tertanam (DI Container) </h2><br>  Locator layanan memiliki kelemahan karena jarang diterapkan dalam praktik - ketergantungan modul pada locator itu sendiri.  Wadah dependensi tertanam (wadah DI) tidak memiliki kelemahan ini.  Bahkan, ini adalah pencari layanan yang sama dengan fungsi tambahan yang menentukan dependensi modul sebelum membuat turunannya.  Anda bisa menentukan dependensi modul dengan mem-parsing dan mengekstraksi argumen dari konstruktor modul (dalam JavaScript, Anda bisa melemparkan tautan ke fungsi ke string menggunakan toString ()).  Metode ini cocok jika pengembangan berjalan murni untuk server.  Jika kode klien ditulis, sering kali diperkecil dan tidak ada gunanya mengekstrak nama argumen.  Dalam hal ini, daftar dependensi dapat diteruskan sebagai array string (dalam Angular.js, berdasarkan penggunaan wadah DI, pendekatan ini digunakan).  Kami menerapkan wadah DI menggunakan parsing argumen konstruktor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fnArgs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'parse-fn-args'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dependencies = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factories = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = {}; diContainer.factory = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { factories[name] = factory; }; diContainer.register = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, dep</span></span></span><span class="hljs-function">) =&gt;</span></span> { dependencies[name] = dep; }; diContainer.get = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factory = factories[name]; dependencies[name] = factory &amp;&amp; diContainer.inject(factory); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Cannot find module: '</span></span> + name); } } diContainer.inject = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = fnArgs(factory) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dependency</span></span></span><span class="hljs-function"> =&gt;</span></span> diContainer.get(dependency)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dependencies[name]; };</code> </pre> <br>  Dibandingkan dengan pelacak layanan, metode injeksi telah ditambahkan, yang menentukan dependensi modul sebelum membuat turunannya.  Kode modul eksternal tidak banyak berubah: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./diContainer.js'</span></span>)(); diContainer.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = diContainer.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Modul kami terlihat persis sama dengan injeksi ketergantungan sederhana: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { //       ... };</span></span></code> </pre> <br>  Sekarang modul kami dapat disebut keduanya dengan bantuan wadah DI dan melewatkannya contoh ketergantungan yang diperlukan secara langsung, menggunakan injeksi ketergantungan sederhana. <br><br><h4>  Pro: </h4><br><ul><li>  Kemudahan tes unit menulis </li><li>  Penggunaan kembali modul dengan mudah </li><li>  Berkurangnya keterlibatan, peningkatan konektivitas modul (terutama dibandingkan dengan pencari layanan) </li><li>  Mengalihkan tanggung jawab untuk menciptakan ketergantungan ke tingkat yang lebih tinggi </li><li>  Tidak perlu melacak inisialisasi modul </li></ul><br><h4>  Minus terbesar: </h4><br><ul><li>  Komplikasi signifikan dari logika pengikatan modul </li></ul><br><h4>  Ringkasan </h4><br>  Pendekatan ini lebih sulit untuk dipahami dan mengandung sedikit lebih banyak kode, tetapi sepadan dengan waktu yang dihabiskan untuk itu karena kekuatan dan keanggunannya.  Dalam proyek-proyek kecil, pendekatan ini mungkin berlebihan, tetapi harus dipertimbangkan jika aplikasi besar sedang dirancang. <br><br><h2>  Kesimpulan </h2><br>  Pendekatan dasar untuk pengikatan modul di Node.js. dipertimbangkan.  Seperti yang biasanya terjadi, "peluru perak" tidak ada, tetapi pengembang harus menyadari alternatif yang mungkin dan memilih solusi yang paling cocok untuk setiap kasus tertentu. <br><br>  Artikel ini didasarkan pada bab dari buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Node.js Design Patterns yang</a> dirilis pada 2017.  Sayangnya, banyak hal dalam buku ini sudah usang, jadi saya tidak bisa merekomendasikan 100% untuk membacanya, tetapi beberapa hal masih relevan sampai sekarang. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438546/">https://habr.com/ru/post/id438546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438536/index.html">Di bawah kap chatbot: apa yang dapat dilakukan oleh RocketBot dan cara kerjanya</a></li>
<li><a href="../id438538/index.html">Teamlead Conf 2019 Msk: tentang format komunikasi lain</a></li>
<li><a href="../id438540/index.html">Tren dalam manajemen dokumen dan penyimpanan data untuk 2019</a></li>
<li><a href="../id438542/index.html">Bagaimana kami menciptakan layanan rekomendasi untuk pemilihan pakaian di jaringan saraf</a></li>
<li><a href="../id438544/index.html">Kami menonton film di rumah: 10 materi tentang membangun teater rumah dan memilih peralatan</a></li>
<li><a href="../id438548/index.html">Lombok, sources.jar dan debug nyaman</a></li>
<li><a href="../id438550/index.html">Manifes lain</a></li>
<li><a href="../id438554/index.html">Mengelola keadaan dan acara antar komponen di GameObject</a></li>
<li><a href="../id438556/index.html">Menggergaji data dengan nyaman</a></li>
<li><a href="../id438560/index.html">Menulis XGBoost dari awal - bagian 1: pohon keputusan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>