<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐑 🤾 🛑 Dasar-dasar mesin JavaScript: optimasi prototipe. Bagian 2 🛀🏿 🧝🏽 🗾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat sore teman! Kursus "Keamanan sistem informasi" telah diluncurkan, sehubungan dengan ini kami berbagi dengan Anda bagian akhir dari artikel "Da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar mesin JavaScript: optimasi prototipe. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449144/">  Selamat sore teman!  Kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Keamanan sistem informasi" telah</a> diluncurkan, sehubungan dengan ini kami berbagi dengan Anda bagian akhir dari artikel "Dasar-dasar mesin JavaScript: optimalisasi prototipe", bagian pertama yang dapat dibaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Kami juga mengingatkan Anda bahwa publikasi saat ini adalah kelanjutan dari dua artikel ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Dasar-dasar mesin JavaScript: formulir umum dan caching Inline.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1 "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">" Dasar-dasar mesin JavaScript: formulir umum dan caching Inline.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2 "</a> . <br><br><img src="https://habrastorage.org/webt/2w/nl/r8/2wnlr8o2nlb7dcbfs4hgkbmf-hm.png"><br><br>  <b>Kelas dan pemrograman prototipe</b> <br><br>  Sekarang setelah kita tahu cara mendapatkan akses cepat ke properti objek JavaScript, kita dapat melihat struktur kelas JavaScript yang lebih kompleks.  Ini adalah apa yang tampak seperti sintaksis kelas dalam JavaScript: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } }</code> </pre> <a name="habracut"></a><br>  Meskipun ini tampaknya seperti konsep yang relatif baru untuk JavaScript, itu hanya "gula sintaksis" untuk pemrograman prototipe yang selalu digunakan dalam JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Di sini kita menetapkan properti <code>getX</code> ke objek <code>getX</code> .  Ini akan berfungsi seperti halnya dengan objek lain, karena prototipe dalam JavaScript adalah objek yang sama.  Dalam bahasa pemrograman prototipe seperti JavaScript, metode diakses melalui prototipe, sementara bidang disimpan dalam kasus tertentu. <br><br>  Mari kita lihat lebih dekat apa yang terjadi ketika kita membuat instance baru dari <code>Bar</code> , yang akan kita sebut <code>foo</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Sebuah instance yang dibuat menggunakan kode ini memiliki formulir dengan properti <code>'x'</code> tunggal.  Prototipe <code>foo</code> adalah <code>Bar.prototype</code> , yang termasuk dalam kelas <code>Bar</code> . <br><br><img src="https://habrastorage.org/webt/bo/fa/q_/bofaq_0uieucjmw-dys_fv6rzk8.png"><br><br>  <code>Bar.prototype</code> ini memiliki bentuk sendiri, berisi satu-satunya properti <code>'getX'</code> , yang nilainya ditentukan oleh fungsi <code>'getX'</code> , yang ketika dipanggil mengembalikan <code>this.x</code>  Prototipe <code>Bar.prototype</code> adalah <code>Object.prototype</code> , yang merupakan bagian dari bahasa JavaScript.  <code>Object.prototype</code> adalah akar dari pohon prototipe, sedangkan prototipenya adalah <code>null</code> . <br><br><img src="https://habrastorage.org/webt/do/wd/bu/dowdbubzibagdufziezgg9sp_tq.png"><br><br>  Saat Anda membuat instance baru dari kelas yang sama, kedua instance memiliki bentuk yang sama, seperti yang sudah kita pahami.  Kedua instance akan menunjuk ke objek <code>Bar.prototype</code> sama. <br><br>  <b>Akses properti prototipe</b> <br><br>  Nah, sekarang kita tahu apa yang terjadi ketika kita mendefinisikan kelas dan membuat instance baru.  Tetapi apa yang terjadi jika kita memanggil metode pada contoh, seperti yang kita lakukan pada contoh berikut? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Anda dapat mempertimbangkan pemanggilan metode apa pun sebagai dua langkah terpisah: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// is actually two steps: const $getX = foo.getX; const x = $getX.call(foo);</span></span></code> </pre><br>  Langkah pertama adalah memuat metode, yang sebenarnya merupakan properti dari prototipe (yang nilainya adalah fungsi).  Langkah kedua adalah memanggil fungsi dengan instance, misalnya, nilai <code>this</code> .  Mari kita lihat lebih dekat pada langkah pertama di mana metode <code>getX</code> dari instance <code>foo</code> . <br><br><img src="https://habrastorage.org/webt/-o/8_/wo/-o8_wolugn73mtcs65v_yomvtzo.png"><br><br>  Mesin memulai turunan <code>foo</code> dan menyadari bahwa form <code>foo</code> tidak memiliki <code>'getX'</code> , sehingga harus melalui rantai prototipe untuk menemukannya.  Kita sampai ke <code>Bar.prototype</code> , lihat pada bentuk prototipe, lihat bahwa ia memiliki properti <code>'getX'</code> dengan nol offset  Kami mencari nilai pada offset ini di <code>Bar.prototype</code> dan menemukan <code>JSFunction getX</code> yang kami cari. <br><br>  Fleksibilitas JavaScript memungkinkan tautan rantai prototipe berubah, misalnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// → true Object.setPrototypeOf(foo, null); foo.getX(); // → Uncaught TypeError: foo.getX is not a function</span></span></code> </pre> <br>  Dalam contoh ini, kami menelepon <pre> <code class="javascript hljs">foo.getX()</code> </pre>  dua kali, tetapi setiap kali memiliki arti dan hasil yang sama sekali berbeda.  Itulah sebabnya, meskipun fakta bahwa prototipe hanyalah objek dalam JavaScript, mempercepat akses ke properti prototipe adalah tugas yang bahkan lebih penting untuk mesin JavaScript daripada mempercepat akses mereka sendiri ke properti pada objek biasa. <br><br>  Dalam praktik sehari-hari, memuat properti prototipe adalah operasi yang cukup umum: ini terjadi setiap kali Anda memanggil metode! <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Sebelumnya, kami berbicara tentang bagaimana mesin mengoptimalkan pemuatan properti reguler dengan menggunakan formulir dan cache inline.  Bagaimana saya bisa mengoptimalkan pemuatan properti prototipe untuk objek dengan bentuk yang sama?  Dari atas kita melihat bagaimana properti dimuat. <br><br><img src="https://habrastorage.org/webt/h1/1q/tw/h11qtwohm_mgsjyp0iphqairudo.png"><br><br>  Untuk melakukan ini dengan cepat dengan unduhan berulang dalam kasus khusus ini, Anda perlu mengetahui tiga hal berikut: <br><br><ul><li>  Bentuk <code>foo</code> tidak mengandung <code>'getX'</code> dan tidak berubah.  Ini berarti bahwa tidak ada seorang pun yang mengubah objek foo dengan menambahkan atau menghapus properti atau mengubah salah satu atribut properti. </li><li>  Prototipe foo masih merupakan <code>Bar.prototype</code> asli.  Jadi tidak ada yang mengubah prototipe <code>foo</code> menggunakan <code>Object.setPrototypeOf()</code> atau menugaskannya ke properti <code>_proto_</code> khusus. </li><li>  Formulir <code>Bar.prototype</code> berisi <code>'getX'</code> dan belum berubah.  Ini berarti bahwa tidak ada yang mengubah <code>Bar.prototype</code> dengan menambahkan atau menghapus properti atau mengubah salah satu atribut properti. </li></ul><br>  Dalam kasus umum, ini berarti bahwa Anda perlu membuat satu pemeriksaan instance itu sendiri dan dua pemeriksaan lagi untuk setiap prototipe hingga prototipe yang berisi properti yang diinginkan.  1 + 2N memeriksa, di mana N adalah jumlah prototipe yang digunakan, tidak terdengar begitu buruk dalam kasus ini, karena rantai prototipe relatif dangkal.  Namun, mesin sering harus berurusan dengan rantai prototipe yang lebih lama, seperti halnya dengan kelas DOM reguler.  Sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// → HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Kami memiliki <code>HTMLAnchorElement</code> dan kami memanggil metode <code>getAttribute()</code> .  Rantai untuk elemen sederhana ini sudah termasuk 6 prototipe!  Sebagian besar metode DOM yang menarik minat kita bukan pada prototipe <code>HTMLAnchorElement</code> , tetapi di suatu tempat di rantai. <br><br><img src="https://habrastorage.org/webt/wz/kw/fa/wzkwfavxcgkiod8jgz0ybrmgzo8.png"><br><br>  Metode <code>getAttribute()</code> ada di <code>Element.prototype</code> .  Ini berarti bahwa setiap kali kita memanggil <code>anchor.getAttribute()</code> , mesin JavaScript perlu: <br><br><ol><li>  Periksa bahwa <code>'getAttribute'</code> bukan objek <code>anchor</code> per se; </li><li>  Verifikasi bahwa prototipe terakhir adalah <code>HTMLAnchorElement.prototype</code> ; </li><li>  Konfirmasikan tidak adanya <code>'getAttribute'</code> sana; </li><li>  Verifikasi bahwa prototipe berikutnya adalah <code>HTMLElement.prototype</code> ; </li><li>  Konfirmasikan tidak adanya <code>'getAttribute'</code> ; </li><li>  Verifikasi bahwa prototipe berikutnya adalah <code>Element.prototype</code> ; </li><li>  Periksa apakah <code>'getAttribute'</code> ada di dalamnya. </li></ol><br>  Sebanyak 7 cek.  Karena jenis kode ini cukup umum di web, mesin menggunakan berbagai trik untuk mengurangi jumlah pemeriksaan yang diperlukan untuk memuat properti prototipe. <br><br>  Kembali ke contoh sebelumnya di mana kami hanya melakukan tiga pemeriksaan ketika meminta <code>'getX'</code> untuk <code>foo</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Untuk setiap objek yang terjadi sebelum prototipe yang berisi properti yang diinginkan, perlu untuk memeriksa formulir untuk tidak adanya properti ini.  Alangkah baiknya jika kita bisa mengurangi jumlah cek dengan menghadirkan cek prototipe sebagai cek untuk tidak adanya properti.  Intinya, inilah yang dilakukan mesin dengan trik sederhana: alih-alih menyimpan tautan prototipe ke instance itu sendiri, engine menyimpannya dalam bentuk. <br><br><img src="https://habrastorage.org/webt/_q/j1/8q/_qj18qiex6e31a17r7sgho1r5hc.png"><br><br>  Setiap bentuk menunjukkan prototipe.  Ini berarti bahwa setiap kali prototipe <code>foo</code> berubah, mesin pindah ke bentuk baru.  Sekarang kita perlu memeriksa hanya bentuk objek untuk mengkonfirmasi tidak adanya properti tertentu, serta melindungi tautan prototipe (menjaga tautan prototipe). <br><br>  Dengan pendekatan ini, kami dapat mengurangi jumlah cek yang diperlukan dari 2N + 1 hingga 1 + N untuk mempercepat akses.  Ini masih merupakan operasi yang cukup mahal, karena masih merupakan fungsi linier dari jumlah prototipe dalam rantai.  Mesin menggunakan berbagai trik untuk lebih mengurangi jumlah cek ke nilai konstan tertentu, terutama dalam kasus pemuatan berurutan dari properti yang sama. <br><br>  <b>Sel validitas</b> <br><br>  V8 memproses formulir prototipe khusus untuk tujuan ini.  Setiap prototipe memiliki bentuk unik yang tidak dibagi dengan objek lain (khususnya, dengan prototipe lain), dan masing-masing bentuk prototipe ini memiliki <code>ValidityCell</code> khusus yang terkait dengannya. <br><br><img src="https://habrastorage.org/webt/pm/gc/m_/pmgcm_cjj6ufzx_dw8npfdbx2wi.png"><br><br>  <code>ValidityCell</code> dinonaktifkan setiap kali seseorang mengubah prototipe yang terkait dengannya atau prototipe lain di atasnya.  Mari kita lihat cara kerjanya. <br>  Untuk mempercepat unduhan prototipe berikutnya, V8 menempatkan cache Inline di lokasi empat bidang: <br><br><img src="https://habrastorage.org/webt/mr/ab/d2/mrabd2cyki6gglqlxphuqhjzoji.png"><br><br>  Ketika cache inline dipanaskan saat pertama kali kode dijalankan, V8 mengingat offset di mana properti ditemukan dalam prototipe, prototipe ini (misalnya, <code>Bar.prototype</code> ), bentuk instance (dalam kasus kami, form <code>foo</code> ), dan juga mengikat <code>ValidityCell</code> saat ini ke prototipe yang diterima dari contoh formulir (dalam kasus kami, <code>Bar.prototype</code> diambil). <br><br>  Lain kali Anda menggunakan cache Inline, mesin perlu memeriksa formulir instance dan <code>ValidityCell</code> .  Jika masih valid, mesin langsung menggunakan offset pada prototipe, melewatkan langkah-langkah pencarian tambahan. <br><br><img src="https://habrastorage.org/webt/hd/qw/4w/hdqw4wkuumyd9dmm0opxan9cbji.png"><br><br>  Saat Anda mengubah prototipe, formulir baru disorot, dan sel <code>ValidityCell</code> sebelumnya dinonaktifkan.  Karena itu, cache Inline dilewati saat berikutnya dimulai, yang berujung pada kinerja yang buruk. <br><br>  Mari kita kembali ke contoh dengan elemen DOM.  Setiap perubahan <code>Object.prototype</code> tidak hanya membatalkan cache Inline untuk <code>Object.prototype</code> , tetapi juga untuk setiap prototipe dalam rantai di bawahnya, termasuk <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , dll., <code>HTMLAnchorElement.prototype</code> itu sendiri. <br><br><img src="https://habrastorage.org/webt/oo/ml/ga/oomlgamrgo0peti1y3xsae-vtes.png"><br><br>  Bahkan, memodifikasi <code>Object.prototype</code> saat kode sedang dieksekusi adalah kehilangan kinerja yang mengerikan.  Jangan lakukan ini! <br><br>  Mari kita lihat contoh spesifik untuk lebih memahami bagaimana ini bekerja.  Katakanlah kita memiliki kelas <code>Bar</code> dan fungsi <code>loadX</code> yang memanggil metode pada objek bertipe <code>Bar</code> .  Kami memanggil fungsi <code>loadX</code> beberapa kali dengan instance dari kelas yang sama. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); <span class="hljs-comment"><span class="hljs-comment">// IC for 'getX' on `Bar` instances. } loadX(new Bar(true)); loadX(new Bar(false)); // IC in `loadX` now links the `ValidityCell` for // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // The `ValidityCell` in the `loadX` IC is invalid // now, because `Object.prototype` changed.</span></span></code> </pre> <br>  Cache sebaris di <code>loadX</code> sekarang menunjuk ke <code>ValidityCell</code> untuk <code>Bar.prototype</code> .  Jika Anda kemudian memodifikasi (mutate) <code>Object.prototype</code> , yang merupakan akar dari semua prototipe dalam JavaScript, <code>ValidityCell</code> menjadi tidak valid dan cache Inline yang ada tidak akan digunakan lain kali, yang mengakibatkan kinerja buruk. <br><br>  Mengubah <code>Object.prototype</code> selalu merupakan ide yang buruk, karena membatalkan semua cache Inline untuk prototipe yang dimuat pada saat perubahan.  Ini adalah contoh bagaimana TIDAK harus dilakukan: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Run critical code: someObject.foo(); // End of critical code. delete Object.prototype.foo;</span></span></code> </pre> <br>  Kami sedang memperluas <code>Object.prototype</code> , yang membatalkan semua cache prototipe Inline yang dimuat oleh mesin pada saat ini.  Kemudian kita akan menjalankan beberapa kode yang menggunakan metode yang dijelaskan oleh kita.  Mesin harus mulai dari awal dan mengkonfigurasi cache Inline untuk setiap akses ke properti prototipe.  Dan akhirnya, "bersihkan" dan hapus metode prototipe yang kami tambahkan sebelumnya. <br><br>  Anda pikir membersihkan adalah ide yang bagus, bukan?  Nah, dalam hal ini, ini akan semakin memperburuk situasi!  Menghapus properti mengubah <code>Object.prototype</code> , sehingga semua cache Inline dinonaktifkan lagi, dan mesin harus mulai bekerja dari awal lagi. <br><br>  <b>Untuk meringkas</b> .  Terlepas dari kenyataan bahwa prototipe hanyalah objek, mereka secara khusus diproses oleh mesin JavaScript untuk mengoptimalkan kinerja pencarian metode oleh prototipe.  <b>Biarkan prototipe sendiri!</b>  Atau jika Anda benar-benar harus berurusan dengan mereka, lakukan sebelum menjalankan kode, sehingga Anda setidaknya tidak akan membatalkan semua upaya untuk mengoptimalkan kode Anda selama eksekusi! <br><br><blockquote>  <b>Ringkaslah</b> <br><br>  Kami mempelajari bagaimana JavaScript menyimpan objek dan kelas, dan bagaimana formulir, cache inline, dan sel validitas membantu mengoptimalkan operasi prototipe.  Berdasarkan pengetahuan ini, kami memahami cara meningkatkan kinerja dari sudut pandang praktis: jangan menyentuh prototipe!  (atau jika Anda benar-benar membutuhkannya, lakukan sebelum menjalankan kode). </blockquote><br>  ← <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> <br><br>  Apakah seri publikasi ini bermanfaat bagi Anda?  Tulis di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449144/">https://habr.com/ru/post/id449144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449132/index.html">17 plugin teratas untuk Android Studio</a></li>
<li><a href="../id449134/index.html">Kebun binatang afl</a></li>
<li><a href="../id449138/index.html">5 alasan untuk crypto-hat Mengapa orang IT tidak menyukai bitcoin</a></li>
<li><a href="../id449140/index.html">Tinggalkan permintaan dan kami akan membalas Anda online dalam 1 menit. Atau bagaimana kami berjalan menjauh dari OTRS</a></li>
<li><a href="../id449142/index.html">Mikrobiota. Bakteri apa yang hidup di usus Rusia</a></li>
<li><a href="../id449146/index.html">Tapi bukankah kita melambaikan komunikasi optik? Laser, luar angkasa, CubeSat</a></li>
<li><a href="../id449148/index.html">Buku-buku seni anak-anak tentang rekayasa sosial</a></li>
<li><a href="../id449154/index.html">FAQ tentang pelabelan wajib sepatu: Segala sesuatu yang Anda tidak tahu dan takut untuk bertanya</a></li>
<li><a href="../id449158/index.html">Rough Coster: Community Cookbook</a></li>
<li><a href="../id449162/index.html">C ++ Rusia 2019. Sebuah laporan kecil dari tempat acara dan pengumuman konferensi berikutnya di St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>