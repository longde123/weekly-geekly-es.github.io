<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎓 🎸 🤠 Banding bit perangkat keras CortexM3 / M4 (ARM), arsitektur kernel, assembler, C / C ++ 14 dan setetes metaprogramming 🤲🏿 ⛪️ 💃🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Perhatian, ini bukan artikel "Hello world" lainnya tentang cara mengedipkan LED atau memasuki interupsi pertama pada STM32. Namun, saya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Banding bit perangkat keras CortexM3 / M4 (ARM), arsitektur kernel, assembler, C / C ++ 14 dan setetes metaprogramming</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454408/"><h2>  Pendahuluan </h2><br>  Perhatian, ini bukan artikel "Hello world" lainnya tentang cara mengedipkan LED atau memasuki interupsi pertama pada STM32.  Namun, saya mencoba untuk memberikan penjelasan komprehensif tentang semua masalah yang diangkat, sehingga artikel ini akan bermanfaat tidak hanya bagi banyak profesional dan bermimpi menjadi pengembang seperti itu (seperti yang saya harapkan), tetapi juga untuk pemrogram mikrokontroler pemula, karena topik ini karena beberapa alasan beredar di banyak situs / blog "guru pemrograman MK." <br><br><img src="https://habrastorage.org/webt/e5/rs/75/e5rs75rpejygxwippglfvpftzci.png" alt="gambar"><br><a name="habracut"></a><br><h2>  Mengapa saya memutuskan untuk menulis ini? </h2><br>  Meskipun saya melebih-lebihkan, setelah mengatakan sebelumnya bahwa bit banding perangkat keras keluarga Cortex-M tidak dijelaskan pada sumber daya khusus, masih ada tempat-tempat di mana fitur ini dibahas (dan bahkan bertemu satu artikel di sini), tetapi topik ini jelas perlu ditambah dan dimodernisasi.  Saya perhatikan bahwa ini juga berlaku untuk sumber daya berbahasa Inggris.  Di bagian selanjutnya, saya akan menjelaskan mengapa fitur kernel ini bisa sangat penting. <br><br><h2>  Teori </h2><br>  <i>(dan mereka yang mengenalnya bisa langsung berlatih)</i> <br>  Hardware bit banding adalah fitur dari inti itu sendiri, dan oleh karena itu tidak tergantung pada keluarga dan perusahaan pembuat mikrokontroler, hal utama adalah bahwa inti tersebut cocok.  Dalam kasus kami, biarlah Cortex-M3.  Oleh karena itu, informasi tentang masalah ini harus dicari dalam dokumen resmi tentang inti itu sendiri, dan ada dokumen seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">itu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini dia</a> , bagian 4.2 menjelaskan secara rinci bagaimana menggunakan alat ini. <br><br>  Di sini saya ingin membuat penyimpangan teknis kecil untuk programmer yang tidak terbiasa dengan assembler, yang mayoritasnya sekarang, karena kompleksitas propagandized dan tidak berguna assembler untuk mikrokontroler 32-bit "serius" seperti STM32, LPC, dll. Selain itu, kita sering dapat menghadapi upaya kecaman untuk penggunaan assembler di daerah ini, bahkan pada Habr.  Pada bagian ini saya ingin menjelaskan secara singkat mekanisme penulisan ke memori MK, yang seharusnya menjelaskan keunggulan bit banding. <br><br>  Saya akan menjelaskan contoh sederhana spesifik untuk sebagian besar STM32.  Misalkan saya perlu mengubah PB0 menjadi output untuk keperluan umum.  Solusi khas akan terlihat seperti ini: <br><br><pre><code class="cpp hljs">GPIOB-&gt;MODER |= GPIO_MODER_MODER0_0;</code> </pre> <br>  Jelas, kami menggunakan bitwise "OR" agar tidak menimpa bit register yang tersisa. <br><br>  Untuk kompiler, ini diterjemahkan ke dalam 4 instruksi berikut: <br><br><ol><li>  Unduh GPIOB-&gt; MODER ke register tujuan umum (RON) </li><li>  Unggah nilai ke RON lain di alamat yang ditunjukkan di RON dari p1. </li><li>  Buat bitwise ATAU dari nilai ini dengan GPIO_MODER_MODER0_0. </li><li>  Unduh hasilnya kembali ke GPIOB-&gt; MODER. </li></ol><br>  Juga, orang tidak boleh lupa bahwa kernel ini menggunakan set instruksi thumb2, yang berarti bahwa mereka dapat berbeda dalam volume.  Saya juga mencatat bahwa di mana-mana kita berbicara tentang tingkat optimasi O3. <br><br>  Dalam bahasa assembly, tampilannya seperti ini: <br><br><img src="https://habrastorage.org/webt/kt/px/tf/ktpxtfc4bapih79fj96yf7poi64.png" alt="gambar"><br><br>  Dapat dilihat bahwa instruksi pertama adalah tidak lebih dari instruksi semu dengan offset, kami menemukan alamat register di alamat PC (diberi ban berjalan) + 0x58. <br><br><img src="https://habrastorage.org/webt/wf/ar/ea/wfareavtgdjjmqckiemg0jfbygs.png" alt="gambar"><br><br>  Ternyata kami memiliki 4 langkah (dan lebih banyak siklus clock) dan 14 byte memori yang digunakan per operasi. <br>  Jika Anda ingin tahu lebih banyak tentang ini, maka saya merekomendasikan buku [2], omong-omong, ada juga dalam bahasa Rusia. <br><br><h3>  Kami meneruskan ke metode bit_banding. </h3><br>  Intinya, menurut petani, adalah bahwa prosesor memiliki area memori yang dialokasikan khusus, menulis nilai-nilai di mana kita tidak mengubah bit lain dari register periferal atau RAM.  Artinya, kita tidak perlu memenuhi poin 2) dan 3) yang dijelaskan di atas, dan untuk ini cukup dengan hanya menceritakan alamat sesuai dengan rumus dari [1]. <br><br><img src="https://habrastorage.org/webt/t1/fo/yu/t1foyujiyauoiecjczide1myroi.png" alt="gambar"><br><br>  Kami mencoba melakukan operasi serupa, assemblernya: <br><br><img src="https://habrastorage.org/webt/j_/g-/6d/j_g-6dq9yi1cjt0yxbo7rzqbmrw.png" alt="gambar"><br><br>  Alamat yang dihitung ulang: <br><br><img src="https://habrastorage.org/webt/du/1k/qp/du1kqpsrhjinmp6y4i2hkuqeut4.png" alt="gambar"><br><br>  Di sini kami menambahkan instruksi tulis # 1 di RON, tetapi bagaimanapun, hasilnya adalah 10 byte, bukan 14, dan beberapa siklus clock lebih sedikit. <br><br><h2>  Tetapi bagaimana jika perbedaannya konyol? </h2><br>  Di satu sisi, penghematan tidak signifikan, terutama dalam siklus ketika sudah menjadi kebiasaan overclocking controller ke 168 MHz.  Dalam proyek rata-rata, saat-saat di mana Anda dapat menerapkan metode ini masing-masing adalah 40 - 80, dalam byte penghematan dapat mencapai 250 byte jika alamatnya berbeda.  Dan jika kita menganggap bahwa pemrograman MK secara langsung pada register sekarang dianggap sebagai "zashkvar", dan "keren" untuk menggunakan segala macam dadu-kubus, maka penghematannya bisa lebih banyak. <br><br>  Juga, angka 250 byte terdistorsi oleh fakta bahwa perpustakaan tingkat tinggi secara aktif digunakan dalam komunitas, firmware mengembang hingga ukuran tidak senonoh.  Ketika pemrograman pada level rendah, ini setidaknya 2 - 5% dari volume perangkat lunak untuk proyek rata-rata, dengan arsitektur yang kompeten dan optimalisasi O3. <br><br>  <i>Sekali lagi, saya tidak ingin mengatakan bahwa ini adalah semacam alat keren super-duper-mega yang harus digunakan oleh setiap programmer MK yang menghargai diri sendiri.</i>  <i>Tetapi jika saya dapat memotong biaya bahkan dengan sebagian kecil, lalu mengapa tidak?</i> <br><br><h2>  Implementasi </h2><br>  Semua opsi hanya akan diberikan untuk mengkonfigurasi periferal, karena saya tidak menemukan situasi di mana akan diperlukan untuk RAM.  Tegasnya, untuk RAM, rumusnya mirip, cukup ganti alamat dasar untuk perhitungan.  Jadi bagaimana Anda menerapkan ini? <br><br><h4>  Assembler </h4><br>  Mari kita pergi dari bawah, dari Assembler tercinta. <br><br>  Pada proyek assembler, saya biasanya mengalokasikan beberapa 2-byte (sesuai dengan instruksi yang bekerja dengan mereka) RON di bawah # 0 dan # 1 untuk seluruh proyek, dan menggunakannya juga dalam makro, yang mengurangi saya 2 byte lagi secara berkelanjutan.  Catatan, saya tidak menemukan CMSIS di Assembler untuk STM, karena saya langsung memasukkan nomor bit di makro, dan bukan nilai registernya. <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi untuk GNU Assembler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">@  . MOVW R0, 0x0000 MOVW R1, 0x0001 @   .macro PeriphBitSet PerReg, BitNum LDR R3, =(BIT_BAND_ALIAS+(((\PerReg) - BIT_BAND_REGION) * 32) + ((\BitNum) * 4)) STR R1, [R3] .endm @   .macro PeriphBitReset PerReg, BitNum LDR R3, =(BIT_BAND_ALIAS+((\PerReg - BIT_BAND_REGION) * 32) + (\BitNum * 4)) STR R0, [R3] .endm</code> </pre> <br></div></div><br>  Contoh: <br><br><div class="spoiler">  <b class="spoiler_title">Contoh Assembler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">PeriphSet TIM2_CCR2, 0 PeriphBitReset USART1_SR, 5</code> </pre><br></div></div><br>  Keuntungan yang tidak diragukan dari opsi ini adalah bahwa kami memiliki kontrol penuh, yang tidak dapat dikatakan tentang opsi lebih lanjut.  Dan seperti yang akan ditunjukkan bagian terakhir artikel ini, plus yang ini <b>sangat</b> penting. <br><br>  Namun, tidak ada yang membutuhkan proyek untuk MK di Assembler, dari sekitar akhir nol, yang berarti Anda harus beralih ke SI. <br><br><h4>  Biasa c </h4><br>  Jujur, opsi Sishny sederhana ditemukan oleh saya di awal jalan, di suatu tempat di jaringan yang luas.  Pada saat itu, saya sudah menerapkan bit banding di Assembler, dan secara tidak sengaja menemukan file C, itu segera bekerja dan saya memutuskan untuk tidak menciptakan apa pun. <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi untuk C polos</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*!&lt;=================PLAIN C SECTION========================&gt;!*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT31(A) (A==0x80000000)? 31 : 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT30(A) (A==0x40000000)? 30 : MASK_TO_BIT31(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT29(A) (A==0x20000000)? 29 : MASK_TO_BIT30(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT28(A) (A==0x10000000)? 28 : MASK_TO_BIT29(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT27(A) (A==0x08000000)? 27 : MASK_TO_BIT28(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT26(A) (A==0x04000000)? 26 : MASK_TO_BIT27(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT25(A) (A==0x02000000)? 25 : MASK_TO_BIT26(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT24(A) (A==0x01000000)? 24 : MASK_TO_BIT25(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT23(A) (A==0x00800000)? 23 : MASK_TO_BIT24(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT22(A) (A==0x00400000)? 22 : MASK_TO_BIT23(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT21(A) (A==0x00200000)? 21 : MASK_TO_BIT22(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT20(A) (A==0x00100000)? 20 : MASK_TO_BIT21(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT19(A) (A==0x00080000)? 19 : MASK_TO_BIT20(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT18(A) (A==0x00040000)? 18 : MASK_TO_BIT19(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT17(A) (A==0x00020000)? 17 : MASK_TO_BIT18(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT16(A) (A==0x00010000)? 16 : MASK_TO_BIT17(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT15(A) (A==0x00008000)? 15 : MASK_TO_BIT16(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT14(A) (A==0x00004000)? 14 : MASK_TO_BIT15(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT13(A) (A==0x00002000)? 13 : MASK_TO_BIT14(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT12(A) (A==0x00001000)? 12 : MASK_TO_BIT13(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT11(A) (A==0x00000800)? 11 : MASK_TO_BIT12(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT10(A) (A==0x00000400)? 10 : MASK_TO_BIT11(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT09(A) (A==0x00000200)? 9 : MASK_TO_BIT10(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT08(A) (A==0x00000100)? 8 : MASK_TO_BIT09(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT07(A) (A==0x00000080)? 7 : MASK_TO_BIT08(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT06(A) (A==0x00000040)? 6 : MASK_TO_BIT07(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT05(A) (A==0x00000020)? 5 : MASK_TO_BIT06(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT04(A) (A==0x00000010)? 4 : MASK_TO_BIT05(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT03(A) (A==0x00000008)? 3 : MASK_TO_BIT04(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT02(A) (A==0x00000004)? 2 : MASK_TO_BIT03(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT01(A) (A==0x00000002)? 1 : MASK_TO_BIT02(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT(A) (A==0x00000001)? 0 : MASK_TO_BIT01(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) (*(volatile uint32_t*)(PERIPH_BB_BASE+32*((uint32_t)(&amp;(reg))-PERIPH_BASE)+4*((uint32_t)(MASK_TO_BIT(reg_val)))))</span></span></code> </pre><br></div></div><br>  Seperti yang Anda lihat, sepotong kode yang sangat sederhana dan langsung ditulis dalam bahasa prosesor.  Pekerjaan utama di sini adalah terjemahan nilai-nilai CMSIS ke dalam bit number, yang tidak ada sebagai kebutuhan untuk versi assembler. <br><br>  Oh ya, gunakan opsi ini seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">Contoh untuk plain C</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = 1; // (!0)</span></span></code> </pre><br></div></div><br>  Namun, tren modern (secara besar-besaran, menurut pengamatan saya, sekitar tahun 2015) lebih suka mengganti C dengan C ++ bahkan untuk MK.  Dan makro bukan alat yang paling dapat diandalkan, jadi versi berikutnya ditakdirkan untuk dilahirkan. <br><br><h4>  Cpp03 </h4><br>  Di sini, yang sangat menarik dan didiskusikan, tetapi sedikit digunakan mengingat kompleksitasnya, dengan satu contoh basi dari faktorial muncul, alat ini metaprogramming. <br><br>  Lagi pula, tugas menerjemahkan nilai variabel ke dalam bit number ideal (sudah ada nilai dalam CMSIS), dan dalam hal ini praktis untuk waktu kompilasi. <br><br>  Saya menerapkan ini sebagai berikut menggunakan template: <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi untuk C ++ 03</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> val, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> comp_val, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cur_bit_num&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bit_num_from_value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { bit_num = (val == comp_val) ? cur_bit_num : bit_num_from_value&lt;val, <span class="hljs-number"><span class="hljs-number">2</span></span> * comp_val, cur_bit_num + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::bit_num }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> val&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bit_num_from_value</span></span></span><span class="hljs-class">&lt;val, static_cast&lt;uint32_t&gt;(0x80000000), static_cast&lt;uint32_t&gt;(31)&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { bit_num = <span class="hljs-number"><span class="hljs-number">31</span></span> }; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) *(reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value&lt;static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)&gt;::bit_num)))</span></span></span></span></code> </pre><br></div></div><br>  Anda dapat menggunakannya dengan cara yang sama: <br><br><div class="spoiler">  <b class="spoiler_title">Contoh untuk C ++ 03</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = true; //</span></span></code> </pre><br></div></div><br>  Dan mengapa makro kiri?  Faktanya adalah bahwa saya tidak tahu cara lain untuk memasukkan operasi ini dengan aman tanpa membuka bagian lain dari kode program.  Saya akan sangat senang jika mereka meminta komentar saya.  Baik templat maupun fungsi inline tidak memberikan jaminan seperti itu.  Ya, dan makro di sini mengatasi tugasnya dengan sangat baik, tidak ada gunanya mengubahnya hanya karena seseorang yang <s>konformis</s> menganggap ini “tidak aman”. <br><br>  Anehnya, waktu masih tidak berhenti, kompiler semakin mendukung C ++ 14 / C ++ 17, mengapa tidak mengambil keuntungan dari inovasi, membuat kode lebih mudah dimengerti. <br><br><h4>  Cpp14 / cpp17 </h4><br><div class="spoiler">  <b class="spoiler_title">Implementasi untuk C ++ 14</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bit_num_from_value_cpp14</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comp_val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bit_num = (val == comp_val) ? bit_num : bit_num_from_value_cpp14(val, <span class="hljs-number"><span class="hljs-number">2</span></span> * comp_val, bit_num + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) *(reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value_cpp14(static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)))))</span></span></span></span></code> </pre><br></div></div><br>  Seperti yang Anda lihat, saya baru saja mengganti template dengan fungsi constexpr rekursif, yang, menurut pendapat saya, lebih jelas bagi mata manusia. <br><br>  Gunakan cara yang sama.  Omong-omong, dalam C ++ 17, pada prinsipnya, Anda dapat menggunakan fungsi constexpr lambda rekursif, tapi saya tidak yakin bahwa ini akan mengarah pada setidaknya beberapa penyederhanaan, dan juga tidak akan menyulitkan urutan assembler. <br><br>  <b>Singkatnya, ketiga implementasi C / Cpp memberikan seperangkat instruksi yang sama benarnya, menurut bagian Teori.</b>  <b>Saya telah bekerja dengan semua implementasi pada IAR ARM 8.30 dan gcc 7.2.0 untuk waktu yang lama.</b> <br><br><h2>  Latihan itu menyebalkan </h2><br>  Sepertinya itu saja yang terjadi.  Penghematan memori dihitung, implementasi dipilih, siap untuk meningkatkan kinerja.  Tidak di sini, itu hanya kasus perbedaan teori dan praktik.  Dan kapan itu berbeda? <br><br>  Saya tidak akan pernah menerbitkannya jika saya belum mengujinya, tetapi seberapa realistis volume yang diduduki berkurang pada proyek.  Saya secara khusus pada beberapa proyek lama menggantikan makro ini dengan implementasi reguler tanpa topeng, dan melihat perbedaannya.  Hasilnya mengejutkan dengan tidak menyenangkan. <br><br>  Ternyata, volumenya tetap tidak berubah.  Saya secara khusus memilih proyek di mana tepatnya 40-50 instruksi tersebut digunakan.  Menurut teori, saya harus menyimpan dengan baik setidaknya 100 byte, dan paling banyak 200 byte. Dalam praktiknya, perbedaannya menjadi 24 - 32 byte.  Tapi mengapa? <br><br>  Biasanya, ketika Anda mengatur periferal, Anda mengatur 5-10 register hampir berturut-turut.  Dan pada tingkat optimasi yang tinggi, kompiler tidak mengatur instruksi persis dalam urutan register, tetapi mengatur instruksi yang tampaknya benar, kadang-kadang mengganggu mereka di tempat-tempat yang tampaknya tidak dapat dipisahkan. <br><br>  Saya melihat dua opsi (berikut adalah spekulasi saya): <br><br><ol><li>  Atau kompilernya sangat pintar sehingga Anda tahu bagaimana cara mengoptimalkan set instruksi </li><li>  Atau kompiler masih tidak lebih pintar dari seseorang, dan membingungkan dirinya sendiri ketika dia menemukan konstruksi seperti itu </li></ol><br>  Yaitu, ternyata metode ini dalam bahasa "tingkat tinggi" pada tingkat optimasi yang tinggi hanya berfungsi dengan benar jika tidak ada operasi serupa yang berdekatan dengan satu operasi tersebut. <br><br>  Kebetulan, pada level O0, teori dan praktik bertemu dalam kasus apa pun, tetapi saya tidak tertarik pada tingkat optimasi ini. <br><br><h2>  Saya meringkas </h2><br>  Hasil negatif juga merupakan hasil.  Saya pikir semua orang akan menarik kesimpulan untuk dirinya sendiri.  Secara pribadi, saya akan terus menggunakan teknik ini, itu pasti tidak akan lebih buruk dari itu. <br><br>  Saya harap itu menarik dan saya ingin menyampaikan rasa hormat yang besar kepada mereka yang telah membaca sampai akhir. <br><br><h2>  Daftar literatur </h2><br><ol><li>  "Manual Referensi Teknis Cortex-M3", Bagian 4.2, ARM 2005. </li><li>  Panduan definitif untuk ARM Cortex-M3, Joseph Yiu. </li></ol><br>  PS saya miliki di tas saya sedikit cakupan topik yang terkait dengan pengembangan elektronik tertanam.  Biarkan saya tahu, jika tertarik, saya perlahan akan mendapatkannya. <br><br>  PPS Entah bagaimana ternyata bengkok untuk menyisipkan bagian dari kode, tolong katakan padaku bagaimana meningkatkan, jika memungkinkan.  Secara umum, Anda dapat menyalin sepotong kode yang menarik ke notepad dan menghindari emosi yang tidak menyenangkan dalam analisis. <br><br><h2>  UPD: </h2>  Atas permintaan pembaca, saya menunjukkan bahwa operasi bit banding itu sendiri adalah atom, yang memberi kita keamanan ketika bekerja dengan register.  Ini adalah salah satu fitur terpenting dari metode ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454408/">https://habr.com/ru/post/id454408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454398/index.html">Dari kritik hingga algoritma: bagaimana demokrasi dan teknokrasi datang ke industri musik</a></li>
<li><a href="../id454400/index.html">Laporan Harian Status Mesin Virtual dengan R dan PowerShell</a></li>
<li><a href="../id454402/index.html">Arsitektur Mesin Unity State untuk Mengatur Perilaku Unit</a></li>
<li><a href="../id454404/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 6. Isi bagian yang kosong (DHCP, TCP, "jabat tangan", nomor port umum)</a></li>
<li><a href="../id454406/index.html">Akihabara: situs bersarang otaku</a></li>
<li><a href="../id454410/index.html">Baru di PHP 7.4</a></li>
<li><a href="../id454414/index.html">Pelajaran SDL 2: Pelajaran 2 - Main Non-Karet</a></li>
<li><a href="../id454416/index.html">Impor Distribusi Distribusi Hadoop</a></li>
<li><a href="../id454418/index.html">Tiga contoh tidak jelas menggunakan mesin template di backend</a></li>
<li><a href="../id454420/index.html">Cadangan, Bagian 3: Gambaran Umum dan Pengujian duplikasi, dupati</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>