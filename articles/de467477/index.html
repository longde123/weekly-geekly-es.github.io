<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🚀 🦂 👈🏻 Kubernetes 1.16: Highlights Übersicht 🧘🏿 📚 🌄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute, am Mittwoch, findet die nächste Veröffentlichung von Kubernetes statt - 1.16. Nach der Tradition, die sich für unseren Blog zum zehnten Jahrest...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.16: Highlights Übersicht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/467477/"><img src="https://habrastorage.org/webt/6b/oi/xq/6boixq7wqypazw43aysbw8y9xty.png"><br><br>  Heute, am Mittwoch, findet die nächste Veröffentlichung von Kubernetes <a href="">statt</a> - 1.16.  Nach der Tradition, die sich für unseren Blog zum zehnten Jahrestag entwickelt hat, sprechen wir über die wichtigsten Änderungen in der neuen Version. <br><br>  Die zur Vorbereitung dieses Materials verwendeten Informationen stammen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Kubernetes-Erweiterungsverfolgungstabelle</a> , <a href="">CHANGELOG-1.16</a> und verwandten Problemen, Pull-Anforderungen sowie Kubernetes-Verbesserungsvorschlägen (KEP).  Also lass uns gehen! .. <a name="habracut"></a><br><br><h2>  Knoten </h2><br>  Eine wirklich große Anzahl bemerkenswerter Innovationen (im Alpha-Versionsstatus) wird auf der Seite der Knoten von K8s-Clustern (Kubelet) präsentiert. <br><br>  Zunächst werden die sogenannten <b>" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ephemeral Container</a> " <i>(Ephemeral Containers)</i></b> vorgestellt <b>, die den Debugging-Prozess in Pods vereinfachen sollen</b> .  Mit dem neuen Mechanismus können Sie spezielle Container ausführen, die im Namespace vorhandener Pods beginnen und für kurze Zeit leben.  Ihr Zweck ist die Interaktion mit anderen Pods und Containern, um Probleme und Fehlerbehebungen zu lösen.  Für diese Funktion wird ein neuer <code>kubectl debug</code> Befehl <code>kubectl debug</code> , der im Wesentlichen <code>kubectl exec</code> : Nur anstatt den Prozess im Container zu <code>kubectl exec</code> (wie im Fall von <code>exec</code> ), wird der Container im Pod <code>kubectl exec</code> .  Ein solcher Befehl verbindet beispielsweise einen neuen Container mit dem Pod: <br><br><pre> <code class="bash hljs">kubectl debug -c debug-shell --image=debian target-pod -- bash</code> </pre> <br>  Details zu kurzlebigen Behältern (und Beispiele für deren Verwendung) finden Sie im <a href="">entsprechenden KEP</a> .  Die aktuelle Implementierung (in K8s 1.16) ist die Alpha-Version. Zu den Kriterien für die Übertragung auf die Beta-Version gehört das Testen der Ephemeral Containers-API auf mindestens zwei Releases [Kubernetes]. <br><br>  <i><b>NB</b> : Im Wesentlichen ähnelt sogar der Name des Features dem bereits vorhandenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubectl-debug-</a> Plugin, über das wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits geschrieben haben</a> .</i>  <i>Es wird davon ausgegangen, dass mit dem Aufkommen kurzlebiger Container die Entwicklung eines separaten externen Plug-Ins aufhören wird.</i> <br><br>  Eine weitere Innovation, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PodOverhead</code></a> bietet einen <b>Mechanismus zur Berechnung der Gemeinkosten für Pods</b> , die je nach verwendeter Laufzeit stark variieren können.  Als Beispiel zitieren die Autoren <a href="">dieses KEP</a> Kata-Container, für die der Gastkernel, der Kata-Agent, das Init-System usw. gestartet werden müssen.  Wenn der Overhead so groß wird, kann er nicht ignoriert werden. Dies bedeutet, dass ein Weg erforderlich ist, um ihn für weitere Quoten, Planungen usw. zu berücksichtigen.  Um dies zu implementieren, wurde <code>PodSpec</code> Feld <code>Overhead *ResourceList</code> hinzugefügt (verglichen mit Daten in der <code>RuntimeClass</code> , falls eine verwendet wird). <br><br>  Eine weitere bemerkenswerte Neuerung ist der <i>Node Topology Manager</i> , mit dem der Ansatz zur Feinabstimmung der Zuweisung von Hardwareressourcen für verschiedene Komponenten in Kubernetes vereinheitlicht werden soll.  Diese Initiative wird durch die wachsende Nachfrage verschiedener moderner Systeme (aus den Bereichen Telekommunikation, maschinelles Lernen, Finanzdienstleistungen usw.) nach Hochleistungs-Parallelcomputern und zur Minimierung von Verzögerungen bei der Ausführung von Vorgängen verursacht, für die sie die erweiterten Funktionen der CPU- und Hardwarebeschleunigung nutzen.  Solche Optimierungen in Kubernetes wurden bisher dank unterschiedlicher Komponenten (CPU-Manager, Geräte-Manager, CNI) erzielt. Jetzt werden sie eine einzige interne Schnittstelle hinzufügen, die den Ansatz vereinheitlicht und die Verbindung neuer ähnlicher - der sogenannten topologiebewussten - Komponenten auf der Kubelet-Seite vereinfacht.  Details finden Sie im <a href="">entsprechenden KEP</a> . <br><br><img src="https://habrastorage.org/webt/tq/bs/vr/tqbsvryzr9tnxv_9uldn-ofx1es.png"><br>  <i>Komponentendiagramm des Topologie-Managers</i> <br><br>  Die nächste Funktion ist das <b>Überprüfen von Containern während des Startvorgangs <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Startsonde</a> )</i></b> .  Wie Sie wissen, ist es für Container, die lange laufen, schwierig, den aktuellen Status zu erhalten: Sie werden entweder vor dem eigentlichen Betriebsstart "getötet" oder sie geraten für lange Zeit in einen Deadlock.  Eine neue Prüfung (aktiviert über das Feature-Gate <code>StartupProbeEnabled</code> ) <code>StartupProbeEnabled</code> die Aktion anderer Prüfungen ab - oder <code>StartupProbeEnabled</code> vielmehr, bis der Start des Pods abgeschlossen ist.  Aus diesem Grund wurde die Funktion ursprünglich als <a href="">Pod-Startup-Liveness-Probe-Holdoff bezeichnet</a> .  Bei Pods, deren Start lange dauert, können Sie den Status in relativ kurzen Zeitintervallen abfragen. <br><br>  Darüber hinaus wird sofort im Beta-Status eine Verbesserung für RuntimeClass hinzugefügt, die Unterstützung für „heterogene Cluster“ hinzufügt.  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RuntimeClass Scheduling muss</a> jetzt nicht mehr jeder Knoten für jede RuntimeClass unterstützt werden: Für Pods können Sie RuntimeClass auswählen, ohne über die Clustertopologie nachzudenken.  Um dies zu erreichen, mussten Pods NodeSelector und Toleranzen entsprechende Regeln zuweisen, damit Pods auf Knoten mit Unterstützung für alles, was sie benötigen, angezeigt werden.  <a href="">KEP</a> spricht über Anwendungsbeispiele und natürlich über Implementierungsdetails. <br><br><h2>  Netzwerk </h2><br>  Zwei wichtige Netzwerkfunktionen, die erstmals (in der Alpha-Version) in Kubernetes 1.16 verfügbar waren, sind: <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für einen</a> dualen Netzwerkstapel - IPv4 / IPv6</b> - und das entsprechende "Verständnis" auf der Ebene von Pods, Knoten und Diensten.  Es umfasst die Interaktion von IPv4-zu-IPv4 und IPv6-zu-IPv6 zwischen Pods, von Pods zu externen Diensten, Referenzimplementierungen (im Rahmen von Bridge CNI-, PTP CNI- und Host-Local IPAM-Plug-Ins) sowie umgekehrt Kompatibel mit Kubernetes-Clustern, die nur über IPv4 oder IPv6 funktionieren.  Implementierungsdetails finden Sie in <a href="">KEP</a> . <br><br>  Ein Beispiel für die Ausgabe von zwei Arten von IP-Adressen (IPv4 und IPv6) in der Liste der Pods: <br><br><pre> <code class="bash hljs">kube-master<span class="hljs-comment"><span class="hljs-comment"># kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE nginx-controller 1/1 Running 0 20m fd00:db8:1::2,192.168.1.3 kube-minion-1 kube-master#</span></span></code> </pre> <br></li><li>  <b>Die neue API für Endpoint</b> ist die <a href="">EndpointSlice-API</a> .  Es löst die Probleme der vorhandenen Endpoint-API mit Leistung / Skalierbarkeit, die verschiedene Komponenten in der Steuerebene betreffen (Apiserver usw., Endpoints-Controller, Kube-Proxy).  Die neue API wird der Discovery-API-Gruppe hinzugefügt und kann Zehntausende von Backend-Endpunkten für jeden Dienst in einem Cluster aus tausend Knoten bereitstellen.  Zu diesem Zweck wird jeder Dienst N <code>EndpointSlice</code> Objekten zugeordnet, von denen jedes standardmäßig nicht mehr als 100 Endpunkte hat (der Wert ist konfigurierbar).  Die EndpointSlice-API bietet auch Möglichkeiten für ihre zukünftige Entwicklung: Unterstützung für viele IP-Adressen für jeden Pod, neue <code>NotReady</code> für Endpunkte (nicht nur <code>Ready</code> und <code>NotReady</code> ), dynamische Teilmenge für Endpunkte. </li></ul><br>  Der in der letzten Version mit dem Namen <code>service.kubernetes.io/load-balancer-cleanup</code> und an jeden Dienst mit dem Typ <code>LoadBalancer</code> angehängte <code>LoadBalancer</code> auf die Beta-Version erweitert.  Zum Zeitpunkt des Entfernens eines solchen Dienstes wird das tatsächliche Löschen der Ressource verhindert, bis die "Bereinigung" aller entsprechenden Ressourcen des Balancers abgeschlossen ist. <br><br><h2>  API-Maschinen </h2><br>  Der eigentliche "Stabilisierungsmeilenstein" ist im Bereich des Kubernetes-API-Servers und der Interaktion mit diesem festgelegt.  In vielerlei Hinsicht geschah dies aufgrund der <b>Übertragung auf den stabilen Status von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CustomResourceDefinitions</a> (CRD)</b> , für <b>die keine spezielle Präsentation erforderlich war</b> , die seit dem entfernten Kubernetes 1.7 (und dies ist Juni 2017!) Den Beta-Status hatte.  Die gleiche Stabilisierung ergab sich für die damit verbundenen Merkmale: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Subresources"</a> mit <code>/status</code> und <code>/scale</code> für CustomResources; </li><li>  Versionskonvertierung für CRD basierend auf einem externen Webhook; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kürzlich eingeführte</a> (in K8s 1.15) Standardwerte <i>(</i> Standard <i>)</i> und automatisches Löschen von Feldern <i>(</i> Bereinigen <i>)</i> für CustomResources; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Möglichkeit</a> , das OpenAPI v3-Schema zum Erstellen und Veröffentlichen von OpenAPI-Dokumentationen zu verwenden, die zum Überprüfen von CRD-Ressourcen auf der Serverseite verwendet werden. </li></ul><br>  Ein weiterer Mechanismus, der Kubernetes-Administratoren seit langem bekannt ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Admission Webhook</b></a> - befindet sich ebenfalls seit langer Zeit (seit K8s 1.9) im Beta-Status und wurde nun für stabil erklärt. <br><br>  Zwei weitere Funktionen haben die Beta erreicht: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">serverseitiges Anwenden</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überwachen von Lesezeichen</a> . <br><br>  Die einzige wesentliche Neuerung in der Alpha-Version war die <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ablehnung</a> von <code>SelfLink</code></b> - einer speziellen URI, die das angegebene Objekt darstellt und Teil von <code>ObjectMeta</code> und <code>ListMeta</code> (d. H. Teil eines beliebigen Objekts in Kubernetes).  Warum es ablehnen?  Die „einfache“ Motivation <a href="">klingt</a> nach dem Fehlen realer (unüberwindbarer) Gründe für das Fortbestehen dieses Feldes.  Formalere Gründe sind die Optimierung der Leistung (Entfernen eines unnötigen Felds) und die Vereinfachung der Arbeit von generic-apiserver, das gezwungen ist, ein solches Feld auf besondere Weise zu verarbeiten (dies ist das einzige Feld, das unmittelbar vor der Serialisierung des Objekts festgelegt wird).  Die eigentliche "Veralterung" (in der Beta-Version) von <code>SelfLink</code> wird mit Kubernetes Version 1.20 und der letzten Version - 1.21 geschehen. <br><br><h2>  Datenspeicherung </h2><br>  Die Hauptarbeit im Bereich der Speicherung wird wie in früheren Versionen im Bereich der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für CSI beobachtet</a> .  Die wichtigsten Änderungen hier sind: <br><br><ul><li>  Zum ersten Mal (in der Alpha-Version) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurde die</a> <b>Unterstützung für CSI-Plug-Ins für Windows-Arbeitsknoten angezeigt</b> : Die derzeitige Methode zur Arbeit mit Repositorys ersetzt die In-Tree-Plug-Ins im Kubernetes-Kern und die Powershell-basierten FlexVolume-Plug-Ins von Microsoft. <br><br><img src="https://habrastorage.org/webt/4_/6o/h2/4_6oh2zuutje1tcvwqwzhi385m0.png"><br>  <i>Implementierungsschema für das Windows CSI-Plugin von Kubernetes</i> <br></li><li>  Die in K8s 1.12 eingeführte Möglichkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, die Größe von CSI-Volumes zu ändern</a> , ist auf eine Beta-Version angewachsen. </li><li>  Die Möglichkeit, mit CSI lokale kurzlebige Volumes zu erstellen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI Inline Volume Support</a> ), hat einen ähnlichen „Anstieg“ erreicht (von Alpha auf Beta). </li></ul><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktion zum Klonen von Volumes,</a> die in der vorherigen Version von Kubernetes (Verwendung vorhandener PVCs als <code>DataSource</code> zum Erstellen neuer PVCs) angezeigt wurde, hat jetzt auch den Beta-Status erhalten. <br><br><h2>  Planer </h2><br>  Zwei bemerkenswerte Änderungen in der Planung (beide in der Alpha-Version): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>EvenPodsSpreading</code></a> ist die Fähigkeit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>EvenPodsSpreading</code></a> <b>zu verwenden, um Lasten anstelle von logischen Anwendungseinheiten</b> (wie Deployment und ReplicaSet) <b>"fair zu verteilen"</b> und diese Verteilung anzupassen (als strenge Anforderung oder als milde Bedingung, d. H. Priorität).  Die Funktion erweitert die vorhandenen Verteilungsfunktionen geplanter Pods, die jetzt durch die <code>PodAntiAffinity</code> <code>PodAffinity</code> und <code>PodAntiAffinity</code> , und gibt Administratoren mehr Kontrolle über dieses Problem, was eine bessere Zugänglichkeit und einen optimierten Ressourcenverbrauch bedeutet.  Details finden Sie im <a href="">KEP</a> . </li><li>  Verwenden der <i>BestFit-Richtlinie</i> in der <i>Prioritätsfunktion RequestedToCapacityRatio</i> während der Pod-Planung, mit der das Packen von Behältern („Packen in Containern“) sowohl für Kernressourcen (Prozessor, Speicher) als auch für erweiterte Ressourcen (wie GPU) verwendet werden kann.  Weitere Informationen finden Sie unter <a href="">KEP</a> . <br><br><img src="https://habrastorage.org/webt/4z/gx/zm/4zgxzmdtmhyg-mmjnw-cccyw8wq.gif"><br>  <i>Pod-Planung: Bevor Sie die Best-Fit-Richtlinie verwenden (direkt über den Standardplaner) und sie verwenden (über den Scheduler-Extender).</i> </li></ul><br>  Darüber hinaus wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Möglichkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geboten</a> , eigene Plugins für den Scheduler außerhalb des Hauptentwicklungsbaums von Kubernetes (außerhalb des Baums) zu erstellen. <br><br><h2>  Andere Änderungen </h2><br>  Auch in der Version 1.16 von Kubernetes kann eine <b>Initiative erwähnt werden, <a href="">um</a> vorhandene Metriken in voller Reihenfolge</b> oder genauer in Übereinstimmung mit den <a href="">offiziellen</a> Instrumentierungsanforderungen von K8 zu bringen.  Sie stützen sich grundsätzlich auf die einschlägige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus-Dokumentation</a> .  Die Inkonsistenzen wurden aus verschiedenen Gründen gebildet (zum Beispiel wurden einige Metriken einfach erstellt, bevor die aktuellen Anweisungen erschienen), und die Entwickler entschieden, dass es Zeit war, alles auf einen einzigen Standard zu bringen, "im Einklang mit dem Rest des Prometheus-Ökosystems".  Die aktuelle Implementierung dieser Initiative hat den Status der Alpha-Version, die in zukünftigen Versionen von Kubernetes schrittweise auf Beta (1.17) und Stable (1.18) ansteigen wird. <br><br>  Darüber hinaus können folgende Änderungen festgestellt werden: <br><br><ul><li>  <b>Entwicklung der Windows-Unterstützung</b> mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufkommen</a> des Kubeadm-Dienstprogramms für dieses Betriebssystem (Alpha-Version), der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Möglichkeit von</a> <code>RunAsUserName</code> für Windows-Container (Alpha-Version), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbesserung der</a> Unterstützung für Group Managed Service Account (gMSA) auf Beta-Version, Mount / Attach- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung</a> für vSphere-Volumes. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überarbeiteter</a> <b>Datenkomprimierungsmechanismus in API-Antworten</b> .  Zuvor wurde für diese Zwecke ein HTTP-Filter verwendet, der eine Reihe von Einschränkungen auferlegte, die dessen Aufnahme standardmäßig verhinderten.  Jetzt funktioniert die "transparente Komprimierung von Anforderungen": Clients, die <code>Accept-Encoding: gzip</code> im Header senden, erhalten eine komprimierte Antwort in GZIP, wenn ihre Größe 128 KB überschreitet.  Clients on Go unterstützen automatisch die Komprimierung (senden Sie den gewünschten Header), sodass sie sofort einen Rückgang des Datenverkehrs bemerken.  (Für andere Sprachen sind möglicherweise geringfügige Änderungen erforderlich.) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es wurde möglich,</a> <b>HPA basierend auf externen Metriken von / auf Null</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu</a> <b>skalieren</b> .  Wenn die Skalierung auf Objekten / externen Metriken basiert, können Sie bei Leerlauf der Workloads automatisch auf 0 Replikate skalieren, um Ressourcen zu sparen.  Diese Funktion sollte besonders nützlich sein, wenn Mitarbeiter GPU-Ressourcen anfordern und die Anzahl der verschiedenen Arten von nicht aktiven Mitarbeitern die Anzahl der verfügbaren GPUs überschreitet. </li><li>  Ein neuer Client - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>k8s.io/client-go/metadata.Client</code></a> - für den "allgemeinen" Zugriff auf Objekte.  Es wurde entwickelt, um auf einfache Weise Metadaten (d. H. Den <code>metadata</code> Unterabschnitt) aus Clusterressourcen abzurufen und Operationen mit diesen aus der Kategorie der Speicherbereinigung und der Kontingente auszuführen. </li><li>  Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können jetzt</a> ohne veraltete Cloud-Anbieter (Alpha-Version) erstellt werden. </li><li>  Das Dienstprogramm kubeadm wurde <code>join</code> die experimentelle Möglichkeit (Alpha-Version) erweitert, Patches während Init-, Join- und <code>upgrade</code> Vorgängen anzupassen.  Einzelheiten zur Verwendung des <code>--experimental-kustomize</code> finden Sie unter <a href="">KEP</a> . </li><li>  Der neue Endpunkt für Apiserver ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>readyz</code></a> , mit dem Sie Bereitschaftsinformationen exportieren können.  Der API-Server verfügt außerdem über das Flag <code>--maximum-startup-sequence-duration</code> , mit dem Sie die Neustarts anpassen können. </li><li>  Zwei <b>Funktionen für Azure werden</b> als stabil deklariert: Unterstützung für Verfügbarkeitszonen und RG ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cross Resource Group</a> ).  Darüber hinaus hat Azure Folgendes hinzugefügt: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung der</a> AAD- und ADFS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Authentifizierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">annotation</a> <code>service.beta.kubernetes.io/azure-pip-name</code> , um die öffentliche IP des Load Balancers anzugeben; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Möglichkeit zum</a> Konfigurieren von <code>LoadBalancerName</code> und <code>LoadBalancerResourceGroup</code> . </li></ul></li><li>  AWS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterstützt</a> EBS unter Windows und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optimierte</a> EC2-API-Aufrufe von <code>DescribeInstances</code> . </li><li>  Kubeadm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">migriert</a> jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seine</a> CoreDNS-Konfiguration beim Upgrade auf CoreDNS selbstständig. </li><li>  Die Binärdateien <b>usw.</b> im entsprechenden Docker-Image sind weltweit ausführbar, <b>sodass</b> Sie dieses Image ausführen können, ohne Root-Rechte zu benötigen.  Darüber hinaus hat das etcd-Migrationsimage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Unterstützung für die etcd2-Version eingestellt. </li><li>  <a href="">Cluster Autoscaler 1.16.0 hat</a> auf die Verwendung von Distroless als <a href="">Basisimage</a> umgestellt, die Leistung verbessert und neue Cloud-Anbieter (DigitalOcean, Magnum, Packet) hinzugefügt. </li><li>  Aktualisierungen in der verwendeten / abhängigen Software: Go 1.12.9, etcd 3.3.15, CoreDNS 1.6.2. </li></ul><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.15: Ein Überblick über wichtige Innovationen</a> “; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.14: Ein Überblick über wichtige Innovationen</a> “; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.13: Ein Überblick über wichtige Innovationen</a> “; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.12: Ein Überblick über wichtige Innovationen</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467477/">https://habr.com/ru/post/de467477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467463/index.html">Nur Teilung oder wie man eine mathematische Theorie erstellt und 400.000 Dollar damit verdient. Serie Drei, Finale</a></li>
<li><a href="../de467465/index.html">Spart die Cloud Ultra-Budget-Smartphones?</a></li>
<li><a href="../de467471/index.html">Soul Mikrotik gegen seelenloses ILV und den gleichen Anbieter</a></li>
<li><a href="../de467473/index.html">Und mehr über Sorten</a></li>
<li><a href="../de467475/index.html">Geben Sie Thread.Abort () an .NET Core zurück. Anwendungsbereitstellung mit der Version von CoreCLR und CoreFX</a></li>
<li><a href="../de467479/index.html">Kir Shatrov: Shopify hat mit Rails angefangen und hier lieben sie diesen Rahmen aufrichtig.</a></li>
<li><a href="../de467485/index.html">Problemlösung mit pwnable.kr 23 - md5 Rechner. Wir beschäftigen uns mit Stack Canary. C-Bibliotheken in Python verbinden</a></li>
<li><a href="../de467487/index.html">Über die Zukunft von Blockchain- und Kryptowährungszahlungen</a></li>
<li><a href="../de467489/index.html">Sie sind seltsame statische Variablen in PHP</a></li>
<li><a href="../de467493/index.html">So werden Sie für einen potenziellen Angreifer im Internet weniger zugänglich. Persönliche Erfahrungen und Beobachtungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>