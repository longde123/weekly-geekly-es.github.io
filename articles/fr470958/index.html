<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎹 ❕ 🗼 Les sondes de vitalité à Kubernetes peuvent être dangereuses 🤶🏿 ✍🏿 👨‍❤️‍👨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque perev. : Le principal ingénieur de Zalando, Henning Jacobs, a remarqué à plusieurs reprises des problèmes avec les utilisateurs de Kubernetes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les sondes de vitalité à Kubernetes peuvent être dangereuses</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/470958/"> <i><b>Remarque</b></i>  <i><b>perev.</b></i>  <i>: Le principal ingénieur de Zalando, Henning Jacobs, a remarqué à plusieurs reprises des problèmes avec les utilisateurs de Kubernetes pour comprendre le but des sondes de vivacité (et de préparation) et leur application correcte.</i>  <i>Par conséquent, il a rassemblé ses pensées dans cet article volumineux, qui au fil du temps fera partie de la documentation du K8.</i> <br><br><img src="https://habrastorage.org/webt/fi/js/iq/fijsiqs-9gxysn-0-ueyupkidvu.jpeg"><br><br>  Les bilans de santé, connus à Kubernetes sous le <i>nom de sondes de vivacité</i> <i>(c'est-à-dire littéralement «tests de viabilité» - environ. Trad.)</i> , Peuvent être très dangereux.  Je recommande de les éviter autant que possible: les seules exceptions sont les cas où elles sont vraiment nécessaires et que vous êtes pleinement conscient des spécificités et des conséquences de leur utilisation.  Cette publication se concentrera sur les contrôles de vivacité et de préparation, et expliquera également dans quels cas <i>cela vaut la peine</i> et ne vaut pas la peine de les utiliser. <a name="habracut"></a><br><br>  Mon collègue Sandor a récemment partagé sur Twitter les erreurs les plus courantes qu'il rencontre, y compris celles liées à l'utilisation des sondes de préparation / vivacité: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/rr/zn/-q/rrzn-qkpw1s-5-c3g3vfn5tehzy.png"></a> <br><br>  Une <code>livenessProbe</code> mal configurée peut aggraver les situations avec une charge élevée (arrêt d'avalanche + lancement potentiellement long du conteneur / de l'application) et entraîner d'autres conséquences négatives telles qu'une baisse des dépendances <i>(voir également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon récent article</a> sur la limitation du nombre de requêtes dans le bundle K3s + ACME)</i> .  Pire encore, lorsqu'une sonde de vivacité est combinée à un bilan de santé, qui agit comme une base de données externe: la <b>seule défaillance de la base de données redémarrera tous vos conteneurs</b> ! <br><br>  Le message général <i>«N'utilisez pas de sondes de vivacité»</i> dans ce cas aide un peu, par conséquent, nous examinerons à quoi servent les contrôles de préparation et de vivacité. <br><br>  <i>Remarque: La plupart du test ci-dessous a été initialement inclus dans la documentation interne pour les développeurs Zalando.</i> <br><br><h2>  Contrôles de préparation et de vivacité </h2><br>  Kubernetes fournit deux mécanismes importants appelés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sondes de vivacité et sondes de préparation</a> .  Ils effectuent périodiquement certaines actions - par exemple, envoyer une demande HTTP, ouvrir une connexion TCP ou exécuter une commande dans un conteneur - pour confirmer que l'application fonctionne correctement. <br><br>  Kubernetes utilise des <b>sondes de préparation</b> pour comprendre quand un conteneur est prêt à recevoir du trafic.  Un pod est considéré prêt à partir si tous ses conteneurs sont prêts.  Une application de ce mécanisme est de contrôler quels pods sont utilisés comme backends pour les services Kubernetes (et en particulier Ingress). <br><br>  <b>Les sondes de vivacité</b> aident Kubernetes à comprendre quand il est temps de redémarrer le conteneur.  Par exemple, une telle vérification vous permet d'intercepter un blocage lorsque l'application est «bloquée» en un seul endroit.  Le redémarrage du conteneur dans cet état permet de déplacer l'application du sol, malgré les erreurs, mais cela peut également entraîner des échecs en cascade (voir ci-dessous). <br><br>  Si vous essayez de déployer une mise à jour vers une application qui échoue aux vérifications de vivacité / préparation, le déploiement se bloquera car Kubernetes attendra l'état <code>Ready</code> de tous les pods. <br><br><h2>  Exemple </h2><br>  Voici un exemple de sonde de préparation vérifiant le chemin <code>/health</code> via HTTP avec les paramètres par défaut ( <i>intervalle</i> : 10 secondes, <i>délai d'expiration</i> : 1 seconde, <i>seuil de réussite</i> : 1, <i>seuil d'échec</i> : 3): <br><br><pre> <code class="plaintext hljs">#    deployment'/ podTemplate: spec: containers: - name: my-container # ... readinessProbe: httpGet: path: /health port: 8080</code> </pre> <br><h2>  Recommandations </h2><br><ol><li>  Pour les microservices avec un point de terminaison HTTP (REST, etc.), <b>définissez toujours une sonde de disponibilité</b> qui vérifie si l'application (pod) est prête à recevoir du trafic. </li><li>  Assurez-vous que la sonde de disponibilité <b>couvre la disponibilité du port de serveur Web réel</b> : <ul><li>  En utilisant des ports pour les besoins administratifs appelés «admin» ou «gestion» (par exemple, 9090) pour <code>readinessProbe</code> , assurez-vous que le point de terminaison ne retourne OK que si le port HTTP principal (comme 8080) est prêt à accepter le trafic *; <br><br>  <i>* Je connais au moins un cas à Zalando où cela ne s'est pas produit, c'est-à-dire que <code>readinessProbe</code> vérifié le port de «gestion», mais le serveur lui-même n'a pas démarré en raison de problèmes de chargement du cache.</i> </li><li>  suspendre la sonde de préparation sur un port séparé peut entraîner le fait que la congestion sur le port principal ne sera pas reflétée dans le contrôle d'intégrité (c'est-à-dire que le pool de threads sur le serveur est plein, mais le contrôle d'intégrité montre toujours que tout est OK). </li></ul></li><li>  S'assurer que la <b>sonde de préparation permet l'initialisation / migration de la base de données</b> ; <ul><li>  la manière la plus simple d'y parvenir est d'accéder au serveur HTTP uniquement une fois l'initialisation terminée (par exemple, migration de la base de données depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flyway</a> , etc.);  c'est-à-dire qu'au lieu de modifier l'état du contrôle de l'intégrité, ne démarrez simplement pas le serveur Web tant que la migration de la base de données * n'est pas terminée. <br><br>  <i>* Vous pouvez également exécuter des migrations de base de données à partir de conteneurs d'initialisation en dehors du pod.</i>  <i>Je suis toujours un fan des applications autonomes, c'est-à-dire celles dans lesquelles le conteneur d'applications, sans coordination externe, sait comment amener la base de données à l'état souhaité.</i> </li></ul></li><li>  Utilisez <code>httpGet</code> pour les vérifications de préparation via les points de terminaison typiques des vérifications de l'état (par exemple <code>/health</code> ). </li><li>  <code>successThreshold: 1</code> <b>paramètres de</b> <code>successThreshold: 1</code> ( <code>interval: 10s</code> , <code>timeout: 1s</code> , <code>failureThreshold: 3</code> <code>successThreshold: 1</code> , <code>failureThreshold: 3</code> ): <ul><li>  les paramètres par défaut signifient que le pod ne sera <i>pas prêt</i> après environ 30 secondes (3 contrôles de santé ont échoué). </li></ul></li><li>  Utilisez un port distinct pour «admin» ou «gestion» si la pile technologique (par exemple, Java / Spring) permet de séparer la gestion de l'intégrité et des métriques du trafic normal: <ul><li>  mais n'oubliez pas le paragraphe 2. </li></ul></li><li>  Si nécessaire, une sonde de disponibilité peut être utilisée pour réchauffer / charger le cache et renvoyer le code d'état 503 jusqu'à ce que le conteneur soit «réchauffé»: <ul><li>  Je vous recommande également de vous familiariser avec la nouvelle vérification <code>startupProbe</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui est apparue dans la version 1.16</a> <i>(nous avons écrit à ce sujet en russe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> - traduction approximative)</i> . </li></ul></li></ol><br><h2>  Avertissements </h2><br><ol><li>  <b>Ne vous fiez pas à des dépendances externes</b> (telles que des stockages de données) lorsque vous effectuez des tests de préparation / vivacité - cela peut entraîner des échecs en cascade: <ul><li>  à titre d'exemple, prenons un service REST avec état avec 10 pods en fonction d'une base de données Postgres: lorsque la vérification dépend d'une connexion fonctionnelle à la base de données, les 10 pods peuvent tomber en cas de retard dans le réseau / côté base de données - généralement, tout se termine pire qu'il ne pourrait; </li><li>  notez que Spring Data vérifie par défaut la connexion à la base de données *; <br><br>  <i>* Il s'agit du comportement par défaut de Spring Data Redis (du moins c'était comme lorsque j'ai vérifié la dernière fois), ce qui a conduit à un échec «catastrophique»: lorsque Redis était indisponible pendant une courte période, tous les pods «sont tombés».</i> </li><li>  «Externe» dans ce sens peut également signifier d'autres pods de la même application, c'est-à-dire, idéalement, la vérification ne devrait pas dépendre de l'état des autres pods du même cluster pour éviter les plantages en cascade: <ul><li>  les résultats peuvent varier pour les applications à état distribué (par exemple, la mise en cache en mémoire dans les pods). </li></ul></li></ul></li><li>  <b>N'utilisez pas de sonde de vivacité</b> pour les pods (les exceptions sont des cas où elles sont vraiment nécessaires et que vous êtes pleinement conscient des spécificités et des conséquences de leur utilisation): <ul><li>  La sonde de vivacité peut aider à récupérer les conteneurs «bloqués», mais comme vous avez le contrôle total de votre application, des choses comme les processus et les blocages «bloqués» ne devraient idéalement pas se produire: la meilleure alternative est de supprimer intentionnellement l'application et de la renvoyer à précédent état d'équilibre; </li><li>  une sonde de vivacité échouée redémarrera le conteneur, ce qui aggravera potentiellement les conséquences des erreurs de chargement: le redémarrage du conteneur entraînera un temps d'arrêt (au moins pour le temps de lancement de l'application, disons pendant plus de 30 secondes), provoquant de nouvelles erreurs, augmentant la charge sur d'autres conteneurs et augmentant la probabilité de leur défaillance, etc.; </li><li>  les contrôles de vivacité combinés à une dépendance externe sont les pires combinaisons possibles, ce qui peut entraîner des échecs en cascade: un léger retard du côté base de données redémarrera tous vos conteneurs! </li></ul></li><li>  Les paramètres des contrôles de vivacité et de préparation <b>doivent être différents</b> : <ul><li>  vous pouvez utiliser une sonde de vivacité avec le même bilan de santé, mais un seuil plus élevé ( <code>failureThreshold</code> ), par exemple, attribuer le statut <i>non prêt</i> après 3 tentatives et supposer que la sonde de vivacité a échoué après 10 tentatives; </li></ul></li><li>  <b>N'utilisez pas de vérifications exécutées</b> , car elles sont associées à des problèmes connus qui conduisent à l'apparition de processus zombies: <ul><li>  Détails: Voir une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">présentation de Datadog</a> . </li></ul></li></ol><br><h2>  Résumé </h2><br><ul><li>  Utilisez des sondes de préparation pour déterminer quand un pod est prêt à recevoir du trafic. </li><li>  N'utilisez les sondes de vivacité que lorsqu'elles sont vraiment nécessaires. </li><li>  Une utilisation incorrecte des sondes de disponibilité / vivacité peut entraîner une disponibilité réduite et des échecs en cascade. </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/u5/pf/dc/u5pfdcgajwkicj1fuluthhxm68y.png"></a> <br><br><h2>  Documents supplémentaires sur le sujet </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documents Kubernetes: Configurer les sondes de vivacité et de préparation</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les sondes de vivacité et de préparation de Kubernetes revisitées: comment éviter de se tirer une balle dans l'autre pied</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NRE Labs Outage Post-Mortem</a> (parle de livenessProbe). </li></ul><br><h2>  Mise à jour No1 du 2019-09-29 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À propos des conteneurs d'initialisation pour la migration de la base de données</a> : note de bas de page ajoutée. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EJ m'a rappelé la</a> PDB: l'un des problèmes des contrôles de vivacité est le manque de coordination entre les pods.  Kubernetes dispose de PDP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pod Disruption Budgets)</a> pour limiter le nombre d'échecs simultanés qu'une application peut rencontrer, mais les vérifications ne prennent pas en compte les PDB.  Idéalement, nous pouvons commander des K8: "Redémarrez un pod si sa vérification échoue, mais ne les redémarrez pas tous pour ne pas les aggraver." <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bryan a parfaitement formulé</a> : «Utilisez un son vivant lorsque vous savez avec certitude que la <b>meilleure chose que vous pouvez faire est de« tuer »l'application</b> » (encore une fois, ne <b>vous laissez</b> pas emporter). <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/gn/0r/lx/gn0rlxxmjqqpm86kdv_fyteifza.png"></a> <br><br><h2>  Mise à jour n ° 2 du 2019-09-29 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Concernant la lecture de la documentation avant utilisation</a> : j'ai créé une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">demande de fonctionnalité</a> pour compléter la documentation sur les sondes de vivacité. <br><br><h2>  PS du traducteur </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes: la vie du foyer</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7 bonnes pratiques pour le fonctionnement des conteneurs selon Google</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7 principes pour concevoir des applications basées sur des conteneurs</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470958/">https://habr.com/ru/post/fr470958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470940/index.html">Meetup MSK VUE.JS # 3 au groupe Mail.ru: matériaux de mitap</a></li>
<li><a href="../fr470942/index.html">Du débutant aux icônes de style: comment nous avons remporté des prix dans 2GIS</a></li>
<li><a href="../fr470950/index.html">bear_hug: jeux en art ASCII en Python3.6 +</a></li>
<li><a href="../fr470952/index.html">Trucs et astuces de Digital Forensics: Forensics de l'application «Votre téléphone»</a></li>
<li><a href="../fr470954/index.html">Installez Zimbra OSE 8.8.15 et Zextras Suite Pro sur Ubuntu 18.04 LTS</a></li>
<li><a href="../fr470962/index.html">JSConf Budapest 2019</a></li>
<li><a href="../fr470964/index.html">Jouets en bois - inscriptions</a></li>
<li><a href="../fr470966/index.html">Mot de passe Unix de Ken Thompson</a></li>
<li><a href="../fr470974/index.html">DNS passif entre les mains de l'analyste</a></li>
<li><a href="../fr470976/index.html">Song of Ice (Bloody Enterprise) et Flames (DevOps et IaC)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>