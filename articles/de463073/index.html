<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 👨🏾‍🎓 🧗🏻 QUIC in Aktion: Wie Uber es implementiert hat, um die Leistung zu optimieren 👢 👩🏻‍🏭 🐟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das QUIC-Protokoll ist äußerst interessant anzusehen, daher schreiben wir gerne darüber. Wenn die vorherigen Veröffentlichungen zu QUIC jedoch eher hi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>QUIC in Aktion: Wie Uber es implementiert hat, um die Leistung zu optimieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/463073/">  Das QUIC-Protokoll ist äußerst interessant anzusehen, daher schreiben wir gerne darüber.  Wenn die vorherigen Veröffentlichungen zu QUIC jedoch eher historischer Natur (Material, wenn Sie möchten) und Material waren, freuen wir uns, heute eine andere Interpretation zu veröffentlichen - wir werden über die tatsächliche Anwendung des Protokolls im Jahr 2019 sprechen.  Und es geht nicht um eine kleine Infrastruktur in einer bedingten Garage, sondern um Uber, das fast auf der ganzen Welt funktioniert.  Wie kamen die Ingenieure des Unternehmens zu der Entscheidung, QUIC in der Produktion einzusetzen, wie testeten sie und was sahen sie nach dem Start in die Produktion - unter dem Schnitt. <br><blockquote>  Bilder sind anklickbar.  Viel Spaß beim Lesen! </blockquote><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/t-/vf/ou/t-vfouxapcoi45iq_uugxs3-4lo.png"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <a name="habracut"></a><br>  Uber ist ein globaler Maßstab, nämlich 600 Präsenzstädte, in denen die Anwendung vollständig auf dem drahtlosen Internet von mehr als 4.500 Mobilfunkbetreibern basiert.  Benutzer erwarten, dass die Anwendung nicht nur schnell, sondern auch in Echtzeit funktioniert. Um dies sicherzustellen, benötigt die Uber-Anwendung eine geringe Latenz und eine sehr zuverlässige Verbindung.  Leider fühlt sich der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP / 2-</a> Stack in dynamischen und verlustanfälligen drahtlosen Netzwerken nicht gut an.  Wir haben festgestellt, dass in diesem Fall eine geringe Leistung in direktem Zusammenhang mit TCP-Implementierungen in den Kerneln von Betriebssystemen steht. <br><br>  Um das Problem zu lösen, haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QUIC</a> angewendet, ein modernes Protokoll mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kanalmultiplex</a> , mit dem wir die Leistung des Transportprotokolls besser kontrollieren können.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IETF-</a> Arbeitsgruppe standardisiert derzeit QUIC als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP / 3</a> . <br><br>  Nach detaillierten Tests kamen wir zu dem Schluss, dass die Implementierung von QUIC in unserer Anwendung die Verzögerungen im Vergleich zu TCP verringert.  Am Beispiel von Fahrer- und Beifahreranwendungen beobachteten wir einen Rückgang des Bereichs von 10 bis 30% für den HTTPS-Verkehr.  QUIC gab uns auch die End-to-End-Kontrolle über benutzerdefinierte Pakete. <br><br>  In diesem Artikel teilen wir unsere Erfahrungen mit der Optimierung von TCP für Uber-Anwendungen mithilfe eines Stacks, der QUIC unterstützt. <br><br><h2>  Letztes Wort der Technologie: TCP </h2><br>  Heute ist TCP das am häufigsten verwendete Transportprotokoll für die Bereitstellung von HTTPS-Verkehr im Internet.  TCP stellt einen zuverlässigen Bytestrom bereit und bewältigt so die Überlastung des Netzwerks und den Verlust der Verbindungsschicht.  Die weit verbreitete Verwendung von TCP für den HTTPS-Verkehr erklärt sich aus der Allgegenwart des ersteren (fast jedes Betriebssystem enthält TCP), der Verfügbarkeit auf dem größten Teil der Infrastruktur (z. B. auf Load Balancern, HTTPS-Proxys und CDNs) und der sofort einsatzbereiten Funktionalität, die auf den meisten Plattformen und Plattformen verfügbar ist Netzwerke. <br><br>  Die meisten Benutzer verwenden unsere Anwendung unterwegs, und TCP-Verzögerungen sind weit entfernt von den Echtzeitanforderungen unseres HTTPS-Verkehrs.  Einfach ausgedrückt, Benutzer auf der ganzen Welt sind damit konfrontiert - Abbildung 1 zeigt Verzögerungen in Großstädten: <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/z1/4r/dr/z14rdrs2ba8rzmrb8akbtadvqxy.png"></a> </div><br>  <font color="grey">Abbildung 1. Das Ausmaß der Verzögerungen variiert in den Hauptstädten, in denen Uber tätig ist.</font> <br><br>  Trotz der Tatsache, dass es in indischen und brasilianischen Netzen mehr Verzögerungen gab als in den USA und Großbritannien, sind die Verzögerungen im Heck viel größer als die durchschnittlichen Verzögerungen.  Dies gilt auch für die USA und Großbritannien. <br><br><h2>  TCP-Leistung über Funk </h2><br>  TCP wurde für <b>kabelgebundene</b> Netzwerke entwickelt, <b>dh</b> mit Schwerpunkt auf gut vorhersehbaren Verbindungen.  <b>Drahtlose</b> Netzwerke haben jedoch ihre eigenen Eigenschaften und Schwierigkeiten.  Erstens sind drahtlose Netzwerke aufgrund von Interferenzen und Signaldämpfung verlustanfällig.  Beispielsweise reagieren Wi-Fi-Netzwerke empfindlich auf Mikrowellen, Bluetooth und andere Funkwellen.  Mobilfunknetze leiden unter Signalverlust ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pfadverlust</a> ) aufgrund von Reflexion / Absorption des Signals durch Objekte und Gebäude sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Störungen</a> durch benachbarte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zelltürme</a> .  Dies führt zu signifikanteren (4-10-fachen) und einer Vielzahl von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Round-Trip-Verzögerungen (RTT)</a> und Paketverlusten im Vergleich zu einer Kabelverbindung. <br><br>  Um Bandbreitenschwankungen und -verlusten entgegenzuwirken, verwenden Mobilfunknetze normalerweise große Puffer für Verkehrsstöße.  Dies kann zu einer übermäßigen Priorität führen, was längere Verzögerungen bedeutet.  Sehr oft behandelt TCP eine solche Sequenz als Verlust aufgrund eines erhöhten Zeitlimits, so dass TCP dazu neigt, ein Relais durchzuführen und dadurch den Puffer zu füllen.  Dieses Problem ist als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bufferbloat</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">übermäßige Netzwerkpufferung, Pufferschwellung</a> ) bekannt und ein sehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ernstes Problem des</a> modernen Internets. <br><br>  Schließlich variiert die Leistung des Mobilfunknetzes je nach Netzbetreiber, Region und Zeit.  In Abbildung 2 haben wir die mittleren Verzögerungen des HTTPS-Verkehrs über Zellen in einer Reichweite von 2 Kilometern erfasst.  Daten werden für die beiden größten Mobilfunkbetreiber in Delhi, Indien, gesammelt.  Wie Sie sehen können, variiert die Leistung von Zelle zu Zelle.  Außerdem unterscheidet sich die Leistung eines Bedieners von der Leistung des zweiten.  Dies wird durch Faktoren wie Muster des Netzwerkzugriffs unter Berücksichtigung von Zeit und Ort, Benutzermobilität sowie Netzwerkinfrastruktur unter Berücksichtigung der Dichte der Türme und des Verhältnisses der Netzwerktypen (LTE, 3G usw.) beeinflusst. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/ln/vz/ya/lnvzyai54p_xde2mfcr50ddoopa.png"></a> </div><br>  <font color="grey">Abbildung 2. Verzögerungen für ein Beispiel eines Radius von 2 km.</font>  <font color="grey">Delhi, Indien.</font> <br><br>  Auch die Leistung von Mobilfunknetzen variiert im Laufe der Zeit.  Abbildung 3 zeigt die mittlere Verzögerung nach Wochentag.  Wir haben auch einen Unterschied in kleinerem Maßstab beobachtet - innerhalb eines Tages und einer Stunde. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/xu/oo/u_/xuoou_03qrdllnyebxvrpiwa1iy.png"></a> </div><br>  <font color="grey">Abbildung 3. Schwanzverzögerungen können an verschiedenen Tagen erheblich variieren, jedoch mit demselben Bediener.</font> <br><br>  All dies führt dazu, dass die TCP-Leistung in drahtlosen Netzwerken ineffizient ist.  Bevor wir jedoch nach Alternativen zu TCP suchten, wollten wir ein genaues Verständnis der folgenden Punkte entwickeln: <br><ul><li>  Ist TCP der Hauptverursacher von Verzögerungen bei unseren Anwendungen? </li><li>  Haben moderne Netze erhebliche und unterschiedliche Round-Trip-Verzögerungen (RTT)? </li><li>  Welche Auswirkungen hat der Leistungsverlust von RTT und TCP? </li></ul><br><h2>  TCP-Leistungsanalyse </h2><br>  Um zu verstehen, wie wir die TCP-Leistung analysiert haben, erinnern wir uns kurz daran, wie TCP Daten von einem Absender zu einem Empfänger überträgt.  Zunächst stellt der Absender eine TCP-Verbindung her, indem er einen Drei-Wege- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handshake</a> ausführt: Der Absender sendet ein SYN-Paket, wartet auf ein SYN-ACK-Paket vom Empfänger und sendet dann ein ACK-Paket.  Zusätzliche zweite und dritte Durchgänge dienen zum Erstellen einer TCP-Verbindung.  Der Empfänger bestätigt den Empfang jedes Pakets (ACK), um eine zuverlässige Zustellung sicherzustellen. <br><br>  Wenn ein Paket oder eine ACK verloren geht, sendet der Absender nach einer Zeitüberschreitung erneut (RTO, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitüberschreitung bei</a> erneuter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übertragung</a> ).  Die RTO wird dynamisch basierend auf verschiedenen Faktoren berechnet, beispielsweise der erwarteten RTT-Verzögerung zwischen Sender und Empfänger. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/-w/nf/g8/-wnfg8rew9-lbfsaxfw6k9fnnxi.png"></a> </div><br>  <font color="grey">Abbildung 4. Der TCP / TLS-Paketaustausch enthält einen Mechanismus zur erneuten Übertragung.</font> <br><br>  Um festzustellen, wie TCP in unseren Anwendungen funktioniert, haben wir eine Woche lang TCP-Pakete mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tcpdump</a> auf den Kampfverkehr von indischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grenzservern</a> überwacht.  Dann haben wir die TCP-Verbindungen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tcptrace</a> analysiert.  Darüber hinaus haben wir eine Android-Anwendung erstellt, die emulierten Datenverkehr an einen Testserver sendet und den tatsächlichen Datenverkehr so ​​weit wie möglich nachahmt.  Smartphones mit dieser Anwendung wurden an mehrere Mitarbeiter verteilt, die mehrere Tage lang Protokolle sammelten. <br><br>  Die Ergebnisse beider Experimente stimmten überein.  Wir haben hohe RTT-Verzögerungen gesehen;  Schwanzwerte waren fast 6-mal höher als der Medianwert;  arithmetischer Mittelwert der Verzögerungen - mehr als 1 Sekunde.  Viele Verbindungen waren verlustbehaftet, sodass TCP 3,5% aller Pakete erneut übertrug.  In überlasteten Gebieten wie Flughäfen und Bahnhöfen verzeichneten wir einen Verlust von 7%.  Solche Ergebnisse werfen Zweifel an der herkömmlichen Weisheit auf, dass die in Mobilfunknetzen verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fortschrittlichen Neuübertragungsschemata</a> den Transportverlust erheblich reduzieren.  Nachfolgend finden Sie die Testergebnisse der Anwendung „Simulator“: <br><div class="scrollable-table"><table><tbody><tr><th>  Netzwerkmetriken </th><th>  Werte </th></tr><tr><td>  <b>RTT, Millisekunden [50%, 75%, 95%, 99%]</b> </td><td>  [350, 425, 725, 2300] </td></tr><tr><td>  <b>RTT-Diskrepanz, Sekunden</b> </td><td>  ~ 1,2 s Durchschnitt </td></tr><tr><td>  <b>Paketverlust bei instabilen Verbindungen</b> </td><td>  Im Durchschnitt ~ 3,5% (7% in Gebieten mit Überlastung) </td></tr></tbody></table></div><br>  Fast die Hälfte dieser Verbindungen hatte mindestens einen Paketverlust, von denen die meisten SYN- und SYN-ACK-Pakete waren.  Die meisten TCP-Implementierungen verwenden einen RTO-Wert von 1 Sekunde für SYN-Pakete, der für nachfolgende Verluste exponentiell ansteigt.  Die Ladezeit der Anwendung kann sich erhöhen, da TCP mehr Zeit zum Herstellen von Verbindungen benötigt. <br><br>  Im Fall von Datenpaketen reduzieren hohe RTOs die nützliche Netzwerkauslastung bei vorübergehenden Verlusten in drahtlosen Netzwerken erheblich.  Wir haben festgestellt, dass die durchschnittliche Neuübertragungszeit etwa 1 Sekunde mit einer Endverzögerung von fast 30 Sekunden beträgt.  Solche hohen Verzögerungen auf TCP-Ebene verursachten HTTPS-Timeouts und Wiederholungsversuche, was die Latenz und die Ineffizienz des Netzwerks weiter erhöhte. <br><br>  Während das 75. Perzentil der gemessenen RTT etwa 425 ms betrug, betrug das 75. Perzentil für TCP fast 3 Sekunden.  Dies deutet darauf hin, dass der Verlust TCP gezwungen hat, 7 bis 10 Durchgänge durchzuführen, um Daten erfolgreich zu übertragen.  Dies kann auf eine ineffektive RTO-Berechnung, die Unfähigkeit von TCP, schnell auf den Verlust der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Pakete</a> im Fenster zu reagieren, und die Ineffizienz des Überlastungssteuerungsalgorithmus zurückzuführen sein, der nicht zwischen drahtlosen Verlusten und Verlusten aufgrund von Netzwerküberlastung unterscheidet.  Nachfolgend sind die Ergebnisse des TCP-Verlusttests aufgeführt: <br><div class="scrollable-table"><table><tbody><tr><th>  TCP-Paketverluststatistik </th><th>  Wert </th></tr><tr><td>  Prozentsatz der Verbindungen mit mindestens 1 Paketverlust </td><td>  45% </td></tr><tr><td>  Der Prozentsatz der Verbindungen mit Verlust während des Verbindungsaufbaus </td><td>  30% </td></tr><tr><td>  Der Prozentsatz der Verbindungen mit Verlust während des Datenaustauschs </td><td>  76% </td></tr><tr><td>  Verteilung der Verzögerungen bei erneuter Übertragung, Sekunden [50%, 75%, 95%, 99%] </td><td>  [1, 2,8, 15, 28] </td></tr><tr><td>  Verteilung von Neuübertragungen für ein einzelnes Paket oder TCP-Segment </td><td>  [1,3,6,7] </td></tr></tbody></table></div><br><h2>  QUIC-Anwendung </h2><br>  QUIC wurde ursprünglich von Google entwickelt und ist ein modernes Multithread-Transportprotokoll, das auf UDP ausgeführt wird.  Im Moment befindet sich QUIC im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardisierungsprozess</a> (wir haben bereits geschrieben, dass es sozusagen zwei Versionen von QUIC gibt, die Neugierigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können dem Link folgen</a> - ca. Übersetzer).  Wie in Abbildung 5 gezeigt, wird QUIC unter HTTP / 3 gehostet (tatsächlich HTTP / 2 über QUIC - dies ist HTTP / 3, das jetzt stark standardisiert ist).  Es ersetzt teilweise die HTTPS- und TCP-Schichten und verwendet UDP, um Pakete zu bilden.  QUIC unterstützt nur die sichere Datenübertragung, da TLS vollständig in QUIC integriert ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y4/an/qg/y4anqgxplkww-bc3thmjykbdg2i.png"></div><br>  <font color="grey">Abbildung 5: QUIC funktioniert unter HTTP / 3 und ersetzt TLS, das früher unter HTTP / 2 funktioniert hat.</font> <br><br>  Nachfolgend sind die Gründe aufgeführt, die uns überzeugt haben, QUIC zur Stärkung von TCP zu verwenden: <br><ul><li>  <b>0-RTT-Verbindungsaufbau.</b>  QUIC ermöglicht die Wiederverwendung von Berechtigungen aus früheren Verbindungen, wodurch die Anzahl der Sicherheitshandshakes verringert wird.  In Zukunft wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLS1.3</a> 0-RTT unterstützen, es ist jedoch weiterhin ein Drei-Wege-TCP-Handshake erforderlich. </li><li>  <b>Überwindung der HoL-Blockierung.</b>  HTTP / 2 verwendet eine TCP-Verbindung für jeden Client, um die Leistung zu verbessern. Dies kann jedoch zu einem HoL-Block (Head-of-Line) führen.  QUIC vereinfacht das Multiplexen und liefert Anforderungen unabhängig voneinander an die Anwendung. </li><li>  <b>Überlastungsmanagement.</b>  QUIC befindet sich auf Anwendungsebene, wodurch es einfacher wird, den Haupttransportalgorithmus zu aktualisieren, der das Senden basierend auf Netzwerkparametern (Verlustbetrag oder RTT) steuert.  Die meisten TCP-Implementierungen verwenden den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBIC-</a> Algorithmus, der für verzögerungsempfindlichen Datenverkehr nicht optimal ist.  Neu entwickelte Algorithmen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BBR</a> modellieren das Netzwerk genauer und optimieren die Latenz.  Mit QUIC können Sie BBR verwenden und diesen Algorithmus aktualisieren, wenn er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verbessert wird</a> . </li><li>  <b>Verluste ausgleichen.</b>  QUIC ruft zwei TLPs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tail Loss Probe</a> ) auf, bevor die RTO ausgelöst wird - auch wenn die Verluste sehr spürbar sind.  Dies unterscheidet sich von TCP-Implementierungen.  TLP überträgt hauptsächlich das letzte Paket (oder ein neues, falls vorhanden) erneut, um eine schnelle Wiederauffüllung auszulösen.  Die Schwanzverzögerungsverarbeitung ist besonders nützlich für die Arbeitsweise von Uber mit dem Netzwerk, insbesondere für kurze, episodische und verzögerungsempfindliche Datenübertragungen. </li><li>  <b>optimiertes ACK.</b>  Da jedes Paket eine eindeutige Seriennummer hat, besteht kein Problem bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterscheidung zwischen</a> Paketen, wenn diese weitergeleitet werden.  ACK-Pakete enthalten auch Zeit zum Verarbeiten des Pakets und zum Generieren clientseitiger ACKs.  Diese Funktionen stellen sicher, dass QUIC die RTT genauer berechnet.  Das QUIC ACK unterstützt bis zu 256 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NACK-</a> Bereiche, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wodurch</a> der Absender widerstandsfähiger gegen Paketaustausch ist und dabei weniger Bytes verwendet.  Selective ACK ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SACK</a> ) in TCP löst dieses Problem nicht in allen Fällen. </li><li>  <b>Verbindungsmigration.</b>  QUIC-Verbindungen werden durch eine 64-Bit-ID identifiziert. Wenn der Client die IP-Adressen ändert, können Sie die ID der alten Verbindung ohne Unterbrechung weiterhin für die neue IP-Adresse verwenden.  Dies ist eine sehr gängige Praxis für mobile Anwendungen, wenn ein Benutzer zwischen Wi-Fi und Mobilfunkverbindungen wechselt. </li></ul><br><h2>  Alternativen zu QUIC </h2><br>  Wir haben uns alternative Lösungsansätze angesehen, bevor wir uns für QUIC entschieden haben. <br><br>  Zunächst haben wir versucht, TPC-PoPs (Points of Presence) bereitzustellen, um TCP-Verbindungen näher an den Benutzern herzustellen.  Im Wesentlichen beenden PoPs die TCP-Verbindung mit dem mobilen Gerät näher am Mobilfunknetz und leiten den Datenverkehr an die ursprüngliche Infrastruktur weiter.  Wenn wir TCP näher schließen, können wir möglicherweise die RTT reduzieren und sicherstellen, dass TCP besser auf dynamische drahtlose Umgebungen reagiert.  Unsere Experimente haben jedoch gezeigt, dass RTT und Verluste größtenteils aus zellularen Netzwerken stammen und die Verwendung von PoPs keine signifikante Leistungsverbesserung bietet. <br><br>  Wir haben uns auch mit der Optimierung der TCP-Parameter befasst.  Die Konfiguration des TCP-Stacks auf unseren heterogenen Edgeservern war schwierig, da TCP in verschiedenen Betriebssystemversionen unterschiedliche Implementierungen aufweist.  Es war schwierig, dies zu implementieren und verschiedene Netzwerkkonfigurationen zu testen.  Die Konfiguration von TCP direkt auf Mobilgeräten war aufgrund mangelnder Berechtigung nicht möglich.  Noch wichtiger ist, dass Chips wie Verbindungen mit 0-RTT und eine verbesserte RTT-Vorhersage für die Protokollarchitektur von entscheidender Bedeutung sind. Daher ist es nicht möglich, allein durch die Konfiguration von TCP signifikante Vorteile zu erzielen. <br><br>  Schließlich haben wir mehrere UDP-basierte Protokolle evaluiert, mit denen das Video-Streaming behoben werden kann. Wir wollten wissen, ob diese Protokolle in unserem Fall hilfreich sind.  Leider fehlten ihnen viele Sicherheitseinstellungen und sie benötigten eine zusätzliche TCP-Verbindung für Metadaten und Steuerinformationen. <br><br>  Unsere Untersuchungen haben gezeigt, dass QUIC fast das einzige Protokoll ist, das bei dem Problem des Internetverkehrs helfen kann, wobei sowohl Sicherheit als auch Leistung berücksichtigt werden. <br><br><h2>  QUIC-Integration in die Plattform </h2><br>  Um QUIC erfolgreich zu integrieren und die Anwendungsleistung unter schlechten Kommunikationsbedingungen zu verbessern, haben wir den alten Stack (HTTP / 2 über TLS / TCP) durch das QUIC-Protokoll ersetzt.  Wir haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cronet-</a> Netzwerkbibliothek von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chromium Projects verwendet</a> , die die ursprüngliche Google-Version des Protokolls - gQUIC - enthält.  Diese Implementierung wird auch ständig verbessert, um der neuesten IETF-Spezifikation zu entsprechen. <br><br>  Zuerst haben wir Cronet in unsere Android-Apps integriert, um QUIC-Unterstützung hinzuzufügen.  Die Integration wurde durchgeführt, um die Migrationskosten zu minimieren.  Anstatt den alten Netzwerkstapel, der die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://square.github.io/ok">OkHttp-</a> Bibliothek verwendete, vollständig zu ersetzen, haben wir Cronet UNTER das OkHttp-API-Framework integriert.  Durch diese Integration haben wir Änderungen in unseren Netzwerkaufrufen (die von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Retrofit</a> verwendet werden) auf API-Ebene vermieden. <br><br>  Ähnlich wie bei Android-Geräten haben wir Cronet in Uber-Anwendungen für iOS implementiert und den HTTP-Verkehr von Netzwerk- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APIs</a> mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NSURLProtocol abgefangen</a> .  Diese von der iOS Foundation bereitgestellte Abstraktion verarbeitet protokollspezifische URL-Daten und stellt sicher, dass wir Cronet ohne erhebliche Migrationskosten in unsere iOS-Apps integrieren können. <br><br><h2>  Quic auf Google Cloud Balancers abgeschlossen </h2><br>  Auf der Backend-Seite wird die QUIC-Beendigung von der Google Cloud Load Balancing-Infrastruktur bereitgestellt, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alt-SVC-</a> Header in Antworten verwendet, um QUIC zu unterstützen.  Im Allgemeinen fügt der Balancer jeder HTTP-Anforderung den alt-svc-Header hinzu und überprüft bereits die QUIC-Unterstützung für die Domäne.  Wenn der Cronet-Client eine HTTP-Antwort mit diesem Header empfängt, verwendet er QUIC für nachfolgende HTTP-Anforderungen an diese Domäne.  Sobald der Balancer QUIC abgeschlossen hat, sendet unsere Infrastruktur diese Aktion explizit über HTTP2 / TCP an unsere Rechenzentren. <br><br><h2>  Leistung: Ergebnisse </h2><br>  Hervorragende Leistung ist der Hauptgrund für unsere Suche nach einem besseren Protokoll.  Zuerst haben wir einen Stand mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerkemulation erstellt,</a> um herauszufinden, wie sich QUIC mit verschiedenen Netzwerkprofilen verhält.  Um den Betrieb von QUIC in realen Netzwerken zu testen, haben wir in Neu-Delhi mit emuliertem Netzwerkverkehr experimentiert, der HTTP-Anrufen in der Passagieranwendung sehr ähnlich ist. <br><br><h3>  Versuch 1 </h3><br>  Inventar für Experimente: <br><ul><li>  Android-Testgeräte mit OkHttp- und Cronet-Stacks, um sicherzustellen, dass HTTPS-Datenverkehr über TCP bzw. QUIC gesendet wird; </li><li>  ein Java-basierter Emulationsserver, der in Antworten denselben Typ von HTTPS-Headern sendet und Clientgeräte lädt, um Anforderungen von ihnen zu empfangen; </li><li>  Cloud-Proxys, die sich physisch in der Nähe von Indien befinden, um TCP- und QUIC-Verbindungen herzustellen.  Während wir den Reverse-Proxy unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NGINX verwendet haben</a> , um TCP abzuschließen, war es schwierig, den Open-Source-Reverse-Proxy für QUIC zu finden.  Wir haben den Reverse-Proxy für QUIC selbst erstellt, indem wir den Basis-QUIC-Stack von Chromium verwendet und ihn als Open Source in Chrom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">veröffentlicht</a> haben. </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/vp/qt/sx/vpqtsxbastzm3um6hjwcdz2giv8.png" width="49%"></a> <a href=""><img src="https://habrastorage.org/webt/qc/ti/vz/qctivzpddsppzzfxhfqbkgzopyk.png" width="49%"></a> <br>  <font color="grey">Abbildung 6. Der Reisesatz für TCP- und QUIC-Tests bestand aus Android-Geräten mit OkHttp und Cronet, Cloud-Proxys zum Beenden von Verbindungen und einem Emulationsserver.</font> <br><br><h3>  Experiment 2 </h3><br>  Als Google QUIC mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://cloud.google.com/blog/products/gcp/introducing-quic-support-">Google Cloud Load Balancing zur Verfügung stellte</a> , verwendeten wir dasselbe Inventar, jedoch mit einer Änderung: Anstelle von NGINX verwendeten wir Google Balancer, um TCP- und QUIC-Verbindungen von Geräten herzustellen und den HTTPS-Verkehr zum Emulationsserver weiterzuleiten .  Balancer sind auf der ganzen Welt verteilt, verwenden jedoch den PoP-Server, der dem Gerät am nächsten liegt (dank der Geolokalisierung). <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/bl/ec/v-/blecv-4m260dn8_ufg9d0tuq5e4.png"></a> </div><br>  <font color="grey">Abbildung 7. Im zweiten Experiment wollten wir die TCP-Abschlussverzögerung und QUIC vergleichen: Verwenden von Google Cloud und Verwenden unseres Cloud-Proxys.</font> <br><br>  Infolgedessen erwarteten uns mehrere Enthüllungen: <br><ul><li>  <b>Die PoP-Terminierung verbesserte die TCP-Leistung.</b>  Da Balancer die TCP-Verbindung näher an den Benutzern herstellen und perfekt optimiert sind, führt dies zu einer geringeren RTT, was die TCP-Leistung verbessert.    QUIC   ,     TCP      ( 10-30 ). </li><li> <b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  (hops)</a> .</b>   QUIC-     (   50  ),   ,     – 15%-    20%-   99   TCP.    ,      –    (bottleneck)   . </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/ne/co/7c/neco7cpjmlkjsp0uxdnwfez9cuk.png" width="49%"></a> <a href=""><img src="https://habrastorage.org/webt/zd/gl/2d/zdgl2d_tftg33ztgy_t90ikfcui.png" width="49%"></a> <br> <font color="grey"> 8.    ,  QUIC   TCP.</font> <br><br><h2>   </h2><br>  ,    QUIC   Android  iOS-.   A/B ,    QUIC    Uber.  ,          ,       . <br><br>        (95  99 )       – LTE, 3G, 2G. <br> <a href=""><img src="https://habrastorage.org/webt/-7/p7/11/-7p711t91dffb4aoecw6f_woexw.png" width="49%"></a> <a href=""><img src="https://habrastorage.org/webt/oo/q4/gr/ooq4grp5mldwwmiyxyy8poqyqug.png" width="49%"></a> <br> <font color="grey"> 9.    QUIC  TCP  .</font> <br><br><h2>   </h2><br> ,    –  QUIC           ,    ,  : <br><br><h3>   </h3><br>      ,  ,   80%    QUIC  <b></b> ,     15%    QUIC  TCP.  ,    - ,   Cronet    TCP  ,        UDP-    .      ,        QUIC. <br><br><h3>  QUIC </h3><br>       ,     .        .   ,     ,        TCP  QUIC   .           QUIC-  . <br><br>                 ,           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463073/">https://habr.com/ru/post/de463073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463061/index.html">Regeln für die Erstellung von Layouts in Figma</a></li>
<li><a href="../de463063/index.html">Wir beschäftigen uns mit Schnittstellen in Go</a></li>
<li><a href="../de463067/index.html">Zuerst die Vorderseite und dann die Rückseite (eines Tages)</a></li>
<li><a href="../de463069/index.html">Reagieren Sie auf den animierten Leitfaden</a></li>
<li><a href="../de463071/index.html">Welche Auswirkungen haben Internetausfälle?</a></li>
<li><a href="../de463075/index.html">Neue Open Source-Lizenzen</a></li>
<li><a href="../de463083/index.html">Schutz von iPhone-Backups</a></li>
<li><a href="../de463085/index.html">Cage Remote File Access System</a></li>
<li><a href="../de463089/index.html">Implementierung eines Unternehmenssuchsystems für Konstrukteure unter Verwendung der Low-Code-Plattform</a></li>
<li><a href="../de463095/index.html">Warum nicht SQL?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>