<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèø üë®üèæ‚Äçüéì üßóüèª QUIC in Aktion: Wie Uber es implementiert hat, um die Leistung zu optimieren üë¢ üë©üèª‚Äçüè≠ üêü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das QUIC-Protokoll ist √§u√üerst interessant anzusehen, daher schreiben wir gerne dar√ºber. Wenn die vorherigen Ver√∂ffentlichungen zu QUIC jedoch eher hi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>QUIC in Aktion: Wie Uber es implementiert hat, um die Leistung zu optimieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/463073/">  Das QUIC-Protokoll ist √§u√üerst interessant anzusehen, daher schreiben wir gerne dar√ºber.  Wenn die vorherigen Ver√∂ffentlichungen zu QUIC jedoch eher historischer Natur (Material, wenn Sie m√∂chten) und Material waren, freuen wir uns, heute eine andere Interpretation zu ver√∂ffentlichen - wir werden √ºber die tats√§chliche Anwendung des Protokolls im Jahr 2019 sprechen.  Und es geht nicht um eine kleine Infrastruktur in einer bedingten Garage, sondern um Uber, das fast auf der ganzen Welt funktioniert.  Wie kamen die Ingenieure des Unternehmens zu der Entscheidung, QUIC in der Produktion einzusetzen, wie testeten sie und was sahen sie nach dem Start in die Produktion - unter dem Schnitt. <br><blockquote>  Bilder sind anklickbar.  Viel Spa√ü beim Lesen! </blockquote><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/t-/vf/ou/t-vfouxapcoi45iq_uugxs3-4lo.png"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <a name="habracut"></a><br>  Uber ist ein globaler Ma√üstab, n√§mlich 600 Pr√§senzst√§dte, in denen die Anwendung vollst√§ndig auf dem drahtlosen Internet von mehr als 4.500 Mobilfunkbetreibern basiert.  Benutzer erwarten, dass die Anwendung nicht nur schnell, sondern auch in Echtzeit funktioniert. Um dies sicherzustellen, ben√∂tigt die Uber-Anwendung eine geringe Latenz und eine sehr zuverl√§ssige Verbindung.  Leider f√ºhlt sich der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP / 2-</a> Stack in dynamischen und verlustanf√§lligen drahtlosen Netzwerken nicht gut an.  Wir haben festgestellt, dass in diesem Fall eine geringe Leistung in direktem Zusammenhang mit TCP-Implementierungen in den Kerneln von Betriebssystemen steht. <br><br>  Um das Problem zu l√∂sen, haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QUIC</a> angewendet, ein modernes Protokoll mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kanalmultiplex</a> , mit dem wir die Leistung des Transportprotokolls besser kontrollieren k√∂nnen.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IETF-</a> Arbeitsgruppe standardisiert derzeit QUIC als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP / 3</a> . <br><br>  Nach detaillierten Tests kamen wir zu dem Schluss, dass die Implementierung von QUIC in unserer Anwendung die Verz√∂gerungen im Vergleich zu TCP verringert.  Am Beispiel von Fahrer- und Beifahreranwendungen beobachteten wir einen R√ºckgang des Bereichs von 10 bis 30% f√ºr den HTTPS-Verkehr.  QUIC gab uns auch die End-to-End-Kontrolle √ºber benutzerdefinierte Pakete. <br><br>  In diesem Artikel teilen wir unsere Erfahrungen mit der Optimierung von TCP f√ºr Uber-Anwendungen mithilfe eines Stacks, der QUIC unterst√ºtzt. <br><br><h2>  Letztes Wort der Technologie: TCP </h2><br>  Heute ist TCP das am h√§ufigsten verwendete Transportprotokoll f√ºr die Bereitstellung von HTTPS-Verkehr im Internet.  TCP stellt einen zuverl√§ssigen Bytestrom bereit und bew√§ltigt so die √úberlastung des Netzwerks und den Verlust der Verbindungsschicht.  Die weit verbreitete Verwendung von TCP f√ºr den HTTPS-Verkehr erkl√§rt sich aus der Allgegenwart des ersteren (fast jedes Betriebssystem enth√§lt TCP), der Verf√ºgbarkeit auf dem gr√∂√üten Teil der Infrastruktur (z. B. auf Load Balancern, HTTPS-Proxys und CDNs) und der sofort einsatzbereiten Funktionalit√§t, die auf den meisten Plattformen und Plattformen verf√ºgbar ist Netzwerke. <br><br>  Die meisten Benutzer verwenden unsere Anwendung unterwegs, und TCP-Verz√∂gerungen sind weit entfernt von den Echtzeitanforderungen unseres HTTPS-Verkehrs.  Einfach ausgedr√ºckt, Benutzer auf der ganzen Welt sind damit konfrontiert - Abbildung 1 zeigt Verz√∂gerungen in Gro√üst√§dten: <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/z1/4r/dr/z14rdrs2ba8rzmrb8akbtadvqxy.png"></a> </div><br>  <font color="grey">Abbildung 1. Das Ausma√ü der Verz√∂gerungen variiert in den Hauptst√§dten, in denen Uber t√§tig ist.</font> <br><br>  Trotz der Tatsache, dass es in indischen und brasilianischen Netzen mehr Verz√∂gerungen gab als in den USA und Gro√übritannien, sind die Verz√∂gerungen im Heck viel gr√∂√üer als die durchschnittlichen Verz√∂gerungen.  Dies gilt auch f√ºr die USA und Gro√übritannien. <br><br><h2>  TCP-Leistung √ºber Funk </h2><br>  TCP wurde f√ºr <b>kabelgebundene</b> Netzwerke entwickelt, <b>dh</b> mit Schwerpunkt auf gut vorhersehbaren Verbindungen.  <b>Drahtlose</b> Netzwerke haben jedoch ihre eigenen Eigenschaften und Schwierigkeiten.  Erstens sind drahtlose Netzwerke aufgrund von Interferenzen und Signald√§mpfung verlustanf√§llig.  Beispielsweise reagieren Wi-Fi-Netzwerke empfindlich auf Mikrowellen, Bluetooth und andere Funkwellen.  Mobilfunknetze leiden unter Signalverlust ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pfadverlust</a> ) aufgrund von Reflexion / Absorption des Signals durch Objekte und Geb√§ude sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">St√∂rungen</a> durch benachbarte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zellt√ºrme</a> .  Dies f√ºhrt zu signifikanteren (4-10-fachen) und einer Vielzahl von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Round-Trip-Verz√∂gerungen (RTT)</a> und Paketverlusten im Vergleich zu einer Kabelverbindung. <br><br>  Um Bandbreitenschwankungen und -verlusten entgegenzuwirken, verwenden Mobilfunknetze normalerweise gro√üe Puffer f√ºr Verkehrsst√∂√üe.  Dies kann zu einer √ºberm√§√üigen Priorit√§t f√ºhren, was l√§ngere Verz√∂gerungen bedeutet.  Sehr oft behandelt TCP eine solche Sequenz als Verlust aufgrund eines erh√∂hten Zeitlimits, so dass TCP dazu neigt, ein Relais durchzuf√ºhren und dadurch den Puffer zu f√ºllen.  Dieses Problem ist als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bufferbloat</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberm√§√üige Netzwerkpufferung, Pufferschwellung</a> ) bekannt und ein sehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ernstes Problem des</a> modernen Internets. <br><br>  Schlie√ülich variiert die Leistung des Mobilfunknetzes je nach Netzbetreiber, Region und Zeit.  In Abbildung 2 haben wir die mittleren Verz√∂gerungen des HTTPS-Verkehrs √ºber Zellen in einer Reichweite von 2 Kilometern erfasst.  Daten werden f√ºr die beiden gr√∂√üten Mobilfunkbetreiber in Delhi, Indien, gesammelt.  Wie Sie sehen k√∂nnen, variiert die Leistung von Zelle zu Zelle.  Au√üerdem unterscheidet sich die Leistung eines Bedieners von der Leistung des zweiten.  Dies wird durch Faktoren wie Muster des Netzwerkzugriffs unter Ber√ºcksichtigung von Zeit und Ort, Benutzermobilit√§t sowie Netzwerkinfrastruktur unter Ber√ºcksichtigung der Dichte der T√ºrme und des Verh√§ltnisses der Netzwerktypen (LTE, 3G usw.) beeinflusst. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/ln/vz/ya/lnvzyai54p_xde2mfcr50ddoopa.png"></a> </div><br>  <font color="grey">Abbildung 2. Verz√∂gerungen f√ºr ein Beispiel eines Radius von 2 km.</font>  <font color="grey">Delhi, Indien.</font> <br><br>  Auch die Leistung von Mobilfunknetzen variiert im Laufe der Zeit.  Abbildung 3 zeigt die mittlere Verz√∂gerung nach Wochentag.  Wir haben auch einen Unterschied in kleinerem Ma√üstab beobachtet - innerhalb eines Tages und einer Stunde. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/xu/oo/u_/xuoou_03qrdllnyebxvrpiwa1iy.png"></a> </div><br>  <font color="grey">Abbildung 3. Schwanzverz√∂gerungen k√∂nnen an verschiedenen Tagen erheblich variieren, jedoch mit demselben Bediener.</font> <br><br>  All dies f√ºhrt dazu, dass die TCP-Leistung in drahtlosen Netzwerken ineffizient ist.  Bevor wir jedoch nach Alternativen zu TCP suchten, wollten wir ein genaues Verst√§ndnis der folgenden Punkte entwickeln: <br><ul><li>  Ist TCP der Hauptverursacher von Verz√∂gerungen bei unseren Anwendungen? </li><li>  Haben moderne Netze erhebliche und unterschiedliche Round-Trip-Verz√∂gerungen (RTT)? </li><li>  Welche Auswirkungen hat der Leistungsverlust von RTT und TCP? </li></ul><br><h2>  TCP-Leistungsanalyse </h2><br>  Um zu verstehen, wie wir die TCP-Leistung analysiert haben, erinnern wir uns kurz daran, wie TCP Daten von einem Absender zu einem Empf√§nger √ºbertr√§gt.  Zun√§chst stellt der Absender eine TCP-Verbindung her, indem er einen Drei-Wege- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handshake</a> ausf√ºhrt: Der Absender sendet ein SYN-Paket, wartet auf ein SYN-ACK-Paket vom Empf√§nger und sendet dann ein ACK-Paket.  Zus√§tzliche zweite und dritte Durchg√§nge dienen zum Erstellen einer TCP-Verbindung.  Der Empf√§nger best√§tigt den Empfang jedes Pakets (ACK), um eine zuverl√§ssige Zustellung sicherzustellen. <br><br>  Wenn ein Paket oder eine ACK verloren geht, sendet der Absender nach einer Zeit√ºberschreitung erneut (RTO, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeit√ºberschreitung bei</a> erneuter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbertragung</a> ).  Die RTO wird dynamisch basierend auf verschiedenen Faktoren berechnet, beispielsweise der erwarteten RTT-Verz√∂gerung zwischen Sender und Empf√§nger. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/-w/nf/g8/-wnfg8rew9-lbfsaxfw6k9fnnxi.png"></a> </div><br>  <font color="grey">Abbildung 4. Der TCP / TLS-Paketaustausch enth√§lt einen Mechanismus zur erneuten √úbertragung.</font> <br><br>  Um festzustellen, wie TCP in unseren Anwendungen funktioniert, haben wir eine Woche lang TCP-Pakete mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tcpdump</a> auf den Kampfverkehr von indischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grenzservern</a> √ºberwacht.  Dann haben wir die TCP-Verbindungen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tcptrace</a> analysiert.  Dar√ºber hinaus haben wir eine Android-Anwendung erstellt, die emulierten Datenverkehr an einen Testserver sendet und den tats√§chlichen Datenverkehr so ‚Äã‚Äãweit wie m√∂glich nachahmt.  Smartphones mit dieser Anwendung wurden an mehrere Mitarbeiter verteilt, die mehrere Tage lang Protokolle sammelten. <br><br>  Die Ergebnisse beider Experimente stimmten √ºberein.  Wir haben hohe RTT-Verz√∂gerungen gesehen;  Schwanzwerte waren fast 6-mal h√∂her als der Medianwert;  arithmetischer Mittelwert der Verz√∂gerungen - mehr als 1 Sekunde.  Viele Verbindungen waren verlustbehaftet, sodass TCP 3,5% aller Pakete erneut √ºbertrug.  In √ºberlasteten Gebieten wie Flugh√§fen und Bahnh√∂fen verzeichneten wir einen Verlust von 7%.  Solche Ergebnisse werfen Zweifel an der herk√∂mmlichen Weisheit auf, dass die in Mobilfunknetzen verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fortschrittlichen Neu√ºbertragungsschemata</a> den Transportverlust erheblich reduzieren.  Nachfolgend finden Sie die Testergebnisse der Anwendung ‚ÄûSimulator‚Äú: <br><div class="scrollable-table"><table><tbody><tr><th>  Netzwerkmetriken </th><th>  Werte </th></tr><tr><td>  <b>RTT, Millisekunden [50%, 75%, 95%, 99%]</b> </td><td>  [350, 425, 725, 2300] </td></tr><tr><td>  <b>RTT-Diskrepanz, Sekunden</b> </td><td>  ~ 1,2 s Durchschnitt </td></tr><tr><td>  <b>Paketverlust bei instabilen Verbindungen</b> </td><td>  Im Durchschnitt ~ 3,5% (7% in Gebieten mit √úberlastung) </td></tr></tbody></table></div><br>  Fast die H√§lfte dieser Verbindungen hatte mindestens einen Paketverlust, von denen die meisten SYN- und SYN-ACK-Pakete waren.  Die meisten TCP-Implementierungen verwenden einen RTO-Wert von 1 Sekunde f√ºr SYN-Pakete, der f√ºr nachfolgende Verluste exponentiell ansteigt.  Die Ladezeit der Anwendung kann sich erh√∂hen, da TCP mehr Zeit zum Herstellen von Verbindungen ben√∂tigt. <br><br>  Im Fall von Datenpaketen reduzieren hohe RTOs die n√ºtzliche Netzwerkauslastung bei vor√ºbergehenden Verlusten in drahtlosen Netzwerken erheblich.  Wir haben festgestellt, dass die durchschnittliche Neu√ºbertragungszeit etwa 1 Sekunde mit einer Endverz√∂gerung von fast 30 Sekunden betr√§gt.  Solche hohen Verz√∂gerungen auf TCP-Ebene verursachten HTTPS-Timeouts und Wiederholungsversuche, was die Latenz und die Ineffizienz des Netzwerks weiter erh√∂hte. <br><br>  W√§hrend das 75. Perzentil der gemessenen RTT etwa 425 ms betrug, betrug das 75. Perzentil f√ºr TCP fast 3 Sekunden.  Dies deutet darauf hin, dass der Verlust TCP gezwungen hat, 7 bis 10 Durchg√§nge durchzuf√ºhren, um Daten erfolgreich zu √ºbertragen.  Dies kann auf eine ineffektive RTO-Berechnung, die Unf√§higkeit von TCP, schnell auf den Verlust der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Pakete</a> im Fenster zu reagieren, und die Ineffizienz des √úberlastungssteuerungsalgorithmus zur√ºckzuf√ºhren sein, der nicht zwischen drahtlosen Verlusten und Verlusten aufgrund von Netzwerk√ºberlastung unterscheidet.  Nachfolgend sind die Ergebnisse des TCP-Verlusttests aufgef√ºhrt: <br><div class="scrollable-table"><table><tbody><tr><th>  TCP-Paketverluststatistik </th><th>  Wert </th></tr><tr><td>  Prozentsatz der Verbindungen mit mindestens 1 Paketverlust </td><td>  45% </td></tr><tr><td>  Der Prozentsatz der Verbindungen mit Verlust w√§hrend des Verbindungsaufbaus </td><td>  30% </td></tr><tr><td>  Der Prozentsatz der Verbindungen mit Verlust w√§hrend des Datenaustauschs </td><td>  76% </td></tr><tr><td>  Verteilung der Verz√∂gerungen bei erneuter √úbertragung, Sekunden [50%, 75%, 95%, 99%] </td><td>  [1, 2,8, 15, 28] </td></tr><tr><td>  Verteilung von Neu√ºbertragungen f√ºr ein einzelnes Paket oder TCP-Segment </td><td>  [1,3,6,7] </td></tr></tbody></table></div><br><h2>  QUIC-Anwendung </h2><br>  QUIC wurde urspr√ºnglich von Google entwickelt und ist ein modernes Multithread-Transportprotokoll, das auf UDP ausgef√ºhrt wird.  Im Moment befindet sich QUIC im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardisierungsprozess</a> (wir haben bereits geschrieben, dass es sozusagen zwei Versionen von QUIC gibt, die Neugierigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√∂nnen dem Link folgen</a> - ca. √úbersetzer).  Wie in Abbildung 5 gezeigt, wird QUIC unter HTTP / 3 gehostet (tats√§chlich HTTP / 2 √ºber QUIC - dies ist HTTP / 3, das jetzt stark standardisiert ist).  Es ersetzt teilweise die HTTPS- und TCP-Schichten und verwendet UDP, um Pakete zu bilden.  QUIC unterst√ºtzt nur die sichere Daten√ºbertragung, da TLS vollst√§ndig in QUIC integriert ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y4/an/qg/y4anqgxplkww-bc3thmjykbdg2i.png"></div><br>  <font color="grey">Abbildung 5: QUIC funktioniert unter HTTP / 3 und ersetzt TLS, das fr√ºher unter HTTP / 2 funktioniert hat.</font> <br><br>  Nachfolgend sind die Gr√ºnde aufgef√ºhrt, die uns √ºberzeugt haben, QUIC zur St√§rkung von TCP zu verwenden: <br><ul><li>  <b>0-RTT-Verbindungsaufbau.</b>  QUIC erm√∂glicht die Wiederverwendung von Berechtigungen aus fr√ºheren Verbindungen, wodurch die Anzahl der Sicherheitshandshakes verringert wird.  In Zukunft wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLS1.3</a> 0-RTT unterst√ºtzen, es ist jedoch weiterhin ein Drei-Wege-TCP-Handshake erforderlich. </li><li>  <b>√úberwindung der HoL-Blockierung.</b>  HTTP / 2 verwendet eine TCP-Verbindung f√ºr jeden Client, um die Leistung zu verbessern. Dies kann jedoch zu einem HoL-Block (Head-of-Line) f√ºhren.  QUIC vereinfacht das Multiplexen und liefert Anforderungen unabh√§ngig voneinander an die Anwendung. </li><li>  <b>√úberlastungsmanagement.</b>  QUIC befindet sich auf Anwendungsebene, wodurch es einfacher wird, den Haupttransportalgorithmus zu aktualisieren, der das Senden basierend auf Netzwerkparametern (Verlustbetrag oder RTT) steuert.  Die meisten TCP-Implementierungen verwenden den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBIC-</a> Algorithmus, der f√ºr verz√∂gerungsempfindlichen Datenverkehr nicht optimal ist.  Neu entwickelte Algorithmen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BBR</a> modellieren das Netzwerk genauer und optimieren die Latenz.  Mit QUIC k√∂nnen Sie BBR verwenden und diesen Algorithmus aktualisieren, wenn er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verbessert wird</a> . </li><li>  <b>Verluste ausgleichen.</b>  QUIC ruft zwei TLPs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tail Loss Probe</a> ) auf, bevor die RTO ausgel√∂st wird - auch wenn die Verluste sehr sp√ºrbar sind.  Dies unterscheidet sich von TCP-Implementierungen.  TLP √ºbertr√§gt haupts√§chlich das letzte Paket (oder ein neues, falls vorhanden) erneut, um eine schnelle Wiederauff√ºllung auszul√∂sen.  Die Schwanzverz√∂gerungsverarbeitung ist besonders n√ºtzlich f√ºr die Arbeitsweise von Uber mit dem Netzwerk, insbesondere f√ºr kurze, episodische und verz√∂gerungsempfindliche Daten√ºbertragungen. </li><li>  <b>optimiertes ACK.</b>  Da jedes Paket eine eindeutige Seriennummer hat, besteht kein Problem bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterscheidung zwischen</a> Paketen, wenn diese weitergeleitet werden.  ACK-Pakete enthalten auch Zeit zum Verarbeiten des Pakets und zum Generieren clientseitiger ACKs.  Diese Funktionen stellen sicher, dass QUIC die RTT genauer berechnet.  Das QUIC ACK unterst√ºtzt bis zu 256 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NACK-</a> Bereiche, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wodurch</a> der Absender widerstandsf√§higer gegen Paketaustausch ist und dabei weniger Bytes verwendet.  Selective ACK ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SACK</a> ) in TCP l√∂st dieses Problem nicht in allen F√§llen. </li><li>  <b>Verbindungsmigration.</b>  QUIC-Verbindungen werden durch eine 64-Bit-ID identifiziert. Wenn der Client die IP-Adressen √§ndert, k√∂nnen Sie die ID der alten Verbindung ohne Unterbrechung weiterhin f√ºr die neue IP-Adresse verwenden.  Dies ist eine sehr g√§ngige Praxis f√ºr mobile Anwendungen, wenn ein Benutzer zwischen Wi-Fi und Mobilfunkverbindungen wechselt. </li></ul><br><h2>  Alternativen zu QUIC </h2><br>  Wir haben uns alternative L√∂sungsans√§tze angesehen, bevor wir uns f√ºr QUIC entschieden haben. <br><br>  Zun√§chst haben wir versucht, TPC-PoPs (Points of Presence) bereitzustellen, um TCP-Verbindungen n√§her an den Benutzern herzustellen.  Im Wesentlichen beenden PoPs die TCP-Verbindung mit dem mobilen Ger√§t n√§her am Mobilfunknetz und leiten den Datenverkehr an die urspr√ºngliche Infrastruktur weiter.  Wenn wir TCP n√§her schlie√üen, k√∂nnen wir m√∂glicherweise die RTT reduzieren und sicherstellen, dass TCP besser auf dynamische drahtlose Umgebungen reagiert.  Unsere Experimente haben jedoch gezeigt, dass RTT und Verluste gr√∂√ütenteils aus zellularen Netzwerken stammen und die Verwendung von PoPs keine signifikante Leistungsverbesserung bietet. <br><br>  Wir haben uns auch mit der Optimierung der TCP-Parameter befasst.  Die Konfiguration des TCP-Stacks auf unseren heterogenen Edgeservern war schwierig, da TCP in verschiedenen Betriebssystemversionen unterschiedliche Implementierungen aufweist.  Es war schwierig, dies zu implementieren und verschiedene Netzwerkkonfigurationen zu testen.  Die Konfiguration von TCP direkt auf Mobilger√§ten war aufgrund mangelnder Berechtigung nicht m√∂glich.  Noch wichtiger ist, dass Chips wie Verbindungen mit 0-RTT und eine verbesserte RTT-Vorhersage f√ºr die Protokollarchitektur von entscheidender Bedeutung sind. Daher ist es nicht m√∂glich, allein durch die Konfiguration von TCP signifikante Vorteile zu erzielen. <br><br>  Schlie√ülich haben wir mehrere UDP-basierte Protokolle evaluiert, mit denen das Video-Streaming behoben werden kann. Wir wollten wissen, ob diese Protokolle in unserem Fall hilfreich sind.  Leider fehlten ihnen viele Sicherheitseinstellungen und sie ben√∂tigten eine zus√§tzliche TCP-Verbindung f√ºr Metadaten und Steuerinformationen. <br><br>  Unsere Untersuchungen haben gezeigt, dass QUIC fast das einzige Protokoll ist, das bei dem Problem des Internetverkehrs helfen kann, wobei sowohl Sicherheit als auch Leistung ber√ºcksichtigt werden. <br><br><h2>  QUIC-Integration in die Plattform </h2><br>  Um QUIC erfolgreich zu integrieren und die Anwendungsleistung unter schlechten Kommunikationsbedingungen zu verbessern, haben wir den alten Stack (HTTP / 2 √ºber TLS / TCP) durch das QUIC-Protokoll ersetzt.  Wir haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cronet-</a> Netzwerkbibliothek von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chromium Projects verwendet</a> , die die urspr√ºngliche Google-Version des Protokolls - gQUIC - enth√§lt.  Diese Implementierung wird auch st√§ndig verbessert, um der neuesten IETF-Spezifikation zu entsprechen. <br><br>  Zuerst haben wir Cronet in unsere Android-Apps integriert, um QUIC-Unterst√ºtzung hinzuzuf√ºgen.  Die Integration wurde durchgef√ºhrt, um die Migrationskosten zu minimieren.  Anstatt den alten Netzwerkstapel, der die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://square.github.io/ok">OkHttp-</a> Bibliothek verwendete, vollst√§ndig zu ersetzen, haben wir Cronet UNTER das OkHttp-API-Framework integriert.  Durch diese Integration haben wir √Ñnderungen in unseren Netzwerkaufrufen (die von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Retrofit</a> verwendet werden) auf API-Ebene vermieden. <br><br>  √Ñhnlich wie bei Android-Ger√§ten haben wir Cronet in Uber-Anwendungen f√ºr iOS implementiert und den HTTP-Verkehr von Netzwerk- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APIs</a> mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NSURLProtocol abgefangen</a> .  Diese von der iOS Foundation bereitgestellte Abstraktion verarbeitet protokollspezifische URL-Daten und stellt sicher, dass wir Cronet ohne erhebliche Migrationskosten in unsere iOS-Apps integrieren k√∂nnen. <br><br><h2>  Quic auf Google Cloud Balancers abgeschlossen </h2><br>  Auf der Backend-Seite wird die QUIC-Beendigung von der Google Cloud Load Balancing-Infrastruktur bereitgestellt, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alt-SVC-</a> Header in Antworten verwendet, um QUIC zu unterst√ºtzen.  Im Allgemeinen f√ºgt der Balancer jeder HTTP-Anforderung den alt-svc-Header hinzu und √ºberpr√ºft bereits die QUIC-Unterst√ºtzung f√ºr die Dom√§ne.  Wenn der Cronet-Client eine HTTP-Antwort mit diesem Header empf√§ngt, verwendet er QUIC f√ºr nachfolgende HTTP-Anforderungen an diese Dom√§ne.  Sobald der Balancer QUIC abgeschlossen hat, sendet unsere Infrastruktur diese Aktion explizit √ºber HTTP2 / TCP an unsere Rechenzentren. <br><br><h2>  Leistung: Ergebnisse </h2><br>  Hervorragende Leistung ist der Hauptgrund f√ºr unsere Suche nach einem besseren Protokoll.  Zuerst haben wir einen Stand mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerkemulation erstellt,</a> um herauszufinden, wie sich QUIC mit verschiedenen Netzwerkprofilen verh√§lt.  Um den Betrieb von QUIC in realen Netzwerken zu testen, haben wir in Neu-Delhi mit emuliertem Netzwerkverkehr experimentiert, der HTTP-Anrufen in der Passagieranwendung sehr √§hnlich ist. <br><br><h3>  Versuch 1 </h3><br>  Inventar f√ºr Experimente: <br><ul><li>  Android-Testger√§te mit OkHttp- und Cronet-Stacks, um sicherzustellen, dass HTTPS-Datenverkehr √ºber TCP bzw. QUIC gesendet wird; </li><li>  ein Java-basierter Emulationsserver, der in Antworten denselben Typ von HTTPS-Headern sendet und Clientger√§te l√§dt, um Anforderungen von ihnen zu empfangen; </li><li>  Cloud-Proxys, die sich physisch in der N√§he von Indien befinden, um TCP- und QUIC-Verbindungen herzustellen.  W√§hrend wir den Reverse-Proxy unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NGINX verwendet haben</a> , um TCP abzuschlie√üen, war es schwierig, den Open-Source-Reverse-Proxy f√ºr QUIC zu finden.  Wir haben den Reverse-Proxy f√ºr QUIC selbst erstellt, indem wir den Basis-QUIC-Stack von Chromium verwendet und ihn als Open Source in Chrom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ver√∂ffentlicht</a> haben. </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/vp/qt/sx/vpqtsxbastzm3um6hjwcdz2giv8.png" width="49%"></a> <a href=""><img src="https://habrastorage.org/webt/qc/ti/vz/qctivzpddsppzzfxhfqbkgzopyk.png" width="49%"></a> <br>  <font color="grey">Abbildung 6. Der Reisesatz f√ºr TCP- und QUIC-Tests bestand aus Android-Ger√§ten mit OkHttp und Cronet, Cloud-Proxys zum Beenden von Verbindungen und einem Emulationsserver.</font> <br><br><h3>  Experiment 2 </h3><br>  Als Google QUIC mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://cloud.google.com/blog/products/gcp/introducing-quic-support-">Google Cloud Load Balancing zur Verf√ºgung stellte</a> , verwendeten wir dasselbe Inventar, jedoch mit einer √Ñnderung: Anstelle von NGINX verwendeten wir Google Balancer, um TCP- und QUIC-Verbindungen von Ger√§ten herzustellen und den HTTPS-Verkehr zum Emulationsserver weiterzuleiten .  Balancer sind auf der ganzen Welt verteilt, verwenden jedoch den PoP-Server, der dem Ger√§t am n√§chsten liegt (dank der Geolokalisierung). <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/bl/ec/v-/blecv-4m260dn8_ufg9d0tuq5e4.png"></a> </div><br>  <font color="grey">Abbildung 7. Im zweiten Experiment wollten wir die TCP-Abschlussverz√∂gerung und QUIC vergleichen: Verwenden von Google Cloud und Verwenden unseres Cloud-Proxys.</font> <br><br>  Infolgedessen erwarteten uns mehrere Enth√ºllungen: <br><ul><li>  <b>Die PoP-Terminierung verbesserte die TCP-Leistung.</b>  Da Balancer die TCP-Verbindung n√§her an den Benutzern herstellen und perfekt optimiert sind, f√ºhrt dies zu einer geringeren RTT, was die TCP-Leistung verbessert.    QUIC   ,     TCP      ( 10-30 ). </li><li> <b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  (hops)</a> .</b>   QUIC-     (   50  ),   ,     ‚Äì 15%-    20%-   99   TCP.    ,      ‚Äì    (bottleneck)   . </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/ne/co/7c/neco7cpjmlkjsp0uxdnwfez9cuk.png" width="49%"></a> <a href=""><img src="https://habrastorage.org/webt/zd/gl/2d/zdgl2d_tftg33ztgy_t90ikfcui.png" width="49%"></a> <br> <font color="grey"> 8.    ,  QUIC   TCP.</font> <br><br><h2>   </h2><br>  ,    QUIC   Android  iOS-.   A/B ,    QUIC    Uber.  ,          ,       . <br><br>        (95  99 )       ‚Äì LTE, 3G, 2G. <br> <a href=""><img src="https://habrastorage.org/webt/-7/p7/11/-7p711t91dffb4aoecw6f_woexw.png" width="49%"></a> <a href=""><img src="https://habrastorage.org/webt/oo/q4/gr/ooq4grp5mldwwmiyxyy8poqyqug.png" width="49%"></a> <br> <font color="grey"> 9.    QUIC  TCP  .</font> <br><br><h2>   </h2><br> ,    ‚Äì  QUIC           ,    ,  : <br><br><h3>   </h3><br>      ,  ,   80%    QUIC  <b></b> ,     15%    QUIC  TCP.  ,    - ,   Cronet    TCP  ,        UDP-    .      ,        QUIC. <br><br><h3>  QUIC </h3><br>       ,     .        .   ,     ,        TCP  QUIC   .           QUIC-  . <br><br>                 ,           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463073/">https://habr.com/ru/post/de463073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463061/index.html">Regeln f√ºr die Erstellung von Layouts in Figma</a></li>
<li><a href="../de463063/index.html">Wir besch√§ftigen uns mit Schnittstellen in Go</a></li>
<li><a href="../de463067/index.html">Zuerst die Vorderseite und dann die R√ºckseite (eines Tages)</a></li>
<li><a href="../de463069/index.html">Reagieren Sie auf den animierten Leitfaden</a></li>
<li><a href="../de463071/index.html">Welche Auswirkungen haben Internetausf√§lle?</a></li>
<li><a href="../de463075/index.html">Neue Open Source-Lizenzen</a></li>
<li><a href="../de463083/index.html">Schutz von iPhone-Backups</a></li>
<li><a href="../de463085/index.html">Cage Remote File Access System</a></li>
<li><a href="../de463089/index.html">Implementierung eines Unternehmenssuchsystems f√ºr Konstrukteure unter Verwendung der Low-Code-Plattform</a></li>
<li><a href="../de463095/index.html">Warum nicht SQL?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>