<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‼️ 👩🏾‍🔬 🧜🏿 在实体框架中加入本地集合和DbSet ⚕️ 👨🏼‍🚒 😣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在我参与的一年多一点的时间里，发生了以下“对话”： 


 .Net App ：嗨，实体框架，给我很多数据！ 
 实体框架 ：对不起，我不了解您。 什么意思 
 .Net App ：是的，我刚刚收集了10万笔交易。 现在，我们需要快速检查那里显示的证券价格的正确性。 
 实体框架 ：嗯，让我们尝试一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在实体框架中加入本地集合和DbSet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435810/"><p> 在我参与的一年多一点的时间里，发生了以下“对话”： </p><br><p>  <strong>.Net App</strong> ：嗨，实体框架，给我很多数据！ <br>  <strong>实体框架</strong> ：对不起，我不了解您。 什么意思 <br>  <strong>.Net App</strong> ：是的，我刚刚收集了10万笔交易。 现在，我们需要快速检查那里显示的证券价格的正确性。 <br>  <strong>实体框架</strong> ：嗯，让我们尝试一下... <br>  <strong>.Net App</strong> ：这是代码： </p><br><pre><code class="cpp hljs">var query = from p in context.Prices join t in transactions on <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { p.Ticker, p.TradedOn, p.PriceSourceId } equals <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { t.Ticker, t.TradedOn, t.PriceSourceId } select p; query.ToList();</code> </pre> <br><p>  <strong>实体框架</strong> ： </p><br><p><img src="https://habrastorage.org/webt/kc/jh/lp/kcjhlpnggo_fhkdgik481svjuea.png"></p><br><p> 经典版 我认为许多人都熟悉这种情况：当我真的想“美丽”并使用本地集合的<em>JOIN</em>和<em>DbSet</em>快速在数据库中进行搜索时。 通常，这种体验令人失望。 </p><br><p> 在本文（这是<em>我其他文章</em>的<em>免费翻译</em> ）中，我将进行一系列实验，并尝试各种方法来解决这一限制。 会有一个代码（不复杂），思想和诸如幸福的结局之类的东西。 </p><a name="habracut"></a><br><h2 id="vvedenie"> 引言 </h2><br><p> 每个人都知道<em>Entity Framework</em> ，每天都有很多人使用它，并且有很多很好的文章介绍了如何正确地制作它（使用更简单的查询，使用Skip and Take中的参数，使用VIEW，仅请求必要的字段，监视查询缓存和其他），但是本地集合和<em>DbSet</em>的<em>JOIN</em>主题仍然是薄弱点。 </p><br><h2 id="zadacha"> 挑战赛 </h2><br><p> 假设有一个包含价格的数据库，并且有一个需要检查价格正确性的交易集合。 并假设我们有以下代码。 </p><br><pre> <code class="cpp hljs">var localData = GetDataFromApiOrUser(); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in localData on <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { s.Ticker, p.TradedOn, p.PriceSourceId } equals <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { t.Ticker, t.TradedOn, t.PriceSourceId } select p; var result = query.ToList();</code> </pre> <br><p> 此代码根本不在<em>Entity Framework 6</em>中工作。 在<em>Entity Framework Core中</em> -它可以工作，但是一切都将在客户端完成，并且在数据库中有数百万条记录的情况下，这不是一个选择。 </p><br><p> 正如我所说，我将尝试不同的方法来解决此问题。 从简单到复杂。 在实验中，我使用以下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库中</a>的代码。 使用以下代码编写代码： <em>C＃</em> <em>，.Net Core</em> ， <em>EF Core</em>和<em>PostgreSQL</em> 。 </p><br><p> 我还拍摄了一些指标：花费的时间和内存消耗。 免责声明：如果测试进行了10分钟以上，我会打断它（限制来自上面）。 测试机器Intel Core i5、8 GB RAM，SSD。 </p><br><div class="spoiler">  <b class="spoiler_title">数据库架构</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/getpro/habr/post_images/1d5/f8c/cec/1d5f8ccec6ef1b7361195c18ac139d09.png" alt="图片"></p><br><p> 仅3个表格： <em>价格</em> ， <em>证券</em>和<em>价格来源</em> 。  <em>价格</em> -包含1000万个条目。 </p></div></div><br><h4 id="sposob-1-naive"> 方法1。天真 </h4><br><p> 让我们开始简单并使用以下代码： </p><br><div class="spoiler">  <b class="spoiler_title">方法1的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { foreach (var testElement in TestData) { result.AddRange(context.Prices.Where( x =&gt; x.Security.Ticker == testElement.Ticker &amp;&amp; x.TradedOn == testElement.TradedOn &amp;&amp; x.PriceSourceId == testElement.PriceSourceId)); } }</code> </pre> </div></div><br><p> 这个想法很简单：在一个循环中，我们一次从数据库读取一条记录，然后将其添加到结果集合中。 这段代码只有一个优点-简单。 缺点之一是速度慢：即使数据库中有索引，大多数情况下它也会与数据库服务器通信。 指标如下： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/985/61c/b6a/98561cb6a2566faff490fc2bf7432fb9.png" alt="图片"></p><br><p> 内存消耗很小。 大量收藏需要1分钟。 首先，还不错，但我希望更快。 </p><br><h4 id="sposob-2-naive-parallel"> 方法2：天真并行 </h4><br><p> 让我们尝试添加并行性。 这个想法是从多个线程访问数据库。 </p><br><div class="spoiler">  <b class="spoiler_title">方法2的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;Price&gt;(); var partitioner = Partitioner.Create(<span class="hljs-number"><span class="hljs-number">0</span></span>, TestData.Count); Parallel.ForEach(partitioner, range =&gt; { var subList = TestData.Skip(range.Item1) .Take(range.Item2 - range.Item1) .ToList(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { foreach (var testElement in subList) { var query = context.Prices.Where( x =&gt; x.Security.Ticker == testElement.Ticker &amp;&amp; x.TradedOn == testElement.TradedOn &amp;&amp; x.PriceSourceId == testElement.PriceSourceId); foreach (var el in query) { result.Add(el); } } } });</code> </pre> </div></div><br><p> 结果： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/916/d22/428/916d224282a3020dc31df6c67a18b070.png" alt="图片"></p><br><p> 对于小型馆藏，此方法甚至比第一种方法慢。 而最大的-快2倍。 有趣的是，我的机器上生成了4个线程，但这并没有导致4倍的加速。 这表明此方法的开销很大：无论是在客户端还是在服务器端。 内存消耗增加了，但没有明显增加。 </p><br><h4 id="sposob-3-multiple-contains"> 方法3：多个包含 </h4><br><p> 是时候尝试其他尝试并将任务简化为一个查询了。 可以按照以下步骤完成： </p><br><ol><li> 准备3个唯一的<em>Ticker</em> ， <em>PriceSourceId</em>和<em>Date</em>集合 </li><li> 运行请求并使用3个<em>包含</em> </li><li> 在本地重新检查结果 </li></ol><br><div class="spoiler">  <b class="spoiler_title">方法3的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { <span class="hljs-comment"><span class="hljs-comment">//   var tickers = TestData.Select(x =&gt; x.Ticker).Distinct().ToList(); var dates = TestData.Select(x =&gt; x.TradedOn).Distinct().ToList(); var ps = TestData.Select(x =&gt; x.PriceSourceId).Distinct().ToList(); //    3 Contains var data = context.Prices .Where(x =&gt; tickers.Contains(x.Security.Ticker) &amp;&amp; dates.Contains(x.TradedOn) &amp;&amp; ps.Contains(x.PriceSourceId)) .Select(x =&gt; new { Price = x, Ticker = x.Security.Ticker, }) .ToList(); var lookup = data.ToLookup(x =&gt; $"{x.Ticker}, {x.Price.TradedOn}, {x.Price.PriceSourceId}"); //  foreach (var el in TestData) { var key = $"{el.Ticker}, {el.TradedOn}, {el.PriceSourceId}"; result.AddRange(lookup[key].Select(x =&gt; x.Price)); } }</span></span></code> </pre> </div></div><br><p> 这里的问题是执行时间和返回的数据量高度依赖于数据本身（在查询和数据库中）。 即，仅返回必要数据的集合，并且可以返回额外的记录（甚至多100倍）。 </p><br><p> 可以使用以下示例进行说明。 假设有包含数据的下表： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3f/2bb/ea5/f3f2bbea5148127963cab9010d2b2f10.png" alt="图片"></p><br><p> 还假设我需要<em>TradedOn</em> = <em>2018-01-01的Ticker1</em>和<em>TradedOn</em> = <em>2018-01-02</em>的<em>Ticker2的</em>价格。 </p><br><p> 然后<em>代码的</em>唯一值=（ <em>Ticker1</em> ， <em>Ticker2</em> ） <br> 而且<em>TradedOn的</em>唯一值=（ <em>2018-01-01，2018-01-02</em> ） </p><br><p> 但是，结果将返回4条记录，因为它们确实对应于这些组合。 不好的是，使用的字段越多，结果获得更多记录的机会就越大。 </p><br><p> 因此，必须在客户端另外过滤通过此方法获得的数据。 这是最大的缺点。 <br> 指标如下： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd5/078/5ef/dd50785efd38900c4d18467607b87a1e.png" alt="图片"></p><br><p> 内存消耗比以前的所有方法都要糟糕。 读取的行数比请求的行数大很多倍。 大型集合的测试运行了10分钟以上，因此被中断。 这种方法不好。 </p><br><h4 id="sposob-4-predicate-builder"> 方法4.谓词生成器 </h4><br><p> 让我们在另一侧尝试一下：好的老式<em>Expression</em> 。 使用它们，您可以按照以下形式构建1个大型查询： </p><br><p> <code>… (.. AND .. AND ..) OR (.. AND .. AND ..) OR (.. AND .. AND ..) …</code> </p> <br><p> 这给希望建立1个请求并仅获得1个呼叫的必要数据的希望。 代码： </p><br><div class="spoiler">  <b class="spoiler_title">方法4的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { var baseQuery = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId select <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestData() { Ticker = s.Ticker, TradedOn = p.TradedOn, PriceSourceId = p.PriceSourceId, PriceObject = p }; var tradedOnProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>); var priceSourceIdProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>); var tickerProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>); var paramExpression = Expression.Parameter(typeof(TestData)); Expression wholeClause = null; foreach (var td in TestData) { var elementClause = Expression.AndAlso( Expression.Equal( Expression.MakeMemberAccess( paramExpression, tradedOnProperty), Expression.Constant(td.TradedOn) ), Expression.AndAlso( Expression.Equal( Expression.MakeMemberAccess( paramExpression, priceSourceIdProperty), Expression.Constant(td.PriceSourceId) ), Expression.Equal( Expression.MakeMemberAccess( paramExpression, tickerProperty), Expression.Constant(td.Ticker)) )); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wholeClause == null) wholeClause = elementClause; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> wholeClause = Expression.OrElse(wholeClause, elementClause); } var query = baseQuery.Where( (Expression&lt;Func&lt;TestData, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt;)Expression.Lambda( wholeClause, paramExpression)).Select(x =&gt; x.PriceObject); result.AddRange(query); }</code> </pre> </div></div><br><p> 事实证明，该代码比以前的方法更复杂。 手动构建<em>Expression</em>不是最简单，最快的操作。 </p><br><p> 指标： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/312/373/4fc/3123734fc82c4fc4d783f4f9ce2cf225.png" alt="图片"></p><br><p> 临时结果甚至比以前的方法差。 看起来，在构造过程中以及在穿过树时的开销远远大于使用一个请求所带来的收益。 </p><br><h4 id="sposob-5-shared-query-data-table"> 方法5：共享查询数据表 </h4><br><p> 让我们尝试另一个选择： <br> 我在数据库中创建了一个新表，在其中将写入完成请求所需的数据（这意味着在上下文中我需要一个新的<em>DbSet</em> ）。 </p><br><p> 现在，要获得结果，您需要： </p><br><ol><li> 开始交易 </li><li> 将查询数据上传到新表 </li><li> 运行查询本身（使用新表） </li><li> 回滚事务（清除数据表以进行查询） </li></ol><br><p> 代码如下： </p><br><div class="spoiler">  <b class="spoiler_title">方法5的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { context.Database.BeginTransaction(); var reducedData = TestData.Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedQueryModel() { PriceSourceId = x.PriceSourceId, Ticker = x.Ticker, TradedOn = x.TradedOn }).ToList(); <span class="hljs-comment"><span class="hljs-comment">//      context.QueryDataShared.AddRange(reducedData); context.SaveChanges(); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in context.QueryDataShared on new { s.Ticker, p.TradedOn, p.PriceSourceId } equals new { t.Ticker, t.TradedOn, t.PriceSourceId } select p; result.AddRange(query); context.Database.RollbackTransaction(); }</span></span></code> </pre> </div></div><br><p> 第一指标： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df0/ab7/d7d/df0ab7d7d01b0aeaeebf2b9a41f5e75b.png" alt="图片"></p><br><p> 所有测试都有效并且很快！ 内存消耗也是可以接受的。 <br> 因此，通过使用事务，该表可以被多个进程同时使用。 由于这是一个真实存在的表，因此我们可以使用<em>Entity Framework的</em>所有功能：您只需将数据加载到表中，使用<em>JOIN</em>生成查询并执行它。 乍一看，这是您所需要的，但是有很多缺点： </p><br><ul><li> 您必须为特定类型的查询创建表 </li><li> 有必要使用事务（并浪费事务上的DBMS资源） </li><li> 而且，当您需要阅读时，您需要写一些东西的想法看起来很奇怪。 在只读副本上，它将无法正常工作。 <br> 其余的是或多或少可以使用的解决方案。 </li></ul><br><h4 id="sposob-6-memoryjoin-extension"> 方法6。MemoryJoin扩展 </h4><br><p> 现在，您可以尝试改进以前的方法。 这些想法是： </p><br><ul><li> 您可以使用一些通用选项来代替使用特定于一种查询类型的表。 即，创建一个具有诸如<em>shared_query_data之</em>类的名称的表，并向其中添加几个<em>Guid</em>字段，几个<em>Long</em> ，几个<em>String</em>等。 可以采用简单的名称： <em>Guid1</em> ， <em>Guid2</em> ， <em>String1</em> ， <em>Long1</em> ， <em>Date2</em>等。 然后，该表可用于95％的查询类型。 稍后可以使用“ <strong>选择”</strong>透视图“调整”属性名称。 </li><li> 接下来，您需要为<em>shared_query_data</em>添加一个<em>DbSet</em> 。 </li><li> 但是，如果不是使用<strong>VALUES</strong>构造传递值，而不是将数据写入数据库，该怎么办？ 也就是说，有必要在最终的SQL查询中，而不是访问<em>shared_query_data，应该</em>吸引<strong>VALUES</strong> 。 怎么做？ <br><ul><li> 在Entity Framework Core中-仅使用<em>FromSql</em> 。 </li><li> 在Entity Framework 6中-您必须使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DbInterception-</a>也就是说，通过在执行之前添加<strong>VALUES</strong>构造来更改生成的SQL。 这将导致限制：在一个请求中，最多只能有一个<strong>VALUES</strong>构造。 但这会起作用！ </li></ul></li><li> 由于我们不打算写数据库，因此我们在<em>第一步</em>中创建了<em>shared_query_data</em>表，是否根本不需要它？ 答：是的，它不是必需的，但仍然需要<em>DbSet</em> ，因为实体框架必须知道数据方案才能构建查询。 事实证明，对于某些通用模型，我们需要一个<em>DbSet</em> ，该模型在数据库中不存在，仅用于激发实体框架，它知道它在做什么。 </li></ul><br><div class="spoiler">  <b class="spoiler_title">将IEnumerable转换为IQueryable示例</b> <div class="spoiler_text"><ol><li> 输入接收到以下类型的对象的集合： <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeQueryData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Ticker {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTimeTradedOn {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PriceSourceId {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} }</code> </pre> </li><li> 我们可以使用字段<em>String1</em> ， <em>String2</em> ， <em>Date1</em> ， <em>Long1</em> <em>等</em> <em>DbSet</em> </li><li> 让<em>代码</em>行存储在<em>String1</em> ， <em>Date1</em>的<em>TradedOn</em>以及<em>Long1的PriceSourceId</em>中（ <em>int</em>映射为<em>long</em> ，以便不将<em>int</em>和<em>long的</em>字段分开） </li><li> 然后， <em>FromSql</em> + <em>VALUES</em>将如下所示： <br><pre> <code class="cpp hljs">var query = context.QuerySharedData.FromSql( <span class="hljs-string"><span class="hljs-string">"SELECT * FROM ( VALUES (1, 'Ticker1', @date1, @id1), (2, 'Ticker2', @date2, @id2) ) AS __gen_query_data__ (id, string1, date1, long1)"</span></span>)</code> </pre> </li><li> 现在，您可以进行投影并使用与输入相同的类型返回一个方便的<em>IQueryable</em> ： <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> query.Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeQueryData() { Ticker = x.String1, TradedOn = x.Date1, PriceSourceId = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x.Long1 });</code> </pre> </li></ol></div></div><br><p> 我设法实现了这种方法，甚至将其设计为NuGet包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EntityFrameworkCore.MemoryJoin</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a>也可用）。 尽管名称中包含单词<em>Core</em> ，但也支持<em>Entity Framework</em> 6。 我将其称为<strong>MemoryJoin</strong> ，但实际上它会将本地数据发送到<em>VALUES</em>构造中的DBMS，并且所有工作都在此完成。 </p><br><p> 代码如下： </p><br><div class="spoiler">  <b class="spoiler_title">方法6的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { <span class="hljs-comment"><span class="hljs-comment">// :    ,      var reducedData = TestData.Select(x =&gt; new { x.Ticker, x.TradedOn, x.PriceSourceId }).ToList(); //  IEnumerable&lt;&gt;   IQueryable&lt;&gt; var queryable = context.FromLocalList(reducedData); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in queryable on new { s.Ticker, p.TradedOn, p.PriceSourceId } equals new { t.Ticker, t.TradedOn, t.PriceSourceId } select p; result.AddRange(query); }</span></span></code> </pre> </div></div><br><p> 指标： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a7/d72/bb2/6a7d72bb265d9dedbc8e54d94fe16a4f.png" alt="图片"></p><br><p> 这是我尝试过的最好结果。 该代码非常简单明了，并且同时适用于只读副本。 </p><br><div class="spoiler">  <b class="spoiler_title">生成的用于接收3个元素的请求的示例</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"ClosePrice"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"OpenPrice"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"Price"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-string"><span class="hljs-string">"Security"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"s"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span> = <span class="hljs-string"><span class="hljs-string">"s"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"string1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"date1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"long1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> int4) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, @__gen_q_p0, @__gen_q_p1, @__gen_q_p2), (<span class="hljs-number"><span class="hljs-number">2</span></span>, @__gen_q_p3, @__gen_q_p4, @__gen_q_p5), (<span class="hljs-number"><span class="hljs-number">3</span></span>, @__gen_q_p6, @__gen_q_p7, @__gen_q_p8) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> __gen_query_data__ (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, string1, date1, long1) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"x"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"t"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ((<span class="hljs-string"><span class="hljs-string">"s"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span> = <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (<span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> = <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>)</code> </pre> <br><p> 在这里，您还可以看到使用Select的广义模型（具有<em>String1</em> ， <em>Date1</em> ， <em>Long1</em>字段）如何变成代码中使用的模型（具有<em>Ticker</em> ， <em>TradedOn</em> ， <em>PriceSourceId</em>字段）。 </p></div></div><br><p> 所有工作都在SQL服务器上的1个查询中完成。 这是一个小小的幸福结局，我在开始时就谈到了。 但是，使用此方法需要了解并执行以下步骤： </p><br><ul><li> 您需要在上下文中添加一个额外的<em>DbSet</em> （尽管表本身可以<em>省略</em> ） </li><li> 在默认情况下使用的通用模型中，声明了类型为<em>Guid</em> ， <em>String</em> ， <em>Double</em> ， <em>Long</em> ， <em>Date</em>等的3个字段。 对于95％的请求类型，这应该足够了。 并且，如果将具有20个字段的对象的集合传递给<em>FromLocalList</em> ，则将引发<em>Exception</em> ，表示该对象太复杂。 这是一个软限制，可以绕开-您可以声明类型并在其中添加至少100个字段。 但是，更多字段的工作速度较慢。 </li><li> 我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>中介绍了更多技术细节。 </li></ul><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 在本文中，我介绍了有关JOIN本地集合和DbSet的想法。 在我看来，使用<em>VALUES</em>进行开发可能会引起社区的兴趣。 当我自己解决这个问题时，至少我没有遇到这种方法。 就个人而言，这种方法可以帮助我克服当前项目中的许多性能问题，也许对您也有帮助。 </p><br><p> 有人会说<em>MemoryJoin</em>的使用过于“ <em>抽象</em> ”，需要进一步开发，在此之前，您不需要使用它。 这正是我非常怀疑的原因，并且近一年来我都没有写这篇文章。 我同意我希望它更轻松地工作（希望有一天能做到），但是我也要说，优化从来都不是Junior的任务。 优化始终需要了解工具的工作方式。 如果有机会获得约8倍的加速（ <em>Naive Parallel</em> vs <em>MemoryJoin</em> ），那么我将掌握2分和文档。 </p><br><p> 最后，这些图： </p><br><p> 花时间。 在不到10分钟的时间内只有4种方法完成了任务，而<em>MemoryJoin</em>是在不到10秒的时间内完成任务的唯一方法。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/720/256/846/72025684620477d221c0f113a6cb354f.png" alt="图片"></p><br><p> 内存消耗。 除了<em>Multiple Contains</em>之外，所有方法都显示出大致相同的内存消耗。 这是由于返回的数据量。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e07/a91/b63/e07a91b63375d49a21adb81e8213ffdb.png" alt="图片"></p><br><p> 感谢您的阅读！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435810/">https://habr.com/ru/post/zh-CN435810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435798/index.html">索尼WH-1000XM3-最好的无线耳机？</a></li>
<li><a href="../zh-CN435800/index.html">十进制字母11</a></li>
<li><a href="../zh-CN435802/index.html">OpenVPN，您对此了解甚少</a></li>
<li><a href="../zh-CN435804/index.html">重新启动后，英特尔Cyclone不会保存配置</a></li>
<li><a href="../zh-CN435806/index.html">日本宣布心脏生物工程学的临床试验</a></li>
<li><a href="../zh-CN435812/index.html">幸福理论。 统计是一无所知的科学方法</a></li>
<li><a href="../zh-CN435814/index.html">[旧事物]我可以随便使用我的堆栈吗？</a></li>
<li><a href="../zh-CN435816/index.html">马萨诸塞州医院和DeepMind分别打开了医学界的AI黑匣子</a></li>
<li><a href="../zh-CN435822/index.html">如何使用声音控制数据中心的硬件</a></li>
<li><a href="../zh-CN435824/index.html">在从事音频行业之前需要了解的内容</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>