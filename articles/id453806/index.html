<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚾️ 👩🏻‍🎓 🐎 Penanganan Kesalahan saat Go 🗽 👨‍🎤 👫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, warga Habrovsk! Kursus Pengembang Golang sudah dimulai di OTUS hari ini , dan kami menganggap ini kesempatan yang bagus untuk berbagi pos lain y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penanganan Kesalahan saat Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453806/">  Halo, warga Habrovsk!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kursus Pengembang Golang</a> sudah dimulai di OTUS hari ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> dan kami menganggap ini kesempatan yang bagus untuk berbagi pos lain yang bermanfaat tentang topik tersebut.  Hari ini mari kita bicara tentang pendekatan Go untuk kesalahan.  Ayo mulai! <br><br><img src="https://habrastorage.org/webt/mr/8i/ch/mr8ichd887jvkbuzbf3dh_h5oc0.png"><br><br><h3>  Menguasai penanganan kesalahan pragmatis dalam kode Go Anda </h3><br><img src="https://habrastorage.org/webt/gp/i3/ff/gpi3ffckknhyvkcqyfyk1dnbltc.png"><br><br>  <i>Posting ini adalah bagian dari seri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sebelum</a> Memulai, di mana kami menjelajahi dunia Golang, berbagi kiat dan ide yang harus Anda ketahui saat menulis kode di Go sehingga Anda tidak perlu mengisi benjolan Anda sendiri.</i> <br><br>  Saya berasumsi bahwa Anda sudah memiliki setidaknya pengalaman dasar dengan Go, tetapi jika Anda merasa bahwa pada suatu saat Anda menemukan bahan diskusi yang tidak dikenal, jangan ragu untuk berhenti sebentar, jelajahi topiknya dan kembali. <br><br>  Sekarang setelah kita membersihkan jalan kita, ayo pergi! <a name="habracut"></a><br><br>  Pendekatan Go untuk penanganan kesalahan adalah salah satu fitur yang paling kontroversial dan disalahgunakan.  Dalam artikel ini, Anda akan mempelajari pendekatan Go untuk kesalahan, dan memahami cara kerjanya "di bawah tenda."  Anda akan mempelajari beberapa pendekatan berbeda, lihat kode sumber Go dan perpustakaan standar untuk mengetahui bagaimana kesalahan ditangani dan bagaimana cara mengatasinya.  Anda akan belajar mengapa Ketegasan Jenis memainkan peran penting dalam menanganinya, dan Anda akan melihat perubahan mendatang untuk penanganan kesalahan yang Anda rencanakan untuk diperkenalkan di Go 2. <br><br><img src="https://habrastorage.org/webt/e3/0t/gk/e30tgk9zbbofawpffxugwstrhow.png"><br><br><h2>  Entri </h2><br>  Hal pertama yang pertama: kesalahan di Go tidak terkecuali.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dave Cheney</a> menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting blog epik</a> tentang ini, jadi saya merujuk Anda untuk itu dan meringkas: dalam bahasa lain Anda tidak dapat memastikan apakah suatu fungsi dapat melempar pengecualian atau tidak.  Alih-alih melempar pengecualian, fungsi Go mendukung <b>beberapa nilai pengembalian</b> , dan dengan konvensi fitur ini biasanya digunakan untuk mengembalikan hasil fungsi bersama dengan variabel kesalahan. <br><br><img src="https://habrastorage.org/webt/p5/nl/dw/p5nldwpihop5qjmlgz4f0h0v_yi.png"><br><br>  Jika karena alasan tertentu fungsi Anda mungkin gagal, Anda mungkin harus mengembalikan jenis <code>error</code> dinyatakan sebelumnya dari itu.  Dengan konvensi, mengembalikan kesalahan memberi sinyal kepada penelepon tentang masalah tersebut, dan mengembalikan nol tidak dianggap sebagai kesalahan.  Dengan demikian, Anda akan membuat penelepon memahami bahwa masalah telah muncul, dan dia perlu mengatasinya: siapa pun yang memanggil fungsi Anda, ia tahu bahwa ia tidak boleh mengandalkan hasil sebelum memeriksa kesalahan.  Jika kesalahan tidak nihil, ia berkewajiban untuk memeriksa dan memprosesnya (mencatat, mengembalikan, memelihara, memanggil beberapa jenis coba lagi / mekanisme pembersihan, dll.). <br><br><img src="https://habrastorage.org/webt/l2/u-/05/l2u-05npjr4ptcwn7woqyb20usg.png"><br>  <i>(3 // penanganan kesalahan</i> <i><br></i>  <i>5 // lanjutan)</i> <br><br>  Cuplikan ini sangat umum di Go, dan beberapa menganggapnya sebagai kode boilerplate.  Kompiler memperlakukan variabel yang tidak digunakan sebagai kesalahan kompilasi, jadi jika Anda tidak akan memeriksa kesalahan, Anda harus menetapkannya ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengidentifikasi kosong</a> .  Tapi betapapun nyamannya, kesalahan tidak boleh diabaikan. <br><br><img src="https://habrastorage.org/webt/fm/pq/rv/fmpqrvcl6_eh4tvwhq0ebxmd4qo.png"><br>  <i>(4 // mengabaikan kesalahan tidak aman, dan Anda tidak boleh mengandalkan hasilnya sebelum memeriksa kesalahan)</i> <br>  <i><b>hasilnya tidak dapat dipercaya sampai memeriksa kesalahan</b></i> <br><br>  Kesalahan kembali bersama dengan hasilnya, bersama dengan sistem tipe Go ketat, sangat menyulitkan penulisan kode tag.  Anda harus selalu berasumsi bahwa nilai fungsi rusak, kecuali jika Anda telah memeriksa kesalahan yang dikembalikan, dan dengan menetapkan kesalahan ke pengidentifikasi kosong, Anda secara eksplisit mengabaikan bahwa nilai fungsi Anda mungkin rusak. <br><br><img src="https://habrastorage.org/webt/lm/xj/uh/lmxjuhxt8v8sdvillwvsbbuct5o.png"><br>  <b><i>ID kosong gelap dan penuh kengerian.</i></b> <br><br>  Go memang memiliki mekanisme <code>panic</code> dan <code>recover</code> , yang juga dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting blog Go yang detail lainnya</a> .  Tetapi mereka tidak dimaksudkan untuk mensimulasikan pengecualian.  Menurut Dave, <i>"Ketika kamu panik di Go, kamu benar-benar panik: ini bukan masalah orang lain, ini sudah seorang gamer."</i>  Mereka berakibat fatal dan menyebabkan crash pada program Anda.  Rob Pike datang dengan mengatakan "Jangan panik," yang berbicara sendiri: Anda mungkin harus menghindari mekanisme ini dan mengembalikan kesalahan sebagai gantinya. <br><br><blockquote>  "Kesalahan adalah artinya." <br>  "Jangan hanya memeriksa kesalahan, tapi tangani dengan elegan." <br>  "Jangan panik" <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semua ucapan Rob Pike</a> <br></blockquote><br><h2>  Di bawah tenda </h2><br>  <b>Antarmuka galat</b> <br><br>  Di bawah tenda, jenis kesalahan adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka sederhana dengan satu metode</a> , dan jika Anda tidak terbiasa dengan itu, saya sangat merekomendasikan melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting ini</a> di blog Go resmi. <br><br><img src="https://habrastorage.org/webt/n_/c3/ip/n_c3iptfnwohofkgwwhhxc-cwda.png"><br>  <b><i>antarmuka kesalahan dari sumber</i></b> <br><br>  Membuat kesalahan sendiri tidak sulit.  Ada berbagai pendekatan untuk struktur pengguna yang menerapkan metode <code>string</code> <code>Error()</code> .  Setiap struktur yang mengimplementasikan metode tunggal ini dianggap sebagai nilai kesalahan yang valid dan dapat dikembalikan seperti itu. <br><br>  Mari kita lihat beberapa pendekatan ini. <br><br><h3>  Struktur errorString bawaan </h3><br>  Implementasi antarmuka kesalahan yang paling umum digunakan dan tersebar luas adalah struktur <code>errorString</code> .  Ini adalah implementasi termudah yang dapat Anda pikirkan. <br><br><img src="https://habrastorage.org/webt/uv/hj/by/uvhjbyzjh8cmovqpjdkda0ww5_c.png"><br>  Sumber: <a href="">Go source code</a> <br><br>  Anda dapat melihat implementasinya yang disederhanakan di <a href="">sini</a> .  Yang dilakukannya hanyalah berisi <code>string</code> , dan string ini dikembalikan oleh metode <code>Error</code> .  Kesalahan string ini dapat diformat oleh kami berdasarkan beberapa data, katakanlah, menggunakan <code>fmt.Sprintf</code> .  Tapi selain itu, tidak mengandung fitur lain.  Jika Anda menerapkan <a href="">kesalahan. Baru</a> atau <a href="">fmt.Errorf</a> , maka Anda sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakannya</a> . <br><br><img src="https://habrastorage.org/webt/br/6h/g5/br6hg5p3lozppuf98ry0g2ptsw4.png"><br>  <i>(13 // output :)</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">coba</a> <br><br><h3>  github.com/pkg/errors </h3><br>  Contoh sederhana lainnya adalah paket <a href="">pkg / kesalahan</a> .  Tidak perlu bingung dengan paket <code>errors</code> bawaan yang Anda pelajari sebelumnya, paket ini menyediakan fitur-fitur penting tambahan, seperti pembungkus kesalahan, ekspansi, pemformatan, dan perekaman jejak jejak.  Anda dapat menginstal paket dengan menjalankan <code>go get github.com/pkg/errors</code> . <br><br><img src="https://habrastorage.org/webt/bo/vs/f7/bovsf7dn4l2gvaesqbepogmjxrw.png"><br><br>  Dalam kasus di mana Anda perlu melampirkan jejak tumpukan atau informasi debug yang diperlukan untuk kesalahan Anda, menggunakan fungsi <code>New</code> atau <code>Errorf</code> paket ini memberikan kesalahan yang sudah ditulis ke jejak tumpukan Anda, dan Anda juga dapat melampirkan metadata sederhana menggunakannya kemampuan memformat.  <code>Errorf</code> mengimplementasikan antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fmt.Formatter</a> , mis. Anda dapat memformatnya menggunakan rune dari paket <code>fmt</code> ( <code>%s</code> , <code>%v</code> , <code>%+v</code> , dll.). <br><br><img src="https://habrastorage.org/webt/tz/r6/if/tzr6if2llu8ayda0lrnl1zblkju.png"><br>  <i>(// 6 atau alternatif)</i> <br><br>  Paket ini juga memperkenalkan fungsi <code>errors.Wrap</code> dan <code>errors.Wrapf</code> .  Fungsi-fungsi ini menambah konteks kesalahan menggunakan pesan dan jejak tumpukan di tempat mereka dipanggil.  Jadi, alih-alih mengembalikan kesalahan, Anda bisa membungkusnya dengan konteks dan data debug penting. <br><br><img src="https://habrastorage.org/webt/pa/pz/3t/papz3tu-dlhtdcb4r8lmldfxazu.png"><br><br>  Pembungkus kesalahan oleh kesalahan lain mendukung metode <code>Cause() error</code> , yang mengembalikan kesalahan internal mereka.  Selain itu, mereka dapat digunakan dengan fungsi <code>errors.Cause(err error) error</code> , yang mengekstrak kesalahan internal utama dalam kesalahan pembungkus. <br><br><h2>  Menangani kesalahan </h2><br><h3>  Ketikkan persetujuan </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ketik</a> asersi memainkan peran penting ketika berhadapan dengan kesalahan.  Anda akan menggunakannya untuk mengekstraksi informasi dari nilai antarmuka, dan karena penanganan kesalahan dikaitkan dengan implementasi pengguna dari antarmuka <code>error</code> , penerapan pernyataan <code>error</code> adalah alat yang sangat nyaman. <br><br>  Sintaksnya sama untuk semua keperluannya - <code>x.(T)</code> jika <code>x</code> memiliki tipe antarmuka.  <code>x.(T)</code> menyatakan bahwa <code>x</code> tidak <code>nil</code> dan bahwa nilai yang disimpan dalam <code>x</code> adalah tipe <code>T</code>  Dalam beberapa bagian berikutnya, kita akan melihat dua cara untuk menggunakan pernyataan tipe - dengan tipe <code>T</code> tertentu dan dengan antarmuka tipe <code>T</code> <br><br><img src="https://habrastorage.org/webt/tb/fd/e2/tbfde2ne-8parkmkbsthfamc_ym.png"><br>  <i>(2 // steno sintaks melewatkan variabel boolean ok</i> <i><br></i>  <i>3 // panik: konversi antarmuka: antarmuka {} adalah nihil, bukan string</i> <i><br></i>  <i>6 // sintaks yang diperluas dengan boolean ok</i> <i><br></i>  <i>8 // tidak panik, sebaliknya set ok false ketika pernyataan itu salah</i> <i><br></i>  <i>9 // sekarang kita bisa menggunakan s sebagai string dengan aman)</i> <br><br>  <b><i>sandbox: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panik dengan sintaks yang diperpendek</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sintaks yang diperluas aman</a></i></b> <br><br><blockquote>  <i>Catatan sintaks tambahan: pernyataan tipe dapat digunakan baik dengan sintaks singkat (yang panik ketika pernyataan gagal) atau sintaks diperpanjang (yang menggunakan nilai logis OK untuk menunjukkan keberhasilan atau kegagalan).</i>  <i>Saya selalu merekomendasikan mengambil memanjang bukannya diperpendek, karena saya lebih suka memeriksa variabel OK, dan tidak berurusan dengan panik.</i> </blockquote><br><br><h3>  Persetujuan Tipe T </h3><br>  Pernyataan tipe <code>x.(T)</code> dengan antarmuka tipe <code>T</code> mengonfirmasi bahwa <code>x</code> mengimplementasikan antarmuka <code>T</code>  Dengan demikian, Anda dapat menjamin bahwa nilai antarmuka mengimplementasikan antarmuka, dan hanya jika demikian, Anda dapat menggunakan metode-metodenya. <br><br><img src="https://habrastorage.org/webt/jl/ps/k7/jlpsk7f8m1bj-7jhwbgmzigsqea.png"><br>  <i>(5 ... // klaim bahwa x mengimplementasikan antarmuka resolver</i> <i><br></i>  <i>6 ... // di sini kita sudah bisa menggunakan metode ini dengan aman)</i> <br><br>  Untuk memahami bagaimana ini dapat digunakan, mari kita lihat lagi <code>pkg/errors</code> .  Anda sudah mengetahui paket kesalahan ini, jadi mari kita <code>errors.Cause(err error) error</code> fungsi <code>errors.Cause(err error) error</code> . <code>errors.Cause(err error) error</code> . <br><br>  Fungsi ini menerima kesalahan dan mengekstrak kesalahan paling dalam yang dideritanya (salah satu yang tidak lagi berfungsi sebagai pembungkus untuk kesalahan lain).  Ini mungkin terlihat primitif, tetapi ada banyak hal hebat yang dapat Anda pelajari dari implementasi ini: <br><br><img src="https://habrastorage.org/webt/kj/uy/rm/kjuyrm3rxxgtqt-8a6_cd1bvsqg.png"><br>  sumber: <a href="">pkg / kesalahan</a> <br><br>  Fungsi menerima nilai kesalahan, dan tidak dapat mengasumsikan bahwa argumen <code>err</code> yang diterimanya adalah kesalahan pembungkus (didukung oleh metode <code>Cause</code> ).  Karena itu, sebelum memanggil metode <code>Cause</code> , Anda harus memastikan bahwa Anda berurusan dengan kesalahan yang mengimplementasikan metode ini.  Dengan melakukan pernyataan tipe di setiap iterasi dari for loop, Anda dapat memastikan bahwa variabel <code>cause</code> mendukung metode <code>Cause</code> , dan dapat terus mengekstrak kesalahan internal hingga Anda menemukan kesalahan yang tidak memiliki <code>Cause</code> . <br><br>  Dengan membuat antarmuka lokal sederhana yang hanya berisi metode-metode yang Anda butuhkan, dan menerapkan pernyataan tegas, kode Anda dipisahkan dari dependensi lainnya.  Argumen yang Anda terima tidak harus menjadi struktur yang diketahui, itu hanya harus menjadi kesalahan.  Jenis apa pun yang mengimplementasikan metode <code>Error</code> dan <code>Cause</code> akan dilakukan.  Dengan demikian, jika Anda menerapkan metode <code>Cause</code> dalam jenis kesalahan Anda, Anda dapat menggunakan fungsi ini tanpa memperlambat. <br><br>  Namun, ada satu kelemahan kecil yang perlu diingat: antarmuka dapat berubah, jadi Anda harus hati-hati menjaga kode sehingga pernyataan Anda tidak dilanggar.  Jangan lupa untuk mendefinisikan antarmuka Anda di mana Anda menggunakannya, untuk membuatnya tetap ramping dan rapi, dan Anda akan baik-baik saja. <br><br>  Akhirnya, jika Anda hanya membutuhkan satu metode, terkadang lebih mudah untuk membuat pernyataan pada antarmuka anonim yang hanya berisi metode yang Anda andalkan, yaitu <code>v, ok := x.(interface{ F() (int, error) })</code> .  Menggunakan antarmuka anonim dapat membantu memisahkan kode Anda dari kemungkinan dependensi dan melindunginya dari kemungkinan perubahan pada antarmuka. <br><br><h3>  Tipe T dan Persetujuan Tipe Switch </h3><br><br>  Saya mengawali bagian ini dengan memperkenalkan dua pola penanganan kesalahan serupa yang menderita beberapa kekurangan dan perangkap.  Ini tidak berarti bahwa mereka tidak umum.  Keduanya dapat menjadi alat yang mudah digunakan dalam proyek-proyek kecil, tetapi mereka tidak skala dengan baik. <br><br>  Yang pertama adalah versi kedua dari pernyataan tipe: pernyataan tipe <code>x.(T)</code> dengan tipe <code>T</code> tertentu dilakukan.  Dia mengklaim bahwa nilai <code>x</code> adalah tipe <code>T</code> , atau dapat dikonversi ke tipe <code>T</code> <br><br><img src="https://habrastorage.org/webt/mh/c5/qy/mhc5qyqfrrnhpct7wyfzhhpflju.png"><br>  <i>(2 // kita bisa menggunakan v sebagai mypkg.SomeErrorType)</i> <br><br>  Lainnya adalah pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Type Switch</a> .  Tipe Switch menggabungkan pernyataan switch dengan pernyataan tipe menggunakan kata kunci <code>type</code> dipesan.  Mereka sangat umum dalam penanganan kesalahan, di mana mengetahui tipe dasar dari kesalahan variabel bisa sangat berguna. <br><br><img src="https://habrastorage.org/webt/on/iz/ji/onizji38uqjzltxqord4icmmvoq.png"><br>  <i>(3 // memproses ...</i> <i><br></i>  <i>5 // memproses ...)</i> <br><br>  Kelemahan besar dari kedua pendekatan ini adalah keduanya mengarah pada pengikatan kode dengan dependensi mereka.  Kedua contoh harus terbiasa dengan struktur <code>SomeErrorType</code> (yang jelas harus diekspor) dan harus mengimpor paket <code>mypkg</code> . <br>  Dalam kedua pendekatan, saat menangani kesalahan Anda, Anda harus terbiasa dengan jenis dan mengimpor paketnya.  Situasi bertambah buruk ketika Anda berurusan dengan kesalahan dalam pembungkus, di mana penyebab kesalahan mungkin kesalahan yang timbul dari ketergantungan internal yang Anda tidak tahu dan tidak perlu tahu. <br><br><img src="https://habrastorage.org/webt/vz/xz/zq/vzxzzqe6qajcsroflsuy0mjt5jk.png"><br>  <i>(7 // memproses ...</i> <i><br></i>  <i>9 // memproses ...)</i> <br><br>  Jenis Switch membedakan antara <code>*MyStruct</code> dan <code>MyStruct</code> .  Oleh karena itu, jika Anda tidak yakin apakah Anda berurusan dengan pointer atau contoh aktual dari suatu struktur, Anda harus memberikan kedua opsi.  Selain itu, seperti dalam kasus switch biasa, kasus-kasus di Type Switch tidak gagal, tetapi tidak seperti Switch Type biasa, penggunaan <code>fallthrough</code> dilarang di Type Switch, jadi Anda harus menggunakan koma dan memberikan kedua opsi, yang mudah dilupakan. <br><br><img src="https://habrastorage.org/webt/pe/1y/g7/pe1yg7one8orth5kvcdguqtpteo.png"><br><br><h2>  Untuk meringkas </h2><br>  Itu saja!  Anda sekarang terbiasa dengan kesalahan dan harus siap untuk memperbaiki kesalahan yang aplikasi Go Anda dapat melempar (atau benar-benar kembali) ke jalan Anda! <br>  Kedua paket <code>errors</code> menyediakan pendekatan sederhana namun penting untuk kesalahan di Go, dan jika mereka memenuhi kebutuhan Anda, mereka adalah pilihan yang bagus.  Anda dapat dengan mudah mengimplementasikan struktur kesalahan Anda sendiri dan memanfaatkan penanganan kesalahan Go dengan menggabungkannya dengan <code>pkg/errors</code> . <br><br>  Saat Anda skala kesalahan sederhana, penggunaan yang benar dari pernyataan tipe bisa menjadi alat yang hebat untuk menangani berbagai kesalahan.  Baik menggunakan Type Switch, atau dengan memvalidasi perilaku kesalahan dan memeriksa antarmuka yang diterapkannya. <br><br><h2>  Apa selanjutnya </h2><br>  Penanganan kesalahan di Go sekarang sangat relevan.  Sekarang setelah Anda memiliki dasar-dasarnya, Anda mungkin bertanya-tanya apa yang ada di depan bagi kami untuk menangani kesalahan Go! <br><br>  Versi Go 2 berikutnya sangat memperhatikan hal ini, dan Anda sudah dapat melihat <a href="">versi draft</a> .  Selain itu, selama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotGo 2019,</a> Marcel van Lojuizen melakukan percakapan luar biasa tentang topik yang saya tidak bisa merekomendasikan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Nilai kesalahan GO 2 hari ini"</a> . <br><br>  Jelas, ada banyak lagi pendekatan, tips dan trik, dan saya tidak bisa memasukkan semuanya dalam satu posting!  Meskipun demikian, saya harap Anda menikmatinya, dan saya akan melihat Anda di episode <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sebelum Memulai</a></i> ! <br><br>  Dan sekarang secara tradisional menunggu komentar Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453806/">https://habr.com/ru/post/id453806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453790/index.html">"Klien sudah pergi - apakah selamanya?" Bagaimana cara menghitung churn pelanggan dalam SaaS dan apa yang salah dengan metrik dasar</a></li>
<li><a href="../id453792/index.html">Sistem pemberi rekomendasi: ide, pendekatan, tugas</a></li>
<li><a href="../id453796/index.html">Apakah orang membutuhkan matematika?</a></li>
<li><a href="../id453800/index.html">Cara mengatasi "Minesweeper" (dan membuatnya lebih baik)</a></li>
<li><a href="../id453804/index.html">Buku “Daya Saing dan Konkurensi pada Platform .NET. Pola Desain yang Efektif ”</a></li>
<li><a href="../id453808/index.html">Kami membongkar model bisnis Viking</a></li>
<li><a href="../id453810/index.html">Umpan balik biometrik</a></li>
<li><a href="../id453812/index.html">Tema, gaya, dan lainnya</a></li>
<li><a href="../id453816/index.html">Tick-borne encephalitis: bahaya yang diabaikan</a></li>
<li><a href="../id453818/index.html">GitLab 11.11: beberapa bertanggung jawab untuk menggabungkan permintaan dan peningkatan untuk kontainer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>