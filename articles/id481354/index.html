<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜüèΩ üÄÑÔ∏è üë©üèª‚Äç‚úàÔ∏è TelegramBot. Fungsionalitas dasar. Terbang secara terpisah, irisan daging secara terpisah. (Bagian 2) ‚ôëÔ∏è üßñ üñäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus mengembangkan fungsionalitas dasar untuk bot di telegram. Di bagian sebelumnya, kami membahas titik bahwa bot bekerja untuk menerima pesan,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TelegramBot. Fungsionalitas dasar. Terbang secara terpisah, irisan daging secara terpisah. (Bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481354/"> Kami terus mengembangkan fungsionalitas dasar untuk bot di telegram.  Di bagian sebelumnya, kami membahas titik bahwa bot bekerja untuk menerima pesan, memproses dan mengirim harus dibagi.  Mari kita coba menggunakan alat Java Core dasar untuk membuat bot kita multithreaded dan asynchronous.  Kami akan datang dengan tugas yang membutuhkan banyak waktu untuk diproses.  Mari kita lihat bagaimana perintah dalam telegram bekerja dan bagaimana mereka perlu diproses. <br><br>  Ini adalah kelanjutan dari bagian pertama artikel tentang pemrograman bot untuk telegram di Jawa <br>  <a href="https://habr.com/ru/post/476306/">Instruksi TelegramBot untuk membuat fungsionalitas dasar untuk bot.</a>  <a href="https://habr.com/ru/post/476306/">(Bagian 1)</a> <br>  Untuk siapa ini lebih menarik, Anda dipersilakan ... <br><a name="habracut"></a><br>  Saya harus mengatakan segera bahwa di bagian ini banyak semuanya ditambahkan sekaligus dan diam-diam kita akan menganalisis semua fungsi yang memungkinkan bot untuk dapat multithread dan mengapa itu diperlukan sama sekali. <br><br>  Seperti biasa dari main: <br>  Anda dapat menemukan semua kode yang sudah jadi untuk artikel ini di cabang <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers" rel="nofollow">Part2-Handlers</a> di repositori git. <br>  Kode berfungsi penuh, cukup untuk miring, mengubah data untuk otorisasi bot (nama dan token) dan menjalankan metode utama di kelas App.class. <br><br>  <i>Harap dicatat bahwa kelas ini mengirimkan pemberitahuan kepada administrator bot ketika bot mulai bahwa bot telah dimulai.</i>  <i>ID admin bot juga ditentukan dalam kelas App.class dan jika Anda tidak mengubahnya, bot Anda akan mencoba mengirim pesan kepada saya :)</i> <br><br>  Dan lebih lanjut tentang poin-poin kami akan menganalisis perubahan-perubahan yang muncul setelah rilis bagian pertama. <br><br><h3>  Pemrosesan perintah </h3><br>  Untuk memulainya, mari kita berurusan dengan konsep ini tentang apa yang tim secara umum dalam sistem untuk berkomunikasi dengan bot telegram.  Bergantung pada pengaturan bot, ia dapat melihat pesan dalam format apa pun atau hanya perintah yang dirancang khusus.  Apa bedanya dan <br>  di mana Anda dapat memenuhi opsi pesan ini. <br><br><ol><li>  <b>Teks biasa, pesan biasa.</b> <br>  Dalam formulir ini, bot menerima pesan saat mereka menulis kepadanya di PM.  Namun, jika dalam pengaturan bot <a href="https://core.telegram.org/bots" rel="nofollow">mode privasi dalam grup</a> dimatikan, bot mulai melihat semua pesan sepenuhnya.  Jika pengaturan ini diaktifkan, saat ditambahkan ke grup, bot hanya melihat perintah yang ditujukan padanya.  Bagaimana mereka terlihat - lihat paragraf kedua </li><li>  <b>Tim yang dirancang khusus</b> <br>  Perintah seperti itu selalu dimulai dengan garis miring: <b>/</b> <br>  Setelah itu muncul tim itu sendiri.  Teks perintah harus tanpa spasi.  Contoh: <br>  <b>/ mulai</b> <br>  Dengan perintah ini, setiap pengguna selalu memulai komunikasi dengan bot Anda.  Oleh karena itu, sesuai dengan aturan bentuk yang baik, respons terhadap perintah ini harus ditentukan. <br><img src="https://habrastorage.org/webt/ol/pi/ud/olpiudptbqgig5zhoqzpnpjquyq.png"><br>  Semua perintah yang bot Anda tahu cara bekerja dengannya, disarankan untuk menambah daftar keterampilan dalam pengaturan bot Anda.  Ini semua dilakukan dalam telegram dengan @BotFather. <br><br>  <b>Dengan</b> memanggil perintah <b>/ myBots,</b> pilih bot Anda dan kemudian tombol "Edit Bot" <br>  Anda akan mendapatkan jendela di mana semua parameter bot akan ditampilkan dan kemudian Anda dapat mengkonfigurasi seluruh antarmuka dan menunjukkan perintah mana yang bisa digunakan oleh bot Anda. <br><br><img src="https://habrastorage.org/webt/u6/7o/cl/u67oclalxrv7v3v83h1wzp91gr4.png"><br><br>  Mereka diatur dalam format ini: <br><br><img src="https://habrastorage.org/webt/-a/4x/i-/-a4xi-kqpuxjoielhmog7oh1tom.png"><br><br>  Dan setelah itu, ketika Anda mulai memasukkan perintah ke bot Anda, itu akan menunjukkan bantuan dengan daftar perintah yang terdaftar: <br><br><img src="https://habrastorage.org/webt/hn/yi/wa/hnyiwabkhmbrc7zn0rbuzkfvook.png"><br><br>  Dan ada satu lagi nuansa.  Sebuah grup dapat berisi beberapa bot, dan jika mereka memiliki perintah umum (dan perintah umum akan wajib, mulai dan bantuan yang sama diimplementasikan di sebagian besar bot), maka bagian akan ditambahkan ke perintah itu sendiri, memberi tahu bot yang mana milik perintah ini.  Dan perintahnya akan terlihat seperti ini: <br>  <b>/ start @ test_habr_bot</b> <br></li></ol><br>  Dan sekarang, mengetahui semua nuansa ini, mari kita buat dengan Anda opsi pemrosesan seperti itu yang harus memahami perintah yang dimulai dengan slash dan mengetahui bagaimana membedakan apakah perintah tersebut ditujukan khusus untuk bot Anda atau ke yang lain. <br><br>  Buat paket yang akan berisi kelas yang bertanggung jawab untuk memproses perintah. <br>  <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers/src/main/java/com/example/telegrambot/command" rel="nofollow">paket com.example.telegrambot.command</a> <br><br>  Di kelas Command, kami daftar semua perintah yang bot kami harus bisa mengerti. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Command { NONE, NOTFORME, NOTIFY, START, HELP, ID }</code> </pre> <br>  Seperti yang Anda lihat sebelumnya, saya menunjukkan pada @BotFather bahwa bot saya harus dapat memahami 4 tim.  Ini akan menjadi standar awal dan bantuan.  Kami menambahkan satu id berguna.  Dan satu lagi, beri tahu, yang akan saya bicarakan nanti.  Dan dua tim NONE dan NOTFORME, yang akan memberi tahu kami bahwa pesan teks itu bukan perintah sama sekali, atau perintah ini bukan untuk bot kami. <br><br>  <a href="" rel="nofollow">Tambahkan</a> kelas pembantu lain <a href="" rel="nofollow">ParsedCommand</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.AllArgsConstructor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.Getter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.NoArgsConstructor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.Setter; <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@Setter</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParsedCommand</span></span></span><span class="hljs-class"> </span></span>{ Command command = Command.NONE; String text=<span class="hljs-string"><span class="hljs-string">""</span></span>; }</code> </pre> <br>  Tujuan utamanya adalah untuk menyimpan hasil parsing teks pada objek kelas ini.  Ini hanya akan berisi tim itu sendiri dan semua teks yang datang setelah tim. <br><br>  Dan kami akan menulis kelas terpisah yang akan mem-parsing tim kepada kami.  Kelas <a href="" rel="nofollow">Parser</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javafx.util.Pair; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(Parser.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PREFIX_FOR_COMMAND = <span class="hljs-string"><span class="hljs-string">"/"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String DELIMITER_COMMAND_BOTNAME = <span class="hljs-string"><span class="hljs-string">"@"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String botName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String botName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.botName = botName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ParsedCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParsedCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ String trimText = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) trimText = text.trim(); ParsedCommand result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParsedCommand(Command.NONE, trimText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(trimText)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; Pair&lt;String, String&gt; commandAndText = getDelimitedCommandFromText(trimText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCommand(commandAndText.getKey())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCommandForMe(commandAndText.getKey())) { String commandForParse = cutCommandFromFullText(commandAndText.getKey()); Command commandFromText = getCommandFromText(commandForParse); result.setText(commandAndText.getValue()); result.setCommand(commandFromText); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.setCommand(Command.NOTFORME); result.setText(commandAndText.getValue()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutCommandFromFullText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(DELIMITER_COMMAND_BOTNAME) ? text.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, text.indexOf(DELIMITER_COMMAND_BOTNAME)) : text.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Command </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCommandFromText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ String upperCaseText = text.toUpperCase().trim(); Command command = Command.NONE; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { command = Command.valueOf(upperCaseText); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IllegalArgumentException e) { log.debug(<span class="hljs-string"><span class="hljs-string">"Can't parse command: "</span></span> + text); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> command; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Pair&lt;String, String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDelimitedCommandFromText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String trimText)</span></span></span><span class="hljs-function"> </span></span>{ Pair&lt;String, String&gt; commandText; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (trimText.contains(<span class="hljs-string"><span class="hljs-string">" "</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indexOfSpace = trimText.indexOf(<span class="hljs-string"><span class="hljs-string">" "</span></span>); commandText = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(trimText.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, indexOfSpace), trimText.substring(indexOfSpace + <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> commandText = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(trimText, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> commandText; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCommandForMe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command.contains(DELIMITER_COMMAND_BOTNAME)) { String botNameForEqual = command.substring(command.indexOf(DELIMITER_COMMAND_BOTNAME) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> botName.equals(botNameForEqual); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.startsWith(PREFIX_FOR_COMMAND); } }</code> </pre> <br>  Singkatnya.  Ketika menginisialisasi parser, kita harus memberikan nama bot kita di konstruktor sehingga parser dapat membedakan perintahnya dari orang asing. <br><br>  Nah, kalau begitu kita sebut saja metode publik <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ParsedCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParsedCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span></span></code> </pre> <br>  Untuk yang kami sampaikan teks pesan dalam argumen, dan dia harus mengembalikan perintah kepada kami dan teks pesan datang setelah perintah. <br><br>  Anda dapat melihat bagaimana parser bekerja di <a href="" rel="nofollow">kelas tes</a> . <br><br><h3>  Terbang secara terpisah, irisan daging secara terpisah </h3><br>  Sekarang kita perlu mengajarkan bot kita untuk secara terpisah menerima pesan, memproses dan mengirim tanggapan.  Setelah serangkaian coba-coba, saya sampai pada logika aplikasi ini. <br>  <a href="" rel="nofollow">Bot</a> kelas utama akan bekerja di utas utama aplikasi dan hanya akan sibuk dengan kenyataan bahwa semua pesan yang diterima akan dimasukkan ke dalam antrian khusus dan juga akan menjadi wadah untuk pesan yang kami rencanakan untuk dikirimkan kepada pengguna sebagai tanggapan. <br><br>  Perubahan di kelas ini sangat kecil.  Kami menambahkan dua antrian: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Queue&lt;Object&gt; sendQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentLinkedQueue&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Queue&lt;Object&gt; receiveQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentLinkedQueue&lt;&gt;();</code> </pre><br>  dan sedikit menulis ulang kode fungsi <b>public void onUpdateReceived (Perbarui pembaruan)</b> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdateReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Update update)</span></span></span><span class="hljs-function"> </span></span>{ log.debug(<span class="hljs-string"><span class="hljs-string">"Receive new Update. updateID: "</span></span> + update.getUpdateId()); receiveQueue.add(update); }</code> </pre> <br>  Kenapa begitu  Sekali lagi saya mencoba opsi yang berbeda.  Dan masalah utama multithreading adalah bekerja dengan data bersama.  Dan yang paling penting saya menyukai bagaimana implementasi antrian multi-threaded <b>ConcurrentLinkedQueue &lt;&gt; ()</b> menangani ini. <br>  Dan seperti yang Anda lihat, dalam kedua antrian kami akan menyimpan tipe data Object.  Ini adalah penunjuk lain untuk masa depan.  Dengan demikian, kami tidak terikat pada jenis pesan yang diterima.  Dalam antrian yang masuk, kita dapat menambahkan tidak hanya objek dari jenis Pembaruan, tetapi juga beberapa objek lain yang kita butuhkan. <br><br>  Hal yang sama dengan antrian untuk pengiriman.  Karena kami dapat mengirim berbagai jenis pesan dan tidak memiliki induk yang sama - kami juga menggunakan tipe data umum - Objek. <br>  Jika Anda menjalankan bot dalam formulir ini, itu akan berfungsi, tetapi tidak akan melakukan apa pun.  Dia akan merekam semua pesan yang diterima di log dan dimasukkan ke dalam antrian. <br>  Oleh karena itu, kita memerlukan semacam utas yang akan menerima pesan yang diterima dari antrian dan melakukan beberapa tindakan pada mereka dan menempatkan antrian <b>sendQueue dalam</b> hasil kerjanya. <br><br>  Mari kita buat paket terpisah: <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers/src/main/java/com/example/telegrambot/service" rel="nofollow">layanan</a> dan di dalamnya kita hanya akan memiliki 2 kelas: <br><br>  <b>MessageReciever</b> - penangan pesan yang diterima <br>  <b>MessageSender</b> adalah penangan antrian pesan untuk dikirim ke pengguna. <br><br>  Kami akan mempertimbangkan pekerjaan mereka sedikit lebih rendah, tetapi untuk saat ini, kami akan menjelaskan penggunaannya di <a href="" rel="nofollow">Aplikasi</a> kelas awal kami <br><br>  Setelah bot kami terhubung, kami memulai penangan kami di utas terpisah: <br><br><pre> <code class="java hljs">MessageReciever messageReciever = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageReciever(test_habr_bot); MessageSender messageSender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageSender(test_habr_bot); test_habr_bot.botConnect(); Thread receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(messageReciever); receiver.setDaemon(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); receiver.setName(<span class="hljs-string"><span class="hljs-string">"MsgReciever"</span></span>); receiver.setPriority(PRIORITY_FOR_RECEIVER); receiver.start(); Thread sender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(messageSender); sender.setDaemon(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); sender.setName(<span class="hljs-string"><span class="hljs-string">"MsgSender"</span></span>); sender.setPriority(PRIORITY_FOR_SENDER); sender.start();</code> </pre><br>  Untuk kedua utas, kami menentukan mode Daemon.  Ini diperlukan agar utas dapat berfungsi selama utas utama berjalan dan untuk mengakhiri sendiri segera setelah utas berhenti bekerja. <br><br>  Kami tidak ingin berurusan dengan penangan pesan yang masuk terlebih dahulu - mari kita lihat operasi kelas <a href="" rel="nofollow">MessageSender</a> . <br><br>  Mari kita lihat apa yang bisa dia lakukan dan apa yang dia lakukan: <br><br><ul><li>  Biasanya, ini adalah warisan antarmuka untuk multithreading: <br>  <b>mengimplementasikan runnable</b> <br>  dan implementasi dari fungsi <b>run</b> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Di sini kita memulai infinite loop, yang hanya sibuk dengan fakta bahwa ia memeriksa antrian send dan memanggil perintah send <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object object)</span></span></span></span></code> </pre> <br>  jika sesuatu muncul dalam antrian. <br></li><li>  Di konstruktor kelas, kita melewatkan objek kelas Bot, karena  dari sana kita akan mengambil objek untuk mengirim pesan dan dengannya kita akan mengirimkannya. </li><li>  Metode kirim menentukan jenis pesan yang akan dikirim dan menerapkan perintah yang sesuai. </li></ul><br>  Nah, sekarang mari kita <a href="" rel="nofollow">lihat</a> karya dari kelas <a href="" rel="nofollow">MessageReciever</a> <br><br>  Dia, seperti MessageSender, harus multithreaded, di konstruktor menerima objek Bot kelas, di mana ia akan menerima pesan yang diterima dalam loop tak terbatas, memprosesnya dan menempatkannya dalam antrian untuk mengirim hasil karyanya. <br><br>  Di sini kita menggunakan parser perintah yang dibuat sebelumnya.  Dan kemudian kami menambahkan kemampuan untuk menggunakan berbagai jenis penangan untuk tim kami dan beberapa dari mereka akan kami buat multi-threaded. <br><br>  Siklus kerjanya sangat sederhana: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"[STARTED] MsgReciever. Bot class: "</span></span> + bot); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object = bot.receiveQueue.poll(); object != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; object = bot.receiveQueue.poll()) { log.debug(<span class="hljs-string"><span class="hljs-string">"New object for analyze in queue "</span></span> + object.toString()); analyze(object); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(WAIT_FOR_NEW_MESSAGE_DELAY); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { log.error(<span class="hljs-string"><span class="hljs-string">"Catch interrupt. Exit"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  Periksa antrian.  Jika ada sesuatu, jalankan alat analisa: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object object)</span></span></span></span></code> </pre> <br>  Jika tidak ada apa-apa, kami menunggu. <br><br>  Penganalisa memeriksa jenis objek.  Jika dia tahu cara bekerja dengannya, dia memulai penganalisa berikutnya.  Jika Anda tidak bisa - bersumpah :) <br><br>  Kenapa begitu  Sekali lagi, ini adalah penunjuk untuk masa depan dan, saya harap, saya akan mengungkapkannya di bagian selanjutnya dari seri artikel ini.  Implementasi seperti itu akan memungkinkan kita untuk kemudian membentuk tugas kita sendiri untuk bot, membuat milis, tugas harian.  Untuk ini, penerima harus dapat memproses tidak hanya objek dari jenis Pembaruan, tetapi juga sesuatu dari kita.  Tetapi lebih lanjut tentang itu nanti :) <br><br>  Mari kita pertimbangkan penganalisa untuk tipe Pembaruan secara lebih rinci: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyzeForUpdateType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Update update)</span></span></span><span class="hljs-function"> </span></span>{ Long chatId = update.getMessage().getChatId(); String inputText = update.getMessage().getText(); ParsedCommand parsedCommand = parser.getParsedCommand(inputText); AbstractHandler handlerForCommand = getHandlerForCommand(parsedCommand.getCommand()); String operationResult = handlerForCommand.operate(chatId.toString(), parsedCommand, update); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(operationResult)) { SendMessage message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SendMessage(); message.setChatId(chatId); message.setText(operationResult); bot.sendQueue.add(message); } }</code> </pre> <br>  Ini mendefinisikan ID obrolan.  Mendapat teks pesan.  Menggunakan parser, itu menentukan apakah pesan adalah perintah dan menentukan penangan mana perintah ini harus diproses.  Ini mulai memproses perintah dan jika pemrosesan perintah mengembalikan beberapa teks yang tidak kosong - itu membentuk pesan untuk dikirim ke pengguna dan memasukkannya ke dalam antrian. <br><br>  Dan kemudian Anda harus memiliki pertanyaan: "Penangan seperti apa?".  Tidak ada pembicaraan tentang dia sebelumnya, dan dia tidak disebutkan dalam kode.  Baiklah  Sekarang kita akan menganalisis fungsi ini. <br><br>  Untuk melakukan ini, buat paket terpisah, yang akan menyimpan semua penangan kami.  Sebut saja <a href="https://github.com/dp-ua/TelegramBotBase/tree/Part2-Handlers/src/main/java/com/example/telegrambot/handler" rel="nofollow">pawang</a> <br>  Mari kita membuat kelas abstrak <a href="" rel="nofollow">AbstractHandler</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ Bot bot; AbstractHandler(Bot bot) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bot = bot; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span></span>; }</code> </pre> <br>  Dia akan memiliki konstruktor dasar di mana kita lulus dengan objek Bot mana dia perlu berinteraksi.  Dan fungsi abstrak untuk <b>beroperasi</b> dinyatakan, implementasi yang harus kita daftarkan di ahli waris kelas kita. <br><br>  Dan segera kami akan mengimplementasikan handler yang paling sederhana yang tidak akan melakukan apa-apa dan kami akan menggunakannya ketika kami tidak dapat memahami jenis perintah apa yang diberikan kepada kami dan tidak ada respons yang diperlukan dari bot. <br><br>  <a href="" rel="nofollow">DefaultHandler.java</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(DefaultHandler.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DefaultHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } }</code> </pre> <br>  Bagaimana kita akan menerapkannya dan di mana kita akan mendapatkan hasil pekerjaannya - kita akan menganalisis sedikit kemudian. <br><br>  Baris berikutnya adalah <a href="" rel="nofollow">SystemHandler</a> <br>  Dia akan berurusan dengan perintah dasar, seperti start, help, dan kami juga akan menginstruksikan dia untuk mengeksekusi perintah id <br><br>  Dasarnya terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.Command; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.methods.send.SendMessage; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SystemHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(SystemHandler.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String END_LINE = <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SystemHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ Command command = parsedCommand.getCommand(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (command) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> START: bot.sendQueue.add(getMessageStart(chatId)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HELP: bot.sendQueue.add(getMessageHelp(chatId)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Your telegramID: "</span></span> + update.getMessage().getFrom().getId(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; }</code> </pre> <br>  Anda dapat melihat bagaimana respons terhadap perintah mulai dan bantuan terbentuk dalam kode :) <br>  Kami membentuk pesan teks dan menempatkannya dalam antrian untuk dikirim.  Tentang ini, pekerjaan pawang berhenti.  Siapa dan bagaimana akan mengirim pesan-pesan ini - dia tidak peduli sama sekali. <br>  Dan ingat, saya sebutkan sedikit di atas bahwa sebagai hasil dari handler, ia mengembalikan beberapa data teks.  Dan jika baris ini tidak kosong, kita harus mengirim teks ini kepada pengguna.  Ini persis fungsi yang kami gunakan saat mengerjakan perintah ID: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Your telegramID: "</span></span> + update.getMessage().getFrom().getId();</code> </pre> <br>  Handler akan mengembalikan teks dengan ID pengguna kepada orang yang memanggilnya dan sudah ada pesan yang akan dihasilkan untuk dikirim, yang kemudian akan masuk ke antrian. <br><br>  Dan di awal artikel, saya menyebutkan bahwa kami menerapkan opsi ini untuk memproses pesan dari pengguna yang membutuhkan waktu untuk bekerja.  Dan agar tidak mengganggu penangan kami, kami akan mengalokasikannya dalam aliran terpisah dan membiarkannya melanjutkan bisnisnya tanpa mengganggu sisanya. <br>  Sebagai utas "kelas berat", saya datang dengan perintah notify.  Prinsip pekerjaannya adalah ini. <br><br>  Dengan mengirimkan bot perintah dari form: <br>  <b>/ beri tahu 300</b> <br><br>  Bot harus memberi tahu Anda bahwa tim memahami dan setelah 300 detik ia akan mengirimi Anda pemberitahuan bahwa 300 detik telah berlalu.  Tim ini bahkan mungkin memiliki penggunaan praktis :) <br><br>  Misalnya, Anda membuat pangsit terbakar dan Anda harus menghapusnya setelah 5 menit.  Bot akan melakukan ini dengan sempurna dan akan mengirimkan pemberitahuan kepada Anda dalam obrolan bahwa waktunya sudah habis. <br><br>  Atau mengambil tugas yang lebih serius.  Anda pergi ke pertemuan penting dan Anda tahu bahwa ketika berkomunikasi dengan seseorang, Anda perlu menginterupsi pembicaraan.  Untuk ini, mereka biasanya meminta teman untuk menelepon atau menulis pesan, yang akan menjadi motif untuk tidak mengalihkan perhatian dari percakapan untuk waktu yang lama dan mengambil tindakan.  Tapi mengapa repot-repot teman ketika Anda memiliki bot?  Setelah memintanya tugas terlebih dahulu dan menunjukkan waktu, Anda akan menerima pemberitahuan yang diperlukan di telegram.  Tapi ini semua liriknya.  Tugas dan perintah ini diciptakan hanya untuk menunjukkan kepada Anda bagaimana mengalokasikan dalam aliran terpisah sesuatu yang pekerjaannya dapat memakan waktu yang sangat lama. <br><br>  Jadi, <a href="" rel="nofollow">NotifyHandler</a> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.ability.Notify; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotifyHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(NotifyHandler.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MILLISEC_IN_SEC = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String WRONG_INPUT_MESSAGE = <span class="hljs-string"><span class="hljs-string">"Wrong input. Time must be specified as an integer greater than 0"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NotifyHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ String text = parsedCommand.getText(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(text)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"You must specify the delay time. Like this:\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"/notify 30"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timeInSec; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { timeInSec = Long.parseLong(text.trim()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NumberFormatException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WRONG_INPUT_MESSAGE; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeInSec &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Thread thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notify(bot, chatId, timeInSec * MILLISEC_IN_SEC)); thread.start(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WRONG_INPUT_MESSAGE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } }</code> </pre> <br>  Kami memeriksa apakah waktu tunda diberikan kepada kami dalam teks.  Jika tidak, kami bersumpah.  Jika demikian, kami memulai utas baru, di mana kami melewati pengantar pada instruksi kami.  Tugas ini akan ditangani oleh kelas <a href="" rel="nofollow">Notify yang</a> terpisah. <br>  Fungsionalitasnya sangat sederhana.  Dia tidur jumlah yang ditunjukkan detik.  Tetapi dalam proses tidurnya, bot Anda dapat menerima pesan lain, berkomunikasi dengan Anda, dan meluncurkan pemberitahuan tambahan.  Dan semua ini bekerja secara terpisah satu sama lain. <br><br>  Dan untuk menyelesaikan secara keseluruhan kumpulan ini dengan penangan panggilan, mari kembali ke kelas <a href="" rel="nofollow">MessageReciever</a> kami dan lihat bagaimana kami memahami penangan mana yang kami butuhkan dan bagaimana kami menjalankannya. <br>  Pawang yang diperlukan dikembalikan kepada kami dengan perintah <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> AbstractHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHandlerForCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Command command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { log.warn(<span class="hljs-string"><span class="hljs-string">"Null command accepted. This is not good scenario."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHandler(bot); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (command) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> START: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HELP: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: SystemHandler systemHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemHandler(bot); log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] is: "</span></span> + systemHandler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> systemHandler; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NOTIFY: NotifyHandler notifyHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyHandler(bot); log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] is: "</span></span> + notifyHandler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> notifyHandler; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] not Set. Return DefaultHandler"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHandler(bot); } }</code> </pre> <br>  Sekarang, jika Anda ingin menambahkan beberapa perintah lagi, Anda perlu melakukan hal berikut: <br><br><ol><li>  Di kelas <a href="" rel="nofollow">Command</a> tambahkan sintaks perintah. </li><li>  Di <a href="" rel="nofollow">penerima,</a> dalam fungsi <b>getHandlerForCommand,</b> tentukan siapa yang akan bertanggung jawab untuk memproses perintah ini. </li><li>  Dan benar-benar menulis penangan ini. </li></ol><br>  Saya akan mengatakan sebelumnya bahwa proses penambahan tim baru dapat disederhanakan.  Penangan yang bertanggung jawab dapat didaftarkan segera di kelas dengan daftar perintah.  Tapi saya khawatir kode itu tidak mudah dimengerti.  Teksnya sangat panjang.  Tapi aku tidak bisa mengalahkannya.  Tiga fungsi dasar bot dijelaskan di sini, yang hanya bekerja bersama dan tidak tepat untuk membicarakannya secara terpisah. <br><br>  Apa yang akan kita bicarakan di bagian berikut? <br><br>  Kita perlu memahami cara membentuk berbagai jenis pesan.  Cara bekerja dengan keyboard dan tombol.  Cara mengedit posting lama Anda.  Cara bekerja dengan callback.  Cara memberi tugas kepada bot untuk melakukan beberapa tindakan.  Cara membuat pesan interaktif dengan bot dan banyak lagi.  Semua bagian lebih lanjut terserah Anda dan aktivitas Anda. <br>  Dalam komentar, saya menantikan umpan balik dan arahan Anda, yang akan kami pertimbangkan sebagai prioritas. <br><br>  Jangan ragu untuk bertanya.  Jika ada sesuatu yang tidak ditunjukkan dalam artikel atau pada titik tertentu tidak jelas - menulis kepada saya tentang hal itu.  Saya pasti akan memperbaiki, mengedit, atau mengklarifikasi masalah kontroversial. <br><br>  Program dengan senang hati dan semoga kekuatan dan kode yang indah datang bersama Anda :) <br><br>  py.s. <br><br>  Bot yang ditulis di bagian artikel ini berfungsi.  Anda dapat menyiksanya di sini: <a href="http://t.me/test_habr_bot" rel="nofollow">@test_habr_bot</a> <br>  Anda juga dapat menyiksa perencana saya: <a href="http://t.me/EventCheckPlanner_Bot" rel="nofollow">@EventCheckPlanner_Bot</a> <br>  Dan <a href="http://t.me/FilmFanAmateurBot" rel="nofollow">penggemar film Cheeky</a> : <a href="http://t.me/FilmFanAmateurBot" rel="nofollow">@FilmFanAmateurBot</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481354/">https://habr.com/ru/post/id481354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481344/index.html">Rencana Tim Platform IntelliJ untuk 2020</a></li>
<li><a href="../id481346/index.html">5 perubahan besar dalam industri otomotif</a></li>
<li><a href="../id481348/index.html">Direktori Aktif Pentest. Bagian 1</a></li>
<li><a href="../id481350/index.html">Siapa yang bekerja di kosmodrom Plesetsk</a></li>
<li><a href="../id481352/index.html">DBA: membersihkan catatan klon dari tabel tanpa PK</a></li>
<li><a href="../id481356/index.html">Terima kasih, 2019</a></li>
<li><a href="../id481358/index.html">C ++ Rusia: bagaimana itu</a></li>
<li><a href="../id481360/index.html">Hasil minggu ini: Rambler dan Twitch setuju, tenaga kerja elektronik akan diperkenalkan di Federasi Rusia, dan Facebook akan membuat OS sendiri</a></li>
<li><a href="../id481362/index.html">Sertifikat SSL untuk aplikasi web Docker</a></li>
<li><a href="../id481364/index.html">Rumah sensitif menggantikan rumah pintar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>