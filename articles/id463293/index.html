<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÑ üî± ‚ÜôÔ∏è Pengumpul Sampah. Kursus lengkap + transfer dari BOTR ‚ö°Ô∏è üë©üèæ‚Äç‚öïÔ∏è ü§≤üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini Anda akan menemukan dua sumber informasi sekaligus: 


1. Kursus Lengkap Pengumpul Sampah dalam Bahasa Rusia: CLRium # 6 ( workshop ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengumpul Sampah. Kursus lengkap + transfer dari BOTR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/463293/"><p>  Dalam artikel ini Anda akan menemukan dua sumber informasi sekaligus: </p><br><ol><li>  Kursus Lengkap Pengumpul Sampah dalam Bahasa Rusia: CLRium # 6 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">workshop saat ini di sini</a> ) </li><li>  Terjemahan sebuah artikel dari BOTR "Garbage Collector Device" oleh Maoni Stevens. </li></ol><br><p><img src="https://habrastorage.org/webt/q2/r5/db/q2r5dbgih_azfbdvqe1dxcxsgp8.jpeg"></p><a name="habracut"></a><br><h2 id="1-clrium-5-polnyy-kurs-po-garbage-collector">  1. CLRium # 5: Kursus Kolektor Sampah Lengkap </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/gx/ef/-t/gxef-ta_pk2ywxouxlgj8zjhhra.png"></a> </p><br><h2 id="2-ustroystvo-sborschika-musora-by-maoni-stephens-maoni0httpsgithubcommaoni0">  2. Perangkat pengumpul sampah oleh Maoni Stephens ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ maoni0</a> ) </h2><br><p>  Catatan: untuk mempelajari lebih lanjut tentang pengumpulan sampah secara umum, lihat <em>Buku Pegangan Pengumpulan Sampah</em> ;  informasi khusus tentang pemulung di CLR disediakan dalam buku <em>Pro .NET Memory Management</em> .  Tautan ke kedua sumber diberikan di akhir dokumen. </p><br><h3 id="arhitektura-komponentov">  Arsitektur Komponen </h3><br><p>  Pengumpulan sampah dikaitkan dengan dua komponen: dispenser dan kolektor.  Pengalokasi bertanggung jawab untuk mengalokasikan memori dan memanggil kolektor jika perlu.  Kolektor mengumpulkan sampah atau memori objek yang tidak lagi digunakan oleh program. </p><br><p>  Ada cara lain untuk memanggil kolektor, misalnya secara manual, menggunakan GC.Collect.  Juga, utas finalizer dapat menerima pemberitahuan asinkron bahwa kehabisan memori (yang akan menyebabkan kolektor). </p><br><h3 id="ustroystvo-raspredelitelya">  Perangkat distributor </h3><br><p>  Distributor dipanggil oleh komponen tambahan runtime dengan informasi berikut: </p><br><ul><li>  ukuran yang diperlukan dari plot yang dialokasikan; </li><li>  konteks alokasi memori untuk utas eksekusi; </li><li>  bendera yang menunjukkan, misalnya, apakah objek dapat diselesaikan. </li></ul><br><p>  Pengumpul sampah tidak menyediakan metode pemrosesan khusus untuk berbagai jenis objek.  Ini menerima informasi tentang ukuran objek dari runtime. </p><br><p>  Bergantung pada ukuran, kolektor membagi objek menjadi dua kategori: kecil (&lt;85.000 byte) dan besar (&gt; = 85.000 byte).  Secara umum, perakitan benda kecil dan besar dapat terjadi dengan cara yang sama.  Namun, kolektor memisahkannya berdasarkan ukuran, karena mengompresi objek besar membutuhkan banyak sumber daya. </p><br><p>  Pengumpul sampah mengalokasikan memori ke pengalokasi berdasarkan konteks alokasi.  Ukuran konteks alokasi ditentukan oleh blok memori yang dialokasikan. </p><br><ul><li><p>  <strong>Konteks seleksi</strong> adalah area kecil dari segmen heap tertentu, yang masing-masing ditujukan untuk aliran eksekusi tertentu.  Pada mesin dengan satu prosesor (artinya 1 prosesor logis), konteks alokasi memori tunggal digunakan untuk objek generasi 0. </p><br></li><li><p>  <strong>Blok memori yang dialokasikan</strong> - jumlah memori yang dialokasikan oleh pengalokasi setiap kali membutuhkan lebih banyak memori untuk memposisikan objek di dalam area.  Ukuran blok biasanya 8 KB, dan ukuran rata-rata objek yang dikelola adalah 35 byte.  Karena itu, dalam satu blok Anda dapat menempatkan banyak objek. </p><br></li></ul><br><p>  Objek besar tidak menggunakan konteks dan blok.  Satu objek besar mungkin lebih besar dari potongan kecil memori ini.  Selain itu, manfaat menggunakan area ini (dijelaskan di bawah) hanya terlihat ketika bekerja dengan benda kecil.  Ruang untuk objek besar dialokasikan langsung di segmen heap. </p><br><p>  Distributor dirancang sedemikian rupa sehingga: </p><br><ul><li><p> <strong>panggil pengumpul sampah bila perlu:</strong> pengalokasi memanggil pengumpul ketika jumlah memori yang dialokasikan untuk objek melebihi nilai ambang batas (ditetapkan oleh pengumpul), atau jika pengalokasi tidak lagi dapat mengalokasikan memori di segmen ini.  Ambang dan segmen yang dikontrol akan dijelaskan secara rinci nanti. </p><br></li><li><p>  <strong>menyimpan lokasi objek:</strong> objek yang terletak bersama dalam satu segmen tumpukan disimpan di alamat virtual yang berdekatan satu sama lain. </p><br></li><li><p>  <strong>gunakan cache secara efisien:</strong> pengalokasi mengalokasikan memori dalam <em>blok</em> , dan bukan untuk setiap objek.  Ini mengeluarkan begitu banyak memori untuk menyiapkan cache prosesor, karena beberapa objek akan ditempatkan langsung di dalamnya.  Blok memori yang dialokasikan biasanya 8 KB. </p><br></li><li><p>  <strong>secara efektif membatasi area yang dialokasikan untuk utas eksekusi:</strong> kedekatan konteks dan blok memori yang dialokasikan untuk utas memastikan bahwa hanya satu utas yang akan menulis data ke ruang yang dialokasikan.  Akibatnya, tidak perlu membatasi alokasi memori sampai ruang dalam konteks alokasi saat ini telah berakhir. </p><br></li><li><p>  <strong>memastikan integritas memori:</strong> pengumpul sampah selalu mengatur ulang memori untuk objek yang baru dialokasikan sehingga tautannya tidak mengarah ke bagian memori yang berubah-ubah. </p><br></li><li><p>  <strong>memastikan heap continuity:</strong> pengalokasi menciptakan objek bebas dari memori yang tersisa di setiap blok yang dialokasikan.  Misalnya, jika 30 byte dibiarkan di blok, dan 40 byte diperlukan untuk mengakomodasi objek berikutnya, pengalokasi akan mengubah 30 byte ini menjadi objek bebas dan meminta blok memori baru. </p><br></li></ul><br><h2>  API </h2><br><pre><code class="plaintext hljs">Object* GCHeap::Alloc(size_t size,  DWORD); Object* GCHeap::Alloc(alloc_context* acontext, size_t size,  DWORD);</code> </pre> <br><p>  Dengan menggunakan fungsi-fungsi ini, Anda dapat mengalokasikan memori untuk objek kecil dan besar.  Ada fungsi untuk mengalokasikan ruang tepat di tumpukan benda besar (LOH): </p><br><pre> <code class="plaintext hljs"> Object* GCHeap::AllocLHeap(size_t size,  DWORD);</code> </pre> <br><h3 id="ustroystvo-sborschika">  Perangkat kolektor </h3><br><h4 id="zadachi-sborschika-musora">  Tugas Pengumpul Sampah </h4><br><p>  GC dirancang untuk manajemen memori yang efisien.  Pengembang yang menulis kode terkelola dapat menggunakannya tanpa banyak usaha.  Tata pemerintahan yang baik berarti: </p><br><ul><li>  pengumpulan sampah harus cukup sering terjadi agar tidak mengotori tumpukan yang dikelola dengan sejumlah besar (berdasarkan rasio atau dalam jumlah absolut) dari objek yang tidak digunakan (sampah) yang memori dialokasikan; </li><li>  pengumpulan sampah harus dilakukan sesering mungkin agar tidak membuang waktu prosesor yang berguna, meskipun pengumpulan yang lebih sering akan memungkinkan penggunaan memori yang lebih sedikit; </li><li>  pengumpulan sampah harus produktif, karena jika sebagai hasil dari perakitan hanya sepotong kecil memori yang dibebaskan, maka baik perakitan dan waktu prosesor yang dihabiskan sia-sia; </li><li>  pengumpulan sampah harus cepat, karena banyak beban kerja memerlukan waktu tunda yang singkat; </li><li>  pengembang yang menulis kode terkelola tidak perlu tahu banyak tentang pengumpulan sampah untuk mencapai penggunaan memori yang efisien (dibandingkan dengan beban kerja mereka); </li><li>  Pengumpul sampah harus beradaptasi dengan sifat penggunaan memori yang berbeda. </li></ul><br><h4 id="logicheskoe-opisanie-upravlyaemoy-kuchi">  Deskripsi logis dari Heap yang Dikelola </h4><br><p>  Pengumpul sampah CLR mengumpulkan objek yang secara logis dipisahkan oleh generasi.  Setelah merakit objek dalam generasi <em>N</em> , objek yang tersisa ditandai sebagai milik generasi <em>N + 1</em> .  Proses ini disebut promosi benda lintas generasi.  Ada pengecualian dalam proses ini ketika perlu untuk mentransfer objek ke generasi yang lebih rendah atau tidak memajukannya sama sekali. </p><br><p>  Dalam kasus benda kecil, tumpukan dibagi menjadi tiga generasi: gen0, gen1 dan gen2.  Untuk objek besar, hanya ada satu generasi - gen3.  Gen0 dan gen1 disebut generasi fana (objek hidup dalam waktu singkat). </p><br><p>  Untuk sekelompok benda kecil, jumlah generasi berarti usia mereka.  Misalnya, gen0 adalah generasi termuda.  Ini tidak berarti bahwa semua objek di gen0 lebih muda dari objek di gen1 atau gen2.  Ada beberapa pengecualian yang dijelaskan di bawah ini.  Merakit satu generasi berarti mengumpulkan objek dalam generasi ini, serta semua generasi mudanya. </p><br><p>  Secara teoritis, perakitan benda besar dan kecil dapat terjadi dengan cara yang sama.  Namun, karena kompresi objek besar membutuhkan banyak sumber daya, perakitannya berlangsung dengan cara yang berbeda.  Benda-benda besar hanya terkandung dalam gen2 dan hanya dikumpulkan selama pengumpulan sampah di generasi ini karena alasan kinerja.  Baik gen2 dan gen3 bisa berukuran besar, dan membangun objek dalam generasi sementara (gen0 dan gen1) tidak boleh terlalu intensif sumber daya. </p><br><p>  Objek ditempatkan pada generasi termuda.  Untuk objek kecil, ini adalah gen0, dan untuk objek besar, gen3. </p><br><h4 id="fizicheskoe-opisanie-upravlyaemoy-kuchi">  Deskripsi Fisik Tumpukan Terkelola </h4><br><p>  Tumpukan terkelola terdiri dari sekumpulan segmen.  Segmen adalah blok memori yang terus-menerus yang dilewati OS ke pengumpul sampah.  Segmen heap dibagi menjadi beberapa bagian kecil dan besar untuk mengakomodasi objek kecil dan besar.  Segmen setiap tumpukan dihubungkan bersama.  Setidaknya satu segmen untuk objek kecil dan satu untuk segmen besar dicadangkan saat memuat CLR. </p><br><p>  Di setiap tumpukan benda kecil hanya ada satu segmen fana, di mana generasi gen0 dan gen1 berada.  Segmen ini mungkin atau mungkin tidak mengandung objek generasi gen2.  Selain segmen fana, satu atau lebih segmen tambahan mungkin ada, yang akan menjadi segmen gen2, karena mengandung segmen generasi 2. </p><br><p>  Tumpukan benda besar terdiri dari satu atau lebih segmen. </p><br><p>  Segmen tumpukan diisi dari alamat yang lebih rendah ke yang lebih tinggi.  Ini berarti bahwa objek yang terletak di alamat bawah segmen lebih tua dari yang terletak di senior.  Ada juga pengecualian yang dijelaskan di bawah ini. </p><br><p>  Segmen heap dialokasikan sesuai kebutuhan.  Jika mereka tidak mengandung objek yang digunakan, segmen dihapus.  Namun, segmen awal pada heap selalu ada.  Satu segmen dialokasikan pada satu waktu untuk setiap tumpukan.  Dalam hal benda kecil, ini terjadi selama pengumpulan sampah, dan untuk benda besar, selama alokasi memori untuk mereka.  Skema semacam itu meningkatkan produktivitas, karena benda-benda besar dikumpulkan hanya pada generasi 2 (yang membutuhkan banyak sumber daya). </p><br><p>  Segmen tumpukan bergabung bersama dalam pemilihan.  Segmen terakhir dalam rantai selalu singkat.  Segmen tempat semua objek dikumpulkan dapat digunakan kembali, misalnya, sebagai sementara.  Penggunaan kembali segmen hanya berlaku untuk tumpukan benda kecil.  Untuk mengakomodasi objek besar setiap kali seluruh objek besar dipertimbangkan.  Benda kecil ditempatkan hanya di segmen fana. </p><br><h4 id="porogovoe-znachenie-obyoma-vydelennoy-pamyati">  Nilai ambang memori yang dialokasikan </h4><br><p>  Ini adalah konsep logis terkait dengan ukuran setiap generasi.  Jika terlampaui, generasi memulai pengumpulan sampah. </p><br><p>  Nilai ambang batas untuk generasi tertentu diatur tergantung pada jumlah objek yang bertahan dalam generasi ini.  Jika jumlah ini tinggi, nilai ambang batas menjadi lebih tinggi.  Diharapkan bahwa rasio objek yang digunakan dan yang tidak digunakan akan lebih baik selama sesi pengumpulan sampah generasi berikutnya. </p><br><h2>  Seleksi generasi untuk pengumpulan sampah </h2><br><p>  Saat diaktifkan, kolektor harus menentukan generasi yang akan dibangun.  Selain nilai ambang, faktor lain memengaruhi pilihan ini: </p><br><ul><li>  fragmentasi satu generasi - jika satu generasi sangat terfragmentasi, pengumpulan sampah di dalamnya cenderung produktif; </li><li>  jika memori mesin terlalu sibuk, kolektor dapat melakukan pembersihan yang lebih dalam, jika pembersihan seperti itu lebih cenderung membebaskan ruang dan menghindari pertukaran halaman yang tidak perlu (memori di seluruh mesin); </li><li>  jika segmen fana kehabisan ruang, kolektor dapat melakukan pembersihan yang lebih dalam di segmen ini (mengumpulkan lebih banyak objek generasi 1) untuk menghindari mengalokasikan segmen tumpukan baru. </li></ul><br><h3 id="process-sborki-musora">  Proses pengumpulan sampah </h3><br><h4 id="etap-markirovki">  Tahap penandaan </h4><br><p>  Selama fase ini, CLR harus menemukan semua benda hidup. </p><br><p>  Keuntungan dari seorang kolektor dengan dukungan generasi adalah kemampuannya untuk membersihkan sampah hanya di bagian tumpukan, daripada terus-menerus mengamati semua benda.  Mengumpulkan sampah dalam generasi sementara, pengumpul harus menerima informasi dari lingkungan runtime tentang objek mana dalam generasi ini yang masih digunakan oleh program.  Selain itu, objek pada generasi yang lebih tua dapat menggunakan objek pada generasi yang lebih muda, mengacu pada mereka. </p><br><p>  Untuk menandai objek lama yang mereferensikan objek baru, pemulung menggunakan bit khusus.  Bit diatur oleh mekanisme kompiler JIT selama operasi penugasan.  Jika objek milik generasi ephemeral, kompiler JIT akan mengatur byte yang mengandung bit yang mengindikasikan posisi awal.  Mengumpulkan sampah dalam generasi sementara, kolektor dapat menggunakan bit ini untuk seluruh tumpukan yang tersisa dan hanya melihat objek yang sesuai dengan bit ini. </p><br><h4 id="etap-planirovaniya">  Tahap perencanaan </h4><br><p>  Pada titik ini, kompresi dimodelkan untuk menentukan efektivitasnya.  Jika hasilnya produktif, pengumpul memulai kompresi yang sebenarnya.  Kalau tidak, dia hanya membersihkan. </p><br><h4 id="etap-peremescheniya">  Pindah panggung </h4><br><p>  Jika kolektor melakukan kompresi, ini akan menyebabkan benda bergerak.  Dalam hal ini, Anda harus memperbarui tautan ke objek-objek ini.  Selama fase pemindahan, pengumpul harus menemukan semua tautan yang menunjuk ke objek dalam generasi tempat pengumpulan sampah berlangsung.  Sebaliknya, selama tahap penandaan, kolektor hanya menandai objek hidup, sehingga tidak perlu mempertimbangkan tautan lemah. </p><br><h4 id="etap-szhatiya">  Tahap kompresi </h4><br><p>  Tahap ini cukup sederhana, karena kolektor telah menentukan alamat baru untuk objek bergerak selama tahap perencanaan.  Ketika dikompresi, objek akan disalin ke alamat ini. </p><br><h4 id="etap-uborki">  Tahap pembersihan </h4><br><p>  Selama fase ini, kolektor mencari ruang yang tidak digunakan antara benda hidup.  Alih-alih ruang ini, ia menciptakan objek gratis.  Objek yang tidak digunakan di sekitarnya menjadi satu objek gratis.  Semua objek gratis ditempatkan dalam <em>daftar objek gratis</em> . </p><br><h3 id="code-flow">  Aliran kode </h3><br><p>  Ketentuan: </p><br><ul><li>  <strong>WKS GC:</strong> Pengumpulan Sampah dalam Mode Workstation </li><li>  <strong>SVR GC:</strong> Pengumpulan Sampah Mode Server </li></ul><br><h4 id="funkcionalnoe-povedenie">  Perilaku fungsional </h4><br><h5 id="wks-gc-bez-parallelnoy-sborki-musora">  WKS GC tanpa pengumpulan sampah paralel </h5><br><ol><li>  Utas pengguna menggunakan semua memori yang dialokasikan untuknya dan memanggil pengumpul sampah. </li><li>  Kolektor memanggil <code>SuspendEE</code> untuk menangguhkan semua utas yang dikelola. </li><li>  Kolektor memilih generasi untuk dibersihkan. </li><li>  Penandaan objek dimulai. </li><li>  Kolektor pergi ke tahap perencanaan dan menentukan kebutuhan untuk kompresi. </li><li>  Jika perlu, kolektor memindahkan objek dan melakukan kompresi.  Dalam kasus lain, itu hanya pembersihan. </li><li>  Kolektor memanggil <code>RestartEE</code> untuk memulai kembali utas yang dikelola. </li><li>  Utas pengguna terus bekerja. </li></ol><br><h5 id="wks-gc-s-parallelnoy-sborkoy-musora">  WKS GC dengan pengumpulan sampah paralel </h5><br><p>  Algoritma ini menjelaskan pengumpulan sampah latar belakang. </p><br><ol><li>  Utas pengguna menggunakan semua memori yang dialokasikan untuknya dan memanggil pengumpul sampah. </li><li>  Kolektor memanggil <code>SuspendEE</code> untuk menangguhkan semua utas yang dikelola. </li><li>  Kolektor menentukan apakah akan menjalankan pengumpulan sampah latar belakang. </li><li>  Jika demikian, utas pengumpulan sampah latar belakang diaktifkan.  Utas ini memanggil <code>RestartEE</code> untuk melanjutkan utas yang dikelola. </li><li>  Alokasi memori untuk proses yang dikelola berlanjut pada saat yang sama dengan pengumpulan sampah latar belakang. </li><li>  Utas pengguna dapat menggunakan semua memori yang dialokasikan untuk itu dan memulai pengumpulan sampah sementara (juga dikenal sebagai pengumpulan sampah prioritas tinggi).  Ini berjalan dengan cara yang sama seperti dalam mode workstation tanpa pengumpulan sampah paralel. </li><li>  <code>SuspendEE</code> pengumpulan sampah latar belakang memanggil <code>SuspendEE</code> lagi untuk menyelesaikan tanda, dan kemudian memanggil <code>RestartEE</code> untuk memulai pembersihan paralel dengan utas pengguna berjalan. </li><li>  Pengumpulan sampah latar belakang selesai. </li></ol><br><h5 id="svr-gc-bez-parallelnoy-sborki-musora">  SVR GC tanpa pengumpulan sampah paralel </h5><br><ol><li>  Utas pengguna menggunakan semua memori yang dialokasikan untuknya dan memanggil pengumpul sampah. </li><li>  Utas pengumpulan sampah mode server diaktifkan dan menyebabkan <code>SuspendEE</code> menghentikan sementara eksekusi utas yang dikelola. </li><li>  Aliran pengumpulan sampah dalam mode server melakukan operasi yang sama seperti dalam mode workstation tanpa pengumpulan sampah paralel. </li><li>  Utas pengumpulan sampah mode server meminta <code>RestartEE</code> untuk memulai utas yang dikelola. </li><li>  Utas pengguna terus bekerja. </li></ol><br><h5 id="svr-gc-s-parallelnoy-sborkoy-musora">  SVR GC dengan pengumpulan sampah paralel </h5><br><p>  Algoritma ini sama seperti dalam kasus pengumpulan sampah paralel dalam mode workstation, hanya pengumpulan non-fonon dilakukan di utas server. </p><br><h2 id="fizicheskaya-arhitektura">  Arsitektur fisik </h2><br><p>  Bagian ini akan membantu Anda memahami aliran kode. </p><br><p>  Ketika utas pengguna kehabisan memori, itu bisa mendapatkan ruang kosong menggunakan fungsi <code>try_allocate_more_space</code> . </p><br><p>  Fungsi <code>try_allocate_more_space</code> memanggil <code>GarbageCollectGeneration</code> ketika Anda perlu memulai pengumpul sampah. </p><br><p>  Jika pengumpulan sampah dalam mode workstation tidak paralel, <code>GarbageCollectGeneration</code> dijalankan di utas pengguna yang disebut oleh pemulung.  Aliran kode adalah sebagai berikut: </p><br><pre> <code class="plaintext hljs"> GarbageCollectGeneration() { SuspendEE(); garbage_collect(); RestartEE(); } garbage_collect() { generation_to_condemn(); gc1(); } gc1() { mark_phase(); plan_phase(); } plan_phase() { //   ,   //    if (compact) { relocate_phase(); compact_phase(); } else make_free_lists(); }</code> </pre> <br><p>  Jika pengumpulan sampah paralel dilakukan dalam mode workstation (secara default), aliran kode untuk pengumpulan sampah latar belakang terlihat seperti ini: </p><br><pre> <code class="plaintext hljs"> GarbageCollectGeneration() { SuspendEE(); garbage_collect(); RestartEE(); } garbage_collect() { generation_to_condemn(); //     //      do_background_gc(); } do_background_gc() { init_background_gc(); start_c_gc (); //           . wait_to_proceed(); } bgc_thread_function() { while (1) { //    //  gc1(); } } gc1() { background_mark_phase(); background_sweep(); }</code> </pre> <br><h1>  Tautan Sumber Daya </h1><br><ul><li>  <a href="">Implementasi .NET CLR GC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Garbage Collection Handbook: Seni Manajemen Memori Otomatis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengumpulan sampah (Wikipedia)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manajemen Memori .NET Pro</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463293/">https://habr.com/ru/post/id463293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463279/index.html">PHP Digest No. 162 (1 - 12 Agustus 2019)</a></li>
<li><a href="../id463281/index.html">Mengapa ada beberapa aplikasi inovatif di Google Play atau mengapa terkadang pemrograman itu ajaib</a></li>
<li><a href="../id463285/index.html">ShIoTiny: node, tautan, dan acara atau fitur program menggambar</a></li>
<li><a href="../id463289/index.html">Matematika Terpisah untuk WMS: Clustering Stock Lot</a></li>
<li><a href="../id463291/index.html">Dadu atau Tulang</a></li>
<li><a href="../id463295/index.html">C ++ dan CMake - Brothers Forever, Bagian II</a></li>
<li><a href="../id463297/index.html">Kesetiaan dengan selera Anda</a></li>
<li><a href="../id463299/index.html">Kiat dan trik Kubernetes: cara meningkatkan produktivitas</a></li>
<li><a href="../id463301/index.html">Gonkey - Alat Penguji Microservice</a></li>
<li><a href="../id463303/index.html">Facebook akhirnya berhenti menargetkan iklan untuk nomor telepon yang dimasukkan orang untuk 2FA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>