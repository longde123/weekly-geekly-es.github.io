<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòµ üßòüèΩ üîµ OpenSceneGraph: Sistema de complementos üö¥üèº üê§ üåÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 En alguna parte de las lecciones anteriores, ya se dijo que OSG admite la carga de diversos tipos de recursos, como im√°genes r√°ster, mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Sistema de complementos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438296/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><h1>  Introduccion </h1><br>  En alguna parte de las lecciones anteriores, ya se dijo que OSG admite la carga de diversos tipos de recursos, como im√°genes r√°ster, modelos 3D de varios formatos o, por ejemplo, fuentes a trav√©s de su propio sistema de complemento.  El complemento OSG es un componente separado que extiende la funcionalidad del motor y tiene una interfaz estandarizada dentro del OSG.  El complemento se implementa como una biblioteca din√°mica compartida (dll en Windows, Linux, etc.).  Los nombres de las bibliotecas de complementos corresponden a una convenci√≥n espec√≠fica <br><br><pre><code class="plaintext hljs">osgdb_&lt; &gt;.dll</code> </pre> <br>  es decir, el nombre del complemento siempre contiene el prefijo osgdb_.  Una extensi√≥n de archivo le dice al motor qu√© complemento se debe usar para descargar un archivo con esta extensi√≥n.  Por ejemplo, cuando escribimos una funci√≥n en c√≥digo <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>);</code> </pre><br>  el motor ve la extensi√≥n osg y carga un complemento llamado osgdb_osg.dll (u osgdb_osg.so en el caso de Linux).  El c√≥digo del complemento hace todo el trabajo sucio devolvi√©ndonos un puntero a un nodo que describe el modelo cessna.  Del mismo modo, tratando de cargar una imagen PNG <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg:Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.png"</span></span>);</code> </pre><br>  har√° que se cargue el complemento osgdb_png.dll, que implementa un algoritmo para leer datos de una imagen PNG y colocar estos datos en un objeto de tipo osg :: Image. <br><a name="habracut"></a><br>  Todas las operaciones para trabajar con recursos externos se implementan mediante las funciones de la biblioteca osgDB, con la que invariablemente vinculamos los programas de un ejemplo a otro.  Esta biblioteca se basa en el sistema de complemento OSG.  Hasta la fecha, el paquete OSG incluye muchos complementos que funcionan con la mayor√≠a de los formatos de imagen, modelos 3D y fuentes utilizados en la pr√°ctica.  Los complementos proporcionan datos de lectura (importaci√≥n) de un formato espec√≠fico y, en la mayor√≠a de los casos, escritura de datos en un archivo del formato requerido (exportaci√≥n).  La utilidad osgconv, en particular, le permite convertir datos de un formato a otro, por ejemplo, el sistema de complemento. <br><br><pre> <code class="plaintext hljs">$ osgconv cessna.osg cessna.3ds</code> </pre><br>  convierte f√°cil y naturalmente el modelo cessna osg en formato 3DS, que luego puede importarse a un editor 3D, por ejemplo, a Blender (por cierto, hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extensi√≥n para trabajar con osg directamente</a> para Blender) <br><br><img src="https://habrastorage.org/webt/vy/dm/qm/vydmqm2a3evtdqxu2vtf_kknmrw.png"><br><br>  Hay una lista oficial de complementos OSG est√°ndar con una descripci√≥n de su prop√≥sito, pero es larga y soy demasiado vaga para traerla aqu√≠.  Es m√°s f√°cil mirar la ruta de instalaci√≥n de la biblioteca en la carpeta bin / ospPlugins-xyz, donde x, y, z es el n√∫mero de versi√≥n de OSG.  Desde el nombre del archivo de complemento, es f√°cil entender qu√© formato procesa. <br><br>  Si el compilador MinGW compila el OSG, se agrega un prefijo adicional mingw_ al nombre est√°ndar del complemento, es decir, el nombre se ver√° as√≠ <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;.dll</code> </pre><br>  La versi√≥n del complemento compilado en la configuraci√≥n DEBUG tambi√©n est√° equipada con el sufijo d al final del nombre, es decir, el formato ser√° <br><br><pre> <code class="plaintext hljs">osgdb_&lt; &gt;d.dll</code> </pre><br>  o <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;d.dll</code> </pre><br>  cuando se ensambla MinGW. <br><br><h1>  1. Complementos pseudo-cargadores </h1><br>  Algunos complementos OSG realizan las funciones de los llamados pseudocargadores: esto significa que no est√°n vinculados a una extensi√≥n de archivo espec√≠fica, pero al agregar un sufijo al final del nombre del archivo, puede especificar qu√© complemento se debe usar para descargar este archivo, por ejemplo <br><br><pre> <code class="plaintext hljs">$ osgviewer worldmap.shp.ogr</code> </pre><br>  En este caso, el nombre real del archivo en el disco es worldmap.shp: este archivo almacena un mapa mundial en formato de archivo ESRI.  El sufijo .ogr le dice a la biblioteca osgDB que use el complemento osgdb_ogr para cargar este archivo;  de lo contrario, se usar√° el complemento osgdb_shp. <br><br>  Otro buen ejemplo es el complemento osgdb_ffmpeg.  La biblioteca FFmpeg admite m√°s de 100 c√≥decs diferentes.  Para leer cualquiera de ellos, simplemente podemos agregar el sufijo .ffmpeg despu√©s del nombre del archivo multimedia. <br><br>  Adem√°s de esto, algunos pseudocargadores nos permiten pasar a trav√©s de un sufijo una serie de par√°metros que afectan el estado del objeto cargado, y ya lo encontramos en un ejemplo con animaci√≥n <br><br><pre> <code class="cpp hljs">node = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  La l√≠nea 0.90 indica al complemento osgdb_osg los par√°metros de la orientaci√≥n inicial del modelo cargado.  Algunos pseudo-cargadores requieren par√°metros completamente espec√≠ficos para funcionar. <br><br><h1>  2. API para desarrollar complementos de terceros </h1><br>  Es completamente l√≥gico si, despu√©s de toda la lectura, tuvo la idea de que probablemente no ser√≠a dif√≠cil escribir su propio complemento para OSG, lo que le permitir√≠a importar un formato no est√°ndar de im√°genes o modelos 3D.  Y este es un pensamiento verdadero!  El mecanismo del complemento est√° dise√±ado para expandir la funcionalidad del motor sin cambiar el OSG.  Para comprender los principios b√°sicos de escribir un complemento, intentemos implementar un ejemplo simple. <br><br>  El desarrollo del complemento consiste en expandir la interfaz virtual de lectura / escritura proporcionada por OSG.  Esta funcionalidad es proporcionada por la clase virtual osgDB :: ReaderWriter.  Esta clase proporciona una serie de m√©todos virtuales redefinidos por el desarrollador del complemento. <br><table><thead><tr><th>  M√©todo </th><th>  Descripci√≥n </th></tr></thead><tbody><tr><td>  supportsExtensions () </td><td>  Acepta dos par√°metros de cadena: extensi√≥n de archivo y descripci√≥n.  El m√©todo siempre se llama en el constructor de la subclase. </td></tr><tr><td>  acceptExtension () </td><td>  Devuelve verdadero si la extensi√≥n pasada como argumento es compatible con el complemento </td></tr><tr><td>  fileExists () </td><td>  Le permite determinar si existe un archivo determinado (la ruta se pasa como un par√°metro) en el disco (devuelve verdadero si tiene √©xito) </td></tr><tr><td>  readNode () </td><td>  Acepta el nombre del archivo y las opciones como un objeto osgDB :: Option.  El desarrollador implementa las funciones para leer datos de un archivo </td></tr><tr><td>  writeNode () </td><td>  Acepta el nombre del nodo, el nombre del archivo deseado y las opciones.  El desarrollador implementa las funciones de escritura de datos en el disco </td></tr><tr><td>  readImage () </td><td>  Lectura de datos de mapa de bits del disco </td></tr><tr><td>  writeImage () </td><td>  Escribir un mapa de bits en el disco </td></tr></tbody></table><br>  La implementaci√≥n del m√©todo readNode () se puede describir mediante el siguiente c√≥digo <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         bool recognizableExtension = ...; bool fileExists = ...; if (!recognizableExtension) return ReadResult::FILE_NOT_HANDLED; if (!fileExists) return ReadResult::FILE_NOT_FOUND; //          osg::Node *root = ...; //       -     . //    -      bool errorInParsing = ...; if (errorInParsing) return ReadResult::ERROR_IN_READING_FILE; return root; }</span></span></code> </pre><br>  Es un poco sorprendente que, en lugar de un puntero al nodo del gr√°fico de escena, el m√©todo devuelva el tipo osgDB :: ReaderWriter :: ReadResult.  Este tipo es un objeto de resultado de lectura y se puede usar como contenedor de nodo, imagen, enumerador de estado (por ejemplo, FILE_NOT_FOUND), otro objeto especial o incluso como una cadena de mensaje de error.  Tiene muchos constructores impl√≠citos para implementar las funciones descritas. <br><br>  Otra clase √∫til es osgDB :: Options.  Puede permitirle establecer u obtener una serie de opciones de carga utilizando los m√©todos setOptionString () y getOptionString ().  Tambi√©n se permite pasar esta cadena al constructor de esta clase como argumento. <br><br>  El desarrollador puede controlar el comportamiento del complemento configurando la configuraci√≥n en la cadena de par√°metros que se pasa al cargar el objeto, por ejemplo, de esta manera <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    osg::Node* node1 = osgDB::readNodeFile("cow.osg"); //     string osg::Node* node2 = osgDB::readNodeFile("cow.osg", new osgDB::Options(string));</span></span></code> </pre><br><h1>  3. Procesamiento del flujo de datos en el complemento OSG </h1><br>  La clase base osgDB :: ReaderWriter incluye un conjunto de m√©todos que procesan los datos de los flujos de entrada / salida proporcionados por la biblioteca est√°ndar de C ++.  La √∫nica diferencia entre estos m√©todos de lectura / escritura y los discutidos anteriormente es que, en lugar del nombre del archivo, aceptan std :: istream &amp; input streams o std :: ostream &amp; output stream.  Usar un flujo de E / S de archivo siempre es preferible a usar un nombre de archivo.  Para realizar operaciones de lectura de archivos, podemos usar el siguiente dise√±o de interfaz: <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... osgDB::<span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file.c_str(), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::binary)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stream) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReadResult::ERROR_IN_READING_FILE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readNode(stream, options); } ... osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         osg::Node *root = ...; return root; }</span></span></code> </pre><br>  Despu√©s de implementar el complemento, podemos usar las funciones est√°ndar osgDB :: readNodeFile () y osgDB :: readImageFile () para cargar modelos e im√°genes, simplemente especificando la ruta del archivo.  OSG encontrar√° y descargar√° el complemento que escribimos. <br><br><h1>  4. Escribimos nuestro propio complemento </h1><br><br>  Por lo tanto, nadie nos molesta en crear nuestro propio formato para almacenar datos en geometr√≠a tridimensional, y lo inventaremos. <br><br>  <strong>piramide.pmd</strong> <br><br><pre> <code class="plaintext hljs">vertex: 1.0 1.0 0.0 vertex: 1.0 -1.0 0.0 vertex: -1.0 -1.0 0.0 vertex: -1.0 1.0 0.0 vertex: 0.0 0.0 2.0 face: 0 1 2 3 face: 0 3 4 face: 1 0 4 face: 2 1 4 face: 3 2 4</code> </pre><br>  Aqu√≠ al principio del archivo hay una lista de v√©rtices con sus coordenadas.  Los √≠ndices de v√©rtices van en orden, comenzando desde cero.  Despu√©s de la lista de v√©rtices viene una lista de caras.  Cada cara est√° definida por una lista de √≠ndices de v√©rtices a partir de los cuales se forma.  Al parecer, nada complicado.  La tarea es leer este archivo desde el disco y formar una geometr√≠a tridimensional sobre su base. <br><br><h1>  5. Configuraci√≥n del proyecto del complemento: caracter√≠sticas del script de compilaci√≥n </h1><br>  Si antes cre√°bamos aplicaciones, ahora tenemos que escribir una biblioteca din√°mica, y no solo una biblioteca, sino un complemento OSG que satisfaga ciertos requisitos.  Comenzaremos a cumplir estos requisitos con un script de compilaci√≥n del proyecto que se ver√° as√≠ <br><br>  <strong>plugin.pro</strong> <br><br><pre> <code class="cmake hljs">TEMPLATE = lib CONFIG += plugin CONFIG += no_plugin_name_prefix <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,) win32 { OSG_LIB_DIRECTORY = $$(OSG_BIN_PATH) OSG_INCLUDE_DIRECTORY = $$(OSG_INCLUDE_PATH) DESTDIR = $$(OSG_PLUGINS_PATH) CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -L$$OSG_LIB_DIRECTORY -losgd LIBS += -L$$OSG_LIB_DIRECTORY -losgViewerd LIBS += -L$$OSG_LIB_DIRECTORY -losgDBd LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreadsd LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -L$$OSG_LIB_DIRECTORY -losg LIBS += -L$$OSG_LIB_DIRECTORY -losgViewer LIBS += -L$$OSG_LIB_DIRECTORY -losgDB LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreads LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil } INCLUDEPATH += $$OSG_INCLUDE_DIRECTORY } unix { DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -losgd LIBS += -losgViewerd LIBS += -losgDBd LIBS += -lOpenThreadsd LIBS += -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -losg LIBS += -losgViewer LIBS += -losgDB LIBS += -lOpenThreads LIBS += -losgUtil } } INCLUDEPATH += ./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> HEADERS += $$files(./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/*.h) SOURCES += $$files(./src/*.cpp)</code> </pre><br>  Analizaremos los matices individuales con m√°s detalle. <br><br><pre> <code class="cmake hljs">TEMPLATE = lib</code> </pre><br>  significa que construiremos la biblioteca.  Para evitar la generaci√≥n de enlaces simb√≥licos con la ayuda de qu√© problemas de conflictos de versiones de la biblioteca se resuelven en los sistemas * nix, le indicamos al sistema de compilaci√≥n que esta biblioteca ser√° un complemento, es decir, se cargar√° en la memoria "sobre la marcha" <br><br><pre> <code class="cmake hljs">CONFIG += plugin</code> </pre><br>  A continuaci√≥n, excluimos la generaci√≥n del prefijo lib, que se agrega al usar los compiladores de la familia gcc y que se tiene en cuenta en el entorno de tiempo de ejecuci√≥n al cargar la biblioteca <br><br><pre> <code class="cmake hljs">CONFIG += no_plugin_name_prefix</code> </pre><br>  Establecer el nombre del archivo de biblioteca <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd</code> </pre><br>  donde pmd es la extensi√≥n de archivo del formato del modelo 3D que inventamos.  Adem√°s, debemos indicar que en el caso del ensamblaje MinGW, el prefijo mingw_ se agrega necesariamente al nombre <br><br><pre> <code class="cmake hljs">win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,)</code> </pre><br>  Especifique la ruta de compilaci√≥n de la biblioteca: para Windows <br><br><pre> <code class="cmake hljs">DESTDIR = $$(OSG_PLUGINS_PATH)</code> </pre><br>  para linux <br><br><pre> <code class="cmake hljs">DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Para Linux, con tal indicaci√≥n de la ruta (que sin duda es una muleta, pero a√∫n no he encontrado otra soluci√≥n), le damos el derecho de escribir en la carpeta especificada con complementos OSG de un usuario ordinario <br><br><pre> <code class="plaintext hljs"># chmod 666 /usr/lib/osgPlugins-3.7.0</code> </pre><br>  Todas las dem√°s configuraciones de compilaci√≥n son similares a las utilizadas en el ensamblaje de aplicaciones de muestra anteriores. <br><br><h1>  6. Configuraci√≥n del proyecto del complemento: caracter√≠sticas del modo de depuraci√≥n </h1><br>  Dado que este proyecto es una biblioteca din√°mica, debe haber un programa que cargue esta biblioteca en el proceso de su ejecuci√≥n.  Puede ser cualquier aplicaci√≥n que use OSG y en la que se llamar√° a la funci√≥n <br><br><pre> <code class="cpp hljs">node = osdDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"piramide.pmd"</span></span>);</code> </pre><br>  En este caso, nuestro complemento se cargar√°.  Para no escribir un programa de este tipo, usaremos una soluci√≥n preparada: el visor est√°ndar de osgviewer, que se incluye en el paquete de entrega del motor.  Si en la consola ejecuta <br><br><pre> <code class="plaintext hljs">$ osgviewer piramide.pmd</code> </pre><br>  entonces tambi√©n activar√° el complemento.  En la configuraci√≥n de inicio del proyecto, especifique la ruta a osgviewerd, como el directorio de trabajo, especifique el directorio donde se encuentra el archivo piramide.pmd y especifique el mismo archivo en las opciones de la l√≠nea de comandos de osgviewer <br><br><img src="https://habrastorage.org/webt/v8/9y/xa/v89yxafvygysowtw7aeihf9mgcs.png"><br><br>  Ahora podemos ejecutar el complemento y depurarlo directamente desde QtCreator IDE. <br><br><h1>  6. Implementamos el marco del complemento </h1><br>  Este ejemplo, en cierta medida, generaliza el conocimiento que ya hemos recibido sobre OSG de lecciones anteriores.  Al escribir un complemento, tenemos que <br><br><ol><li>  Seleccione una estructura de datos para almacenar la informaci√≥n de geometr√≠a del modelo le√≠da de un archivo de modelo <br></li><li>  Leer y analizar (analizar) el archivo de datos del modelo <br></li><li>  Configure correctamente el objeto geom√©trico osg :: Drawable basado en los datos le√≠dos del archivo <br></li><li>  Construye un subgrafo de escena para un modelo cargado <br></li></ol><br>  Entonces, por tradici√≥n, dar√© el c√≥digo fuente completo del complemento <br><br><div class="spoiler">  <b class="spoiler_title">Complemento Osgdb_pmd</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgDB/FileNameUtils&gt; #include &lt;osgDB/FileUtils&gt; #include &lt;osgDB/Registry&gt; #include &lt;osgUtil/SmoothingVisitor&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct face_t { std::vector&lt;unsigned int&gt; indices; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct pmd_mesh_t { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; std::vector&lt;face_t&gt; faces; pmd_mesh_t() : vertices(new osg::Vec3Array) , normals(new osg::Vec3Array) { } osg::Vec3 calcFaceNormal(const face_t &amp;face) const { osg::Vec3 v0 = (*vertices)[face.indices[0]]; osg::Vec3 v1 = (*vertices)[face.indices[1]]; osg::Vec3 v2 = (*vertices)[face.indices[2]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); return n * (1 / n.length()); } }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ReaderWriterPMD : public osgDB::ReaderWriter { public: ReaderWriterPMD(); virtual ReadResult readNode(const std::string &amp;filename, const osgDB::Options *options) const; virtual ReadResult readNode(std::istream &amp;stream, const osgDB::Options *options) const; private: pmd_mesh_t parsePMD(std::istream &amp;stream) const; std::vector&lt;std::string&gt; parseLine(const std::string &amp;line) const; }; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ ReaderWriterPMD::ReaderWriterPMD() { supportsExtension("pmd", "PMD model file"); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( const std::string &amp;filename, const osgDB::Options *options) const { std::string ext = osgDB::getLowerCaseFileExtension(filename); if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; return readNode(stream, options); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( std::istream &amp;stream, const osgDB::Options *options) const { (void) options; pmd_mesh_t mesh = parsePMD(stream); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(mesh.vertices.get()); for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); geom-&gt;addPrimitiveSet(polygon.get()); } geom-&gt;setNormalArray(mesh.normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); return geode.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ pmd_mesh_t ReaderWriterPMD::parsePMD(std::istream &amp;stream) const { pmd_mesh_t mesh; while (!stream.eof()) { std::string line; std::getline(stream, line); std::vector&lt;std::string&gt; tokens = parseLine(line); if (tokens[0] == "vertex") { osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); mesh.vertices-&gt;push_back(point); } if (tokens[0] == "face") { unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } mesh.faces.push_back(face); mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::string delete_symbol(const std::string &amp;str, char symbol) { std::string tmp = str; tmp.erase(std::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); return tmp; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::vector&lt;std::string&gt; ReaderWriterPMD::parseLine(const std::string &amp;line) const { std::vector&lt;std::string&gt; tokens; std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; while ( (pos = tmp.find(':')) != std::string::npos ) { token = tmp.substr(0, pos); tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } tokens.push_back(tmp); return tokens; } REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</span></span></span></span></code> </pre><br></div></div><br>  Primero, cuidemos las estructuras para almacenar datos de geometr√≠a. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">face_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices; };</code> </pre><br>  - describe la cara definida por la lista de √≠ndices de los v√©rtices que pertenecen a esta cara.  El modelo como un todo ser√° descrito por dicha estructura. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pmd_mesh_t</span></span></span><span class="hljs-class"> {</span></span> osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">face_t</span></span>&gt; faces; <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { } osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcFaceNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">face_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;face)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ osg::Vec3 v0 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; osg::Vec3 v1 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; osg::Vec3 v2 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * (<span class="hljs-number"><span class="hljs-number">1</span></span> / n.length()); } };</code> </pre><br>  La estructura consta de variables miembro para almacenar datos: v√©rtices: para almacenar una matriz de v√©rtices de un objeto geom√©trico;  normales: una serie de normales a las caras del objeto;  caras: una lista de caras del objeto.  El constructor de estructura inicializa inmediatamente punteros inteligentes <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { }</code> </pre><br>  Adem√°s, la estructura contiene un m√©todo que le permite calcular el vector normal de la cara calcFaceNormal () como un par√°metro que toma una estructura que describe la cara.  Todav√≠a no entraremos en detalles sobre la implementaci√≥n de este m√©todo, los analizaremos un poco m√°s tarde. <br><br>  Por lo tanto, decidimos sobre las estructuras en las que almacenaremos los datos de geometr√≠a.  Ahora escribamos el marco de nuestro complemento, es decir, implementamos la clase de herencia osgDB :: ReaderWriter <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReaderWriterPMD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgDB::ReaderWriter { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReaderWriterPMD(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; };</code> </pre><br>  Como se recomienda en la descripci√≥n de la API para desarrollar complementos, en esta clase redefinimos los m√©todos para leer datos de un archivo y convertirlos en un subgrafo de la escena.  El m√©todo readNode () realiza dos sobrecargas: una acepta el nombre del archivo como entrada y la otra recibe una secuencia de entrada est√°ndar.  El constructor de la clase define las extensiones de archivo compatibles con el complemento. <br><br><pre> <code class="cpp hljs">ReaderWriterPMD::ReaderWriterPMD() { supportsExtension(<span class="hljs-string"><span class="hljs-string">"pmd"</span></span>, <span class="hljs-string"><span class="hljs-string">"PMD model file"</span></span>); }</code> </pre><br>  La primera sobrecarga del m√©todo readNode () analiza la exactitud del nombre y la ruta del archivo, asocia una secuencia de entrada est√°ndar con el archivo y llama a la segunda sobrecarga, que hace el trabajo principal <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;filename, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       std::string ext = osgDB::getLowerCaseFileExtension(filename); // ,      if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; // ,       std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; //      std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; //      readNode() return readNode(stream, options); }</span></span></code> </pre><br>  En la segunda sobrecarga, implementamos el algoritmo de generaci√≥n de objetos para OSG <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) options; <span class="hljs-comment"><span class="hljs-comment">//   *.pmd       pmd_mesh_t mesh = parsePMD(stream); //    osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; //    geom-&gt;setVertexArray(mesh.vertices.get()); //    for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { //    GL_POLYGON      (  - 0) osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); //       for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); //     geom-&gt;addPrimitiveSet(polygon.get()); } //    geom-&gt;setNormalArray(mesh.normals.get()); //  OpenGL,       geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); //             osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); //     return geode.release(); }</span></span></code> </pre><br>  Al final del archivo main.cpp, llame a la macro REGISTER_OSGPLUGIN (). <br><br><pre> <code class="cpp hljs">REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</code> </pre><br>  Esta macro genera c√≥digo adicional que permite a OSG, en forma de biblioteca osgDB, construir un objeto de tipo ReaderWriterPMD y llamar a sus m√©todos para cargar archivos de tipo pmd.  Por lo tanto, el marco del complemento est√° listo, la cosa queda por peque√±a: implementar la carga y el an√°lisis del archivo pmd. <br><br><h1>  7. archivo de modelo 3D Parsim </h1><br>  Ahora toda la funcionalidad del complemento se basa en la implementaci√≥n del m√©todo parsePMD () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> ReaderWriterPMD::parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> mesh; <span class="hljs-comment"><span class="hljs-comment">//    while (!stream.eof()) { //      std::string line; std::getline(stream, line); //     -     std::vector&lt;std::string&gt; tokens = parseLine(line); //    -  if (tokens[0] == "vertex") { //       osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); //      mesh.vertices-&gt;push_back(point); } //    -  if (tokens[0] == "face") { //         unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } //      mesh.faces.push_back(face); //     mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El m√©todo ParseLine () analiza la l√≠nea del archivo pmd </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; ReaderWriterPMD::parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tokens; <span class="hljs-comment"><span class="hljs-comment">//   ,        ( Windows) std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; //      ,     : //      while ( (pos = tmp.find(':')) != std::string::npos ) { //     (vertex  face   ) token = tmp.substr(0, pos); //         tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } //        tokens.push_back(tmp); return tokens; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m√©todo convertir√° la cadena "v√©rtice: 1.0 -1.0 0.0" en una lista de las dos l√≠neas "v√©rtice" y "1.0 -1.0 0.0". </font><font style="vertical-align: inherit;">En la primera l√≠nea identificamos el tipo de datos: el v√©rtice o la cara, a partir de la segunda extraemos los datos en las coordenadas del v√©rtice. </font><font style="vertical-align: inherit;">Para garantizar el funcionamiento de este m√©todo, necesitamos la funci√≥n auxiliar delete_symbol (), que elimina el car√°cter dado de la cadena y devuelve una cadena que no contiene este car√°cter</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_symbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tmp = str; tmp.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es decir, ahora hemos implementado toda la funcionalidad de nuestro complemento y podemos probarlo. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Probar el complemento </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compilamos el complemento y ejecutamos la depuraci√≥n (F5). </font><font style="vertical-align: inherit;">Se lanzar√° una versi√≥n de depuraci√≥n del visor est√°ndar osgviewerd, que analizar√° el archivo piramide.pmd que se le pas√≥, cargar√° nuestro complemento y llamar√° a su m√©todo readNode (). </font><font style="vertical-align: inherit;">Si hicimos todo bien, obtendremos ese resultado. </font></font><br><br><img src="https://habrastorage.org/webt/s3/5g/-y/s35g-ykmmlet5z8jisj7efkz7je.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resulta que la lista de v√©rtices y caras en nuestro archivo inventado del modelo 3D ocultaba una pir√°mide cuadrangular. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© calculamos las normales nosotros mismos? </font><font style="vertical-align: inherit;">En una de las lecciones, se nos ofreci√≥ el siguiente m√©todo de c√°lculo autom√°tico de normales suavizadas</font></font><br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aplicamos esta funci√≥n en nuestro ejemplo, en lugar de asignar nuestras propias normales </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//geom-&gt;setNormalArray(mesh.normals.get()); //geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osgUtil::SmoothingVisitor::smooth(*geom);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y obtenemos el siguiente resultado: las </font></font><br><br><img src="https://habrastorage.org/webt/eb/gd/kt/ebgdktxsplxyqatprxunnwd8r2o.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normales afectan el c√°lculo de la iluminaci√≥n del modelo, y vemos que en esta situaci√≥n las normales suavizadas conducen a resultados incorrectos del c√°lculo de la iluminaci√≥n de la pir√°mide. </font><font style="vertical-align: inherit;">Es por esta raz√≥n que aplicamos nuestra bicicleta al c√°lculo de las normales. </font><font style="vertical-align: inherit;">Pero creo que explicar los matices de esto est√° m√°s all√° del alcance de esta lecci√≥n.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438296/">https://habr.com/ru/post/438296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438286/index.html">Trabajando con zonas horarias en JavaScript</a></li>
<li><a href="../438288/index.html">Protecci√≥n sin miedo. Seguridad de memoria en √≥xido</a></li>
<li><a href="../438290/index.html">Post-mortem con GGJ-2019: c√≥mo obtener golpes, pero a√∫n as√≠ hacer el juego</a></li>
<li><a href="../438292/index.html">Automatizaci√≥n de apartamentos con HomePod, Raspberry Pi y Node.js</a></li>
<li><a href="../438294/index.html">Encontrar Twitch Streamers en una partida de PUBG</a></li>
<li><a href="../438298/index.html">¬øPor qu√© ense√±ar si el desarrollo es m√°s rentable? Conversaci√≥n con GeekBrains</a></li>
<li><a href="../438302/index.html">La incre√≠ble creatividad de la evoluci√≥n digital.</a></li>
<li><a href="../438304/index.html">Subcontrataci√≥n? Genial, golpeas</a></li>
<li><a href="../438306/index.html">Radiaci√≥n: Laboratorio radioqu√≠mico de lunes a viernes.</a></li>
<li><a href="../438310/index.html">Instagram utiliza el aprendizaje autom√°tico para eliminar seguidores falsos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>