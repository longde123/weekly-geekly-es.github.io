<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèæ üç¨ üö° Sistemas operativos: tres piezas f√°ciles. Parte 5: Planificaci√≥n: Cola de comentarios de varios niveles (traducci√≥n) ü•© üè≥Ô∏è‚Äçüåà üè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introducci√≥n a los sistemas operativos 
 Hola Habr! Quiero llamar su atenci√≥n sobre una serie de art√≠culos-traducciones de una literatura interesante ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistemas operativos: tres piezas f√°ciles. Parte 5: Planificaci√≥n: Cola de comentarios de varios niveles (traducci√≥n)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450116/"><h1>  Introducci√≥n a los sistemas operativos </h1><br>  Hola Habr!  Quiero llamar su atenci√≥n sobre una serie de art√≠culos-traducciones de una literatura interesante en mi opini√≥n: OSTEP.  Este art√≠culo analiza en profundidad el trabajo de los sistemas operativos tipo Unix, a saber, el trabajo con procesos, varios programadores, memoria y otros componentes similares que componen el sistema operativo moderno.  El original de todos los materiales que puedes ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Tenga en cuenta que la traducci√≥n se realiz√≥ de manera no profesional (con bastante libertad), pero espero haber conservado el significado general. <br><br>  El trabajo de laboratorio sobre este tema se puede encontrar aqu√≠: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi adaptaci√≥n personal</a> </li></ul><br>  Otras partes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: Introducci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2: Abstracci√≥n: el proceso</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: Introducci√≥n a la API de proceso</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4: Introducci√≥n al Programador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5: Programador MLFQ</a> </li></ul><br>  Y puedes mirar mi canal en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">telegram</a> =) <br><a name="habracut"></a><br><h2>  Planificaci√≥n: cola de comentarios de varios niveles </h2><br>  En esta conferencia hablaremos sobre los problemas de desarrollar uno de los enfoques m√°s famosos para <br>  La planificaci√≥n se llama <b>Multi-Level Feedback Queue</b> (MLFQ).  El programador MLFQ fue descrito por primera vez en 1962 por Fernando J. Corbat√≥ en un sistema llamado Sistema de tiempo compartido compatible (CTSS).  Estos trabajos (incluido el trabajo posterior en Multics) se presentaron posteriormente al Premio Turing.  El planificador se mejor√≥ posteriormente y adquiri√≥ un aspecto que ya se puede encontrar en algunos sistemas modernos. <br><br>  El algoritmo MLFQ intenta resolver 2 problemas fundamentales transversales. <br>  <b>Primero</b> , intenta optimizar el tiempo de respuesta, que, como examinamos en la conferencia anterior, se optimiza comenzando al comienzo de la cola de las tareas m√°s cortas.  Sin embargo, el sistema operativo no sabe cu√°nto tiempo funcionar√° este o aquel proceso, y este es el conocimiento necesario para el funcionamiento de los algoritmos SJF, STCF.  <b>En segundo lugar</b> , MLFQ intenta hacer que el sistema responda a los usuarios (por ejemplo, aquellos que est√°n sentados y mirando la pantalla mientras esperan que se complete la tarea) y as√≠ minimizar el tiempo de respuesta.  Desafortunadamente, los algoritmos como RR reducen el tiempo de respuesta, pero tienen un efecto muy malo en las m√©tricas de tiempo de respuesta.  De ah√≠ nuestro problema: ¬øc√≥mo dise√±ar un planificador que cumpla con nuestros requisitos y al mismo tiempo no sepa nada sobre la naturaleza del proceso, en general?  ¬øC√≥mo puede el planificador aprender las caracter√≠sticas de las tareas que inicia y as√≠ tomar mejores decisiones de planificaci√≥n? <br><br>  <u>La esencia del problema: ¬øC√≥mo planificar la formulaci√≥n de tareas sin un conocimiento perfecto?</u>  <u>¬øC√≥mo desarrollar un planificador que minimice simult√°neamente el tiempo de respuesta para tareas interactivas y al mismo tiempo minimice el tiempo de respuesta sin saber el tiempo para completar la tarea?</u> <br><br>  Nota: aprender de eventos anteriores <br><br>  La alineaci√≥n MLFQ es un gran ejemplo de un sistema que aprende de eventos pasados ‚Äã‚Äãpara predecir el futuro.  A menudo se encuentran enfoques similares en el sistema operativo (y en muchas otras ramas de la inform√°tica, incluidas las ramas de predicci√≥n de hardware y los algoritmos de almacenamiento en cach√©).  Los viajes similares funcionan cuando las tareas tienen fases de comportamiento y, por lo tanto, son predecibles. <br><br>  Sin embargo, uno debe tener cuidado con tal t√©cnica, porque las predicciones pueden resultar f√°cilmente err√≥neas y llevar al sistema a tomar peores decisiones de las que ser√≠an sin conocimiento. <br><br><h3>  MLFQ: Reglas b√°sicas </h3><br>  Considere las reglas b√°sicas del algoritmo MLFQ.  Aunque hay varias implementaciones de este algoritmo, los enfoques b√°sicos son similares. <br><br>  En la implementaci√≥n que consideraremos, en MLFQ habr√° varias colas separadas, cada una de las cuales tendr√° una prioridad diferente.  En cualquier momento, una tarea lista para su ejecuci√≥n est√° en una cola.  MLFQ usa prioridades para decidir qu√© tarea ejecutar, es decir  primero se iniciar√° una tarea con una prioridad m√°s alta (una tarea de la cola con una prioridad m√°s alta). <br><br>  Sin lugar a dudas, m√°s de una tarea puede estar en una cola particular, por lo que tendr√°n la misma prioridad.  En este caso, el motor RR se utilizar√° para programar el lanzamiento entre estas tareas. <br><br>  As√≠ llegamos a dos reglas b√°sicas para MLFQ: <br><br><ul><li>  Regla 1: si la prioridad (A)&gt; Prioridad (B), se iniciar√° la tarea A (B no) </li><li>  Regla 2: Si prioridad (A) = Prioridad (B), A&amp;B se inician usando RR </li></ul><br>  Con base en lo anterior, los elementos clave para la planificaci√≥n de MLFQ son prioridades.  En lugar de establecer una prioridad fija para cada tarea, MLFQ cambia su prioridad seg√∫n el comportamiento observado. <br><br>  Por ejemplo, si una tarea deja de funcionar constantemente en la CPU mientras espera la entrada del teclado, MLFQ mantendr√° la prioridad del proceso en un nivel alto, porque as√≠ es como deber√≠a funcionar el proceso interactivo.  Si, por el contrario, la tarea utiliza constante e intensamente la CPU durante un per√≠odo prolongado, MLFQ reducir√° su prioridad.  Por lo tanto, MLFQ estudiar√° el comportamiento de los procesos en el momento de su operaci√≥n y utilizar√° el comportamiento. <br><br>  Dibujemos un ejemplo de c√≥mo podr√≠an verse las colas en alg√∫n momento y luego obtenemos algo como esto: <br><br><img src="https://habrastorage.org/webt/4x/ad/rr/4xadrrwfmrtn3mg-se6wgith9gm.png" alt="imagen"><br><br>  En este esquema, 2 procesos A y B est√°n en la cola con la m√°xima prioridad.  El proceso C est√° en alg√∫n punto intermedio, y el proceso D est√° al final de la cola.  De acuerdo con las descripciones anteriores del algoritmo MLFQ, el planificador ejecutar√° tareas solo con la prioridad m√°s alta de acuerdo con RR, y las tareas C, D estar√°n sin trabajo. <br><br>  Naturalmente, una instant√°nea est√°tica no dar√° una imagen completa de c√≥mo funciona MLFQ. <br>  Es importante comprender exactamente c√≥mo cambia la imagen con el tiempo. <br><br><h4>  Intento 1: c√≥mo cambiar la prioridad </h4><br>  En este punto, debe decidir c√≥mo MLFQ cambiar√° el nivel de prioridad de la tarea (y, por lo tanto, la posici√≥n de la tarea en la cola) durante su ciclo de vida.  Para hacer esto, debe tener en cuenta el flujo de trabajo: una serie de tareas interactivas con un tiempo de trabajo corto (y, por lo tanto, una liberaci√≥n frecuente de la CPU) y varias tareas largas que usan la CPU todo su tiempo de trabajo, mientras que el tiempo de respuesta para tales tareas no es importante.  Y as√≠, puede hacer el primer intento de implementar el algoritmo MLFQ con las siguientes reglas: <br><br><ul><li>  Regla 3: cuando una tarea ingresa al sistema, se pone en cola con el m√°s alto </li><li>  prioridad </li><li>  Regla 4a: Si una tarea usa toda la ventana de tiempo asignada, entonces su </li><li>  La prioridad baja. </li><li>  Regla 4b: si la tarea libera a la CPU antes de que expire su ventana de tiempo, entonces </li><li>  permanece con la misma prioridad. </li></ul><br>  <b>Ejemplo 1: una sola tarea de larga duraci√≥n</b> <br><br>  Como puede ver en este ejemplo, la tarea de admisi√≥n se plantea con la m√°xima prioridad.  Despu√©s de una ventana de tiempo de 10 ms, el planificador reduce la prioridad del proceso.  Despu√©s de la pr√≥xima ventana de tiempo, la tarea finalmente cae a la prioridad m√°s baja en el sistema, donde permanece. <br><br><img src="https://habrastorage.org/webt/jl/wi/fg/jlwifg8osgxds9bpyftx2aoa9pa.png"><br><br>  <b>Ejemplo 2: trajeron una tarea corta</b> <br><br>  Ahora veamos un ejemplo de c√≥mo MLFQ intentar√° acercarse a SJF.  Hay dos tareas en este ejemplo: A, que es una tarea de larga duraci√≥n que ocupa constantemente la CPU, y B, que es una tarea interactiva corta.  Suponga que A ya trabaj√≥ durante alg√∫n tiempo cuando llega la tarea B. <br><br><img src="https://habrastorage.org/webt/hq/dp/ou/hqdpouigzrlqbjbhwnvgv9e8mxc.png"><br><br>  En este gr√°fico, los resultados del script son visibles.  La tarea A, como cualquier tarea que use una CPU, est√° en la parte inferior.  La tarea B llegar√° a T = 100 y se colocar√° en la cola con la m√°xima prioridad.  Como el tiempo de su trabajo es corto, terminar√° antes de llegar a la √∫ltima etapa. <br><br>  A partir de este ejemplo, uno debe comprender el objetivo principal del algoritmo: dado que el algoritmo no conoce una tarea larga o corta, en primer lugar se supone que la tarea es corta y le da la m√°xima prioridad.  Si esta es una tarea realmente corta, se completar√° r√°pidamente, de lo contrario, si es una tarea larga, se mover√° lentamente hacia abajo en prioridad y pronto demostrar√° que es una tarea realmente larga que no requiere una respuesta. <br><br>  <b>Ejemplo 3: ¬øQu√© pasa con las E / S?</b> <br><br>  Ahora eche un vistazo al ejemplo de E / S.  Como se indica en la regla 4b, si un proceso libera un procesador sin utilizar completamente su tiempo de procesador, entonces permanece en el mismo nivel de prioridad.  La intenci√≥n de esta regla es bastante simple: si una tarea interactiva realiza muchas operaciones de E / S, por ejemplo, esperando que un usuario presione una tecla o un mouse, dicha tarea liberar√° el procesador antes de la ventana asignada.  No quisi√©ramos omitir dicha tarea por prioridad y, por lo tanto, permanecer√° en el mismo nivel. <br><br><img src="https://habrastorage.org/webt/md/oa/f_/mdoaf_yf81n7xvy-j_bdo6hvbmm.png"><br><br>  Este ejemplo muestra c√≥mo funcionar√° el algoritmo con dichos procesos: una tarea interactiva B, que necesita una CPU durante solo 1 ms antes de realizar el proceso de E / S, y una tarea larga A, que usa la CPU todo el tiempo. <br><br>  MLFQ mantiene el proceso B con la m√°xima prioridad, ya que contin√∫a todo el tiempo. <br>  liberar la CPU.  Si B es una tarea interactiva, entonces el algoritmo logr√≥ su objetivo de lanzar tareas interactivas r√°pidamente. <br><br>  <b>Problemas con el algoritmo MLFQ actual</b> <br><br>  En los ejemplos anteriores, creamos la versi√≥n base de MLFQ.  Y parece que hace su trabajo bien y honestamente, distribuyendo honestamente el tiempo del procesador entre tareas largas y permitiendo que las tareas cortas o las tareas de acceso intensivo a E / S funcionen r√°pidamente.  Lamentablemente, este enfoque contiene varios problemas graves. <br><br>  <b>En primer lugar</b> , el problema del hambre: si hay muchas tareas interactivas en el sistema, consumir√°n todo el tiempo del procesador y, por lo tanto, no se podr√° ejecutar una sola tarea larga (se est√°n muriendo de hambre). <br><br>  <b>En segundo lugar</b> , los usuarios inteligentes pueden escribir sus programas para que <br>  enga√±ar al planificador.  El truco es hacer algo para hacer <br>  planificador para dar al proceso m√°s tiempo de procesador.  Algoritmo que <br>  descrito anteriormente es bastante vulnerable a tales ataques: antes de que la ventana de tiempo sea pr√°cticamente <br>  finalizado, debe realizar una operaci√≥n de E / S (para algunos, sin importar qu√© archivo) <br>  y as√≠ liberar la CPU.  Este comportamiento te permitir√° permanecer en el mismo <br>  la cola en s√≠ misma y nuevamente obtiene un mayor porcentaje de tiempo de CPU.  Si hecho <br>  esto es correcto (por ejemplo, el 99% del tiempo de la ventana antes de liberar la CPU) <br>  tal tarea puede simplemente monopolizar el procesador. <br><br>  Finalmente, un programa puede cambiar su comportamiento con el tiempo.  Esas tareas <br>  qui√©n us√≥ la CPU puede volverse interactivo.  En nuestro ejemplo, similar <br>  las tareas no recibir√°n el tratamiento adecuado del planificador, como otros recibir√≠an <br>  (inicial) tareas interactivas. <br><br>  <u>Pregunta a la audiencia: ¬øqu√© ataques al planificador podr√≠an realizarse en el mundo moderno?</u> <u><br></u> <br><h4>  Intento 2: Elevar la prioridad </h4><br><br>  Tratemos de cambiar las reglas y ver si podemos evitar problemas con <br>  ayuno  ¬øQu√© podr√≠amos hacer para asegurar que <br>  Las tareas de la CPU tendr√°n su tiempo (aunque no sea por mucho tiempo). <br>  Como una soluci√≥n simple al problema, puede ofrecer peri√≥dicamente <br>  aumentar la prioridad de todas esas tareas en el sistema.  Hay muchas formas <br>  para lograr esto, intentemos implementar como ejemplo algo simple: traducir <br>  todas las tareas a la vez en la m√°s alta prioridad, de ah√≠ la nueva regla: <br><ul><li>  <b>Regla 5</b> : Despu√©s de un cierto per√≠odo de S, transfiera todas las tareas en el sistema a la m√°xima prioridad. </li></ul><br>  Nuestra nueva regla resuelve dos problemas a la vez.  Primero, los procesos <br>  garantizado para no morir de hambre: las tareas de mayor prioridad compartir√°n <br>  tiempo de procesador de acuerdo con el algoritmo RR y, por lo tanto, todos los procesos recibir√°n <br>  tiempo de procesador  En segundo lugar, si hay alg√∫n proceso que utiliz√≥ anteriormente <br>  solo el procesador se vuelve interactivo, entonces permanecer√° en l√≠nea con el m√°s alto <br>  prioridad despu√©s de una vez recibir√° un aumento de prioridad al m√°s alto. <br>  Considera un ejemplo.  En este escenario, considere un proceso usando <br><img src="https://habrastorage.org/webt/cx/te/ll/cxtellydeep0hkgrqfiypt-zqq4.png"><br><br>  CPU y dos procesos cortos interactivos.  A la izquierda de la figura, la figura muestra el comportamiento sin aumentar la prioridad y, por lo tanto, la tarea larga comienza a morir de hambre despu√©s de que llegan dos tareas interactivas al sistema.  En la figura de la derecha, cada 50 ms aumenta la prioridad y, por lo tanto, se garantiza que todos los procesos recibir√°n tiempo de procesador y se iniciar√°n peri√≥dicamente.  50ms en este caso se toma como ejemplo, en realidad este n√∫mero es algo mayor. <br>  Obviamente, la adici√≥n de tiempo para un aumento peri√≥dico en S conduce a <br>  pregunta l√≥gica: ¬øqu√© valor se debe establecer?  Uno de los honrados <br>  Los ingenieros de sistemas John Ousterhout llamaron cantidades similares en sistemas como voo-doo <br>  constante, porque de alguna manera exig√≠an magia negra para corregir <br>  exponiendo  Y, desafortunadamente, S tiene ese aroma.  Si configura el valor tambi√©n <br>  grandes tareas largas comenzar√°n a morir de hambre.  Y si establece el valor demasiado bajo, <br>  Las tareas interactivas no recibir√°n el tiempo de procesador adecuado. <br><br><h4>  Intento 3: Mejor contabilidad </h4><br><br>  Ahora tenemos un problema m√°s que debe resolverse: c√≥mo no <br>  dejar enga√±ar a nuestro planificador?  Los culpables de esta oportunidad son <br>  reglas 4a, 4b, que permiten que la tarea mantenga prioridad, liberando el procesador <br>  antes de la expiraci√≥n del tiempo asignado.  ¬øC√≥mo lidiar con esto? <br>  La soluci√≥n en este caso puede considerarse la mejor contabilidad del tiempo de CPU en cada <br>  Nivel MLFQ.  En lugar de olvidar el tiempo que el programa us√≥ <br>  procesador para el per√≠odo asignado, debe considerar y guardarlo.  Despues <br>  el proceso ha gastado el tiempo asignado para que se reduzca al siguiente <br>  nivel de prioridad  Ahora, no importa c√≥mo el proceso use su tiempo, c√≥mo <br>  computaci√≥n constante en el procesador o tantas llamadas.  De esta manera <br>  La regla 4 debe reescribirse de la siguiente manera: <br><br><ul><li>  <b>Regla 4</b> : despu√©s de que la tarea haya agotado el tiempo asignado en la cola actual (independientemente de cu√°ntas veces haya liberado la CPU), la prioridad de dicha tarea disminuye (baja por la cola). </li></ul><br>  Veamos un ejemplo: <br><img src="https://habrastorage.org/webt/je/rs/kw/jerskwy36cewrg6auapm-dal7iu.png">  " <br><br>  La figura muestra lo que sucede si intenta enga√±ar al planificador, c√≥mo <br>  si fuera con las reglas anteriores 4a, 4b, obtenemos el resultado a la izquierda.  Feliz nuevo <br>  La regla es el resultado a la derecha.  Antes de la protecci√≥n, cualquier proceso podr√≠a invocar E / S hasta su finalizaci√≥n y <br>  as√≠ dominar la CPU, despu√©s de habilitar la protecci√≥n, independientemente del comportamiento <br>  E / S, seguir√° bajando por la l√≠nea y, por lo tanto, no ser√° deshonesto <br>  tomar posesi√≥n de los recursos de la CPU. <br><br><h4>  Mejora de MLFQ y otros problemas </h4><br>  Con las mejoras anteriores, surgen nuevos problemas: uno de los principales <br>  preguntas: ¬øc√≥mo parametrizar tal programador?  Es decir  Cuanto debe ser <br>  r√°fagas?  ¬øCu√°l deber√≠a ser el tama√±o de la ventana del programa dentro de la cola?  Como <br>  La prioridad del programa a menudo debe aumentarse para evitar el hambre y <br>  tener en cuenta los cambios en el comportamiento del programa?  Para estas preguntas, no es f√°cil <br>  respuesta y solo experimentos con cargas y configuraci√≥n posterior <br>  El planificador puede conducir a un equilibrio satisfactorio. <br><br>  Por ejemplo, la mayor√≠a de las implementaciones de MLFQ le permiten asignar diferentes <br>  intervalos de tiempo a diferentes colas.  Colas de alta prioridad generalmente <br>  Se asignan intervalos cortos.  Estas colas consisten en tareas interactivas, <br>  cambiar entre lo que es bastante sensible y deber√≠a tomar 10 o menos <br>  ms  Por el contrario, las colas de baja prioridad consisten en tareas largas que utilizan <br>  CPU  Y en este caso, los intervalos de tiempo largos se ajustan muy bien (100 ms). <br><img src="https://habrastorage.org/webt/p4/1j/-d/p41j-d9spzwfok9w7xmkcewqgrq.png"><br><br>  En este ejemplo, hay 2 tareas que funcionaron en la cola de alta prioridad 20 <br>  ms, roto por windows durante 10 ms.  40 ms en la cola media (ventana a 20 ms) y en prioridad baja <br>  El tiempo de espera se convirti√≥ en 40 ms, donde las tareas completaron su trabajo. <br><br>  La implementaci√≥n de Solaris OS MLFQ es una clase de programadores de tiempo compartido. <br>  El planificador proporciona un conjunto de tablas que determinan exactamente c√≥mo deber√≠a <br>  cambiar la prioridad del proceso sobre su vida, cu√°l deber√≠a ser el tama√±o <br>  la ventana seleccionada y con qu√© frecuencia necesita elevar las prioridades de la tarea.  Administrador <br>  los sistemas pueden interactuar con esta tabla y hacer que el planificador se comporte <br>  de una manera diferente  Por defecto, hay 60 colas incrementales en esta tabla. <br>  tama√±o de ventana de 20 ms (prioridad alta) a varios cientos de ms (prioridad m√°s baja), y <br>  Tambi√©n con un impulso de todas las tareas una vez por segundo. <br><br>  Otros planificadores de MLFQ no usan una tabla ni ninguna <br>  las reglas que se describen en esta conferencia, por el contrario, calculan prioridades utilizando <br>  f√≥rmulas matem√°ticas  Entonces, por ejemplo, el planificador en FreeBSD usa la f√≥rmula para <br>  calcular la prioridad actual de una tarea en funci√≥n de cu√°nto el proceso <br>  CPU utilizada  Adem√°s, el uso de la CPU decae con el tiempo, y as√≠ <br>  Por lo tanto, el aumento de prioridad ocurre de manera algo diferente a lo descrito anteriormente.  Es asi <br>  llamados algoritmos de descomposici√≥n.  Desde la versi√≥n 7.1, FreeBSD usa el planificador ULE. <br><br>  Finalmente, muchos planificadores tienen otras caracter√≠sticas.  Por ejemplo, algunos <br>  los planificadores reservan los niveles m√°s altos para el sistema operativo y as√≠ <br>  de esta manera, ning√∫n proceso de usuario puede obtener la m√°xima prioridad en <br>  sistema  Algunos sistemas le permiten dar consejos para ayudar. <br>  el planificador para establecer prioridades correctamente.  Por ejemplo, usando el comando <b>nice</b> <br>  puede aumentar o disminuir la prioridad de la tarea y as√≠ aumentar o <br>  reducir las posibilidades del programa para el tiempo de procesador. <br><h3>  MLFQ: Resumen </h3><br>  Describimos un enfoque de planificaci√≥n llamado MLFQ.  Su nombre <br>     ‚Äî         <br>    . <br>     : <br><ul><li> <b>Rule1</b> :  () &gt; (),     (  ) </li><li> <b>Rule2</b> :  () = (),     RR </li><li> <b>Rule3</b> :     ,       . </li><li> <b>Rule4</b> :            (       CPU)     (   ). </li><li> <b>Rule5</b> :     S        . </li></ul><br> MLFQ     ‚Äî       <br>   ,        <br>  .          ‚Äî      (SJF, STCF)    , <br>  CPU .   ,  BSD   , <br> Solaris, Windows, Mac        <br> MLFQ    . <br><h4>  : </h4><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manpages.debian.org/stretch/manpages/sched.7.en.html</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en.wikipedia.org/wiki/Scheduling_</a> (computing) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pages.lip6.fr/Julia.Lawall/atc18-bouron.pdf</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.usenix.org/legacy/event/bsdcon03/tech/full_papers/roberson/roberson.pdf</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chebykin.org/freebsd-process-scheduling</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450116/">https://habr.com/ru/post/450116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450104/index.html">Muy dif√≠cil y muy interesante: comunidades de TI en TechTrain</a></li>
<li><a href="../450106/index.html">El proyecto de la organizaci√≥n de construcci√≥n y reconstrucci√≥n en condiciones de hacinamiento en el sitio de construcci√≥n SPDS</a></li>
<li><a href="../450110/index.html">Patentes de dise√±o: segunda parte (ejemplos de Microsoft, Snapchat, Samsung, Netflix, Airbnb, Tinder)</a></li>
<li><a href="../450112/index.html">Eh, ¬øqu√© pas√≥ con las maletas? En el ejemplo de una maleta-scooter infantil ZINC</a></li>
<li><a href="../450114/index.html">Sobre lo que hemos implementado en EWM gracias a tu consejo</a></li>
<li><a href="../450118/index.html">Transmita la pantalla a m√∫ltiples dispositivos a trav√©s de la red</a></li>
<li><a href="../450120/index.html">Busque im√°genes similares, analizando un solo algoritmo</a></li>
<li><a href="../450122/index.html">Startup Digest: Genetics (enero - marzo 2019)</a></li>
<li><a href="../450124/index.html">Configuraci√≥n de mapas OsmAnd de la capa de mapa de calor de Strava</a></li>
<li><a href="../450126/index.html">La puerta trasera y el encriptador Buhtrap se distribuyeron usando Yandex.Direct</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>