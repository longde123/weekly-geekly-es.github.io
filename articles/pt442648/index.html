<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèø üè• üöì Ir mecanismos de aloca√ß√£o üõåüèø üêøÔ∏è üè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando tentei entender como as ferramentas de aloca√ß√£o de mem√≥ria no Go funcionam, o que eu queria lidar parecia uma caixa preta misteriosa. Como em q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ir mecanismos de aloca√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442648/">  Quando tentei entender como as ferramentas de aloca√ß√£o de mem√≥ria no Go funcionam, o que eu queria lidar parecia uma caixa preta misteriosa.  Como em qualquer outra tecnologia, a coisa mais importante aqui est√° oculta por tr√°s de muitas camadas de abstra√ß√µes, pelas quais voc√™ precisa passar para entender alguma coisa. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/tv/0k/gh/tv0kghio2zhsc-og7bjd-mtl41q.jpeg"></a> <br><br>  O autor do material, cuja tradu√ß√£o estamos publicando, decidiu chegar ao fundo dos meios de aloca√ß√£o de mem√≥ria no Go e falar sobre isso. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mem√≥ria f√≠sica e virtual</font> </h2><br>  Todos os meios para alocar mem√≥ria precisam trabalhar com o espa√ßo de endere√ßo da mem√≥ria virtual, que √© controlada pelo sistema operacional.  Vamos ver como a mem√≥ria funciona, come√ßando no n√≠vel mais baixo - com c√©lulas de mem√≥ria. <br>  Veja como imaginar uma c√©lula RAM. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e22/5e5/74c/e225e574c2649eb0bf9f5dd9cb1edadb.png"></div><br>  <i><font color="#999999">Layout da c√©lula de mem√≥ria</font></i> <br><br>  Se, muito simplificado, imaginar uma c√©lula de mem√≥ria e o que a rodeia, obtemos o seguinte: <br><br><ol><li>  A linha de endere√ßo (o transistor atua como um comutador) √© o que d√° acesso ao capacitor (linha de dados). </li><li>  Quando um sinal aparece na linha de endere√ßo (linha vermelha), a linha de dados permite gravar dados na c√©lula de mem√≥ria, ou seja, carregar o capacitor, o que possibilita armazenar um valor l√≥gico correspondente a 1 nele. </li><li> Quando n√£o h√° sinal na linha de endere√ßo (linha verde), o capacitor √© isolado e sua carga n√£o muda.  Para gravar na c√©lula 0, voc√™ deve selecionar seu endere√ßo e enviar um 0 l√≥gico pela linha de dados, ou seja, conectar a linha de dados com um sinal de menos, descarregando assim o capacitor. </li><li>  Quando o processador precisa ler o valor da mem√≥ria, o sinal √© enviado ao longo da linha de endere√ßo (a chave fecha).  Se o capacitor estiver carregado, o sinal passa pela linha de dados (1 √© lido), caso contr√°rio, o sinal n√£o passa pela linha de dados (0 √© lido). </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/33a/100/e8d33a100b5dbf94d34e794785670f24.png"></div><br>  <i><font color="#999999">O esquema de intera√ß√£o da mem√≥ria f√≠sica e do processador</font></i> <br><br>  O barramento de dados √© respons√°vel pelo transporte de dados entre o processador e a mem√≥ria f√≠sica. <br><br>  Agora vamos falar sobre a linha de endere√ßo e os bytes endere√ß√°veis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/e38/542/d24e38542de230b449750b26641f5e8c.png"></div><br>  <i><font color="#999999">Linhas de endere√ßo de barramento entre o processador e a mem√≥ria f√≠sica</font></i> <br><br><ol><li>  Cada byte na RAM recebe um identificador num√©rico (endere√ßo) exclusivo.  Note-se que o n√∫mero de bytes f√≠sicos presentes na mem√≥ria n√£o √© igual ao n√∫mero de linhas de endere√ßo. </li><li>  Cada linha de endere√ßo pode especificar um valor de 1 bit, indicando um bit no endere√ßo de um determinado byte. </li><li>  Nosso circuito possui 32 linhas de endere√ßo.  Como resultado, cada byte endere√ß√°vel usa um n√∫mero de 32 bits como endere√ßo.  [00000000000000000000000000000000] - o menor endere√ßo de mem√≥ria.  [1111111111111111111111111111111111] - o endere√ßo de mem√≥ria mais alto. </li><li>  Como cada byte possui um endere√ßo de 32 bits, nosso espa√ßo de endere√ßo consiste em 2 <sup>32</sup> bytes endere√ß√°veis ‚Äã‚Äã(4 GB). </li></ol><br>  Como resultado, verifica-se que o n√∫mero de bytes endere√ß√°veis ‚Äã‚Äãdepende do n√∫mero total de linhas de endere√ßo.  Por exemplo, se houver 64 linhas de endere√ßo (processadores x86-64), √© poss√≠vel endere√ßar 2 <sup>64</sup> bytes (16 exabytes) de mem√≥ria, mas a maioria das arquiteturas que usam ponteiros de 64 bits na verdade usa linhas de endere√ßo de 48 bits (AMD64) e linhas de endere√ßo de 42 bits (Intel), que teoricamente permitem que os computadores sejam equipados com 256 terabytes de mem√≥ria f√≠sica (o Linux permite, na arquitetura x86-64, ao usar p√°ginas de endere√ßo de n√≠vel 4, alocar at√© 128 TB de espa√ßo de endere√ßo para processos, o Windows permite alocar at√© 192 TB). <br>  Como o tamanho da RAM f√≠sica √© limitado, cada processo √© executado em sua pr√≥pria "caixa de areia" - no chamado "espa√ßo de endere√ßo virtual", chamado mem√≥ria virtual. <br><br>  Os endere√ßos de bytes no espa√ßo de endere√ßo virtual n√£o correspondem aos endere√ßos que o processador usa para acessar a mem√≥ria f√≠sica.  Como resultado, precisamos de um sistema que nos permita converter endere√ßos virtuais em f√≠sicos.  Veja como s√£o os endere√ßos de mem√≥ria virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/09b/354/9d009b354ada519bf1280ea96e139e64.jpg"></div><br>  <i><font color="#999999">Representa√ß√£o de espa√ßo de endere√ßo virtual</font></i> <br><br>  Como resultado, quando o processador executa uma instru√ß√£o que se refere a um endere√ßo de mem√≥ria, a primeira etapa √© converter o endere√ßo l√≥gico em um endere√ßo linear.  Essa convers√£o √© realizada pela unidade de gerenciamento de mem√≥ria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/330/ba9/56a330ba9d27daeb5737e013c0c15156.png"></div><br>  <i><font color="#999999">Representa√ß√£o simplificada do relacionamento entre mem√≥ria virtual e f√≠sica</font></i> <br><br>  Como os endere√ßos l√≥gicos s√£o grandes demais para serem convenientes para trabalhar com eles separadamente (isso depende de v√°rios fatores), a mem√≥ria √© organizada em estruturas chamadas p√°ginas.  Nesse caso, o espa√ßo de endere√ßo virtual √© dividido em pequenas √°reas, p√°ginas, que na maioria dos sistemas operacionais t√™m 4 KB de tamanho, embora geralmente esse tamanho possa ser alterado.  Essa √© a menor unidade de gerenciamento de mem√≥ria da mem√≥ria virtual.  A mem√≥ria virtual n√£o armazena nada, simplesmente define a correspond√™ncia entre o espa√ßo de endere√ßo do programa e a mem√≥ria f√≠sica. <br><br>  Os processos veem apenas endere√ßos de mem√≥ria virtual.  O que acontece se um programa precisar de mais mem√≥ria din√¢mica (tamb√©m chamada de mem√≥ria heap ou "heap")?  Aqui est√° um exemplo de c√≥digo assembler simples no qual a mem√≥ria alocada dinamicamente adicional √© solicitada ao sistema: <br><br><pre><code class="plaintext hljs">_start:        mov $12, %rax #    brk        mov $0, %rdi # 0 -  ,            syscall b0:        mov %rax, %rsi #  rsi    ,           mov %rax, %rdi #     ...        add $4, %rdi # ..  4 ,           mov $12, %rax #    brk        syscall</code> </pre> <br>  Aqui est√° como ele pode ser representado na forma de um diagrama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c22/962/904/c229629041c7612e254d89d146fcc4ef.png"></div><br>  <i><font color="#999999">Aumentar mem√≥ria alocada dinamicamente</font></i> <br><br>  O programa solicita mem√≥ria adicional usando a chamada do sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">brk</a> (sbrk / mmap e assim por diante).  O kernel atualiza as informa√ß√µes sobre mem√≥ria virtual, mas novas p√°ginas ainda n√£o foram apresentadas na mem√≥ria f√≠sica, e aqui h√° uma diferen√ßa entre a mem√≥ria virtual e a f√≠sica. <br><br><h2>  <font color="#3AC1EF">Alocador de mem√≥ria</font> </h2><br>  Depois que, em termos gerais, discutimos o trabalho com o espa√ßo de endere√ßo virtual, falamos sobre como solicitar mem√≥ria din√¢mica adicional (mem√≥ria na pilha), ser√° mais f√°cil falar sobre meios para alocar mem√≥ria. <br><br>  Se o heap tiver mem√≥ria suficiente para satisfazer nossas solicita√ß√µes de c√≥digo, o alocador de mem√≥ria poder√° executar essas solicita√ß√µes sem acessar o kernel.  Caso contr√°rio, ele precisar√° aumentar o tamanho do heap usando uma chamada do sistema (usando brk, por exemplo), enquanto solicita um grande bloco de mem√≥ria.  No caso do malloc, ‚Äúgrande‚Äù significa o tamanho descrito pelo par√¢metro <code>MMAP_THRESHOLD</code> , que, por padr√£o, √© de 128 Kb. <br><br>  No entanto, um alocador de mem√≥ria tem mais responsabilidades do que simplesmente alocar mem√≥ria.  Uma de suas responsabilidades mais importantes √© reduzir a fragmenta√ß√£o de mem√≥ria interna e externa e alocar blocos de mem√≥ria o mais r√°pido poss√≠vel.  Suponha que nosso programa execute sequencialmente solicita√ß√µes para alocar blocos cont√≠nuos de mem√≥ria usando uma fun√ß√£o do formul√°rio <code>malloc(size)</code> , ap√≥s o qual essa mem√≥ria √© liberada usando uma fun√ß√£o do formul√°rio <code>free(pointer)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a0/779/9448a077982dfb81e4c982c1228cad15.png"></div><br>  <i><font color="#999999">Demonstra√ß√£o de fragmenta√ß√£o externa</font></i> <br><br>  No diagrama anterior, na etapa p4, n√£o temos blocos de mem√≥ria localizados em sequ√™ncia suficientes para atender √† solicita√ß√£o de aloca√ß√£o de seis desses blocos, embora a quantidade total de mem√≥ria livre permita isso.  Essa situa√ß√£o leva √† fragmenta√ß√£o da mem√≥ria. <br><br>  Como reduzir a fragmenta√ß√£o da mem√≥ria?  A resposta a esta pergunta depende do algoritmo de aloca√ß√£o de mem√≥ria espec√≠fico, no qual a biblioteca base √© usada para trabalhar com mem√≥ria. <br><br>  Agora, veremos a ferramenta de aloca√ß√£o de mem√≥ria TCMalloc, na qual os mecanismos de aloca√ß√£o de mem√≥ria Go s√£o baseados. <br><br><h2>  <font color="#3AC1EF">TCMalloc</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O TCMalloc</a> √© baseado na id√©ia de dividir a mem√≥ria em v√°rios n√≠veis para reduzir a fragmenta√ß√£o da mem√≥ria.  No TCMalloc, o gerenciamento de mem√≥ria √© dividido em duas partes: trabalhando com a mem√≥ria de threads e trabalhando com heap. <br><br><h3>  <font color="#3AC1EF">‚ñç Mem√≥ria da thread</font> </h3><br>  Cada p√°gina da mem√≥ria √© dividida em uma sequ√™ncia de fragmentos de determinados tamanhos, selecionados de acordo com as classes de tamanho.  Isso reduz a fragmenta√ß√£o.  Como resultado, cada encadeamento tem √† sua disposi√ß√£o um cache para objetos pequenos, o que permite uma aloca√ß√£o muito eficiente de mem√≥ria para objetos menores ou iguais a 32 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/331/901/7c8/3319017c8657e4b75a25003357d4b4f4.png"></div><br>  <i><font color="#999999">Cache de fluxo</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç</font> </h3><br>  Um heap gerenciado pelo TCMalloc √© uma cole√ß√£o de p√°ginas na qual um conjunto de p√°ginas consecutivas pode ser representado como um intervalo de p√°ginas (extens√£o).  Quando voc√™ precisa alocar mem√≥ria para um objeto maior que 32 KB, o heap √© usado para alocar mem√≥ria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48c/f49/707/48cf497071e18b1539c18e6c2057e85d.png"></div><br>  <i><font color="#999999">Empilhe e trabalhe com p√°ginas</font></i> <br><br>  Quando n√£o h√° espa√ßo suficiente para colocar pequenos objetos na mem√≥ria, eles recorrem √† pilha de mem√≥ria.  Se o heap n√£o tiver mem√≥ria livre suficiente, ser√° solicitada mem√≥ria adicional ao sistema operacional. <br><br>  Como resultado, o modelo apresentado de trabalho com mem√≥ria suporta o pool de mem√≥ria do espa√ßo do usu√°rio; seu uso melhora significativamente a efici√™ncia da aloca√ß√£o e libera√ß√£o de mem√≥ria. <br><br>  Deve-se observar que a ferramenta de aloca√ß√£o de mem√≥ria Go foi originalmente baseada no TCMalloc, mas difere um pouco dela. <br><br><h2>  <font color="#3AC1EF">Alocador de mem√≥ria Go</font> </h2><br>  Sabemos que o tempo de execu√ß√£o do Go planeja executar goroutines em processadores l√≥gicos.  Da mesma forma, a vers√£o do TCMalloc usada pelo Go divide as p√°ginas de mem√≥ria em blocos cujos tamanhos correspondem a determinadas classes de tamanho das quais 67 existem. <br><br>  Se voc√™ n√£o est√° familiarizado com o planejador Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> pode ler sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/824/d5c/0df/824d5c0dfac562629662650924292583.png"></div><br>  <i><font color="#999999">Ir para classes de tamanho</font></i> <br><br>  Como o tamanho m√≠nimo da p√°gina no Go √© 8192 bytes (8 Kb), se essa p√°gina for dividida em blocos de 1 KB, obteremos 8 desses blocos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/150/865/6ba/1508656ba4a4c009624468a164d41e5b.png"></div><br>  <i><font color="#999999">Um tamanho de p√°gina de 8 KB √© dividido em blocos correspondentes a um tamanho de classe de 1 KB</font></i> <br><br>  Sequ√™ncias de p√°ginas semelhantes no Go s√£o controladas usando uma estrutura chamada mspan. <br><br><h3>  <font color="#3AC1EF">PanEstrutura mspan</font> </h3><br>  A estrutura mspan √© uma lista duplamente vinculada, um objeto que cont√©m o endere√ßo inicial da p√°gina, informa√ß√µes sobre o tamanho da p√°gina e o n√∫mero de p√°ginas inclu√≠das nela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbd/cae/fc0/dbdcaefc090a443369d33c2cde7e06ae.png"></div><br>  <i><font color="#999999">Estrutura Mspan</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç estrutura do mcache</font> </h3><br>  Como o TCMalloc, o Go fornece a cada processador l√≥gico um cache de encadeamento local, conhecido como mcache.  Como resultado, se a goroutine precisar de mem√≥ria, poder√° obt√™-la diretamente do mcache.  Para fazer isso, voc√™ n√£o precisa executar bloqueios, pois a qualquer momento, apenas uma goroutin √© executada em um processador l√≥gico. <br><br>  A estrutura mcache cont√©m, na forma de um cache, estruturas mspan de v√°rias classes de tamanho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/7bb/459/4787bb4597d56f89b474189c5e86441b.png"></div><br>  <i><font color="#999999">Intera√ß√£o entre processador l√≥gico, mcache e mspan no Go</font></i> <br><br>  Como cada processador l√≥gico possui seu pr√≥prio mcache, n√£o h√° necessidade de bloqueios ao alocar mem√≥ria do mcache. <br><br>  Cada classe de tamanho pode ser representada por um dos seguintes objetos: <br><br><ul><li>  Um objeto de digitaliza√ß√£o √© um objeto que cont√©m um ponteiro. </li><li>  Um objeto noscan √© um objeto no qual n√£o h√° ponteiro. </li></ul><br>  Um dos pontos fortes dessa abordagem √© que, quando a coleta de lixo √© realizada, os objetos noscan n√£o precisam ser contornados, pois n√£o cont√™m objetos para os quais a mem√≥ria est√° alocada. <br><br>  O que entra no mcache?  Objetos cujo tamanho n√£o exceda 32 KB v√£o diretamente para o mcache usando mspan da classe de tamanho correspondente. <br><br>  O que acontece se o mcache n√£o tiver uma c√©lula livre?  Em seguida, eles obt√™m um novo mspan da classe de tamanho desejada da lista de objetos mspan chamados mcentral. <br><br><h3>  <font color="#3AC1EF">Estrutura central</font> </h3><br>  A estrutura mcentral coleta todos os intervalos de p√°ginas de uma classe de tamanho espec√≠fica.  Cada objeto mcentral cont√©m duas listas de objetos mspan. <br><br><ol><li>  Lista de objetos mspan nos quais n√£o h√° objetos livres ou aqueles que est√£o no mcache. </li><li>  Lista de objetos mspan que possuem objetos livres. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/b88/7f9/6dcb887f9c717bb1f24735daa4b50aa7.png"></div><br>  <i><font color="#999999">Estrutura central</font></i> <br><br>  Cada estrutura mcentral existe dentro da estrutura mheap. <br><br><h3>  <font color="#3AC1EF">Estrutura da pilha</font> </h3><br>  A estrutura mheap √© representada por um objeto que lida com o gerenciamento de heap no Go.  Existe apenas um objeto global que possui um espa√ßo de endere√ßo virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8e/b07/01b/c8eb0701bbe46523e2735e695db97115.png"></div><br>  <i><font color="#999999">Estrutura Mheap</font></i> <br><br>  Como voc√™ pode ver no diagrama acima, a estrutura mheap cont√©m uma matriz de estruturas mcentrais.  Essa matriz cont√©m estruturas centrais para todas as classes de tamanho. <br><br><pre> <code class="plaintext hljs">central [numSpanClasses]struct { mcentral mcentral   pad     [sys.CacheLineSize unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte }</code> </pre> <br>  Como temos uma estrutura mcentral para cada classe de tamanho, quando o mcache solicita a estrutura mspan do mcentral, um bloqueio √© aplicado no n√≠vel mcentral individual; como resultado, solicita√ß√µes de outros mcache que solicitam estruturas mspan de outros tamanhos podem ser atendidas ao mesmo tempo. <br><br>  O alinhamento (pad) garante que as estruturas mcentrais sejam separadas uma da outra pelo n√∫mero de bytes correspondentes ao valor <code>CacheLineSize</code> .  Como resultado, cada <code>mcentral.lock</code> possui sua pr√≥pria linha de cache, o que evita os problemas associados ao compartilhamento de mem√≥ria falsa. <br><br>  O que acontece se a lista central estiver vazia?  O mcentral recebe uma sequ√™ncia de p√°ginas do mheap para alocar fragmentos de mem√≥ria da classe de tamanho necess√°ria. <br><br><ul><li>  <code>free[_MaxMHeapList]mSpanList</code> √© uma matriz de spanList.  A estrutura mspan em cada spanList consiste em 1 a 127 p√°ginas (_MaxMHeapList - 1).  Por exemplo, free [3] √© uma lista vinculada de estruturas mspan contendo 3 p√°ginas.  A palavra "livre", neste caso, indica que estamos falando de uma lista vazia na qual a mem√≥ria n√£o est√° alocada.  Uma lista pode ser, ao contr√°rio de vazia, uma lista na qual a mem√≥ria est√° alocada (ocupada). </li><li>  <code>freelarge mSpanList</code> √© uma lista de estruturas gratuitas do mspan.  O n√∫mero de p√°ginas por elemento (ou seja, mspan) √© maior que 127. Para suportar esta lista, a estrutura de dados mtreap √© usada.  A lista de estruturas de mspan ocupadas √© chamada de busylarge. </li></ul><br>  Objetos maiores que 32 Kb s√£o considerados objetos grandes, a mem√≥ria para eles √© alocada diretamente do mheap.  As solicita√ß√µes para alocar mem√≥ria para esses objetos s√£o executadas usando um bloqueio, como resultado, em um determinado momento, uma solicita√ß√£o semelhante pode ser processada a partir de apenas um processador l√≥gico. <br><br><h2>  <font color="#3AC1EF">O processo de alocar mem√≥ria para objetos</font> </h2><br><ul><li>  Se o tamanho do objeto exceder 32 Kb, ele ser√° considerado grande, a mem√≥ria para ele ser√° alocada diretamente do mheap. </li><li>  Se o tamanho do objeto for menor que 16 Kb, o mecanismo mcache chamado tiny alocador ser√° usado. </li><li>  Se o tamanho do objeto estiver no intervalo de 16 a 32 Kb, descobrir√° qual classe de tamanho (sizeClass) usar, um bloco adequado ser√° alocado no mcache. </li><li>  Se n√£o houver blocos dispon√≠veis no sizeClass correspondentes ao mcache, o mcentral ser√° chamado. </li><li>  Se o mcentral n√£o tiver blocos livres, eles chamar√£o mheap e procurar√£o o mspan mais adequado.  Se o tamanho da mem√≥ria exigido pelo aplicativo for maior do que √© poss√≠vel alocar, o tamanho da mem√≥ria solicitada ser√° processado para que seja poss√≠vel retornar quantas p√°ginas forem necess√°rias pelo programa, tendo formado uma nova estrutura mspan. </li><li>  Se a mem√≥ria virtual do aplicativo ainda n√£o for suficiente, o sistema operacional ser√° acessado para um novo conjunto de p√°ginas (pelo menos 1 MB de mem√≥ria √© solicitado). </li></ul><br>  De fato, no n√≠vel do sistema operacional, o Go solicita a aloca√ß√£o de peda√ßos de mem√≥ria ainda maiores, chamados arenas.  A aloca√ß√£o simult√¢nea de grandes fragmentos de mem√≥ria permite encontrar um compromisso entre a quantidade de mem√≥ria alocada ao aplicativo e o caro acesso ao sistema operacional em termos de desempenho. <br><br>  A mem√≥ria solicitada no heap √© alocada na arena.  Considere esse mecanismo. <br><br><h2>  <font color="#3AC1EF">Mem√≥ria virtual</font> </h2><br>  D√™ uma olhada no uso da mem√≥ria com um programa simples escrito em Go: <br><br><pre> <code class="plaintext hljs">func main() {   for {} }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/4cd/dee/c334cddee46f32a66d3528b08deda48e.png"></div><br>  <i><font color="#999999">Informa√ß√µes do processo do programa</font></i> <br><br>  O espa√ßo de endere√ßo virtual de um programa t√£o simples √© de aproximadamente 100 MB, enquanto o √≠ndice RSS √© de apenas 696 Kb.  Primeiro, vamos tentar descobrir o motivo dessa discrep√¢ncia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/2a7/f41/f342a7f41d8ff7fbf3b5f081415c5ab4.png"></div><br>  <i><font color="#999999">Informa√ß√µes de mapa e smap</font></i> <br><br>  Aqui voc√™ pode ver as √°reas de mem√≥ria, cujo tamanho √© aproximadamente igual a 2 MB, 64 MB, 32 MB.  Que tipo de mem√≥ria √© essa? <br><br><h3>  <font color="#3AC1EF">‚ñçArena</font> </h3><br>  Acontece que a mem√≥ria virtual no Go consiste em um conjunto de arenas.  O tamanho da mem√≥ria inicial destinado ao heap corresponde a uma arena, ou seja, 64 MB (isso √© relevante para o Go 1.11.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dd/17e/ba9/9dd17eba9a4c5acf9371052d62d902d9.png"></div><br>  <i><font color="#999999">Tamanho atual da arena em v√°rios sistemas</font></i> <br><br>  Como resultado, a mem√≥ria necess√°ria para as necessidades atuais do programa √© alocada em pequenas por√ß√µes.  Esse processo come√ßa com uma arena de 64 MB. <br><br>  Esses indicadores num√©ricos sobre os quais estamos falando aqui n√£o devem ser tomados por alguns valores absolutos e inalterados.  Eles podem mudar.  Antes, por exemplo, a Go reservava um espa√ßo virtual cont√≠nuo e antecipadamente, em sistemas de 64 bits, o tamanho da arena era de 512 GB (√© interessante pensar no que acontece se a demanda de mem√≥ria real for t√£o grande que a solicita√ß√£o correspondente ser√° rejeitada pelo mmap?). <br><br>  De fato, chamamos um monte de arenas de monte.  No Go, as arenas s√£o percebidas como fragmentos de mem√≥ria, divididos em blocos de 8192 bytes (8 Kb) de tamanho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/927/7e0/55b9277e0c55876b1bbf11bb1b869c9e.png"></div><br>  <i><font color="#999999">Uma arena de 64 MB</font></i> <br><br>  Go tem mais alguns tipos de blocos - span e bitmap.  A mem√≥ria para eles √© alocada fora da pilha, eles armazenam metadados da arena.  Eles s√£o usados ‚Äã‚Äãprincipalmente na coleta de lixo. <br>  Aqui est√° um resumo geral de como os mecanismos de aloca√ß√£o de mem√≥ria funcionam no Go. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/61f/13f/b0161f13f6bc905731f0bfb339fd3a10.png"></div><br>  <i><font color="#999999">Descri√ß√£o geral dos mecanismos de aloca√ß√£o de mem√≥ria no Go</font></i> <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Em geral, pode-se notar que neste material descrevemos os subsistemas para trabalhar com a mem√≥ria Go em termos muito gerais.  A id√©ia principal do subsistema de mem√≥ria no Go √© alocar mem√≥ria usando v√°rias estruturas e caches de diferentes n√≠veis.  Isso leva em considera√ß√£o o tamanho dos objetos para os quais a mem√≥ria est√° alocada. <br><br>  A representa√ß√£o de um √∫nico bloco de endere√ßos de mem√≥ria cont√≠nua recebidos do sistema operacional na forma de uma estrutura multin√≠vel aumenta a efici√™ncia do mecanismo de aloca√ß√£o de mem√≥ria devido ao fato de que essa abordagem evita o bloqueio.  A aloca√ß√£o de recursos, levando em considera√ß√£o o tamanho dos objetos que precisam ser armazenados na mem√≥ria, reduz a fragmenta√ß√£o e, ap√≥s liberar mem√≥ria, permite acelerar a coleta de lixo. <br><br>  <b>Caros leitores!</b>  Voc√™ encontrou problemas causados ‚Äã‚Äãpelo mau funcionamento da mem√≥ria em programas escritos no Go? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442648/">https://habr.com/ru/post/pt442648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442638/index.html">Escalonamento de aplicativos Kubernetes com base nas m√©tricas do Prometheus</a></li>
<li><a href="../pt442640/index.html">Bug perfeito: usando confus√£o de tipo no Flash. Parte 1</a></li>
<li><a href="../pt442642/index.html">O que ler em mar√ßo: 22 novos livros para profissionais de marketing, gerentes, desenvolvedores e designers</a></li>
<li><a href="../pt442644/index.html">A maioria das habilidades que n√£o s√£o de programa√ß√£o aumentam o valor do desenvolvedor</a></li>
<li><a href="../pt442646/index.html">Redes Kubernetes: ingresso</a></li>
<li><a href="../pt442650/index.html">An√°lise e otimiza√ß√£o de aplicativos React</a></li>
<li><a href="../pt442652/index.html">Usando Fastify e Preact para prototipar aplicativos da Web rapidamente</a></li>
<li><a href="../pt442654/index.html">Mudando para Next.js e acelerando o carregamento da p√°gina inicial do manifold.co 7,5 vezes</a></li>
<li><a href="../pt442658/index.html">8 truques para trabalhar com CSS: paralaxe, rodap√© fixo e outros</a></li>
<li><a href="../pt442660/index.html">Matem√°tica reconciliando Newton com o mundo qu√¢ntico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>