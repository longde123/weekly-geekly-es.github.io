<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤝 🗺️ 👩‍✈️ iOS中的复杂显示集合：VKontakte feed示例中的问题和解决方案 🧓🏾 ⛹🏾 💇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好 我叫Sasha，我是制作VKontakte供稿的团队中的iOS开发人员。 现在，我将告诉您如何优化界面显示并解决与此相关的问题。 
 我想您可以想象什么是VK磁带。 在此屏幕上，您可以查看各种内容：文本，静态图片，GIF动画，嵌入式元素（视频和音乐）。 所有这些都应平稳显示，因此对解决方案的性...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS中的复杂显示集合：VKontakte feed示例中的问题和解决方案</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/481626/"><p> 你好 我叫Sasha，我是制作VKontakte供稿的团队中的iOS开发人员。 现在，我将告诉您如何优化界面显示并解决与此相关的问题。 <br> 我想您可以想象什么是VK磁带。 在此屏幕上，您可以查看各种内容：文本，静态图片，GIF动画，嵌入式元素（视频和音乐）。 所有这些都应平稳显示，因此对解决方案的性能提出了很高的要求。 </p><br><p> 现在，让我们看看存在哪些使用映射的标准方法以及应该考虑哪些限制或优点。 </p><br><p> 如果您喜欢听多于阅读，请在<a href="https://vk.com/video-147415323_456239051">此处查看</a>报告的录像。 </p><br><p><img src="https://habrastorage.org/webt/6u/np/1d/6unp1dycdkq5wxkhtv-6ixrmv-q.png"></p><a name="habracut"></a><br><h1 id="soderzhanie"> 目录内容 </h1><br><ol><li>布局描述和计算 <br>  1.1。 自动布局 <br>  1.2。 手动<code>frame</code>计算 </li><li> 文字大小计算 <br>  2.1。 计算<code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code>大小的标准方法 <br>  2.2。  <code>NSAttributedString</code> / <code>NSString</code>方法 <br>  2.3。 文字套件 <br>  2.4。 核心文字 </li><li>  VKontakte提要如何工作？ </li><li> 如何获得更好的性能 <br>  4.1为什么出现性能问题 <br>  4.2。 <code>CATransaction.commit</code> <br>  4.3。 渲染管线 <br>  4.4。 最脆弱的表演场所 </li><li> 测量工具 <br>  5.1。 金属系统痕迹 <br>  5.2。 我们在应用程序运行时修复代码中的性能下降 </li></ol><br><ul><li> 如何研究问题。 推荐建议 </li><li> 结论 </li><li> 信息来源 </li></ul><br><h1 id="1-opisanie-i-vychislenie-layout">  <strong>1.布局的描述和计算</strong> </h1><br><p> 首先，让我们回想一下如何使用常规工具创建可视界面结构（ <em>布局</em> ）。 为了节省空间，我们将不列出任何内容-我将仅列出解决方案并说明其功能。 </p><br><h2 id="11-auto-layout">  <strong>1.1。</strong>  <strong>自动布局</strong> </h2><br><p> 在iOS中创建界面的最流行的方法也许是使用Apple的<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html">自动版式</a>布局系统。 它<a href="https://habr.com/ru/company/oleg-bunin/blog/437584/">基于</a> <a href="https://constraints.cs.washington.edu/cassowary/">Cassowary</a>算法，与<em>约束</em>概念密不可分<em>。</em> </p><br><p>  <em>现在，请记住，使用自动布局实现的界面是基于限制的。</em> </p><br><p>  <strong>该方法的特点：</strong> </p><br><ul><li> 约束系统转化为<a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">线性规划问题</a> 。 </li><li>  <a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">Cassowary</a>使用<a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581-%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4">单纯形法</a> <a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">解决了</a>由此产生的优化问题。 该方法具有指数渐近复杂性。 这是什么意思？ 随着布局中约束的数量增加，在最坏的情况下，计算速度可能呈指数下降。 </li><li>  <a href="https://developer.apple.com/documentation/uikit/uiview"><code>UIView</code></a>的最终<a href="https://developer.apple.com/documentation/uikit/uiview/1622621-frame"><code>frame</code></a>值是相应优化问题的解决方案。 </li></ul><br><p>  <strong>使用自动版式的好处：</strong> </p><br><ul><li>  <a href="https://developer.apple.com/videos/play/wwdc2018/220">在简单映射上，线性计算复杂性是可能的</a> 。 </li><li> 它是Apple的“本机”技术，它与所有标准元素都相处得很好。 </li><li> 开箱即用可与<code>UIView</code> 。 </li><li> 在Interface Builder中可用，它允许您在情节提要或XIB中描述布局。 </li><li> 即使在过渡期间，它也保证了最新的解决方案。 这意味着每个<code>UIView</code>的<code>frame</code>值始终<code>UIView</code> （！）解决实际布局任务的方法。 </li></ul><br><p> 该系统功能足以满足大多数显示器的需求。 但是它不适用于创建具有大量异构内容的磁带。 怎么了 </p><br><p>  <strong>重要的是要记住自动布局：</strong> </p><br><ul><li>  <em>仅在主线程中有效</em> 。 假设Apple工程师选择了Mainstream作为自动版式解决方案的同步点以及所有<code>UIView</code>的帧值。 否则，您将不得不在单独的线程中计算自动布局，并不断将值与主线程同步。 </li><li>  <em>它基于复杂的</em>算法，在最坏情况下的复杂度是指数级的，因此<em>它可以在复杂的表示形式上缓慢运行</em> 。 </li><li>  <em>在iOS 6.0中</em> <em>可用</em> 。 现在这几乎不是问题，但值得考虑。 </li></ul><br><p>  <em>结论：使用自动版式可以方便地创建不带集合或不带集合的显示，但元素之间没有复杂的关系。</em> </p><br><h2 id="12-raschyot-frame-vruchnuyu">  <strong>1.2。</strong>  <strong>手动<code>frame</code>计算</strong> </h2><br><p> 该方法的本质：我们自己计算所有<code>frame</code>值。 例如，我们实现方法<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews%3Flanguage%3Dobjc%2560"><code>layoutSubviews</code></a> ， <a href="https://developer.apple.com/documentation/uikit/uiview/1622625-sizethatfits"><code>sizeThatFits</code></a> 。 也就是说，在<code>layoutSubviews</code>自己安排所有子元素，在<code>sizeThatFits</code>我们计算与子元素和内容的所需位置相对应的大小。 </p><br><p> 它有什么作用？ 我们可以将复杂的计算传递到Background流，并且可以在Main流中执行相对简单的计算。 </p><br><p> 怎么了 您必须自己实施计算，很容易出错。 您还需要确保子代的位置与<code>sizeThatFits</code>返回的结果<code>sizeThatFits</code> 。 </p><br><p>  <strong>在以下情况下，自我评估是合理的：</strong> </p><br><ul><li> 我们已经遇到或预期会遇到自动版式性能限制。 </li><li> 该应用程序具有复杂的集合，并且很有可能使已开发的元素落入其单元格之一； </li><li> 我们要计算Background线程中元素的大小； </li><li> 我们会在屏幕上显示非标准元素，必须根据内容或环境不断重新计算其大小。 <br><img src="https://habrastorage.org/webt/tg/-l/nl/tg-lnlwfkzfzkqir1xdd2dun6la.png"></li></ul><br><p>  <strong>一个例子。</strong> 绘图工具提示会自动缩放以适合内容。 此任务中最有趣的部分是如何计算每个工具提示中文本的视觉大小。 </p><br><hr><br><h1 id="2-vychislenie-razmera-teksta">  <strong>2.计算文字大小</strong> </h1><br><p> 可以通过至少四种方式解决此问题，每种方式都依赖于其自己的方法集。 而且每种都有自己的特点和局限性。 </p><br><h2 id="21-standartnye-metody-vychisleniya-razmera-uilabeluitextviewuitextfield">  <strong>2.1。</strong>  <strong>计算<code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code>大小的标准方法</strong> </h2><br><p>  <a href="https://developer.apple.com/documentation/uikit/uiview/1622625-sizethatfits"><code>sizeThatFits</code></a> （默认在<a href="https://developer.apple.com/documentation/uikit/uiview/1622630-sizetofit"><code>sizeToFit</code></a> ）和<a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize"><code>intrinsicContentSize</code></a> （在Auto Layout中使用）方法返回视图内容的首选大小。 例如，在他们的帮助下，我们可以找出用<code>UILabel</code>编写的文本要占用多少空间。 </p><br><p> 缺点是这两种方法都只能在Main线程中工作-不能从后台调用它们。 </p><br><p>  <strong>标准方法什么时候有用？</strong> </p><br><ul><li> 如果我们已经使用<code>sizeToFit</code>或Auto Layout。 </li><li> 当显示中有标准元素时，我们希望在代码中获取它们的大小。 </li><li> 对于任何没有复杂集合的显示。 </li></ul><br><h2 id="22-metody-nsattributedstringnsstring">  <strong>2.2。</strong>  <strong>NSAttributedString / NSString方法</strong> </h2><br><p> 注意<a href="https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrect"><code>boundingRect</code></a>和<a href="https://developer.apple.com/documentation/foundation/nsstring/1531844-sizewithattributes%3Flanguage%3Dobjc"><code>sizeWithAttributes</code></a> 。 我不建议使用它们来读取<code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code>内容的大小。 我没有在文档信息中的任何地方找到<code>NSString</code>方法和<code>UIView</code>元素的布局方法基于同一代码（相同类）。 这两组类分别属于不同的框架：Foundation和UIKit。 也许您已经必须使boundingRect结果适合<code>UILabel</code>大小？ 还是您遇到<a href="https://stackoverflow.com/questions/15965525/how-to-get-nsstring-size-when-nsstring-includes-emojis"><code> NSString</code>不考虑表情符号大小</a>的事实？ 这些是您可以获得的问题。 </p><br><p> 我还将告诉您哪些类负责绘制<code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code>文本，但现在<code>UITextField</code>返回方法。 </p><br><p>  <strong>如果我们能够使用boundingRect和sizeWithAttributes是值得的：</strong> </p><br><ul><li> 我们使用<a href="https://developer.apple.com/documentation/foundation/nsstring/1529855-drawinrect"><code>drawInRect</code></a> ， <a href="https://developer.apple.com/documentation/foundation/nsstring/1533109-drawatpoint"><code>drawAtPoint</code></a>或<code>NSString</code> / <code>NSAttributedString</code>其他方法绘制非标准接口元素。 </li><li> 我们要考虑Background流中元素的大小。 同样，这仅在使用适当的渲染方法时。 </li><li> 在任意<a href="https://developer.apple.com/documentation/coregraphics/cgcontextref%3Flanguage%3Dobjc">上下文</a>上绘制，例如，在图像顶部显示一条线。 </li></ul><br><h2 id="23-textkit">  <strong>2.3。</strong>  <strong>文字套件</strong> </h2><br><p> 该工具由标准类<a href="https://developer.apple.com/documentation/uikit/nslayoutmanager"><code>NLayoutManager</code></a> ， <a href="https://developer.apple.com/documentation/uikit/nstextstorage"><code>NSTextStorage</code></a>和<a href="https://developer.apple.com/documentation/uikit/nstextcontainer"><code>NSTextContainer</code></a> 。 布局<code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code>也<a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html">基于</a>它们。 </p><br><p> 当您需要详细描述文本的位置并<a href="https://developer.apple.com/documentation/uikit/nstextcontainer/1444569-exclusionpaths">指出它将围绕哪些形状流动</a>时，TextKit十分方便。 </p><br><p><img src="https://habrastorage.org/webt/g8/m1/hi/g8m1hixof_ic7gpugctcvug9gsk.png"></p><br><p> 使用TextKit，您可以计算后台队列中界面元素的大小以及<a href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1403160-enumeratelinefragments">行/字符</a>的<a href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1403160-enumeratelinefragments"><code>  frame</code></a> 。 此外，该框架还允许您<a href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1403158-drawglyphs">绘制字形</a>并完全改变现有布局中文本的外观。 所有这些在iOS 7.0及更高版本中均有效。 </p><br><p>  <strong>当您需要：</strong> </p><br><ul><li> 显示具有复杂布局的文本； </li><li> 在图像上绘制文字； </li><li> 计算单个子字符串的大小； </li><li> 计算行数； </li><li> 使用<code>UITextView</code>的计算结果。 </li></ul><br><p> 我再次强调。 如果需要提前计算<code>UITextView</code>的大小，我们首先配置<code>NSLayoutManager</code> ， <code>NSTextStorage</code>和<code>NSTextContainer</code> <a href="https://developer.apple.com/documentation/uikit/uitextview/1618602-layoutmanager">实例</a> ，然后<a href="https://developer.apple.com/documentation/uikit/uitextview/1618602-layoutmanager">将这些实例传递给相应的</a> <code>UITextView</code> ，由它们负责布局。 只有这样，我们才能保证所有值的完全一致。 </p><br><p> 不要将TextKit与<code>UILabel</code>和<code>UITextField</code> ！ 对于它们（与<code>UITextView</code>不同），您无法配置<code>NSLayoutManager</code> ， <code>NSTextStorage</code>和<code>NSTextContainer</code> 。 </p><br><h2 id="24-coretext">  <strong>2.4。</strong>  <strong>核心文字</strong> </h2><br><p> 这是iOS中最低级别的文本工具。 它可以最大程度地控制字体，字符，线条，缩进的呈现。 而且，他和TextKit一样，允许您计算文本的印刷参数，例如基线和每行的框架大小。 </p><br><p> 如您所知，自由越多，责任就越高。 为了使用CoreText获得良好的结果，您需要能够使用其方法。 </p><br><p>  CoreText为大多数对象上的操作提供线程安全性。 这意味着我们可以从不同的线程调用其方法。 为了进行比较，使用TextKit时，您自己必须考虑方法调用的顺序。 </p><br><p> 在以下情况下应使用CoreText： </p><br><ul><li> 直接访问文本参数需要非常简单的低级API。 我必须马上说，对于绝大多数任务，TextKit的功能就足够了。 </li><li> 单独的行（ <a href="https://developer.apple.com/documentation/coretext/ctline-61l"><code>CTLine</code></a> ）和字符/元素有很多工作要做。 </li><li> 支持在iOS 6.0中很重要。 </li></ul><br><p> 对于VKontakte提要，我们使用了CoreText。 怎么了 就在我们实现处理文本的基本功能时，TextKit还不存在。 </p><br><hr><br><h1 id="3-kak-rabotaet-lenta-vkontakte">  <strong>3. VKontakte提要如何工作？</strong> </h1><br><p> 简要介绍我们如何从服务器接收数据，表单布局和显示。 </p><br><p><img src="https://habrastorage.org/webt/7g/kx/pt/7gkxptt4lpgjhjzbtyl3prm4vxy.png"></p><br><p> 首先，考虑在后台队列中执行的任务。 我们从服务器接收数据，对其进行处理并以声明方式描述随后的显示。 在这个阶段，我们还没有<code>UIView</code>实例，我们仅使用声明工具来设置future接口的规则和结构，这与<a href="https://developer.apple.com/xcode/swiftui/">SwiftUI</a>有点类似。 为了计算布局，我们在考虑当前限制（例如屏幕宽度）的情况下计算整个<code>frame</code> 。 我们更新当前的<code>dataSource</code> （ <code>dataSourceUpdate</code> ）。 在这里，我们在背景队列中准备图像：执行解压缩（有关更多详细信息，请参见性能部分），绘制阴影，倒圆角和其他效果。 </p><br><p> 现在转到主队列。  <code>dataSourceUpdate</code>接收到的<code>dataSourceUpdate</code>应用于<code>UITableView</code> ，重用并处理接口事件，填充单元格。 </p><br><p> 为了描述我们的布局系统，将需要另外一篇文章，但是在这里我将列出其主要功能： </p><br><ul><li> 声明性API是在其上构建接口的一组规则。 </li><li> 基本组件形成一棵树（ <code>nodes</code> ）。 </li><li> 基本组成部分的简单计算。 例如，在列表中，我们仅考虑所有子项的宽度/高度来计算<code>origin</code>偏移。 </li><li> 基本元素不会在层次结构中创建不必要的<code>UIView</code> “容器”。 例如，列表组件不会形成附加的<code>UIView</code> ，也不会为其添加子项。 相反，我们计算子项相对于父项（对于列表）元素的<code>origin</code>偏移。 </li><li> 使用CoreText进行低级文本管理。 </li></ul><br><p> 但是，即使采用这种方法，由于性能问题，磁带的观看可能仍然不够流畅。 怎么了 </p><br><p> 每个单元都有一个复杂的<code>nodes</code>层次结构。 而且，尽管基本元素不会创建不必要的容器，但功能区<code>UIView</code>仍显示许多<code>UIView</code> 。 并且在Main-queue中用“节点”（视图绑定）填充层次结构时，还有许多其他工作难以摆脱。 </p><br><p> 我们尝试将尽可能多的任务转移到“后台”队列中，现在继续这样做。 此外，必须考虑并规避CPU密集型和GPU密集型操作。 </p><br><hr><br><h1 id="4-kak-dobitsya-luchshey-proizvoditelnosti">  <strong>4.如何获得更好的性能</strong> </h1><br><p> 最简单的答案是卸载主线程，CPU和GPU。 为此，您需要深入了解iOS应用程序的工作。 最重要的是，找出问题的根源。 </p><br><h2 id="41-pochemu-voznikayut-problemy-s-proizvoditelnostyu">  <strong>4.1为什么出现性能问题</strong> </h2><br><p>  <strong>核心动画， <code>RunLoop</code>和滚动</strong> <br> 让我们记住该接口是如何在iOS中构建的。 在顶层，有<a href="https://developer.apple.com/documentation/uikit">UIKit</a> ，它负责与用户进行交互：处理手势，使应用程序从睡眠中唤醒以及类似的事情。 为了渲染界面，需要使用较低级别的工具- <a href="https://developer.apple.com/documentation/quartzcore">核心动画</a> （如macOS中一样）。 这是一个具有自己的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/CoreAnimationBasics/CoreAnimationBasics.html">接口描述系统</a>的框架。 考虑构建接口的基本概念。 </p><br><p> 对于Core Animation，整个界面都是<a href="https://developer.apple.com/documentation/quartzcore/calayer"><code>CALayer</code></a>层。 它们形成了一个渲染树，通过<a href="https://developer.apple.com/documentation/quartzcore/catransaction"><code>CATransaction</code></a>事务进行管理。 </p><br><p> 事务是一组更改，更准确地说，是有关在显示的界面中更新某些内容的信息。  <code>frame</code>或其他层参数的任何更改都属于当前事务。 如果还没有，系统本身会创建一个<a href="https://developer.apple.com/documentation/quartzcore/catransaction%3Flanguage%3Dobjc"><em>隐式事务</em></a> 。 </p><br><p> 几个事务形成一个堆栈。 新的更新属于堆栈的最高事务。 </p><br><p>  <em>现在我们知道要更新屏幕，我们需要使用层树的新参数来形成事务。</em> </p><br><p><img src="https://habrastorage.org/webt/84/2n/q5/842nq5jznw5i30ybdmqjrngqhiw.png"></p><br><p>  <strong>何时以及如何创建交易？</strong> 在我们的应用程序中，线程具有一个称为<a href="https://developer.apple.com/documentation/foundation/runloop"><code>RunLoop</code></a>的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">实体</a> 。 简单来说，这是一个无限循环，每次循环都会处理当前<a href="https://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B8%25D0%25BA%25D0%25BB_%25D1%2581%25D0%25BE%25D0%25B1%25D1%258B%25D1%2582%25D0%25B8%25D0%25B9">事件队列</a> 。 </p><br><p> 在Main线程中，需要<code>RunLoop</code>来处理来自不同来源的事件，例如接口（手势），计时器或从<a href="https://developer.apple.com/documentation/foundation/nsstream"><code>NSStream</code></a>和<a href="https://developer.apple.com/documentation/foundation/nsport"><code>NSPort</code></a>接收数据的处理程序。 </p><br><p><img src="https://habrastorage.org/webt/rd/f_/_m/rdf__mlll7k8wkiz6ijg8cnhhba.png"></p><br><p> 核心动画和<code>RunLoop</code> ？ 我们在上面发现，在更改“渲染树”中的图层属性时，系统会在必要时创建隐式事务（因此，我们无需调用<a href="https://developer.apple.com/documentation/quartzcore/catransaction/1448282-begin"><code>CATransaction.begin</code></a> 。开始重新绘制内容）。 此外，在每次<code>RunLoop</code>迭代时<code>RunLoop</code>系统都会自动关闭未完成的事务并应用所做的更改（ <a href="https://developer.apple.com/documentation/quartzcore/catransaction/1448255-commit"><code>CATransaction.commit</code></a> ）。 </p><br><p>  <strong>注意！</strong>  <code>RunLoop</code>的迭代次数不取决于屏幕的刷新率。 该循环根本不与屏幕同步，其工作方式类似于“ Endless <code>while()</code> ”。 </p><br><p> 现在，让我们看看滚动过程中Main线程的<code>RunLoop</code>迭代中发生了什么： </p><br><pre> <code class="plaintext hljs"> ... if (dispatchBlocks.count &gt; 0) { //   MainQueue doBlocks() } ... if (hasPanEvent) { handlePan() // UIScrollView change content offset -&gt; change bounds } ... if (hasCATransaction) { CATransaction.commit() } ...</code> </pre> <br><p> 首先，执行通过<a href="https://developer.apple.com/documentation/dispatch/1453057-dispatch_async"><code>dispatch_async</code></a> / <a href="https://developer.apple.com/documentation/dispatch/1452870-dispatch_sync"><code>dispatch_sync</code></a>添加到Main队列中的块。 并且在完成之前，程序不会继续执行以下任务。 </p><br><p> 接下来，UIKit开始处理用户的<a href="https://developer.apple.com/documentation/uikit/uipangesturerecognizer">手势</a> 。 作为处理此手势的一部分， <a href="https://developer.apple.com/documentation/uikit/uiscrollview/1619404-contentoffset"><code>UIScrollView.contentOffset</code></a>更改，因此， <a href="https://developer.apple.com/documentation/uikit/uiview/1622580-bounds"><code>UIScrollView.bounds</code></a>也会更改。 更改<a href="https://developer.apple.com/documentation/uikit/uiscrollview"><code>UIScrollView</code></a> （分别及其后代<a href="https://developer.apple.com/documentation/uikit/uitableview"><code>UITableView</code></a>和<a href="https://developer.apple.com/documentation/uikit/uicollectionview"><code>UICollectionView</code></a> ）的<code>bounds</code>更新内容的可见部分（ <code>viewport</code> ）。 </p><br><p> 在<code>RunLoop</code>迭代结束时，如果我们有未完成的事务，则会自动<code>commit</code>或<a href="https://developer.apple.com/documentation/quartzcore/catransaction/1448270-flush"><code>flush</code></a> 。 </p><br><p> 要检查它是如何工作的，请在适当的位置放置断点。 <br> 手势处理如下所示： </p><br><p><img src="https://habrastorage.org/webt/9c/kw/08/9ckw08wo9cay2nhxqm7qikm1n4w.png"></p><br><p> 这是<code>handlePan</code>之后的<code>CATransaction.commit</code> ： </p><br><p><img src="https://habrastorage.org/webt/0k/h0/xc/0kh0xcaq1yx04htvepmilc_przq.png"></p><br><p> 在滚动减速期间， <code>UIScrollView</code>创建一个<a href="https://developer.apple.com/documentation/quartzcore/cadisplaylink"><code>CADisplayLink</code></a>计时器，以将每秒对<code>contentOffset</code>的更改数量与屏幕的刷新率同步。 </p><br><p><img src="https://habrastorage.org/webt/42/gz/5x/42gz5xmatumqfi9jpcl3z1gabic.png"></p><br><p> 我们<code>CATransaction.commit</code> ， <code>CATransaction.commit</code>不在<code>RunLoop</code>迭代结束时发生，而是直接在<code>CADisplayLink</code>计时器的处理中<code>CADisplayLink</code> 。 但这无关紧要： </p><br><p><img src="https://habrastorage.org/webt/oq/si/f0/oqsif0ek7f1-w4f4lguvp_eun20.png"></p><br><h2 id="42-catransactioncommit">  <strong>4.2。</strong> <strong><code>CATransaction.commit</code></strong> </h2><br><p> 实际上， <code>CATransaction.commit</code>中的所有操作都在<code>CALayer</code>层上执行。  <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers%3Flanguage%3Dobjc"><code>layoutSublayers</code></a>具有自己的更新布局（ <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers%3Flanguage%3Dobjc"><code>layoutSublayers</code></a> ）和图像（ <a href="https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097262-draw"><code>drawLayer</code></a> ）的方法。 这些方法的默认实现导致<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410984-delegate">委托</a>方法调用。 通过将新的<code>UIView</code>实例添加到<code>UIView</code>层次结构中，我们隐式地将相应的图层添加到Core Animation图层层次结构中。 在这种情况下，默认情况下， <code>UIView</code>其图层的委托。 从调用堆栈中可以看到， <code>UIView</code>作为<code>CALayer</code>委托方法的实现的一部分，将执行其方法，将对此进行讨论： </p><br><p><img src="https://habrastorage.org/webt/oq/si/f0/oqsif0ek7f1-w4f4lguvp_eun20.png"></p><br><p> 由于我们通常使用<code>UIView</code>层次结构，因此将以<code>UIView</code>示例继续进行描述。 </p><br><p> 在<code>CATransaction.commit</code>期间， <a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout"><code>setNeedsLayout</code></a>所有带有<a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout"><code>setNeedsLayout</code></a>标记的<code>UIView</code>的布局。 请注意，我们自己也不再次调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews"><code>layoutSubviews</code></a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622507-layoutifneeded"><code>layoutIfNeeded</code></a>因为它们保证了<code>CATransaction.commit</code>内部系统中的延迟执行。 即使在一次事务中（在调用<code>CATransaction.begin</code>和<code>CATransaction.commit</code> ），您多次更改<code>frame</code>并调用<code>setNeedsLayout</code> ，但每次更改都不会立即<code>CATransaction.commit</code> 。 最终更改仅在调用<code>CATransaction.commit</code>之后<code>CATransaction.commit</code> 。 相关的<code>CALayer</code>方法： <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410946-setneedslayout%3Flanguage%3Dobjc"><code>setNeedsLayout</code></a> ， <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410873-layoutifneeded%3Flanguage%3Dobjc"><code>layoutIfNeeded</code></a>和<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers%3Flanguage%3Dobjc"><code>layoutSublayers</code></a> 。 </p><br><p> 通过<a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a>和<a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect"><code>drawRect</code></a>方法可以形成类似的绘图束。 对于<code>CALayer</code>这是<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410855-setneedsdisplay"><code>setNeedsDisplay</code></a> ， <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410813-displayifneeded"><code>displayIfNeeded</code></a>和<a href="https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097262-draw"><code>drawLayer</code></a> 。  <code>CATransaction.commit</code>调用所有标记有<code>setNeedsDisplay</code>元素的呈现方法。 此步骤有时称为屏幕外绘制。 </p><br><p>  <strong>一个例子</strong> 。 为方便起见，请使用<code>UITableView</code> ： </p><br><pre> <code class="plaintext hljs"> ... // Layout UITableView.layoutSubviews() //  ,   .. ... // Offscreen drawing UITableView.drawRect() //    ...</code> </pre> <br><p>  UIKit重用<code>layoutSubviews</code> <code>UITableView</code> / <code>UICollectionView</code> ：调用<code>willDisplayCell</code>委托<code>willDisplayCell</code> ，依此类推。 在<code>CATransaction.commit</code>期间，发生屏幕外绘制：标记为<a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a>的所有层的<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410757-drawincontext%3Flanguage%3Dobjc"><code>drawInContext</code></a>方法或所有<code>UIView</code>的<a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect"><code>drawRect</code></a>被<a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a> 。 我注意到，当我们在<code>drawRect</code>绘制某些东西时，这发生在主线程上，我们迫切需要为新框架更改图层的显示。 显然，这样的解决方案可能效率很低。 </p><br><p>  <code>CATransaction.commit</code>接下来会发生什么？ 渲染树将发送到渲染服务器。 </p><br><h2 id="43-rendering-pipeline">  <strong>4.3。</strong>  <strong>渲染管线</strong> </h2><br><p> 回顾在iOS中形成界面框架的整个过程（渲染管道[WWDC 2014 Session419。iOS应用的高级图形和动画]）： </p><br><p><img src="https://habrastorage.org/webt/wh/ac/dj/whacdjlwdz9p3yxk4q2lonad4ag.png"></p><br><p> 不仅我们应用程序的过程负责帧的形成-Core Animation还可以在名为Render Server的单独系统过程中工作。 </p><br><p>  <strong>框架的形成方式。</strong> 我们（或我们的系统）在应用程序中创建一个带有接口更改描述的新事务（ <code>CATransaction</code> ），“提交”该事务<code>CATransaction</code>其传输到Render Server。 在应用程序方面，所有工作都已完成。 接下来，渲染服务器解码事务（渲染树），在视频芯片上调用必要的命令，绘制新帧并将其显示在屏幕上。 </p><br><p> 有趣的是，在创建框架时，使用了某种“多线程”。 如果屏幕刷新率为每秒60帧，则新形成的帧总数不是以1/60，而是以1/30秒。 这是因为在应用程序准备新帧时，Render Server仍在处理前一个帧： </p><br><p><img src="https://habrastorage.org/webt/vz/cp/oa/vzcpoae_zvhzw0zkhll1_tjuwwy.png"></p><br><p> 粗略地说，在我们进行交易形成的过程中，在屏幕上显示之前帧形成的总时间为1/60秒，而在交易处理过程中，在Render Server进程中为1/60秒。 </p><br><p> 我想发表以下评论。  <strong>我们可以自己并行化图层的绘制，</strong>并在Background流中<a href="https://developer.apple.com/documentation/uikit/1623912-uigraphicsbeginimagecontextwitho">渲染</a> <code>UIImage</code> / <code>CGImage</code> <a href="https://developer.apple.com/documentation/uikit/1623912-uigraphicsbeginimagecontextwitho">的</a>内容。 之后，在主线程中，您需要将创建的图像分配给<a href="https://developer.apple.com/documentation/quartzcore/calayer/1410773-contents"><code>CALayer.contents</code></a>属性。 就性能而言，这是一种非常好的方法。 是使用它的开发人员<a href="https://texturegroup.org/">Texture</a> 。 但是由于我们只能在应用程序生成事务的过程中更改<code>CALayer.contents</code> ，因此在60帧时创建和替换新图像的时间只有1/60秒，而不是1/30秒（考虑到优化和渲染管道与Render Server的并行化） ） </p><br><p> 此外，Render Server仍可以处理混合（请参阅下文）和短期图层缓存[iOS核心动画：高级技术。 Nick Lockwood].        1/60      <code>CALayer.contents</code> ,         .     . </p><br><p> <em>:    ,     .</em> </p><br><h2 id="44-samye-uyazvimye-po-proizvoditelnosti-mesta"> <strong>4.4.     </strong> </h2><br><p> <strong>Main-thread</strong> </p><br><p><img src="https://habrastorage.org/webt/yt/c7/2n/ytc72nywgvqohz44yx_lsr9jhti.png"></p><br><p> <strong><em> 1.     ( <code>CATransaction.commit</code> )</em></strong> -   <code>UIView.layoutSubviews</code>     <code>UIView</code> (,  <code>CALayer</code> ).   ,         <code>layoutSubviews</code> / <code>cellForRow</code> / <code>willDisplayCell</code> . </p><br><p> <strong><em> 2.    <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410757-drawincontext%3Flanguage%3Dobjc"><code>drawInContext</code></a> / <a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect"><code>drawRect</code></a> .</em></strong>  -  Main-      ( <code>CATransaction.commit</code> ) —  .                 ,    . </p><br><p> <strong><em> 3.     </em></strong> .          .        <code>CATransaction.commit</code> ,        ,  <a href="https://developer.apple.com/documentation/uikit/uiimage/1624092-draw"></a>    . </p><br><p> <strong><em> 4.   .</em></strong>                <code>UIImage</code> / <code>CGImage</code> . </p><br><p> <strong><em> 5.  </em></strong> .     Main-thread   ,     scroll.           -  ,       UI. </p><br><p> <strong><em> 6.    Main-.</em></strong>    , <code>RunLoop</code>  Main-   ,     ,   Main-.         . </p><br><p> <strong>GPU</strong> </p><br><p><img src="https://habrastorage.org/webt/xx/gl/cq/xxglcqd-3yjgmjsuxkppjbzbc38.png"></p><br><p> <strong><em>Blending</em></strong> .        GPU       (  Render Server       GPU,         ).   ,      ,      Background-. </p><br><p> <strong><em> </em></strong> . ,    <a href="https://developer.apple.com/documentation/uikit/uiblureffect"><code>UIBlurEffect</code></a> , <a href="https://developer.apple.com/documentation/uikit/uivibrancyeffect"><code>UIVibrancyEffect</code></a>    ,  ,    (Render Pass).      ,       ,    . </p><br><p> <strong>Offscreen rendering (Render Server)</strong> </p><br><p><img src="https://habrastorage.org/webt/zm/ru/b4/zmrub4eko8bdeelh2lbivcem8bi.png"></p><br><p> Render Server        .        , ,     : </p><br><ul><li> <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410818-cornerradius"><code>cornerRadius</code></a> —  Render Server      ,         ; </li><li> <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410819-shadowradius"><code>shadowRadius</code></a> —   Render Server    ,   ; </li><li> <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask"><code>mask</code></a> —        . </li></ul><br><p>    <code>CALayer</code> ,       ,    Offscreen rendering.    ,     <a href="https://developer.apple.com/documentation/uikit/uivisualeffect"><code>UIVisualEffect</code></a> (   ,     Render Server  CPU,   GPU). </p><br><p>  ,       . </p><br><hr><br><h1 id="5-instrumenty-izmereniy"> <strong>5.  </strong> </h1><br><p>    ,    ,    Time Profiler.   <a href="https://developer.apple.com/documentation/metal/using_metal_system_trace_in_instruments_to_profile_your_app">Metal System Trace</a> —         Time Profiler    . </p><br><h2 id="51-metal-system-trace"> <strong>5.1. Metal System Trace</strong> </h2><br><p>  ,          ( ).   ,    : ,    . </p><br><p>  ,   Metal System Trace  ,           .     ,       Render Server.       ,      Main-,   — ,     . </p><br><p><img src="https://habrastorage.org/webt/gy/pv/ay/gypvay-wwr1f0ldbjazina-ewtg.png"></p><br><p>      - ,   : </p><br><p><img src="https://habrastorage.org/webt/0r/af/6e/0raf6e-cvoukj_6jzt1o6frzjom.png"></p><br><p>  Metal System Trace   .     64- ,     iPhone 5s.  ,    <em></em>    .   , -   ,  ,          UI. </p><br><h2 id="52-fiksiruem-prosadki-proizvoditelnosti-v-kode-vo-vremya-raboty-prilozheniya"> <strong>5.2.         </strong> </h2><br><p>         . ,   - -  .         ,    <a href="https://developer.apple.com/documentation/quartzcore/cadisplaylink"><code>CADisplayLink</code></a> . </p><br><p>   <code>CADisplayLink</code>   <a href="https://developer.apple.com/documentation/quartzcore/cadisplaylink/1621257-timestamp"><code>timestamp</code></a> —     (    Render Server).         <code>CADisplayLink.timestamp</code>     <code>timestamp</code> .   ,          (, 1/60 )  : </p><br><pre> <code class="plaintext hljs"> //  CADisplayLink. link = [CADisplayLink displayLinkWithTarget:target selector:selector] [link addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode] //    CADisplayLink : diff = prevTimestamp - link.timestamp if (diff &gt; 1/fps) { //  freeze } prevTimestamp = link.timestamp</code> </pre> <br><p> <code>CADisplayLink</code>   <a href="https://developer.apple.com/documentation/uikit/uitrackingrunloopmode%3Flanguage%3Dobjc"><code>UITrackingRunLoopMode</code></a> ,       . </p><br><p>     Rendering Pipeline: <br><img src="https://habrastorage.org/webt/yv/ca/t3/yvcat3yxparod3whs19qzwwjzhw.png"></p><br><p>      UI-,         .    «»     <code>freezeFrameTimeRate</code> : </p><br><pre> <code class="plaintext hljs">scrollTime //    Scroll freezeFrameTime //    ,  "",       freezeFrameTimeRate = freezeFrameTime / scrollTime</code> </pre> <br><p>  ,            -    <code>UIView</code> .   ,      «»: </p><br><p><img src="https://habrastorage.org/webt/ws/l7/tr/wsl7trcro6gr-t7ax-paqn_rxls.png"></p><br><p>  ,          ,    « <code>UIView</code> »         . 怎么了   ,   . , ,      ,     : <code>CADisplayLink</code> ,       Render Server    <code>link.timetamp</code> ,    Render Server     ,      .   60     UI-,         Render Server.   Render Server      ,     . </p><br><p>  ,     ,   ,  Render Server    .    <a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442997-addcompletedhandler%3Flanguage%3Dobjc">Metal</a> ,        Render Server. ,  ,       iOS,   Render Server            . </p><br><h2 id="kak-issledovat-problemy-rekomendacii"> <strong>  . </strong> </h2><br><p>   ,   ,      .             ,        . </p><br><p> :   —   !          —        . </p><br><hr><br><h1 id="zaklyuchenie">  <strong>结论</strong> </h1><br><p>   —               .    ,     ,      . </p><br><hr><br><h1 id="istochniki-informacii"> <strong> </strong> </h1><br><p>  ,        —        .        ,   . </p><br><p>  ,        : </p><br><ol><li> <a href="https://developer.apple.com/documentation"> Apple</a> . </li><li> <a href="https://habr.com/ru/company/oleg-bunin/blog/437584/">    Auto Layout</a> . </li><li> <a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">The Cassowary Linear Arithmetic Constraint Solving Algorithm</a> . </li><li> iOS Core Animation: Advanced Techniques. Nick Lockwood. </li><li> WWDC 2014 Session 419. Advanced Graphics and Animations for iOS Apps. </li></ol><br><p><img src="https://habrastorage.org/webt/ij/vj/ex/ijvjexv2ppdy6bdkepcwbqk7wy8.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481626/">https://habr.com/ru/post/zh-CN481626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481612/index.html">我们对Avalonia UI争取更少平台的贡献</a></li>
<li><a href="../zh-CN481616/index.html">测地线圆顶。 关于设备和我的计算经验</a></li>
<li><a href="../zh-CN481618/index.html">Unity MVP或如何简化生活</a></li>
<li><a href="../zh-CN481620/index.html">瞻博网络SRX和Cisco ASA：下一个系列</a></li>
<li><a href="../zh-CN481624/index.html">与Redux一起在Flutter上编写应用程序</a></li>
<li><a href="../zh-CN481628/index.html">在测试用例中编写初步步骤的规则</a></li>
<li><a href="../zh-CN481630/index.html">最佳有用的工具和资源，以使2019年的初创企业变得更聪明</a></li>
<li><a href="../zh-CN481632/index.html">云提供商：谁是市场上最好的？</a></li>
<li><a href="../zh-CN481634/index.html">食品设计文摘，2019年11月</a></li>
<li><a href="../zh-CN481638/index.html">为什么复杂生产的3D模型有用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>