<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👭 🙃 🛌🏼 "Parece que esto ya sucedió?" Busque incidentes y reclamos similares 🧕🏻 🧘 🆓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos los que pasaron un cierto tiempo apoyando los sistemas están familiarizados con la sensación de déjà vu cuando recibieron una nueva aplicación: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Parece que esto ya sucedió?" Busque incidentes y reclamos similares</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472210/"><p>  Todos los que pasaron un cierto tiempo apoyando los sistemas están familiarizados con la sensación de déjà vu cuando recibieron una nueva aplicación: "fue así, se resolvió, pero no recuerdo exactamente cómo".  Puede pasar tiempo, profundizar en aplicaciones anteriores e intentar encontrar otras similares.  Esto ayudará: el incidente se cerrará más rápido, o incluso será posible detectar la causa raíz y cerrar el problema de una vez por todas. </p><br><p>  Los empleados "jóvenes" que acaban de unirse al equipo no tienen esa historia en sus cabezas.  Lo más probable es que no sepan que un incidente similar, por ejemplo, ocurrió hace seis meses a un año.  Y el colega de la habitación contigua decidió ese incidente. </p><br><p>  Lo más probable es que los empleados "jóvenes" no busquen algo similar en la base de datos de incidentes, pero resolverán los problemas desde cero.  Pase más tiempo, gane experiencia y la próxima vez será más rápido.  O tal vez lo olvidarán de inmediato bajo la corriente de nuevas aplicaciones.  Y la próxima vez todo volverá a suceder. </p><br><p>  Ya estamos utilizando modelos ML para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clasificar incidentes</a> .  Para ayudar a nuestro equipo a procesar las aplicaciones de manera más eficiente, hemos creado otro modelo de ML para preparar una lista de "incidentes similares previamente cerrados".  Detalles - debajo del corte. </p><a name="habracut"></a><br><h2 id="chto-nam-nuzhno">  Que necesitamos </h2><br><p>  Para cada incidente entrante, es necesario encontrar incidentes cerrados "similares" en el historial.  La definición de "similitud" debe aparecer al comienzo del incidente, preferiblemente antes de que el personal de apoyo haya comenzado el análisis. </p><br><p>  Para comparar incidentes, es necesario utilizar la información proporcionada por el usuario al contactar: ​​una breve descripción, una descripción detallada (si la hay), cualquier atributo del registro del usuario. </p><br><p>  El equipo admite 4 grupos de sistemas.  El número total de incidentes que quiero usar para buscar otros similares es de aproximadamente 10 mil. </p><br><h2 id="pervoe-reshenie">  Primera decisión </h2><br><p>  No hay información verificada sobre la "similitud" de incidentes disponibles.  Por lo tanto, las opciones de vanguardia para entrenar redes siamesas tendrán que posponerse por ahora. <br>  Lo primero que viene a la mente es una simple agrupación de una "bolsa de palabras" compuesta por el contenido de las apelaciones. </p><br><p>  En este caso, el proceso de manejo de incidentes es el siguiente: </p><br><ol><li>  Destacando los fragmentos de texto necesarios </li><li>  Preprocesamiento / limpieza de texto </li><li>  Vectorización TF-IDF </li><li>  Encuentra tu vecino más cercano </li></ol><br><p>  Está claro que con el enfoque descrito, la similitud se basará en una comparación de diccionarios: el uso de las mismas palabras o n-gramas en dos incidentes diferentes se considerará como "similitud". </p><br><p>  Por supuesto, este es un enfoque bastante simplificado.  Pero recordando que evaluamos los textos de visitas de usuarios, si el problema se describe con palabras similares, lo más probable es que los incidentes sean similares.  Además del texto, puede agregar el nombre del departamento del usuario, esperando que los usuarios de los mismos departamentos en diferentes organizaciones tengan problemas similares. </p><br><h3 id="vydelenie-neobhodimyh-tekstovyh-fragmentov">  Destacando los fragmentos de texto necesarios </h3><br><p>  Datos de incidentes que obtenemos de service-now.com de la manera más simple: ejecutando informes personalizados mediante programación y recuperando sus resultados en forma de archivos CSV. </p><br><p>  Los datos sobre mensajes intercambiados entre el soporte y los usuarios como parte del incidente se devuelven en este caso en forma de un campo de texto grande, con el historial completo de la correspondencia. </p><br><p>  La información sobre la primera llamada de dicho campo tuvo que ser "cortada" por expresiones regulares. </p><br><ul><li>  Todos los mensajes están separados por una línea característica &lt;when&gt; - &lt;who&gt;. </li><li>  Los mensajes a menudo terminan con firmas formales, especialmente si la apelación se realizó por correo electrónico.  Esta información es notablemente "fonil" en la lista de palabras significativas, por lo que la firma también tuvo que ser eliminada. </li></ul><br><p>  Resultó algo como esto: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_first_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messages)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(messages) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># take the first message spl = re.split("\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2} - ((\w+((\s|-)\w+)?,(\s\w+)+)|\w{9}|guest)\s\(\w+\s\w+\)\n", messages.lower()) res = spl[-1] # cut off "mail footer" with finalization statements res = re.split("(best|kind)(\s)+regard(s)+", res)[0] # cut off "mail footer" with embedded pictures res = re.split("\[cid:", res)[0] # cut off "mail footer" with phone prefix res = re.split("\+(\d(\s|-)?){7}", res)[0] return res</span></span></code> </pre> <br><h3 id="predvaritelnaya-obrabotka-tekstov-incidenta">  Preprocesamiento de textos de incidentes </h3><br><p>  Para mejorar la calidad de la clasificación, el texto de la apelación se procesa previamente. </p><br><p>  Utilizando un conjunto de expresiones regulares en las descripciones de incidentes, se encontraron fragmentos característicos: fechas, nombres de servidores, códigos de productos, direcciones IP, direcciones web, formas incorrectas de nombres, etc.  Dichos fragmentos fueron reemplazados con los correspondientes tokens de concepto. </p><br><p>  Al final, el tartamudeo se usó para llevar las palabras a una forma común.  Esto nos permitió deshacernos de las formas y terminaciones plurales de los verbos.  El conocido <code>snowballstemmer</code> se utilizó como stemmer. </p><br><p>  Todos los procesos de procesamiento se combinan en una clase de transformación, que se puede utilizar en diferentes procesos. </p><br><p>  Por cierto, resultó (experimentalmente, por supuesto) que el método <code>stemmer.stemWord()</code> no es seguro para subprocesos.  Por lo tanto, si intenta implementar el procesamiento de texto paralelo dentro de la tubería, por ejemplo, utilizando <code>joblib</code> Prallel / delay, el acceso a la instancia general del stemmer debe protegerse con bloqueos. </p><br><pre> <code class="python hljs">__replacements = [ (<span class="hljs-string"><span class="hljs-string">'(\d{1,3}\.){3}\d{1,3}'</span></span>, <span class="hljs-string"><span class="hljs-string">'IPV4'</span></span>), (<span class="hljs-string"><span class="hljs-string">'(?&lt;=\W)((\d{2}[-\/ \.]?){2}(19|20)\d{2})|(19|20)\d{2}([-\/ \.]?\d{2}){2}(?=\W)'</span></span>, <span class="hljs-string"><span class="hljs-string">'YYYYMMDD'</span></span>), (<span class="hljs-string"><span class="hljs-string">'(?&lt;=\W)(19|20)\d{2}(?=\W)'</span></span>, <span class="hljs-string"><span class="hljs-string">'YYYY'</span></span>), (<span class="hljs-string"><span class="hljs-string">'(?&lt;=\W)(0|1)?\d\s?(am|pm)(?=\W)'</span></span>, <span class="hljs-string"><span class="hljs-string">'HOUR'</span></span>), (<span class="hljs-string"><span class="hljs-string">'http[s]?:\/\/(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'</span></span>, <span class="hljs-string"><span class="hljs-string">'SOMEURL'</span></span>) <span class="hljs-comment"><span class="hljs-comment">#      ] __stemmer_lock = threading.Lock() __stemmer = snowballstemmer.stemmer('english') def stem_string(text: str): def stem_words(word_list): with __stemmer_lock: res = __stemmer.stemWords(word_list) return res return " ".join(stem_words(text.split())) def clean_text(text: str): res = text for p in __replacements: res = re.sub(p[0], '#'+p[1]+'#', res) return res def process_record(record): txt = "" for t in record: t = "" if t == np.nan else t txt += " " + get_first_message(str(t)) return stem_string(clean_text(txt.lower())) class CommentsTextTransformer(BaseEstimator, TransformerMixin): _n_jobs = 1 def __init__(self, n_jobs=1): self._n_jobs = n_jobs def fit(self, X, y=None): return self def transform(self, X, y=None): features = Parallel(n_jobs=self._n_jobs)( delayed(process_record)(rec) for i, rec in enumerate(X.values) ) return np.array(features, dtype=object).reshape(len(X),)</span></span></code> </pre> <br><h3 id="vektorizaciya">  Vectorización </h3><br><p>  La vectorización se realiza mediante el <code>TfidfVectorizer</code> estándar con la siguiente configuración: </p><br><ul><li>  <code>max_features</code> = 10000 </li><li>  <code>ngram</code> = (1,3) - en un intento de atrapar combinaciones estables y conectivas semánticas </li><li>  <code>max_df</code> / <code>min_df</code> : izquierda por defecto </li><li>  <code>stop_words</code> : una lista estándar de palabras en inglés, más su propio conjunto adicional de palabras.  Por ejemplo, algunos usuarios mencionaron nombres de analistas, y con frecuencia los nombres propios se convirtieron en atributos significativos. </li></ul><br><p>  <code>TfidfVectorizer</code> propio <code>TfidfVectorizer</code> realiza la normalización L2 por defecto, por lo que los vectores incidentes están listos para medir la distancia del coseno entre ellos. </p><br><h3 id="poisk-pohozhih-incidentov">  Buscar incidentes similares </h3><br><p>  La tarea principal del proceso es devolver una lista de los N vecinos más cercanos.  La clase <code>sklearn.neighbors.NearestNeighbors</code> es bastante adecuada para esto.  Un problema es que no implementa el método de <code>transform</code> , sin el cual no se puede usar en la <code>pipeline</code> . </p><br><p>  Por lo tanto, era necesario hacerlo basado en <code>Transformer</code> , que solo entonces lo colocó en el último paso de la <code>pipeline</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NearestNeighborsTransformer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(NearestNeighbors, TransformerMixin)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n_neighbors=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, radius=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, algorithm=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'auto'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, leaf_size=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">30</span></span></span></span><span class="hljs-function"><span class="hljs-params">, metric=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'minkowski'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, metric_params=None, n_jobs=None, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super(NearestNeighbors, self).__init__(n_neighbors=n_neighbors, radius=radius, algorithm=algorithm, leaf_size=leaf_size, metric=metric, p=p, metric_params=metric_params, n_jobs=n_jobs) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, X, y=None)</span></span></span><span class="hljs-function">:</span></span> res = self.kneighbors(X, self.n_neighbors, return_distance=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br><h3 id="process-obrabotki">  Proceso de procesamiento </h3><br><p>  En conjunto, obtenemos un proceso compacto: </p><br><pre> <code class="python hljs">p = Pipeline( steps=[ (<span class="hljs-string"><span class="hljs-string">'grp'</span></span>, ColumnTransformer( transformers=[ (<span class="hljs-string"><span class="hljs-string">'text'</span></span>, Pipeline(steps=[ (<span class="hljs-string"><span class="hljs-string">'pp'</span></span>, CommentsTextTransformer(n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>)), (<span class="hljs-string"><span class="hljs-string">"tfidf"</span></span>, TfidfVectorizer(stop_words=get_stop_words(), ngram_range=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), max_features=<span class="hljs-number"><span class="hljs-number">10000</span></span>)) ]), [<span class="hljs-string"><span class="hljs-string">'short_description'</span></span>, <span class="hljs-string"><span class="hljs-string">'comments'</span></span>, <span class="hljs-string"><span class="hljs-string">'u_impacted_department'</span></span>] ) ] )), (<span class="hljs-string"><span class="hljs-string">"nn"</span></span>, NearestNeighborsTransformer(n_neighbors=<span class="hljs-number"><span class="hljs-number">10</span></span>, metric=<span class="hljs-string"><span class="hljs-string">'cosine'</span></span>)) ], memory=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  Después del entrenamiento, la <code>pipeline</code> se puede guardar en un archivo usando <code>pickle</code> y usar para manejar incidentes entrantes. <br>  Junto con el modelo, guardaremos los campos de incidentes necesarios, para luego usarlos en la salida cuando el modelo se esté ejecutando. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># inc_data - pandas.Dataframe,     # ref_data - pandas.Dataframe,    . #     .    # inc_data["recommendations_json"] = "" #   . # column_list -  ,          nn_dist, nn_refs = p.transform(inc_data[column_list]) for idx, refs in enumerate(nn_refs): nn_data = ref_data.iloc[refs][['number', 'short_description']].copy() nn_data['distance'] = nn_dist[idx] inc_data.iloc[idx]["recommendations_json"] = nn_data.to_json(orient='records') #     , .     -. inc_data[['number', 'short_description', 'recommendations_json']].to_json(out_file_name, orient='records')</span></span></code> </pre> <br><h2 id="pervye-rezultaty-primeneniya">  Resultados de la primera aplicación </h2><br><p>  La reacción de los colegas a la introducción de un sistema de "pistas" fue generalmente muy positiva.  Los incidentes recurrentes comenzaron a resolverse más rápido, comenzamos a trabajar en la solución de problemas. </p><br><p>  Sin embargo, uno no podría esperar un milagro del sistema de aprendizaje no supervisado.  Los colegas se quejaron de que a veces el sistema ofrece enlaces completamente irrelevantes.  A veces incluso era difícil entender de dónde provienen esas recomendaciones. </p><br><p>  Estaba claro que el campo para mejorar el modelo es enorme.  Algunas de las deficiencias pueden resolverse, incluyendo o excluyendo algunos atributos del incidente.  Parte: seleccionando un nivel de corte adecuado para la distancia entre el incidente actual y la "recomendación".  Se pueden considerar otros métodos de vectorización. </p><br><p>  Pero el problema principal era la falta de métricas de calidad para las recomendaciones.  Y si es así, era imposible entender "qué es bueno y qué es malo, y cuánto es", y construir una comparación de modelos sobre esto. </p><br><p>  No teníamos acceso a los registros http, porque el sistema de servicio funciona de forma remota (SaaS).  Realizamos encuestas de usuarios, pero solo de forma cualitativa.  Era necesario proceder a evaluaciones cuantitativas y construir sobre su base parámetros de calidad claros. </p><br><p>  Pero más sobre eso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la siguiente parte ...</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472210/">https://habr.com/ru/post/472210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472198/index.html">Localización de mensajes push en aplicaciones móviles.</a></li>
<li><a href="../472200/index.html">Modernización de la clase de informática en una escuela rusa sobre frambuesa: barata y alegre</a></li>
<li><a href="../472202/index.html">Windows 10 + Python = Código VS + WSL</a></li>
<li><a href="../472204/index.html">Experimentos simples con el microcontrolador STM32F103 (Blue Tablet)</a></li>
<li><a href="../472208/index.html">Pantallas OLED de teléfonos inteligentes Android y cómo lidiar con ellos</a></li>
<li><a href="../472212/index.html">Cómo aterrizar el transbordador espacial desde el espacio</a></li>
<li><a href="../472214/index.html">La ramificación pronosticada erróneamente puede aumentar significativamente el tiempo de ejecución del programa</a></li>
<li><a href="../472216/index.html">¿Qué debemos construir IoT? Tu IoT en Amazon en un día</a></li>
<li><a href="../472220/index.html">¿Por qué a los mejores físicos no les gusta una interpretación multimundo?</a></li>
<li><a href="../472222/index.html">“Lee si te gusta escuchar”: libros para aquellos que no son indiferentes a la música, desde clásica hasta hip-hop.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>