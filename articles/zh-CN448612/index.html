<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦀 🥩 🦉 在功能冻结2019中冻结的内容。第一部分。JSONPath 😒 🧝🏻 ✍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在2019-03年委员会成立后 ，功能冻结了。 我们这里有几乎是传统的专栏文章：我们已经写了关于去年的冻结。 现在，2019年的结果是：新的更新将包含在PostgreSQL 12中。在本部分的JSONPath专栏中，使用了Oleg Bartunov在今年4月9日在圣彼得堡的Saint Highloa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在功能冻结2019中冻结的内容。第一部分。JSONPath</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448612/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/kw/ra/ylkwraooftas8s1ft0ik4pgn5tc.jpeg"></div><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>2019-03年委员会成立后</b></a> ，功能冻结了。 我们这里有几乎是传统的专栏文章：我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已经写了</a>关于去年的冻结。 现在，2019年的结果是：新的更新将包含在PostgreSQL 12中。在本部分的JSONPath专栏中，使用了Oleg Bartunov在今年4月9日在圣彼得堡的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Saint Highload ++上</a>阅读的“ Etudes中的Postgres 12”报告中的示例和片段。 <br><a name="habracut"></a><br><h2> 杰森帕特 </h2><br> 与JSON（B）相关的所有内容在世界范围内都与俄罗斯相关，这是Postgres Professional最重要的开发领域之一。 用于JSON / JSONB的jsonb类型，函数和运算符出现在PostgreSQL 9.4版中，由Oleg Bartunov领导的团队制作。 <br><br>  SQL / 2016标准提供了使用JSON的功能：此处提到了JSONPath-JSON中的一组数据寻址工具；  JSONTABLE-将JSON转换为常规表的方法； 大量的功能和运算符。 尽管Postgres中的JSON已获得长期支持，但2017年Oleg Bartunov及其同事开始致力于支持该标准。 符合标准总是好的。 在标准中描述的所有内容中，只有一个但最重要的补丁是版本12中的JSONPath，因此我们将首先讨论它。 <br><br> 在远古时代，人们使用JSON并将其存储在文本字段中。 在9.3中，出现了一种特殊的JSON数据类型，但与之相关的功能并不丰富，由于解析JSON的文本表示所花费的时间，这种类型的请求工作缓慢。 这阻止了许多使用NoSQL数据库的潜在Postgres用户。 由于O. Bartunov，A。Korotkov和F. Sigaev，Postgres的生产率提高了9.4，这是因为Postgres引入了JSON的二进制版本-jsonb类型。 <br> 不需要每次都解析jsonb，因此使用它要快得多。 在与此同时出现的新函数和运算符中，有些仅适用于新的二进制类型，例如出现的重要运算符<b>@&gt;</b> ，用于检查给定JSONB中是否包含元素或数组： <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, 3]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br> 给出TRUE，因为右侧的数组进入左侧的数组。 但是 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, [1, 3]]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br> 将给出FALSE，因为嵌套级别不同，因此必须显式设置它。 是否为jsonb类型引入了存在运算符<b>？</b>  （一个问号），它检查字符串是JSONB值顶层的对象键还是数组的元素，以及两个类似的运算符（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>详细说明）。 具有两类GIN运算符的GIN索引支持它们。 运算符<b>-&gt;</b> （箭头）允许您通过JSONB“导航”，它按键返回值，如果是数组，则按索引返回值。 还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多</a>的移动运营商。 但是没有办法组织像WHERE一样起作用的过滤器。 这是一个突破：借助jsonb，Postgres作为具有NoSQL功能的RDBMS开始流行。 <br><br>  2014年，A。Korotkov，O。Bartunov和F. Sigaev开发了jsquery扩展，该扩展被包含在Postgres Pro Standard 9.5（以及后来的Standard和Enterprise版本）中。 它提供了用于处理json（b）的其他非常广泛的功能。 此扩展定义了用于从json（b）中提取数据的查询语言和索引以加快这些查询的速度。 用户需要此功能，他们还没有准备好等待标准以及在香草版本中包含新功能。 该开发项目由Wargaming.net赞助，也证明了其实用价值。 该扩展实现了一种特殊的类型-jsquery。 <br><br> 使用这种语言的查询是紧凑的，并且看起来像这样： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'{"apt":[{"no": 1, "rooms":2}, {"no": 2, "rooms":3}, {"no": 3, "rooms":2}]}'</span></span>::jsonb @@ <span class="hljs-string"><span class="hljs-string">'apt.#.rooms=3'</span></span>::jsquery;</code> </pre> <br> 我们在这里问公寓楼中是否有“三卢布”。 必须指定jsquery类型，因为@@运算符现在也为jsonb类型。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>是说明， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>是带有许多示例的演示。 <br><br> 总计：Postgres已经具备使用JSON的所有功能，然后出现了SQL：2016标准。 事实证明，它的语义与jsquery扩展中的语义没有太大不同。 该标准的作者甚至可能浏览了jsquery并发明了JSONPath。 我们的团队必须实施一些与现有产品有所不同的东西，当然还有很多新事物。 <br><br> 一年多以前，在3月的commitfest上，我们以3个支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SQL：2016</a>标准的大补丁的形式向社区提供了我们编程工作的成果： <br><br>  SQL / JSON：JSONPath; <br>  SQL / JSON：函数； <br>  SQL / JSON：JSON_TABLE。 <br><br> 但是要开发补丁程序并不是一件容易的事，推广它们也不是一件容易的事，尤其是当补丁程序很大且影响许多模块时。 需要进行许多次修订，修订版必须像商业公司那样推广，要投入大量资源（工时）。  Postgres Professional的首席架构师Alexander Korotkov亲自负责（因为他现在拥有提交者的身份）并实现了JSONPath补丁的采用-JSONPath补丁是本系列补丁中的主要补丁。 第二个和第三个现在处于“需求审查”状态。 聚焦的JSONPath允许您使用JSON（B）结构，并且足够灵活以突出显示其片段。 该标准规定的15个要点中，有14个已实现，这比Oracle，MySQL和MS SQL中的要多。 <br><br>  JSONPath表示法与Postgres语句在使用JSON和JSQuery表示法方面有所不同。 层次结构由点表示： <br><br>  $ .abc（用postgres 11表示法，我必须写'a'-&gt;'b'-&gt;'c'）； <br>  $-元素的当前上下文-实际上，带有$的表达式定义了要处理的json（b）区域，包括过滤器中的一个，其余部分则无法使用； <br>  @-过滤器表达式中的当前上下文-使用$遍历表达式中可用的路径； <br>  [*]-数组； <br>  *-通配符，在带有$或@的表达式中表示路径段的任何值，但要考虑到层次结构； <br>  **-作为带有$或@的表达式的一部分，可以表示路径段的任何值，而无需考虑层次结构-如果您不知道元素的嵌套级别，则使用它很方便； <br> 运算符“？” 允许您组织类似于WHERE的过滤器： <br>  $ .abc？  （@ .x&gt; 10）； <br>  $ .abcxtype（）以及size（），double（），ceiling（），floor（），abs（），datetime（），keyvalue（）是方法。 <br> 使用jsonb_path_query函数（关于以下函数）的查询可能看起来像这样： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; 3)'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [4, 5] (1 row)</span></span></code> </pre> <br> 尽管没有提交带有功能的特殊补丁，但JSONPath补丁已经具有用于JSON（B）的关键功能： <br><br><br><pre> <code class="sql hljs">jsonb_path_exists('{"a": 1}', '$.a')  true (  "?") jsonb_path_exists('{"a": 1}', '$.b')  false jsonb_path_match('{"a": 1}', '$.a == 1')  true (  "@&gt;") jsonb_path_match('{"a": 1}', '$.a &gt;= 2')  false jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3, 4, 5 jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  0  jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  [3, 4, 5] jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  [] jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3 jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  NULL</code> </pre> <br> 请注意，JSONPath表达式中的相等性是单个“ =”，而在jsquery中则是双重的：“ ==”。 <br><br> 为了获得更优雅的插图，我们将在单列房屋牌中生成JSONB： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> house(js jsonb); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'{ "address": { "city":"Moscow", "street": "Ulyanova, 7A" }, "lift": false, "floor": [ { "level": 1, "apt": [ {"no": 1, "area": 40, "rooms": 1}, {"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2} ] }, { "level": 2, "apt": [ {"no": 4, "area": 100, "rooms": 3}, {"no": 5, "area": 60, "rooms": 2} ] } ] }'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/u6/ob/nb/u6obnbokethtz5gatlcbdtvhjyi.png"><br>  <i>图1：带有分配的叶子单元的“住房JSON”树。</i> <br><br> 这是一个奇怪的JSON：它具有混乱的层次结构，但它是取自生活的，在生活中，经常有必要使用实际存在的东西，而不是应该使用实际的东西。 有了新版本的功能，我们将在1楼和2楼找到公寓，但不在楼层公寓列表中找到第一个（在树上以绿色突出显示）： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(js, <span class="hljs-string"><span class="hljs-string">'$.floor[0, 1].apt[1 to last]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; <span class="hljs-comment"><span class="hljs-comment">--------------------- [{"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2}, {"no": 5, "area": 60, "rooms": 2}]</span></span></code> </pre><br> 在PostgreSQL 11中，您必须提出以下要求： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_agg(apt) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> apt-&gt;generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, jsonb_array_length(apt) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> js-&gt;<span class="hljs-string"><span class="hljs-string">'floor'</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])-&gt;<span class="hljs-string"><span class="hljs-string">'apt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house ) apts(apt) ) apts(apt);</code> </pre> <br> 现在是一个非常简单的问题：是否有行（任何地方）包含“莫斯科”值？ 真的很简单： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_exists(js, <span class="hljs-string"><span class="hljs-string">'$.** ? (@ == "Moscow")'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house;</code> </pre> <br> 在版本11中，您将必须编写一个巨大的脚本： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RECURSIVE</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(kv.value, e.value) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_each ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) kv <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_array_elements ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'array'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) e <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> kv.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> e.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'"Moscow"'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/1k/uv/go/1kuvgo4f2bnjj_aylnvej76gltc.png"><br>  <i>图2找到了JSON树，莫斯科！</i> <br><br> 我们正在寻找面积为40至90平方米的任何楼层的任何公寓： <br><br><pre> <code class="plaintext hljs">select jsonb_path_query(js, '$.floor[*].apt[*] ? (@.area &gt; 40 &amp;&amp; @.area &lt; 90)') FROM house; jsonb_path_query ----------------------------------- {"no": 2, "area": 80, "rooms": 3} {"no": 3, "area": 50, "rooms": 2} {"no": 5, "area": 60, "rooms": 2} (3 rows)</code> </pre><br> 我们正在使用我们的住房杰森（Jason）寻找3号以后有房间的公寓： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 4 5 (2 rows)</span></span></code> </pre> <br> 这是jsonb_path_query_first的工作方式： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_first(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query_first <span class="hljs-comment"><span class="hljs-comment">------------------------ 4 (1 row)</span></span></code> </pre> <br> 我们看到仅选择满足过滤条件的第一个值。 <br><br>  JSONB @@的布尔JSONPath运算符称为匹配运算符。 它通过调用jsonb_path_match_opr函数来计算JSONPath谓词。 <br><br> 另一个布尔运算符是@？  -这是一个存在性测试，回答JSONPath表达式是否将返回SQL / JSON对象的问题，它调用jsonb_path_exists_opr函数： <br><br><pre> <code class="sql hljs"> '[1,2,3]' @@ '$[*] == 3'  true;  '[1,2,3]' @? '$[*] @? (@ == 3)' -  true</code> </pre> <br> 使用不同的运算符可以达到相同的结果： <br><br><pre> <code class="sql hljs">js @? '$.a'  js @@ 'exists($.a)' js @@ '$.a == 1'  js @? '$ ? ($.a == 1)'</code> </pre> <br>  JSONPath布尔运算符的美丽之处在于它们得到GIN索引的支持和加速。  jsonb_ops和jsonb_path_ops是相应的运算符类。 在此示例中，由于有一个微型表，因此我们禁用了SEQSCAN，因此在大型表上，优化器本身将选择位图索引： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ENABLE_SEQSCAN <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gin (js); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (COSTS <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> js @? <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.rooms == 3)'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on house Recheck Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) -&gt; Bitmap Index Scan on house_js_idx Index Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) (4 rows)</span></span></code> </pre> <br>  jsonb_path_xxx（）形式的所有函数都具有相同的签名： <br><br><pre> <code class="sql hljs">jsonb_path_xxx( js jsonb, jsp jsonpath, vars jsonb DEFAULT '{}', silent boolean DEFAULT false )</code> </pre> <br>  vars是用于传递JSONPath变量的JSONB对象： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; $x)'</span></span>, vars =&gt; <span class="hljs-string"><span class="hljs-string">'{"x": 2}'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [3, 4, 5]</span></span></code> </pre> <br> 当我们在其中一张表中进行涉及jsonb类型字段的联接时，没有var很难做到。 假设我们制作了一个应用程序，该应用程序在那座房子里为员工准备了合适的公寓，这些员工在问卷中写下了他们对最小面积的要求： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> demands(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">position</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">demand</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> demands <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">85</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.area &gt;= $min)'</span></span>, vars =&gt; jsonb_build_object(<span class="hljs-string"><span class="hljs-string">'min'</span></span>, demands.demand)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house, demands <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----+----------------------------------- jsonb_path_query | {"no": 2, "area": 80, "rooms": 3} -[ RECORD 2 ]----+----------------------------------- jsonb_path_query | {"no": 3, "area": 50, "rooms": 2} -[ RECORD 3 ]----+----------------------------------- jsonb_path_query | {"no": 4, "area": 100, "rooms": 3} -[ RECORD 4 ]----+----------------------------------- jsonb_path_query | {"no": 5, "area": 60, "rooms": 2}</span></span></code> </pre> <br>  Lucky Pasha可以提供4套公寓。 但是值得在请求中更改1个字母-从“ P”更改为“ C”，并且别无选择！ 只有一间公寓可以。 <br><br><br> 还有一个关键字：silent是禁止执行错误处理的标志；它们是程序员的良心。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>); ERROR: SQL/JSON member not found DETAIL: jsonpath member accessor can only be applied to an object</code> </pre> <br> 错误。 但这不会是一个错误： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>, silent =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ (0 rows)</span></span></code> </pre> <br> 顺便说一下，关于错误：按照标准，表达式中的算术错误不会给出错误消息，它们是程序员的良心： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[1,0,2]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (1/ @ &gt;= 1)'</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 1 (1 row)</span></span></code> </pre> <br> 在过滤器中计算表达式时，将搜索数组值，其中包含0，但除以0不会产生错误。 <br><br> 功能根据所选模式的不同而有所不同：“严格”或“宽松”（在“非严格”或“宽松”的翻译中，默认情况下已选中）。 假设我们正在JSON中寻找Lax模式下的密钥，但显然不是这样： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- f (1 row)</span></span></code> </pre> <br> 现在处于严格模式下： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- (null) (1 row)</span></span></code> </pre> <br> 也就是说，在自由模式下，我们收到FALSE，在严格的情况下我们得到NULL。 <br><br> 在Lax模式下，具有复杂层次结构[1,2，[3,4,5]]的数组始终扩展为[1,2,3,4,5]： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $[*] ? (@ == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br> 在严格模式下，将找不到数字“ 5”，因为它不在层次结构的底部。 要找到它，您必须修改查询，用“ @ [*]”替换“ @”： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $[*] ? (@[*] == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br> 在PostgreSQL 12中，JSONPath是一种数据类型。 该标准没有说明是否需要新的类型，它是实现的属性。 使用新类型，我们可以在操作员和索引的帮助下使用jsonpath进行全面的工作，以加速其工作，而JSONB已经存在。 否则，必须在执行程序和优化程序代码级别集成JSONPath。 <br><br> 例如，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关SQL / JSON语法的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> 。 <br><br>  Oleg Bartunov的博客文章介绍了PostgreSQL，Oracle，SQL Server和MySQL的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SQL / JSON standard-2016一致性</a> 。 <br><br> 这是有关SQL / JSON的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示</a> 。 <br><br> 这是SQL / JSON的<a href="">介绍</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448612/">https://habr.com/ru/post/zh-CN448612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448602/index.html">监控死了吗？ -实时监控</a></li>
<li><a href="../zh-CN448604/index.html">C＃中的Gameboy</a></li>
<li><a href="../zh-CN448606/index.html">Sidorin：KnowledgeConf是关于如何在2-3年内将平均工作时间保持在一个地方的知识</a></li>
<li><a href="../zh-CN448608/index.html">如何迈出机器人技术的第一步？</a></li>
<li><a href="../zh-CN448610/index.html">DIY：我们如何制定Codefest X的实时时间表</a></li>
<li><a href="../zh-CN448618/index.html">Douglas-Pecker算法</a></li>
<li><a href="../zh-CN448622/index.html">PHP GR8：JIT将提高PHP 8性能</a></li>
<li><a href="../zh-CN448624/index.html">看到数据了吗？ 不行 所以我看不到，但是他们知道。 我们销毁SSD驱动器上的数据，甚至恢复速度</a></li>
<li><a href="../zh-CN448628/index.html">苏联技术美学与技术</a></li>
<li><a href="../zh-CN448632/index.html">Java现在付款了吗？ 揭穿谣言（还是没有？）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>