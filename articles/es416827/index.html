<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游꿉 游뚺 久勇 Contenedores para adultos (Parte 02): una gu칤a pr치ctica de terminolog칤a 游눥 游놈 游눈游낖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay muchas plantillas de construcci칩n de contenedores. Un contenedor es solo una versi칩n ejecutable de su propia imagen. Por lo tanto, la forma de con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contenedores para adultos (Parte 02): una gu칤a pr치ctica de terminolog칤a</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416827/">  Hay muchas plantillas de construcci칩n de contenedores.  Un contenedor es solo una versi칩n ejecutable de su propia imagen.  Por lo tanto, la forma de construir un contenedor est치 estrechamente relacionada con c칩mo se inicia. <br><br>  Algunas im치genes de contenedor funcionan bien sin ning칰n privilegio especial; otras requieren privilegios de root.  Adem치s, la misma imagen / contenedor puede combinar varios patrones de construcci칩n y escenarios de uso a la vez. <br><br><img src="https://habrastorage.org/webt/vb/ka/oc/vbkaocfqfq-tdb_a97lu5sifqna.png" width="100%"><br><br>  A continuaci칩n consideraremos los casos de uso de contenedores m치s comunes. <br><br>  (Para una introducci칩n a la terminolog칤a del contenedor, vea la primera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte</a> ) <br><a name="habracut"></a><br><h3>  Escenarios de uso de contenedores </h3><br><h4>  Contenedores de aplicaciones </h4><br>  Los contenedores de aplicaciones son el tipo m치s com칰n de contenedor.  Los desarrolladores y propietarios de aplicaciones los manejan, y ellos mismos contienen el c칩digo fuente, adem치s de cosas como MySQL, Apache, MongoDB y Node.js. <br><br>  Se est치 formando un vasto ecosistema de contenedores de aplicaciones.  Proyectos como Software Collections proporcionan im치genes de contenedores de aplicaciones seguras y compatibles para Red Hat Enterprise Linux.  Al mismo tiempo, los miembros de la comunidad de Red Hat est치n desarrollando y respaldando contenedores de aplicaciones innovadores. <br><br>  En Red Hat, creemos que los contenedores de aplicaciones generalmente no necesitan privilegios especiales.  Sin embargo, al construir entornos de producci칩n de contenedores, existe la necesidad de otros contenedores. <br><br><h4>  Contenedores del sistema operativo </h4><br>  El contenedor del sistema operativo es un contenedor que se parece mucho m치s a un sistema operativo virtual completo.  Dichos contenedores tambi칠n usan el n칰cleo del host, pero ejecutan el sistema init completo, lo que les permite ejecutar f치cilmente varios procesos.  Ejemplos de contenedores del sistema operativo son LXC y LXD. <br><br>  Los contenedores del sistema operativo pueden, en principio, emularse utilizando contenedores docker / OCI, siempre que sea posible ejecutar el sistema dentro de ellos para que el usuario final pueda instalar el software dentro de dichos contenedores de la manera habitual y los perciba como un sistema operativo virtual completo. <br><br><pre><code class="hljs sql">yum <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> mysql systemctl <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> mysql</code> </pre> <br>  Esto simplifica enormemente la contenedorizaci칩n de las aplicaciones existentes.  Red Hat est치 trabajando arduamente para simplificar los contenedores del sistema operativo al permitir que systemd se ejecute dentro del contenedor y use el demonio mecanizado.  Aunque muchos clientes a칰n no est치n listos para la arquitectura de microservicios, la transici칩n a un modelo de entrega de software en contenedor basado en im치genes de contenedor a칰n puede brindarles muchas ventajas. <br><br><h4>  Contenedores para mascotas </h4><br>  Aunque Red Hat recomienda, promueve y apoya firmemente el uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plantillas basadas en la nube</a> al desarrollar nuevas aplicaciones, somos conscientes de que no todas las aplicaciones existentes se reescribir치n de esta manera.  En particular, porque muchos de ellos son tan 칰nicos e inimitables que, en comparaci칩n con las aplicaciones est치ndar, se ven como mascotas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pets</a> ) contra un reba침o de vacas.  Es para tales aplicaciones que se dise침an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedores</a> especiales para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mascotas</a> . <br><br>  Los contenedores para mascotas combinan la portabilidad y la conveniencia de una infraestructura de contenedores construida sobre la base de servidores de registro, im치genes de contenedores y hosts de contenedores con la flexibilidad de un entorno de TI tradicional, implementado dentro de un contenedor separado.  La idea aqu칤 es simplificar la contenedorizaci칩n de aplicaciones existentes debido a la misma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capacidad de usar systemd dentro del contenedor</a> para usar herramientas de automatizaci칩n existentes, instalaciones de software y otras herramientas para crear f치cilmente im치genes listas para contenedores para el lanzamiento. <br><br><h4>  Contenedores Super Privilege </h4><br>  Cuando se construye una infraestructura de contenedores basada en hosts de contenedores dedicados como Red Hat Enterprise Linux Atomic Host, los administradores de sistemas a칰n deben administrar.  Y los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedores s칰per privilegiados</a> (SPC) demuestran ser muy 칰tiles en dichos entornos distribuidos, ya sea Kubernetes, OpenShift o incluso contenedores independientes.  Los SPC pueden incluso cargar m칩dulos de kernel especializados, como systemtap. <br><br>  En la infraestructura creada para ejecutar contenedores, es probable que los administradores necesiten contenedores SPC para realizar tareas como monitoreo, respaldo, etc. Es importante entender que, dado que los contenedores SPC generalmente est치n mucho m치s conectados al n칰cleo del host, los administradores deber칤an Preste especial atenci칩n a los problemas de confiabilidad y estandarizaci칩n al elegir los sistemas operativos host, especialmente en entornos grandes agrupados y distribuidos que dificultan la soluci칩n de problemas.  Adem치s, los administradores deben asegurarse de que el espacio del usuario dentro del SPC sea compatible con el n칰cleo del host. <br><br><h4>  Herramientas y software del sistema </h4><br>  Las distribuciones de Linux siempre proporcionaron al usuario software del sistema, como Rsyslogd, SSSD, sadc, etc. Tradicionalmente, este software se instal칩 en forma de paquetes RPM o DEB, pero con el advenimiento de los formatos de empaquetado de contenedores se hizo m치s f치cil y m치s conveniente instalarlo usando im치genes de contenedor.  En particular, Red Hat ofrece cosas como contenedores ya hechos, como las herramientas de virtualizaci칩n de Red Hat, rsyslog, sssd y sadc. <br><br><h3>  Arquitectura de contenedores </h3><br>  A medida que la entrega de software en contenedores est치 ganando impulso, est치n surgiendo nuevos patrones de dise침o de contenedores.  En esta secci칩n hablaremos sobre algunos de ellos. <br><br>  La forma en que el contenedor se guarda en el disco (en otras palabras, el formato de la imagen) puede afectar en gran medida c칩mo se inicia.  Por ejemplo, un contenedor dise침ado para ejecutar sssd debe tener privilegios especiales cada vez que se inicia; de lo contrario, no podr치 hacer su trabajo.  A continuaci칩n, consideramos brevemente los patrones principales que actualmente se encuentran en la etapa de formaci칩n activa. <br><br><h4>  Im치genes de aplicaci칩n </h4><br>  Es con estas im치genes que los usuarios finales tratan.  Los escenarios para usar tales im치genes van desde DBMS y servidores web hasta aplicaciones individuales y buses de servicio.  Estas im치genes pueden ser creadas internamente por la organizaci칩n o proporcionadas por proveedores de software.  Por lo tanto, los usuarios finales a menudo se relacionan con el contenido de dichos contenedores aut칩nomos con precauci칩n y escrupulosidad.  Adem치s, aunque esta es la opci칩n m치s f치cil para el usuario final de los contenedores, las im치genes independientes son mucho m치s dif칤ciles de dise침ar, construir y parchear. <br><br><h4>  Im치genes basicas </h4><br>  Una imagen b치sica es uno de los tipos de im치genes m치s simples.  Sin embargo, las personas pueden denotar este t칠rmino con una variedad de cosas, por ejemplo, un ensamblaje corporativo est치ndar o incluso una imagen de aplicaci칩n.  Aunque, estrictamente hablando, estas no son im치genes b치sicas, sino intermedias. <br>  Tan solo deje en claro que la imagen base es una imagen que no tiene una capa principal.  Las im치genes b치sicas generalmente contienen una copia limpia del sistema operativo, as칤 como las herramientas necesarias para instalar paquetes de software o actualizar la imagen m치s tarde (yum, rpm, apt-get, dnf, microdnf).  Las im치genes b치sicas pueden ser recopiladas manualmente por el usuario final, pero en la pr치ctica generalmente son creadas y publicadas por comunidades de desarrollo (por ejemplo, Debian, Fedora o CentOS) o proveedores de software (por ejemplo, Red Hat).  El origen de la imagen base es cr칤tico para la seguridad.  En resumen, el principal y 칰nico prop칩sito de la imagen b치sica es proporcionar una base sobre la cual puede crear las im치genes de su hijo.  Cuando se utiliza dockerfile, la selecci칩n de la imagen base subyacente se realiza expl칤citamente: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> registry.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.redhat.com/rhel7-atomic</code> </pre> <br><h4>  Im치genes de constructor </h4><br>  Este es un tipo especial de imagen en funci칩n del cual se crean im치genes secundarias de contenedores de aplicaciones.  Las im치genes del constructor incluyen todo excepto el c칩digo fuente escrito por los desarrolladores, a saber, bibliotecas del sistema operativo, tiempos de ejecuci칩n del lenguaje, middleware y herramientas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente a imagen</a> . <br><br>  Al inicio, la imagen del generador extrae el c칩digo fuente de la aplicaci칩n escrito por los desarrolladores y crea una imagen secundaria del contenedor de la aplicaci칩n que est치 lista para ser lanzada, que luego puede ejecutarse en un entorno de desarrollo o producci칩n. <br><br>  Digamos que los desarrolladores han escrito el c칩digo PHP para la aplicaci칩n y quieren ejecutarlo en el contenedor.  Para hacer esto, simplemente toman la imagen del constructor de PHP y le pasan la URL en el sitio web de GitHub, donde se almacena su c칩digo.  Como resultado, los desarrolladores obtienen una imagen del contenedor de la aplicaci칩n lista para su lanzamiento que contiene Red Hat Enterprise Linux, PHP de las Colecciones de software y, por supuesto, el c칩digo fuente de PHP para la aplicaci칩n. <br><br>  Las im치genes del generador son una forma poderosa, f치cil y r치pida de convertir el c칩digo fuente en un contenedor construido sobre la base de componentes confiables. <br><br><h4>  Componentes en contenedores </h4><br>  Un contenedor est치 dise침ado principalmente para implementarse como un componente de un sistema de software m치s grande, y no como una unidad aut칩noma.  Y hay dos razones principales para esto. <br><br>  En primer lugar, la arquitectura de microservicios aumenta la libertad de elecci칩n de componentes, y tambi칠n conduce a un aumento en el n칰mero de componentes de los que se componen las aplicaciones y los sistemas de software.  Los componentes en contenedores ayudan a implementar dichos sistemas de manera m치s r치pida y f치cil.  Por ejemplo, las im치genes de contenedor facilitan la resoluci칩n del problema de la coexistencia de diferentes versiones del mismo componente.  Y las herramientas de definici칩n de aplicaciones, como las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementaciones yaml / json</a> en Kubernetes / OpenShift, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el broker de servicios abiertos</a> , las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plantillas OpenShift</a> y los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gr치ficos Helm,</a> proporcionan la creaci칩n de descripciones de aplicaciones de alto nivel. <br><br>  En segundo lugar, lejos de siempre, todas las partes de un sistema de software se pueden contener f치cilmente.  Por lo tanto, tiene sentido realizar la contenedorizaci칩n solo para los componentes individuales m치s adecuados para esto o m치s prometedores en t칠rminos de resultados.  En aplicaciones multiservicio, una parte de los servicios se puede implementar como contenedores, y la otra utilizando m칠todos tradicionales, como RPM o scripts de instalaci칩n, consulte contenedores de mascotas.  Adem치s, algunos componentes pueden ser dif칤ciles de contener, porque est치n mal divididos en componentes, o est치n vinculados a alg칰n hardware especial, o usan llamadas API de kernel de bajo nivel, etc. Por lo tanto, en un sistema de software grande, muy probablemente Habr치 partes que pueden ser contenedorizadas y partes que no pueden ser contenedorizadas.  Los componentes en contenedores son lo que se puede contener en contenedores y ya en contenedores.  Los componentes en contenedores est치n dise침ados para ejecutarse como parte de una aplicaci칩n espec칤fica, y no por s칤 mismos.  Es importante comprender que no est치n destinados a un funcionamiento aut칩nomo, ya que son 칰tiles solo como parte de un sistema de software m치s grande y, de forma aislada, son pr치cticamente in칰tiles. <br><br>  Por ejemplo, en OpenShift Enterprise 3.0, la mayor parte del c칩digo principal se implement칩 usando RPM, pero despu칠s de que se instal칩, los administradores implementaron el enrutador y el registro como contenedores.  OpenShift 3.1 introdujo la opci칩n de implementaci칩n en contenedores para master, node, openvswitch y etcd, y una vez instalados, los administradores tambi칠n podr칤an implementar elasticsearch, fluentd y kibana como contenedores. <br><br>  Aunque el instalador de OpenShift todav칤a est치 haciendo cambios en el sistema de archivos del servidor, todos los componentes principales del software ahora se pueden instalar utilizando im치genes de contenedor.  Por lo tanto, estos componentes en contenedores, por ejemplo, una instancia de la imagen etcd incrustada en OpenShift, nunca deber칤an, y no ser치n, utilizados para almacenar el c칩digo fuente de la aplicaci칩n con la que trabajan sus clientes, simplemente porque estos componentes en contenedores est치n destinados a ejecutarse como parte Plataforma de contenedores OpenShift. <br><br>  En las nuevas versiones de OpenShift, la tendencia hacia la contenedorizaci칩n de componentes solo se est치 intensificando, y otros desarrolladores de software utilizan cada vez m치s este enfoque. <br><br><h4>  Im치genes del desplegador </h4><br>  La imagen del desplegador es un tipo especial de contenedor que, cuando se inicia, implementa o administra otros contenedores.  Deployer le permite implementar esquemas de implementaci칩n complejos, por ejemplo, lanzar contenedores en un cierto orden o realizar algunas acciones al primer inicio, como generar un esquema de datos o llenar inicialmente la base de datos. <br><br>  Por ejemplo, en OpenShift, la plantilla "tipo de imagen / contenedor" se utiliza para implementar registros y m칠tricas.  La implementaci칩n de estos componentes utilizando im치genes de implementaci칩n permite a los ingenieros de OpenShift controlar el orden en que se ejecutan los distintos componentes y verificar que funcionan correctamente. <br><br><h4>  Im치genes intermedias </h4><br>  Una imagen intermedia es cualquier imagen de un contenedor que se basa en una imagen base.  Los ensamblajes del n칰cleo, el middleware y los tiempos de ejecuci칩n del lenguaje generalmente se implementan como capas adicionales en la parte superior de la imagen base y luego se especifican en la directiva FROM con esta imagen base.  Las im치genes intermedias generalmente no se usan solas, sino como bloques de construcci칩n para crear una imagen aut칩noma. <br><br>  Las diferentes capas de la imagen, por regla general, participan en diferentes grupos de especialistas.  Por ejemplo, los administradores del sistema son responsables de la capa de ensamblaje del n칰cleo y los desarrolladores de la capa de middleware.  Al mismo tiempo, las capas subyacentes preparadas por un equipo act칰an como una imagen intermedia para los responsables de las capas de un nivel superior.  Aunque a veces tales im치genes intermedias se pueden usar de forma aut칩noma, especialmente cuando se realizan pruebas. <br><br><h4>  Im치genes multiprop칩sito (intermodales) </h4><br>  Las im치genes de contenedor multiprop칩sito son im치genes con una arquitectura h칤brida.  Por ejemplo, muchas de las im치genes en Red Hat Software Collections se pueden usar de dos maneras.  En primer lugar, como contenedores de aplicaciones regulares con Ruby on Rails completo y el servidor Apache.  En segundo lugar, puede usarlos como im치genes de construcci칩n para OpenShift Container Platform y crear im치genes secundarias basadas en ellas que contengan Ruby on Rails, Apache y el c칩digo de aplicaci칩n que pas칩 al proceso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">origen a imagen</a> al construir una imagen secundaria de este tipo. <br><br>  Tenga en cuenta que las im치genes multiprop칩sito est치n ganando popularidad porque le permiten resolver dos tareas fundamentalmente diferentes utilizando la misma imagen. <br><br><h4>  Contenedores del sistema </h4><br>  Al implementar el software del sistema en forma de contenedores, estos 칰ltimos a menudo requieren privilegios de superusuario.  Para simplificar esta opci칩n de implementaci칩n y garantizar que dichos contenedores se inicien antes del tiempo de ejecuci칩n del contenedor y del sistema de orquestaci칩n, Red Hat ha desarrollado una plantilla especial llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedores del sistema</a> .  Estos contenedores se inician durante el proceso de arranque del sistema operativo utilizando systemd y el comando at칩mico, lo que los hace independientes de cualquier sistema de orquestaci칩n de contenedores o tiempo de ejecuci칩n.  Hoy, Red Hat ofrece contenedores del sistema para rsyslog, cockpit, etcd y flanneld y ampliar치 esta lista en el futuro. <br><br>  Los contenedores del sistema simplifican enormemente la adici칩n selectiva de estos servicios a Red Hat Enterprise Linux y Atomic Host. <br><br><h3>  Conclusi칩n </h3><br>  Los contenedores parecen ser algo bastante simple para el consumidor final, pero surgen muchas preguntas al construir un entorno de producci칩n de contenedores.  Para discutir fruct칤feramente la arquitectura y los m칠todos de construcci칩n de tales entornos, se requiere una terminolog칤a uniforme para todos los participantes.  Cuanto m치s profundice en el dise침o y la construcci칩n de dichos entornos, surgir치n m치s dificultades.  Finalmente, recordamos solo un par de ellos. <br><br>  Las personas a menudo no ven la diferencia entre los t칠rminos "imagen del contenedor" y "repositorio", especialmente cuando se usan en los comandos de Docker.  Pero si puede usar los comandos sin comprender las diferencias, cuando trabaje en la arquitectura de entornos de contenedor, debe comprender claramente que el repositorio es realmente la estructura de datos principal. <br><br>  Tambi칠n es bastante f치cil entender mal la diferencia entre espacios de nombres, repositorios, capas de im치genes y etiquetas.  Cada una de estas cosas tiene su prop칩sito en la arquitectura de contenedores.  Y aunque los proveedores y usuarios los usan para una variedad de prop칩sitos, son solo herramientas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/du/gj/fh/dugjfhpr95u8484ca-bttbr-3no.png"></div><br><br>  El prop칩sito de este art칤culo es ayudarlo a comprender la terminolog칤a para que pueda crear arquitecturas m치s avanzadas.  Por ejemplo, imagine que le acaban de encargar que desarrolle una infraestructura que deber칤a delimitar la disponibilidad de espacios de nombres, repositorios y, adem치s, etiquetas y capas dependiendo de los roles y las reglas comerciales.  Y el 칰ltimo: recuerde que la forma en que se ensambla el contenedor determina en gran medida c칩mo se inicia (orquestaci칩n, privilegios, etc.). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416827/">https://habr.com/ru/post/es416827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416817/index.html">3er lugar en la etapa de calificaci칩n de DataScienceGame 2018</a></li>
<li><a href="../es416819/index.html">Adi칩s, microservicios: de cien ni침os problem치ticos a una superestrella</a></li>
<li><a href="../es416821/index.html">C칩mo funciona JS: comunicaciones WebRTC y P2P</a></li>
<li><a href="../es416823/index.html">Sangre, sudor y p칤xeles: de qu칠 trata el libro de Jason Schreier</a></li>
<li><a href="../es416825/index.html">C칩mo no ser un desarrollador mediocre</a></li>
<li><a href="../es416829/index.html">Modelo de modelo ABI v0.5.6 Beta</a></li>
<li><a href="../es416831/index.html">El enrutamiento externo del tr치fico dom칠stico ruso se reducir치 al 5%</a></li>
<li><a href="../es416833/index.html">Bienvenido a MskDotNet Meetup # 24</a></li>
<li><a href="../es416837/index.html"># Dashanalune 0</a></li>
<li><a href="../es416839/index.html">Curso MIT "Seguridad de sistemas inform치ticos". Lecci칩n 3: Desbordamientos del b칰fer: exploits y protecci칩n, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>