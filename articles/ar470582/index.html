<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚦 🕣 🐩 فحص Telerik UI لـ UWP كطريقة للبدء باستخدام PVS-Studio 👴 ♠️ 💚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="أصبح من المألوف بالنسبة للمطورين المعينين حديثًا في فريق PVS-Studio أن يبدأوا بكتابة مقال يستعرض الأخطاء التي عثر عليها المحلل في مشروع مفتوح المصدر. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>فحص Telerik UI لـ UWP كطريقة للبدء باستخدام PVS-Studio</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/470582/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"></p><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/ww/cf/vp/wwcfvpz0hkpkv-ubqtskjfq2ahg.png" alt="الصورة 2"></div><br>  أصبح من المألوف بالنسبة للمطورين المعينين حديثًا في فريق PVS-Studio أن يبدأوا بكتابة مقال يستعرض الأخطاء التي عثر عليها المحلل في مشروع مفتوح المصدر.  Telerik UI for UWP هو المشروع الذي تم اختياره للمراجعة اليوم. <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  PVS-Studio محلل الكود </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">يعد PVS-Studio</a> أداة للكشف عن الأخطاء ونقاط الضعف المحتملة في التعليمات البرمجية المصدر للبرامج المكتوبة بلغات C و C ++ و C # و Java.  يعمل المحلل على أنظمة التشغيل Windows و Linux و macOS. <br><br>  يمكن تشغيل PVS-Studio بعدة طرق: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  كمكون إضافي لبرنامج Visual Studio أو IntelliJ IDEA محليًا على أجهزة الكمبيوتر الفردية للمطورين ؛ </li><li style=";text-align:right;direction:rtl">  من خلال الدمج مع SonarQube: منصة فحص جودة الكود المستمر ؛ </li><li style=";text-align:right;direction:rtl">  كتطبيق مستقل للدمج في نظام البناء ؛ </li><li style=";text-align:right;direction:rtl">  عن طريق تشغيل مع أداة مراقبة تجميع خاصة ؛ </li><li style=";text-align:right;direction:rtl">  من خلال التكامل مع Azure DevOps و Jenkins و TeamCity و Travis CI وأنظمة أخرى مماثلة ؛ </li><li style=";text-align:right;direction:rtl">  إلخ </li></ul><br><h2 style=";text-align:right;direction:rtl">  المشروع قيد التحليل </h2><br>  Telerik UI for UWP عبارة عن مجموعة من عناصر تحكم UI لنظام التشغيل Windows Universal Platform (UWP).  رمز مصدر المشروع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">متاح في جيثب</a> .  تتضمن المجموعة أكثر من 20 مكونًا مما يسمح للمستخدمين بتصور البيانات في شكل مخطط ، وإنشاء قوائم وجداول ، واستخدام خريطة لعرض المحتوى في سياق جغرافي. <br><br><h2 style=";text-align:right;direction:rtl">  مقتطفات برمجية مثيرة للاهتمام أبلغ عنها المحلل </h2><br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3013 من</a> الغريب أن تكون وظيفة "OnMinValuePropertyChanged" مساوية بالكامل لجسم وظيفة "OnMaxValuePropertyChanged".  RadGauge.cs 446 <br><br><pre style=";text-align:right;direction:rtl"><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMinValuePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> DependencyObject sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> newVal = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue; ValidateValue(newVal); RadGauge gauge = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGauge; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gauge.panel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { gauge.panel.UpdateOnMinMaxValueChange(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(AutomationPeer.ListenerExists(AutomationEvents.PropertyChanged)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peer = FrameworkElementAutomationPeer.FromElement(gauge) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGaugeAutomationPeer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (peer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { peer.RaiseMinimumPropertyChangedEvent((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.OldValue, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMaxValuePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> DependencyObject sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> newVal = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue; ValidateValue(newVal); RadGauge gauge = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGauge; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gauge.panel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { gauge.panel.UpdateOnMinMaxValueChange(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AutomationPeer.ListenerExists(AutomationEvents.PropertyChanged)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peer = FrameworkElementAutomationPeer.FromElement(gauge) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGaugeAutomationPeer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (peer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { peer.RaiseMinimumPropertyChangedEvent((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.OldValue, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue); } } }</code> </pre> <br>  طريقتين ، <i>OnMinValuePropertyChanged</i> و <i>OnMaxValuePropertyChanged</i> ، تنفيذ نفس الإجراءات.  أظن بشدة أن هناك خطأ هنا.  لاحظ أن كلا الطريقتين تستدعي نفس الأسلوب ، <i>RaiseMinimumPropertyChangedEvent</i> ، بينما <i>تطبق</i> فئة <i>RadGaugeAutomationPeer</i> الأساليب الفردية لـ "الحد الأدنى" و "الحد الأقصى": <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseMaximumPropertyChangedEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RaisePropertyChangedEvent( RangeValuePatternIdentifiers.MaximumProperty, oldValue, newValue); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseMinimumPropertyChangedEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RaisePropertyChangedEvent( RangeValuePatternIdentifiers.MinimumProperty, oldValue, newValue); }</code> </pre> <br>  يتم استخدام الأسلوب <i>RaiseMinimumPropertyChangedEvent</i> مرتين ، بينما لا يتم استخدام الأسلوب <i>RaiseMaximumPropertyChangedEvent</i> على الإطلاق.  هذا يجعلني أشك في أن أسلوب <i>OnMaxValuePropertyChanged</i> يعمل بشكل جيد ... أعتقد أنه كان من المفترض أن يبدو مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMaxValuePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> DependencyObject sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { .... peer.RaiseMaximumPropertyChangedEvent((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.OldValue, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue); .... }</code> </pre> <br>  ولكن حتى مع هذا الإصلاح ، لا يبدو الرمز أنيقًا بسبب العديد من العناصر المكررة.  من الصعب قراءتها ، كما أن الخطوط المتشابهة تشد انتباهك ، مما يجعل مراجعة الكود مهمة صعبة.  على العكس من ذلك ، يمكن لأدوات التحليل الثابت التعامل معها بسهولة (وهذا لا يعني أنه يجب عليك عدم إعادة تشكيل الكود الخاص بك ولا سيما إزالة الخطوط المكررة). <br><br>  بالنظر إلى هذه القطعة والجزء التالي ، أظن أن مؤلفي المشروع ينغمسون في نسخ نسخ بين الحين والآخر.  حسنا ، نحن جميعا نفعل ... :) <br><br>  <b>رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3001</a></b> هناك <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">عنصر</a></b> تعبير فرعي متطابق ". RenderSize == حجم فارغ" إلى اليسار وإلى يمين "||"  المشغل.  TiltInteractionEffect.cs 181 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInElementBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameworkElement element, Point position</span></span></span><span class="hljs-function">)</span></span> { Size emptySize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element.RenderSize == emptySize || element.RenderSize == emptySize) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(....).Contains(position); }</code> </pre> <br>  كلاً من معاملات '||'  عامل التشغيل في التعبير الشرطي للبيان ممثلاً بعبارات فرعية متطابقة.  من الواضح أن التعبير الثاني يجب أن يكون مختلفًا.  ربما كان المقصود من <i>RenderSize</i> الثاني أن يكون <i>DesiredSize</i> أو ربما يجب ألا يكون هناك subexpression الثاني على الإطلاق.  في أي حال ، يحتاج هذا الرمز إصلاح. <br><br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3001</a> هناك نص تعبيرات فرعية متطابقة '[0] ==' - '' إلى اليسار وإلى يمين '||'  المشغل.  RadNumericBox.cs 1057 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.textBox.Text; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text.Length == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; (text[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span> || text[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isNegative) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isNegative = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetText(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  تتم قراءة النص الذي تم إدخاله في حقل مربع النص في متغير.  ثم تتم مقارنة الحرف الأول في السلسلة مرتين بالحرف "-" ، والذي لا يبدو صحيحًا.  من الواضح أن هذه الوظيفة لا تؤدي عملية التحقق من صحة النص كما هو مقصود. <br><br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3001</a> هناك تعبيرات فرعية متطابقة "newValue.HasValue" إلى اليسار وإلى يمين المشغل "&amp;&amp;".  DateTimePicker.cs 576 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValueChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { DateTimePicker picker = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> DateTimePicker; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newValue = (DateTime?)args.NewValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newValue.HasValue &amp;&amp; newValue != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  تعبيرات الشرطية ، <i>newValue.HasValue</i> و <i>newValue! =</i> <i>Null</i> ، تُرجع <i>true</i> إذا كان <i>newValue</i> له قيمة.  يشير المحلل إلى ذلك ، ولكن ما إذا كان ينبغي إصلاح هذا الخطأ عن طريق إزالة أحد التعبيرات الفرعية أو عن طريق استبداله بأخرى (في حالة وجود شيء آخر لفحصه) ، فهذا شيء يمكن لمؤلفي هذا الرمز فقط اكتشافه. <br><br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3125</a> تم استخدام كائن "CurrentAttachedMenu" بعد التحقق من أنه لاغٍ.  خطوط التحقق: 98 ، 96. PopupService.cs 98 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PopupService</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Overlay_PointerPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentAttachedMenu == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !CurrentAttachedMenu.hitTestService. HitTest(e.GetCurrentPoint(CurrentAttachedMenu).Position).Any()) { CurrentAttachedMenu.IsOpen = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; HideOverlay(); } } }</code> </pre> <br>  إذا كان المتغير <i>CurrentAttachedMenu مساوياً للقيمة</i> <i>الخالية</i> ، <i>فسيؤدي</i> تقييم تعبير <i>CurrentAttachedMenu.IsOpen</i> إلى رفع استثناء.  يبدو الأمر كما لو أنه مجرد خطأ مطبعي والمطورين يعنيون في الواقع العملية المعاكسة ، '! =' ، بدلاً من التحقق الفارغ ، ولكن إذا كان هذا هو الحال ، <i>فشرط</i> العبارة <i>if</i> سوف يلقي استثناءًا إذا كان متغير <i>CurrentAttachedMenu</i> يساوي <i>لاغية</i> . <br><br>  كان هناك <b>37</b> تحذيرات أخرى من هذا النوع ، بعضها يشير على ما يبدو إلى أخطاء حقيقية.  لكن هذه تحذيرات كثيرة جدًا لمقال واحد ، لذلك سأتخطاها. <br><br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3019</a> ربما تتم مقارنة متغير غير صحيح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بالقيمة</a> الخالية بعد التحويل باستخدام كلمة "as".  تحقق من المتغيرات "dragDropElement" ، و "uiDragDropElement".  DragDrop.cs 91 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDrag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dragDropElement = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IDragDropElement; .... UIElement uiDragDropElement = dragDropElement <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UIElement; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dragDropElement == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !dragDropElement.CanStartDrag(trigger, initializeContext)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  يجب أن يكون مبرمجاً الخلط بين متغير واحد لآخر.  يتم إجراء التحقق الخالي من مرجع المصدر ، <i>dragDropElement</i> ، بدلاً من المرجع الناتج من المدلى بها ، <i>uiDragDropElement</i> ، وهو <i>المرجع</i> الذي تم التحقق منه بالفعل.  يتم دعم هذا الافتراض من خلال حقيقة أن <i>uiDragDropElement</i> يُستخدم بشكل أكبر دون أي <i>اختبارات</i> فارغة. <br><br>  <b>رسالة تشخيص PVS-Studio:</b> فحص متكرر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3030</a> .  تم التحقق من الشرط "! ShowIndicatorWhenNoData" بالفعل في السطر 139. RadDataBoundListBox.PullToRefresh.cs 141 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandlePullToRefreshItemStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item, ItemState state</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showIndicatorWhenNoData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ShowPullToRefreshWhenNoData; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.realizedItems.Count == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !showIndicatorWhenNoData) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == ItemState.Recycled &amp;&amp; !showIndicatorWhenNoData) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.StopPullToRefreshLoading(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HidePullToRefreshIndicator(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  تحقق حالتان من نفس المتغير <i>showIndicatorWhenNoData</i> .  قد يكون الفحص الثاني زائداً عن الحاجة ، لكن من الممكن أيضًا أن يكون أحد التعبيرات الفرعية المكررة شيئًا آخر تمامًا. <br><br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3031</a> يمكن تبسيط عملية التحقق المفرطة.  '||'  يحيط عامل التشغيل بعبارات معاكسة.  SelectedItemCollection.cs 77 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SelectedItemCollection</span></span> : <span class="hljs-title"><span class="hljs-title">ObservableCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanInsertItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspendLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowSelect &amp;&amp; ((!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowMultipleSelect &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowMultipleSelect); } }</code> </pre> <br>  من الناحية الفنية ، هذا المقتطف صحيح ؛  المحلل يشير فقط إلى بعض التكرار في هذه الحالة.  لكن ضع في اعتبارك أن التعليمات البرمجية المتكررة غالباً ما تكون علامة على وجود خطأ في البرمجة مثل التحقق من متغير واحد أكثر من اللازم بدلاً من متغير آخر. <br><br>  يمكن تبسيط الحالة قليلاً عن طريق إزالة التعليمات البرمجية غير الضرورية كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SelectedItemCollection</span></span> : <span class="hljs-title"><span class="hljs-title">ObservableCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanInsertItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspendLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowSelect &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowMultipleSelect || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br>  تحذيرات أخرى مماثلة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V3031 يمكن تبسيط عملية التحقق المفرطة.  '||'  يحيط بالمشغل تعبيرات معاكسة.  SelectedItemCollection.cs 93 </li><li style=";text-align:right;direction:rtl">  V3031 يمكن تبسيط عملية التحقق المفرطة.  '||'  يحيط بالمشغل تعبيرات معاكسة.  StackVirtualizationStrategy.cs 49 </li><li style=";text-align:right;direction:rtl">  V3031 يمكن تبسيط عملية التحقق المفرطة.  '||'  عامل التشغيل محاط بعبارات التعبيرات المعاكسة "الحالة == فارغة" و "الحالة! = فارغة".  LocalFieldDescriptionsProviderBase.cs 24 </li></ul><br>  لننظر في جزء آخر من التعليمات البرمجية ، أصدر المحلل ما يلي: <br><br>  <b>رسائل تشخيص PVS-Studio:</b> <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V3137 يتم تعيين متغير "leftMargin" ولكن لا يتم استخدامه بحلول نهاية الوظيفة.  DragDrop.cs 87 </li><li style=";text-align:right;direction:rtl">  V3137 يتم تعيين متغير "topMargin" ولكن لا يتم استخدامه بحلول نهاية الوظيفة.  DragDrop.cs 88 </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DragDrop</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> leftMargin = <span class="hljs-number"><span class="hljs-number">0</span></span>d; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> topMargin = <span class="hljs-number"><span class="hljs-number">0</span></span>d; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (frameworkElementSource != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { leftMargin = frameworkElementSource.Margin.Left; <span class="hljs-comment"><span class="hljs-comment">// &lt;= topMargin = frameworkElementSource.Margin.Top; // &lt;= } if (dragDropElement == null || !dragDropElement.CanStartDrag(trigger, initializeContext)) { return; } var context = dragDropElement .DragStarting(trigger, initializeContext); if (context == null) { return; } var startDragPosition = e .GetCurrentPoint(context.DragSurface.RootElement).Position; var relativeStartDragPosition = e .GetCurrentPoint(uiDragDropElement).Position; var dragPositionMode = DragDrop .GetDragPositionMode(uiDragDropElement); AddOperation(new DragDropOperation( context, dragDropElement, dragPositionMode, e.Pointer, startDragPosition, relativeStartDragPosition)); }</span></span></code> </pre> <br>  المتغيرات <i>leftMargin</i> و <i>topMargin</i> مساحات بعض القيم ولكن لم تستخدم بعد ذلك.  إنه ليس بالضرورة خطأ ، لكن الكود من هذا القبيل لا يزال يبدو مريبًا.  يمكن أن يكون علامة على خطأ مطبعي أو إعادة بيع سيئة. <br><br>  كان هناك تحذير آخر من هذا النوع: V3137 يتم تعيين متغير "currentColumnLength" ولكن لا يتم استخدامه بحلول نهاية الوظيفة.  WrapLayout.cs 824 <br><br>  <b>رسالة تشخيص PVS-Studio:</b> يتم دائمًا إعادة كتابة "فهرس" المعلمة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3061</a> في نص الطريقة قبل استخدامها.  DataEngine.cs 1443 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Tuple&lt;Group, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindGroupAndItemIndex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">.... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exhaustiveSearch) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aggregateRowGroup = rowRootGroup; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rowGroupNames = valueProvider.GetRowGroupNames(item); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> groupName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rowGroupNames) { Group <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aggregateRowGroup.TryGetGroup(groupName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { aggregateRowGroup = <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>; } } index = aggregateRowGroup.IndexOf(item, <span class="hljs-comment"><span class="hljs-comment">// &lt;= valueProvider.GetSortComparer()); return Tuple.Create(aggregateRowGroup, index); } }</span></span></code> </pre> <br>  يتم الكتابة فوق المعلمة <i>الفهرس</i> للأسلوب <i>FindGroupAndItemIndex</i> قبل الاستخدام.  على الأرجح ، يشير هذا إلى خطأ مبرمج. <br><br>  <b>رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3083</a></b> الاحتجاج غير الآمن للحدث "مكتمل" ، NullReferenceException ممكن.  النظر في تعيين الحدث إلى متغير محلي قبل استدعاء ذلك.  ActionBase.cs 32 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ActionBase</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsCompleted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Completed != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Completed(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); } } }</code> </pre> <br>  يتم استدعاء معالج الأحداث بطريقة غير آمنة محتملة ، في خطر رفع <i>NullReferenceException</i> .  سيحدث هذا إذا لم يكن هناك أي مشتركين متبقين بين الاختيار الفارغ واستدعاء معالج الحدث. <br><br>  يشير التقرير إلى <b>49</b> مشكلة أخرى من هذا النوع.  ليس من المثير للاهتمام مناقشتها هنا ، وبعد كل شيء ، يمكن لمؤلفي المشروع العثور عليها بسهولة باستخدام PVS-Studio بمفردهم ، لذلك دعونا ننتقل إلى الأمثلة التالية. <br><br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3145 إلغاء الأمان</a> غير الآمن لهدف WeakReference ، فكّر في فحص info.Target.  يمكن أن يكون الكائن قد تم تجميعه بين التحقق من "IsAlive" والوصول إلى خاصية "Target".  FadeAnimation.cs 84 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RadFadeAnimation</span></span> : <span class="hljs-title"><span class="hljs-title">RadAnimation</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyAnimationValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlayAnimationInfo info</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.Target.Opacity != opacity) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { info.Target.Opacity = opacity; } .... } .... }</span></span></code> </pre> <br>  قد يتم رفع <i>NullReferenceException</i> عند معالجة خاصية <i>info.Target.Opacity</i> .  لفهم المشكلة بشكل أفضل ، نحتاج إلى إلقاء نظرة على كتل معينة من فئة <i>PlayAnimationInfo</i> ، وخاصةً خاصية <i>Target</i> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayAnimationInfo</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WeakReference target; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayAnimationInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Storyboard storyboard, RadAnimation animation, UIElement target</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference(target); .... } .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UIElement Target { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target.IsAlive) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target.Target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UIElement; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } .... }</code> </pre> <br>  في الواقع ، كلما قمت بالبحث في هذا الرمز ، كلما زادت المشكلات المحتملة التي اكتشفتها.  دعونا نلقي نظرة على الأكثر إثارة للاهتمام - واحد الذي أثار التحذير.  المشكلة هي أنه حتى إذا كان التنفيذ يتبع الفرع <i>الآخر</i> من عبارة <i>if</i> ، فإنه لا يضمن إرجاع مرجع غير فارغ حتى لو لم نأخذ تأثيرات تحويل النوع في الاعتبار (يتم تهيئة الكائن بواسطة المنشئ) . <br><br>  كيف يكون ذلك ممكنا؟  كما ترى ، إذا كان الكائن المشار إليه بواسطة <i>WeakReference</i> قد تم جمعه من خلال جمع البيانات المهملة بين الاختيار <i>IsAlive</i> والدعوة إلى <i>الهدف</i> ، فإن هذا. <i>target.Target</i> سيعود <i>لاغية</i> .  أي أن التحقق من <i>IsAlive</i> لا يضمن أن الكائن سيظل متاحًا في المرة التالية التي تتصل فيها <i>بالهدف</i> . <br><br>  بالمناسبة ، <i>عودة فارغة.</i>  تم الكشف عن المشكلة عن طريق تشخيص آخر: V3080 dereference خالية ممكن.  النظر في تفتيش "info.Target".  FadeAnimation.cs 84 <br><br>  كان هناك عدد قليل من العيوب مثل هذا: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V3145 التراجع غير الآمن عن هدف WeakReference ، فكّر في فحص الهدف.  يمكن أن يكون الكائن قد تم تجميعه قبل الوصول إلى خاصية "الهدف".  MoveXAnimation.cs 80 </li><li style=";text-align:right;direction:rtl">  V3145 التراجع غير الآمن عن هدف WeakReference ، فكّر في فحص الهدف.  يمكن أن يكون الكائن قد تم تجميعه قبل الوصول إلى خاصية "الهدف".  MoveYAnimation.cs 80 </li><li style=";text-align:right;direction:rtl">  V3145 dereference غير الآمن لهدف WeakReference ، فكّر في فحص info.Target.  يمكن أن يكون الكائن قد تم تجميعه قبل الوصول إلى خاصية "الهدف".  PlaneProjectionAnimation.cs 244 </li><li style=";text-align:right;direction:rtl">  V3145 dreference غير آمن لهدف WeakReference.  يمكن أن يكون الكائن قد تم تجميعه بين التحقق من "IsAlive" والوصول إلى خاصية "Target".  WeakEventHandler.cs 109 </li></ul><br>  دعنا ننتقل إلى المثال التالي. <br><br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3066</a> تم تمرير الترتيب غير الصحيح المحتمل للوسيطات إلى مُنشئ 'NotifyCollectionChangedEventArgs': 'oldItem' و 'newItem'.  CheckedItemsCollection.cs 470 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CheckedItemsCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">INotifyCollectionChanged</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> NotifyCollectionChangedEventArgs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NotifyCollectionChangedAction.Add: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NotifyCollectionChangedAction.Remove: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NotifyCollectionChangedAction.Replace: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyCollectionChangedEventArgs( action, oldItem, newItem, changeIndex); <span class="hljs-comment"><span class="hljs-comment">// &lt;= default: return new NotifyCollectionChangedEventArgs(action); } } }</span></span></code> </pre> <br>  لمعرفة معنى هذا التحذير ، نحتاج إلى إلقاء نظرة على <i>معلمات</i> مُنشئ <i>NotifyCollectionChangedEventArgs</i> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NotifyCollectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> NotifyCollectionChangedAction action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newItem, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldItem, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  يخبرنا المحلل أن المتغيرات <i>oldItem</i> و <i>newItem</i> يتم <i>تبديلهما</i> في التعبير التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyCollectionChangedEventArgs( action, oldItem, newItem, changeIndex);</code> </pre> <br>  ومع ذلك ، فإن تطبيق المنشئ له تلك المتغيرات المدرجة في الترتيب المعاكس.  يمكنك فقط أن تتساءل عما إذا كان هذا قد تم عن قصد أم لا. <br><br>  <b>رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3102</a></b> وصول مشبوه إلى عنصر 'x' بواسطة فهرس ثابت داخل حلقة.  DataEngine.cs 1718 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ObjectArrayComparer</span></span> : <span class="hljs-title"><span class="hljs-title">IEqualityComparer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>[]&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] y</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; x.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.Equals(x[<span class="hljs-number"><span class="hljs-number">0</span></span>], y[<span class="hljs-number"><span class="hljs-number">0</span></span>])) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return false; } } return true; } .... }</span></span></code> </pre> <br>  تتم مقارنة العناصر <i>x [0]</i> و <i>y [0]</i> في كل تكرار حلقة.  ولكن بما أن العناصر الأولى فقط تتم مقارنتها ، فإن الحلقة لا معنى لها.  ربما يهدف المطورون إلى مقارنة العناصر الخاصة بالصفائف بدلاً من ذلك.  في هذه الحالة ، سيبدو الإصدار الصحيح كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; x.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.Equals(x[i], y[i])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3123</a> ربما يعمل المشغل '؟: بطريقة مختلفة عما كان متوقعًا.  أولويتها أقل من أولوية المشغلين الآخرين في حالتها.  EditRowHostPanel.cs 35 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Size </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureOverride</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Size availableSize</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> shouldUpdateRowHeight = editorLine == <span class="hljs-number"><span class="hljs-number">0</span></span> || displayedElement == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-literal"><span class="hljs-literal">false</span></span> : displayedElement.ContainerType != <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DataGridGroupHeader); .... }</code> </pre> <br>  يتعامل هذا التحذير مع استخدام المشغل '؟:'.  الأسبقية أقل من سابقتها <i>! = و ||</i> و <i>==</i> ، مما يعني أن ترتيب تقييم التعبير أعلاه قد يختلف عن المتوقع.  يبدو أن هذه الحالة بالذات إيجابية خاطئة ، حيث تعمل الشفرة فعليًا على النحو المنشود.  ولكن من الصعب للغاية قراءة مثل هذا الرمز ، ولا يمكنك أبدًا التأكد من فهمه بشكل صحيح.  يبدو كما لو كان مكتوبًا بهذه الطريقة بشكل متعمد حتى لا يتمكن أي شخص من معرفة ذلك :) أفضل طريقة لتسهيل قراءته هي استخدام الأقواس أو عبارة <i>if</i> . <br><br>  <b>رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3078</a></b> سيتم فقد ترتيب الفرز الأصلي بعد استدعاء متكرر لأسلوب "OrderBy".  استخدم طريقة "ThenBy" للحفاظ على التصنيف الأصلي.  GridModel.Selection.cs 107 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GridModel</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildCellSelectionRegions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MergeCellSelectionRegions(selectedItemsInView .OrderBy(c =&gt; c.Column.ItemInfo.LayoutInfo.Line) .OrderBy(c =&gt; c.RowItemInfo.LayoutInfo.Line)); } }</code> </pre> <br>  هذا الخطأ له علاقة باستدعاء متكرر للأسلوب <i>OrderBy</i> على مجموعة من النوع <i>IOrderedEnumerable</i> .  يتم فرز المجموعة أولاً حسب الأعمدة ثم حسب الصفوف.  المشكلة هي أن نتيجة الفرز الأول - حسب الأعمدة - لا يتم تخزينها في أي مكان وسيتم فقدها عند بدء التصنيف حسب الصفوف.  إذا كنت تريد الاحتفاظ بنتيجة الفرز حسب العمود <i>وتنفذ</i> معايير متعددة ، <i>فاستخدم</i> طريقة <i>ThenBy</i> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MergeCellSelectionRegions(selectedItemsInView .OrderBy(c =&gt; c.Column.ItemInfo.LayoutInfo.Line) .ThenBy(c =&gt; c.RowItemInfo.LayoutInfo.Line));</code> </pre> <br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3008</a> يتم تعيين قيم " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">currentColumnLength</a> " مرتين على التوالي.  ربما هذا خطأ.  خطوط التحقق: 791 ، 785. WrapLayout.cs 791 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAvailableLengthChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumnLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paddingValue = Math.Max(<span class="hljs-number"><span class="hljs-number">0</span></span>, newValue - currentColumnLength); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.paddingRenderInfo.Add(paddingValue); currentColumnLength = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= slotCount++; } this.ColumnSlotsRenderInfo.Update(i, newValue); this.paddingRenderInfo.Add(0); currentColumnLength = 0; // &lt;= slotCount++; continue; } else { .... } .... }</span></span></code> </pre> <br>  وجد المحلل أنه من الغريب أن يتم تحديد قيمة المتغير <i>currentColumnLength</i> مرتين بينما لا يتم استخدامه في أي مكان بين هاتين المهمتين.  بغض النظر عن الشرط ، فإن المتغير سينتهي به المطاف في النهاية.  هذا الرمز هو إما خاطئة أو زائدة عن الحاجة. <br><br>  <b>رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3127</a></b> تم العثور على شظايا رمز مشابه.  ربما ، هذا خطأ مطبعي ويجب استخدام متغير "blankIconContainer" بدلاً من RadRatingItem.cs 240 "fillIconContainer" <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RadRatingItem</span></span> : <span class="hljs-title"><span class="hljs-title">RadContentControl</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnApplyTemplate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.filledIconContainer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetTemplateChild( <span class="hljs-string"><span class="hljs-string">"FilledIconContainer"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Border; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.filledIconContainer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { throw new MissingTemplatePartException( "FilledIconContainer", typeof(Border)); } this.emptyIconContainer = this.GetTemplateChild( "EmptyIconContainer") as Border; if (this.filledIconContainer == null) // &lt;= { throw new MissingTemplatePartException( "EmptyIconContainer", typeof(Border)); } this.Initialize(); } .... }</span></span></code> </pre> <br>  ظهر الشرطان متطابقان أعلاه نتيجة خطأ مطبعي.  يشير الاستثناء الذي ألقاه هذا الرمز إلى أن الشرط الثاني يجب أن يبدو كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emptyIconContainer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MissingTemplatePartException( <span class="hljs-string"><span class="hljs-string">"EmptyIconContainer"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Border)); }</code> </pre> <br>  <b>رسالة تشخيص PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V3020</a> "فاصل" غير مشروط داخل حلقة.  NodePool.cs 189 <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;T&gt;&gt;&gt; GetUnfrozenDisplayedElements() { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generatedContainers) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> item.Value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pair.IsFrozen) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> <br>  بيان <i>الاستراحة</i> ليس جزءًا من عبارة <i>if</i> .  سيتم تنفيذه بغض النظر عن القيمة المخزّنة في <i>زوج</i> . إذا تم <i>تجميده</i> ، <i>فستكرر</i> حلقة <i>foreach</i> مرة واحدة فقط. <br><br>  هذا كل ما في تقييمي للأخطاء الموجودة في Telerik.  نحن على استعداد لتزويد المطورين بترخيص مؤقت مجاني حتى يتمكنوا من إجراء تحليل أكثر شمولًا وإصلاح العيوب.  يمكنهم أيضًا الاستفادة من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">خيارات ترخيص PVS-Studio</a> المجانية المتاحة للمطورين ذوي المصادر المفتوحة. <br><br><h2 style=";text-align:right;direction:rtl">  استنتاج </h2><br>  على الرغم من أن مؤلفي Telerik UI for UWP قاموا بعمل كبير في تطوير مشروعهم ، إلا أنهم ما زالوا يسمحون لعدد من الأخطاء المطبعية بالزحف ، كما يحدث عادة معنا :).  كان من الممكن اكتشاف كل هذه الأخطاء وإصلاحها بسهولة باستخدام محلل ثابت ، ولكن الشيء الأساسي الذي يجب تذكره حول التحليل الثابت هو أنه ينبغي استخدامه <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بالطريقة الصحيحة وعلى أساس منتظم</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar470582/">https://habr.com/ru/post/ar470582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar470568/index.html">نشر الأزرق والأخضر من تطبيقات الربيع مع خادم ويب Nginx</a></li>
<li><a href="../ar470570/index.html">GridmiAPI - مكتبة Android بسيطة ومرنة للعمل مع REST & RPC</a></li>
<li><a href="../ar470572/index.html">"أتمتة البنية التحتية. لماذا نفعل هذا؟ " (دينيس ياكوفليف)</a></li>
<li><a href="../ar470576/index.html">ستتخلص بنوك أمريكا في السنوات القادمة من 200000 وظيفة</a></li>
<li><a href="../ar470578/index.html">كيف "أنسنة" مسك الدفاتر في بنك للهاتف المحمول</a></li>
<li><a href="../ar470584/index.html">تحقق Telerik UI لـ UWP للتعرف على PVS-Studio</a></li>
<li><a href="../ar470592/index.html">استعراض Plesk - استضافة ومراقبة لوحات الموقع</a></li>
<li><a href="../ar470594/index.html">تقرير من المعرض الضوئي "دائرة الضوء" 2019 في موسكو</a></li>
<li><a href="../ar470596/index.html">ميزات Q و KDB + على مثال خدمة في الوقت الحقيقي</a></li>
<li><a href="../ar470598/index.html">كتاب "جافا الحديثة. تعبيرات Lambda ، والجداول ، والبرمجة الوظيفية "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>