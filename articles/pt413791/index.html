<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òØÔ∏è ü•´ üç∂ Mec√¢nica Qu√¢ntica de C√°lculos em JS üíß üë≥üèø üßúüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°, meu nome √© Dmitry Karlovsky e eu ... desempregado. Portanto, tenho muito tempo livre para tocar m√∫sica, esportes, criatividade, idiomas, confer√™n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mec√¢nica Qu√¢ntica de C√°lculos em JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413791/"><p> Ol√°, meu nome √© Dmitry Karlovsky e eu ... desempregado.  Portanto, tenho muito tempo livre para tocar m√∫sica, esportes, criatividade, idiomas, confer√™ncias em JS e ci√™ncia da computa√ß√£o.  Vou falar sobre as pesquisas mais recentes no campo da divis√£o semiautom√°tica de c√°lculos longos em pequenos quanta de v√°rios milissegundos, o que resultou em uma biblioteca em miniatura <code>$mol_fiber</code> .  Mas primeiro, vamos descrever os problemas que resolveremos .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/787/033/fb0/787033fb0e7d49cad98ce046a4e2380a.gif" alt="Quanta!"></p><br><p>  Esta √© uma vers√£o em texto da performance de mesmo nome no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HolyJS 2018 Piter</a> .  Voc√™ pode <a href="">l√™-lo como um artigo</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">abri-lo na interface de apresenta√ß√£o</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">assistir a um v√≠deo</a> . </p><a name="habracut"></a><br><h1 id="issue-low-responsiveness">  Problema: Baixa capacidade de resposta </h1><br><p>  Se queremos ter 60 quadros por segundo est√°veis, temos apenas 16 com uma ninharia de milissegundos para fazer todo o trabalho, incluindo o que o navegador faz para mostrar os resultados na tela. </p><br><p>  Mas e se tomarmos o fluxo por mais tempo?  Em seguida, o usu√°rio observar√° uma interface atrasada, inibindo a anima√ß√£o e similares da degrada√ß√£o do UX. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f8/b6f/431/9f8b6f43150f6aa318daf6bd7bde9e56.gif" alt="Baixa capacidade de resposta"></p><br><h1 id="issue-no-escape">  Problema: N√£o h√° escapat√≥ria </h1><br><p>  Acontece que, enquanto realizamos os c√°lculos, o resultado n√£o √© mais interessante para n√≥s.  Por exemplo, temos um pergaminho virtual, o usu√°rio o puxa ativamente, mas n√£o podemos acompanh√°-lo e n√£o podemos renderizar a √°rea real at√© que a renderiza√ß√£o anterior retorne o controle para processar eventos do usu√°rio. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/28d/4d9/12f/28d4d912fb979ddb97ac61f3bb314756.jpg" alt="N√£o pode ser desfeito"></p><br><p>  Idealmente, n√£o importa quanto tempo trabalhemos, devemos continuar processando eventos e poder cancelar a qualquer momento o trabalho que come√ßamos, mas ainda n√£o conclu√≠mos. </p><br><h1 id="im-fast-and-i-know-it">  Eu sou r√°pido e sei disso </h1><br><p>  Mas e se o nosso trabalho n√£o for um, mas v√°rios, mas um fluxo?  Imagine que voc√™ dirige com o l√≥tus amarelo rec√©m-adquirido e vai at√© a travessia ferrovi√°ria.  Quando est√° livre, voc√™ pode coloc√°-lo em uma fra√ß√£o de segundo.  Mas .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fcc/078/f2b/fcc078f2b90d03703c61d42ffe53701f.jpg" alt="Carro legal"></p><br><h1 id="issue-no-concurrency">  Problema: sem simultaneidade </h1><br><p>  Quando a travessia √© ocupada por um trem de um quil√¥metro, √© preciso ficar de p√© e esperar dez minutos at√© que ela passe.  N√£o √© por isso que voc√™ comprou um carro esportivo, certo? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0fe/ed1/d50/0feed1d50bc38d61f26f11d28f80a87c.gif" alt="Espera r√°pida lenta"></p><br><p>  E como seria legal se este trem fosse dividido em 10 trens de 100 metros cada e houvesse v√°rios minutos entre eles para passar!  Voc√™ n√£o chegaria t√£o tarde ent√£o. </p><br><p>  Ent√£o, quais s√£o as solu√ß√µes para esses problemas no mundo JS agora? </p><br><h1 id="solution-workers">  Solu√ß√£o: Trabalhadores </h1><br><p>  A primeira coisa que vem √† mente: vamos colocar todos os c√°lculos complexos em um segmento separado?  Para fazer isso, temos um mecanismo para WebWorkers. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6b/005/e78/f6b005e7836243e1434af86e1cc337cc.png" alt="L√≥gica dos Trabalhadores"></p><br><p>  Eventos do fluxo da interface do usu√°rio s√£o passados ‚Äã‚Äãpara o trabalhador.  L√° eles s√£o processados ‚Äã‚Äãe as instru√ß√µes sobre o que e como alterar na p√°gina j√° s√£o passadas de volta.  Assim, salvamos o fluxo da interface do usu√°rio de uma grande camada de computa√ß√£o, mas nem todos os problemas s√£o resolvidos dessa maneira e, al√©m disso, novos s√£o adicionados. </p><br><h1 id="workers-issues-deserialization">  Trabalhadores: problemas: (des) serializa√ß√£o </h1><br><p>  A comunica√ß√£o entre fluxos ocorre enviando mensagens serializadas em um fluxo de bytes, transferidas para outro fluxo e, em seguida, s√£o analisadas em objetos.  Tudo isso √© muito mais lento que uma chamada de m√©todo direta em um √∫nico encadeamento. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c76/7db/e9fc767db4a76ac2079610a2df590eaa.jpg" alt="(Des) serializa√ß√£o"></p><br><h1 id="workers-issues-asynchronous-only">  Trabalhadores: problemas: somente ass√≠ncrono </h1><br><p>  As mensagens s√£o transmitidas estritamente de forma ass√≠ncrona.  E isso significa que alguns recursos solicitados n√£o est√£o dispon√≠veis.  Por exemplo, voc√™ n√£o pode parar a ascens√£o de um evento de interface do usu√°rio de um trabalhador, pois quando o manipulador √© iniciado, o evento no encadeamento da interface do usu√°rio j√° completar√° seu ciclo de vida. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/083/1c9/d42/0831c9d4270c8a64e17febb2d509ec56.png" alt="Filas de mensagens"></p><br><h1 id="workers-issues-limited-apis">  Trabalhadores: problemas: APIs limitadas </h1><br><p>  As seguintes APIs n√£o est√£o dispon√≠veis para n√≥s nos trabalhadores. </p><br><ul><li>  DOM, CSSOM </li><li>  Tela </li><li>  Localiza√ß√£o geogr√°fica </li><li>  Hist√≥ria e Localiza√ß√£o </li><li>  Sincronizar solicita√ß√µes http </li><li>  XMLHttpRequest.responseXML </li><li>  Janela </li></ul><br><h1 id="workers-issues-cant-cancel">  Trabalhadores: Problemas: N√£o √© poss√≠vel cancelar </h1><br><p>  E, novamente, n√£o temos como parar os c√°lculos no woker. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/059/e49/064059e49ab01b803d84001dc2111da8.jpg" alt="Pare com isso!"></p><br><p>  Sim, podemos parar o trabalhador inteiro, mas isso interromper√° todas as tarefas nele. <br>  Sim, voc√™ pode executar cada tarefa em um trabalhador separado, mas consome muitos recursos. </p><br><h1 id="solution-react-fiber">  Solu√ß√£o: Reagir fibra </h1><br><p>  Certamente muitos ouviram o FaceBook reescrever heroicamente o React, dividindo todos os c√°lculos nele em um monte de pequenas fun√ß√µes lan√ßadas por um agendador especial. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/079/4f3/de4/0794f3de41b63342f7298e82f7d6bdb2.png" alt="Tricky React Fiber Logic"></p><br><p>  N√£o entrarei em detalhes de sua implementa√ß√£o, pois esse √© um grande t√≥pico separado.  Anotarei apenas alguns recursos, pelos quais pode n√£o ser adequado para voc√™. </p><br><h1 id="react-fiber-react-required">  Reagir fibra: Reagir necess√°rio </h1><br><p>  Obviamente, se voc√™ usar Angular, Vue ou outra estrutura diferente de React, o React Fiber ser√° in√∫til para voc√™. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/015/01e/1fa/01501e1fa047ab219dbaf0cd140e7002.jpg" alt="Reagir Everywere!"></p><br><h1 id="react-fiber-only-rendering">  React Fiber: Somente renderiza√ß√£o </h1><br><p>  React - cobre apenas a camada de renderiza√ß√£o.  Todas as outras camadas do aplicativo s√£o deixadas sem quantiza√ß√£o. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a82/3f5/c3e/a823f5c3e063d3961f64b0c18b25aa1b.gif" alt="N√£o √© t√£o r√°pido!"></p><br><p>  O React Fiber n√£o o salvar√° quando voc√™ precisar, por exemplo, filtrar um grande bloco de dados por condi√ß√µes dif√≠ceis. </p><br><h1 id="react-fiber-quantization-is-disabled">  React Fiber: A quantiza√ß√£o est√° desativada </h1><br><p>  Apesar do suporte alegado para quantiza√ß√£o, ele ainda est√° desativado por padr√£o, pois quebra a compatibilidade com vers√µes anteriores. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/498/f7b/4be/498f7b4be46edbbbf0884a71bccc89a8.jpg" alt="Armadilha de marketing"></p><br><p>  A quantiza√ß√£o no React ainda √© uma coisa experimental.  Cuidado! </p><br><h1 id="react-fiber-debug-is-pain">  Reagir fibra: depura√ß√£o √© dor </h1><br><p>  Quando voc√™ ativa a quantiza√ß√£o, o callstack n√£o corresponde mais ao seu c√≥digo, o que complica bastante a depura√ß√£o.  Mas retornaremos a esta quest√£o. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3dd/725/bd5/3dd725bd5c728f4ecc43f167f2724f63.jpg" alt="Toda a dor da depura√ß√£o"></p><br><h1 id="solution-quantization">  Solu√ß√£o: quantiza√ß√£o </h1><br><p>  Vamos tentar generalizar a abordagem React Fiber para se livrar das desvantagens mencionadas.  Queremos permanecer em um fluxo, mas dividimos c√°lculos longos em pequenas quanta, entre as quais o navegador pode processar as altera√ß√µes j√° feitas na p√°gina e responderemos a eventos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a98/9c5/e9e/a989c5e9e41bc35a36a656a7ce19d610.png" alt="gr√°ficos de chama"></p><br><p>  Acima, voc√™ v√™ um longo c√°lculo que parou o mundo inteiro em mais de 100ms.  E de baixo - o mesmo c√°lculo, mas dividido em fatias de tempo de cerca de 16ms, o que deu uma m√©dia de 60 quadros por segundo.  Como geralmente n√£o sabemos quanto tempo os c√°lculos levar√£o, n√£o podemos dividi-lo manualmente em 16ms de anteced√™ncia.  portanto, precisamos de algum tipo de mecanismo de tempo de execu√ß√£o que mede o tempo necess√°rio para concluir a tarefa e quando o quantum √© excedido, o que interrompe a execu√ß√£o at√© o pr√≥ximo quadro de anima√ß√£o.  Vamos pensar em quais mecanismos temos para implementar tarefas suspensas aqui .. </p><br><h1 id="concurrency-fibers--stackfull-coroutines">  Concorr√™ncia: fibras - stackfull coroutines </h1><br><p>  Em idiomas como Go e D, existe um idioma como uma "corotina com uma pilha", tamb√©m √© uma "fibra" ou "fibra". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Future } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-fibers'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> Future.wait( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">future</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( future.return ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> Future.task( four ).detach()</code> </pre> <br><p>  No exemplo de c√≥digo, voc√™ v√™ a <code>one</code> fun√ß√£o, que pode pausar a fibra atual, mas possui uma interface completamente s√≠ncrona.  As fun√ß√µes <code>two</code> , <code>three</code> e <code>four</code> s√£o fun√ß√µes s√≠ncronas regulares que n√£o sabem nada sobre fibra.  Neles, voc√™ pode usar todos os recursos do javascript na √≠ntegra.  E, finalmente, na √∫ltima linha, simplesmente executamos as <code>four</code> fun√ß√µes em uma fibra separada. </p><br><p>  O uso de fibras √© bastante conveniente, mas para suport√°-las, voc√™ precisa de suporte em tempo de execu√ß√£o, que a maioria dos int√©rpretes JS n√£o possui.  No entanto, para o NodeJS, h√° uma extens√£o nativa <code>node-fibers</code> que adiciona esse suporte.  Infelizmente, nenhum navegador est√° dispon√≠vel em nenhum navegador. </p><br><h1 id="concurrency-fsm--stackless-coroutines">  Simultaneidade: FSM - coroutines sem pilha </h1><br><p>  Em linguagens como C # e agora JS, h√° suporte para "coroutines sem pilha" ou "fun√ß√µes ass√≠ncronas".  Tais fun√ß√µes s√£o uma m√°quina de estado sob o cap√¥ e n√£o sabem nada sobre a pilha; portanto, elas precisam ser marcadas com a palavra-chave especial "async", e os locais onde podem ser pausadas s√£o "aguardam". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( done ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-function"><span class="hljs-params"> one(</span></span></span><span class="hljs-function">) ) + 1 </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">three</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> two() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> three() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> four()</code> </pre> <br><p>  Como podemos precisar adiar o c√°lculo a qualquer momento, acontece que quase todas as fun√ß√µes no aplicativo precisar√£o ser ass√≠ncronas.  Isso n√£o √© apenas a complexidade do c√≥digo, mas tamb√©m afeta muito o desempenho.  Al√©m disso, muitas APIs de aceita√ß√£o de retorno de chamada ainda n√£o oferecem suporte a retornos de chamada ass√≠ncronos.  Um exemplo impressionante √© o m√©todo de <code>reduce</code> de qualquer matriz. </p><br><h1 id="concurrency-semi-fibers---restarts">  Simultaneidade: semi-fibras - reinicia </h1><br><p>  Vamos tentar fazer algo semelhante √† fibra, usando apenas os recursos dispon√≠veis em qualquer navegador moderno. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async , $mol_fiber_start } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> $mol_fiber_async( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( back ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> $mol_fiber_start( four )</code> </pre> <br><p>  Como voc√™ pode ver, as fun√ß√µes intermedi√°rias n√£o sabem nada sobre interrup√ß√£o - isso √© JS comum.  Somente a <code>one</code> fun√ß√£o sabe da possibilidade de suspens√£o.  Para abortar o c√°lculo, ela simplesmente lan√ßa <code>Promise</code> como uma exce√ß√£o.  Na √∫ltima linha, executamos a fun√ß√£o <code>four</code> em uma pseudo-fibra separada, que monitora as exce√ß√µes lan√ßadas no interior e, se o <code>Promise</code> chegar, assina sua <code>resolve</code> e reinicia a fibra. </p><br><h1 id="figures">  Figuras </h1><br><p>  Para mostrar como as pseudo-fibras funcionam, escreveremos um c√≥digo complicado. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dce/e56/26a/dcee5626ad6c81048ca43a54a2825fe4.svg" alt="Gr√°fico de execu√ß√£o t√≠pico"></p><br><p>  Vamos imaginar que a fun√ß√£o <code>step</code> aqui grave algo no console e fa√ßa algum outro trabalho duro por 20ms.  E a fun√ß√£o <code>walk</code> chama o <code>step</code> duas vezes, registrando todo o processo.  No meio, ele mostrar√° o que agora √© exibido no console.  E √† direita est√° o estado da √°rvore de pseudo-fibra. </p><br><h1 id="mol_fiber-no-quantization">  $ mol_fiber: sem quantiza√ß√£o </h1><br><p>  Vamos executar esse c√≥digo e ver o que acontece .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aa0/8aa/d4e/aa08aad4e3770368fd787aba5e8fcf81.svg" alt="Execu√ß√£o sem quantiza√ß√£o"></p><br><p>  At√© agora, tudo √© simples e √≥bvio.  A √°rvore de pseudo-fibra, √© claro, n√£o est√° envolvida.  E tudo ficaria bem, mas esse c√≥digo √© executado por mais de 40 ms, o que √© in√∫til. </p><br><h1 id="mol_fiber-cache-first">  $ mol_fiber: cache primeiro </h1><br><p>  Vamos agrupar as duas fun√ß√µes em um inv√≥lucro especial que o executa em uma pseudo-fibra e ver o que acontece. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f2/7e3/2f9/1f27e32f982035e32f59c4100aac3dd0.svg" alt="Caches de preenchimento"></p><br><p>  Aqui vale a pena prestar aten√ß√£o ao fato de que para cada local de chamada da <code>one</code> fun√ß√£o dentro da fibra de <code>walk</code> , uma fibra separada foi criada.  O resultado da primeira chamada foi armazenado em cache, mas, em vez da segunda, a <code>Promise</code> foi lan√ßada, pois t√≠nhamos esgotado nosso tempo. </p><br><h1 id="mol_fiber-cache-second">  $ mol_fiber: cache segundo </h1><br><p>  Lan√ßada no primeiro quadro, o <code>Promise</code> ser√° resolvido automaticamente no pr√≥ximo, o que levar√° ao rein√≠cio da fibra de <code>walk</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ec/d06/80b/2ecd0680bb11b2b425c2464e8d119362.svg" alt="Reutiliza√ß√£o de cache"></p><br><p>  Como voc√™ pode ver, devido ao rein√≠cio, produzimos novamente ‚Äústart‚Äù e ‚Äúfirst done‚Äù para o console, mas ‚Äúfirst begin‚Äù n√£o est√° mais l√°, pois est√° na fibra com o cache preenchido anteriormente, raz√£o pela qual seu manipulador √© mais n√£o chamado.  Quando o cache da fibra de <code>walk</code> √© preenchido, todas as fibras incorporadas s√£o destru√≠das, pois a execu√ß√£o nunca as alcan√ßar√°. </p><br><p>  Ent√£o, por que voc√™ <code>first begin</code> imprimir uma vez e <code>first done</code> duas?  √â tudo sobre idempot√™ncia.  <code>console.log</code> - opera√ß√£o n√£o idempotente, quantas vezes voc√™ o chama, tantas vezes ele adiciona uma entrada ao console.  Mas a fibra que est√° sendo executada em outra fibra √© idempotente, apenas executa o identificador na primeira chamada e, nos retornos subsequentes, imediatamente o resultado do cache, sem levar a efeitos colaterais adicionais. </p><br><h1 id="mol_fiber-idempotence-first">  $ mol_fiber: idempot√™ncia primeiro </h1><br><p>  Vamos agrupar <code>console.log</code> em uma fibra, tornando-a idempotente e ver como o programa se comporta. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/340/552/c63/340552c63f8356ee7b680ae76558ec90.svg" alt="preenchendo caches idempotentes"></p><br><p>  Como voc√™ pode ver, agora na √°rvore de fibras temos entradas para cada chamada para a fun√ß√£o de <code>log</code> . </p><br><h1 id="mol_fiber-idempotence-second">  $ mol_fiber: idempot√™ncia em segundo </h1><br><p>  Na pr√≥xima reinicializa√ß√£o da fibra <code>walk</code> , chamadas repetidas para a fun√ß√£o <code>log</code> n√£o levam mais a chamadas para o <code>console.log</code> real, mas assim que chegamos √† execu√ß√£o das fibras com um cache vazio, as chamadas para <code>console.log</code> retomadas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b32/2ac/e0b/b322ace0b34b91d3db8c52cbf78599f5.svg" alt="Reutilizando Caches Idempotentes"></p><br><p>  Observe que no console agora n√£o exibimos nada sup√©rfluo - exatamente o que seria exibido no c√≥digo s√≠ncrono sem fibra e quantifica√ß√£o. </p><br><h1 id="mol_fiber-break">  $ mol_fiber: break </h1><br><p>  Como o c√°lculo √© interrompido?  No in√≠cio do quantum, um prazo √© definido.  E antes de iniciar cada fibra, √© verificado se a alcan√ßamos.  E se voc√™ chegar, ent√£o <code>Promise</code> corre, o que √© resolvido no pr√≥ximo quadro e inicia um novo quantum. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) }</code> </pre> <br><h1 id="mol_fiber-deadline">  $ mol_fiber: prazo </h1><br><p>  O prazo para o quantum √© f√°cil de definir.  8 milissegundos s√£o adicionados ao hor√°rio atual.  Por que exatamente 8, porque existem at√© 16 para preparar a foto?  O fato √© que n√£o sabemos antecipadamente quanto tempo o navegador precisar√° renderizar, portanto, precisamos deixar algum tempo para que ele funcione.  Mas √†s vezes acontece que o navegador n√£o precisa renderizar nada e, com 8 ms de quanta, podemos inserir outro quantum no mesmo quadro, o que fornecer√° um pacote denso de quanta com tempo de inatividade m√≠nimo do processador. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> now = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quant = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elapsed = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max( <span class="hljs-number"><span class="hljs-number">0</span></span> , now - $mol_fiber.deadline ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resistance = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( elapsed , <span class="hljs-number"><span class="hljs-number">1000</span></span> ) / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 .. 100 ms $mol_fiber.deadline = now + quant + resistence</span></span></code> </pre> <br><p>  Mas se lan√ßarmos uma exce√ß√£o a cada 8ms, a depura√ß√£o com a exce√ß√£o ativada se transformar√° em um pequeno ramo do inferno.  Precisamos de algum mecanismo para detectar esse modo de depurador.  Infelizmente, isso s√≥ pode ser entendido indiretamente: uma pessoa leva cerca de um segundo para entender se deve continuar executando ou n√£o.  E isso significa que, se o controle n√£o retornar ao script por muito tempo, o depurador ser√° interrompido ou haver√° um c√°lculo pesado.  Para sentar em ambas as cadeiras, adicionamos ao quantum 10% do tempo decorrido, mas n√£o mais que 100 ms.  Isso n√£o afeta muito o FPS, mas reduz a frequ√™ncia de parada do depurador em uma ordem de magnitude devido √† quantiza√ß√£o. </p><br><h1 id="debug-trycatch">  Depura√ß√£o: try / catch </h1><br><p>  Como estamos falando sobre depura√ß√£o, o que voc√™ acha, em que lugar desse c√≥digo o depurador para? </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new Error( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) // [<span class="hljs-number"><span class="hljs-number">1</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { foo() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { handle( error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error // [<span class="hljs-number"><span class="hljs-number">2</span></span>] }</code> </pre> <br><p>  Como regra, ele precisa parar onde a exce√ß√£o √© lan√ßada pela primeira vez, mas a realidade √© que ele para apenas onde foi lan√ßada pela √∫ltima vez, o que geralmente √© muito longe de onde ocorreu.  Portanto, para n√£o complicar a depura√ß√£o, as exce√ß√µes nunca devem ser capturadas atrav√©s do try-catch.  Mas mesmo sem manipula√ß√£o de exce√ß√£o √© imposs√≠vel. </p><br><h1 id="debug-unhandled-events">  Depura√ß√£o: eventos n√£o manipulados </h1><br><p>  Normalmente, um tempo de execu√ß√£o fornece um evento global que ocorre para cada exce√ß√£o n√£o capturada. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener( <span class="hljs-string"><span class="hljs-string">'error'</span></span> , event =&gt; handle( event.error ) ) foo()</code> </pre> <br><p>  Al√©m da inconveni√™ncia, essa solu√ß√£o tem uma desvantagem que todas as exce√ß√µes se enquadram aqui e √© bastante dif√≠cil entender de qual fibra e fibra se o evento ocorreu. </p><br><h1 id="debug-promise">  Depura√ß√£o: Promessa </h1><br><p>  Promessas s√£o a melhor maneira de lidar com exce√ß√µes. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { foo() } ).catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> handle( error ) )</code> </pre> <br><p>  A fun√ß√£o passada para o Promise √© chamada imediatamente, de forma s√≠ncrona, mas a exce√ß√£o n√£o √© capturada e para com seguran√ßa o depurador no lugar de sua ocorr√™ncia.  Um pouco mais tarde, de forma ass√≠ncrona, ele j√° chama o manipulador de erros, no qual sabemos exatamente qual fibra causou a falha e qual falha.  Este √© precisamente o mecanismo usado no $ mol_fiber. </p><br><h1 id="stack-trace-react-fiber">  Rastreamento de pilha: reagir fibra </h1><br><p>  Vamos dar uma olhada no rastreamento de pilha que voc√™ obt√©m no React Fiber .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/074/97d/d53/07497dd53b67863fe121c9cc7d314f96.png" alt="Stackrace vazio"></p><br><p>  Como voc√™ pode ver, temos muita rea√ß√£o no est√¥mago.  Do √∫til aqui, apenas o ponto de ocorr√™ncia da exce√ß√£o e os nomes dos componentes s√£o mais altos na hierarquia.  N√£o muito. </p><br><h1 id="stack-trace-mol_fiber">  Rastreamento de pilha: $ mol_fiber </h1><br><p>  No $ mol_fiber, obtemos um rastreamento de pilha muito mais √∫til: sem tripas, apenas pontos espec√≠ficos no c√≥digo do aplicativo atrav√©s do qual houve uma exce√ß√£o. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b8/99d/8cc/5b899d8ccd70b5489cf87fea439beb5a.png" alt="Conte√∫do strace"></p><br><p>  Isto √© conseguido atrav√©s do uso da pilha nativa, promessas e remo√ß√£o autom√°tica dos intestinos.  Se desejar, voc√™ pode expandir o erro no console, como na captura de tela, e ver as entranhas, mas n√£o h√° nada de interessante. </p><br><h1 id="mol_fiber-handle">  $ mol_fiber: handle </h1><br><p>  Ent√£o, para interromper um quantum, Promise √© lan√ßado. </p><br><pre> <code class="hljs javascript">limit() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Mas, como voc√™ pode imaginar, Promise pode ser absolutamente qualquer coisa - para uma fibra, de um modo geral, n√£o importa o que esperar: o pr√≥ximo quadro, a conclus√£o do carregamento de dados ou algo mais. </p><br><pre> <code class="hljs javascript">fail( error : <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> self.start() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.then( listener , listener ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  O Fiber simplesmente se inscreve para resolver promessas e reinicializa√ß√µes.  Mas n√£o √© necess√°rio lan√ßar e receber promessas manualmente, porque o pacote inclui v√°rios inv√≥lucros √∫teis. </p><br><h1 id="mol_fiber-functions">  $ mol_fiber: fun√ß√µes </h1><br><p>  Para transformar qualquer fun√ß√£o s√≠ncrona em uma fibra idempotente, envolva-a em <code>$mol_fiber_func</code> .. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = fiberize( <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> main = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { log( getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ).data ) } )</code> </pre> <br><p>  Aqui, tornamos o <code>console.log</code> idempotente e o <code>main</code> ensinou a interromper enquanto aguardava o download. </p><br><h1 id="mol_fiber-error-handling">  $ mol_fiber: tratamento de erros </h1><br><p>  Mas como responder a exce√ß√µes se n√£o queremos usar o <code>try-catch</code> ?  Em seguida, podemos registrar o manipulador de erros com <code>$mol_fiber_catch</code> ... </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize , $mol_fiber_catch <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> onError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getConfig = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { onError( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> }) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getData( <span class="hljs-string"><span class="hljs-string">'/config'</span></span> ).data } )</code> </pre> <br><p>  Se retornarmos algo diferente do erro nele, ser√° o resultado da fibra atual.  Neste exemplo, se n√£o for poss√≠vel fazer o download da configura√ß√£o do servidor, a fun√ß√£o <code>getConfig</code> retornar√° a configura√ß√£o por padr√£o. </p><br><h1 id="mol_fiber-methods">  $ mol_fiber: m√©todos </h1><br><p>  Obviamente, voc√™ pode agrupar n√£o apenas fun√ß√µes, mas tamb√©m m√©todos usando um decorador. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_method <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mover</span></span></span><span class="hljs-class"> </span></span>{ @action move() { sendData( <span class="hljs-string"><span class="hljs-string">'ya.ru'</span></span> , getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ) ) } }</code> </pre> <br><p>  Aqui, por exemplo, carregamos dados do Google e no Yandex. </p><br><h1 id="mol_fiber-promises">  $ mol_fiber: promessas </h1><br><p>  Para baixar dados do servidor, basta levar, por exemplo, a <code>fetch</code> ass√≠ncrona da fun√ß√£o e, com um movimento do pulso, transform√°-la em s√≠ncrona. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_sync <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sync } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getData = sync( fetch )</code> </pre> <br><p>  Essa implementa√ß√£o √© boa para todos, mas n√£o suporta o cancelamento de uma solicita√ß√£o quando uma √°rvore de fibras √© destru√≠da; portanto, precisamos usar uma <code>API</code> mais confusa. </p><br><h1 id="mol_fiber-cancel-request">  $ mol_fiber: solicita√ß√£o de cancelamento </h1><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> uri : string </span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AbortController(); fetch( uri , { <span class="hljs-attr"><span class="hljs-attr">signal</span></span> : controller.signal } ).then( back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> res ) , back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error } ) , ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> controller.abort() } ) }</code> </pre> <br><p>  A fun√ß√£o passada para o wrapper <code>async</code> √© chamada apenas uma vez e o wrapper de <code>back</code> √© passado para ele, no qual √© necess√°rio agrupar os retornos de chamada.  Portanto, nesses retornos de chamada, voc√™ deve retornar o valor ou lan√ßar uma exce√ß√£o.  Qualquer que seja o resultado do retorno de chamada, ele tamb√©m ser√° o resultado da fibra.  Observe que, no final, retornamos uma fun√ß√£o que ser√° chamada em caso de destrui√ß√£o prematura da fibra. </p><br><h1 id="mol_fiber-cancel-response">  $ mol_fiber: cancelar resposta </h1><br><p>  No lado do servidor, tamb√©m pode ser √∫til cancelar o c√°lculo quando o cliente cair.  Vamos implementar um wrapper sobre o <code>midleware</code> que criar√° uma fibra na qual o <code>midleware</code> original ser√° executado.     ,    ,       ,      . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_make <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Fiber } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> const middle_fiber = middleware =&gt; ( req , res ) =&gt; { const fiber = Fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> middleware( req , res ) ) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>( <span class="hljs-string"><span class="hljs-string">'close'</span></span> , <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> fiber.destructor() ) fiber.start() } app.get( <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> , middle_fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( req , res )</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something } ) )</code> </pre> <br><h1 id="mol_fiber-concurrency"> $mol_fiber: concurrency </h1><br><p>       ,         .  ,    3 :    ,     ,   - .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/257/b87/a50/257b87a5095cecaf0e53da2234666a62.png" alt="Solicita√ß√µes r√°pidas e lentas"></p><br><p>      :      ,    .       .       ,       ,   . </p><br><h1 id="mol_fiber-properties"> $mol_fiber: properties </h1><br><p>  ,    .. </p><br><blockquote> <strong>Pros:</strong> <br><ul><li> Runtime support isn't required </li><li> Can be cancelled at any time </li><li> High FPS </li><li> Concurrent execution </li><li> Debug friendly </li><li> ~ 3KB gzipped </li></ul><br><br> <strong>Cons:</strong> <br><ul><li> Instrumentation is required </li><li> All code should be idempotent </li><li> Longer total execution </li></ul><br></blockquote><p> $mol_fiber ‚Äî   ,         .  ‚Äî ,            .      , ,    .  ,   ,     ,     ,      .  ,          .        . </p><br><h1 id="links"> Links </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nin-jin.github.io/slides/fibers/</a> ‚Äî this slides </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mol.js.org/fiber</a> ‚Äî $mol_fiber online demo </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/eigenmethod/mol/tree/master/fiber</a> ‚Äî $mol_fiber documentation </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">t.me/mam_mol</a> ‚Äî lovely $mol chat </li></ul><br><h1 id="call-back"> Call back </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d35/cd4/554/d35cd4554553fa35a7d756cbf9737949.jpg" alt="Coment√°rios"></p><br><p> <strong></strong> :   , ,        ) </p><br><p> <strong></strong> :  ,       . </p><br><p> <strong></strong> :  .    ,        . </p><br><p> <strong></strong> :    .   ,        .   ,    . </p><br><p> <strong></strong> :   ,            .     ,      ) </p><br><p> <strong></strong> :    ,     . </p><br><p> <strong></strong> :    -      .   ,        ,     . </p><br><p> <strong></strong> :       .  ,  ,     . </p><br><p> <strong></strong> :  ,     .     16ms,     ?  16  8 ,      8,   .      ,       .            ,    ¬´¬ª. </p><br><p> <strong></strong> :      ‚Äî       .  Obrigada </p><br><p> <strong></strong> :    .    ,   .  ! </p><br><p> <strong></strong> :  ,         .        . </p><br><p> <strong></strong> :  ,     ,            ,      ,     ,     / ,            . </p><br><p> <strong></strong> :  ,     . </p><br><p> <strong></strong> :  . </p><br><p> <strong></strong> :         ,     .      mol. </p><br><p> <strong></strong> :    ,     ,    . ,  ,  ,   . </p><br><p> <strong></strong> :   . </p><br><p> <strong></strong> :       ,     .   ,     $mol,    ,  . </p><br><p> <strong></strong> :  ,  ,      .            ‚Äî .  . </p><br><p> <strong></strong> :  -   ,         . </p><br><p> <strong></strong> :       $mol    ,        .  (pdf,  )  ,      . </p><br><p> <strong></strong> :     ,   .   ,     . </p><br><p> <strong></strong> :   ,    )       . </p><br><p> <strong></strong> :   .  . </p><br><p> <strong></strong> : In some places I missed what the reporter was saying. The conversation was about how to use the "Mola" library and "why?". But how it works remains a mystery for me.To smoke an source code is for the overhead. </p><br><p> <strong> </strong> :  ,  . </p><br><p> <strong> </strong> :  .         ,    .       .        . </p><br><p> <strong> </strong> :     :     .   -      (,   ).           ,   :          16? </p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ou menos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : eu n√£o trabalhei com fibra. </font><font style="vertical-align: inherit;">No relat√≥rio, ouvi a teoria do trabalho da fibra. </font><font style="vertical-align: inherit;">Mas eu absolutamente n√£o descobri como usar o mol_fiber em casa ... Pequenos exemplos s√£o √≥timos, mas como isso pode ser aplicado em um aplicativo grande com 30fps para acelerar para 60fps - n√£o havia entendimento. </font><font style="vertical-align: inherit;">Agora, se o autor prestasse mais aten√ß√£o a este e menos design do m√≥dulo interno - a classifica√ß√£o seria maior.</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413791/">https://habr.com/ru/post/pt413791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413779/index.html">Temporizadores e multitarefa no Arduino</a></li>
<li><a href="../pt413781/index.html">Como os Bloodhounds de publicidade seguem sua trilha na Internet</a></li>
<li><a href="../pt413783/index.html">Como morrem as estrelas mais massivas: supernova, hipernova ou colapso direto?</a></li>
<li><a href="../pt413787/index.html">Angular: ngx-translate. Melhorando a infraestrutura com o Webpack</a></li>
<li><a href="../pt413789/index.html">Na Fl√≥rida, eles n√£o verificaram os compradores de armas na base do FBI por um ano porque esqueceram a senha</a></li>
<li><a href="../pt413793/index.html">Cassetes de √°udio na cultura pop: por que o formato obsoleto de grava√ß√£o de som √© novamente considerado moda</a></li>
<li><a href="../pt413795/index.html">Por que a ind√∫stria do entretenimento est√° mudando para o IaaS: estudo de caso</a></li>
<li><a href="../pt413797/index.html">A EA apresentou a nova parte do C&C na E3. E √© fisicamente doloroso olhar para ele</a></li>
<li><a href="../pt413799/index.html">Contagem de abelhas na rede neural do Raspberry Pi</a></li>
<li><a href="../pt413801/index.html">"Roskosmos" oferece refazer um canh√£o laser ... um telesc√≥pio √≥ptico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>