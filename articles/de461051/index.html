<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÖ ‚ôÇÔ∏è ‚úâÔ∏è Top 10 der h√§ufigsten Fehler, auf die ich in Go-Projekten gesto√üen bin üö≥ üî¥ üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Beitrag ist einer der h√§ufigsten Fehler, die ich in Go-Projekten festgestellt habe. Ordnung spielt keine Rolle. 



 Unbekannter Wert von Enum ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 der h√§ufigsten Fehler, auf die ich in Go-Projekten gesto√üen bin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461051/">  <b><i>Dieser Beitrag ist einer der h√§ufigsten Fehler, die ich in Go-Projekten festgestellt habe.</i></b>  Ordnung spielt keine Rolle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b01/9ed/114/b019ed114553265d5cd0c773c2d2e2c6.jpg" alt="Bild"><br><br><h3>  Unbekannter Wert von Enum </h3><br>  Schauen wir uns ein einfaches Beispiel an: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusOpen Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusClosed StatusUnknown )</code> </pre> <br>  Hier erstellen wir mit iota einen Enumerator, der zu diesem Status f√ºhrt: <br><br><pre> <code class="go hljs">StatusOpen = <span class="hljs-number"><span class="hljs-number">0</span></span> StatusClosed = <span class="hljs-number"><span class="hljs-number">1</span></span> StatusUnknown = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <a name="habracut"></a><br>  Stellen wir uns nun vor, dass diese Art von Status Teil der JSON-Anforderung ist, die gepackt / entpackt wird.  Wir k√∂nnen die folgende Struktur entwerfen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Id"`</span></span> Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Timestamp"`</span></span> Status Status <span class="hljs-string"><span class="hljs-string">`json:"Status"`</span></span> }</code> </pre> <br>  Dann erhalten wir dieses Abfrageergebnis: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Status"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Im Allgemeinen nichts Besonderes - Status wird in StatusOpen entpackt. <br>  Lassen Sie uns nun eine weitere Antwort erhalten, bei der der Statuswert nicht festgelegt ist: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span> }</code> </pre> <br>  In diesem Fall wird das Statusfeld der Anforderungsstruktur auf Null initialisiert (f√ºr uint32 ist es 0).  Daher erhalten wir wieder StatusOpen anstelle von StatusUnknown. <br><br>  In diesem Fall ist es am besten, zuerst den unbekannten Wert des Enumerators einzustellen - d. H.  0: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusUnknown Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusOpen StatusClosed )</code> </pre><br>  Wenn der Status nicht Teil der JSON-Anforderung ist, wird er erwartungsgem√§√ü in StatusUnknown initialisiert. <br><br><h3>  Benchmarking </h3><br>  Richtiges Benchmarking ist ziemlich schwierig.  Zu viele Faktoren k√∂nnen das Ergebnis beeinflussen. <br><br>  Ein h√§ufiger Fehler wird durch Compiler-Optimierungen ausgetrickst.  Sehen wir uns ein konkretes Beispiel aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">teivah / bitvector-Bibliothek an</a> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.MaxUint64&lt;&lt;j | ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; n }</code> </pre> <br>  Diese Funktion l√∂scht Bits in einem bestimmten Bereich.  Wir k√∂nnen die Leistung folgenderma√üen testen: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkWrong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } }</code> </pre> <br>  In diesem Test wird der Compiler feststellen, dass clear keine andere Funktion aufruft und sie einfach so einbettet, wie sie ist.  Sobald es eingebaut ist, sieht der Compiler, dass keine Nebenwirkungen auftreten.  Somit wird der eindeutige Anruf einfach gel√∂scht, was zu ungenauen Ergebnissen f√ºhrt. <br><br>  Eine L√∂sung kann darin bestehen, das Ergebnis auf eine globale Variable wie diese festzulegen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkCorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } result = r }</code> </pre> <br>  Hier wei√ü der Compiler nicht, ob der Aufruf einen Nebeneffekt erzeugt.  Daher ist der Benchmark genau. <br><br><h3>  Zeiger!  Zeiger sind √ºberall! </h3><br>  Wenn Sie eine Variable als Wert √ºbergeben, wird eine Kopie dieser Variablen erstellt.  Kopieren Sie beim √úbergeben des Zeigers einfach die Adresse in den Speicher. <br><br>  Folglich ist das √úbergeben eines Zeigers immer schneller, oder? <br><br>  Wenn Sie so denken, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Beispiel an</a> .  Dies ist ein Benchmark f√ºr eine 0,3-KB-Datenstruktur, die wir zuerst per Zeiger und dann nach Wert senden und empfangen.  0,3 KB sind ein bisschen - ungef√§hr die √ºblichen Datenstrukturen, mit denen wir jeden Tag arbeiten, belegen ungef√§hr so ‚Äã‚Äãviel. <br><br>  Wenn ich diese Tests in einer lokalen Umgebung durchf√ºhre, ist die √úbertragung von Wert zu Wert mehr als viermal schneller.  Ziemlich unerwartet, oder? <br><br>  Die Erkl√§rung dieses Ergebnisses h√§ngt mit dem Verst√§ndnis der Speicherverwaltung in Go zusammen.  Ich kann es nicht so brillant erkl√§ren wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">William Kennedy</a> , aber lassen Sie uns versuchen, es auf den Punkt zu bringen. <br><br>  Eine Variable kann auf dem Heap oder Stack platziert werden: <br><ul><li>  Der Stack enth√§lt die aktuellen Variablen dieses Programms.  Sobald die Funktion zur√ºckkehrt, werden die Variablen vom Stapel entfernt. </li><li>  Der Heap enth√§lt allgemeine Variablen (globale Variablen usw.). </li></ul><br>  Schauen wir uns ein einfaches Beispiel an, in dem wir einen Wert zur√ºckgeben: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return result }</span></span></code> </pre> <br>  Hier wird die Ergebnisvariable von der aktuellen Goroutine erstellt.  Diese Variable wird auf den aktuellen Stapel verschoben.  Sobald die Funktion zur√ºckkehrt, erh√§lt der Client eine Kopie dieser Variablen.  Die Variable selbst wird vom Stapel genommen.  Es ist noch im Speicher vorhanden, bis eine andere Variable √ºberschrieben wird, auf die jedoch nicht mehr zugegriffen werden kann. <br>  Nun das gleiche Beispiel, aber mit einem Zeiger: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return &amp;result }</span></span></code> </pre> <br>  Die Ergebnisvariable wird weiterhin von der aktuellen Goroutine erstellt, der Client erh√§lt jedoch einen Zeiger (eine Kopie der Adresse der Variablen).  Wenn die Ergebnisvariable aus dem Stapel entfernt wurde, kann der Client dieser Funktion nicht darauf zugreifen. <br><br>  In diesem Szenario gibt der Go-Compiler die Ergebnisvariable dort aus, wo die Variablen gemeinsam genutzt werden k√∂nnen, d. H.  in einem Haufen. <br><br>  Ein weiteres Skript zum √úbergeben von Zeigern: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { p := &amp;foo{} f(p) }</code> </pre> <br>  Da wir f im selben Programm aufrufen, muss die Variable p nicht geh√§uft werden.  Es wird einfach auf den Stapel geschoben, und eine Unterfunktion kann darauf zugreifen. <br><br>  Auf diese Weise wird beispielsweise ein Slice in der Read-Methode von io.Reader erhalten.  Wenn Sie ein Slice (das ein Zeiger ist) zur√ºckgeben, wird es auf einen Heap gelegt. <br><br>  Warum ist der Stapel so schnell?  Es gibt zwei Gr√ºnde: <br><ul><li>  Der Garbage Collector muss nicht auf dem Stapel verwendet werden.  Wie bereits erw√§hnt, wird eine Variable nach dem Erstellen einfach verschoben und dann vom Stapel entfernt, wenn die Funktion zur√ºckkehrt.  Sie m√ºssen keinen komplizierten Prozess aufr√ºhren, um nicht verwendete Variablen usw. zur√ºckzugeben. </li><li>  Der Stack geh√∂rt zu einer Goroutine, sodass der Speicher der Variablen nicht synchronisiert werden muss, wie dies beim Speichern auf dem Heap der Fall ist, was ebenfalls zu einer Leistungssteigerung f√ºhrt. </li></ul><br>  Wenn wir eine Funktion erstellen, sollte unsere Standardaktion darin bestehen, Werte anstelle von Zeigern zu verwenden.  Ein Zeiger sollte nur verwendet werden, wenn wir eine Variable gemeinsam nutzen m√∂chten. <br><br>  Wenn wir unter Leistungsproblemen leiden, besteht eine der m√∂glichen Optimierungen darin, zu √ºberpr√ºfen, ob Zeiger in bestimmten Situationen hilfreich sind.  Ob der Compiler eine Variable an den Heap ausgibt, kann mit dem folgenden Befehl ermittelt werden: <pre> <code class="bash hljs">go build -gcflags <span class="hljs-string"><span class="hljs-string">"-m -m"</span></span></code> </pre>  . <br>  Aber auch hier ist es f√ºr die meisten unserer t√§glichen Aufgaben am besten, Werte zu verwenden. <br><br><h3>  Abbrechen f√ºr / switch oder for / select </h3><br>  Was passiert im folgenden Beispiel, wenn f true zur√ºckgibt? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> f() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Do something } }</span></span></code> </pre> <br>  Wir nennen Pause.  Nur diese Unterbrechung unterbricht den Schalter, nicht die for-Schleife. <br><br>  Gleiches Problem hier: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break } }</span></span></code> </pre> <br>  Break ist einer select-Anweisung zugeordnet, nicht einer for-Schleife. <br><br>  Eine m√∂gliche L√∂sung zum Unterbrechen von / switch oder for / select ist die Verwendung eines Etiketts: <br><br><pre> <code class="go hljs">loop: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break loop } }</span></span></code> </pre> <br><h3>  Fehlerbehandlung </h3><br>  Go ist noch jung, insbesondere im Bereich der Fehlerbehandlung.  Die √úberwindung dieses Mangels ist eine der am meisten erwarteten Innovationen in Go 2. <br><br>  Die aktuelle Standardbibliothek (vor Go 1.13) bietet nur Funktionen zum Erstellen von Fehlern.  Daher wird es interessant sein, sich das Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>pkg / Errors</i></a> anzusehen. <br><br>  Diese Bibliothek ist eine gute M√∂glichkeit, einer Regel zu folgen, die nicht immer eingehalten wird: <br><blockquote>  Der Fehler sollte nur einmal verarbeitet werden.  Die Fehlerprotokollierung ist eine Fehlerbehandlung </blockquote>  .  Daher sollte der Fehler protokolliert oder h√∂her geworfen werden. <br><br>  In der aktuellen Standardbibliothek ist dieses Prinzip schwer zu beobachten, da wir dem Fehler m√∂glicherweise einen Kontext hinzuf√ºgen und eine Art Hierarchie haben m√∂chten. <br><br>  Schauen wir uns ein Beispiel mit einem REST-Aufruf an, der zu einem Datenbankfehler f√ºhrt: <br><br><pre> <code class="bash hljs">unable to server HTTP POST request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction</code> </pre><br>  Wenn wir pkg / error verwenden, k√∂nnen wir Folgendes tun: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do something then fail return errors.New("unable to commit transaction") }</span></span></code> </pre> <br>  Der anf√§ngliche Fehler (wenn er nicht von der externen Bibliothek zur√ºckgegeben wird) kann mit error.New erstellt werden.  Die mittlere Ebene, Einf√ºgen, umschlie√üt diesen Fehler und f√ºgt ihm mehr Kontext hinzu.  Dann protokolliert der Elternteil es.  Somit gibt jede Ebene entweder einen Fehler zur√ºck oder verarbeitet ihn. <br><br>  M√∂glicherweise m√∂chten wir auch die Fehlerursache finden, z. B. zur√ºckrufen.  Angenommen, wir haben ein Datenbankpaket aus einer externen Bibliothek, die Zugriff auf eine Datenbank hat.  Diese Bibliothek gibt m√∂glicherweise einen tempor√§ren Fehler namens db.DBError zur√ºck.  Um festzustellen, ob wir es erneut versuchen m√ºssen, m√ºssen wir die Fehlerursache ermitteln: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err).(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := db.dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Dies geschieht mit Fehlern. Ursache, die auch in <i>pkg / error enthalten ist</i> : <br><br>  Einer der h√§ufigsten Fehler, auf die ich gesto√üen bin, war die Verwendung von <i>pkg / error</i> nur teilweise.  Eine Fehlerpr√ºfung wurde beispielsweise wie folgt durchgef√ºhrt: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) }</code> </pre> <br>  Wenn in diesem Beispiel db.DBError eingeschlossen ist, wird niemals ein zweiter Aufruf ausgef√ºhrt. <br><br><h3>  Slice-Initialisierung </h3><br>  Manchmal wissen wir, wie lang die Scheibe letztendlich sein wird.  Angenommen, wir m√∂chten ein Foo-Slice in ein Bar-Slice konvertieren, was bedeutet, dass diese beiden Slices dieselbe L√§nge haben. <br><br>  Ich sto√üe oft auf Slices, die folgenderma√üen initialisiert wurden: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bars []Bar bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Slice ist keine magische Struktur.  Unter der Haube implementiert er eine Strategie zur Vergr√∂√üerung, wenn kein freier Speicherplatz mehr vorhanden ist.  In diesem Fall wird automatisch ein neues Array erstellt (mit einer gr√∂√üeren Kapazit√§t), und alle Elemente werden darauf kopiert. <br><br>  Stellen wir uns nun vor, wir m√ºssen diesen Vorgang des Vergr√∂√üerns mehrmals wiederholen, da unser [] Foo Tausende von Elementen enth√§lt.  Die Komplexit√§t des Einf√ºgealgorithmus bleibt O (1), in der Praxis wirkt sich dies jedoch auf die Leistung aus. <br><br>  Wenn wir also die endg√ºltige L√§nge kennen, k√∂nnen wir entweder: <br><br><ul><li>  Initialisieren Sie es mit einer vordefinierten L√§nge: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars[i] = fooToBar(foo) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br><ul><li>  Oder initialisieren Sie es mit einer L√§nge von 0 und einer vorgegebenen Kapazit√§t: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bars, fooToBar(foo)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br>  Was ist die beste Option?  Der erste ist etwas schneller.  Sie k√∂nnen jedoch Letzteres bevorzugen, da es konsistenter ist: Unabh√§ngig davon, ob wir die Anfangsgr√∂√üe kennen, erfolgt das Hinzuf√ºgen eines Elements am Ende des Slice mithilfe von Anh√§ngen. <br><br><h3>  Kontextverwaltung </h3><br>  context.Context wird von Entwicklern oft missverstanden.  Laut offizieller Dokumentation: <br><blockquote>  Der Kontext enth√§lt die Frist, das Abbruch-Signal und andere Werte √ºber die Grenzen der API hinweg. <br>  Diese Beschreibung ist recht allgemein gehalten und kann den Programmierer verwirren, wie er sie richtig verwendet. </blockquote><br>  Versuchen wir es herauszufinden.  Kontext kann tragen: <br><ul><li>  Frist - bezeichnet entweder die Dauer (z. B. 250 ms) oder die Datums- und Uhrzeit (z. B. 2019-01-08 01:00:00), nach der wir der Ansicht sind, dass die aktuelle Aktion abgebrochen werden muss, wenn sie erreicht ist (E / A-Anforderung) ), Warten auf Kanaleingang usw.). </li><li>  Signal abbrechen (im Grunde &lt;-chan struct {}).  Hier ist das Verhalten √§hnlich.  Sobald wir ein Signal erhalten, m√ºssen wir die aktuelle Arbeit einstellen.  Nehmen wir zum Beispiel an, wir erhalten zwei Anfragen.  Eine zum Einf√ºgen von Daten und die andere zum Abbrechen der ersten Anforderung (weil sie beispielsweise nicht mehr relevant ist).  Dies kann mithilfe des abgebrochenen Kontexts im ersten Anruf erreicht werden, der dann abgebrochen wird, sobald wir die zweite Anfrage erhalten. </li><li>  Schl√ºssel- / Werteliste (beide basierend auf dem Typ der Schnittstelle {}). </li></ul><br>  Noch zwei Punkte.  Erstens ist der Kontext zusammensetzbar.  Daher haben wir m√∂glicherweise einen Kontext, der beispielsweise die Frist und die Schl√ºssel- / Werteliste enth√§lt.  Dar√ºber hinaus k√∂nnen mehrere Goroutinen denselben Kontext verwenden, sodass ein Abbruchsignal m√∂glicherweise mehrere Jobs stoppen kann. <br><br>  Zur√ºck zu unserem Thema, hier ist ein Fehler, den ich getroffen habe. <br><br>  Die Go-Anwendung basierte auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>urfave / cli</i></a> (wenn Sie nicht wissen, ist dies eine gute Bibliothek zum Erstellen von Befehlszeilenanwendungen in Go).  Nach dem Start erbt der Entwickler eine Art Anwendungskontext.  Dies bedeutet, dass die Bibliothek beim Stoppen der Anwendung den Kontext verwendet, um ein Abbruchsignal zu senden. <br><br>  Ich habe festgestellt, dass dieser Kontext direkt √ºbertragen wurde, beispielsweise wenn ein gRPC-Endpunkt aufgerufen wurde.  Das brauchen wir √ºberhaupt nicht. <br><br>  Stattdessen m√∂chten wir der gRPC-Bibliothek mitteilen: Bitte brechen Sie die Anforderung ab, wenn die Anwendung gestoppt wird oder beispielsweise nach 100 ms. <br><br>  Um dies zu erreichen, k√∂nnen wir einfach einen zusammengesetzten Kontext erstellen.  Wenn parent der Name des Anwendungskontexts ist (erstellt von <i>urfave / cli</i> ), k√∂nnen wir dies einfach tun: <br><br><pre> <code class="go hljs">ctx, cancel := context.WithTimeout(parent, <span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) response, err := grpcClient.Send(ctx, request)</code> </pre> <br>  Kontexte sind nicht so schwer zu verstehen, und meiner Meinung nach ist dies eines der besten Merkmale der Sprache. <br><br><h3>  Die Option -race wird nicht verwendet </h3><br>  Das Testen einer Go-Anwendung ohne die Option -race ist ein Fehler, auf den ich st√§ndig sto√üe. <br><br>  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel beschrieben</a> , leiden wir immer noch stark unter Parallelit√§tsproblemen, obwohl Go ‚Äû <i>entwickelt wurde, um die parallele Programmierung einfacher und weniger fehleranf√§llig zu machen</i> ‚Äú. <br><br>  Offensichtlich hilft der Renndetektor Go bei keinem Problem.  Es ist jedoch ein wertvolles Werkzeug, und wir sollten es beim Testen unserer Anwendungen immer einbeziehen. <br><br><h3>  Dateinamen als Eingabe verwenden </h3><br>  Ein weiterer h√§ufiger Fehler besteht darin, den Dateinamen an eine Funktion zu √ºbergeben. <br><br>  Angenommen, wir m√ºssen eine Funktion implementieren, um die Anzahl der leeren Zeilen in einer Datei zu z√§hlen.  Die nat√ºrlichste Implementierung w√ºrde ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() scanner := bufio.NewScanner(file) count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scanner.Text() == <span class="hljs-string"><span class="hljs-string">""</span></span> { count++ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Der Dateiname wird als Eingabe festgelegt, also √∂ffnen wir ihn und implementieren dann unsere Logik, oder? <br><br>  Nehmen wir nun an, wir m√∂chten diese Funktion mit Unit-Tests abdecken.  Wir werden mit einer regul√§ren Datei, einer leeren Datei, einer Datei mit einer anderen Art der Codierung usw. testen. Es kann sehr schwierig sein, sie zu verwalten. <br><br>  Wenn wir dieselbe Logik beispielsweise f√ºr den HTTP-Body implementieren m√∂chten, m√ºssen wir hierf√ºr eine weitere Funktion erstellen. <br><br>  Go kommt mit zwei gro√üartigen Abstraktionen: io.Reader und io.Writer.  Anstatt den Dateinamen zu √ºbergeben, k√∂nnen wir einfach io.Reader √ºbergeben, wodurch die Datenquelle abstrahiert wird. <br>  Ist das eine Datei?  HTTP-Body?  Byte-Puffer?  Es spielt keine Rolle, da wir immer noch dieselbe Lesemethode verwenden. <br><br>  In unserem Fall k√∂nnen wir Eingaben sogar puffern, um sie Zeile f√ºr Zeile zu lesen.  Dazu k√∂nnen Sie bufio.Reader und seine ReadLine-Methode verwenden: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader *bufio.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { line, _, err := reader.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to read"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EOF: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) == <span class="hljs-number"><span class="hljs-number">0</span></span> { count++ } } }</code> </pre> <br>  Jetzt wurde die Verantwortung f√ºr das √ñffnen der Datei an den Z√§hlclient delegiert: <br><br><pre> <code class="go hljs">file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() count, err := count(bufio.NewReader(file))</code> </pre> <br>  In einer zweiten Implementierung kann eine Funktion unabh√§ngig von der tats√§chlichen Datenquelle aufgerufen werden.  In der Zwischenzeit wird dies unsere Unit-Tests erleichtern, da wir einfach bufio.Reader aus der Zeile erstellen k√∂nnen: <br><br><pre> <code class="go hljs">count, err := count(bufio.NewReader(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"input"</span></span>)))</code> </pre> <br><h3>  Goroutinen und Zyklusvariablen </h3><br>  Der letzte h√§ufige Fehler, den ich traf, war die Verwendung von Goroutinen mit Schleifenvariablen. <br><br>  Was wird die Schlussfolgerung des folgenden Beispiels sein? <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  1 2 3 zuf√§llig?  Nein. <br><br>  In diesem Beispiel verwendet jede Goroutine dieselbe Instanz einer Variablen, sodass (h√∂chstwahrscheinlich) 3 3 3 ausgegeben wird. <br><br>  F√ºr dieses Problem gibt es zwei L√∂sungen.  Die erste besteht darin, den Wert der Variablen i an den Abschluss zu √ºbergeben (interne Funktion): <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }(i) }</code> </pre> <br>  Die zweite besteht darin, eine weitere Variable innerhalb der for-Schleife zu erstellen: <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { i := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  Das Zuweisen von i: = i mag etwas seltsam erscheinen, aber dieses Design ist vollkommen g√ºltig.  In einer Schleife zu sein bedeutet, in einem anderen Bereich zu sein.  Daher erstellt i: = i eine weitere Instanz der Variablen i.  Nat√ºrlich k√∂nnen wir es aus Gr√ºnden der Lesbarkeit mit einem anderen Namen bezeichnen. <br><br>  <i>Wenn Sie andere h√§ufige Fehler kennen, k√∂nnen Sie diese gerne in den Kommentaren beschreiben.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461051/">https://habr.com/ru/post/de461051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461041/index.html">Abgerundet oder spitzwinklig?</a></li>
<li><a href="../de461043/index.html">Konfliktmanagement im Team - Balanceakt oder lebenswichtige Notwendigkeit?</a></li>
<li><a href="../de461045/index.html">Holen Sie sich einen Auszug aus Rosreestr √ºber FSIS USRN und Python. Teil 1</a></li>
<li><a href="../de461047/index.html">Schreiben oder nicht schreiben. Briefe an Beh√∂rden bei Veranstaltungen</a></li>
<li><a href="../de461049/index.html">ONYX BOOX Faust - Wer sucht, ist nicht gezwungen zu wandern</a></li>
<li><a href="../de461053/index.html">Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 2 - Vektorkarten</a></li>
<li><a href="../de461055/index.html">Rekko Challenge 2019: wie es war</a></li>
<li><a href="../de461057/index.html">Telegrammkan√§le zur Spieleentwicklung</a></li>
<li><a href="../de461059/index.html">Schreiben einer Android-App f√ºr Filmfans - Teil 1 (Prototyping)</a></li>
<li><a href="../de461061/index.html">Magnesiumlegierungen, Zwillingsgrenzen und Entmischung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>