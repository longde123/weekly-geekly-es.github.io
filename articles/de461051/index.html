<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚅 ♂️ ✉️ Top 10 der häufigsten Fehler, auf die ich in Go-Projekten gestoßen bin 🚳 🔴 🔑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Beitrag ist einer der häufigsten Fehler, die ich in Go-Projekten festgestellt habe. Ordnung spielt keine Rolle. 



 Unbekannter Wert von Enum ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 der häufigsten Fehler, auf die ich in Go-Projekten gestoßen bin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461051/">  <b><i>Dieser Beitrag ist einer der häufigsten Fehler, die ich in Go-Projekten festgestellt habe.</i></b>  Ordnung spielt keine Rolle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b01/9ed/114/b019ed114553265d5cd0c773c2d2e2c6.jpg" alt="Bild"><br><br><h3>  Unbekannter Wert von Enum </h3><br>  Schauen wir uns ein einfaches Beispiel an: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusOpen Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusClosed StatusUnknown )</code> </pre> <br>  Hier erstellen wir mit iota einen Enumerator, der zu diesem Status führt: <br><br><pre> <code class="go hljs">StatusOpen = <span class="hljs-number"><span class="hljs-number">0</span></span> StatusClosed = <span class="hljs-number"><span class="hljs-number">1</span></span> StatusUnknown = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <a name="habracut"></a><br>  Stellen wir uns nun vor, dass diese Art von Status Teil der JSON-Anforderung ist, die gepackt / entpackt wird.  Wir können die folgende Struktur entwerfen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Id"`</span></span> Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Timestamp"`</span></span> Status Status <span class="hljs-string"><span class="hljs-string">`json:"Status"`</span></span> }</code> </pre> <br>  Dann erhalten wir dieses Abfrageergebnis: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Status"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Im Allgemeinen nichts Besonderes - Status wird in StatusOpen entpackt. <br>  Lassen Sie uns nun eine weitere Antwort erhalten, bei der der Statuswert nicht festgelegt ist: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span> }</code> </pre> <br>  In diesem Fall wird das Statusfeld der Anforderungsstruktur auf Null initialisiert (für uint32 ist es 0).  Daher erhalten wir wieder StatusOpen anstelle von StatusUnknown. <br><br>  In diesem Fall ist es am besten, zuerst den unbekannten Wert des Enumerators einzustellen - d. H.  0: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusUnknown Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusOpen StatusClosed )</code> </pre><br>  Wenn der Status nicht Teil der JSON-Anforderung ist, wird er erwartungsgemäß in StatusUnknown initialisiert. <br><br><h3>  Benchmarking </h3><br>  Richtiges Benchmarking ist ziemlich schwierig.  Zu viele Faktoren können das Ergebnis beeinflussen. <br><br>  Ein häufiger Fehler wird durch Compiler-Optimierungen ausgetrickst.  Sehen wir uns ein konkretes Beispiel aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">teivah / bitvector-Bibliothek an</a> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.MaxUint64&lt;&lt;j | ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; n }</code> </pre> <br>  Diese Funktion löscht Bits in einem bestimmten Bereich.  Wir können die Leistung folgendermaßen testen: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkWrong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } }</code> </pre> <br>  In diesem Test wird der Compiler feststellen, dass clear keine andere Funktion aufruft und sie einfach so einbettet, wie sie ist.  Sobald es eingebaut ist, sieht der Compiler, dass keine Nebenwirkungen auftreten.  Somit wird der eindeutige Anruf einfach gelöscht, was zu ungenauen Ergebnissen führt. <br><br>  Eine Lösung kann darin bestehen, das Ergebnis auf eine globale Variable wie diese festzulegen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkCorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } result = r }</code> </pre> <br>  Hier weiß der Compiler nicht, ob der Aufruf einen Nebeneffekt erzeugt.  Daher ist der Benchmark genau. <br><br><h3>  Zeiger!  Zeiger sind überall! </h3><br>  Wenn Sie eine Variable als Wert übergeben, wird eine Kopie dieser Variablen erstellt.  Kopieren Sie beim Übergeben des Zeigers einfach die Adresse in den Speicher. <br><br>  Folglich ist das Übergeben eines Zeigers immer schneller, oder? <br><br>  Wenn Sie so denken, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Beispiel an</a> .  Dies ist ein Benchmark für eine 0,3-KB-Datenstruktur, die wir zuerst per Zeiger und dann nach Wert senden und empfangen.  0,3 KB sind ein bisschen - ungefähr die üblichen Datenstrukturen, mit denen wir jeden Tag arbeiten, belegen ungefähr so ​​viel. <br><br>  Wenn ich diese Tests in einer lokalen Umgebung durchführe, ist die Übertragung von Wert zu Wert mehr als viermal schneller.  Ziemlich unerwartet, oder? <br><br>  Die Erklärung dieses Ergebnisses hängt mit dem Verständnis der Speicherverwaltung in Go zusammen.  Ich kann es nicht so brillant erklären wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">William Kennedy</a> , aber lassen Sie uns versuchen, es auf den Punkt zu bringen. <br><br>  Eine Variable kann auf dem Heap oder Stack platziert werden: <br><ul><li>  Der Stack enthält die aktuellen Variablen dieses Programms.  Sobald die Funktion zurückkehrt, werden die Variablen vom Stapel entfernt. </li><li>  Der Heap enthält allgemeine Variablen (globale Variablen usw.). </li></ul><br>  Schauen wir uns ein einfaches Beispiel an, in dem wir einen Wert zurückgeben: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return result }</span></span></code> </pre> <br>  Hier wird die Ergebnisvariable von der aktuellen Goroutine erstellt.  Diese Variable wird auf den aktuellen Stapel verschoben.  Sobald die Funktion zurückkehrt, erhält der Client eine Kopie dieser Variablen.  Die Variable selbst wird vom Stapel genommen.  Es ist noch im Speicher vorhanden, bis eine andere Variable überschrieben wird, auf die jedoch nicht mehr zugegriffen werden kann. <br>  Nun das gleiche Beispiel, aber mit einem Zeiger: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return &amp;result }</span></span></code> </pre> <br>  Die Ergebnisvariable wird weiterhin von der aktuellen Goroutine erstellt, der Client erhält jedoch einen Zeiger (eine Kopie der Adresse der Variablen).  Wenn die Ergebnisvariable aus dem Stapel entfernt wurde, kann der Client dieser Funktion nicht darauf zugreifen. <br><br>  In diesem Szenario gibt der Go-Compiler die Ergebnisvariable dort aus, wo die Variablen gemeinsam genutzt werden können, d. H.  in einem Haufen. <br><br>  Ein weiteres Skript zum Übergeben von Zeigern: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { p := &amp;foo{} f(p) }</code> </pre> <br>  Da wir f im selben Programm aufrufen, muss die Variable p nicht gehäuft werden.  Es wird einfach auf den Stapel geschoben, und eine Unterfunktion kann darauf zugreifen. <br><br>  Auf diese Weise wird beispielsweise ein Slice in der Read-Methode von io.Reader erhalten.  Wenn Sie ein Slice (das ein Zeiger ist) zurückgeben, wird es auf einen Heap gelegt. <br><br>  Warum ist der Stapel so schnell?  Es gibt zwei Gründe: <br><ul><li>  Der Garbage Collector muss nicht auf dem Stapel verwendet werden.  Wie bereits erwähnt, wird eine Variable nach dem Erstellen einfach verschoben und dann vom Stapel entfernt, wenn die Funktion zurückkehrt.  Sie müssen keinen komplizierten Prozess aufrühren, um nicht verwendete Variablen usw. zurückzugeben. </li><li>  Der Stack gehört zu einer Goroutine, sodass der Speicher der Variablen nicht synchronisiert werden muss, wie dies beim Speichern auf dem Heap der Fall ist, was ebenfalls zu einer Leistungssteigerung führt. </li></ul><br>  Wenn wir eine Funktion erstellen, sollte unsere Standardaktion darin bestehen, Werte anstelle von Zeigern zu verwenden.  Ein Zeiger sollte nur verwendet werden, wenn wir eine Variable gemeinsam nutzen möchten. <br><br>  Wenn wir unter Leistungsproblemen leiden, besteht eine der möglichen Optimierungen darin, zu überprüfen, ob Zeiger in bestimmten Situationen hilfreich sind.  Ob der Compiler eine Variable an den Heap ausgibt, kann mit dem folgenden Befehl ermittelt werden: <pre> <code class="bash hljs">go build -gcflags <span class="hljs-string"><span class="hljs-string">"-m -m"</span></span></code> </pre>  . <br>  Aber auch hier ist es für die meisten unserer täglichen Aufgaben am besten, Werte zu verwenden. <br><br><h3>  Abbrechen für / switch oder for / select </h3><br>  Was passiert im folgenden Beispiel, wenn f true zurückgibt? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> f() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Do something } }</span></span></code> </pre> <br>  Wir nennen Pause.  Nur diese Unterbrechung unterbricht den Schalter, nicht die for-Schleife. <br><br>  Gleiches Problem hier: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break } }</span></span></code> </pre> <br>  Break ist einer select-Anweisung zugeordnet, nicht einer for-Schleife. <br><br>  Eine mögliche Lösung zum Unterbrechen von / switch oder for / select ist die Verwendung eines Etiketts: <br><br><pre> <code class="go hljs">loop: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break loop } }</span></span></code> </pre> <br><h3>  Fehlerbehandlung </h3><br>  Go ist noch jung, insbesondere im Bereich der Fehlerbehandlung.  Die Überwindung dieses Mangels ist eine der am meisten erwarteten Innovationen in Go 2. <br><br>  Die aktuelle Standardbibliothek (vor Go 1.13) bietet nur Funktionen zum Erstellen von Fehlern.  Daher wird es interessant sein, sich das Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>pkg / Errors</i></a> anzusehen. <br><br>  Diese Bibliothek ist eine gute Möglichkeit, einer Regel zu folgen, die nicht immer eingehalten wird: <br><blockquote>  Der Fehler sollte nur einmal verarbeitet werden.  Die Fehlerprotokollierung ist eine Fehlerbehandlung </blockquote>  .  Daher sollte der Fehler protokolliert oder höher geworfen werden. <br><br>  In der aktuellen Standardbibliothek ist dieses Prinzip schwer zu beobachten, da wir dem Fehler möglicherweise einen Kontext hinzufügen und eine Art Hierarchie haben möchten. <br><br>  Schauen wir uns ein Beispiel mit einem REST-Aufruf an, der zu einem Datenbankfehler führt: <br><br><pre> <code class="bash hljs">unable to server HTTP POST request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction</code> </pre><br>  Wenn wir pkg / error verwenden, können wir Folgendes tun: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do something then fail return errors.New("unable to commit transaction") }</span></span></code> </pre> <br>  Der anfängliche Fehler (wenn er nicht von der externen Bibliothek zurückgegeben wird) kann mit error.New erstellt werden.  Die mittlere Ebene, Einfügen, umschließt diesen Fehler und fügt ihm mehr Kontext hinzu.  Dann protokolliert der Elternteil es.  Somit gibt jede Ebene entweder einen Fehler zurück oder verarbeitet ihn. <br><br>  Möglicherweise möchten wir auch die Fehlerursache finden, z. B. zurückrufen.  Angenommen, wir haben ein Datenbankpaket aus einer externen Bibliothek, die Zugriff auf eine Datenbank hat.  Diese Bibliothek gibt möglicherweise einen temporären Fehler namens db.DBError zurück.  Um festzustellen, ob wir es erneut versuchen müssen, müssen wir die Fehlerursache ermitteln: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err).(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := db.dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Dies geschieht mit Fehlern. Ursache, die auch in <i>pkg / error enthalten ist</i> : <br><br>  Einer der häufigsten Fehler, auf die ich gestoßen bin, war die Verwendung von <i>pkg / error</i> nur teilweise.  Eine Fehlerprüfung wurde beispielsweise wie folgt durchgeführt: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) }</code> </pre> <br>  Wenn in diesem Beispiel db.DBError eingeschlossen ist, wird niemals ein zweiter Aufruf ausgeführt. <br><br><h3>  Slice-Initialisierung </h3><br>  Manchmal wissen wir, wie lang die Scheibe letztendlich sein wird.  Angenommen, wir möchten ein Foo-Slice in ein Bar-Slice konvertieren, was bedeutet, dass diese beiden Slices dieselbe Länge haben. <br><br>  Ich stoße oft auf Slices, die folgendermaßen initialisiert wurden: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bars []Bar bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Slice ist keine magische Struktur.  Unter der Haube implementiert er eine Strategie zur Vergrößerung, wenn kein freier Speicherplatz mehr vorhanden ist.  In diesem Fall wird automatisch ein neues Array erstellt (mit einer größeren Kapazität), und alle Elemente werden darauf kopiert. <br><br>  Stellen wir uns nun vor, wir müssen diesen Vorgang des Vergrößerns mehrmals wiederholen, da unser [] Foo Tausende von Elementen enthält.  Die Komplexität des Einfügealgorithmus bleibt O (1), in der Praxis wirkt sich dies jedoch auf die Leistung aus. <br><br>  Wenn wir also die endgültige Länge kennen, können wir entweder: <br><br><ul><li>  Initialisieren Sie es mit einer vordefinierten Länge: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars[i] = fooToBar(foo) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br><ul><li>  Oder initialisieren Sie es mit einer Länge von 0 und einer vorgegebenen Kapazität: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bars, fooToBar(foo)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br>  Was ist die beste Option?  Der erste ist etwas schneller.  Sie können jedoch Letzteres bevorzugen, da es konsistenter ist: Unabhängig davon, ob wir die Anfangsgröße kennen, erfolgt das Hinzufügen eines Elements am Ende des Slice mithilfe von Anhängen. <br><br><h3>  Kontextverwaltung </h3><br>  context.Context wird von Entwicklern oft missverstanden.  Laut offizieller Dokumentation: <br><blockquote>  Der Kontext enthält die Frist, das Abbruch-Signal und andere Werte über die Grenzen der API hinweg. <br>  Diese Beschreibung ist recht allgemein gehalten und kann den Programmierer verwirren, wie er sie richtig verwendet. </blockquote><br>  Versuchen wir es herauszufinden.  Kontext kann tragen: <br><ul><li>  Frist - bezeichnet entweder die Dauer (z. B. 250 ms) oder die Datums- und Uhrzeit (z. B. 2019-01-08 01:00:00), nach der wir der Ansicht sind, dass die aktuelle Aktion abgebrochen werden muss, wenn sie erreicht ist (E / A-Anforderung) ), Warten auf Kanaleingang usw.). </li><li>  Signal abbrechen (im Grunde &lt;-chan struct {}).  Hier ist das Verhalten ähnlich.  Sobald wir ein Signal erhalten, müssen wir die aktuelle Arbeit einstellen.  Nehmen wir zum Beispiel an, wir erhalten zwei Anfragen.  Eine zum Einfügen von Daten und die andere zum Abbrechen der ersten Anforderung (weil sie beispielsweise nicht mehr relevant ist).  Dies kann mithilfe des abgebrochenen Kontexts im ersten Anruf erreicht werden, der dann abgebrochen wird, sobald wir die zweite Anfrage erhalten. </li><li>  Schlüssel- / Werteliste (beide basierend auf dem Typ der Schnittstelle {}). </li></ul><br>  Noch zwei Punkte.  Erstens ist der Kontext zusammensetzbar.  Daher haben wir möglicherweise einen Kontext, der beispielsweise die Frist und die Schlüssel- / Werteliste enthält.  Darüber hinaus können mehrere Goroutinen denselben Kontext verwenden, sodass ein Abbruchsignal möglicherweise mehrere Jobs stoppen kann. <br><br>  Zurück zu unserem Thema, hier ist ein Fehler, den ich getroffen habe. <br><br>  Die Go-Anwendung basierte auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>urfave / cli</i></a> (wenn Sie nicht wissen, ist dies eine gute Bibliothek zum Erstellen von Befehlszeilenanwendungen in Go).  Nach dem Start erbt der Entwickler eine Art Anwendungskontext.  Dies bedeutet, dass die Bibliothek beim Stoppen der Anwendung den Kontext verwendet, um ein Abbruchsignal zu senden. <br><br>  Ich habe festgestellt, dass dieser Kontext direkt übertragen wurde, beispielsweise wenn ein gRPC-Endpunkt aufgerufen wurde.  Das brauchen wir überhaupt nicht. <br><br>  Stattdessen möchten wir der gRPC-Bibliothek mitteilen: Bitte brechen Sie die Anforderung ab, wenn die Anwendung gestoppt wird oder beispielsweise nach 100 ms. <br><br>  Um dies zu erreichen, können wir einfach einen zusammengesetzten Kontext erstellen.  Wenn parent der Name des Anwendungskontexts ist (erstellt von <i>urfave / cli</i> ), können wir dies einfach tun: <br><br><pre> <code class="go hljs">ctx, cancel := context.WithTimeout(parent, <span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) response, err := grpcClient.Send(ctx, request)</code> </pre> <br>  Kontexte sind nicht so schwer zu verstehen, und meiner Meinung nach ist dies eines der besten Merkmale der Sprache. <br><br><h3>  Die Option -race wird nicht verwendet </h3><br>  Das Testen einer Go-Anwendung ohne die Option -race ist ein Fehler, auf den ich ständig stoße. <br><br>  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel beschrieben</a> , leiden wir immer noch stark unter Parallelitätsproblemen, obwohl Go „ <i>entwickelt wurde, um die parallele Programmierung einfacher und weniger fehleranfällig zu machen</i> “. <br><br>  Offensichtlich hilft der Renndetektor Go bei keinem Problem.  Es ist jedoch ein wertvolles Werkzeug, und wir sollten es beim Testen unserer Anwendungen immer einbeziehen. <br><br><h3>  Dateinamen als Eingabe verwenden </h3><br>  Ein weiterer häufiger Fehler besteht darin, den Dateinamen an eine Funktion zu übergeben. <br><br>  Angenommen, wir müssen eine Funktion implementieren, um die Anzahl der leeren Zeilen in einer Datei zu zählen.  Die natürlichste Implementierung würde ungefähr so ​​aussehen: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() scanner := bufio.NewScanner(file) count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scanner.Text() == <span class="hljs-string"><span class="hljs-string">""</span></span> { count++ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Der Dateiname wird als Eingabe festgelegt, also öffnen wir ihn und implementieren dann unsere Logik, oder? <br><br>  Nehmen wir nun an, wir möchten diese Funktion mit Unit-Tests abdecken.  Wir werden mit einer regulären Datei, einer leeren Datei, einer Datei mit einer anderen Art der Codierung usw. testen. Es kann sehr schwierig sein, sie zu verwalten. <br><br>  Wenn wir dieselbe Logik beispielsweise für den HTTP-Body implementieren möchten, müssen wir hierfür eine weitere Funktion erstellen. <br><br>  Go kommt mit zwei großartigen Abstraktionen: io.Reader und io.Writer.  Anstatt den Dateinamen zu übergeben, können wir einfach io.Reader übergeben, wodurch die Datenquelle abstrahiert wird. <br>  Ist das eine Datei?  HTTP-Body?  Byte-Puffer?  Es spielt keine Rolle, da wir immer noch dieselbe Lesemethode verwenden. <br><br>  In unserem Fall können wir Eingaben sogar puffern, um sie Zeile für Zeile zu lesen.  Dazu können Sie bufio.Reader und seine ReadLine-Methode verwenden: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader *bufio.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { line, _, err := reader.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to read"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EOF: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) == <span class="hljs-number"><span class="hljs-number">0</span></span> { count++ } } }</code> </pre> <br>  Jetzt wurde die Verantwortung für das Öffnen der Datei an den Zählclient delegiert: <br><br><pre> <code class="go hljs">file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() count, err := count(bufio.NewReader(file))</code> </pre> <br>  In einer zweiten Implementierung kann eine Funktion unabhängig von der tatsächlichen Datenquelle aufgerufen werden.  In der Zwischenzeit wird dies unsere Unit-Tests erleichtern, da wir einfach bufio.Reader aus der Zeile erstellen können: <br><br><pre> <code class="go hljs">count, err := count(bufio.NewReader(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"input"</span></span>)))</code> </pre> <br><h3>  Goroutinen und Zyklusvariablen </h3><br>  Der letzte häufige Fehler, den ich traf, war die Verwendung von Goroutinen mit Schleifenvariablen. <br><br>  Was wird die Schlussfolgerung des folgenden Beispiels sein? <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  1 2 3 zufällig?  Nein. <br><br>  In diesem Beispiel verwendet jede Goroutine dieselbe Instanz einer Variablen, sodass (höchstwahrscheinlich) 3 3 3 ausgegeben wird. <br><br>  Für dieses Problem gibt es zwei Lösungen.  Die erste besteht darin, den Wert der Variablen i an den Abschluss zu übergeben (interne Funktion): <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }(i) }</code> </pre> <br>  Die zweite besteht darin, eine weitere Variable innerhalb der for-Schleife zu erstellen: <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { i := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  Das Zuweisen von i: = i mag etwas seltsam erscheinen, aber dieses Design ist vollkommen gültig.  In einer Schleife zu sein bedeutet, in einem anderen Bereich zu sein.  Daher erstellt i: = i eine weitere Instanz der Variablen i.  Natürlich können wir es aus Gründen der Lesbarkeit mit einem anderen Namen bezeichnen. <br><br>  <i>Wenn Sie andere häufige Fehler kennen, können Sie diese gerne in den Kommentaren beschreiben.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461051/">https://habr.com/ru/post/de461051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461041/index.html">Abgerundet oder spitzwinklig?</a></li>
<li><a href="../de461043/index.html">Konfliktmanagement im Team - Balanceakt oder lebenswichtige Notwendigkeit?</a></li>
<li><a href="../de461045/index.html">Holen Sie sich einen Auszug aus Rosreestr über FSIS USRN und Python. Teil 1</a></li>
<li><a href="../de461047/index.html">Schreiben oder nicht schreiben. Briefe an Behörden bei Veranstaltungen</a></li>
<li><a href="../de461049/index.html">ONYX BOOX Faust - Wer sucht, ist nicht gezwungen zu wandern</a></li>
<li><a href="../de461053/index.html">Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 2 - Vektorkarten</a></li>
<li><a href="../de461055/index.html">Rekko Challenge 2019: wie es war</a></li>
<li><a href="../de461057/index.html">Telegrammkanäle zur Spieleentwicklung</a></li>
<li><a href="../de461059/index.html">Schreiben einer Android-App für Filmfans - Teil 1 (Prototyping)</a></li>
<li><a href="../de461061/index.html">Magnesiumlegierungen, Zwillingsgrenzen und Entmischung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>