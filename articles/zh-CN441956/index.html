<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📼 👔 👼🏾 统一的错误处理（微控制器的C ++选项） 📺 🧗🏾 🏗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在为使用C ++的微控制器开发软件时，经常可能会遇到这样的事实，即使用标准库会导致不希望的RAM和ROM资源额外成本。 因此， std库中的类和方法通常不太适合在微控制器中实现。 使用动态分配的内存，RTTI，异常等也有一些限制。 通常，为了编写紧凑而快速的代码，您不能只使用std库并开始使用typ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>统一的错误处理（微控制器的C ++选项）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441956/">在为使用C ++的微控制器开发软件时，经常可能会遇到这样的事实，即使用标准库会导致不希望的RAM和ROM资源额外成本。 因此， <code>std</code>库中的类和方法通常不太适合在微控制器中实现。 使用动态分配的内存，RTTI，异常等也有一些限制。 通常，为了编写紧凑而快速的代码，您不能只使用<code>std</code>库并开始使用<code>typeid</code>运算符，因为您需要RTTI支持，尽管这虽然不是很大，但却是一项开销。 <br><br> 因此，有时您必须重新发明轮子才能满足所有这些条件。 这样的任务很少，但是确实如此。 在本文中，我想谈谈一个看似简单的任务-扩展微控制器软件中现有子系统的返回码。 <br><a name="habracut"></a><br><h2> 挑战赛 </h2><br> 假设您有一个CPU诊断子系统，并且它具有可枚举的返回码，请说明以下内容： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom, Ram } ;</code> </pre><br> 如果CPU诊断子系统检测到其中一个CPU模块（例如ALU或RAM）发生故障，则它必须返回相应的代码。 <br><br> 对于另一个子系统，同样，将其作为测量诊断，检查测量值是否在范围内并且通常有效（不等于NAN或Infinity）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Measure_Error</span></span></span><span class="hljs-class"> {</span></span> OutOfLimits, Ok, BadCode } ;</code> </pre> <br> 对于每个子系统，都有一个<code>GetLastError()</code>方法，该方法返回该子系统的枚举错误类型。 对于<code>CpuDiagnostic</code>将返回<code>MeasureDiagnostic</code>类型<code>CpuDiagnostic</code>代码，对于<code>CpuDiagnostic</code>将返回<code>MeasureDiagnostic</code>类型<code>MeasureDiagnostic</code>代码。 <br><br> 并且有一个特定的日志，当发生错误时，应该记录错误代码。 <br> 为了理解，我将以一种非常简化的形式编写该代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Logger::Update() { Log(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(cpuDiagnostic.GetLastError()) ; Log(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(measureDiagstic.GetLastError()) ; }</code> </pre><br> 显然，将枚举类型转换为整数时，对于不同类型，我们可以获得相同的值。 如何区分第一个错误代码是Cpu诊断子系统和第二个测量子系统的错误代码？ <br><br><h3> 寻找解决方案 </h3><br>  <code>GetLastError()</code>方法为不同的子系统返回不同的代码是合乎逻辑的。 前额中最直接的决定之一是为每种枚举类型使用不同范围的代码。 像这样 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 CPU_ERROR_ALU = <span class="hljs-number"><span class="hljs-number">0x10000001</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 CPU_ERROR_ROM = <span class="hljs-number"><span class="hljs-number">0x10000002</span></span> ; ... <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 MEAS_ERROR_OUTOF = <span class="hljs-number"><span class="hljs-number">0x01000001</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 MEAS_ERROR_BAD = <span class="hljs-number"><span class="hljs-number">0x01000002</span></span> ; ... <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu = CPU_ERROR_ALU, Rom = CPU_ERROR_ROM, Ram = CPU_ERROR_RAM } ; ...</code> </pre><br> 我认为这种方法的缺点很明显。 首先，大量的手动工作需要您手动确定范围和返回码，这肯定会导致人为错误。 其次，可以有许多子系统，并且根本不为每个子系统添加枚举。 <br><br> 实际上，如果根本不涉及转移，以稍微不同的方式扩展其代码，例如能够做到这一点，那就太好了： <br><br><pre> <code class="cpp hljs">ResultCode result = Cpu_Error::Ok ; <span class="hljs-comment"><span class="hljs-comment">//GetLastError()   Cpu_Error result = cpuDiagnostic.GetLastError() ; if(result) //    { //       Logger::Log(result) ; } //GetLastError()   Measure_Error result = measureDiagnostic.GetLastError() ; if(result) //    { //       Logger::Log(result) ; }</span></span></code> </pre><br> 大概： <br><br><pre> <code class="cpp hljs">ReturnCode result ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it: diagnostics) { <span class="hljs-comment"><span class="hljs-comment">//GetLastError()     result = it.GetLastError() ; if (result) //    { Logger::Log(result) ; //      } }</span></span></code> </pre><br> 大概： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CpuDiagnostic::SomeFunction(ReturnCode errocode) { Cpu_Error status = errorcode ; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CpuError::Alu: <span class="hljs-comment"><span class="hljs-comment">// do something ; break; .... } }</span></span></code> </pre><br> 从代码中可以看到，此处使用了一些<code>ReturnCode</code>类，该类应包含错误代码及其类别。 在标准库中，有一个这样的类<code>std::error_code</code> ，实际上几乎完成了所有这一切。 这里很好地描述了它的目的： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">你自己的std :: code_error</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持C ++中的系统错误</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“未来的C ++”中的确定性异常和错误处理</a> <br><br> 主要的抱怨是要使用该类，我们需要继承<code>std::error_category</code> ，显然，在小型微控制器上的固件中使用该重载时会严重过载。 即使至少使用std :: string。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CpuErrorCategory</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_category { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ev)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre><br> 此外，您还必须手动描述其每种枚举类型的类别（名称和消息）。 指示<code>std::error_code</code>没有错误的代码也为0。在每种情况下，错误代码可能会不同。 <br> 除了添加类别编号，我希望没有任何开销。 <br><br> 因此，“发明”某些东西将使开发人员在为其枚举类型添加类别方面做出最少的动作是合乎逻辑的。 <br><br> 首先，您需要创建一个类似于<code>std::error_code</code>的类，该类能够将任何枚举类型转换为整数，反之亦然，从整数转换为枚举类型。 加上这些功能，为了能够返回类别，代码的实际值，并能够检查： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//GetLastError()   CpuError ReturnCode result(cpuDiagnostic.GetLastError()) ; if(result) //    { ... }</span></span></code> </pre><br><h3> 解决方案 </h3><br> 该类必须存储错误代码，类别代码和与没有错误相对应的代码，强制转换运算符和赋值运算符。 对应的类如下： <br><br><img src="https://habrastorage.org/webt/v9/s3/nv/v9s3nvtgcu06simqv7mahn0h3fk.png"><br><br><div class="spoiler">  <b class="spoiler_title">类代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReturnCode() { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//Cast to only enum types static_assert(std::is_enum&lt;T&gt;::value, "   ") ; return static_cast&lt;T&gt;(errorValue) ; } tU32 GetValue() const { return errorValue; } tU32 GetCategoryValue() const { return errorCategory; } operator bool() const { return (GetValue() != goodCode); } template&lt;class T&gt; ReturnCode&amp; operator=(const T returnCode) { errorValue = static_cast&lt;tU32&gt;(returnCode) ; errorCategory = GetCategory(returnCode) ; goodCode = GetOk(returnCode) ; return *this ; } private: tU32 errorValue = 0U ; tU32 errorCategory = 0U ; tU32 goodCode = 0U ; } ;</span></span></code> </pre><br></div></div><br> 有必要解释一下这里发生了什么。 从模板构造函数开始 <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) ; }</code> </pre><br><br> 它允许您从任何枚举类型创建对象类： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error::Ok)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(My_Error::Error1)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpuDiagnostic.GetLatestError())</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br> 为了确保构造函数只能接受枚举类型，将<code>static_assert</code>添加到其主体，该主体在编译时将使用<code>std::is_enum</code>检查传递给构造函数的类型，并使用<code>std::is_enum</code>错误。 此处未生成实际代码，仅用于编译器。 所以实际上这是一个空的构造函数。 <br><br> 构造函数还初始化了私有属性，我稍后会再讲... <br> 接下来，强制转换运算符： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//Cast to only enum types static_assert(std::is_enum&lt;T&gt;::value, "   ") ; return static_cast&lt;T&gt;(errorValue) ; }</span></span></code> </pre><br> 它也只能导致枚举类型，并允许我们执行以下操作： <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error::Rom)</span></span></span><span class="hljs-function"> </span></span>; Cpu_Error status = errorCode ; returnCode = My_Errror::Error2; My_Errror status1 = returnCode ; returnCode = myDiagnostic.GetLastError() ; MyDiagsonticError status2 = returnCode ;</code> </pre><br> 好吧，分别使用bool（）运算符： <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (GetValue() != goodCode); }</code> </pre><br> 这将使我们直接检查返回码中是否有任何错误： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//GetLastError()   Cpu_Error ReturnCode result(cpuDiagnostic.GetLastError()) ; if(result) //    { ... }</span></span></code> </pre><br> 这基本上就是全部。 问题仍然存在于<code>GetCategory()</code>和<code>GetOkCode()</code>函数中。 您可能会猜到，第一个用于枚举类型，以便以某种方式将其类别传递给<code>ReturnCode</code>类，第二个用于枚举类型，表明它是一个很好的返回码，因为我们将其与<code>bool()</code>运算符进行比较。 <br><br> 显然，这些功能可以由用户提供，我们可以通过依赖于参数的搜索机制在构造函数中诚实地调用它们。 <br> 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoryError</span></span></span><span class="hljs-class"> {</span></span> Nv = <span class="hljs-number"><span class="hljs-number">100</span></span>, Cpu = <span class="hljs-number"><span class="hljs-number">200</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom } ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error errorNum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(CategoryError::Cpu); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOkCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(Cpu_Error::Ok); }</code> </pre><br> 这需要开发人员付出额外的努力。 我们需要为每个要分类的枚举类型添加这两个方法并更新<code>CategoryError</code>枚举。 <br><br> 但是，我们希望开发人员几乎不向代码添加任何内容，而不必理会如何扩展其枚举类型。 <br> 可以做什么。 <br><br><ul><li> 首先，可以自动计算类别非常<code>GetCategory()</code> ，并且开发<b>人员不必</b>为每个枚举提供<code>GetCategory()</code>方法的实现。 </li><li> 其次，在我们代码的90％情况下，Ok用于返回良好的代码。 因此，您可以为这90％的人编写一般的实现，而对于10％的人，则必须进行专门化。 </li></ul><br> 因此，让我们专注于第一个任务-自动类别计算。 我的同事提出的想法是，开发人员应该能够注册其枚举类型。 这可以使用带有可变数量参数的模板来完成。 声明这样的结构 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnumTypeRegister</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre><br> 现在要注册一个新的枚举（应按类别进行扩展），我们只需定义一个新类型 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error&gt;;</code> </pre><br> 如果突然需要添加另一个枚举，则只需将其添加到模板参数列表中即可： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;;</code> </pre><br> 显然，我们列表的类别可能是模板参数列表中的位置，即 对于<code>Cpu_Error</code>为<b>0</b> ，对于<code>Measure_Error</code>为<b>1</b> ，对于<code>My_Error</code>为<b>2</b> 。 仍然迫使编译器自动进行计算。 对于C ++ 14，我们这样做： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EnumTypeRegister&lt;Type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, <span class="hljs-string"><span class="hljs-string">"     EnumTypeRegister"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tU32(<span class="hljs-number"><span class="hljs-number">0U</span></span>) ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0U</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1U</span></span> + GetEnumPosition&lt;QueriedType&gt;(EnumTypeRegister&lt;Types...&gt;()) ; }</code> </pre><br> 这是怎么回事。 简而言之，就是<code>GetEnumPosition&lt;T&lt;&gt;&gt;</code>函数，输入参数是<code>EnumTypeRegister</code>枚举类型的列表，在我们的例子中是<code>EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;</code> ，而模板参数<b>T</b>是枚举类型，我们应该在此列表中找到它的索引，在列表中运行，如果T与列表中的一种类型匹配，则返回其索引，否则将显示消息“类型未在EnumTypeRegister列表中注册” <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//..    constexpr EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt; list //  GetEnumPosition&lt;Measure_Error&gt;(list) //   1 -    Measure_Error   .</span></span></code> </pre><br> 让我们更详细地分析。 最低功能 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(TypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1U</span></span> + GetEnumPosition&lt;QueriedType&gt;(TypeRegister&lt;Types...&gt;()) ; }</code> </pre><br> 在这里，分支<code>std::enable_if_t&lt; <b>!std::is_same</b> ..</code>检查请求的类型是否与模板列表中的第一个类型匹配，如果不匹配，则<code>GetEnumPosition</code>函数的返回类型将为<code>tU32</code> ，然后执行函数主体，即再次递归调用同一函数，而模板参数的数量减少<b>1</b> ，而返回值增加<b>1</b> 。 也就是说，在每次迭代中都会有类似的东西： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Iteration 1, 1+: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;) //Iteration 2, 1+1+: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) //Iteration 3, 1+1+1: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;My_Error&gt;)</span></span></code> </pre><br> 列表中的所有类型结束后， <code>std::enable_if_t</code>将无法推断<code>GetEnumPosition()</code>函数的返回值的类型，并且在此迭代中将结束： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         GetEnumPosition&lt;T&gt;(TypeRegister&lt;&gt;) template &lt;typename QueriedType, typename Type&gt; constexpr tU32 GetEnumPosition(EnumTypeRegister&lt;Type&gt;) { static_assert(std::is_same&lt;Type, QueriedType&gt;::value, "     EnumTypeRegister"); return tU32(0U) ; }</span></span></code> </pre><br> 如果类型在列表中，该怎么办。 在这种情况下，另一个分支将起作用，分支c <code>std::enable_if_t&lt; <b>std::is_same</b> ..</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(TypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0U</span></span> ; }</code> </pre><br> 此处检查类型<code>std::enable_if_t&lt; <b>std::is_same</b> ...</code>如果，如果在输入处输入类型<code>Measure_Error</code> ，则将获得以下序列： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Iteration 1, tU32 GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;) { return 1U + GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) } //Iteration 2: tU32 GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) { return 0 ; }</span></span></code> </pre><br> 在第二次迭代中，递归函数调用结束，我们在输出处获得1（从第一次迭代）+ 0（从第二次迭代）= <b>1-</b>这是列表<code>EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;</code>类型的索引 <br><br> 由于这是<code>constexpr,</code>函数<code>constexpr,</code>所有计算都在编译阶段完成，并且实际上未生成任何代码。 <br><br> 所有这些都无法编写，只能由C ++ 17来处理。 不幸的是，我的IAR编译器不完全支持C ++ 17，因此可以用以下代码替换整个鞋类： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//for C++17 template &lt;typename QueriedType, typename Type, typename... Types&gt; constexpr tU32 GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { //        if constexpr (std::is_same&lt;Type, QueriedType&gt;::value) { return 0U ; } else { return 1U + GetEnumPosition&lt;QueriedType&gt;(EnumTypeRegister&lt;Types...&gt;()) ; } }</span></span></code> </pre><br> 现在剩下要做的模板方法<code>GetCategory()</code>和<code>GetOk()</code> ，它们将调用<code>GetEnumPosition</code> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(GetEnumPosition&lt;T&gt;(categoryDictionary)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(T::Ok); }</code> </pre><br> 仅此而已。 现在让我们看一下此对象构造会发生什么： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Measure_Error::Ok)</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br> 让我们回到<code>ReturnCode</code>类的构造函数 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"The type have to be enum"</span></span>) ; }</code> </pre><br> 它是一个模板，如果<code>T</code>是<code>Measure_Error</code>则意味着对于<code>GetCategory(Measure_Error)</code>类型，调用了<code>GetCategory(Measure_Error)</code>方法模板的实例化，该方法模板又调用了类型为<code>Measure_Error</code> ， <code>GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;)</code>返回<code>Measure_Error</code>在列表中的位置。 位置是<b>1</b> 。 实际上，在<code>Measure_Error</code>类型实例化时的整个构造函数代码都由编译器替换为： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Measure_Error initReturnCode)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br><h3> 总结 </h3><br> 对于<code>ReturnCode</code>使用<code>ReturnCode</code>的开发人员，只有一件事要做： <br> 在列表中注册您的枚举类型。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add enum in the category using CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;;</span></span></code> </pre><br> 而且没有不必要的动作，现有代码不会动，对于扩展，您只需要在列表中注册类型。 而且，所有这些都将在编译阶段完成，并且编译器不仅会计算所有类别，而且还会在您忘记注册类型或尝试传递非不可枚举的类型时发出警告。 <br><br> 公平地说，值得注意的是，在这10％的代码中，枚举具有不同的名称而不是Ok代码，您将必须对此类型进行自己的专门化。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 GetOk&lt;MyError&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyError) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(MyError::Good) ; } ;</code> </pre><br> 我在这里发布了一个小示例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码示例</a> <br><br> 通常，这是一个应用程序： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom, Ram } ; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Measure_Error</span></span></span><span class="hljs-class"> {</span></span> OutOfLimits, Ok, BadCode } ; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">My_Error</span></span></span><span class="hljs-class"> {</span></span> Error1, Error2, Error3, Error4, Ok } ; <span class="hljs-comment"><span class="hljs-comment">// Add enum in the category list using CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;; Cpu_Error CpuCheck() { return Cpu_Error::Ram; } My_Error MyCheck() { return My_Error::Error4; } int main() { ReturnCode result(CpuCheck()); //cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; if (result) //if something wrong { result = MyCheck() ; // cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; } result = Measure_Error::BadCode ; //cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; result = Measure_Error::Ok ; if (!result) //if all is Ok { Measure_Error mError = result ; if (mError == Measure_Error::Ok) { // cout &lt;&lt; "mError: "&lt;&lt; tU32(mError) &lt;&lt; endl; } } return 0; }</span></span></code> </pre> <br> 打印以下行： <br><blockquote> 返回码：3返回类别：0 <br> 返回码：3返回类别：2 <br> 返回码：2返回类别：1 <br>  mError：1 <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441956/">https://habr.com/ru/post/zh-CN441956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441944/index.html">为什么我们选择雷克萨斯RX450h</a></li>
<li><a href="../zh-CN441946/index.html">100行代码中Laravel上的REST API</a></li>
<li><a href="../zh-CN441950/index.html">Eclipse Che 7已经在这里</a></li>
<li><a href="../zh-CN441952/index.html">选择文件存储系统进行团队合作</a></li>
<li><a href="../zh-CN441954/index.html">用户奖赏给Habr的作者</a></li>
<li><a href="../zh-CN441962/index.html">PostgreSQL中的索引-1</a></li>
<li><a href="../zh-CN441964/index.html">Kubernetes技巧与窍门：将集群资源移至Helm 2</a></li>
<li><a href="../zh-CN441966/index.html">网络安全测试入门套件</a></li>
<li><a href="../zh-CN441968/index.html">开发新产品分支：如何摆脱不切实际并保持有用</a></li>
<li><a href="../zh-CN441970/index.html">FinFisher Butkit分析</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>