<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💀 🧑🏿‍🤝‍🧑🏾 🖕🏿 Wie eBay einen Barcode-Scanner in WebAssembly erstellt hat 🤘🏼 🖕🏼 ⛳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit ihrer Ankündigung hat die WebAssembly- Technologie sofort die Aufmerksamkeit von Front-End-Entwicklern auf sich gezogen. Die Web-Community akzept...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie eBay einen Barcode-Scanner in WebAssembly erstellt hat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453712/"> Seit ihrer Ankündigung hat die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly-</a> Technologie sofort die Aufmerksamkeit von Front-End-Entwicklern auf sich gezogen.  Die Web-Community akzeptierte begeistert die Idee, Code in einem Browser auszuführen, der in anderen Sprachen als JavaScript geschrieben ist.  Die Hauptsache ist, dass WebAssembly eine viel höhere Geschwindigkeit als JavaScript garantiert. <br><br>  Unsere Ingenieure haben die Entwicklung des Standards genau verfolgt.  Sobald die Unterstützung für WebAssembly 1.0 in allen gängigen Browsern implementiert war, wollten die Entwickler sie sofort ausprobieren. <br><br>  Aber es gab ein Problem.  Obwohl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele Anwendungen</a> von WebAssembly profitieren, ist der Umfang der Technologie im E-Commerce immer noch primitiv.  Wir konnten nicht sofort die richtige Version seiner Verwendung finden.  Es gab einige Vorschläge, aber JavaScript war in allen Variationen besser.  Bei der Bewertung neuer Technologien bei eBay lautet die erste Frage: „Was sind die potenziellen Vorteile für unsere Kunden?“  Wenn hier keine Klarheit besteht, werden wir nicht mit dem nächsten Schritt fortfahren.  Es ist sehr einfach, sich von neuer modischer Technologie mitreißen zu lassen, auch wenn dies für die Kunden keine Rolle spielt und nur den bestehenden Workflow kompliziert.  Die Benutzererfahrung ist immer wichtiger als die Entwicklererfahrung.  Aber mit WebAssembly anders.  Diese Technologie hat ein enormes Potenzial, wir konnten einfach nicht den richtigen Anwendungsfall finden.  Am Ende fanden sie es jedoch immer noch. <br><a name="habracut"></a><br><h2>  Barcode-Scanner </h2><br>  In nativen eBay-Apps für iOS und Android gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UPC-</a> Barcode-Scanfunktion, mit der das Formular automatisch eingegeben werden kann.  Es funktioniert nur in Anwendungen und erfordert eine intensive Verarbeitung von Bildern auf dem Gerät, um die Barcode-Ziffern im Bildstrom von der Kamera zu erkennen.  Der resultierende Code wird dann an den Serverdienst gesendet, der seinerseits das Formular ausfüllt.  Dies bedeutet, dass die Bildverarbeitungslogik auf dem Gerät sehr effizient sein muss.  Für native Anwendungen haben wir unsere eigene C ++ - Bibliothek in nativen Code für iOS und Android kompiliert.  Es erkennt Barcodes außergewöhnlich gut.  Wir wechseln schrittweise zu nativen APIs in iOS und Android, aber unsere C ++ - Bibliothek ist immer noch zuverlässig. <br><br>  Der Barcode-Scanner ist eine intuitive Funktion für Verkäufer und vereinfacht das Ausfüllen des Formulars erheblich.  Leider funktionierte diese Funktion auf der mobilen Version der Website nicht und Verkäufer mussten die UPC manuell eingeben, was unpraktisch ist. <br><br><h2>  Web-Barcode-Scanner </h2><br>  Früher haben wir nach einer Option zum Scannen von Barcodes im Web gesucht.  Vor zwei Jahren veröffentlichten sie sogar einen Prototyp, der auf der Open-Source-JavaScript-Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BarcodeReader</a> basiert.  Das Problem war, dass es nur in 20% der Fälle gut funktionierte.  Die restlichen 80% der Zeit arbeitete der Scanner extrem langsam oder überhaupt nicht.  In den meisten Fällen war es eine Auszeit.  Es wird durchaus erwartet: JavaScript kann nur dann in seiner Geschwindigkeit mit nativem Code verglichen werden, wenn es sich auf einem „heißen Weg“ befindet, dh von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JIT-</a> Compilern stark optimiert wird.  Der Trick besteht darin, dass JavaScript-Engines zahlreiche Heuristiken verwenden, um festzustellen, ob ein Pfad "heiß" ist, ohne ein Ergebnis zu garantieren.  Diese Diskrepanz führte offensichtlich zu Frustration der Benutzer, und wir mussten diese Funktion deaktivieren.  Aber jetzt ist alles anders.  Mit der rasanten Entwicklung der Webplattform stellte sich die Frage: "Ist es möglich, einen zuverlässigen Barcode-Scanner im Web zu implementieren?" <br><br>  Eine Möglichkeit besteht darin, darauf zu warten, dass die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Formerkennungs-API</a> mit ihren integrierten Bilderkennungsfunktionen, einschließlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Barcodes, beendet wird</a> .  Diese Schnittstellen befinden sich jedoch noch in einem sehr frühen Entwicklungsstadium und sind weit von einer browserübergreifenden Kompatibilität entfernt.  Und selbst in diesem Fall ist die Arbeit auf allen Plattformen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht garantiert</a> .  Daher müssen Sie andere Optionen in Betracht ziehen. <br><br>  Hier kommt WebAssembly ins Spiel.  Wenn ein Barcode-Scanner in WebAssembly implementiert ist, funktioniert er garantiert.  Die starke Typisierungs- und Bytecode-Struktur von WebAssembly ermöglicht es Ihnen, immer den "Hot Path" der Ausführung beizubehalten.  Darüber hinaus verfügen wir bereits über eine C ++ - Bibliothek für native Anwendungen.  C ++ - Bibliotheken sind ideale Kandidaten für die Kompilierung in WebAssembly.  Wir dachten, das Problem sei gelöst.  Es stellte sich heraus, nicht wirklich. <br><br><h2>  Architektur </h2><br>  Die funktionierende Prototyparchitektur für den Barcode-Scanner in WebAssembly war ziemlich einfach. <br><br><ul><li>  Kompilieren Sie die C ++ - Bibliothek mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emscripten</a> .  Es werden die Middleware und die WASM-Datei erstellt. <br></li><li>  Wählen Sie einen Arbeitsthread aus dem Hauptthread aus.  Der JavaScript-Code für den Worker importiert den generierten JavaScript-Verknüpfungscode, der wiederum die WASM-Datei erstellt. <br></li><li>  Der Hauptstrom sendet einen Schnappschuss vom Strom von der Kamera an den Arbeitsstrom und ruft die entsprechende WASM-API über den Verbindungscode auf.  Die API-Antwort wird an den Hauptthread übergeben.  Die Antwort kann eine UPC-Zeichenfolge (die an das Backend übergeben wird) oder eine leere Zeichenfolge sein, wenn kein Barcode erkannt wird. <br></li><li>  Für eine leere Antwort wird der obige Schritt wiederholt, bis ein Barcode erkannt wird.  Dieser Zyklus läuft für das angegebene Zeitintervall in Sekunden.  Sobald der Schwellenwert erreicht ist, wird eine Warnmeldung angezeigt: <i>„Ungültiger Produktcode.</i>  <i>Versuchen Sie es mit einer anderen Barcode- oder Textsuche</i> . <i>“</i>  Entweder hat der Benutzer die Kamera nicht auf einen echten Barcode fokussiert, oder der Scanner ist nicht effektiv genug.  Wir verfolgen Statistiken zu Zeitüberschreitungen als Indikator für die Qualität des Scanners. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/08c/b99/50e08cb9985f38e32a51caefe0a0356d.png"></div><br>  <i><font color="gray">WebAssembly-Workflow</font></i> <br><br><h4>  Zusammenstellung </h4><br>  Der erste Schritt in einem WebAssembly-Projekt besteht darin, eine übersichtliche Kompilierungspipeline zu definieren.  Emscripten ist zum De-facto-Standard für die Kompilierung von WebAssembly geworden. Es ist jedoch wichtig, eine konsistente Umgebung zu haben, die ein deterministisches Ergebnis liefert.  Unser Frontend basiert auf Node.js, daher müssen wir eine Lösung finden, die mit dem npm-Workflow kompatibel ist.  Glücklicherweise veröffentlichte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Surma Das zu</a> dieser Zeit einen Artikel mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Titel „Emscripten and npm“</a> .  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-</a> basierte Ansatz zum Kompilieren von WebAssembly ist sinnvoll, da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hierdurch eine Menge Overhead vermieden wird</a> .  Wie im Artikel empfohlen, haben wir das Docker- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Image von Emscripten</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">trzeci übernommen</a> .  Um die Kompilierung in WebAssembly zu ermöglichen, musste die native C ++ - Bibliothek etwas optimiert werden.  Grundsätzlich haben wir zufällig, durch Versuch und Irrtum gehandelt.  Am Ende gelang es mir, es zu kompilieren und einen ordentlichen WebAssembly-Workflow innerhalb der vorhandenen Assembly-Pipeline einzurichten. <br><br><h4>  Es funktioniert schnell, aber ... </h4><br>  Die Scannerleistung wird anhand der Anzahl der von der Wasm-API pro Sekunde verarbeiteten Frames gemessen.  Die Wasm-API nimmt einen Frame aus dem Videostream der Kamera, führt Berechnungen durch und gibt eine Antwort zurück.  Dies erfolgt fortlaufend, bis ein Barcode erkannt wird.  Die Leistung wird in FPS gemessen. <br><br>  Unsere Testimplementierung von WebAssembly zeigte eine erstaunliche Geschwindigkeit von 50 FPS.  Es funktionierte jedoch nur in 60% der Fälle und im Rest stürzte es durch Timeout ab.  Selbst mit solch einer hohen FPS konnten sie den Barcode für die verbleibenden 40% der Scans nicht schnell erkennen und gaben am Ende eine Warnmeldung aus.  Im Vergleich dazu lief die vorherige JavaScript-Implementierung normalerweise mit 1 FPS.  Ja, WebAssembly ist viel schneller (50-mal), aber aus irgendeinem Grund funktioniert es in fast der Hälfte der Fälle nicht.  Es sollte auch beachtet werden, dass JavaScript in einigen Situationen sehr gut funktionierte und den Barcode sofort fand.  Eine der offensichtlichen Optionen bestand darin, das Zeitlimit zu erhöhen. Dies erhöht jedoch nur die Frustration der Benutzer, sodass wir das eigentliche Problem nicht lösen.  Deshalb haben wir diese Idee aufgegeben. <br><br>  Zuerst konnten wir nicht verstehen, warum die native C ++ - Bibliothek, die in nativen Anwendungen perfekt funktionierte, im Web nicht das gleiche Ergebnis zeigte.  Nach langem Testen und Debuggen haben wir festgestellt, dass die Erkennungsgeschwindigkeit vom Fokuswinkel des Objekts und dem Hintergrundschatten abhängt.  Aber wie funktioniert dann alles in nativen Anwendungen?  Tatsache ist, dass wir in nativen Anwendungen die integrierten APIs für den Autofokus verwenden und dem Benutzer die Möglichkeit bieten, manuell zu fokussieren, indem er mit dem Finger auf den Barcode zeigt.  Daher bieten native Anwendungen der Bibliothek immer klare Bilder in hoher Qualität. <br><br>  Wir erkannten die Essenz des Geschehens und beschlossen, eine andere native Bibliothek auszuprobieren: einen recht beliebten und stabilen Open-Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ZBar-</a> Barcode-Scanner.  Noch wichtiger ist, dass es gut mit verschwommenen und körnigen Bildern funktioniert.  Warum probieren Sie es nicht aus?  Da wir bereits über den WebAssembly-Workflow verfügten, verlief die Kompilierung und Bereitstellung von ZBar in WebAssembly reibungslos.  Die Leistung erwies sich mit 15 FPS als anständig, wenn auch nicht so gut wie die unserer eigenen C ++ - Bibliothek.  Bei gleichem Timeout lag die Erfolgsquote jedoch nahe bei 80%.  Eine deutliche Verbesserung gegenüber unserer C ++ - Bibliothek, aber immer noch nicht 100%. <br><br>  Das Ergebnis hat uns noch nicht zufrieden gestellt, aber wir haben etwas Unerwartetes bemerkt.  Wo Zbar ausfiel, erledigte unsere eigene C ++ - Bibliothek die Arbeit sehr schnell.  Es war eine angenehme Überraschung.  Es scheint, dass Bibliotheken Bilder unterschiedlicher Qualität auf unterschiedliche Weise verarbeiteten.  Dies führte uns zu der Idee. <br><br><h4>  Multithreading und Speed ​​Racing </h4><br>  Du hast es wahrscheinlich schon verstanden.  Erstellen Sie zwei Arbeitsthreads: einen für Zbar und einen für unsere C ++ - Bibliothek und führen Sie sie nicht parallel aus.  Wer gewonnen hat (wer zuerst einen gültigen Barcode sendet), sendet das Ergebnis an den Hauptstrom, und beide Mitarbeiter halten an.  Wir haben ein solches Szenario implementiert und uns selbst getestet, um so viele Szenarien wie möglich zu simulieren.  Diese Einstellung zeigte 95% der erfolgreichen Scans.  Viel besser als die vorherigen Ergebnisse, aber immer noch nicht 100%. <br><br>  Einer der seltsamen Vorschläge war, die ursprüngliche JavaScipt-Bibliothek zum Wettbewerb hinzuzufügen.  Es werden drei Streams sein.  Wir haben ehrlich gesagt nicht gedacht, dass dies etwas ändern würde.  Ein solcher Test erforderte jedoch keinen Aufwand, da wir die Arbeitsoberfläche standardisiert haben.  Zu unserer Überraschung lag die Erfolgsquote mit drei Streams tatsächlich nahe bei 100%.  Dies war wiederum völlig unerwartet.  Wie bereits erwähnt, hat JavaScript in einigen Situationen sehr gut funktioniert.  Anscheinend schloss er die Lücke.  Die populäre Weisheit des Gesetzes lautet also: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"JavaScript gewinnt immer</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a>  Wenn ohne Witze, bietet die folgende Abbildung einen Überblick über die endgültige Architektur, die wir implementiert haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/f91/050/422f9105014e7571197453c7d2c9f6ec.png"></div><br>  <i><font color="gray">Barcode-Scanner für die Webarchitektur</font></i> <br><br>  Die folgende Abbildung zeigt ein Funktionsdiagramm auf hoher Ebene: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a74/005/4a6a740059f1599e759d9641a3251233.png"></div><br>  <i><font color="gray">Funktionsdiagramm eines Barcode-Scanners</font></i> <br><br><h4>  Hinweis zum Laden von Ressourcen </h4><br>  Die für das Funktionieren des Scanners erforderlichen Ressourcen werden nach dem Rendern der Hauptseite vorinstalliert.  Auf diese Weise wird die Zielseite schnell geladen und ist für die Interaktion bereit.  WebAssembly-Ressourcen (WASM-Dateien und Middleware-Skripte) und die JavaScript-Scannerbibliothek werden nach dem Laden der Hauptseite mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XMLHttpRequest</a> vorinstalliert und zwischengespeichert.  Hierbei ist es wichtig, dass sie nicht sofort ausgeführt werden, damit der Hauptthread für die Benutzerinteraktion mit der Seite frei bleibt.  Die Ausführung erfolgt nur, wenn der Benutzer auf das Barcodesymbol klickt.  Wenn der Benutzer vor dem Laden der Ressourcen auf das Symbol geklickt hat, werden diese bei Bedarf geladen und sofort ausgeführt.  Der Barcode-Scanner-Ereignishandler und der Worker-Controller werden mit der Seite geladen, sind jedoch sehr klein. <br><br><h2>  Ergebnisse </h2><br>  Nach strengen Tests und internem Gebrauch durch die Mitarbeiter haben wir A / B-Tests für Benutzer gestartet.  Das Scannersymbol (Abbildung unten) wurde der Testgruppe angezeigt, nicht jedoch der Kontrollgruppe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb5/a30/074/bb5a300749c27008137e8f45c9bdced9.png"></div><br>  <i><font color="gray">Endprodukt</font></i> <br><br>  Um den Erfolg zu messen, haben wir die Metrik Draft Completion Rate eingeführt.  Dies ist die Zeit zwischen dem Beginn der Bearbeitung eines Entwurfs und dem Absenden eines Formulars.  Die Metrik sollte zeigen, wie ein Barcode-Scanner beim Ausfüllen von Formularen hilft.  Der Test dauerte mehrere Wochen und die Ergebnisse waren sehr angenehm.  Sie stimmen voll und ganz mit unserer ursprünglichen Hypothese überein.  <b>Die Entwurfsabschlusszeit wurde für einen Stream mit einem Barcode-Scanner um 30% verringert.</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7f/f62/177/c7ff62177f92bc9f19059c569f2531ed.png"></div><br>  <i><font color="gray">A / B-Testergebnisse</font></i> <br><br>  Wir haben auch Profilerstellung hinzugefügt, um die Wirksamkeit aller Scannertypen zu bewerten.  Den größten Beitrag leisteten erwartungsgemäß Zbar (53% der erfolgreichen Scans), dann unsere C ++ - Bibliothek (34%) und schließlich die JavaScript-Bibliothek mit 13%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/359/c5c/a31359c5c4211bf10548d8162370da89.png"></div><br><br><h2>  Fazit </h2><br>  Die Erfahrung bei der Implementierung von WebAssembly ist für uns sehr informativ geworden.  Ingenieure freuen sich sehr über die Entstehung neuer Technologien und möchten diese sofort ausprobieren.  Wenn die Technologie auch für Kunden nützlich ist, ist dies eine doppelte Freude.  Lassen Sie uns den am Anfang des Artikels geäußerten Gedanken wiederholen.  Die Technologie entwickelt sich sehr schnell.  Jeden Tag erscheint etwas Neues.  Für Kunden sind jedoch nur wenige Technologien von Bedeutung, und WebAssembly ist eine davon.  Unsere größte Schlussfolgerung aus dieser Übung ist, in 99 Situationen „Nein“ und in dem einzigen Fall „Ja“ zu sagen, wenn dies für Kunden wirklich wichtig ist. <br><br>  In Zukunft planen wir, die Verwendung eines Barcode-Scanners zu erweitern und auf Käuferseite einzuführen, damit diese Produktcodes offline für die Suche und den Kauf bei eBay scannen können.  Wir werden auch erwägen, die Funktion mithilfe der Formerkennungs-API und anderer Funktionen im Browser zu erweitern.  Wir freuen uns jedoch, den richtigen Anwendungsfall für WebAssembly bei eBay gefunden und die Technologie erfolgreich im E-Commerce eingesetzt zu haben. <br><br>  Besonderer Dank geht an Surma Das und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lin Clark</a> für zahlreiche Artikel zu WebAssembly.  Sie haben uns wirklich geholfen, die Sackgasse mehrmals zu überwinden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453712/">https://habr.com/ru/post/de453712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453698/index.html">Quanteninformation im Quantenbewusstsein</a></li>
<li><a href="../de453700/index.html">Lektionen zu SDL 2: Lektion 1 - Hallo, SDL 2</a></li>
<li><a href="../de453706/index.html">Wie ich die Zertifizierungsprüfung für Google Cloud Professional Data Engineer bestanden habe</a></li>
<li><a href="../de453708/index.html">AQUA RTOS Echtzeit-Betriebssystem für MK AVR in der BASCOM AVR-Umgebung</a></li>
<li><a href="../de453710/index.html">Entwicklungspraxis in großen Projekten: mitp SberPractice iOS # 1</a></li>
<li><a href="../de453714/index.html">TON-Testclient (Telegram Open Network) und die neue Fift-Sprache für intelligente Verträge</a></li>
<li><a href="../de453716/index.html">Country Coworking für Familien-IT-Mitarbeiter - gibt es jemanden?</a></li>
<li><a href="../de453720/index.html">Feinheiten von Lambda-Ausdrücken in C #</a></li>
<li><a href="../de453722/index.html">Über die Erforschung instationärer Prozesse</a></li>
<li><a href="../de453728/index.html">Schlacht der Hyperstars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>