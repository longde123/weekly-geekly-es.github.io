<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÄ üßëüèø‚Äçü§ù‚Äçüßëüèæ üñïüèø Wie eBay einen Barcode-Scanner in WebAssembly erstellt hat ü§òüèº üñïüèº ‚õ≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit ihrer Ank√ºndigung hat die WebAssembly- Technologie sofort die Aufmerksamkeit von Front-End-Entwicklern auf sich gezogen. Die Web-Community akzept...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie eBay einen Barcode-Scanner in WebAssembly erstellt hat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453712/"> Seit ihrer Ank√ºndigung hat die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly-</a> Technologie sofort die Aufmerksamkeit von Front-End-Entwicklern auf sich gezogen.  Die Web-Community akzeptierte begeistert die Idee, Code in einem Browser auszuf√ºhren, der in anderen Sprachen als JavaScript geschrieben ist.  Die Hauptsache ist, dass WebAssembly eine viel h√∂here Geschwindigkeit als JavaScript garantiert. <br><br>  Unsere Ingenieure haben die Entwicklung des Standards genau verfolgt.  Sobald die Unterst√ºtzung f√ºr WebAssembly 1.0 in allen g√§ngigen Browsern implementiert war, wollten die Entwickler sie sofort ausprobieren. <br><br>  Aber es gab ein Problem.  Obwohl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele Anwendungen</a> von WebAssembly profitieren, ist der Umfang der Technologie im E-Commerce immer noch primitiv.  Wir konnten nicht sofort die richtige Version seiner Verwendung finden.  Es gab einige Vorschl√§ge, aber JavaScript war in allen Variationen besser.  Bei der Bewertung neuer Technologien bei eBay lautet die erste Frage: ‚ÄûWas sind die potenziellen Vorteile f√ºr unsere Kunden?‚Äú  Wenn hier keine Klarheit besteht, werden wir nicht mit dem n√§chsten Schritt fortfahren.  Es ist sehr einfach, sich von neuer modischer Technologie mitrei√üen zu lassen, auch wenn dies f√ºr die Kunden keine Rolle spielt und nur den bestehenden Workflow kompliziert.  Die Benutzererfahrung ist immer wichtiger als die Entwicklererfahrung.  Aber mit WebAssembly anders.  Diese Technologie hat ein enormes Potenzial, wir konnten einfach nicht den richtigen Anwendungsfall finden.  Am Ende fanden sie es jedoch immer noch. <br><a name="habracut"></a><br><h2>  Barcode-Scanner </h2><br>  In nativen eBay-Apps f√ºr iOS und Android gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UPC-</a> Barcode-Scanfunktion, mit der das Formular automatisch eingegeben werden kann.  Es funktioniert nur in Anwendungen und erfordert eine intensive Verarbeitung von Bildern auf dem Ger√§t, um die Barcode-Ziffern im Bildstrom von der Kamera zu erkennen.  Der resultierende Code wird dann an den Serverdienst gesendet, der seinerseits das Formular ausf√ºllt.  Dies bedeutet, dass die Bildverarbeitungslogik auf dem Ger√§t sehr effizient sein muss.  F√ºr native Anwendungen haben wir unsere eigene C ++ - Bibliothek in nativen Code f√ºr iOS und Android kompiliert.  Es erkennt Barcodes au√üergew√∂hnlich gut.  Wir wechseln schrittweise zu nativen APIs in iOS und Android, aber unsere C ++ - Bibliothek ist immer noch zuverl√§ssig. <br><br>  Der Barcode-Scanner ist eine intuitive Funktion f√ºr Verk√§ufer und vereinfacht das Ausf√ºllen des Formulars erheblich.  Leider funktionierte diese Funktion auf der mobilen Version der Website nicht und Verk√§ufer mussten die UPC manuell eingeben, was unpraktisch ist. <br><br><h2>  Web-Barcode-Scanner </h2><br>  Fr√ºher haben wir nach einer Option zum Scannen von Barcodes im Web gesucht.  Vor zwei Jahren ver√∂ffentlichten sie sogar einen Prototyp, der auf der Open-Source-JavaScript-Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BarcodeReader</a> basiert.  Das Problem war, dass es nur in 20% der F√§lle gut funktionierte.  Die restlichen 80% der Zeit arbeitete der Scanner extrem langsam oder √ºberhaupt nicht.  In den meisten F√§llen war es eine Auszeit.  Es wird durchaus erwartet: JavaScript kann nur dann in seiner Geschwindigkeit mit nativem Code verglichen werden, wenn es sich auf einem ‚Äûhei√üen Weg‚Äú befindet, dh von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JIT-</a> Compilern stark optimiert wird.  Der Trick besteht darin, dass JavaScript-Engines zahlreiche Heuristiken verwenden, um festzustellen, ob ein Pfad "hei√ü" ist, ohne ein Ergebnis zu garantieren.  Diese Diskrepanz f√ºhrte offensichtlich zu Frustration der Benutzer, und wir mussten diese Funktion deaktivieren.  Aber jetzt ist alles anders.  Mit der rasanten Entwicklung der Webplattform stellte sich die Frage: "Ist es m√∂glich, einen zuverl√§ssigen Barcode-Scanner im Web zu implementieren?" <br><br>  Eine M√∂glichkeit besteht darin, darauf zu warten, dass die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Formerkennungs-API</a> mit ihren integrierten Bilderkennungsfunktionen, einschlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Barcodes, beendet wird</a> .  Diese Schnittstellen befinden sich jedoch noch in einem sehr fr√ºhen Entwicklungsstadium und sind weit von einer browser√ºbergreifenden Kompatibilit√§t entfernt.  Und selbst in diesem Fall ist die Arbeit auf allen Plattformen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht garantiert</a> .  Daher m√ºssen Sie andere Optionen in Betracht ziehen. <br><br>  Hier kommt WebAssembly ins Spiel.  Wenn ein Barcode-Scanner in WebAssembly implementiert ist, funktioniert er garantiert.  Die starke Typisierungs- und Bytecode-Struktur von WebAssembly erm√∂glicht es Ihnen, immer den "Hot Path" der Ausf√ºhrung beizubehalten.  Dar√ºber hinaus verf√ºgen wir bereits √ºber eine C ++ - Bibliothek f√ºr native Anwendungen.  C ++ - Bibliotheken sind ideale Kandidaten f√ºr die Kompilierung in WebAssembly.  Wir dachten, das Problem sei gel√∂st.  Es stellte sich heraus, nicht wirklich. <br><br><h2>  Architektur </h2><br>  Die funktionierende Prototyparchitektur f√ºr den Barcode-Scanner in WebAssembly war ziemlich einfach. <br><br><ul><li>  Kompilieren Sie die C ++ - Bibliothek mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emscripten</a> .  Es werden die Middleware und die WASM-Datei erstellt. <br></li><li>  W√§hlen Sie einen Arbeitsthread aus dem Hauptthread aus.  Der JavaScript-Code f√ºr den Worker importiert den generierten JavaScript-Verkn√ºpfungscode, der wiederum die WASM-Datei erstellt. <br></li><li>  Der Hauptstrom sendet einen Schnappschuss vom Strom von der Kamera an den Arbeitsstrom und ruft die entsprechende WASM-API √ºber den Verbindungscode auf.  Die API-Antwort wird an den Hauptthread √ºbergeben.  Die Antwort kann eine UPC-Zeichenfolge (die an das Backend √ºbergeben wird) oder eine leere Zeichenfolge sein, wenn kein Barcode erkannt wird. <br></li><li>  F√ºr eine leere Antwort wird der obige Schritt wiederholt, bis ein Barcode erkannt wird.  Dieser Zyklus l√§uft f√ºr das angegebene Zeitintervall in Sekunden.  Sobald der Schwellenwert erreicht ist, wird eine Warnmeldung angezeigt: <i>‚ÄûUng√ºltiger Produktcode.</i>  <i>Versuchen Sie es mit einer anderen Barcode- oder Textsuche</i> . <i>‚Äú</i>  Entweder hat der Benutzer die Kamera nicht auf einen echten Barcode fokussiert, oder der Scanner ist nicht effektiv genug.  Wir verfolgen Statistiken zu Zeit√ºberschreitungen als Indikator f√ºr die Qualit√§t des Scanners. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/08c/b99/50e08cb9985f38e32a51caefe0a0356d.png"></div><br>  <i><font color="gray">WebAssembly-Workflow</font></i> <br><br><h4>  Zusammenstellung </h4><br>  Der erste Schritt in einem WebAssembly-Projekt besteht darin, eine √ºbersichtliche Kompilierungspipeline zu definieren.  Emscripten ist zum De-facto-Standard f√ºr die Kompilierung von WebAssembly geworden. Es ist jedoch wichtig, eine konsistente Umgebung zu haben, die ein deterministisches Ergebnis liefert.  Unser Frontend basiert auf Node.js, daher m√ºssen wir eine L√∂sung finden, die mit dem npm-Workflow kompatibel ist.  Gl√ºcklicherweise ver√∂ffentlichte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Surma Das zu</a> dieser Zeit einen Artikel mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Titel ‚ÄûEmscripten and npm‚Äú</a> .  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-</a> basierte Ansatz zum Kompilieren von WebAssembly ist sinnvoll, da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hierdurch eine Menge Overhead vermieden wird</a> .  Wie im Artikel empfohlen, haben wir das Docker- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Image von Emscripten</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">trzeci √ºbernommen</a> .  Um die Kompilierung in WebAssembly zu erm√∂glichen, musste die native C ++ - Bibliothek etwas optimiert werden.  Grunds√§tzlich haben wir zuf√§llig, durch Versuch und Irrtum gehandelt.  Am Ende gelang es mir, es zu kompilieren und einen ordentlichen WebAssembly-Workflow innerhalb der vorhandenen Assembly-Pipeline einzurichten. <br><br><h4>  Es funktioniert schnell, aber ... </h4><br>  Die Scannerleistung wird anhand der Anzahl der von der Wasm-API pro Sekunde verarbeiteten Frames gemessen.  Die Wasm-API nimmt einen Frame aus dem Videostream der Kamera, f√ºhrt Berechnungen durch und gibt eine Antwort zur√ºck.  Dies erfolgt fortlaufend, bis ein Barcode erkannt wird.  Die Leistung wird in FPS gemessen. <br><br>  Unsere Testimplementierung von WebAssembly zeigte eine erstaunliche Geschwindigkeit von 50 FPS.  Es funktionierte jedoch nur in 60% der F√§lle und im Rest st√ºrzte es durch Timeout ab.  Selbst mit solch einer hohen FPS konnten sie den Barcode f√ºr die verbleibenden 40% der Scans nicht schnell erkennen und gaben am Ende eine Warnmeldung aus.  Im Vergleich dazu lief die vorherige JavaScript-Implementierung normalerweise mit 1 FPS.  Ja, WebAssembly ist viel schneller (50-mal), aber aus irgendeinem Grund funktioniert es in fast der H√§lfte der F√§lle nicht.  Es sollte auch beachtet werden, dass JavaScript in einigen Situationen sehr gut funktionierte und den Barcode sofort fand.  Eine der offensichtlichen Optionen bestand darin, das Zeitlimit zu erh√∂hen. Dies erh√∂ht jedoch nur die Frustration der Benutzer, sodass wir das eigentliche Problem nicht l√∂sen.  Deshalb haben wir diese Idee aufgegeben. <br><br>  Zuerst konnten wir nicht verstehen, warum die native C ++ - Bibliothek, die in nativen Anwendungen perfekt funktionierte, im Web nicht das gleiche Ergebnis zeigte.  Nach langem Testen und Debuggen haben wir festgestellt, dass die Erkennungsgeschwindigkeit vom Fokuswinkel des Objekts und dem Hintergrundschatten abh√§ngt.  Aber wie funktioniert dann alles in nativen Anwendungen?  Tatsache ist, dass wir in nativen Anwendungen die integrierten APIs f√ºr den Autofokus verwenden und dem Benutzer die M√∂glichkeit bieten, manuell zu fokussieren, indem er mit dem Finger auf den Barcode zeigt.  Daher bieten native Anwendungen der Bibliothek immer klare Bilder in hoher Qualit√§t. <br><br>  Wir erkannten die Essenz des Geschehens und beschlossen, eine andere native Bibliothek auszuprobieren: einen recht beliebten und stabilen Open-Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ZBar-</a> Barcode-Scanner.  Noch wichtiger ist, dass es gut mit verschwommenen und k√∂rnigen Bildern funktioniert.  Warum probieren Sie es nicht aus?  Da wir bereits √ºber den WebAssembly-Workflow verf√ºgten, verlief die Kompilierung und Bereitstellung von ZBar in WebAssembly reibungslos.  Die Leistung erwies sich mit 15 FPS als anst√§ndig, wenn auch nicht so gut wie die unserer eigenen C ++ - Bibliothek.  Bei gleichem Timeout lag die Erfolgsquote jedoch nahe bei 80%.  Eine deutliche Verbesserung gegen√ºber unserer C ++ - Bibliothek, aber immer noch nicht 100%. <br><br>  Das Ergebnis hat uns noch nicht zufrieden gestellt, aber wir haben etwas Unerwartetes bemerkt.  Wo Zbar ausfiel, erledigte unsere eigene C ++ - Bibliothek die Arbeit sehr schnell.  Es war eine angenehme √úberraschung.  Es scheint, dass Bibliotheken Bilder unterschiedlicher Qualit√§t auf unterschiedliche Weise verarbeiteten.  Dies f√ºhrte uns zu der Idee. <br><br><h4>  Multithreading und Speed ‚Äã‚ÄãRacing </h4><br>  Du hast es wahrscheinlich schon verstanden.  Erstellen Sie zwei Arbeitsthreads: einen f√ºr Zbar und einen f√ºr unsere C ++ - Bibliothek und f√ºhren Sie sie nicht parallel aus.  Wer gewonnen hat (wer zuerst einen g√ºltigen Barcode sendet), sendet das Ergebnis an den Hauptstrom, und beide Mitarbeiter halten an.  Wir haben ein solches Szenario implementiert und uns selbst getestet, um so viele Szenarien wie m√∂glich zu simulieren.  Diese Einstellung zeigte 95% der erfolgreichen Scans.  Viel besser als die vorherigen Ergebnisse, aber immer noch nicht 100%. <br><br>  Einer der seltsamen Vorschl√§ge war, die urspr√ºngliche JavaScipt-Bibliothek zum Wettbewerb hinzuzuf√ºgen.  Es werden drei Streams sein.  Wir haben ehrlich gesagt nicht gedacht, dass dies etwas √§ndern w√ºrde.  Ein solcher Test erforderte jedoch keinen Aufwand, da wir die Arbeitsoberfl√§che standardisiert haben.  Zu unserer √úberraschung lag die Erfolgsquote mit drei Streams tats√§chlich nahe bei 100%.  Dies war wiederum v√∂llig unerwartet.  Wie bereits erw√§hnt, hat JavaScript in einigen Situationen sehr gut funktioniert.  Anscheinend schloss er die L√ºcke.  Die popul√§re Weisheit des Gesetzes lautet also: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"JavaScript gewinnt immer</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a>  Wenn ohne Witze, bietet die folgende Abbildung einen √úberblick √ºber die endg√ºltige Architektur, die wir implementiert haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/f91/050/422f9105014e7571197453c7d2c9f6ec.png"></div><br>  <i><font color="gray">Barcode-Scanner f√ºr die Webarchitektur</font></i> <br><br>  Die folgende Abbildung zeigt ein Funktionsdiagramm auf hoher Ebene: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a74/005/4a6a740059f1599e759d9641a3251233.png"></div><br>  <i><font color="gray">Funktionsdiagramm eines Barcode-Scanners</font></i> <br><br><h4>  Hinweis zum Laden von Ressourcen </h4><br>  Die f√ºr das Funktionieren des Scanners erforderlichen Ressourcen werden nach dem Rendern der Hauptseite vorinstalliert.  Auf diese Weise wird die Zielseite schnell geladen und ist f√ºr die Interaktion bereit.  WebAssembly-Ressourcen (WASM-Dateien und Middleware-Skripte) und die JavaScript-Scannerbibliothek werden nach dem Laden der Hauptseite mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XMLHttpRequest</a> vorinstalliert und zwischengespeichert.  Hierbei ist es wichtig, dass sie nicht sofort ausgef√ºhrt werden, damit der Hauptthread f√ºr die Benutzerinteraktion mit der Seite frei bleibt.  Die Ausf√ºhrung erfolgt nur, wenn der Benutzer auf das Barcodesymbol klickt.  Wenn der Benutzer vor dem Laden der Ressourcen auf das Symbol geklickt hat, werden diese bei Bedarf geladen und sofort ausgef√ºhrt.  Der Barcode-Scanner-Ereignishandler und der Worker-Controller werden mit der Seite geladen, sind jedoch sehr klein. <br><br><h2>  Ergebnisse </h2><br>  Nach strengen Tests und internem Gebrauch durch die Mitarbeiter haben wir A / B-Tests f√ºr Benutzer gestartet.  Das Scannersymbol (Abbildung unten) wurde der Testgruppe angezeigt, nicht jedoch der Kontrollgruppe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb5/a30/074/bb5a300749c27008137e8f45c9bdced9.png"></div><br>  <i><font color="gray">Endprodukt</font></i> <br><br>  Um den Erfolg zu messen, haben wir die Metrik Draft Completion Rate eingef√ºhrt.  Dies ist die Zeit zwischen dem Beginn der Bearbeitung eines Entwurfs und dem Absenden eines Formulars.  Die Metrik sollte zeigen, wie ein Barcode-Scanner beim Ausf√ºllen von Formularen hilft.  Der Test dauerte mehrere Wochen und die Ergebnisse waren sehr angenehm.  Sie stimmen voll und ganz mit unserer urspr√ºnglichen Hypothese √ºberein.  <b>Die Entwurfsabschlusszeit wurde f√ºr einen Stream mit einem Barcode-Scanner um 30% verringert.</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7f/f62/177/c7ff62177f92bc9f19059c569f2531ed.png"></div><br>  <i><font color="gray">A / B-Testergebnisse</font></i> <br><br>  Wir haben auch Profilerstellung hinzugef√ºgt, um die Wirksamkeit aller Scannertypen zu bewerten.  Den gr√∂√üten Beitrag leisteten erwartungsgem√§√ü Zbar (53% der erfolgreichen Scans), dann unsere C ++ - Bibliothek (34%) und schlie√ülich die JavaScript-Bibliothek mit 13%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/359/c5c/a31359c5c4211bf10548d8162370da89.png"></div><br><br><h2>  Fazit </h2><br>  Die Erfahrung bei der Implementierung von WebAssembly ist f√ºr uns sehr informativ geworden.  Ingenieure freuen sich sehr √ºber die Entstehung neuer Technologien und m√∂chten diese sofort ausprobieren.  Wenn die Technologie auch f√ºr Kunden n√ºtzlich ist, ist dies eine doppelte Freude.  Lassen Sie uns den am Anfang des Artikels ge√§u√üerten Gedanken wiederholen.  Die Technologie entwickelt sich sehr schnell.  Jeden Tag erscheint etwas Neues.  F√ºr Kunden sind jedoch nur wenige Technologien von Bedeutung, und WebAssembly ist eine davon.  Unsere gr√∂√üte Schlussfolgerung aus dieser √úbung ist, in 99 Situationen ‚ÄûNein‚Äú und in dem einzigen Fall ‚ÄûJa‚Äú zu sagen, wenn dies f√ºr Kunden wirklich wichtig ist. <br><br>  In Zukunft planen wir, die Verwendung eines Barcode-Scanners zu erweitern und auf K√§uferseite einzuf√ºhren, damit diese Produktcodes offline f√ºr die Suche und den Kauf bei eBay scannen k√∂nnen.  Wir werden auch erw√§gen, die Funktion mithilfe der Formerkennungs-API und anderer Funktionen im Browser zu erweitern.  Wir freuen uns jedoch, den richtigen Anwendungsfall f√ºr WebAssembly bei eBay gefunden und die Technologie erfolgreich im E-Commerce eingesetzt zu haben. <br><br>  Besonderer Dank geht an Surma Das und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lin Clark</a> f√ºr zahlreiche Artikel zu WebAssembly.  Sie haben uns wirklich geholfen, die Sackgasse mehrmals zu √ºberwinden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453712/">https://habr.com/ru/post/de453712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453698/index.html">Quanteninformation im Quantenbewusstsein</a></li>
<li><a href="../de453700/index.html">Lektionen zu SDL 2: Lektion 1 - Hallo, SDL 2</a></li>
<li><a href="../de453706/index.html">Wie ich die Zertifizierungspr√ºfung f√ºr Google Cloud Professional Data Engineer bestanden habe</a></li>
<li><a href="../de453708/index.html">AQUA RTOS Echtzeit-Betriebssystem f√ºr MK AVR in der BASCOM AVR-Umgebung</a></li>
<li><a href="../de453710/index.html">Entwicklungspraxis in gro√üen Projekten: mitp SberPractice iOS # 1</a></li>
<li><a href="../de453714/index.html">TON-Testclient (Telegram Open Network) und die neue Fift-Sprache f√ºr intelligente Vertr√§ge</a></li>
<li><a href="../de453716/index.html">Country Coworking f√ºr Familien-IT-Mitarbeiter - gibt es jemanden?</a></li>
<li><a href="../de453720/index.html">Feinheiten von Lambda-Ausdr√ºcken in C #</a></li>
<li><a href="../de453722/index.html">√úber die Erforschung instation√§rer Prozesse</a></li>
<li><a href="../de453728/index.html">Schlacht der Hyperstars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>