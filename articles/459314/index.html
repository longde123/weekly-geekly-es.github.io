<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèø üë∂üèΩ üë®üèº‚Äçüåæ Visualice y trate con Hash Match Join üë©üèΩ‚Äç‚öñÔ∏è üßóüèΩ üë©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta publicaci√≥n es la tercera parte de la serie sobre operadores de uni√≥n (aseg√∫rese de leer la parte 1: combinaciones de bucles anidados y la parte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Visualice y trate con Hash Match Join</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/459314/"><p>  Esta publicaci√≥n es la tercera parte de la serie sobre operadores de uni√≥n (aseg√∫rese de leer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte 1: combinaciones de bucles anidados</a> y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte 2: combinaciones de fusi√≥n</a> ).  La traducci√≥n del art√≠culo fue preparada espec√≠ficamente para estudiantes del curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"MS SQL Server Developer"</a> . </p><br><p><img src="https://habrastorage.org/webt/zb/ut/6t/zbut6thx839xzxe3p-zgtwobgoy.png"></p><br><p>  <strong>Hash Match Joins</strong> son los caballos de batalla confiables de los operadores de conexi√≥n f√≠sica. <br>  Si bien Nested Loops Join fallar√° si hay demasiados datos para caber en la memoria, y Merge Join requerir√° que se ordene la entrada, <strong>Hash Match</strong> conectar√° todos los datos que env√≠e (siempre que se ejecuta un predicado de igualdad para la conexi√≥n, y hasta ahora hay suficiente espacio libre en su tempdb). </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/59C8c7p_hII" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mira videos relacionados con YouTube</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> </p><br><p>  El algoritmo de <strong>coincidencia hash</strong> consta de dos etapas, que funcionan de la siguiente manera: </p><br><p><img src="https://habrastorage.org/webt/h7/j2/sr/h7j2srrh-fso79crvhty8z3ezfy.gif"></p><br><p>  Durante la primera fase de compilaci√≥n, SQL Server crea una tabla hash en la memoria a partir de una de las tablas de entrada (generalmente la m√°s peque√±a de las dos).  Los hash se calculan en funci√≥n de las teclas de entrada y luego se almacenan junto con la l√≠nea en la tabla de hash en el bloque correspondiente.  En la mayor√≠a de los casos, solo hay una fila de datos en cada bloque, excepto cuando: </p><br><ol><li>  Hay l√≠neas con claves duplicadas. </li><li>  La funci√≥n hash crea una colisi√≥n, y las teclas completamente diferentes reciben el mismo hash (esto es raro, pero posible). </li></ol><br><p>  Despu√©s de crear la tabla hash, comienza la etapa "Sonda" (verificaci√≥n).  En el segundo paso, SQL Server calcula el hash de clave para cada fila en la segunda tabla de entrada y comprueba si existe en la tabla de hash creada en el primer paso.  Si hay una coincidencia para este hash, entonces se verifica si las claves de la (s) fila (s) en la tabla hash y las filas de la segunda tabla realmente coinciden (esta verificaci√≥n debe realizarse debido a posibles colisiones). <br>  Una versi√≥n com√∫n del algoritmo de <strong>coincidencia hash se</strong> produce cuando, en la etapa de construcci√≥n, no es posible crear una tabla hash que se pueda almacenar por completo en la memoria: </p><br><p><img src="https://habrastorage.org/webt/jx/pl/ip/jxplipr_fmggvdhkz3zwzsjmcks.gif"></p><br><p>  Esto sucede cuando hay m√°s datos de los que se pueden almacenar en la memoria o cuando SQL Server proporciona memoria insuficiente para una conexi√≥n de <strong>coincidencia hash</strong> . </p><br><p>  Cuando SQL Server no tiene suficiente memoria para almacenar la tabla hash durante la fase de compilaci√≥n, contin√∫a funcionando, almacenando algunos bloques en la memoria y colocando otros bloques en tempdb. <br>  En la fase de validaci√≥n, SQL Server concatena las filas de datos de la segunda tabla en bloques desde la fase de compilaci√≥n en la memoria.  Si el bloque al que corresponde potencialmente esta l√≠nea est√° actualmente sin memoria, SQL Server escribe esta l√≠nea en tempdb para una comparaci√≥n posterior. </p><br><p> Cuando se completan las coincidencias para un bloque, SQL Server borra estos datos de la memoria y carga los siguientes bloques en la memoria.  Luego compara las filas de la segunda tabla (actualmente ubicada en tempdb) con los nuevos bloques en la memoria. </p><br><p>  Al igual que con cada declaraci√≥n de combinaci√≥n f√≠sica en esta serie, los detalles sobre la declaraci√≥n de <strong>coincidencia hash</strong> se pueden encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ayuda de Hugo Kornelis sobre la coincidencia hash</a> . </p><br><h3 id="chto-pokazyvaet-hash-match-join">  ¬øQu√© muestra Hash Match Join? </h3><br><p>  Conocer las caracter√≠sticas internas de c√≥mo funciona la <strong>combinaci√≥n hash match</strong> nos permite determinar qu√© piensa el optimizador sobre nuestros operadores de datos y conexiones ascendentes, lo que nos ayuda a centrarnos en el ajuste del rendimiento. </p><br><p>  Aqu√≠ hay algunos escenarios para considerar la pr√≥xima vez que vea que la <strong>combinaci√≥n hash match se</strong> usa en su plan de ejecuci√≥n: </p><br><ul><li>  Si bien la <strong>combinaci√≥n de coincidencias hash</strong> puede combinar grandes conjuntos de datos, la construcci√≥n de una tabla hash a partir de la primera tabla de entrada es una operaci√≥n de bloqueo que impide la ejecuci√≥n de declaraciones posteriores.  En este sentido, siempre verifico si hay una manera f√°cil de convertir la <strong>coincidencia hash</strong> en bucles anidados o fusionar combinaci√≥n.  A veces esto no es posible (demasiadas filas para bucles anidados o datos sin clasificar para combinaci√≥n de combinaci√≥n), pero siempre vale la pena verificar si un simple cambio de √≠ndice o estimaciones mejoradas resultar√°n de actualizar estad√≠sticas al hecho de que SQL Server selecciona una declaraci√≥n de combinaci√≥n de <strong>coincidencia hash</strong> no bloqueante </li><li>  <strong>Las uniones de coincidencia de hash son</strong> excelentes para conexiones grandes, ya que pueden transferirse a tempdb, esto les permite hacer conexiones a grandes conjuntos de datos, lo que puede conducir a una conexi√≥n fallida en la memoria usando bucles anidados o fusionar declaraciones de uni√≥n. <br><ul><li>  Si ve una declaraci√≥n de <strong>uni√≥n de coincidencia hash</strong> , significa que SQL Server piensa que la entrada es demasiado grande.  Si sabemos que nuestros datos de entrada no deber√≠an ser tan grandes, entonces vale la pena verificar si hay problemas con las estad√≠sticas o la estimaci√≥n, debido a que SQL Server selecciona incorrectamente la <strong>combinaci√≥n de coincidencia hash</strong> . </li></ul></li><li>  Cuando se ejecuta en la memoria, la <strong>combinaci√≥n hash match es</strong> bastante eficiente.  Los problemas surgen cuando la fase de compilaci√≥n va a tempdb. <br><ul><li>  Si noto un peque√±o tri√°ngulo amarillo que indica que la conexi√≥n va a tempdb, veo por qu√© sucedi√≥ esto: si hay m√°s datos que memoria disponible, es poco lo que se puede hacer, pero si la memoria asignada parece irrazonablemente peque√±a, esto puede significar que Probablemente tenemos un problema m√°s con las estad√≠sticas que conduce a estimaciones demasiado bajas del optimizador de SQL Server. </li></ul></li></ul><br><p>  Gracias por leer el art√≠culo.  Tambi√©n te puede gustar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi Twitter</a> . </p><br><p>  Cubrimos este tema en una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lecci√≥n abierta</a> anterior.  Esperando sus comentarios! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459314/">https://habr.com/ru/post/459314/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459304/index.html">Bypass de trampa angular y ahorro de tiempo</a></li>
<li><a href="../459306/index.html">Representaci√≥n del servidor en un entorno sin servidor</a></li>
<li><a href="../459308/index.html">¬øEl SEO no funciona en 2019?</a></li>
<li><a href="../459310/index.html">Pruebe las herramientas de automatizaci√≥n o el probador de esteroides m√≥vil</a></li>
<li><a href="../459312/index.html">Querida Agile, estoy harta de fingir</a></li>
<li><a href="../459316/index.html">Hydra 2019: transmisi√≥n gratuita de la primera sala y un poco sobre lo que ser√° en la conferencia</a></li>
<li><a href="../459318/index.html">TypeScript y sprints cortos. C√≥mo hicimos la herramienta de variaci√≥n de entrevista frontal</a></li>
<li><a href="../459320/index.html">Operador Kubernetes en Python sin frameworks y SDK</a></li>
<li><a href="../459322/index.html">Editorial Peter. Venta de verano</a></li>
<li><a href="../459326/index.html">Autoescalado y gesti√≥n de recursos en Kubernetes (revisi√≥n e informe de video)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>