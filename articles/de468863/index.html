<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíΩ ‚úä üï∑Ô∏è Internals Go: Wrap-Loop-Variablen werden geschlossen ‚ÜòÔ∏è üë®üèø‚ÄçüöÄ üôÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute habe ich beschlossen, f√ºr Sie einen kurzen Artikel √ºber die Innenseiten der Implementierung der sogenannten Verschl√ºsse oder Verschl√ºsse zu √ºber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Internals Go: Wrap-Loop-Variablen werden geschlossen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468863/"><p><img src="https://habrastorage.org/webt/a2/v0/es/a2v0es8qfgkdntuzeattfznxanq.jpeg"></p><br><p>  <em>Heute habe ich beschlossen, f√ºr Sie einen kurzen Artikel √ºber die Innenseiten der Implementierung der sogenannten Verschl√ºsse oder Verschl√ºsse zu √ºbersetzen.</em>  <em>Au√üerdem erfahren Sie, wie Go in verschiedenen F√§llen automatisch ermittelt, ob ein Zeiger / Link oder ein Wert verwendet werden soll.</em>  <em>Durch das Verstehen dieser Dinge werden Fehler vermieden.</em>  <em>Und es ist nur so, dass all diese Innereien verdammt interessant sind, denke ich!</em> </p><br><p>  <em>Und ich m√∂chte Sie auch zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Golang Conf 2019</a> einladen, der am 7. Oktober in Moskau stattfinden wird.</em>  <em>Ich bin Mitglied des Ausschusses f√ºr Konferenzprogramme, und meine Kollegen und ich haben viele gleicherma√üen harte und sehr, sehr interessante Berichte ausgew√§hlt.</em>  <em>Was ich liebe!</em> </p><br><p>  <em>Unter dem Schnitt gebe ich das Wort an den Autor weiter.</em> </p><a name="habracut"></a><br><br><p>  Im Go-Wiki gibt es eine Seite mit dem Titel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">H√§ufige Fehler"</a> .  Seltsamerweise gibt es nur ein Beispiel: Missbrauch von Schleifenvariablen mit Goroutinen: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(val) }() }</code> </pre> <br><p>  Dieser Code gibt den letzten Wert aus dem Array von Werten len (Werte) mal aus.  Das Korrigieren des Codes ist sehr einfach: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// assume the type of each value is string for _, val := range values { go func(val string) { fmt.Println(val) }(val) }</span></span></code> </pre> <br><p>  Dieses Beispiel reicht aus, um das Problem zu verstehen und nie wieder einen Fehler zu machen.  Wenn Sie jedoch die Implementierungsdetails kennen m√∂chten, erhalten Sie in diesem Artikel ein tiefes Verst√§ndnis sowohl des Problems als auch der L√∂sung. </p><br><h1 id="bazovye-veschi-peredacha-po-znacheniyu-i-peredacha-po-ssylke">  Grundlegende Dinge: Wert√ºbergabe und Referenz√ºbergabe </h1><br><p>  In Go gibt es einen Unterschied bei der √úbergabe von Objekten nach Wert und Referenz [1].  Beginnen wir mit <strong>Beispiel 1</strong> [2]: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyval(i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre><br><p>  H√∂chstwahrscheinlich hat niemand Zweifel daran, dass das Ergebnis Werte von 0 bis 4 anzeigt. Wahrscheinlich in einer zuf√§lligen Reihenfolge. </p><br><p>  Schauen wir uns <strong>Beispiel 2 an</strong> . </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(*n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyref(&amp;i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Als Ergebnis wird Folgendes angezeigt: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Wenn wir verstehen, warum das Ergebnis genau das ist, erhalten wir bereits 80% des Verst√§ndnisses der Essenz des Problems.  Nehmen wir uns daher etwas Zeit, um die Gr√ºnde zu finden. </p><br><p>  Und die Antwort ist genau dort in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Go-Sprachspezifikation</a> .  Die Spezifikation lautet: </p><br><blockquote>  In der Initialisierungsanweisung deklarierte Variablen werden in jeder Schleife wiederverwendet. </blockquote><p>  Dies bedeutet, dass beim Ausf√ºhren des Programms nur ein Objekt oder Speicher f√ºr die Variable i vorhanden ist und nicht f√ºr jeden Zyklus ein neues erstellt wird.  Dieses Objekt nimmt bei jeder Iteration einen neuen Wert an. </p><br><p>  Schauen wir uns den Unterschied im generierten Maschinencode [3] f√ºr die Schleife in den Beispielen 1 und 2 an. Beginnen wir mit Beispiel 1. </p><br><pre> <code class="plaintext hljs">0x0026 00038 (go-func-byval.go:14) MOVL $8, (SP) 0x002d 00045 (go-func-byval.go:14) LEAQ "".foobyval¬∑f(SB), CX 0x0034 00052 (go-func-byval.go:14) MOVQ CX, 8(SP) 0x0039 00057 (go-func-byval.go:14) MOVQ AX, 16(SP) 0x003e 00062 (go-func-byval.go:14) CALL runtime.newproc(SB) 0x0043 00067 (go-func-byval.go:13) MOVQ "".i+24(SP), AX 0x0048 00072 (go-func-byval.go:13) INCQ AX 0x004b 00075 (go-func-byval.go:13) CMPQ AX, $5 0x004f 00079 (go-func-byval.go:13) JLT 33</code> </pre> <br><p>  Die Go-Anweisung wird zum Aufruf der Funktion runtime.newproc.  Die Mechanik dieses Prozesses ist sehr interessant, aber lassen wir dies f√ºr den n√§chsten Artikel.  Jetzt interessiert uns mehr, was mit der Variablen i passiert.  Es wird im AX-Register gespeichert, das dann als Wert durch den Stapel an die foobyval-Funktion [4] als Argument √ºbergeben wird.  "Nach Wert" sieht in diesem Fall so aus, als w√ºrde der Wert des AX-Registers auf den Stapel kopiert.  Und das √Ñndern der AX in der Zukunft hat keinen Einfluss darauf, was an die Foobyval-Funktion √ºbergeben wird. </p><br><p>  Und so sieht Beispiel 2 aus: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-func-byref.go:14) LEAQ "".foobyref¬∑f(SB), CX 0x0047 00071 (go-func-byref.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-func-byref.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-func-byref.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-func-byref.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-func-byref.go:13) INCQ (AX) 0x005e 00094 (go-func-byref.go:13) CMPQ (AX), $5 0x0062 00098 (go-func-byref.go:13) JLT 57</code> </pre> <br><p>  Der Code ist sehr √§hnlich - mit nur einem, aber sehr wichtigen Unterschied.  Jetzt ist in AX die Adresse i und nicht ihr Wert.  Beachten Sie auch, dass Inkrement und Vergleich f√ºr die Schleife auf (AX) und nicht auf AX erfolgen.  Und wenn wir dann AX auf den Stapel legen, √ºbergeben wir, wie sich herausstellt, die Adresse i an die Funktion.  Die √Ñnderung (AX) wird auf diese Weise auch in Goroutine gesehen. </p><br><p>  Keine √úberraschungen.  Am Ende √ºbergeben wir einen Zeiger auf eine Zahl in der Funktion foobyref. <br>  W√§hrend des Betriebs endet der Zyklus schneller, als eine der erstellten Goroutinen zu arbeiten beginnt.  Wenn sie anfangen zu arbeiten, haben sie einen Zeiger auf dieselbe Variable i und nicht auf eine Kopie.  Und was ist der Wert von i in diesem Moment?  Der Wert ist 5. Der Wert, bei dem der Zyklus gestoppt wurde.  Und deshalb leiten alle Goroutinen 5 ab. </p><br><h1 id="metody-so-znacheniem-vs-metody-s-ukazatelem">  Methoden mit einem Wert VS Methoden mit einem Zeiger </h1><br><p>  Ein √§hnliches Verhalten kann beim Erstellen von Goroutinen beobachtet werden, die Methoden aufrufen.  Dies wird durch dieselbe Wiki-Seite angezeigt.  Schauen Sie sich <strong>Beispiel 3 an</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  In diesem Beispiel werden die Elemente des ms-Arrays angezeigt.  In zuf√§lliger Reihenfolge, wie wir erwartet hatten.  Ein sehr √§hnliches <strong>Beispiel 4</strong> verwendet eine Zeigermethode f√ºr die Show-Methode: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi *MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(*mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Versuchen Sie zu erraten, wie die Schlussfolgerung aussehen wird: 90, f√ºnfmal gedruckt.  Der Grund ist der gleiche wie im einfacheren Beispiel 2. Hier ist das Problem aufgrund des syntaktischen Zuckers in Go bei Verwendung von Zeigermethoden weniger auff√§llig.  Wenn wir in den Beispielen beim Wechsel von Beispiel 1 zu Beispiel 2 i in &amp; i ge√§ndert haben, sieht der Aufruf hier gleich aus!  m.Show () in beiden Beispielen, und das Verhalten ist unterschiedlich. </p><br><p>  Es scheint mir keine sehr gl√ºckliche Kombination aus zwei Go-Funktionen zu sein.  Nichts an der Stelle des Anrufs weist auf eine √úbertragung als Referenz hin.  Und Sie m√ºssen sich die Implementierung der Show-Methode ansehen, um genau zu sehen, wie der Aufruf abl√§uft (und die Methode kann sich nat√ºrlich in einer v√∂llig anderen Datei oder einem anderen Paket befinden). </p><br><p>  In den meisten F√§llen ist diese Funktion n√ºtzlich.  Wir schreiben saubereren Code.  Das √úbergeben von Referenzen f√ºhrt hier jedoch zu unerwarteten Effekten. </p><br><h1 id="zamykaniya">  Kurzschl√ºsse </h1><br><p>  Endlich kommen wir zu den Schlie√üungen.  Schauen wir uns <strong>Beispiel 5 an</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(i) }() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Er wird folgendes drucken: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Und das trotz der Tatsache, dass ich im Abschluss als Wert an foobyval √ºbergeben werde.  √Ñhnlich wie in Beispiel 1. Aber warum?  Schauen wir uns die Assembler-Loop-Ansicht an: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-closure.go:14) LEAQ "".main.func1¬∑f(SB), CX 0x0047 00071 (go-closure.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-closure.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-closure.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-closure.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-closure.go:13) INCQ (AX) 0x005e 00094 (go-closure.go:13) CMPQ (AX), $5 0x0062 00098 (go-closure.go:13) JLT 57</code> </pre> <br><p>  Der Code ist Beispiel 2 sehr √§hnlich: Beachten Sie, dass i durch eine Adresse im AX-Register dargestellt wird.  Das hei√üt, wir √ºbergeben i als Referenz.  Und das trotz der Tatsache, dass Foobyval genannt wird.  Der Hauptteil der Schleife ruft die Funktion mit runtime.newproc auf, aber woher kommt diese Funktion? </p><br><p>  Func1 wird vom Compiler erstellt und ist ein Abschluss.  Der Compiler hat den Abschlusscode als separate Funktion zugewiesen und ruft ihn von main auf.  Das Hauptproblem bei dieser Zuordnung ist der Umgang mit Variablen, die von Closures verwendet werden, aber eindeutig keine Argumente sind. </p><br><p>  So sieht der K√∂rper von func1 aus: </p><br><pre> <code class="plaintext hljs">0x0000 00000 (go-closure.go:14) MOVQ (TLS), CX 0x0009 00009 (go-closure.go:14) CMPQ SP, 16(CX) 0x000d 00013 (go-closure.go:14) JLS 56 0x000f 00015 (go-closure.go:14) SUBQ $16, SP 0x0013 00019 (go-closure.go:14) MOVQ BP, 8(SP) 0x0018 00024 (go-closure.go:14) LEAQ 8(SP), BP 0x001d 00029 (go-closure.go:15) MOVQ "".&amp;i+24(SP), AX 0x0022 00034 (go-closure.go:15) MOVQ (AX), AX 0x0025 00037 (go-closure.go:15) MOVQ AX, (SP) 0x0029 00041 (go-closure.go:15) CALL "".foobyval(SB) 0x002e 00046 (go-closure.go:16) MOVQ 8(SP), BP 0x0033 00051 (go-closure.go:16) ADDQ $16, SP 0x0037 00055 (go-closure.go:16) RET</code> </pre> <br><p>  Es ist hier interessant, dass die Funktion ein Argument in 24 (SP) hat, das ein Zeiger auf int ist: Schauen Sie sich die Zeile MOVQ (AX), AX an, die einen Wert annimmt, bevor Sie ihn an foobyval √ºbergeben.  Tats√§chlich sieht func1 ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { foobyval(*i) }    main   - : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> func1(&amp;i) }</code> </pre><br><p>  Erhielt das √Ñquivalent von Beispiel 2, und dies erkl√§rt die Schlussfolgerung.  In der Fachsprache w√ºrden wir sagen, dass i eine freie Variable innerhalb eines Abschlusses ist und solche Variablen durch Referenz in Go erfasst werden. </p><br><p>  Aber ist das immer so?  √úberraschenderweise lautet die Antwort nein.  In einigen F√§llen werden freie Variablen nach Wert erfasst.  Hier ist eine Variation unseres Beispiels: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { ii := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(ii) }() }</code> </pre> <br><p>  In diesem Beispiel werden 0, 1, 2, 3, 4 in zuf√§lliger Reihenfolge ausgegeben.  Aber warum unterscheidet sich das Verhalten hier von Beispiel 5? </p><br><p>  Es stellt sich heraus, dass dieses Verhalten ein Artefakt der Heuristik ist, die der Go-Compiler verwendet, wenn er mit Closures arbeitet. </p><br><h1 id="smotrim-pod-kapot">  Wir schauen unter die Haube </h1><br><p>  Wenn Sie mit der Architektur des Go-Compilers nicht vertraut sind, empfehlen wir Ihnen, meine fr√ºhen Artikel zu diesem Thema zu lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> . </p><br><p>  Der spezifische (im Gegensatz zum abstrakten) Syntaxbaum, der durch Parsen des Codes erhalten wird, sieht folgenderma√üen aus: </p><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.CallStmt { . Tok: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> . Call: *syntax.CallExpr { . . Fun: *syntax.FuncLit { . . . Type: *syntax.FuncType { . . . . ParamList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . . ResultList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . } . . . Body: *syntax.BlockStmt { . . . . List: []syntax.Stmt (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.ExprStmt { . . . . . . X: *syntax.CallExpr { . . . . . . . Fun: foobyval @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span> . . . . . . . ArgList: []syntax.Expr (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: i @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> . . . . . . . } . . . . . . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . . . . . . } . . . . . } . . . . } . . . . Rbrace: syntax.Pos {} . . . } . . } . . ArgList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . } }</code> </pre> <br><p>  Die aufgerufene Funktion wird durch den FuncLit-Knoten dargestellt, eine konstante Funktion.  Wenn dieser Baum in AST (abstrakter Syntaxbaum) konvertiert wird, wird diese Konstantenfunktion als separate hervorgehoben.  Dies geschieht in der Methode noder.funcLit, die sich in gc / Closure.go befindet. </p><br><p>  Dann schlie√üt der Tipe Checker die Transformation ab und wir erhalten die folgende Darstellung f√ºr die Funktion im AST: </p><br><pre> <code class="go hljs">main.func1: . DCLFUNC l(<span class="hljs-number"><span class="hljs-number">14</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) FUNC-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(8)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PFUNC)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">il</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PAUTOHEAP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  Beachten Sie, dass der an foobyval √ºbergebene Wert NAME-main.i ist, dh wir verweisen explizit auf die Variable aus der Funktion, die den Abschluss umschlie√üt. </p><br><p>  In dieser Phase wird die Compiler-Phase, Capturevars genannt, dh "Capturing-Variablen", in Betrieb genommen.  Der Zweck besteht darin, zu entscheiden, wie "geschlossene Variablen" (dh freie Variablen, die in Schlie√üungen verwendet werden) erfasst werden sollen.  Hier ist ein Kommentar der entsprechenden Compilerfunktion, der auch die Heuristik beschreibt: </p><br><p>  // capturevars wird nach allen Typpr√ºfungen in einer separaten Phase aufgerufen. <br>  // Es wird entschieden, ob die Variable nach Wert oder nach Referenz erfasst werden soll. <br>  // Wir verwenden die Erfassung nach Wert f√ºr Werte &lt;= 128 Bytes, deren Wert nach der Erfassung nicht mehr ge√§ndert wird (im Wesentlichen Konstanten). </p><br><p>  Wenn in Beispiel 5 capturevars aufgerufen wird, entscheidet es, dass die Schleifenvariable i als Referenz erfasst werden soll, und f√ºgt ihr das entsprechende addrtaken-Flag hinzu.  Dies ist in der AST-Ausgabe zu sehen: </p><br><pre> <code class="go hljs">FOR l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) . LT l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> . . NAME-main.ia(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) g(<span class="hljs-number"><span class="hljs-number">1</span></span>) l(<span class="hljs-number"><span class="hljs-number">13</span></span>) x(<span class="hljs-number"><span class="hljs-number">0</span></span>) class(PAUTOHEAP) esc(h) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) addrtaken assigned used <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br><p>  F√ºr die Schleifenvariable funktioniert die Auswahlheuristik "Nach Wert" nicht, da die Variable ihren Wert nach dem Aufruf √§ndert (beachten Sie das Zitat aus der Spezifikation, dass die Schleifenvariable bei jeder Iteration wiederverwendet wird).  Daher wird die Variable i als Referenz erfasst. <br>  In dieser Variation unseres Beispiels, in der wir ii: = i haben, wird ii nicht mehr verwendet und wird daher durch den Wert erfasst [5]. </p><br><p>  Wir sehen also ein beeindruckendes Beispiel daf√ºr, wie zwei verschiedene Merkmale einer Sprache auf unerwartete Weise √ºberlappt werden.  Anstatt bei jeder Iteration der Schleife eine neue Variable zu verwenden, verwendet Go dieselbe wieder.  Dies f√ºhrt wiederum zur Ausl√∂sung von Heuristiken und zur Auswahl der Erfassung als Referenz, und dies f√ºhrt zu einem unerwarteten Ergebnis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In den Go-FAQ</a> hei√üt es, dass dieses Verhalten m√∂glicherweise ein Entwurfsfehler ist. </p><br><blockquote>  Dieses Verhalten (keine neue Variable verwenden) ist wahrscheinlich ein Fehler beim Entwerfen einer Sprache.  Vielleicht werden wir es in zuk√ºnftigen Versionen beheben, aber aufgrund der Abw√§rtskompatibilit√§t k√∂nnen wir in Go Version 1 nichts tun. </blockquote><p>  Wenn Sie sich des Problems bewusst sind, werden Sie h√∂chstwahrscheinlich nicht auf diesen Rechen treten.  Beachten Sie jedoch, dass freie Variablen immer als Referenz erfasst werden k√∂nnen.  Um Fehler zu vermeiden, stellen Sie sicher, dass bei Verwendung von goroutin nur schreibgesch√ºtzte Variablen erfasst werden.  Dies ist auch aufgrund m√∂glicher Probleme mit Datenfl√ºgen wichtig. </p><br><hr><br><p>  [1] Einige Leser haben festgestellt, dass es in Go streng genommen kein Konzept f√ºr das ‚Äû√úbergeben als Referenz‚Äú gibt, da alles als Wert √ºbergeben wird, einschlie√ülich Zeigern.  Wenn Sie in diesem Artikel "Referenz√ºbergabe" sehen, meine ich "Adresse √ºbergeben" und es ist in einigen F√§llen explizit (z. B. √úbergabe von &amp; n an eine Funktion, die * int erwartet) und in einigen F√§llen implizit, wie in sp√§teren F√§llen Teile des Artikels. </p><br><p>  [2] Im Folgenden verwende ich die Zeit. Schlafen ist eine schnelle und schmutzige Methode, um auf den Abschluss aller Goroutinen zu warten.  Ohne dies endet main, bevor die Goroutinen zu arbeiten beginnen.  Der richtige Weg, dies zu tun, w√§re, etwas wie WaitGroup oder done channel zu verwenden. </p><br><p>  [3] Die Assembler-Darstellung f√ºr alle Beispiele in diesem Artikel wurde mit dem Befehl go tool compile -l -S erhalten.  Das Flag -l deaktiviert das Inlining von Funktionen und macht Assembler-Code besser lesbar. </p><br><p>  [4] Foobyval wird nicht direkt aufgerufen, da der Anruf durch go geht.  Stattdessen wird die Adresse als zweites Argument (16 (SP)) an die Funktion runtime.newproc √ºbergeben, und das Argument an foobyval (in diesem Fall i) geht den Stapel hoch. </p><br><p>  [5] Addiere als √úbung ii = 10 als letzte Zeile der for-Schleife (nach dem Aufruf von go).  Was war Ihre Schlussfolgerung?  Warum? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468863/">https://habr.com/ru/post/de468863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468849/index.html">Unbekanntes Prozessor-Reverse Engineering in einem einzigen Programm</a></li>
<li><a href="../de468851/index.html">Implementierung der Animation in React Native</a></li>
<li><a href="../de468853/index.html">Die Geschichte einer erfolgreichen Anwendung von SPR in einem Legacy-Projekt</a></li>
<li><a href="../de468859/index.html">‚ÄûRouter zum Pumpen‚Äú: TP-Link-Ger√§teoptimierung f√ºr Internetprovider</a></li>
<li><a href="../de468861/index.html">Positive Technologien erwecken 'Hackable City' in The Standoff Cyberbattle auf der HITB + CyberWeek zum Leben</a></li>
<li><a href="../de468873/index.html">Ein privater Zug, der einst die Bequemlichkeit ruinierte</a></li>
<li><a href="../de468875/index.html">Collapsed Hashrate and Depreciation Episode</a></li>
<li><a href="../de468877/index.html">Ein alternativer Ansatz zum Anzeigen der Last w√§hrend der Paginierung</a></li>
<li><a href="../de468879/index.html">Zu Beginn des Computerspeichers</a></li>
<li><a href="../de468883/index.html">Natalia Kozlovskaya: ‚ÄûWen interessiert es, wer OpenStreetMap zeichnet: M√§nner oder Frauen?‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>