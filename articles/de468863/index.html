<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💽 ✊ 🕷️ Internals Go: Wrap-Loop-Variablen werden geschlossen ↘️ 👨🏿‍🚀 🙄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute habe ich beschlossen, für Sie einen kurzen Artikel über die Innenseiten der Implementierung der sogenannten Verschlüsse oder Verschlüsse zu über...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Internals Go: Wrap-Loop-Variablen werden geschlossen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468863/"><p><img src="https://habrastorage.org/webt/a2/v0/es/a2v0es8qfgkdntuzeattfznxanq.jpeg"></p><br><p>  <em>Heute habe ich beschlossen, für Sie einen kurzen Artikel über die Innenseiten der Implementierung der sogenannten Verschlüsse oder Verschlüsse zu übersetzen.</em>  <em>Außerdem erfahren Sie, wie Go in verschiedenen Fällen automatisch ermittelt, ob ein Zeiger / Link oder ein Wert verwendet werden soll.</em>  <em>Durch das Verstehen dieser Dinge werden Fehler vermieden.</em>  <em>Und es ist nur so, dass all diese Innereien verdammt interessant sind, denke ich!</em> </p><br><p>  <em>Und ich möchte Sie auch zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Golang Conf 2019</a> einladen, der am 7. Oktober in Moskau stattfinden wird.</em>  <em>Ich bin Mitglied des Ausschusses für Konferenzprogramme, und meine Kollegen und ich haben viele gleichermaßen harte und sehr, sehr interessante Berichte ausgewählt.</em>  <em>Was ich liebe!</em> </p><br><p>  <em>Unter dem Schnitt gebe ich das Wort an den Autor weiter.</em> </p><a name="habracut"></a><br><br><p>  Im Go-Wiki gibt es eine Seite mit dem Titel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Häufige Fehler"</a> .  Seltsamerweise gibt es nur ein Beispiel: Missbrauch von Schleifenvariablen mit Goroutinen: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(val) }() }</code> </pre> <br><p>  Dieser Code gibt den letzten Wert aus dem Array von Werten len (Werte) mal aus.  Das Korrigieren des Codes ist sehr einfach: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// assume the type of each value is string for _, val := range values { go func(val string) { fmt.Println(val) }(val) }</span></span></code> </pre> <br><p>  Dieses Beispiel reicht aus, um das Problem zu verstehen und nie wieder einen Fehler zu machen.  Wenn Sie jedoch die Implementierungsdetails kennen möchten, erhalten Sie in diesem Artikel ein tiefes Verständnis sowohl des Problems als auch der Lösung. </p><br><h1 id="bazovye-veschi-peredacha-po-znacheniyu-i-peredacha-po-ssylke">  Grundlegende Dinge: Wertübergabe und Referenzübergabe </h1><br><p>  In Go gibt es einen Unterschied bei der Übergabe von Objekten nach Wert und Referenz [1].  Beginnen wir mit <strong>Beispiel 1</strong> [2]: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyval(i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre><br><p>  Höchstwahrscheinlich hat niemand Zweifel daran, dass das Ergebnis Werte von 0 bis 4 anzeigt. Wahrscheinlich in einer zufälligen Reihenfolge. </p><br><p>  Schauen wir uns <strong>Beispiel 2 an</strong> . </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(*n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyref(&amp;i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Als Ergebnis wird Folgendes angezeigt: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Wenn wir verstehen, warum das Ergebnis genau das ist, erhalten wir bereits 80% des Verständnisses der Essenz des Problems.  Nehmen wir uns daher etwas Zeit, um die Gründe zu finden. </p><br><p>  Und die Antwort ist genau dort in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Go-Sprachspezifikation</a> .  Die Spezifikation lautet: </p><br><blockquote>  In der Initialisierungsanweisung deklarierte Variablen werden in jeder Schleife wiederverwendet. </blockquote><p>  Dies bedeutet, dass beim Ausführen des Programms nur ein Objekt oder Speicher für die Variable i vorhanden ist und nicht für jeden Zyklus ein neues erstellt wird.  Dieses Objekt nimmt bei jeder Iteration einen neuen Wert an. </p><br><p>  Schauen wir uns den Unterschied im generierten Maschinencode [3] für die Schleife in den Beispielen 1 und 2 an. Beginnen wir mit Beispiel 1. </p><br><pre> <code class="plaintext hljs">0x0026 00038 (go-func-byval.go:14) MOVL $8, (SP) 0x002d 00045 (go-func-byval.go:14) LEAQ "".foobyval·f(SB), CX 0x0034 00052 (go-func-byval.go:14) MOVQ CX, 8(SP) 0x0039 00057 (go-func-byval.go:14) MOVQ AX, 16(SP) 0x003e 00062 (go-func-byval.go:14) CALL runtime.newproc(SB) 0x0043 00067 (go-func-byval.go:13) MOVQ "".i+24(SP), AX 0x0048 00072 (go-func-byval.go:13) INCQ AX 0x004b 00075 (go-func-byval.go:13) CMPQ AX, $5 0x004f 00079 (go-func-byval.go:13) JLT 33</code> </pre> <br><p>  Die Go-Anweisung wird zum Aufruf der Funktion runtime.newproc.  Die Mechanik dieses Prozesses ist sehr interessant, aber lassen wir dies für den nächsten Artikel.  Jetzt interessiert uns mehr, was mit der Variablen i passiert.  Es wird im AX-Register gespeichert, das dann als Wert durch den Stapel an die foobyval-Funktion [4] als Argument übergeben wird.  "Nach Wert" sieht in diesem Fall so aus, als würde der Wert des AX-Registers auf den Stapel kopiert.  Und das Ändern der AX in der Zukunft hat keinen Einfluss darauf, was an die Foobyval-Funktion übergeben wird. </p><br><p>  Und so sieht Beispiel 2 aus: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-func-byref.go:14) LEAQ "".foobyref·f(SB), CX 0x0047 00071 (go-func-byref.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-func-byref.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-func-byref.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-func-byref.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-func-byref.go:13) INCQ (AX) 0x005e 00094 (go-func-byref.go:13) CMPQ (AX), $5 0x0062 00098 (go-func-byref.go:13) JLT 57</code> </pre> <br><p>  Der Code ist sehr ähnlich - mit nur einem, aber sehr wichtigen Unterschied.  Jetzt ist in AX die Adresse i und nicht ihr Wert.  Beachten Sie auch, dass Inkrement und Vergleich für die Schleife auf (AX) und nicht auf AX erfolgen.  Und wenn wir dann AX auf den Stapel legen, übergeben wir, wie sich herausstellt, die Adresse i an die Funktion.  Die Änderung (AX) wird auf diese Weise auch in Goroutine gesehen. </p><br><p>  Keine Überraschungen.  Am Ende übergeben wir einen Zeiger auf eine Zahl in der Funktion foobyref. <br>  Während des Betriebs endet der Zyklus schneller, als eine der erstellten Goroutinen zu arbeiten beginnt.  Wenn sie anfangen zu arbeiten, haben sie einen Zeiger auf dieselbe Variable i und nicht auf eine Kopie.  Und was ist der Wert von i in diesem Moment?  Der Wert ist 5. Der Wert, bei dem der Zyklus gestoppt wurde.  Und deshalb leiten alle Goroutinen 5 ab. </p><br><h1 id="metody-so-znacheniem-vs-metody-s-ukazatelem">  Methoden mit einem Wert VS Methoden mit einem Zeiger </h1><br><p>  Ein ähnliches Verhalten kann beim Erstellen von Goroutinen beobachtet werden, die Methoden aufrufen.  Dies wird durch dieselbe Wiki-Seite angezeigt.  Schauen Sie sich <strong>Beispiel 3 an</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  In diesem Beispiel werden die Elemente des ms-Arrays angezeigt.  In zufälliger Reihenfolge, wie wir erwartet hatten.  Ein sehr ähnliches <strong>Beispiel 4</strong> verwendet eine Zeigermethode für die Show-Methode: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi *MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(*mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Versuchen Sie zu erraten, wie die Schlussfolgerung aussehen wird: 90, fünfmal gedruckt.  Der Grund ist der gleiche wie im einfacheren Beispiel 2. Hier ist das Problem aufgrund des syntaktischen Zuckers in Go bei Verwendung von Zeigermethoden weniger auffällig.  Wenn wir in den Beispielen beim Wechsel von Beispiel 1 zu Beispiel 2 i in &amp; i geändert haben, sieht der Aufruf hier gleich aus!  m.Show () in beiden Beispielen, und das Verhalten ist unterschiedlich. </p><br><p>  Es scheint mir keine sehr glückliche Kombination aus zwei Go-Funktionen zu sein.  Nichts an der Stelle des Anrufs weist auf eine Übertragung als Referenz hin.  Und Sie müssen sich die Implementierung der Show-Methode ansehen, um genau zu sehen, wie der Aufruf abläuft (und die Methode kann sich natürlich in einer völlig anderen Datei oder einem anderen Paket befinden). </p><br><p>  In den meisten Fällen ist diese Funktion nützlich.  Wir schreiben saubereren Code.  Das Übergeben von Referenzen führt hier jedoch zu unerwarteten Effekten. </p><br><h1 id="zamykaniya">  Kurzschlüsse </h1><br><p>  Endlich kommen wir zu den Schließungen.  Schauen wir uns <strong>Beispiel 5 an</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(i) }() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Er wird folgendes drucken: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Und das trotz der Tatsache, dass ich im Abschluss als Wert an foobyval übergeben werde.  Ähnlich wie in Beispiel 1. Aber warum?  Schauen wir uns die Assembler-Loop-Ansicht an: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-closure.go:14) LEAQ "".main.func1·f(SB), CX 0x0047 00071 (go-closure.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-closure.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-closure.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-closure.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-closure.go:13) INCQ (AX) 0x005e 00094 (go-closure.go:13) CMPQ (AX), $5 0x0062 00098 (go-closure.go:13) JLT 57</code> </pre> <br><p>  Der Code ist Beispiel 2 sehr ähnlich: Beachten Sie, dass i durch eine Adresse im AX-Register dargestellt wird.  Das heißt, wir übergeben i als Referenz.  Und das trotz der Tatsache, dass Foobyval genannt wird.  Der Hauptteil der Schleife ruft die Funktion mit runtime.newproc auf, aber woher kommt diese Funktion? </p><br><p>  Func1 wird vom Compiler erstellt und ist ein Abschluss.  Der Compiler hat den Abschlusscode als separate Funktion zugewiesen und ruft ihn von main auf.  Das Hauptproblem bei dieser Zuordnung ist der Umgang mit Variablen, die von Closures verwendet werden, aber eindeutig keine Argumente sind. </p><br><p>  So sieht der Körper von func1 aus: </p><br><pre> <code class="plaintext hljs">0x0000 00000 (go-closure.go:14) MOVQ (TLS), CX 0x0009 00009 (go-closure.go:14) CMPQ SP, 16(CX) 0x000d 00013 (go-closure.go:14) JLS 56 0x000f 00015 (go-closure.go:14) SUBQ $16, SP 0x0013 00019 (go-closure.go:14) MOVQ BP, 8(SP) 0x0018 00024 (go-closure.go:14) LEAQ 8(SP), BP 0x001d 00029 (go-closure.go:15) MOVQ "".&amp;i+24(SP), AX 0x0022 00034 (go-closure.go:15) MOVQ (AX), AX 0x0025 00037 (go-closure.go:15) MOVQ AX, (SP) 0x0029 00041 (go-closure.go:15) CALL "".foobyval(SB) 0x002e 00046 (go-closure.go:16) MOVQ 8(SP), BP 0x0033 00051 (go-closure.go:16) ADDQ $16, SP 0x0037 00055 (go-closure.go:16) RET</code> </pre> <br><p>  Es ist hier interessant, dass die Funktion ein Argument in 24 (SP) hat, das ein Zeiger auf int ist: Schauen Sie sich die Zeile MOVQ (AX), AX an, die einen Wert annimmt, bevor Sie ihn an foobyval übergeben.  Tatsächlich sieht func1 ungefähr so ​​aus: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { foobyval(*i) }    main   - : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> func1(&amp;i) }</code> </pre><br><p>  Erhielt das Äquivalent von Beispiel 2, und dies erklärt die Schlussfolgerung.  In der Fachsprache würden wir sagen, dass i eine freie Variable innerhalb eines Abschlusses ist und solche Variablen durch Referenz in Go erfasst werden. </p><br><p>  Aber ist das immer so?  Überraschenderweise lautet die Antwort nein.  In einigen Fällen werden freie Variablen nach Wert erfasst.  Hier ist eine Variation unseres Beispiels: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { ii := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(ii) }() }</code> </pre> <br><p>  In diesem Beispiel werden 0, 1, 2, 3, 4 in zufälliger Reihenfolge ausgegeben.  Aber warum unterscheidet sich das Verhalten hier von Beispiel 5? </p><br><p>  Es stellt sich heraus, dass dieses Verhalten ein Artefakt der Heuristik ist, die der Go-Compiler verwendet, wenn er mit Closures arbeitet. </p><br><h1 id="smotrim-pod-kapot">  Wir schauen unter die Haube </h1><br><p>  Wenn Sie mit der Architektur des Go-Compilers nicht vertraut sind, empfehlen wir Ihnen, meine frühen Artikel zu diesem Thema zu lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> . </p><br><p>  Der spezifische (im Gegensatz zum abstrakten) Syntaxbaum, der durch Parsen des Codes erhalten wird, sieht folgendermaßen aus: </p><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.CallStmt { . Tok: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> . Call: *syntax.CallExpr { . . Fun: *syntax.FuncLit { . . . Type: *syntax.FuncType { . . . . ParamList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . . ResultList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . } . . . Body: *syntax.BlockStmt { . . . . List: []syntax.Stmt (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.ExprStmt { . . . . . . X: *syntax.CallExpr { . . . . . . . Fun: foobyval @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span> . . . . . . . ArgList: []syntax.Expr (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: i @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> . . . . . . . } . . . . . . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . . . . . . } . . . . . } . . . . } . . . . Rbrace: syntax.Pos {} . . . } . . } . . ArgList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . } }</code> </pre> <br><p>  Die aufgerufene Funktion wird durch den FuncLit-Knoten dargestellt, eine konstante Funktion.  Wenn dieser Baum in AST (abstrakter Syntaxbaum) konvertiert wird, wird diese Konstantenfunktion als separate hervorgehoben.  Dies geschieht in der Methode noder.funcLit, die sich in gc / Closure.go befindet. </p><br><p>  Dann schließt der Tipe Checker die Transformation ab und wir erhalten die folgende Darstellung für die Funktion im AST: </p><br><pre> <code class="go hljs">main.func1: . DCLFUNC l(<span class="hljs-number"><span class="hljs-number">14</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) FUNC-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(8)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PFUNC)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">il</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PAUTOHEAP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  Beachten Sie, dass der an foobyval übergebene Wert NAME-main.i ist, dh wir verweisen explizit auf die Variable aus der Funktion, die den Abschluss umschließt. </p><br><p>  In dieser Phase wird die Compiler-Phase, Capturevars genannt, dh "Capturing-Variablen", in Betrieb genommen.  Der Zweck besteht darin, zu entscheiden, wie "geschlossene Variablen" (dh freie Variablen, die in Schließungen verwendet werden) erfasst werden sollen.  Hier ist ein Kommentar der entsprechenden Compilerfunktion, der auch die Heuristik beschreibt: </p><br><p>  // capturevars wird nach allen Typprüfungen in einer separaten Phase aufgerufen. <br>  // Es wird entschieden, ob die Variable nach Wert oder nach Referenz erfasst werden soll. <br>  // Wir verwenden die Erfassung nach Wert für Werte &lt;= 128 Bytes, deren Wert nach der Erfassung nicht mehr geändert wird (im Wesentlichen Konstanten). </p><br><p>  Wenn in Beispiel 5 capturevars aufgerufen wird, entscheidet es, dass die Schleifenvariable i als Referenz erfasst werden soll, und fügt ihr das entsprechende addrtaken-Flag hinzu.  Dies ist in der AST-Ausgabe zu sehen: </p><br><pre> <code class="go hljs">FOR l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) . LT l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> . . NAME-main.ia(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) g(<span class="hljs-number"><span class="hljs-number">1</span></span>) l(<span class="hljs-number"><span class="hljs-number">13</span></span>) x(<span class="hljs-number"><span class="hljs-number">0</span></span>) class(PAUTOHEAP) esc(h) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) addrtaken assigned used <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br><p>  Für die Schleifenvariable funktioniert die Auswahlheuristik "Nach Wert" nicht, da die Variable ihren Wert nach dem Aufruf ändert (beachten Sie das Zitat aus der Spezifikation, dass die Schleifenvariable bei jeder Iteration wiederverwendet wird).  Daher wird die Variable i als Referenz erfasst. <br>  In dieser Variation unseres Beispiels, in der wir ii: = i haben, wird ii nicht mehr verwendet und wird daher durch den Wert erfasst [5]. </p><br><p>  Wir sehen also ein beeindruckendes Beispiel dafür, wie zwei verschiedene Merkmale einer Sprache auf unerwartete Weise überlappt werden.  Anstatt bei jeder Iteration der Schleife eine neue Variable zu verwenden, verwendet Go dieselbe wieder.  Dies führt wiederum zur Auslösung von Heuristiken und zur Auswahl der Erfassung als Referenz, und dies führt zu einem unerwarteten Ergebnis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In den Go-FAQ</a> heißt es, dass dieses Verhalten möglicherweise ein Entwurfsfehler ist. </p><br><blockquote>  Dieses Verhalten (keine neue Variable verwenden) ist wahrscheinlich ein Fehler beim Entwerfen einer Sprache.  Vielleicht werden wir es in zukünftigen Versionen beheben, aber aufgrund der Abwärtskompatibilität können wir in Go Version 1 nichts tun. </blockquote><p>  Wenn Sie sich des Problems bewusst sind, werden Sie höchstwahrscheinlich nicht auf diesen Rechen treten.  Beachten Sie jedoch, dass freie Variablen immer als Referenz erfasst werden können.  Um Fehler zu vermeiden, stellen Sie sicher, dass bei Verwendung von goroutin nur schreibgeschützte Variablen erfasst werden.  Dies ist auch aufgrund möglicher Probleme mit Datenflügen wichtig. </p><br><hr><br><p>  [1] Einige Leser haben festgestellt, dass es in Go streng genommen kein Konzept für das „Übergeben als Referenz“ gibt, da alles als Wert übergeben wird, einschließlich Zeigern.  Wenn Sie in diesem Artikel "Referenzübergabe" sehen, meine ich "Adresse übergeben" und es ist in einigen Fällen explizit (z. B. Übergabe von &amp; n an eine Funktion, die * int erwartet) und in einigen Fällen implizit, wie in späteren Fällen Teile des Artikels. </p><br><p>  [2] Im Folgenden verwende ich die Zeit. Schlafen ist eine schnelle und schmutzige Methode, um auf den Abschluss aller Goroutinen zu warten.  Ohne dies endet main, bevor die Goroutinen zu arbeiten beginnen.  Der richtige Weg, dies zu tun, wäre, etwas wie WaitGroup oder done channel zu verwenden. </p><br><p>  [3] Die Assembler-Darstellung für alle Beispiele in diesem Artikel wurde mit dem Befehl go tool compile -l -S erhalten.  Das Flag -l deaktiviert das Inlining von Funktionen und macht Assembler-Code besser lesbar. </p><br><p>  [4] Foobyval wird nicht direkt aufgerufen, da der Anruf durch go geht.  Stattdessen wird die Adresse als zweites Argument (16 (SP)) an die Funktion runtime.newproc übergeben, und das Argument an foobyval (in diesem Fall i) geht den Stapel hoch. </p><br><p>  [5] Addiere als Übung ii = 10 als letzte Zeile der for-Schleife (nach dem Aufruf von go).  Was war Ihre Schlussfolgerung?  Warum? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468863/">https://habr.com/ru/post/de468863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468849/index.html">Unbekanntes Prozessor-Reverse Engineering in einem einzigen Programm</a></li>
<li><a href="../de468851/index.html">Implementierung der Animation in React Native</a></li>
<li><a href="../de468853/index.html">Die Geschichte einer erfolgreichen Anwendung von SPR in einem Legacy-Projekt</a></li>
<li><a href="../de468859/index.html">„Router zum Pumpen“: TP-Link-Geräteoptimierung für Internetprovider</a></li>
<li><a href="../de468861/index.html">Positive Technologien erwecken 'Hackable City' in The Standoff Cyberbattle auf der HITB + CyberWeek zum Leben</a></li>
<li><a href="../de468873/index.html">Ein privater Zug, der einst die Bequemlichkeit ruinierte</a></li>
<li><a href="../de468875/index.html">Collapsed Hashrate and Depreciation Episode</a></li>
<li><a href="../de468877/index.html">Ein alternativer Ansatz zum Anzeigen der Last während der Paginierung</a></li>
<li><a href="../de468879/index.html">Zu Beginn des Computerspeichers</a></li>
<li><a href="../de468883/index.html">Natalia Kozlovskaya: „Wen interessiert es, wer OpenStreetMap zeichnet: Männer oder Frauen?“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>