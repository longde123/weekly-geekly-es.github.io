<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó∫Ô∏è ü§∞ üßëüèΩ‚Äçü§ù‚Äçüßëüèª Sistemas operacionais: tr√™s pe√ßas f√°ceis. Parte 5: Planejamento: fila de feedback multin√≠vel (tradu√ß√£o) üë©üèº‚Äçü§ù‚Äçüë©üèª üë©‚Äçüë©‚Äçüëß‚Äçüëß üëÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introdu√ß√£o aos sistemas operacionais 
 Ol√° Habr! Quero chamar sua aten√ß√£o para uma s√©rie de artigos - tradu√ß√µes de uma literatura interessante em minh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistemas operacionais: tr√™s pe√ßas f√°ceis. Parte 5: Planejamento: fila de feedback multin√≠vel (tradu√ß√£o)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450116/"><h1>  Introdu√ß√£o aos sistemas operacionais </h1><br>  Ol√° Habr!  Quero chamar sua aten√ß√£o para uma s√©rie de artigos - tradu√ß√µes de uma literatura interessante em minha opini√£o - OSTEP.  Este artigo discute profundamente o trabalho de sistemas operacionais semelhantes a unix, ou seja, trabalha com processos, v√°rios agendadores, mem√≥ria e outros componentes similares que comp√µem o sistema operacional moderno.  O original de todos os materiais que voc√™ pode ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Observe que a tradu√ß√£o foi feita de maneira n√£o profissional (muito livremente), mas espero ter mantido o significado geral. <br><br>  O trabalho de laborat√≥rio sobre este assunto pode ser encontrado aqui: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">minha adapta√ß√£o pessoal</a> </li></ul><br>  Outras partes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: Introdu√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: Abstra√ß√£o: o processo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: Introdu√ß√£o √† API do Processo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4: Introdu√ß√£o ao Agendador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5: MLFQ Scheduler</a> </li></ul><br>  E voc√™ pode olhar para o meu canal no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">telegrama</a> =) <br><a name="habracut"></a><br><h2>  Planejamento: fila de feedback multin√≠vel </h2><br>  Nesta palestra, falaremos sobre os problemas de desenvolver uma das abordagens mais famosas para <br>  Planejamento chamado <b>Fila de feedback de v√°rios n√≠veis</b> (MLFQ).  O agendador do MLFQ foi descrito pela primeira vez em 1962 por Fernando J. Corbat√≥ em um sistema chamado Sistema de Compartilhamento de Tempo Compat√≠vel (CTSS).  Esses trabalhos (incluindo trabalhos posteriores sobre Multics) foram posteriormente submetidos ao Pr√™mio Turing.  O agendador foi posteriormente aprimorado e adquiriu uma apar√™ncia que j√° pode ser encontrada em alguns sistemas modernos. <br><br>  O algoritmo MLFQ tenta resolver 2 problemas transversais fundamentais. <br>  <b>Primeiro</b> , ele tenta otimizar o tempo de resposta, que, como examinamos na palestra anterior, √© otimizado iniciando no in√≠cio da fila das tarefas mais curtas.  No entanto, o sistema operacional n√£o sabe quanto tempo esse ou aquele processo funcionar√°, e esse √© o conhecimento necess√°rio para a opera√ß√£o dos algoritmos SJF, STCF.  <b>Em segundo lugar</b> , o MLFQ tenta tornar o sistema responsivo aos usu√°rios (por exemplo, aqueles que est√£o sentados e olhando para a tela enquanto aguardam a conclus√£o da tarefa) e, assim, minimizar o tempo de resposta.  Infelizmente, algoritmos como o RR reduzem o tempo de resposta, mas t√™m um efeito muito ruim nas m√©tricas de tempo de resposta.  Da√≠ o nosso problema: como projetar um agendador que atenda aos nossos requisitos e, ao mesmo tempo, n√£o saiba nada sobre a natureza do processo, em geral?  Como o planejador pode aprender as caracter√≠sticas das tarefas que inicia e, assim, tomar melhores decis√µes de planejamento? <br><br>  <u>A ess√™ncia do problema: como planejar a formula√ß√£o de tarefas sem conhecimento perfeito?</u>  <u>Como desenvolver um agendador que minimiza simultaneamente o tempo de resposta para tarefas interativas e ao mesmo tempo minimiza o tempo de resposta sem saber o tempo para concluir a tarefa?</u> <br><br>  Nota: aprendendo com eventos anteriores <br><br>  A programa√ß√£o do MLFQ √© um √≥timo exemplo de sistema que aprende com eventos passados ‚Äã‚Äãpara prever o futuro.  Abordagens semelhantes s√£o frequentemente encontradas no sistema operacional (e em muitos outros ramos da ci√™ncia da computa√ß√£o, incluindo ramos de previs√£o de hardware e algoritmos de cache).  Viagens semelhantes funcionam quando as tarefas t√™m fases comportamentais e, portanto, s√£o previs√≠veis. <br><br>  No entanto, √© preciso ter cuidado com essa t√©cnica, porque as previs√µes podem facilmente ser erradas e levar o sistema a tomar decis√µes piores do que seria sem conhecimento. <br><br><h3>  MLFQ: Regras b√°sicas </h3><br>  Considere as regras b√°sicas do algoritmo MLFQ.  Embora existam v√°rias implementa√ß√µes desse algoritmo, as abordagens b√°sicas s√£o semelhantes. <br><br>  Na implementa√ß√£o que consideraremos, no MLFQ haver√° v√°rias filas separadas, cada uma com uma prioridade diferente.  A qualquer momento, uma tarefa pronta para execu√ß√£o est√° em uma fila.  O MLFQ usa prioridades para decidir qual tarefa executar, ou seja,  uma tarefa com uma prioridade mais alta (uma tarefa da fila com uma prioridade mais alta) ser√° iniciada primeiro. <br><br>  Sem d√∫vida, mais de uma tarefa pode estar em uma fila espec√≠fica, portanto elas ter√£o a mesma prioridade.  Nesse caso, o mecanismo RR ser√° usado para agendar o lan√ßamento entre essas tarefas. <br><br>  Assim, chegamos a duas regras b√°sicas para o MLFQ: <br><br><ul><li>  Regra1: Se a prioridade (A)&gt; Prioridade (B), a tarefa A for iniciada (B n√£o ser√°) </li><li>  Regra2: Se a prioridade (A) = Prioridade (B), A&amp;B s√£o iniciados usando RR </li></ul><br>  Com base no exposto, os principais elementos do planejamento do MLFQ s√£o prioridades.  Em vez de definir uma prioridade fixa para cada tarefa, o MLFQ altera sua prioridade, dependendo do comportamento observado. <br><br>  Por exemplo, se uma tarefa parar constantemente de trabalhar na CPU enquanto aguarda a entrada do teclado, o MLFQ manter√° a prioridade do processo em um n√≠vel alto, porque √© assim que o processo interativo deve funcionar.  Se, pelo contr√°rio, a tarefa usar constante e intensivamente a CPU por um longo per√≠odo, o MLFQ diminuir√° sua prioridade.  Assim, o MLFQ estudar√° o comportamento dos processos no momento de sua opera√ß√£o e usar√° o comportamento. <br><br>  Vamos desenhar um exemplo de como as filas podem parecer em algum momento e, em seguida, obtemos algo assim: <br><br><img src="https://habrastorage.org/webt/4x/ad/rr/4xadrrwfmrtn3mg-se6wgith9gm.png" alt="imagem"><br><br>  Nesse esquema, 2 processos A e B est√£o na fila com a prioridade mais alta.  O processo C est√° em algum lugar no meio e o processo D est√° no final da fila.  De acordo com as descri√ß√µes acima do algoritmo MLFQ, o planejador executar√° tarefas apenas com a maior prioridade, de acordo com o RR, e as tarefas C, D ficar√£o sem trabalho. <br><br>  Naturalmente, um instant√¢neo est√°tico n√£o fornecer√° uma imagem completa de como o MLFQ funciona. <br>  √â importante entender exatamente como a imagem muda com o tempo. <br><br><h4>  Tentativa 1: Como alterar a prioridade </h4><br>  Nesse ponto, voc√™ precisa decidir como o MLFQ alterar√° o n√≠vel de prioridade da tarefa (e, portanto, a posi√ß√£o da tarefa na fila) durante seu ciclo de vida.  Para fazer isso, lembre-se do fluxo de trabalho: v√°rias tarefas interativas com um tempo de trabalho curto (e, portanto, libera√ß√£o frequente da CPU) e v√°rias tarefas longas que usam a CPU durante todo o tempo de trabalho, enquanto o tempo de resposta para essas tarefas n√£o √© importante.  E assim, voc√™ pode fazer a primeira tentativa de implementar o algoritmo MLFQ com as seguintes regras: <br><br><ul><li>  Regra3: Quando uma tarefa entra no sistema, √© colocada na fila com a maior </li><li>  prioridade. </li><li>  Regra4a: Se uma tarefa usa a janela de tempo inteira atribu√≠da a ela, ent√£o sua </li><li>  a prioridade diminui. </li><li>  Rule4b: Se a tarefa liberar a CPU antes do vencimento de sua janela de tempo, ent√£o ela </li><li>  permanece com a mesma prioridade. </li></ul><br>  <b>Exemplo 1: Uma √∫nica tarefa de longa execu√ß√£o</b> <br><br>  Como voc√™ pode ver neste exemplo, a tarefa de admiss√£o √© colocada com a maior prioridade.  Ap√≥s uma janela de tempo de 10 ms, o processo √© reduzido em prioridade pelo planejador.  Ap√≥s a pr√≥xima janela de tempo, a tarefa finalmente cai para a menor prioridade do sistema, onde permanece. <br><br><img src="https://habrastorage.org/webt/jl/wi/fg/jlwifg8osgxds9bpyftx2aoa9pa.png"><br><br>  <b>Exemplo 2: Eles trouxeram uma tarefa curta</b> <br><br>  Agora vamos ver um exemplo de como o MLFQ tentar√° se aproximar do SJF.  Existem duas tarefas neste exemplo: A, que √© uma tarefa de longa dura√ß√£o que ocupa constantemente a CPU, e B, que √© uma tarefa interativa curta.  Suponha que A j√° funcionou por algum tempo no momento em que a tarefa B chega. <br><br><img src="https://habrastorage.org/webt/hq/dp/ou/hqdpouigzrlqbjbhwnvgv9e8mxc.png"><br><br>  Neste gr√°fico, os resultados do script s√£o vis√≠veis.  A tarefa A, como qualquer tarefa que usa uma CPU, fica na parte inferior.  A tarefa B chegar√° a T = 100 e ser√° colocada na fila com a maior prioridade.  Como o tempo de seu trabalho √© curto, ele terminar√° antes de chegar ao √∫ltimo est√°gio. <br><br>  A partir deste exemplo, deve-se entender o objetivo principal do algoritmo: como o algoritmo n√£o conhece uma tarefa longa ou curta, ele assume primeiro que a tarefa √© curta e lhe d√° a maior prioridade.  Se for uma tarefa realmente curta, ela ser√° conclu√≠da rapidamente, caso contr√°rio, se for uma tarefa longa, ela se mover√° lentamente para baixo em prioridade e logo provar√° que √© uma tarefa realmente longa que n√£o requer resposta. <br><br>  <b>Exemplo 3: E quanto √† E / S?</b> <br><br>  Agora d√™ uma olhada no exemplo de E / S.  Conforme declarado na regra 4b, se um processo libera um processador sem utilizar totalmente o tempo do processador, ele permanece no mesmo n√≠vel de prioridade.  A inten√ß√£o desta regra √© bastante simples - se uma tarefa interativa executar muitas opera√ß√µes de E / S, por exemplo, aguardando que o usu√°rio pressione uma tecla ou mouse, essa tarefa liberar√° o processador antes da janela alocada.  N√£o gostar√≠amos de omitir essa tarefa por prioridade e, portanto, ela permanecer√° no mesmo n√≠vel. <br><br><img src="https://habrastorage.org/webt/md/oa/f_/mdoaf_yf81n7xvy-j_bdo6hvbmm.png"><br><br>  Este exemplo mostra como o algoritmo funcionar√° com esses processos - uma tarefa interativa B, que precisa de uma CPU por apenas 1 ms antes de executar o processo de E / S, e uma tarefa longa A, que usa a CPU o tempo todo. <br><br>  O MLFQ mant√©m o processo B com a maior prioridade, pois continua o tempo todo. <br>  liberte a CPU.  Se B √© uma tarefa interativa, o algoritmo atingiu seu objetivo de iniciar tarefas interativas rapidamente. <br><br>  <b>Problemas com o algoritmo MLFQ atual</b> <br><br>  Nos exemplos anteriores, criamos a vers√£o base do MLFQ.  E parece que ele faz seu trabalho bem e honestamente, distribuindo honestamente o tempo do processador entre tarefas longas e permitindo que tarefas curtas ou tarefas que acessem intensivamente a E / S trabalhem rapidamente.  Infelizmente, essa abordagem cont√©m v√°rios problemas s√©rios. <br><br>  <b>Primeiro</b> , o problema da fome: se houver muitas tarefas interativas no sistema, elas consumir√£o todo o tempo do processador e, portanto, nem uma √∫nica tarefa longa poder√° ser executada (elas est√£o morrendo de fome). <br><br>  <b>Em segundo lugar</b> , usu√°rios inteligentes poderiam escrever seus programas para que <br>  enganar o planejador.  O truque √© fazer algo para fazer <br>  planejador para dar ao processo mais tempo do processador.  Algoritmo que <br>  descrito acima √© bastante vulner√°vel a esses ataques: antes que a janela de tempo seja praticamente <br>  finalizado, √© necess√°rio executar uma opera√ß√£o de E / S (para alguns, n√£o importa qual arquivo) <br>  e, assim, liberar a CPU.  Esse comportamento permitir√° que voc√™ permane√ßa no mesmo <br>  a pr√≥pria fila e, novamente, obt√©m uma porcentagem maior do tempo da CPU.  Se feito <br>  isso est√° correto (por exemplo, 99% do tempo da janela antes de liberar a CPU) <br>  essa tarefa pode simplesmente monopolizar o processador. <br><br>  Finalmente, um programa pode mudar seu comportamento ao longo do tempo.  Essas tarefas <br>  quem usou a CPU pode se tornar interativo.  No nosso exemplo, similar <br>  tarefas n√£o receber√£o tratamento adequado do agendador, pois outros receberiam <br>  (interativas) tarefas interativas. <br><br>  <u>Pergunta √† plat√©ia: que ataques ao planejador poderiam ser feitos no mundo moderno?</u> <u><br></u> <br><h4>  Tentativa 2: Aumentar a prioridade </h4><br><br>  Vamos tentar mudar as regras e ver se podemos evitar problemas com <br>  jejum.  O que poder√≠amos fazer para garantir que <br>  As tarefas da CPU ter√£o seu tempo (mesmo que n√£o por muito tempo). <br>  Como uma solu√ß√£o simples para o problema, voc√™ pode oferecer periodicamente <br>  aumentar a prioridade de todas essas tarefas no sistema.  Existem muitas maneiras. <br>  para conseguir isso, vamos tentar implementar como exemplo algo simples: traduzir <br>  todas as tarefas ao mesmo tempo na mais alta prioridade, da√≠ a nova regra: <br><ul><li>  <b>Regra5</b> : Ap√≥s um certo per√≠odo de S, transfira todas as tarefas do sistema para a prioridade mais alta. </li></ul><br>  Nossa nova regra resolve dois problemas ao mesmo tempo.  Primeiro, os processos <br>  garantido para n√£o morrer de fome: as tarefas da mais alta prioridade compartilhar√£o <br>  processador de acordo com o algoritmo RR e, portanto, todos os processos receber√£o <br>  tempo do processador.  Em segundo lugar, se houver algum processo usado anteriormente <br>  apenas o processador se tornar interativo, ele permanecer√° alinhado com as <br>  prioridade depois de uma vez receber√° um aumento de prioridade para o mais alto. <br>  Considere um exemplo.  Nesse cen√°rio, considere um processo usando <br><img src="https://habrastorage.org/webt/cx/te/ll/cxtellydeep0hkgrqfiypt-zqq4.png"><br><br>  CPU e dois processos curtos e interativos.  √Ä esquerda na figura, a figura mostra o comportamento sem aumentar a prioridade e, portanto, a longa tarefa come√ßa a passar fome depois que duas tarefas interativas chegam ao sistema.  Na figura √† direita, a cada 50ms, a prioridade √© aumentada e, portanto, todos os processos s√£o garantidos para receber o tempo do processador e ser√£o iniciados periodicamente.  50ms neste caso √© tomado como exemplo, na realidade esse n√∫mero √© um pouco maior. <br>  Obviamente, a adi√ß√£o de tempo para um aumento peri√≥dico de S leva a <br>  pergunta l√≥gica: qual valor deve ser definido?  Um dos homenageados <br>  engenheiros de sistemas John Ousterhout denominaram quantidades semelhantes em sistemas como o voo-doo <br>  constante, porque de alguma maneira exigiam magia negra para <br>  exibindo.  E, infelizmente, S tem esse aroma.  Se voc√™ definir o valor tamb√©m <br>  grandes e longas tarefas come√ßar√£o a passar fome.  E se voc√™ definir o valor muito baixo, <br>  As tarefas interativas n√£o receber√£o o tempo adequado do processador. <br><br><h4>  Tentativa 3: Melhor contabilidade </h4><br><br>  Agora, temos mais um problema que precisa ser resolvido: como n√£o <br>  vamos enganar o nosso planejador?  Culpado desta oportunidade s√£o <br>  regras 4a, 4b, que permitem que a tarefa mantenha prioridade, liberando o processador <br>  antes da expira√ß√£o do tempo alocado.  Como lidar com isso? <br>  A solu√ß√£o nesse caso pode ser considerada a melhor contabiliza√ß√£o do tempo da CPU em cada <br>  N√≠vel MLFQ.  Em vez de esquecer o tempo que o programa usou <br>  processador durante o per√≠odo designado, considere e salve-o.  Depois <br>  o processo gastou tempo alocado para ele deve ser reduzido para o pr√≥ximo <br>  n√≠vel de prioridade.  Agora, n√£o importa como o processo use seu tempo - como <br>  constantemente computando no processador ou em tantas chamadas.  Desta maneira <br>  A regra 4 deve ser reescrita da seguinte maneira: <br><br><ul><li>  <b>Regra4</b> : Depois que a tarefa <b>esgotar</b> o tempo alocado na fila atual (independentemente de quantas vezes liberou a CPU), a prioridade de uma tarefa diminui (ela desce a fila). </li></ul><br>  Vejamos um exemplo: <br><img src="https://habrastorage.org/webt/je/rs/kw/jerskwy36cewrg6auapm-dal7iu.png">  " <br><br>  A figura mostra o que acontece se voc√™ tentar enganar o planejador, como <br>  se fosse com as regras anteriores 4a, 4b, obteremos o resultado √† esquerda.  Feliz novo <br>  a regra √© o resultado √† direita.  Antes da prote√ß√£o, qualquer processo poderia chamar E / S at√© a conclus√£o e <br>  dominam a CPU, depois de ativar a prote√ß√£o, independentemente do comportamento <br>  E / S, ainda vai cair na linha e, portanto, n√£o ser√° desonesto <br>  tomar posse dos recursos da CPU. <br><br><h4>  Melhorando o MLFQ e outros problemas </h4><br>  Com as melhorias acima, surgem novos problemas: um dos principais <br>  perguntas - como parametrizar esse agendador?  I.e.  Quanto deve ser <br>  rajadas?  Qual deve ser o tamanho da janela do programa dentro da fila?  Como <br>  a prioridade do programa deve frequentemente ser aumentada para evitar a fome e <br>  levar em conta mudan√ßas no comportamento do programa?  Para essas perguntas, n√£o √© f√°cil <br>  resposta e apenas experimentos com cargas e configura√ß√£o subsequente <br>  o planejador pode levar a um equil√≠brio satisfat√≥rio. <br><br>  Por exemplo, a maioria das implementa√ß√µes do MLFQ permite atribuir diferentes <br>  intervalos de tempo para diferentes filas.  Filas de alta prioridade geralmente <br>  intervalos curtos s√£o atribu√≠dos.  Essas filas consistem em tarefas interativas, <br>  alternar entre o que √© bastante sens√≠vel e deve levar 10 ou menos <br>  ms  Por outro lado, filas de baixa prioridade consistem em tarefas longas usando <br>  CPU  E, neste caso, longos intervalos de tempo se encaixam muito bem (100ms). <br><img src="https://habrastorage.org/webt/p4/1j/-d/p41j-d9spzwfok9w7xmkcewqgrq.png"><br><br>  Neste exemplo, existem 2 tarefas que funcionaram na fila de alta prioridade 20 <br>  ms, quebrado por janelas por 10ms.  40ms na fila m√©dia (janela √†s 20ms) e na prioridade baixa <br>  A janela de tempo da fila passou a 40ms, onde as tarefas conclu√≠ram seu trabalho. <br><br>  A implementa√ß√£o do Solaris OS MLFQ √© uma classe de agendadores de compartilhamento de tempo. <br>  O planejador fornece um conjunto de tabelas que determinam exatamente como deve <br>  mudar a prioridade do processo ao longo de sua vida, qual deve ser o tamanho <br>  a janela selecionada e com que frequ√™ncia voc√™ precisa elevar as prioridades da tarefa.  Admin <br>  sistemas podem interagir com esta tabela e fazer com que o planejador se comporte <br>  de uma maneira diferente.  Por padr√£o, existem 60 filas incrementais nesta tabela. <br>  tamanho da janela de 20 ms (alta prioridade) a v√°rias centenas de ms (menor prioridade) e <br>  tamb√©m com um aumento de todas as tarefas uma vez por segundo. <br><br>  Outros planejadores do MLFQ n√£o usam uma tabela ou qualquer <br>  as regras descritas nesta palestra, pelo contr√°rio, calculam as prioridades usando <br>  f√≥rmulas matem√°ticas.  Ent√£o, por exemplo, o planejador no FreeBSD usa a f√≥rmula para <br>  calcular a prioridade atual de uma tarefa com base em quanto o processo <br>  CPU usada.  Al√©m disso, o uso da CPU decai com o tempo e, portanto, <br>  Assim, o aumento de prioridade ocorre de maneira um pouco diferente do descrito acima.  √â t√£o <br>  chamados algoritmos de decaimento.  Desde a vers√£o 7.1, o FreeBSD usa o agendador ULE. <br><br>  Finalmente, muitos planejadores t√™m outros recursos.  Por exemplo, alguns <br>  planejadores reservam os n√≠veis mais altos para o sistema operacional e, portanto, <br>  Dessa forma, nenhum processo do usu√°rio pode obter a maior prioridade em <br>  sistema  Alguns sistemas permitem que voc√™ d√™ dicas para ajudar. <br>  o planejador para definir prioridades corretamente.  Por exemplo, usando o comando <b>nice</b> <br>  voc√™ pode aumentar ou diminuir a prioridade da tarefa e, assim, aumentar ou diminuir <br>  reduza as chances do programa para o tempo do processador. <br><h3>  MLFQ: Resumo </h3><br>  Descrevemos uma abordagem de planejamento chamada MLFQ.  O nome dele <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele √© conclu√≠do no princ√≠pio do trabalho - possui v√°rias filas e usa feedback </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar a prioridade da tarefa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A forma final das regras ser√° a seguinte:</font></font><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Se a prioridade (A)&gt; Prioridade (B), a tarefa A for iniciada (B n√£o ser√°)</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Se a prioridade (A) = Prioridade (B), A&amp;B s√£o iniciados usando RR</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Quando uma tarefa entra no sistema, ela √© enfileirada com a prioridade mais alta.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Depois que a tarefa </font><b><font style="vertical-align: inherit;">esgotar</font></b><font style="vertical-align: inherit;"> o tempo alocado na fila atual (independentemente de quantas vezes liberou a CPU), a prioridade de uma tarefa diminui (ela desce a fila).</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ap√≥s um certo per√≠odo de S, transfira todas as tarefas do sistema para a prioridade mais alta.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O MLFQ √© interessante pelo seguinte motivo - em vez de exigir conhecimento pr√©vio sobre a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">natureza da tarefa, o algoritmo examina o comportamento passado da tarefa e </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prioriza de acordo. </font><font style="vertical-align: inherit;">Assim, ele tenta se sentar em duas cadeiras ao mesmo tempo - para obter produtividade para pequenas tarefas (SJF, STCF) e executar honestamente </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarefas </font><font style="vertical-align: inherit;">longas e </font><font style="vertical-align: inherit;">de carregamento da CPU. </font><font style="vertical-align: inherit;">Portanto, muitos sistemas, incluindo BSD e seus derivados, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solaris, Windows, Mac, usam alguma forma de algoritmo </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MLFQ </font><font style="vertical-align: inherit;">como um </font><font style="vertical-align: inherit;">agendador como base.</font></font><br><h4>  Materiais adicionais: </h4><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manpages.debian.org/stretch/manpages/sched.7.en.html</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Scheduling_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (computing)</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pages.lip6.fr/Julia.Lawall/atc18-bouron.pdf</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.usenix.org/legacy/event/bsdcon03/tech/full_papers/roberson/roberson.pdf</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chebykin.org/freebsd-process-scheduling</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450116/">https://habr.com/ru/post/pt450116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450104/index.html">Muito dif√≠cil e muito interessante: comunidades de TI no TechTrain</a></li>
<li><a href="../pt450106/index.html">O projeto da organiza√ß√£o da constru√ß√£o e reconstru√ß√£o em condi√ß√µes apertadas no canteiro de obras do SPDS</a></li>
<li><a href="../pt450110/index.html">Patentes de design: parte dois (exemplos da Microsoft, Snapchat, Samsung, Netflix, Airbnb, Tinder)</a></li>
<li><a href="../pt450112/index.html">Eh, o que aconteceu com as malas ?! No exemplo de uma mala-scooter infantil ZINC</a></li>
<li><a href="../pt450114/index.html">Sobre o que implementamos no EWM, gra√ßas ao seu conselho</a></li>
<li><a href="../pt450118/index.html">Transmita a tela para v√°rios dispositivos pela rede</a></li>
<li><a href="../pt450120/index.html">Pesquise imagens semelhantes, analisando um √∫nico algoritmo</a></li>
<li><a href="../pt450122/index.html">Startup Digest: Genetics (janeiro a mar√ßo de 2019)</a></li>
<li><a href="../pt450124/index.html">Configurando mapas do OsmAnd da camada de mapa de calor do Strava</a></li>
<li><a href="../pt450126/index.html">O backdoor e o criptografador Buhtrap foram distribu√≠dos usando o Yandex.Direct</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>