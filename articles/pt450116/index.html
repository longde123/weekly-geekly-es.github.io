<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗺️ 🤰 🧑🏽‍🤝‍🧑🏻 Sistemas operacionais: três peças fáceis. Parte 5: Planejamento: fila de feedback multinível (tradução) 👩🏼‍🤝‍👩🏻 👩‍👩‍👧‍👧 👄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introdução aos sistemas operacionais 
 Olá Habr! Quero chamar sua atenção para uma série de artigos - traduções de uma literatura interessante em minh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistemas operacionais: três peças fáceis. Parte 5: Planejamento: fila de feedback multinível (tradução)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450116/"><h1>  Introdução aos sistemas operacionais </h1><br>  Olá Habr!  Quero chamar sua atenção para uma série de artigos - traduções de uma literatura interessante em minha opinião - OSTEP.  Este artigo discute profundamente o trabalho de sistemas operacionais semelhantes a unix, ou seja, trabalha com processos, vários agendadores, memória e outros componentes similares que compõem o sistema operacional moderno.  O original de todos os materiais que você pode ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Observe que a tradução foi feita de maneira não profissional (muito livremente), mas espero ter mantido o significado geral. <br><br>  O trabalho de laboratório sobre este assunto pode ser encontrado aqui: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">minha adaptação pessoal</a> </li></ul><br>  Outras partes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: Introdução</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: Abstração: o processo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: Introdução à API do Processo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4: Introdução ao Agendador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5: MLFQ Scheduler</a> </li></ul><br>  E você pode olhar para o meu canal no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">telegrama</a> =) <br><a name="habracut"></a><br><h2>  Planejamento: fila de feedback multinível </h2><br>  Nesta palestra, falaremos sobre os problemas de desenvolver uma das abordagens mais famosas para <br>  Planejamento chamado <b>Fila de feedback de vários níveis</b> (MLFQ).  O agendador do MLFQ foi descrito pela primeira vez em 1962 por Fernando J. Corbató em um sistema chamado Sistema de Compartilhamento de Tempo Compatível (CTSS).  Esses trabalhos (incluindo trabalhos posteriores sobre Multics) foram posteriormente submetidos ao Prêmio Turing.  O agendador foi posteriormente aprimorado e adquiriu uma aparência que já pode ser encontrada em alguns sistemas modernos. <br><br>  O algoritmo MLFQ tenta resolver 2 problemas transversais fundamentais. <br>  <b>Primeiro</b> , ele tenta otimizar o tempo de resposta, que, como examinamos na palestra anterior, é otimizado iniciando no início da fila das tarefas mais curtas.  No entanto, o sistema operacional não sabe quanto tempo esse ou aquele processo funcionará, e esse é o conhecimento necessário para a operação dos algoritmos SJF, STCF.  <b>Em segundo lugar</b> , o MLFQ tenta tornar o sistema responsivo aos usuários (por exemplo, aqueles que estão sentados e olhando para a tela enquanto aguardam a conclusão da tarefa) e, assim, minimizar o tempo de resposta.  Infelizmente, algoritmos como o RR reduzem o tempo de resposta, mas têm um efeito muito ruim nas métricas de tempo de resposta.  Daí o nosso problema: como projetar um agendador que atenda aos nossos requisitos e, ao mesmo tempo, não saiba nada sobre a natureza do processo, em geral?  Como o planejador pode aprender as características das tarefas que inicia e, assim, tomar melhores decisões de planejamento? <br><br>  <u>A essência do problema: como planejar a formulação de tarefas sem conhecimento perfeito?</u>  <u>Como desenvolver um agendador que minimiza simultaneamente o tempo de resposta para tarefas interativas e ao mesmo tempo minimiza o tempo de resposta sem saber o tempo para concluir a tarefa?</u> <br><br>  Nota: aprendendo com eventos anteriores <br><br>  A programação do MLFQ é um ótimo exemplo de sistema que aprende com eventos passados ​​para prever o futuro.  Abordagens semelhantes são frequentemente encontradas no sistema operacional (e em muitos outros ramos da ciência da computação, incluindo ramos de previsão de hardware e algoritmos de cache).  Viagens semelhantes funcionam quando as tarefas têm fases comportamentais e, portanto, são previsíveis. <br><br>  No entanto, é preciso ter cuidado com essa técnica, porque as previsões podem facilmente ser erradas e levar o sistema a tomar decisões piores do que seria sem conhecimento. <br><br><h3>  MLFQ: Regras básicas </h3><br>  Considere as regras básicas do algoritmo MLFQ.  Embora existam várias implementações desse algoritmo, as abordagens básicas são semelhantes. <br><br>  Na implementação que consideraremos, no MLFQ haverá várias filas separadas, cada uma com uma prioridade diferente.  A qualquer momento, uma tarefa pronta para execução está em uma fila.  O MLFQ usa prioridades para decidir qual tarefa executar, ou seja,  uma tarefa com uma prioridade mais alta (uma tarefa da fila com uma prioridade mais alta) será iniciada primeiro. <br><br>  Sem dúvida, mais de uma tarefa pode estar em uma fila específica, portanto elas terão a mesma prioridade.  Nesse caso, o mecanismo RR será usado para agendar o lançamento entre essas tarefas. <br><br>  Assim, chegamos a duas regras básicas para o MLFQ: <br><br><ul><li>  Regra1: Se a prioridade (A)&gt; Prioridade (B), a tarefa A for iniciada (B não será) </li><li>  Regra2: Se a prioridade (A) = Prioridade (B), A&amp;B são iniciados usando RR </li></ul><br>  Com base no exposto, os principais elementos do planejamento do MLFQ são prioridades.  Em vez de definir uma prioridade fixa para cada tarefa, o MLFQ altera sua prioridade, dependendo do comportamento observado. <br><br>  Por exemplo, se uma tarefa parar constantemente de trabalhar na CPU enquanto aguarda a entrada do teclado, o MLFQ manterá a prioridade do processo em um nível alto, porque é assim que o processo interativo deve funcionar.  Se, pelo contrário, a tarefa usar constante e intensivamente a CPU por um longo período, o MLFQ diminuirá sua prioridade.  Assim, o MLFQ estudará o comportamento dos processos no momento de sua operação e usará o comportamento. <br><br>  Vamos desenhar um exemplo de como as filas podem parecer em algum momento e, em seguida, obtemos algo assim: <br><br><img src="https://habrastorage.org/webt/4x/ad/rr/4xadrrwfmrtn3mg-se6wgith9gm.png" alt="imagem"><br><br>  Nesse esquema, 2 processos A e B estão na fila com a prioridade mais alta.  O processo C está em algum lugar no meio e o processo D está no final da fila.  De acordo com as descrições acima do algoritmo MLFQ, o planejador executará tarefas apenas com a maior prioridade, de acordo com o RR, e as tarefas C, D ficarão sem trabalho. <br><br>  Naturalmente, um instantâneo estático não fornecerá uma imagem completa de como o MLFQ funciona. <br>  É importante entender exatamente como a imagem muda com o tempo. <br><br><h4>  Tentativa 1: Como alterar a prioridade </h4><br>  Nesse ponto, você precisa decidir como o MLFQ alterará o nível de prioridade da tarefa (e, portanto, a posição da tarefa na fila) durante seu ciclo de vida.  Para fazer isso, lembre-se do fluxo de trabalho: várias tarefas interativas com um tempo de trabalho curto (e, portanto, liberação frequente da CPU) e várias tarefas longas que usam a CPU durante todo o tempo de trabalho, enquanto o tempo de resposta para essas tarefas não é importante.  E assim, você pode fazer a primeira tentativa de implementar o algoritmo MLFQ com as seguintes regras: <br><br><ul><li>  Regra3: Quando uma tarefa entra no sistema, é colocada na fila com a maior </li><li>  prioridade. </li><li>  Regra4a: Se uma tarefa usa a janela de tempo inteira atribuída a ela, então sua </li><li>  a prioridade diminui. </li><li>  Rule4b: Se a tarefa liberar a CPU antes do vencimento de sua janela de tempo, então ela </li><li>  permanece com a mesma prioridade. </li></ul><br>  <b>Exemplo 1: Uma única tarefa de longa execução</b> <br><br>  Como você pode ver neste exemplo, a tarefa de admissão é colocada com a maior prioridade.  Após uma janela de tempo de 10 ms, o processo é reduzido em prioridade pelo planejador.  Após a próxima janela de tempo, a tarefa finalmente cai para a menor prioridade do sistema, onde permanece. <br><br><img src="https://habrastorage.org/webt/jl/wi/fg/jlwifg8osgxds9bpyftx2aoa9pa.png"><br><br>  <b>Exemplo 2: Eles trouxeram uma tarefa curta</b> <br><br>  Agora vamos ver um exemplo de como o MLFQ tentará se aproximar do SJF.  Existem duas tarefas neste exemplo: A, que é uma tarefa de longa duração que ocupa constantemente a CPU, e B, que é uma tarefa interativa curta.  Suponha que A já funcionou por algum tempo no momento em que a tarefa B chega. <br><br><img src="https://habrastorage.org/webt/hq/dp/ou/hqdpouigzrlqbjbhwnvgv9e8mxc.png"><br><br>  Neste gráfico, os resultados do script são visíveis.  A tarefa A, como qualquer tarefa que usa uma CPU, fica na parte inferior.  A tarefa B chegará a T = 100 e será colocada na fila com a maior prioridade.  Como o tempo de seu trabalho é curto, ele terminará antes de chegar ao último estágio. <br><br>  A partir deste exemplo, deve-se entender o objetivo principal do algoritmo: como o algoritmo não conhece uma tarefa longa ou curta, ele assume primeiro que a tarefa é curta e lhe dá a maior prioridade.  Se for uma tarefa realmente curta, ela será concluída rapidamente, caso contrário, se for uma tarefa longa, ela se moverá lentamente para baixo em prioridade e logo provará que é uma tarefa realmente longa que não requer resposta. <br><br>  <b>Exemplo 3: E quanto à E / S?</b> <br><br>  Agora dê uma olhada no exemplo de E / S.  Conforme declarado na regra 4b, se um processo libera um processador sem utilizar totalmente o tempo do processador, ele permanece no mesmo nível de prioridade.  A intenção desta regra é bastante simples - se uma tarefa interativa executar muitas operações de E / S, por exemplo, aguardando que o usuário pressione uma tecla ou mouse, essa tarefa liberará o processador antes da janela alocada.  Não gostaríamos de omitir essa tarefa por prioridade e, portanto, ela permanecerá no mesmo nível. <br><br><img src="https://habrastorage.org/webt/md/oa/f_/mdoaf_yf81n7xvy-j_bdo6hvbmm.png"><br><br>  Este exemplo mostra como o algoritmo funcionará com esses processos - uma tarefa interativa B, que precisa de uma CPU por apenas 1 ms antes de executar o processo de E / S, e uma tarefa longa A, que usa a CPU o tempo todo. <br><br>  O MLFQ mantém o processo B com a maior prioridade, pois continua o tempo todo. <br>  liberte a CPU.  Se B é uma tarefa interativa, o algoritmo atingiu seu objetivo de iniciar tarefas interativas rapidamente. <br><br>  <b>Problemas com o algoritmo MLFQ atual</b> <br><br>  Nos exemplos anteriores, criamos a versão base do MLFQ.  E parece que ele faz seu trabalho bem e honestamente, distribuindo honestamente o tempo do processador entre tarefas longas e permitindo que tarefas curtas ou tarefas que acessem intensivamente a E / S trabalhem rapidamente.  Infelizmente, essa abordagem contém vários problemas sérios. <br><br>  <b>Primeiro</b> , o problema da fome: se houver muitas tarefas interativas no sistema, elas consumirão todo o tempo do processador e, portanto, nem uma única tarefa longa poderá ser executada (elas estão morrendo de fome). <br><br>  <b>Em segundo lugar</b> , usuários inteligentes poderiam escrever seus programas para que <br>  enganar o planejador.  O truque é fazer algo para fazer <br>  planejador para dar ao processo mais tempo do processador.  Algoritmo que <br>  descrito acima é bastante vulnerável a esses ataques: antes que a janela de tempo seja praticamente <br>  finalizado, é necessário executar uma operação de E / S (para alguns, não importa qual arquivo) <br>  e, assim, liberar a CPU.  Esse comportamento permitirá que você permaneça no mesmo <br>  a própria fila e, novamente, obtém uma porcentagem maior do tempo da CPU.  Se feito <br>  isso está correto (por exemplo, 99% do tempo da janela antes de liberar a CPU) <br>  essa tarefa pode simplesmente monopolizar o processador. <br><br>  Finalmente, um programa pode mudar seu comportamento ao longo do tempo.  Essas tarefas <br>  quem usou a CPU pode se tornar interativo.  No nosso exemplo, similar <br>  tarefas não receberão tratamento adequado do agendador, pois outros receberiam <br>  (interativas) tarefas interativas. <br><br>  <u>Pergunta à platéia: que ataques ao planejador poderiam ser feitos no mundo moderno?</u> <u><br></u> <br><h4>  Tentativa 2: Aumentar a prioridade </h4><br><br>  Vamos tentar mudar as regras e ver se podemos evitar problemas com <br>  jejum.  O que poderíamos fazer para garantir que <br>  As tarefas da CPU terão seu tempo (mesmo que não por muito tempo). <br>  Como uma solução simples para o problema, você pode oferecer periodicamente <br>  aumentar a prioridade de todas essas tarefas no sistema.  Existem muitas maneiras. <br>  para conseguir isso, vamos tentar implementar como exemplo algo simples: traduzir <br>  todas as tarefas ao mesmo tempo na mais alta prioridade, daí a nova regra: <br><ul><li>  <b>Regra5</b> : Após um certo período de S, transfira todas as tarefas do sistema para a prioridade mais alta. </li></ul><br>  Nossa nova regra resolve dois problemas ao mesmo tempo.  Primeiro, os processos <br>  garantido para não morrer de fome: as tarefas da mais alta prioridade compartilharão <br>  processador de acordo com o algoritmo RR e, portanto, todos os processos receberão <br>  tempo do processador.  Em segundo lugar, se houver algum processo usado anteriormente <br>  apenas o processador se tornar interativo, ele permanecerá alinhado com as <br>  prioridade depois de uma vez receberá um aumento de prioridade para o mais alto. <br>  Considere um exemplo.  Nesse cenário, considere um processo usando <br><img src="https://habrastorage.org/webt/cx/te/ll/cxtellydeep0hkgrqfiypt-zqq4.png"><br><br>  CPU e dois processos curtos e interativos.  À esquerda na figura, a figura mostra o comportamento sem aumentar a prioridade e, portanto, a longa tarefa começa a passar fome depois que duas tarefas interativas chegam ao sistema.  Na figura à direita, a cada 50ms, a prioridade é aumentada e, portanto, todos os processos são garantidos para receber o tempo do processador e serão iniciados periodicamente.  50ms neste caso é tomado como exemplo, na realidade esse número é um pouco maior. <br>  Obviamente, a adição de tempo para um aumento periódico de S leva a <br>  pergunta lógica: qual valor deve ser definido?  Um dos homenageados <br>  engenheiros de sistemas John Ousterhout denominaram quantidades semelhantes em sistemas como o voo-doo <br>  constante, porque de alguma maneira exigiam magia negra para <br>  exibindo.  E, infelizmente, S tem esse aroma.  Se você definir o valor também <br>  grandes e longas tarefas começarão a passar fome.  E se você definir o valor muito baixo, <br>  As tarefas interativas não receberão o tempo adequado do processador. <br><br><h4>  Tentativa 3: Melhor contabilidade </h4><br><br>  Agora, temos mais um problema que precisa ser resolvido: como não <br>  vamos enganar o nosso planejador?  Culpado desta oportunidade são <br>  regras 4a, 4b, que permitem que a tarefa mantenha prioridade, liberando o processador <br>  antes da expiração do tempo alocado.  Como lidar com isso? <br>  A solução nesse caso pode ser considerada a melhor contabilização do tempo da CPU em cada <br>  Nível MLFQ.  Em vez de esquecer o tempo que o programa usou <br>  processador durante o período designado, considere e salve-o.  Depois <br>  o processo gastou tempo alocado para ele deve ser reduzido para o próximo <br>  nível de prioridade.  Agora, não importa como o processo use seu tempo - como <br>  constantemente computando no processador ou em tantas chamadas.  Desta maneira <br>  A regra 4 deve ser reescrita da seguinte maneira: <br><br><ul><li>  <b>Regra4</b> : Depois que a tarefa <b>esgotar</b> o tempo alocado na fila atual (independentemente de quantas vezes liberou a CPU), a prioridade de uma tarefa diminui (ela desce a fila). </li></ul><br>  Vejamos um exemplo: <br><img src="https://habrastorage.org/webt/je/rs/kw/jerskwy36cewrg6auapm-dal7iu.png">  " <br><br>  A figura mostra o que acontece se você tentar enganar o planejador, como <br>  se fosse com as regras anteriores 4a, 4b, obteremos o resultado à esquerda.  Feliz novo <br>  a regra é o resultado à direita.  Antes da proteção, qualquer processo poderia chamar E / S até a conclusão e <br>  dominam a CPU, depois de ativar a proteção, independentemente do comportamento <br>  E / S, ainda vai cair na linha e, portanto, não será desonesto <br>  tomar posse dos recursos da CPU. <br><br><h4>  Melhorando o MLFQ e outros problemas </h4><br>  Com as melhorias acima, surgem novos problemas: um dos principais <br>  perguntas - como parametrizar esse agendador?  I.e.  Quanto deve ser <br>  rajadas?  Qual deve ser o tamanho da janela do programa dentro da fila?  Como <br>  a prioridade do programa deve frequentemente ser aumentada para evitar a fome e <br>  levar em conta mudanças no comportamento do programa?  Para essas perguntas, não é fácil <br>  resposta e apenas experimentos com cargas e configuração subsequente <br>  o planejador pode levar a um equilíbrio satisfatório. <br><br>  Por exemplo, a maioria das implementações do MLFQ permite atribuir diferentes <br>  intervalos de tempo para diferentes filas.  Filas de alta prioridade geralmente <br>  intervalos curtos são atribuídos.  Essas filas consistem em tarefas interativas, <br>  alternar entre o que é bastante sensível e deve levar 10 ou menos <br>  ms  Por outro lado, filas de baixa prioridade consistem em tarefas longas usando <br>  CPU  E, neste caso, longos intervalos de tempo se encaixam muito bem (100ms). <br><img src="https://habrastorage.org/webt/p4/1j/-d/p41j-d9spzwfok9w7xmkcewqgrq.png"><br><br>  Neste exemplo, existem 2 tarefas que funcionaram na fila de alta prioridade 20 <br>  ms, quebrado por janelas por 10ms.  40ms na fila média (janela às 20ms) e na prioridade baixa <br>  A janela de tempo da fila passou a 40ms, onde as tarefas concluíram seu trabalho. <br><br>  A implementação do Solaris OS MLFQ é uma classe de agendadores de compartilhamento de tempo. <br>  O planejador fornece um conjunto de tabelas que determinam exatamente como deve <br>  mudar a prioridade do processo ao longo de sua vida, qual deve ser o tamanho <br>  a janela selecionada e com que frequência você precisa elevar as prioridades da tarefa.  Admin <br>  sistemas podem interagir com esta tabela e fazer com que o planejador se comporte <br>  de uma maneira diferente.  Por padrão, existem 60 filas incrementais nesta tabela. <br>  tamanho da janela de 20 ms (alta prioridade) a várias centenas de ms (menor prioridade) e <br>  também com um aumento de todas as tarefas uma vez por segundo. <br><br>  Outros planejadores do MLFQ não usam uma tabela ou qualquer <br>  as regras descritas nesta palestra, pelo contrário, calculam as prioridades usando <br>  fórmulas matemáticas.  Então, por exemplo, o planejador no FreeBSD usa a fórmula para <br>  calcular a prioridade atual de uma tarefa com base em quanto o processo <br>  CPU usada.  Além disso, o uso da CPU decai com o tempo e, portanto, <br>  Assim, o aumento de prioridade ocorre de maneira um pouco diferente do descrito acima.  É tão <br>  chamados algoritmos de decaimento.  Desde a versão 7.1, o FreeBSD usa o agendador ULE. <br><br>  Finalmente, muitos planejadores têm outros recursos.  Por exemplo, alguns <br>  planejadores reservam os níveis mais altos para o sistema operacional e, portanto, <br>  Dessa forma, nenhum processo do usuário pode obter a maior prioridade em <br>  sistema  Alguns sistemas permitem que você dê dicas para ajudar. <br>  o planejador para definir prioridades corretamente.  Por exemplo, usando o comando <b>nice</b> <br>  você pode aumentar ou diminuir a prioridade da tarefa e, assim, aumentar ou diminuir <br>  reduza as chances do programa para o tempo do processador. <br><h3>  MLFQ: Resumo </h3><br>  Descrevemos uma abordagem de planejamento chamada MLFQ.  O nome dele <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele é concluído no princípio do trabalho - possui várias filas e usa feedback </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar a prioridade da tarefa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A forma final das regras será a seguinte:</font></font><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Se a prioridade (A)&gt; Prioridade (B), a tarefa A for iniciada (B não será)</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Se a prioridade (A) = Prioridade (B), A&amp;B são iniciados usando RR</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Quando uma tarefa entra no sistema, ela é enfileirada com a prioridade mais alta.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Depois que a tarefa </font><b><font style="vertical-align: inherit;">esgotar</font></b><font style="vertical-align: inherit;"> o tempo alocado na fila atual (independentemente de quantas vezes liberou a CPU), a prioridade de uma tarefa diminui (ela desce a fila).</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Após um certo período de S, transfira todas as tarefas do sistema para a prioridade mais alta.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O MLFQ é interessante pelo seguinte motivo - em vez de exigir conhecimento prévio sobre a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">natureza da tarefa, o algoritmo examina o comportamento passado da tarefa e </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prioriza de acordo. </font><font style="vertical-align: inherit;">Assim, ele tenta se sentar em duas cadeiras ao mesmo tempo - para obter produtividade para pequenas tarefas (SJF, STCF) e executar honestamente </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarefas </font><font style="vertical-align: inherit;">longas e </font><font style="vertical-align: inherit;">de carregamento da CPU. </font><font style="vertical-align: inherit;">Portanto, muitos sistemas, incluindo BSD e seus derivados, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solaris, Windows, Mac, usam alguma forma de algoritmo </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MLFQ </font><font style="vertical-align: inherit;">como um </font><font style="vertical-align: inherit;">agendador como base.</font></font><br><h4>  Materiais adicionais: </h4><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manpages.debian.org/stretch/manpages/sched.7.en.html</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Scheduling_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (computing)</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pages.lip6.fr/Julia.Lawall/atc18-bouron.pdf</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.usenix.org/legacy/event/bsdcon03/tech/full_papers/roberson/roberson.pdf</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chebykin.org/freebsd-process-scheduling</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450116/">https://habr.com/ru/post/pt450116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450104/index.html">Muito difícil e muito interessante: comunidades de TI no TechTrain</a></li>
<li><a href="../pt450106/index.html">O projeto da organização da construção e reconstrução em condições apertadas no canteiro de obras do SPDS</a></li>
<li><a href="../pt450110/index.html">Patentes de design: parte dois (exemplos da Microsoft, Snapchat, Samsung, Netflix, Airbnb, Tinder)</a></li>
<li><a href="../pt450112/index.html">Eh, o que aconteceu com as malas ?! No exemplo de uma mala-scooter infantil ZINC</a></li>
<li><a href="../pt450114/index.html">Sobre o que implementamos no EWM, graças ao seu conselho</a></li>
<li><a href="../pt450118/index.html">Transmita a tela para vários dispositivos pela rede</a></li>
<li><a href="../pt450120/index.html">Pesquise imagens semelhantes, analisando um único algoritmo</a></li>
<li><a href="../pt450122/index.html">Startup Digest: Genetics (janeiro a março de 2019)</a></li>
<li><a href="../pt450124/index.html">Configurando mapas do OsmAnd da camada de mapa de calor do Strava</a></li>
<li><a href="../pt450126/index.html">O backdoor e o criptografador Buhtrap foram distribuídos usando o Yandex.Direct</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>