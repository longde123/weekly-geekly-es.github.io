<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèª üßëüèæ‚Äçü§ù‚Äçüßëüèª ü§±üèª Automa√ß√£o de teste de servi√ßos pagos no iOS ü§æüèº üõåüèº üßòüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para quem est√° interessado no t√≥pico de automa√ß√£o no iOS, tenho duas novidades - boas e m√°s. Bom: no aplicativo iOS para servi√ßos pagos, apenas um pon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automa√ß√£o de teste de servi√ßos pagos no iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/460667/">  Para quem est√° interessado no t√≥pico de automa√ß√£o no iOS, tenho duas novidades - boas e m√°s.  Bom: no aplicativo iOS para servi√ßos pagos, apenas um ponto de integra√ß√£o √© usado - compras no aplicativo (compras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">integradas no aplicativo</a> ).  Ruim: a Apple n√£o fornece nenhuma ferramenta para automatizar compras de teste. <br><br>  Neste artigo, sugiro que voc√™ e eu procuremos um m√©todo de automa√ß√£o universal al√©m do bem e do mal da Apple.  O artigo ser√° √∫til para quem integra servi√ßos de terceiros que s√£o uma caixa preta em seus aplicativos: publicidade, streaming, gerenciamento de localiza√ß√£o etc. Geralmente, essas integra√ß√µes s√£o muito dif√≠ceis de testar, pois n√£o h√° como configurar de forma flex√≠vel um servi√ßo de terceiros para testar o aplicativo. <br><br><img src="https://habrastorage.org/webt/fg/if/j3/fgifj3qfcwf_98iuebxjx-fxrka.jpeg"><br><a name="habracut"></a><br>  <i>Meu nome √© Victor Koronevich, sou engenheiro s√™nior de automa√ß√£o de testes no Badoo.</i>  <i>Envolvido em automa√ß√£o m√≥vel por mais de dez anos.</i>  <i>Juntamente com meu colega Vladimir Solodov, fizemos este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> na confer√™ncia Heisenbug.</i>  <i>Ele tamb√©m me ajudou a preparar este texto.</i> <br><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> anterior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> descrevemos quais m√©todos o Badoo usa para testar a integra√ß√£o com provedores de pagamento, dos quais temos mais de 70. Neste artigo, falaremos mais sobre como conseguimos obter automa√ß√£o est√°vel e barata de testar servi√ßos pagos em um aplicativo iOS. <br><br>  Vamos come√ßar com uma descri√ß√£o geral de nossa pesquisa: <br><br><ol><li>  Defini√ß√£o do problema <br></li><li>  Declara√ß√£o do problema <br></li><li>  Solu√ß√£o No. 1.  Apple Sandbox <br></li><li>  Decis√£o n√∫mero 2.  M√©todo de simula√ß√£o de fun√ß√£o e uso de um objeto falso <br></li><li>  Avalia√ß√£o da decis√£o: principais riscos <br></li><li>  Resultado <br></li><li>  Conclus√£o <br></li></ol><br><h2>  Defini√ß√£o do problema </h2><br>  A automa√ß√£o precisa ser feita quando surgir uma necessidade natural.  Quando esse momento veio conosco? <br><br>  Existem muitos recursos gratuitos no aplicativo Badoo, mas os pagos oferecem ao usu√°rio mais op√ß√µes.  Eles os obt√™m de duas maneiras: para empr√©stimos - a moeda interna do Badoo - ou adquirindo uma assinatura premium.  Para um determinado n√∫mero de cr√©ditos, voc√™ pode elevar seu perfil nos resultados da pesquisa para o primeiro lugar, fazer um presente para outro usu√°rio e muito mais.  A assinatura premium √© v√°lida por um certo per√≠odo de tempo e oferece v√°rias op√ß√µes ao mesmo tempo: ativar o modo invisibilidade, ver pessoas que demonstraram simpatia por voc√™, cancelar o resultado do seu voto e outras. <br><br>  Esses recursos apareceram no Badoo gradualmente.  H√° alguns anos, testamos servi√ßos pagos em aplicativos iOS apenas manualmente.  Por√©m, √† medida que os recursos e as novas telas aparecem, o teste manual leva cada vez mais tempo.  Os requisitos para altera√ß√µes no aplicativo vieram de lados diferentes: dos desenvolvedores do lado do cliente, dos desenvolvedores do lado do servidor e at√© do pr√≥prio fornecedor da Apple.  Para um testador, uma itera√ß√£o de teste come√ßou a levar cerca de oito horas.  Tornou-se imposs√≠vel obter um feedback r√°pido para um desenvolvedor em sua filial em 30 minutos, o que poderia afetar negativamente a competitividade do produto. <br><br>  Quer√≠amos obter os resultados do teste o mais r√°pido poss√≠vel.  E eles encontraram um problema: como organizar o teste de regress√£o de servi√ßos pagos em nossos aplicativos iOS de forma barata, a fim de obter resultados r√°pidos e est√°veis? <br><br><h2>  Declara√ß√£o do problema </h2><br>  Portanto, levando em considera√ß√£o as especificidades do nosso processo de entrega do produto final e o tamanho da equipe, queremos: <br><br><ul><li>  Teste todas as compras no aplicativo cliente (pagamentos √∫nicos e assinaturas); <br></li></ul><br><ul><li>  repita as itera√ß√µes do teste de 10 a 20 vezes por dia; <br></li><li>  Obtenha resultados de teste ~ 150 scripts de teste em menos de meia hora; <br></li><li>  se livrar do barulho; <br></li><li>  poder executar testes em uma ramifica√ß√£o espec√≠fica do c√≥digo do desenvolvedor, independentemente dos resultados de outras execu√ß√µes. <br></li></ul><br>  Agora que formulamos a tarefa, √© hora de come√ßar a jornada para o maravilhoso mundo dos engenheiros e suas solu√ß√µes. <br><br><h2>  Solu√ß√£o No. 1.  Apple Sandbox </h2><br>  Primeiro, come√ßamos a procurar informa√ß√µes sobre a organiza√ß√£o de testes autom√°ticos de servi√ßos pagos na documenta√ß√£o da Apple.  E eles n√£o encontraram nada.  O suporte √† automa√ß√£o parece muito escasso.  Se algo aparecer, ser√° dif√≠cil configurar a automa√ß√£o com as ferramentas propostas (lembre-se de pelo menos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UIAutomation</a> , bem como o momento em que o primeiro utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">xcrun simctl</a> do iOS Simulator apareceu) e voc√™ precisar√° procurar solu√ß√µes de engenharia, inclusive no segmento de c√≥digo aberto. <br><br>  Na documenta√ß√£o da Apple para testar servi√ßos pagos, voc√™ pode encontrar apenas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apple Sandbox</a> .  N√£o ficou claro como vincular essa sandbox √† automa√ß√£o, mas decidimos pesquisar seriamente essa solu√ß√£o.  O fato de a sandbox do Android ser est√°vel nos deu confian√ßa e, nessa √©poca, j√° t√≠nhamos escrito testes com sucesso no Android.  Talvez a caixa de areia da Apple seja t√£o boa? <br><br>  Mas quando implementamos autotestes usando essa sandbox, bebemos por completo.  Vamos analisar rapidamente os principais problemas. <br><br><h3>  1. O pool de usu√°rios de teste </h3><br>  A principal limita√ß√£o para automa√ß√£o foram os recursos do conte√∫do no pool de usu√°rios de teste, o que deve garantir a independ√™ncia do lan√ßamento dos autotestes. <br><br>  Para executar apenas uma compra autom√°tica de uma assinatura, precisamos: <br><br><ol><li>  leve um novo usu√°rio para autoriza√ß√£o na sandbox; <br></li><li>  alterar no simulador o atual ID Apple vinculado; <br></li><li>  Fa√ßa login no Badoo com o Badoo <br></li><li>  acesse a tela de compra da assinatura e selecione um produto; <br></li><li>  Confirme a compra e fa√ßa login via Apple ID; <br></li><li>  verifique se a compra foi bem-sucedida; <br></li><li>  envie usu√°rio do Badoo para limpeza; <br></li><li>  limpe o usu√°rio da sandbox das assinaturas. <br></li></ol><br>  Se voc√™ tentar usar imediatamente o mesmo usu√°rio no pr√≥ximo teste, ser√° imposs√≠vel comprar uma segunda assinatura.  Voc√™ precisa esperar at√© a primeira assinatura "ficar ruim" ou cancelar a inscri√ß√£o nas configura√ß√µes.  Como dissemos no primeiro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> , o sandbox tem um per√≠odo de validade de assinatura espec√≠fico.  Se voc√™ comprar uma assinatura "por um m√™s", precisar√° aguardar cinco minutos para fech√°-la automaticamente.  O processo de cancelamento de inscri√ß√£o tamb√©m n√£o √© r√°pido. <br><br>  Assim, para uma nova execu√ß√£o do mesmo teste, precisaremos esperar at√© que a assinatura termine ou levar outro usu√°rio "limpo".  Se queremos executar dois testes simultaneamente, independentemente um do outro, precisamos ter pelo menos dois usu√°rios de sandbox no pool.  Portanto, para executar 100 testes autom√°ticos em paralelo em 100 threads, precisamos de 100 usu√°rios diferentes. <br><br>  E agora vamos imaginar que estamos executando um autoteste em dois agentes, cada um dos quais pode execut√°-los em 100 threads.  Nesse caso, precisamos de pelo menos 200 usu√°rios! <br><br><h3>  2. Notifica√ß√µes "ruins" </h3><br>  Bem, o que diabos n√£o est√° brincando!  Organizamos um pool de usu√°rios e come√ßamos a observar como os testes s√£o executados.  Eles ca√≠ram ao longo da estrada, mas a maioria - por novas raz√µes desconhecidas para n√≥s.  Come√ßamos a entender e percebemos que, ao autorizar, confirmar uma compra e trabalhar como usu√°rio na sandbox, a App Store envia alertas: por exemplo, solicita um novo nome de usu√°rio e senha, confirma a autoriza√ß√£o clicando no bot√£o "OK", fornece informa√ß√µes sobre um erro interno com o bot√£o "OK" .  √Äs vezes eles aparecem, √†s vezes n√£o.  E se eles aparecerem, sempre em uma ordem diferente. <br><br><img src="https://habrastorage.org/webt/sq/tu/1j/sqtu1ja-altpboz3pcudwnz8flm.gif"><br><br>  Como √© poss√≠vel que um erro suspeito seja simplesmente ignorado em um autoteste?  E se ocorrer um erro real, o que devo fazer?  Essa √°rea se tornou automaticamente uma ‚Äúzona cega‚Äù para n√≥s, e tivemos que escrever manipuladores especiais para todos os alertas poss√≠veis que pudessem chegar da App Store. <br><br>  Tudo isso tornou os testes mais lentos: <br><br><ul><li>  alertas podem chegar a diferentes etapas do cen√°rio de teste, destruindo a id√©ia principal do teste - cen√°rio de teste previs√≠vel;  tivemos que adicionar um manipulador de erros que esperava que uma poss√≠vel s√©rie de alertas ignorados conhecidos aparecesse; <br></li><li>  √†s vezes, novas varia√ß√µes de alertas chegavam ou outros erros ocorriam; portanto, t√≠nhamos que reiniciar os testes interrompidos;  isso aumentou o tempo de execu√ß√£o de todos os testes. <br></li></ul><br><h3>  3. Houve um teste? </h3><br>  Portanto, os usu√°rios no pool s√£o bloqueados e limpos por n minutos.  Executamos testes em 120 threads e j√° existem muitos usu√°rios no pool, mas isso n√£o √© suficiente.  Criamos nosso sistema de gerenciamento de usu√°rios, manipulamos alertas e, depois, a TI aconteceu.  A sandbox ficou indispon√≠vel por alguns dias para qualquer usu√°rio de teste. <br><br>  Ningu√©m esperava isso.  E essa foi a √∫ltima gota no c√°lice de nossa paci√™ncia, que finalmente matou o amor pela caixa de areia da Apple e nos fez embarcar no caminho para o outro lado do bem e do mal.  Percebemos que n√£o precis√°vamos dessa automa√ß√£o e que n√£o quer√≠amos mais sofrer com essa decis√£o perigosa. <br><br><h2>  Decis√£o n√∫mero 2.  M√©todo de simula√ß√£o de fun√ß√£o e uso de um objeto falso </h2><br>  Ent√£o, tivemos problemas com a automa√ß√£o na caixa de areia da Apple.  Mas n√£o pense que no mundo m√≥vel tudo est√° completamente ruim.  No Android, a sandbox √© muito mais est√°vel - voc√™ pode executar autotestes l√°. <br><br>  Vamos tentar encontrar outra solu√ß√£o para iOS.  Mas como olhar?  Onde procurar?  Vejamos a hist√≥ria dos testes e desenvolvimento de software: o que aconteceu com o mundo louco da Apple?  O que dizem as pessoas que escreveram v√°rios livros e conquistaram autoridade no mundo da automa√ß√£o e desenvolvimento de software? <br><br>  Lembrei-me imediatamente do trabalho ‚ÄúxUnit Test Patterns: Refactoring Test Code‚Äù, escrito por Gerard Mesaroche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">revis√£o de</a> Martin Fowler), - na minha opini√£o, um dos melhores livros para qualquer testador que conhe√ßa pelo menos uma linguagem de programa√ß√£o de alto n√≠vel e queira fazer automa√ß√£o .  Alguns cap√≠tulos deste livro dedicados a testar o SUT isoladamente de outros componentes do aplicativo, que s√£o nossa ‚Äúcaixa preta‚Äù, podem nos ajudar. <br><br><h3>  1. Introdu√ß√£o ao mocha e fake </h3><br>  Deve-se notar que, no mundo dos testes autom√°ticos, n√£o existe um limite geralmente aceito entre os conceitos de Duplas de teste, Stub de teste, Spy de teste, Objeto mock, Objeto falso e Objeto fict√≠cio.  Voc√™ deve sempre considerar a terminologia do autor.  Precisamos apenas de dois conceitos do grande mundo do Test Doubles: uma fun√ß√£o simulada e um objeto falso.  O que √© isso  E por que precisamos disso?  N√≥s damos uma breve defini√ß√£o desses conceitos para que n√£o tenhamos discord√¢ncias. <br><br>  Suponha que tenhamos um aplicativo e um componente integrados, o que √© para n√≥s uma "caixa preta".  Dentro do aplicativo, podemos chamar fun√ß√µes acessando este componente e obtendo os resultados dessas fun√ß√µes.  Dependendo do resultado, nosso aplicativo reage de uma maneira espec√≠fica.  √Äs vezes, o resultado da execu√ß√£o da fun√ß√£o pode ser uma entidade inteira com v√°rios campos que refletem os dados reais do usu√°rio. <br><br>  Substitui√ß√£o de uma fun√ß√£o por qualquer outra que retorne o resultado desejado, vamos chamar de simula√ß√£o da fun√ß√£o, ou simplesmente simula√ß√£o.  Essas fun√ß√µes podem ter a mesma assinatura, mas s√£o duas fun√ß√µes diferentes. <br><br>  E a substitui√ß√£o da entidade obtida como resultado da fun√ß√£o por uma entidade falsa (contendo os dados necess√°rios nos campos e, √†s vezes, at√© dados corrompidos) ser√° chamada de implementa√ß√£o de um objeto falso.  Voc√™ pode ler mais sobre isso no livro que mencionei acima ou em qualquer outro comp√™ndio de testes e desenvolvimento de software. <br><br>  Para finalizar, vamos enfatizar alguns recursos do uso de fun√ß√µes simuladas e objetos falsos: <br><br><ol><li>  Para molhar as fun√ß√µes, voc√™ precisa acessar o c√≥digo-fonte e saber como o aplicativo funciona com o componente de dentro para o desenvolvedor. <br></li><li>  Para implementar um objeto falso, voc√™ precisa conhecer a estrutura do objeto real. <br></li><li>  O uso da fun√ß√£o de simula√ß√£o permite uma configura√ß√£o flex√≠vel do aplicativo com o componente. <br></li><li>  O uso de um objeto falso permite dotar uma entidade de quaisquer propriedades. <br></li></ol><br>  O m√©todo moki e objeto falso √© ideal para isolar a opera√ß√£o de um componente dentro de um aplicativo.  Vamos ver como podemos aplicar esse m√©todo para resolver nosso problema, onde a App Store ser√° o componente.  Devido √†s peculiaridades do uso desse m√©todo, precisamos primeiro estudar a natureza do trabalho de nossa aplica√ß√£o com o componente e, depois, a implementa√ß√£o t√©cnica para criar mokeys espec√≠ficos e objetos falsos. <br><br><h2>  2. Como acontece uma compra real </h2><br>  Antes de come√ßarmos a descrever a intera√ß√£o de todas as partes do sistema, vamos destacar os principais atores: <br><br><ul><li>  usu√°rio do aplicativo - qualquer ator que executa a√ß√µes com o aplicativo, pode ser uma pessoa ou um script que executa as instru√ß√µes necess√°rias; <br></li><li>  aplicativo (no nosso caso, usamos o aplicativo iOS do Badoo instalado no simulador do iOS); <br></li><li>  servidor - um ator que processa solicita√ß√µes do aplicativo e envia respostas ou notifica√ß√µes ass√≠ncronas sem uma solicita√ß√£o do cliente (nesse caso, queremos dizer um servidor Badoo abstrato para simplificar a estrutura); <br></li><li>  A App Store √© um ator que √© uma "caixa preta" para n√≥s: n√£o sabemos como ela √© organizada, mas conhecemos sua interface p√∫blica para processar compras dentro do aplicativo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrutura StoreKit</a> ) e tamb√©m sabemos como verificar dados em um servidor Apple. <br></li></ul><br>  Vamos ver como a compra ocorre.  Todo o processo pode ser visto no diagrama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kw/1l/tg/kw1ltgj7slrlftse7zykm-hrlec.png" width="600"></div><br>  <i><font color="gray">Figura 1. Esquema de pagamento na App Store</font></i> <br><br>  Descreveremos passo a passo as principais a√ß√µes dos atores. <br><br>  1. O ponto de partida √© o estado de todos os atores antes de abrir a tela com uma lista de produtos. <br><br>  O que √© essa tela e como chegamos nela? <br><br>  Suponha que um usu√°rio encontre uma pessoa interessante, abra seu perfil, escreva uma mensagem e deseje enviar um presente.  Enviar um presente √© um servi√ßo pago.  O usu√°rio pode rolar o perfil at√© a se√ß√£o para enviar presentes ou selecionar imediatamente um presente no chat. <br><br>  Se o usu√°rio selecionar um presente e n√£o tiver dinheiro na conta, ele ver√° uma lista de diferentes pacotes de empr√©stimos (Assistente de pagamentos) para compra.  O ponto de partida no nosso exemplo √© uma lista de presentes.  No diagrama, podemos considerar esse ponto em qualquer tela antes de mostrar a lista de produtos para a compra de empr√©stimos ou assinaturas. <br><br>  2. Abrindo uma lista de produtos. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hn/9y/e-/hn9ye-ipwd_pblpxfgbawcpebok.jpeg" width="500"></div><br>  Estamos no ponto de partida, por exemplo, na lista de presentes.  O usu√°rio seleciona um dos presentes no aplicativo.  O aplicativo faz uma solicita√ß√£o ao nosso servidor para obter uma lista dos poss√≠veis pacotes de empr√©stimos para identifica√ß√£o do produto (100, 550, 2000, 5000).  O servidor retorna essa lista para o aplicativo. <br><br>  Em seguida, o aplicativo envia a lista de IDs do produto recebida para verifica√ß√£o ao ator da App Store (estrutura iOS do sistema StoreKit que vai para o servidor Apple).  Ele retorna uma lista de produtos comprovados - e, como resultado, o aplicativo mostra ao usu√°rio a lista final de pacotes de empr√©stimos com √≠cones e pre√ßos. <br><br>  3. Sele√ß√£o de produtos e gera√ß√£o de recibos. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/3j/jd/ua3jjdi5ifqqc0n6fiaqmg3elvq.jpeg" width="500"></div><br>  O usu√°rio seleciona um produto pago.  A App Store exige comprovante de compra e autoriza√ß√£o via Apple ID.  Ap√≥s a autoriza√ß√£o bem-sucedida do usu√°rio, o controle √© transferido para o aplicativo.  O aplicativo est√° aguardando a gera√ß√£o de um recibo dentro de seu pr√≥prio pacote.  O usu√°rio neste momento v√™ o sol, que bloqueia a tela.  Esse recibo foi gerado pode ser entendido usando o m√©todo appStoreReceiptURL da classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bundle</a> .  Ap√≥s a verifica√ß√£o ser gerada pela App Store, o aplicativo seleciona a verifica√ß√£o de seu pacote e envia uma solicita√ß√£o com a verifica√ß√£o e os dados do usu√°rio ao servidor Badoo. <br><br>  4. Verificando a verifica√ß√£o no servidor Badoo. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/4l/ag/qw4laggdbnz4zswxh-b6eopdk-y.jpeg" width="500"></div><br>  Assim que o servidor Badoo recebe a verifica√ß√£o e os dados do usu√°rio, ele os envia de volta ao lado do servidor Apple para realizar o primeiro ciclo de verifica√ß√£o.  Esta √© uma das recomenda√ß√µes da Apple.  Ent√£o, neste primeiro ciclo de verifica√ß√£o, o servidor recebe informa√ß√µes sobre o status atual da assinatura. <br><br>  5. Enviar notifica√ß√µes por push (notifica√ß√£o por push) do servidor. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/ne/ou/yqneoujlb2271__24hinousfjz8.jpeg" width="500"></div><br>  O servidor Badoo processa novamente as informa√ß√µes recebidas ap√≥s a verifica√ß√£o pela Apple e envia ao aplicativo uma resposta junto com uma notifica√ß√£o por push. <br><br>  6. Notifica√ß√£o por push no aplicativo. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/mx/vq/mwmxvqn6zutjpg45rmcq6tibudc.jpeg" width="500"></div><br>  Se foi uma compra de empr√©stimos, imediatamente o saldo do usu√°rio no aplicativo ser√° alterado e ele ver√° o presente enviado no chat.  Se foi uma compra de assinatura, o usu√°rio deve aguardar a notifica√ß√£o por push final de que a assinatura est√° ativada. <br><br><h3>  3. Determina√ß√£o de depend√™ncias e loop de teste </h3><br><br>  Para uma discuss√£o mais aprofundada, apresentamos mais dois conceitos - a depend√™ncia externa e o circuito de teste. <br><br><h4>  Depend√™ncia externa </h4><br>  Por depend√™ncias externas, entendemos qualquer intera√ß√£o com um componente, que √© para n√≥s uma "caixa preta".  Nesse caso, a App Store atua como um componente na forma de uma estrutura de sistema iOS (StoreKit), com a qual nosso aplicativo iOS funciona, e um servidor Apple, para onde as solicita√ß√µes de verifica√ß√£o v√£o. <br><br>  Gerenciar essas depend√™ncias em condi√ß√µes reais √© imposs√≠vel, o aplicativo √© for√ßado a responder aos sinais de sa√≠da da caixa preta (veja a Fig. 2). <br><br>  Temos tr√™s depend√™ncias externas: <br><br><ol><li>  Verificando os produtos StoreKit. <br></li><li>  Recebendo e Substituindo um Recibo de Compra. <br></li><li>  Verificando uma verifica√ß√£o em um servidor Badoo. <br></li></ol><br><img src="https://habrastorage.org/webt/ix/dd/mr/ixddmrcv7pwgene4fw12269cfeg.jpeg"><br>  <i><font color="gray">Figura 2. Depend√™ncias externas</font></i> <br><br><h4>  Circuito de teste </h4><br>  Circuito de teste - s√£o se√ß√µes do caminho que percorreremos e verificaremos durante o processo de teste. <br><br><img src="https://habrastorage.org/webt/26/m3/_u/26m3_uxzsdcrewtozcmgqihwbyu.jpeg"><br>  <i><font color="gray">Figura 3. Loop de teste</font></i> <br><br>  O objetivo do nosso trabalho na elimina√ß√£o de depend√™ncias √© construir um circuito de teste o mais pr√≥ximo poss√≠vel do caminho real e permitir excluir todas as depend√™ncias externas e transferir o controle para o seu lado. <br><br>  Consideramos cada depend√™ncia em sequ√™ncia. <br><br><h3>  4. Isolamento de depend√™ncias: implementa√ß√£o t√©cnica </h3><br>  Em nossa empresa, para a implementa√ß√£o de pagamentos, foi adotado um conceito de PPP, baseado na interface do Provedor de Pagamentos.  Essa √© a interface principal para interagir com o ator da App Store (StoreKit) dentro de nosso aplicativo, que possui dois m√©todos principais: <br><br><ol><li>  preparar √© o m√©todo respons√°vel pela verifica√ß√£o dos produtos; <br></li><li>  makePayment √© um m√©todo que processa uma compra no aplicativo. <br></li></ol><br>  Todos os pagamentos no iOS foram refatorados de acordo com esse conceito, o que nos permitiu obter um Provedor de Pagamento Simulado de classe simples e conveniente.  Essa √© a interface principal para interagir com uma c√≥pia conveniente do comportamento do StoreKit dentro de nosso aplicativo.  O que significa "c√≥pia conveniente"?  Esse provedor possui zombarias dos m√©todos de prepara√ß√£o e makePayment que fazem o que queremos.  Vejamos um exemplo de partes de c√≥digo, como conseguimos integrar o moki. <br><br><h4>  Depend√™ncia n¬∫ 1.  Verificando produtos StoreKit </h4><br>  Para verificar a lista de produtos, use a fun√ß√£o de prepara√ß√£o, que retorna uma lista de produtos verificados.  Podemos usar a simula√ß√£o na qual desativamos a verifica√ß√£o e retornamos a lista de produtos recebidos como totalmente verificada.  Assim, a depend√™ncia ser√° eliminada. <br><br><img src="https://habrastorage.org/webt/nr/nd/xj/nrndxjbquf5uuddom1zw4pcwkky.jpeg"><br>  <i><font color="gray">Figura 4. O primeiro esquema de elimina√ß√£o de depend√™ncia</font></i> <br><br>  No topo da arquitetura em nosso aplicativo est√° o Provedor de Pagamentos.  Ele reflete a interface de um poss√≠vel provedor no aplicativo.  O c√≥digo para implementar o mok pode ser encontrado na classe Mock Payment Provider. <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> receipt: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storeKitTransactionID: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> products } ... }</code> </pre> <br>  <i><font color="gray">Listagem 1. Mock client check</font></i> <br><br>  No provedor de pagamento simulado, podemos ver a implementa√ß√£o do m√©todo de prepara√ß√£o.  A m√°gica do moka acaba sendo muito simples: o m√©todo ignorou a verifica√ß√£o de produtos no lado StoreKit e simplesmente retorna uma lista de produtos recebida.  A implementa√ß√£o real de prepara√ß√£o √© semelhante a esta: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> validatedProducts = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.productsSource.validate(products: products) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> validatedProducts }</code> </pre><br>  <i><font color="gray">Listagem 2. Fornecedor de pagamento em loja real</font></i> <br><br><h3>  Depend√™ncia No. 2.  Recebendo e Substituindo um Recibo de Compra </h3><br>  A segunda depend√™ncia √© um pouco mais complicada: precisamos remover a autoriza√ß√£o primeiro para n√£o manter o pool de contas de usu√°rio e, de alguma forma, obter a verifica√ß√£o propriamente dita.  Podemos simplesmente excluir o formul√°rio de autoriza√ß√£o: <br><br><img src="https://habrastorage.org/webt/ir/zr/ak/irzrakxn_kx2ylzcdaudvux5pv4.jpeg"><br>  <i><font color="gray">Figura 5. Excluindo um formul√°rio de autoriza√ß√£o ao efetuar um pagamento</font></i> <br><br>  N√£o √© t√£o simples com um cheque.  H√° muitas perguntas: <br><br><ol><li>  Como obter antecipadamente um recibo do produto certo? <br></li><li>  Se recebemos o cheque, quando e como anex√°-lo ao aplicativo? <br></li></ol><br>  Aqui, o ator "Usu√°rio" tem um novo papel - controle de qualidade.  Quando executamos o teste, n√£o podemos apenas clicar nos bot√µes da interface, mas tamb√©m chamar os m√©todos de API da estrutura de teste (m√©todos que simulam a√ß√µes do usu√°rio) e os servi√ßos de API REST (m√©todos que podem fazer m√°gica com o servi√ßo interno do Badoo).  No Badoo, usamos uma ferramenta API de controle de qualidade muito poderosa (voc√™ pode encontrar todos os seus recursos no link: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://vimeo.com/116931200</a> ).  √â ele quem nos ajuda nos testes e verifica o produto certo no lado do servidor do Badoo.  O servidor Badoo √© o melhor local para gerar verifica√ß√µes: h√° criptografia e descriptografia da verifica√ß√£o, para que o servidor saiba tudo sobre essa estrutura de dados. <br><br>  Depois de recebermos um cheque falso, podemos coloc√°-lo atrav√©s de uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">porta traseira</a> no lado do aplicativo.  Em seguida, o aplicativo enviar√° um cheque falso junto com os dados do usu√°rio para o nosso servidor. <br><br><img src="https://habrastorage.org/webt/uu/h5/03/uuh503gnoqehjqguhzjhydujvs8.jpeg"><br>  <i><font color="gray">Figura 6. Esquema para recebimento</font></i> <br><br>  Como isso se tornou tecnicamente poss√≠vel? <br><br>  1. Para configurar um cheque falso no aplicativo, pudemos usar um backdoor que salvou o cheque falso no campo MockPaymentProvider do recibo: <br><br><pre> <code class="swift hljs">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">BUILD_FOR_AUTOMATION</span></span> <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BadooAppDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMockPurchaseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> receipt: String?)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">PaymentProvidersFactory</span></span>.useMockPaymentProviderForITunesPayments = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt = receipt } ... } #endif</code> </pre> <br>  <i><font color="gray">Listagem 3. Backdoor de verifica√ß√£o falsa</font></i> <br><br>  2. O aplicativo p√¥de fazer nosso cheque gra√ßas ao MockPaymentProvider, no qual usamos a simula√ß√£o makePayment e o cheque salvo no MockPaymentProvider.receipt: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePayment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transaction: BPDPaymentTransactionContext)</span></span></span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receiptData = <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt?.data(using: .utf8) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">BPDPurchaseReceiptRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.networkService.send(request, completion: { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (<span class="hljs-number"><span class="hljs-number">_</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sSelf = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receipt = request.responsePayload() { sSelf.delegate?.paymentProvider(sSelf, didReceiveReceipt: receipt) } }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate?.paymentProvider(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailTransaction: transaction) } } }</code> </pre> <br>  <i><font color="gray">Listagem 4. Chamando um moka de processamento de compras com um cheque falso</font></i> <br><br>  3. Conseguir um cheque falso <br><br>  Para obter uma verifica√ß√£o falsa, usamos o m√©todo no servidor (consulte a Listagem 5).  √â necess√°ria uma matriz padr√£o com dados para gerar dados de verifica√ß√£o e inclui os dados necess√°rios para um produto espec√≠fico. <br><br><pre> <code class="php hljs">$new_receipt_model = array_replace_recursive( <span class="hljs-comment"><span class="hljs-comment">//       $this-&gt;getDefaultModel(), //       //,      $this-&gt;enrichModelUsingSubscription($nr), //        $this-&gt;enrichModelUsingInput($input) ); //  $new_receipt = $this-&gt;signReceipt( json_encode($new_receipt_model, true), $new_receipt_model );</span></span></code> </pre><br>  <i><font color="gray">Listagem 5. Parte do servidor da gera√ß√£o de verifica√ß√£o</font></i> <br><br>  Para repetir a estrutura de uma verifica√ß√£o real, a verifica√ß√£o personalizada enviada pelo aplicativo deve ser criptografada usando um certificado.  Usamos nosso certificado de trabalho em vez do certificado da Apple. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt, $response)</span></span></span><span class="hljs-function">  </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     base64 $receipt = 'Subject: ' . base64_encode(json_encode($response)) . PHP_EOL . PHP_EOL . $receipt; file_put_contents($receipt_file, $receipt); ... //    $sign_result = openssl_pkcs7_sign( $receipt_file, $signed_receipt_file, 'file://'.$path_cert, 'file://'.$path_key, [], PKCS7_BINARY); ... //  $signed_content_with_headers = file_get_contents($signed_receipt_file); list($headers, $signed_content) = explode(PHP_EOL . PHP_EOL, $signed_content_with_headers); //  return str_replace(["\r\n", "\r", "\n"], '', $signed_content); }</span></span></code> </pre><br>  <i><font color="gray">Listagem 6. M√©todo para assinar uma verifica√ß√£o com um certificado</font></i> <br><br>  4. Como resultado, no teste, obtemos: <br><br><pre> <code class="ruby hljs">(<span class="hljs-regexp"><span class="hljs-regexp">/       "((\d+) |  (\d+) ?/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|service_type|</span></span> <span class="hljs-comment"><span class="hljs-comment">#    service_details = parse_options(service_type) #  QA API (  Badoo) receipt = QaApi::Billing.order_get_app_store_receipt(service_details) #   Backdoors.set_fake_receipt(receipt) end</span></span></code> </pre><br>  <i><font color="gray">Lista 7. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Etapa de</a> teste do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gherkin</a> para a estrutura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cucumber</a></font></i> <br><br><h3>  Depend√™ncia n¬∫ 3.  Verificando uma verifica√ß√£o em um servidor Badoo </h3><br>  Para remover a terceira depend√™ncia, voc√™ precisa se livrar da verifica√ß√£o do cheque no servidor.  √â importante lembrar que a verifica√ß√£o √© feita em duas etapas.  No primeiro est√°gio, a verifica√ß√£o √© autenticada com base em assinaturas e certificados.  No segundo - o cheque √© enviado para a App Store.  Em caso de valida√ß√£o bem-sucedida nesta fase, receberemos uma verifica√ß√£o descriptografada que pode ser processada. <br><br><img src="https://habrastorage.org/webt/pd/9g/p_/pd9gp_uz1kjnsb9rsk9weczdngw.jpeg"><br>  <i><font color="gray">Figura 7. Removendo a verifica√ß√£o do servidor</font></i> <br><br>  Primeiro, o servidor executa a verifica√ß√£o inicial da verifica√ß√£o no m√©todo confirmReceiptByCert da classe pai.  Isso verifica a assinatura com o certificado da App Store.  No caso de uma verifica√ß√£o falsa, essa verifica√ß√£o falhar√° porque foi assinada pelo nosso certificado e chamaremos o m√©todo de verifica√ß√£o com o certificado local confirmReceiptByLocalCert.  Nesse m√©todo, tentaremos descriptografar a verifica√ß√£o usando um certificado local e, se for bem-sucedido, colocaremos o resultado da descriptografia no campo interno local_receipt da classe filho (m√©todo addLocallyVerifiedReceipt). <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">)  </span></span>{ $result = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceiptByCert($receipt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result === <span class="hljs-number"><span class="hljs-number">-1</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($result)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;verifyReceiptByLocalCert($receipt); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyReceiptByLocalCert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt)</span></span></span><span class="hljs-function"> </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addLocallyVerifiedReceipt($receipt, base64_decode($response)); } unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">) </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  <i><font color="gray">Listagem 8. Verifica√ß√£o inicial</font></i> <br><br>  Durante a verifica√ß√£o secund√°ria (confirmReceipt), obtemos o valor do campo local_receipt da classe filho getLocallyVerifiedReceipt.  Se n√£o estiver vazio, usaremos seu valor como resultado da verifica√ß√£o. <br><br>  Se o campo estiver vazio, chamaremos a verifica√ß√£o secund√°ria da classe <i>pai</i> ( <i>parent</i> :: confirmReceipt).  L√°, solicitamos √† App Store a verifica√ß√£o do seu lado.  O resultado da verifica√ß√£o em ambos os casos √© uma verifica√ß√£o descriptografada. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getLocallyVerifiedReceipt($receipt_encoded); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($response)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode($response, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceipt($receipt_encoded, $shared_secret, $env); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_sendRequest($receipt_encoded, $shared_secret, $env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response; }</code> </pre> <br>  <i><font color="gray">Listagem 9. Verifica√ß√£o secund√°ria</font></i> <br><br><h3>  5. Teste de v√≠deo: compra de empr√©stimos e assinaturas </h3><br><h4>  Teste n√∫mero 1.  Compra de Assinaturas </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Quando <br></td><td>  Fa√ßo login no aplicativo como um novo usu√°rio com uma foto <br></td></tr><tr><td>  E <br></td><td>  Gero uma nova verifica√ß√£o de cobran√ßa de assinatura de um m√™s <br></td></tr><tr><td>  E <br></td><td>  Eu vou no meu perfil <br></td></tr><tr><td>  Ent√£o <br></td><td>  Verifique se a assinatura est√° desativada <br></td></tr><tr><td>  Quando <br></td><td>  Eu abro a lista de produtos <br></td></tr><tr><td>  E <br></td><td>  Eu compro um pacote de assinatura de um m√™s <br></td></tr><tr><td>  Ent√£o <br></td><td>  Verifico a notifica√ß√£o de compra bem-sucedida <br></td></tr><tr><td>  E <br></td><td>  Garanto que a assinatura est√° ativada <br></td></tr></tbody></table></div><br>  Teste de execu√ß√£o de v√≠deo: <br><br><img src="https://habrastorage.org/webt/xc/ut/ag/xcutagbl8qmu9wzgva0zop2xqg0.gif"><br><h4>  Teste n√∫mero 2.  Comprando empr√©stimos e enviando um presente </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Quando <br></td><td>  Fa√ßo login no aplicativo como um novo usu√°rio com uma foto <br></td></tr><tr><td>  E <br></td><td>  Eu adiciono dez cr√©ditos ao meu perfil <br></td></tr><tr><td>  E <br></td><td>  Eu gero uma nova verifica√ß√£o de cr√©dito para 550 cr√©ditos <br></td></tr><tr><td>  E <br></td><td>  Eu crio um novo usu√°rio Leela <br></td></tr><tr><td>  E <br></td><td>  Leela votou Sim em mim <br></td></tr><tr><td>  E <br></td><td>  Vou para Pessoas pr√≥ximas e abro um perfil de Leela <br></td></tr><tr><td>  E <br></td><td>  Eu voto "Sim" para Leela <br></td></tr><tr><td>  Ent√£o <br></td><td>  Verifico a p√°gina da partida <br></td></tr><tr><td>  Quando <br></td><td>  Eu escolho enviar um presente regular <br></td></tr><tr><td>  Ent√£o <br></td><td>  Verifico a tela de pagamento com uma lista de pacotes <br></td></tr><tr><td>  Quando <br></td><td>  Eu escolho comprar 550 cr√©ditos <br></td></tr><tr><td>  Ent√£o <br></td><td>  Verifico a notifica√ß√£o de compra bem-sucedida <br></td></tr><tr><td>  E <br></td><td>  Garanto que Leela recebeu um presente de bate-papo <br></td></tr></tbody></table></div><br><br>  Teste de execu√ß√£o de v√≠deo: <br><br><img src="https://habrastorage.org/webt/jb/dl/oj/jbdlojncgj656usnr5bsylaese4.gif"><br><br><h2>  Avalia√ß√£o da decis√£o: principais riscos </h2><br>  A remo√ß√£o de depend√™ncias externas acarreta certos riscos. <br><br>  1. Configura√ß√£o incorreta. <br><br>  Como a verifica√ß√£o n√£o est√° do nosso lado, podemos configurar nossos produtos incorretamente no lado da Apple.  Para nos proteger do erro, escrevemos um teste de unidade separado do lado do servidor, que verifica se todos os produtos que iniciamos no lado da Apple correspondem aos produtos que temos em nossa configura√ß√£o. <br><br>  2. Casos fronteiri√ßos. <br><br>  Por exemplo, quando o pagamento √© totalmente conclu√≠do, o usu√°rio recebe uma notifica√ß√£o de que ele foi conclu√≠do, mas nosso aplicativo n√£o consegue encontrar o cheque que deve ser falsificado como resultado do pagamento.  O risco est√° no fato de n√≥s mesmos anexarmos a verifica√ß√£o com a ajuda de uma porta dos fundos e, naturalmente, n√£o podemos rastrear esse caso.  Para compensar de alguma forma esse risco, realizamos verifica√ß√µes completas usando a sandbox ou um pagamento real ap√≥s o lan√ßamento. <br><br>  3. Falsifica√ß√£o injusta ou fraude. <br><br>  Depois de ler este artigo, voc√™ pode pensar que, como o Badoo usa cheques falsos, voc√™ pode anexar algo falso a n√≥s e usar o servi√ßo gratuitamente.  Para que esse risco n√£o se concretize, assinamos tudo com nosso pr√≥prio certificado e limitamos o uso de moks e verifica√ß√µes falsas a testes funcionais executados apenas em nosso ambiente de desenvolvimento. <br><br>  4. Altere o formato da verifica√ß√£o. <br><br>  Esse √© o risco mais s√©rio.  √â poss√≠vel alterar o formato de um cheque quando a Apple altera algo sem nos avisar.  Tivemos um caso assim: ao mudar para o iOS 11, o formato da verifica√ß√£o mudou completamente.  Geramos uma verifica√ß√£o falsa em nosso servidor e a usamos no teste.  Tudo estava perfeito conosco: todos os campos est√£o no lugar, tudo √© maravilhoso, tudo est√° sendo processado.  Mas quando mudamos para o sistema real, nada funcionou.  Os campos significativos na verifica√ß√£o simplesmente deixaram de existir. <br><br>  Como compensar esse risco?  Em primeiro lugar, n√£o exclu√≠mos a possibilidade de teste de ponta a ponta da sandbox antes do lan√ßamento e pagamento real ap√≥s o lan√ßamento.  Agora, estamos na fase ativa de um projeto para verificar as notifica√ß√µes, quando tentamos classificar todas as verifica√ß√µes que recebemos da produ√ß√£o com base no fato de entendermos o que √© ou n√£o.  Se a resposta for n√£o, ent√£o come√ßamos a processar tudo manualmente, ver o que mudou, o que est√° errado, o que precisa ser alterado em nosso sistema. <br><div class="scrollable-table"><table><tbody><tr><td>  Risco <br></td><td>  Raz√£o <br></td><td>  Como compensar <br></td></tr><tr><td>  configura√ß√£o incorreta <br></td><td>  excluir cheque <br></td><td>  teste de unidade no servidor <br></td></tr><tr><td>  casos de borda <br>  (cheque n√£o entregue) <br></td><td>  usar backdoor <br></td><td>  Cheques E2E (sandbox e pagamento real) <br></td></tr><tr><td>  fraude fraudulenta, fraude <br></td><td>  notifica√ß√£o e gera√ß√£o de verifica√ß√£o no servidor <br></td><td>  certificado pr√≥prio <br></td></tr><tr><td>  alterar formato de verifica√ß√£o <br></td><td>  notifica√ß√£o e gera√ß√£o de verifica√ß√£o no servidor <br></td><td>  verifica√ß√£o de notifica√ß√µes reais e verifica√ß√£o do produto (novo projeto), <br>  Cheques E2E (sandbox e pagamento real) <br></td></tr></tbody></table></div><br><h2>  Resultado </h2><br><br>  Considere as principais vantagens que conseguimos obter como resultado da aplica√ß√£o do m√©todo moki e do objeto falso. <br><br><h4>  Automa√ß√£o barata, r√°pida e est√°vel de servi√ßos pagos no iOS </h4><br>  Juntamente com a equipe de testes manuais do iOS (agradecimentos especiais a Colin Chan), conseguimos escrever mais de 150 testes autom√°ticos para pagamentos.  Essa √© uma quantidade bastante grande de cobertura para uma √°rea do aplicativo. <br><br>  Gra√ßas √† paraleliza√ß√£o, podemos obter o resultado em apenas 15 a 20 minutos em qualquer filial do desenvolvedor do cliente iOS ou do servidor de cobran√ßa.  Antes da automa√ß√£o, o teste manual dessa √°rea por uma pessoa levava oito horas. <br><br>  Tamb√©m podemos testar a grande maioria dos casos de teste, configurando o Mock Payment Provider atrav√©s do moki da maneira que precisamos.  Com a ajuda de mooks, aprendemos como desativar a verifica√ß√£o do produto e simular casos quando a verifica√ß√£o √© parcialmente realizada.  Assim, abrimos casos que antes n√£o pod√≠amos testar em princ√≠pio. <br><br><h4>  Regress√£o funcional no desenvolvimento de novos recursos </h4><br>  A automa√ß√£o funcionou muito bem nesses casos em que o desenvolvedor no processo de trabalhar em um novo recurso afetou a funcionalidade antiga.  Tivemos um exemplo quando um desenvolvedor fez um recurso complexo com cache e executou nossos testes autom√°ticos.  Alguns deles ca√≠ram no erro.  Ele viu e consertou.  Ent√£o ele reiniciou os autotestes novamente - e novamente, algo caiu.  Como resultado, ele fez uma s√©rie de itera√ß√µes at√© o momento em que tudo come√ßou a funcionar normalmente no lado do aplicativo. <br><br><h4>  Regress√£o funcional na refatora√ß√£o de pagamentos </h4><br>  Talvez a automa√ß√£o mais bem-sucedida e eficiente poss√≠vel ocorra no campo da refatora√ß√£o de c√≥digo.  Nesse caso, apenas a implementa√ß√£o interna √© alterada - n√£o h√° necessidade de alterar o c√≥digo de autoteste.  A interface do usu√°rio n√£o muda de forma alguma e os autotestes podem ser conduzidos com efici√™ncia. <br><br><h4>  Testando recursos experimentais da Apple: per√≠odo de car√™ncia </h4><br>  Um sistema semelhante √© completamente intercambi√°vel quando voc√™ testa novas integra√ß√µes que ainda n√£o foram implementadas na sandbox.  Assim foi com o per√≠odo de car√™ncia.  Essa funcionalidade n√£o est√° na sandbox.  O per√≠odo de car√™ncia na Apple ainda n√£o est√° dispon√≠vel para todos.  Este √© um projeto piloto que o Badoo est√° implementando com a Apple.  Para verificar com um per√≠odo de cortesia, precisamos adicionar aqui uma parte do c√≥digo JSON: <br><br><pre> <code class="json hljs">pending_renewal_info:[ { expiration_intent: <span class="hljs-number"><span class="hljs-number">2</span></span> grace_period_expires_date: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> Etc/GMT auto_renew_product_id: badoo.productId original_transaction_id: <span class="hljs-number"><span class="hljs-number">560000361869085</span></span> is_in_billing_retry_period: <span class="hljs-number"><span class="hljs-number">1</span></span> grace_period_expires_date_pst: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> America/Los_Angeles product_id: badoo.productId grace_period_expires_date_ms: <span class="hljs-number"><span class="hljs-number">1556207457000</span></span> auto_renew_status: <span class="hljs-number"><span class="hljs-number">1</span></span> }]</code> </pre><br>  <i><font color="gray">Listagem 10. Per√≠odo de car√™ncia para uma assinatura</font></i> <br><br>  Fizemos isso com muita facilidade em apenas alguns segundos.  Em nosso sistema, fomos capazes de testar nossa rea√ß√£o a um novo recurso.  Agora estamos executando essa funcionalidade no prod. <br><br><h4>  Teste de qualidade do produto em m√©todos de composi√ß√£o </h4><br>  Como resultado de nossa pesquisa, fomos capazes de descrever um m√©todo que elimina o ru√≠do de depend√™ncias externas.  Isso ajudou os desenvolvedores de clientes no processo de desenvolvimento de recursos a encontrar erros nos est√°gios iniciais. <br><br>  Mas n√£o pense que fomos capazes de testar tudo com esse m√©todo.  Para testar tudo, √© melhor usar uma composi√ß√£o de m√©todos: teste com um cart√£o real no produto, teste na caixa de areia, m√©todo de mokes e objetos falsos, teste de unidade e integra√ß√£o.  Lembre-se do equil√≠brio da pir√¢mide de teste e n√£o tente resolver todos os problemas com um m√©todo.  Isso pode levar a uma automa√ß√£o triste na caixa de areia, a testes manuais tristes com um cart√£o real de todos os casos e a muitos outros erros graves no local exato em que sua apar√™ncia √© mais dolorosa. <br><br><h2>  Conclus√£o </h2><br>  Como resultado de nossa pesquisa, obtivemos um m√©todo barato, r√°pido e est√°vel de testar n√£o apenas servi√ßos pagos no iOS, mas tamb√©m quaisquer componentes incorporados ao aplicativo como uma "caixa preta".  Agora, no Badoo, estamos implementando esse m√©todo para testes em provedores pagos do Android (Global Charge, Boku, Centili) que possuem sandboxes inst√°veis ‚Äã‚Äãou outras restri√ß√µes.  Tamb√©m usamos o m√©todo moki para testar publicidade, streaming e geolocaliza√ß√£o. <br><br>  Vale dizer que o processo de introdu√ß√£o de um novo m√©todo n√£o foi r√°pido.  Eu tive que negociar com quatro equipes: controle de qualidade do iOS, desenvolvedor de iOS, controle de qualidade de faturamento, desenvolvedor de faturamento.  Nem todo mundo queria mudar para um novo m√©todo, temendo riscos.  √Äs vezes, era um seguimento dogm√°tico: durante muitos anos testamos na caixa de areia, e a principal for√ßa que poderia destruir o dogma era o desejo dos testadores de cobran√ßa e da plataforma iOS de mudar a situa√ß√£o e se livrar do tormento.  Posteriormente, os desenvolvedores perceberam essas vantagens desse m√©todo, como diagn√≥stico preciso (n√£o conseguimos encontrar bugs no sandbox, mas bugs de nosso cliente ou servidor), flexibilidade na configura√ß√£o do componente (conseguimos testar facilmente casos negativos no n√≠vel de integra√ß√£o) e, √© claro, a resposta foi 30 minutos em uma ramifica√ß√£o com c√≥digo desenvolvido. <br><br>  Muito obrigado a todos que leram at√© o fim.  Muito obrigado a todos que ajudaram e participaram deste projeto.  Agradecimentos especiais a essas pessoas: <br><br><ul><li>  Peter Kolpashchikov √© um desenvolvedor iOS que ajudou a criar moki no lado do cliente e desenvolveu um conceito de PPP; <br></li><li>  Vladimir Solodov - Controle de qualidade de cobran√ßa, que ajudou na API de controle de qualidade para gerar cheques e caixas falsos no servidor de cobran√ßa; <br></li><li>  Maxim Filatov e Vasily Stepanov - equipe de desenvolvimento de cobran√ßa, que ajudou no c√≥digo do servidor de cobran√ßa; <br></li><li>  Equipe de desenvolvimento do iOS - desenvolvedores que foram capazes de refatorar nossos pagamentos em um novo conceito, possibilitando o uso de mokas; <br></li><li>  A equipe de controle de qualidade do iOS √© uma incr√≠vel equipe de testes que escreveu v√°rios autotestes; <br></li><li>  Equipe de QA de cobran√ßa - testadores que ajudaram a pesquisar problemas. <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460667/">https://habr.com/ru/post/pt460667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460651/index.html">Reuni√£o da Sociedade de Testadores An√¥nimos: TMS, monitoramento, monitoramento, avalia√ß√£o da qualidade da pesquisa e testes iOS nativos</a></li>
<li><a href="../pt460655/index.html">Como quebrei o Telegram</a></li>
<li><a href="../pt460659/index.html">Usando Tubos para Giro</a></li>
<li><a href="../pt460661/index.html">Tudo o que voc√™ precisa saber sobre o Node.js</a></li>
<li><a href="../pt460665/index.html">Rascunho de FAQ: Por que os padr√µes C ++ s√£o lan√ßados a cada tr√™s anos?</a></li>
<li><a href="../pt460669/index.html">Como garantir a seguran√ßa do desenvolvimento, economizando tempo e nervosismo</a></li>
<li><a href="../pt460671/index.html">Propriedade e empr√©stimos em D</a></li>
<li><a href="../pt460673/index.html">Expor a magia do DiffUtil</a></li>
<li><a href="../pt460675/index.html">Extra√ß√£o de dados de aprendizado de m√°quina</a></li>
<li><a href="../pt460683/index.html">Projetor de Eventos Laravel e conceito de gera√ß√£o de eventos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>