<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòù ü¶ë ‚ÜòÔ∏è Toda la verdad sobre RTOS. Art√≠culo # 26. Canales: servicios auxiliares y estructuras de datos. üíº üßòüèø ü§∏üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, continuaremos considerando los canales de transmisi√≥n de datos. 

 Servicios de soporte de canales 
 Nucleus RTOS tiene cuatro llama...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art√≠culo # 26. Canales: servicios auxiliares y estructuras de datos.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433374/"><img src="https://habrastorage.org/webt/ok/ll/ke/okllkejturanltd2yqnjeofmqxu.jpeg"><br><br>  En este art√≠culo, continuaremos considerando los canales de transmisi√≥n de datos. <br><br><h2>  Servicios de soporte de canales </h2><br>  Nucleus RTOS tiene cuatro llamadas API que proporcionan funciones auxiliares relacionadas con los canales: restablecer un canal, recibir informaci√≥n del canal, obtener el n√∫mero de canales en una aplicaci√≥n y obtener punteros a todos los canales en una aplicaci√≥n.  Las primeras tres funciones se implementan en Nucleus SE. <br><a name="habracut"></a><br>  Art√≠culos anteriores de la serie: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Canales de datos: introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: servicios auxiliares y estructuras de datos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se√±ales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Particiones de memoria: servicios y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Secciones de memoria: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de datos de tareas y llamadas de API no compatibles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios para trabajar con tareas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas: configuraci√≥n e introducci√≥n a la API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: funciones avanzadas y preservaci√≥n del contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: dise√±o interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫cleo SE: Introducci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n de tareas y sincronizaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci√≥n.</a> <br><br><h3>  Restablecimiento de canal </h3><br>  Esta llamada a la API restablece el canal a su estado original no utilizado.  Cualquier mensaje almacenado en √©l se perder√°.  Cualquier tarea suspendida en el canal se reanuda con el c√≥digo de retorno <b>NUSE_PIPE_WAS_RESET</b> . <br><br>  <b><i>Llamada de restablecimiento de canal en Nucleus RTOS</i></b> <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Reset_Pipe (tuber√≠a NU_PIPE *);</b> <br><br>  Par√°metros: <br><br>  <b>pipe</b> : un puntero a un bloque de control de canal definido por el usuario. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_PIPE</b> : puntero de canal no v√°lido. <br><br>  <b><i>Desaf√≠o de restablecimiento de canal en Nucleus SE</i></b> <br><br>  Esta llamada de servicio API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NUSE_Pipe_Reset (tuber√≠a NUSE_PIPE);</b> <br><br>  Par√°metros: <br><br>  <b>pipe</b> es el √≠ndice (ID) de la <b>tuber√≠a que se</b> cae. <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_PIPE</b> : √≠ndice de canal no v√°lido. <br><br>  <b><i>Implementaci√≥n de restablecimiento de canal en Nucleus SE</i></b> <br><br>  El c√≥digo para la funci√≥n <b>NUSE_Pipe_Reset ()</b> (despu√©s de verificar los par√°metros) es bastante simple.  Los √≠ndices de inicio y finalizaci√≥n del canal, as√≠ como el contador de mensajes en el canal, se establecen en 0. <br><br>  Si se activa el bloqueo de tareas, el c√≥digo adicional es responsable de restaurar las tareas suspendidas: <br><br><pre><code class="plaintext hljs">while (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this pipe */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_PIPE_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Pipe_Blocking_Count[pipe]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  A cada tarea suspendida en el canal se le asigna el estado "listo" con el c√≥digo de retorno <b>NUSE_PIPE_WAS_RESET</b> .  Una vez completado este proceso, si se utiliza el planificador prioritario, se <b>llama a la</b> funci√≥n <b>NUSE_Reschedule ()</b> , ya que una o m√°s tareas con alta prioridad pueden estar listas para su ejecuci√≥n. <br><br><h3>  Informaci√≥n del canal </h3><br>  Esta llamada de servicio devuelve informaci√≥n del canal.  La implementaci√≥n de esta llamada en Nucleus SE difiere de Nucleus RTOS en que devuelve menos informaci√≥n.  Esto se debe a que Nucleus SE no admite los nombres de objetos, los mensajes de longitud variable y el orden de pausa de la tarea, y la pausa de la tarea se puede deshabilitar. <br><br>  <b><i>Llame para obtener informaci√≥n del canal en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Pipe_Information (NU_PIPE * pipe, CHAR * name, VOID ** start_address, UNSIGNED * pipe_size, UNSIGNED * available, UNSIGNED * messages, OPTION * message_type, UNSIGNED * message_size, OPTION * suspend_type, UNSIGNED * task_waask</b> <br><br>  Par√°metros: <br><br>  <b>pipe</b> - puntero al bloque de control de canal proporcionado por el usuario; <br>  <b>nombre</b> : puntero al √°rea de 8 caracteres para el nombre del mensaje del canal; <br>  <b>start_address</b> : un puntero a un puntero en el que se escribir√° la direcci√≥n del comienzo del √°rea de datos del canal; <br>  <b>pipe_size</b> : un puntero a una variable para almacenar el n√∫mero total de bytes en el canal; <br>  <b>disponible</b> : apunta a una variable para almacenar el n√∫mero de bytes disponibles en el canal; <br>  <b>mensajes</b> : un puntero a una variable para almacenar el n√∫mero de mensajes en el canal; <br>  <b>message_type</b> : un puntero a una variable para almacenar el tipo de mensaje admitido por el canal.  Puede tomar los valores <b>NU_FIXED_SIZE</b> y <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> : puntero a una variable para almacenar el n√∫mero de bytes en cada mensaje de canal.  Si el canal admite mensajes de longitud variable, este n√∫mero ser√° el tama√±o m√°ximo del mensaje; <br>  <b>suspend_type</b> : puntero a una variable para almacenar el tipo de tarea de suspensi√≥n.  Puede tomar los valores <b>NU_FIFO</b> y <b>NU_PRIORITY</b> ; <br>  <b>task_waiting</b> : un puntero a una variable para almacenar el n√∫mero de tareas suspendidas en este canal; <br>  <b>first_task</b> : un puntero a un puntero a la primera tarea en pausa. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_PIPE</b> : puntero de canal no v√°lido. <br><br>  <b><i>Llame para obtener informaci√≥n del canal en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>STATUS NUSE_Pipe_Information (tuber√≠a NUSE_PIPE, ADDR * start_address, U8 * pipe_size, U8 * disponible, U8 * messages, U8 * message_size, U8 * tareas_waiting, NUSE_TASK * first_task);</b> <br><br>  Par√°metros: <br><br>  <b>pipe</b> - √≠ndice del canal, informaci√≥n sobre la cual se solicita; <br>  <b>start_address</b> : puntero a una variable de tipo <b>ADDR</b> para almacenar la direcci√≥n del comienzo del √°rea de datos del canal; <br>  <b>pipe_size</b> : un puntero a una variable de tipo <b>U8</b> para almacenar el n√∫mero total de mensajes que puede recibir el canal; <br>  <b>disponible</b> : un puntero a una variable de tipo <b>U8</b> para almacenar la cantidad de mensajes para los que queda espacio libre en el canal; <br>  <b>mensajes</b> : un puntero a una variable de tipo <b>U8</b> para almacenar el n√∫mero actual de mensajes en el canal; <br>  <b>message_size</b> : puntero a una variable de tipo <b>U8</b> para almacenar el tama√±o de los mensajes procesados ‚Äã‚Äãpor este canal; <br>  <b>task_waiting</b> : un puntero a una variable para almacenar el n√∫mero de tareas suspendidas en este canal (no se devuelve nada si la suspensi√≥n de tareas est√° desactivada); <br>  <b>first_task</b> : un puntero a una variable del tipo <b>NUSE_TASK</b> , que tomar√° el √≠ndice de la primera tarea suspendida (no se devuelve nada si la suspensi√≥n de la tarea est√° desactivada). <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_PIPE</b> : √≠ndice de canal no v√°lido; <br>  <b>NUSE_INVALID_POINTER</b> : uno o m√°s par√°metros de puntero son incorrectos. <br><br>  <b><i>Implementaci√≥n de informaci√≥n del canal en Nucleus SE</i></b> <br><br>  Implementar esta llamada a la API es bastante simple: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Pipe_Data[pipe]; *pipe_size = NUSE_Pipe_Size[pipe]; *available = NUSE_Pipe_Size[pipe] - NUSE_Pipe_Items[pipe]; *messages = NUSE_Pipe_Items[pipe]; *message_size = NUSE_Pipe_Message_Size[pipe]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Pipe_Blocking_Count[pipe]; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  La funci√≥n devuelve el estado del canal.  Luego, si se activan los bloqueos de tareas, se devuelve el n√∫mero de tareas pendientes y el √≠ndice de la primera de ellas (de lo contrario, estos dos par√°metros se establecen en 0). <br><br><h3>  Obtener el n√∫mero de canales </h3><br>  Esta llamada de servicio devuelve el n√∫mero de canales configurados en la aplicaci√≥n.  En Nucleus RTOS, este valor puede cambiar con el tiempo, y el valor de retorno indicar√° el n√∫mero actual de canales.  En Nucleus SE, el valor de retorno se establece durante la fase de construcci√≥n y no se puede cambiar. <br><br>  <b><i>Solicite un contador de canales en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br><br>  <b>NO FIRMADO NU_Established_Pipes (VOID);</b> <br><br>  Par√°metros: <br>  Est√°n ausentes <br><br>  Valor de retorno: <br>  El n√∫mero de canales creados en el sistema. <br><br>  <b><i>Llame para obtener un contador de canales en Nucleus SE</i></b> <br>  Esta llamada de utilidad admite la funcionalidad principal de la API Nucleus RTOS <br><br>  Prototipo de llamada de servicio: <br>  <b>U8 NUSE_Pipe_Count (nulo);</b> <br><br>  Par√°metros: <br>  Est√°n ausentes <br><br>  Valor de retorno: <br>  El n√∫mero de canales configurados en la aplicaci√≥n. <br><br>  <b><i>Implementaci√≥n de un contador de canales en Nucleus SE</i></b> <br>  La implementaci√≥n de esta llamada a la API es bastante simple: se <b>devuelve</b> el valor del s√≠mbolo <b>#define</b> <b>NUSE_PIPE_NUMBER</b> . <br><br><h2>  Estructuras de datos </h2><br>  Los canales usan seis o siete estructuras de datos (que est√°n en RAM o en ROM), que son (como otros objetos de Nucleus SE) un conjunto de tablas, cuyo tama√±o y n√∫mero corresponde al n√∫mero de canales configurados y sus par√°metros. <br><br>  Recomiendo encarecidamente que el c√≥digo de la aplicaci√≥n no utilice el acceso directo a estas estructuras de datos, sino que se refiera a ellas a trav√©s de las funciones API proporcionadas.  Esto evitar√° la incompatibilidad con futuras versiones de Nucleus SE y los efectos secundarios no deseados, adem√°s de simplificar la transferencia de aplicaciones a Nucleus RTOS.  La siguiente es una descripci√≥n detallada de las estructuras de datos para simplificar la comprensi√≥n de la llamada de servicio y el c√≥digo de depuraci√≥n. <br><br><h3>  Datos del kernel en RAM </h3><br>  Estos datos tienen la siguiente estructura: <br><br>  <b>NUSE_Pipe_Head []</b> es una matriz de punteros del tipo <b>U8</b> , que tiene una entrada para cada canal configurado e indica el comienzo del canal del mensaje.  Se utiliza como √≠ndice de direcci√≥n en <b>NUSE_Pipe_Data []</b> (ver m√°s abajo). <br>  <b>NUSE_Pipe_Tail []</b> es una matriz <b>U8</b> que tiene una entrada para cada canal configurado y apunta al final del canal del mensaje.  Se utiliza como √≠ndice de direcci√≥n en <b>NUSE_Pipe_Data []</b> (ver m√°s abajo). <br>  <b>NUSE_Pipe_Items []</b> es una matriz de tipo <b>U8</b> , que tiene una entrada para cada canal configurado y es un contador del n√∫mero actual de mensajes en el canal.  Estos datos son redundantes, ya que este valor se puede obtener a trav√©s de los √≠ndices de inicio y final del canal, pero la presencia de un contador simplifica el c√≥digo. <br>  <b>NUSE_Pipe_Blocking_Count []</b> : esta matriz de tipo <b>U8</b> contiene contadores del n√∫mero de tareas bloqueadas en cada canal.  Esta matriz solo se crea si el soporte de bloqueo de tareas est√° activado. <br><br>  Todas estas estructuras de datos se inicializan con ceros mediante la funci√≥n <b>NUSE_Init_Pipe ()</b> cuando se inicia Nucleus SE.  Esto es l√≥gico, ya que todos los canales se crean vac√≠os (sin usar).  Uno de los siguientes art√≠culos contendr√° una descripci√≥n completa de los procedimientos de inicio de Nucleus SE. <br><br>  Las siguientes son las definiciones de estas estructuras de datos en el archivo <b>nuse_init.c</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Pipe_Head[NUSE_PIPE_NUMBER]; RAM U8 NUSE_Pipe_Tail[NUSE_PIPE_NUMBER]; RAM U8 NUSE_Pipe_Items[NUSE_PIPE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Pipe_Blocking_Count[NUSE_PIPE_NUMBER]; #endif</code> </pre><br><h3>  Datos de usuario RAM </h3><br>  Es responsabilidad del usuario proporcionar un √°rea de datos en la RAM para almacenar los datos de cada canal configurado.  El tama√±o de esta √°rea debe contener una matriz de tipo <b>U8</b> , en la que caben todos los mensajes del canal. <br><br><h3>  Datos ROM </h3><br>  La estructura de estos datos es la siguiente: <br><br>  <b>NUSE_Pipe_Data []</b> es una matriz de tipo <b>ADDR</b> que tiene un registro para cada canal configurado e indica el √°rea de datos de cada canal (consulte la secci√≥n "Datos de usuario en RAM" m√°s arriba). <br>  <b>NUSE_Pipe_Size []</b> es una matriz de tipo <b>U8</b> , que tiene una entrada para cada canal configurado y muestra la cantidad de mensajes que pueden caber en cada canal. <br>  <b>NUSE_Pipe_Message_Size []</b> es una matriz de tipo <b>U8</b> que tiene un registro para cada canal configurado y muestra el tama√±o de los mensajes (en bytes) que se pueden colocar en cada canal. <br><br>  Estas estructuras de datos se declaran e inicializan (est√°ticamente) en el archivo <b>nuse_config.c</b> , por lo tanto: <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Pipe_Data[NUSE_PIPE_NUMBER] = { /* addresses of pipe data areas ------ */ }; ROM U8 NUSE_Pipe_Size[NUSE_PIPE_NUMBER] = { /* pipe sizes ------ */ }; ROM U8 NUSE_Pipe_Message_Size[NUSE_PIPE_NUMBER] = { /* pipe message sizes ------ */ };</code> </pre><br><h3>  Memoria de canal </h3><br>  Al igual que todos los dem√°s objetos centrales de Nucleus SE, la cantidad de memoria necesaria para los canales es predecible. <br><br>  La cantidad de datos en ROM (en bytes) para todos los canales en la aplicaci√≥n se puede calcular de la siguiente manera: <br><br>  <b>NUSE_PIPE_NUMBER * (sizeof (ADDR) + 2)</b> <br><br>  La cantidad de datos del kernel en RAM (en bytes) para todos los canales de aplicaci√≥n cuando se activan las tareas se puede calcular de la siguiente manera: <br><br>  <b>NUSE_PIPE_NUMBER * 4</b> <br><br>  De lo contrario: <br><br>  <b>NUSE_PIPE_NUMBER * 3</b> <br><br>  La cantidad de datos de usuario en RAM (en bytes) para el canal con el √≠ndice de <b>canalizaci√≥n</b> : <br><br>  <b>NUSE_Pipe_Size [tuber√≠a] * NUSE_Pipe_Message_Size [tuber√≠a]</b> <br><br><h2>  Llamadas API no realizadas </h2><br>  Cuatro llamadas de servicio API Nucleus RTOS no se implementan en Nucleus SE. <br><br><h3>  Creaci√≥n de canales </h3><br>  Esta llamada a la API crea un canal.  Nucleus SE no necesita esto porque los canales se crean est√°ticamente. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Create_Pipe (NU_PIPE * pipe, CHAR * name, VOID * start_address, UNSIGNED pipe_size, OPTION message_type, UNSIGNED message_size, OPTION suspend_type);</b> <br><br>  Par√°metros: <br><br>  <b>pipe</b> : un puntero al bloque de control de canal proporcionado por el usuario; se usar√° como activador del canal principal en otras llamadas API; <br>  <b>nombre</b> : puntero a un nombre de canal de 7 caracteres con un cero final; <br>  <b>start_address</b> : direcci√≥n de inicio del canal; <br>  <b>pipe_size</b> : el n√∫mero total de bytes en el canal; <br>  <b>message_type</b> : tipo de mensaje admitido por el canal.  Puede tomar los valores <b>NU_FIXED_SIZE</b> o <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> : si el canal admite mensajes de longitud fija, este par√°metro indica el tama√±o exacto de cada mensaje.  De lo contrario, si el canal admite mensajes de longitud variable, este valor ser√° el tama√±o m√°ximo del mensaje; <br>  <b>suspend_type</b> : indica el tipo de suspensi√≥n de tareas en el canal.  Puede tomar los valores <b>NU_FIFO</b> y <b>NU_PRIORITY</b> (planificador FIFO y planificador <b>PRIORITY</b> , respectivamente). <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_PIPE</b> : puntero nulo a la unidad de control de canal ( <b>NULL</b> ), o la unidad de control ya est√° en uso; <br>  <b>NU_INVALID_MEMORY</b> : se especific√≥ un √°rea de datos incorrecta en <b>start_address</b> ; <br>  <b>NU_INVALID_MESSAGE</b> : par√°metro de tipo de <b>mensaje</b> no v√°lido; <br>  <b>NU_INVALID_SIZE</b> : el tama√±o del mensaje es mayor que el tama√±o del canal o el tama√±o del canal o del mensaje es cero; <br>  <b>NU_INVALID_SUSPEND</b> : par√°metro inv√°lido <b>suspend_type</b> . <br><br><h3>  Eliminar canal </h3><br>  Esta llamada a la API elimina un canal creado previamente.  Nucleus SE no lo necesita porque los canales se crean est√°ticamente y no se pueden eliminar. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Delete_Pipe (tuber√≠a NU_PIPE *);</b> <br><br>  Par√°metros: <br>  <b>pipe</b> : un puntero a un bloque de control de canal. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_PIPE</b> : puntero de canal no v√°lido. <br><br><h3>  Punteros de canal </h3><br>  Esta llamada a la API crea una lista secuencial de punteros a todos los canales del sistema.  En Nucleus SE, no es necesario, ya que los canales se identifican mediante un √≠ndice simple, no un puntero, por lo tanto, dicha funci√≥n ser√≠a redundante. <br><br>  Prototipo de llamada de servicio: <br>  <b>NU_Pipe_Pointers SIN FIRMAR (NU_PIPE ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Par√°metros: <br>  <b>pointer_list</b> : puntero a una matriz de punteros <b>NU_PIPE</b> .  Esta matriz se llenar√° con punteros a canales creados previamente en el sistema; <br>  <b>punteros m√°ximos</b> : el n√∫mero m√°ximo de punteros en la matriz. <br><br>  Valor de retorno: <br>  El n√∫mero de punteros <b>NU_PIPE</b> en la matriz <br><br><h3>  Transmitir a un canal </h3><br>  Esta llamada a la API pasa el mensaje a todas las tareas que esperan mensajes de un canal espec√≠fico.  En Nucleus SE, esta caracter√≠stica no se ha implementado ya que agrega complejidad redundante. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Broadcast_To_Pipe (tuber√≠a NU_PIPE *, mensaje VOID *, tama√±o SIN FIRMAR, suspensi√≥n SIN FIRMAR);</b> <br><br>  Par√°metros: <br>  <b>tuber√≠a</b> : un puntero a un bloque de control de canal; <br>  <b>mensaje</b> : puntero al mensaje transmitido; <br>  <b>tama√±o</b> : el n√∫mero de elementos de datos <b>NO FIRMADOS</b> en el mensaje.  Si el canal admite mensajes de longitud variable, este par√°metro debe ser igual o menor que el tama√±o del mensaje admitido por el canal.  Si el canal admite mensajes de longitud fija, este par√°metro debe ser exactamente del tama√±o de los mensajes admitidos por el canal; <br>  <b>suspender</b> : indica si se suspende la tarea de llamada si el canal ya est√° lleno.  Puede ser <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> o un valor de tiempo de espera. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_PIPE</b> : puntero no v√°lido al canal; <br>  <b>NU_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> : el tama√±o del mensaje especificado es incompatible con el tama√±o del mensaje especificado al crear el canal; <br>  <b>NU_INVALID_SUSPEND</b> : intento de suspender un hilo no relacionado con la tarea; <br>  <b>NU_PIPE_FULL</b> : no hay suficiente espacio en el canal para el mensaje; <br>  <b>NU_TIMEOUT</b> : el canal a√∫n est√° lleno, incluso despu√©s de que haya expirado el per√≠odo de tiempo de espera especificado; <br>  <b>NU_PIPE_DELETED</b> : el canal se elimin√≥ mientras se suspendi√≥ la tarea; <br>  <b>NU_PIPE_RESET</b> : el canal se restableci√≥ mientras se suspend√≠a la tarea. <br><br><h2>  Nucleus RTOS Compatible </h2><br>  Al igual que con todos los dem√°s objetos de Nucleus SE, mi objetivo era maximizar la compatibilidad del c√≥digo de la aplicaci√≥n con Nucleus RTOS.  Los canales no son una excepci√≥n y, desde el punto de vista del usuario, se implementan de la misma manera que en Nucleus RTOS.  Tambi√©n hay una cierta incompatibilidad, que consider√© aceptable, dado que, como resultado, el c√≥digo ser√° m√°s comprensible y m√°s eficiente en t√©rminos de la cantidad de memoria requerida.  De lo contrario, las llamadas a la API de Nucleus RTOS se pueden transferir casi directamente a Nucleus SE. <br><br><h3>  Identificadores de objetos </h3><br>  En Nucleus RTOS, todos los objetos se describen mediante una estructura de datos (bloque de control) que tiene un tipo de datos espec√≠fico.  Un puntero a esta unidad de control sirve como un identificador de canal.  Decid√≠ que en Nucleus SE, se necesita un enfoque diferente para el uso eficiente de la memoria: todos los objetos del n√∫cleo se describen mediante un conjunto de tablas en RAM y / o ROM.  El tama√±o de estas tablas est√° determinado por el n√∫mero de objetos configurados de cada tipo.  El identificador de un objeto particular es el √≠ndice en esta tabla.  As√≠ que <b>defin√≠ NUSE_PIPE</b> como el equivalente de <b>U8</b> , una variable (no un puntero) de este tipo sirve como identificador de canal.  Esta ligera incompatibilidad es f√°cil de manejar si el c√≥digo se transfiere de Nucleus SE a Nucleus RTOS y viceversa.  Por lo general, no se realizan operaciones en identificadores de objetos que no sean mover y almacenar. <br><br>  Nucleus RTOS tambi√©n admite nombres de canales.  Estos nombres se usan solo para la depuraci√≥n.  Los exclu√≠ de Nucleus SE para ahorrar memoria. <br><br><h3>  Tama√±o y tipo de mensaje </h3><br>  En Nucleus RTOS, se puede configurar un canal para procesar mensajes que consisten en un n√∫mero arbitrario de bytes, al igual que Nucleus SE.  Nucleus RTOS tambi√©n admite canales de mensajes de longitud variable para los que solo se especifica el tama√±o m√°ximo del mensaje en el momento de la creaci√≥n.  Los mensajes de longitud variable no son compatibles con Nucleus SE. <br><br><h3>  Tama√±o del canal </h3><br>  En Nucleus SE, el n√∫mero m√°ximo de mensajes por canal es 256, ya que todas las variables y constantes son del tipo <b>U8</b> .  Nucleuts RTOS no tiene tales limitaciones. <br><br><h3>  Llamadas API no realizadas </h3><br>  Nucleus RTOS admite diez gastos generales de canal.  Cuatro de ellos no est√°n implementados en Nucleus SE.  Puede encontrar una descripci√≥n detallada de estas llamadas, as√≠ como los motivos de esta decisi√≥n, en la secci√≥n "Llamadas API no realizadas" anteriormente en este art√≠culo. <br><br>  En el siguiente art√≠culo consideraremos la hora del sistema. <br><br>  <b>Sobre el autor:</b> Colin Walls ha trabajado en la industria electr√≥nica durante m√°s de treinta a√±os, dedicando la mayor parte de su tiempo al firmware.  Ahora es ingeniero de firmware en Mentor Embedded (una divisi√≥n de Mentor Graphics).  Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos art√≠culos t√©cnicos y dos libros sobre firmware.  Vive en el Reino Unido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Colin</a> , correo electr√≥nico: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433374/">https://habr.com/ru/post/es433374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433364/index.html">LDraw + Unidad. C√≥mo gener√© Lego</a></li>
<li><a href="../es433366/index.html">Trabajando con recursos externos en Unity3D</a></li>
<li><a href="../es433368/index.html">C√≥mo aplicar el pensamiento de comestibles al mundo: un ejemplo de una sudadera</a></li>
<li><a href="../es433370/index.html">Teor√≠a de fragmentaci√≥n</a></li>
<li><a href="../es433372/index.html">Bicicleta de coche</a></li>
<li><a href="../es433376/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 21: Seguimiento de datos, Parte 1</a></li>
<li><a href="../es433378/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 21: Seguimiento de datos, Parte 2</a></li>
<li><a href="../es433380/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 21: Seguimiento de datos, Parte 3</a></li>
<li><a href="../es433382/index.html">[Ilustrado] Gu√≠a para la creaci√≥n de redes en Kubernetes. Parte 3</a></li>
<li><a href="../es433384/index.html">Nuestros datos personales todav√≠a se venden descaradamente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>