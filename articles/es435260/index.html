<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💭 🛁 🤙🏿 Implementación de una recarga en caliente de código C ++ en Linux ⏏️ 🏩 🚴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Enlace a la biblioteca al final del artículo. El artículo en sí describe los mecanismos implementados en la biblioteca, con detalles medios. La impl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementación de una recarga en caliente de código C ++ en Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435260/"><p><img src="https://alexpolt.github.io/images/stroustrup-didnt-plan-for-this.png" alt="imagen"></p><br><p>  * Enlace a la biblioteca al final del artículo.  El artículo en sí describe los mecanismos implementados en la biblioteca, con detalles medios.  La implementación para macOS aún no está terminada, pero no es muy diferente de la implementación para Linux.  Esto es principalmente una implementación para Linux. </p><br><p>  Caminando por el github un sábado por la tarde, me encontré con una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca</a> que implementa la actualización del código de C ++ sobre la marcha para Windows.  Yo mismo bajé de Windows hace unos años, no me arrepentí un poco, y ahora toda la programación se realiza en Linux (en casa) o en macOS (en el trabajo).  Buscando en Google un poco, descubrí que el enfoque de la biblioteca anterior es bastante popular, y msvc usa la misma técnica para la función "Editar y continuar" en Visual Studio.  El único problema es que no encontré ninguna implementación en aplicaciones que no sean Windows (¿me vi mal?).  A la pregunta al autor de la biblioteca anterior si hará un puerto para otras plataformas, la respuesta fue no. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Debo decir de inmediato</a> que solo estaba interesado en la opción en la que no tendría que cambiar el código del proyecto existente (como, por ejemplo, en el caso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RCCPP</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cr</a> , donde todo el código potencialmente recargado debería estar en una biblioteca separada cargada dinámicamente). </p><br><p>  "¿Cómo es eso?"  - Pensé, y comencé a encender incienso. </p><a name="habracut"></a><br><h2 id="zachem">  Por qué </h2><br><p>  Principalmente hago gamedev.  La mayor parte de mi tiempo de trabajo lo paso escribiendo la lógica del juego y el diseño de cualquier visual.  También uso imgui para utilidades de ayuda.  Mi ciclo de trabajo con el código, como probablemente haya adivinado, es Escribir -&gt; Compilar -&gt; Ejecutar -&gt; Repetir.  Todo sucede bastante rápido (compilación incremental, todo tipo de caché, etc.).  El problema aquí es que este ciclo debe repetirse con la suficiente frecuencia.  Por ejemplo, estoy escribiendo una nueva mecánica de juego, que sea "Jump", un Jump válido y controlado: </p><br><p>  1. Escribió un borrador de implementación basado en el impulso, ensamblado, lanzado.  Vi que accidentalmente aplico un pulso a cada cuadro, y no una vez. </p><br><p>  2. Fijo, montado, lanzado, ahora normal.  Pero sería necesario tomar más el valor absoluto del impulso. </p><br><p>  3. Fijo, montado, lanzado, funcionando.  Pero de alguna manera se siente mal.  Es necesario intentar sobre la base de la fuerza para hacer. </p><br><p>  4. Escribió un borrador de implementación basado en fuerza, ensamblado, lanzado, trabajos.  Sería necesario solo cambiar la velocidad instantánea en el momento del salto. <br>  ... </p><br><p> 10. Fijo, ensamblado, lanzado, funcionando.  Pero aún no es eso.  Probablemente necesite probar una implementación basada en un cambio en <code>gravityScale</code> . <br>  ... </p><br><p>  20. Genial, se ve super!  Ahora sacamos todos los parámetros en el editor para gamediz, prueba y relleno. <br>  ... </p><br><p>  30. El salto está listo. </p><br><p>  Y en cada iteración, debe recopilar el código y en la aplicación iniciada llegar al lugar donde puedo saltar.  Esto generalmente toma al menos 10 segundos.  Y si solo puedo saltar en un área abierta, ¿cuál aún necesita ser alcanzado?  ¿Y si necesito poder saltar sobre bloques con una altura de N unidades?  Aquí ya necesito recopilar una escena de prueba, que también debe ser depurada, y que también necesita pasar tiempo.  Es para tales iteraciones que una recarga en caliente del código sería ideal.  Por supuesto, esto no es una panacea, no es adecuado para todo, y después de reiniciar a veces necesitas recrear parte del mundo del juego, y esto debe tenerse en cuenta.  Pero en muchas cosas, esto puede ser útil y puede ahorrar atención y mucho tiempo. </p><br><h2 id="trebovaniya-i-postanovka-zadachi">  Requisitos y declaración del problema. </h2><br><ul><li>  Al cambiar el código, la nueva versión de todas las funciones debe reemplazar a las versiones anteriores de las mismas funciones. </li><li>  Esto debería funcionar en Linux y macOS </li><li>  Esto no debería requerir cambios en el código de la aplicación existente. </li><li>  Idealmente, esto debería ser una biblioteca, estática o dinámicamente vinculada a la aplicación, sin utilidades de terceros </li><li>  Es deseable que esta biblioteca no afecte mucho el rendimiento de la aplicación. </li><li>  Suficiente si esto funciona con cmake + make / ninja </li><li>  Es suficiente si funcionará con compilaciones de debazina (sin optimizaciones, sin recortar caracteres, etc.) </li></ul><br><p>  Este es el conjunto mínimo de requisitos que debe cumplir una implementación.  Mirando hacia el futuro, describiré brevemente lo que se implementó adicionalmente: </p><br><ul><li>  Transferencia de valores de variables estáticas a código nuevo (consulte la sección "Transferencia de variables estáticas" para averiguar por qué esto es importante) </li><li>  Recarga basada en dependencias (encabezado modificado -&gt; reconstruido <del>  medio proyecto </del>  todos los archivos dependientes) </li><li>  Recargar código de bibliotecas dinámicas </li></ul><br><h2 id="realizaciya">  Implementación </h2><br><p>  Hasta ese momento, estaba completamente lejos del área temática, así que tuve que recopilar y asimilar información desde cero. </p><br><p>  En un nivel alto, el mecanismo se ve así: </p><br><ul><li>  Monitoreamos el sistema de archivos para detectar cambios en la fuente </li><li>  Cuando la fuente cambia, la biblioteca la reconstruye usando el comando de compilación de que este archivo ya estaba compilado </li><li>  Todos los objetos recopilados están vinculados a una biblioteca cargada dinámicamente. </li><li>  La biblioteca se carga en el espacio de direcciones del proceso. </li><li>  Todas las funciones de la biblioteca reemplazan las mismas funciones en la aplicación. </li><li>  Los valores de las variables estáticas se transfieren de la aplicación a la biblioteca. </li></ul><br><p>  Comencemos con lo más interesante: el mecanismo de recarga de funciones. </p><br><h4 id="perezagruzka-funkciy">  Funciones de recarga </h4><br><p>  Aquí hay 3 formas más o menos populares de reemplazar funciones en (o casi) tiempo de ejecución: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Truco con LD_PRELOAD</a> : le permite construir una biblioteca cargada dinámicamente con, por ejemplo, la función <code>strcpy</code> , y hacer que cuando inicie la aplicación tome mi versión de <code>strcpy</code> lugar de la biblioteca </li><li>  Cambiar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tablas PLT y GOT</a> : le permite "sobrecargar" las funciones exportadas </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conexión de funciones</a> : le permite redirigir el hilo de ejecución de una función a otra </li></ul><br><p>  Las primeras 2 opciones, obviamente, no son adecuadas, ya que funcionan solo con funciones exportadas, y no queremos marcar todas las funciones de nuestra aplicación con ningún atributo.  ¡Por lo tanto, el enganche de funciones es nuestra opción! </p><br><p>  En resumen, el enganche funciona así: </p><br><ul><li>  La dirección de la función se encuentra </li><li>  Los primeros pocos bytes de la función se sobrescriben mediante una transición incondicional al cuerpo de otra función. </li><li>  ... </li><li>  Beneficio! <br>  En msvc hay 2 indicadores para esto: <code>/hotpatch</code> y <code>/FUNCTIONPADMIN</code> .  El primero al comienzo de cada función escribe 2 bytes, que no hacen nada, para su posterior reescritura con un "salto corto".  El segundo le permite dejar un espacio vacío frente al cuerpo de cada función en forma de instrucciones de <code>nop</code> para un "salto largo" a la ubicación deseada, por lo que en 2 saltos puede cambiar de la función anterior a la nueva.  Puede leer más sobre cómo se implementa esto en Windows y msvc, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </li></ul><br><p>  Desafortunadamente, no hay nada similar en clang y gcc (al menos en Linux y macOS).  En realidad, este no es un problema tan grande, escribiremos directamente encima de la función anterior.  En este caso, corremos el riesgo de tener problemas si nuestra aplicación es multiproceso.  Si generalmente en un entorno de subprocesos múltiples restringimos el acceso a los datos por un subproceso mientras otro subproceso los modifica, entonces debemos limitar la capacidad de ejecutar código a un subproceso mientras otro subproceso modifica este código.  No he descubierto cómo hacer esto, por lo que la implementación se comportará de manera impredecible en un entorno multiproceso. </p><br><p>  Hay un punto sutil.  En un sistema de 32 bits, 5 bytes son suficientes para "saltar" a cualquier lugar.  En un sistema de 64 bits, si no queremos estropear los registros, necesitamos 14 bytes.  La conclusión es que 14 bytes en la escala del código de máquina es bastante, y si el código tiene alguna función de código auxiliar con un cuerpo vacío, es probable que tenga menos de 14 bytes de longitud.  No sé toda la verdad, pero pasé un tiempo detrás del desensamblador mientras pensaba, escribía y depuraba el código, y noté que todas las funciones están alineadas en un límite de 16 bytes (construcción de depuración sin optimizaciones, no estoy seguro sobre el código optimizado).  Y esto significa que entre el comienzo de cualquiera de las dos funciones habrá al menos 16 bytes, lo que es suficiente para que los "atasquemos".  Google superficial condujo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> , sin embargo, no estoy seguro, tuve suerte, o hoy todos los compiladores hacen esto.  En cualquier caso, en caso de duda, simplemente declare un par de variables al comienzo de la función stub para que sea lo suficientemente grande. </p><br><p>  Entonces, tenemos el primer grano, un mecanismo para redirigir las funciones de la versión anterior a la nueva. </p><br><h4 id="poisk-funkciy-v-skopmilirovannoy-programme">  Buscar funciones en un programa copiado </h4><br><p>  Ahora necesitamos obtener de alguna manera las direcciones de todas las funciones (no solo exportadas) de nuestro programa o de una biblioteca dinámica arbitraria.  Esto se puede hacer simplemente usando la API del sistema si los caracteres no están recortados de su aplicación.  En Linux, estos son api de <code>elf.h</code> y <code>link.h</code> , en macOS, <code>loader.h</code> y <code>nlist.h</code> . </p><br><ul><li>  Usando <code>dl_iterate_phdr</code> revisamos todas las bibliotecas cargadas y, de hecho, el programa </li><li>  Encuentra la dirección donde se carga la biblioteca </li><li>  De la sección <code>.symtab</code> toda la información sobre los caracteres, a saber, el nombre, el tipo, el índice de la sección en la que se encuentra, el tamaño y también calculamos su dirección "real" en función de la dirección virtual y la dirección de carga de la biblioteca </li></ul><br><p>  Hay una sutileza.  Al descargar un archivo elf, el sistema no carga la sección <code>.symtab</code> (corregir si está mal), y la sección <code>.dynsym</code> no nos conviene, ya que no podemos extraer caracteres con la visibilidad <code>STV_INTERNAL</code> y <code>STV_HIDDEN</code> .  En pocas palabras, no veremos tales funciones: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp namespace { int someUsefulFunction(int value) // &lt;----- { return value * 2; } }</span></span></code> </pre> <br><p>  y tales variables: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp void someDefaultFunction() { static int someVariable = 0; // &lt;----- ... }</span></span></code> </pre> <br><p>  Por lo tanto, en el párrafo 3, no estamos trabajando con el programa que <code>dl_iterate_phdr</code> dio, sino con el archivo que hemos descargado del disco y analizado por algún analizador elfo (o en la api simple).  Así que no nos perdemos nada.  En macOS, el procedimiento es similar, solo los nombres de las funciones de la API del sistema son diferentes. </p><br><p>  Después de eso, filtramos todos los caracteres y guardamos solo: </p><br><ul><li>  Las funciones que se pueden volver a cargar son caracteres del tipo <code>STT_FUNC</code> ubicados en la sección <code>.text</code> , que no son de tamaño cero.  Tal filtro omite solo las funciones cuyo código está realmente contenido en este programa o biblioteca </li><li>  Las variables estáticas cuyos valores desea transferir son caracteres de tipo <code>STT_OBJECT</code> ubicados en la sección <code>.bss</code> </li></ul><br><h2 id="edinicy-translyacii">  Unidades de difusión </h2><br><p>  Para volver a cargar el código, necesitamos saber dónde obtener los archivos de código fuente y cómo compilarlos. </p><br><p>  En la primera implementación, leí esta información de la sección <code>.debug_info</code> , que contiene información de depuración en formato DWARF.  Para que cada unidad de compilación (ET) dentro de DWARF obtenga una línea de compilación para este ET, debe pasar <code>-grecord-gcc-switches</code> durante la compilación.  Enano, analicé la biblioteca libdwarf, que viene incluida con <code>libelf</code> .  Además del comando de compilación de DWARF, puede obtener información sobre las dependencias de nuestros ET en otros archivos.  Pero rechacé esta implementación por varias razones: </p><br><ul><li>  Las bibliotecas son bastante pesadas. </li><li>  Analizar una aplicación DWARF compilada a partir de ~ 500 ET, con análisis de dependencias, tomó un poco más de 10 segundos </li></ul><br><p>  10 segundos para iniciar la aplicación es demasiado.  Después de pensarlo, reescribí la lógica de analizar DWARF para analizar <code>compile_commands.json</code> .  Este archivo se puede generar simplemente agregando <code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code> a su CMakeLists.txt.  Por lo tanto, obtenemos toda la información que necesitamos. </p><br><h2 id="obrabotka-zavisimostey">  Manejo de dependencias </h2><br><p>  Como abandonamos DWARF, necesitamos encontrar otra opción, cómo manejar las dependencias entre archivos.  Realmente no quería analizar archivos con mis manos y buscar <code>include</code> en ellos, y ¿quién sabe más sobre las dependencias que el compilador en sí? </p><br><p>  Hay una serie de opciones en clang y gcc que generan los llamados depfiles casi gratis.  Estos archivos utilizan los sistemas de compilación make y ninja para resolver dependencias entre archivos.  Los archivos tienen un formato muy simple: </p><br><pre> <code class="plaintext hljs">CMakeFiles/lib_efsw.dir/libs/efsw/src/efsw/DirectorySnapshot.cpp.o: \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/base.hpp \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/sophist.h \ /home/ddovod/_private/_projects/jet/live/libs/efsw/include/efsw/efsw.hpp \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/c++/7.3.0/string \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/c++config.h \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/os_defines.h \ ...</code> </pre> <br><p>  El compilador coloca estos archivos al lado de los archivos de objetos para cada ET, nos queda analizarlos y colocarlos en un hashmap.  El análisis total de <code>compile_commands.json</code> + depfiles para el mismo 500 ET lleva un poco más de 1 segundo.  Para que todo funcione, necesitamos agregar el indicador <code>-MD</code> globalmente para todos los archivos de proyecto en la opción de compilación. </p><br><p>  Hay una sutileza asociada con ninja.  Este sistema de compilación genera archivos sin importar la presencia del indicador <code>-MD</code> para sus necesidades.  Pero después de que se generan, los traduce a su formato binario y elimina los archivos de origen.  Por lo tanto, al iniciar ninja, debe pasar el <code>-d keepdepfile</code> .  Además, por razones desconocidas para mí, en el caso de make (con la opción <code>-MD</code> ) el archivo se llama <code>some_file.cpp.d</code> , mientras que con ninja se llama <code>some_file.cpp.od</code> .  Por lo tanto, debe verificar ambas versiones. </p><br><h2 id="perenos-staticheskih-peremennyh">  Transferencia Variable Estática </h2><br><p>  Supongamos que tenemos ese código (un ejemplo muy sintético): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Singleton.hpp class Singletor { public: static Singleton&amp; instance(); }; int veryUsefulFunction(int value); // Singleton.cpp Singleton&amp; Singletor::instance() { static Singleton ins; return ins; } int veryUsefulFunction(int value) { return value * 2; }</span></span></code> </pre> <br><p>  Queremos cambiar la función <code>veryUsefulFunction</code> a esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><p>  Al recargar, en la biblioteca dinámica con código nuevo, además de <code>veryUsefulFunction</code> , la variable <code>static Singleton ins;</code>  , y el método <code>Singletor::instance</code> .  Como resultado, el programa comenzará a llamar nuevas versiones de ambas funciones.  Pero las <code>ins</code> estáticas en esta biblioteca aún no se han inicializado y, por lo tanto, la primera vez que se accede, se llamará al constructor de la clase <code>Singleton</code> .  Por supuesto, no queremos esto.  Por lo tanto, la implementación transfiere los valores de todas las variables que encuentra en la biblioteca dinámica ensamblada del código antiguo a esta biblioteca muy dinámica con el código nuevo junto con sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">variables de protección</a> . </p><br><p>  Hay un momento sutil y generalmente insoluble. <br>  Supongamos que tenemos una clase: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  El método <code>calledEachUpdate</code> llama 60 veces por segundo.  Lo cambiamos agregando un nuevo campo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; m_someVar2++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Si una instancia de esta clase se encuentra en la memoria dinámica o en la pila, después de volver a cargar el código, es probable que la aplicación se bloquee.  La instancia asignada contiene solo la variable <code>m_someVar1</code> , pero después del reinicio, el método <code>calledEachUpdate</code> intentará cambiar <code>m_someVar2</code> , cambiando lo que en realidad no pertenece a esta instancia, lo que conduce a consecuencias impredecibles.  En este caso, la lógica de transferencia de estado se transfiere al programador, que de alguna manera debe guardar el estado del objeto y eliminar el objeto en sí mismo antes de volver a cargar el código, y crear un nuevo objeto después del reinicio.  La biblioteca proporciona eventos en forma de métodos delegados <code>onCodePreLoad</code> y <code>onCodePostLoad</code> que la aplicación puede procesar. </p><br><p>  Creo que no sé cómo (y si) es posible resolver esta situación de manera general.  Ahora este caso "más o menos normal" funcionará solo para variables estáticas, utiliza la siguiente lógica: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* oldVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* newVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> oldVarSize = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> newVarSize = ...; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(newVarPtr, oldVarPtr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(oldVarSize, newVarSize));</code> </pre> <br><p>  Esto no es muy correcto, pero es lo mejor que se me ocurrió. </p><br><p>  Como resultado, el código se comportará de manera impredecible si el tiempo de ejecución cambia el conjunto y el diseño de los campos en las estructuras de datos.  Lo mismo se aplica a los tipos polimórficos. </p><br><h2 id="sobiraem-vse-vmeste">  Poniendo todo junto </h2><br><p>  Cómo funciona todo junto. </p><br><ul><li>  La biblioteca itera sobre los encabezados de todas las bibliotecas cargadas dinámicamente en el proceso y, de hecho, el programa mismo analiza y filtra caracteres. </li><li>  A continuación, la biblioteca intenta encontrar el archivo <code>compile_commands.json</code> en el directorio de la aplicación y en los directorios principales de forma recursiva, y extrae toda la información necesaria sobre ET desde allí. </li><li>  Al conocer la ruta de acceso a los archivos de objetos, la biblioteca carga y analiza los archivos. </li><li>  Después de eso, se calcula el directorio más común para todos los archivos de código fuente del programa, y ​​la supervisión de este directorio comienza de forma recursiva. </li><li>  Cuando un archivo cambia, la biblioteca busca ver si está en el hashmap de dependencias y, si lo hay, inicia varios procesos de compilación de los archivos modificados y sus dependencias en segundo plano, utilizando los comandos de compilación de <code>compile_commands.json</code> . </li><li>  Cuando el programa le pide que vuelva a cargar el código (en mi aplicación, se le asigna la combinación <code>Ctrl+r</code> ), la biblioteca espera la finalización de los procesos de compilación y vincula todos los objetos nuevos a la biblioteca dinámica. </li><li>  Esta biblioteca se carga en el espacio de direcciones del proceso <code>dlopen</code> función <code>dlopen</code> . </li><li>  La información sobre los símbolos se carga desde esta biblioteca, y toda la intersección del conjunto de símbolos de esta biblioteca y los símbolos que ya viven en el proceso se vuelve a cargar (si es una función) o se transfiere (si es una variable estática). </li></ul><br><p>  Esto funciona muy bien, especialmente cuando sabes qué hay debajo del capó y qué esperar, al menos a un alto nivel. </p><br><p>  Personalmente, me sorprendió mucho la falta de una solución para Linux, ¿alguien está realmente interesado en esto? </p><br><p>  Estaré encantado de cualquier crítica, gracias! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Enlace a la implementación</strong></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435260/">https://habr.com/ru/post/es435260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435250/index.html">Cómo funciona la Universidad ITMO: un recorrido por nuestro laboratorio ciberfísico</a></li>
<li><a href="../es435252/index.html">Jessica Livingston: “Cómo creamos Y Combinator. El componente emocional "</a></li>
<li><a href="../es435254/index.html">Manejo de errores funcionales en Kotlin usando Arrow</a></li>
<li><a href="../es435256/index.html">Calificamos a los reclutadores por letras frías</a></li>
<li><a href="../es435258/index.html">Escribimos nuestro lenguaje de programación, parte 2: representación intermedia de programas</a></li>
<li><a href="../es435262/index.html">Li-Fi: el futuro de Internet</a></li>
<li><a href="../es435264/index.html">Edición de precios en RMK. 1C: Gestión comercial 11</a></li>
<li><a href="../es435268/index.html">No me trates doctor</a></li>
<li><a href="../es435270/index.html">Mantenga seguras las llaves SSH</a></li>
<li><a href="../es435272/index.html">Ciclofobia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>