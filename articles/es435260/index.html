<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Implementaci贸n de una recarga en caliente de c贸digo C ++ en Linux 锔  </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Enlace a la biblioteca al final del art铆culo. El art铆culo en s铆 describe los mecanismos implementados en la biblioteca, con detalles medios. La impl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementaci贸n de una recarga en caliente de c贸digo C ++ en Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435260/"><p><img src="https://alexpolt.github.io/images/stroustrup-didnt-plan-for-this.png" alt="imagen"></p><br><p>  * Enlace a la biblioteca al final del art铆culo.  El art铆culo en s铆 describe los mecanismos implementados en la biblioteca, con detalles medios.  La implementaci贸n para macOS a煤n no est谩 terminada, pero no es muy diferente de la implementaci贸n para Linux.  Esto es principalmente una implementaci贸n para Linux. </p><br><p>  Caminando por el github un s谩bado por la tarde, me encontr茅 con una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca</a> que implementa la actualizaci贸n del c贸digo de C ++ sobre la marcha para Windows.  Yo mismo baj茅 de Windows hace unos a帽os, no me arrepent铆 un poco, y ahora toda la programaci贸n se realiza en Linux (en casa) o en macOS (en el trabajo).  Buscando en Google un poco, descubr铆 que el enfoque de la biblioteca anterior es bastante popular, y msvc usa la misma t茅cnica para la funci贸n "Editar y continuar" en Visual Studio.  El 煤nico problema es que no encontr茅 ninguna implementaci贸n en aplicaciones que no sean Windows (驴me vi mal?).  A la pregunta al autor de la biblioteca anterior si har谩 un puerto para otras plataformas, la respuesta fue no. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Debo decir de inmediato</a> que solo estaba interesado en la opci贸n en la que no tendr铆a que cambiar el c贸digo del proyecto existente (como, por ejemplo, en el caso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RCCPP</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cr</a> , donde todo el c贸digo potencialmente recargado deber铆a estar en una biblioteca separada cargada din谩micamente). </p><br><p>  "驴C贸mo es eso?"  - Pens茅, y comenc茅 a encender incienso. </p><a name="habracut"></a><br><h2 id="zachem">  Por qu茅 </h2><br><p>  Principalmente hago gamedev.  La mayor parte de mi tiempo de trabajo lo paso escribiendo la l贸gica del juego y el dise帽o de cualquier visual.  Tambi茅n uso imgui para utilidades de ayuda.  Mi ciclo de trabajo con el c贸digo, como probablemente haya adivinado, es Escribir -&gt; Compilar -&gt; Ejecutar -&gt; Repetir.  Todo sucede bastante r谩pido (compilaci贸n incremental, todo tipo de cach茅, etc.).  El problema aqu铆 es que este ciclo debe repetirse con la suficiente frecuencia.  Por ejemplo, estoy escribiendo una nueva mec谩nica de juego, que sea "Jump", un Jump v谩lido y controlado: </p><br><p>  1. Escribi贸 un borrador de implementaci贸n basado en el impulso, ensamblado, lanzado.  Vi que accidentalmente aplico un pulso a cada cuadro, y no una vez. </p><br><p>  2. Fijo, montado, lanzado, ahora normal.  Pero ser铆a necesario tomar m谩s el valor absoluto del impulso. </p><br><p>  3. Fijo, montado, lanzado, funcionando.  Pero de alguna manera se siente mal.  Es necesario intentar sobre la base de la fuerza para hacer. </p><br><p>  4. Escribi贸 un borrador de implementaci贸n basado en fuerza, ensamblado, lanzado, trabajos.  Ser铆a necesario solo cambiar la velocidad instant谩nea en el momento del salto. <br>  ... </p><br><p> 10. Fijo, ensamblado, lanzado, funcionando.  Pero a煤n no es eso.  Probablemente necesite probar una implementaci贸n basada en un cambio en <code>gravityScale</code> . <br>  ... </p><br><p>  20. Genial, se ve super!  Ahora sacamos todos los par谩metros en el editor para gamediz, prueba y relleno. <br>  ... </p><br><p>  30. El salto est谩 listo. </p><br><p>  Y en cada iteraci贸n, debe recopilar el c贸digo y en la aplicaci贸n iniciada llegar al lugar donde puedo saltar.  Esto generalmente toma al menos 10 segundos.  Y si solo puedo saltar en un 谩rea abierta, 驴cu谩l a煤n necesita ser alcanzado?  驴Y si necesito poder saltar sobre bloques con una altura de N unidades?  Aqu铆 ya necesito recopilar una escena de prueba, que tambi茅n debe ser depurada, y que tambi茅n necesita pasar tiempo.  Es para tales iteraciones que una recarga en caliente del c贸digo ser铆a ideal.  Por supuesto, esto no es una panacea, no es adecuado para todo, y despu茅s de reiniciar a veces necesitas recrear parte del mundo del juego, y esto debe tenerse en cuenta.  Pero en muchas cosas, esto puede ser 煤til y puede ahorrar atenci贸n y mucho tiempo. </p><br><h2 id="trebovaniya-i-postanovka-zadachi">  Requisitos y declaraci贸n del problema. </h2><br><ul><li>  Al cambiar el c贸digo, la nueva versi贸n de todas las funciones debe reemplazar a las versiones anteriores de las mismas funciones. </li><li>  Esto deber铆a funcionar en Linux y macOS </li><li>  Esto no deber铆a requerir cambios en el c贸digo de la aplicaci贸n existente. </li><li>  Idealmente, esto deber铆a ser una biblioteca, est谩tica o din谩micamente vinculada a la aplicaci贸n, sin utilidades de terceros </li><li>  Es deseable que esta biblioteca no afecte mucho el rendimiento de la aplicaci贸n. </li><li>  Suficiente si esto funciona con cmake + make / ninja </li><li>  Es suficiente si funcionar谩 con compilaciones de debazina (sin optimizaciones, sin recortar caracteres, etc.) </li></ul><br><p>  Este es el conjunto m铆nimo de requisitos que debe cumplir una implementaci贸n.  Mirando hacia el futuro, describir茅 brevemente lo que se implement贸 adicionalmente: </p><br><ul><li>  Transferencia de valores de variables est谩ticas a c贸digo nuevo (consulte la secci贸n "Transferencia de variables est谩ticas" para averiguar por qu茅 esto es importante) </li><li>  Recarga basada en dependencias (encabezado modificado -&gt; reconstruido <del>  medio proyecto </del>  todos los archivos dependientes) </li><li>  Recargar c贸digo de bibliotecas din谩micas </li></ul><br><h2 id="realizaciya">  Implementaci贸n </h2><br><p>  Hasta ese momento, estaba completamente lejos del 谩rea tem谩tica, as铆 que tuve que recopilar y asimilar informaci贸n desde cero. </p><br><p>  En un nivel alto, el mecanismo se ve as铆: </p><br><ul><li>  Monitoreamos el sistema de archivos para detectar cambios en la fuente </li><li>  Cuando la fuente cambia, la biblioteca la reconstruye usando el comando de compilaci贸n de que este archivo ya estaba compilado </li><li>  Todos los objetos recopilados est谩n vinculados a una biblioteca cargada din谩micamente. </li><li>  La biblioteca se carga en el espacio de direcciones del proceso. </li><li>  Todas las funciones de la biblioteca reemplazan las mismas funciones en la aplicaci贸n. </li><li>  Los valores de las variables est谩ticas se transfieren de la aplicaci贸n a la biblioteca. </li></ul><br><p>  Comencemos con lo m谩s interesante: el mecanismo de recarga de funciones. </p><br><h4 id="perezagruzka-funkciy">  Funciones de recarga </h4><br><p>  Aqu铆 hay 3 formas m谩s o menos populares de reemplazar funciones en (o casi) tiempo de ejecuci贸n: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Truco con LD_PRELOAD</a> : le permite construir una biblioteca cargada din谩micamente con, por ejemplo, la funci贸n <code>strcpy</code> , y hacer que cuando inicie la aplicaci贸n tome mi versi贸n de <code>strcpy</code> lugar de la biblioteca </li><li>  Cambiar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tablas PLT y GOT</a> : le permite "sobrecargar" las funciones exportadas </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conexi贸n de funciones</a> : le permite redirigir el hilo de ejecuci贸n de una funci贸n a otra </li></ul><br><p>  Las primeras 2 opciones, obviamente, no son adecuadas, ya que funcionan solo con funciones exportadas, y no queremos marcar todas las funciones de nuestra aplicaci贸n con ning煤n atributo.  隆Por lo tanto, el enganche de funciones es nuestra opci贸n! </p><br><p>  En resumen, el enganche funciona as铆: </p><br><ul><li>  La direcci贸n de la funci贸n se encuentra </li><li>  Los primeros pocos bytes de la funci贸n se sobrescriben mediante una transici贸n incondicional al cuerpo de otra funci贸n. </li><li>  ... </li><li>  Beneficio! <br>  En msvc hay 2 indicadores para esto: <code>/hotpatch</code> y <code>/FUNCTIONPADMIN</code> .  El primero al comienzo de cada funci贸n escribe 2 bytes, que no hacen nada, para su posterior reescritura con un "salto corto".  El segundo le permite dejar un espacio vac铆o frente al cuerpo de cada funci贸n en forma de instrucciones de <code>nop</code> para un "salto largo" a la ubicaci贸n deseada, por lo que en 2 saltos puede cambiar de la funci贸n anterior a la nueva.  Puede leer m谩s sobre c贸mo se implementa esto en Windows y msvc, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> . </li></ul><br><p>  Desafortunadamente, no hay nada similar en clang y gcc (al menos en Linux y macOS).  En realidad, este no es un problema tan grande, escribiremos directamente encima de la funci贸n anterior.  En este caso, corremos el riesgo de tener problemas si nuestra aplicaci贸n es multiproceso.  Si generalmente en un entorno de subprocesos m煤ltiples restringimos el acceso a los datos por un subproceso mientras otro subproceso los modifica, entonces debemos limitar la capacidad de ejecutar c贸digo a un subproceso mientras otro subproceso modifica este c贸digo.  No he descubierto c贸mo hacer esto, por lo que la implementaci贸n se comportar谩 de manera impredecible en un entorno multiproceso. </p><br><p>  Hay un punto sutil.  En un sistema de 32 bits, 5 bytes son suficientes para "saltar" a cualquier lugar.  En un sistema de 64 bits, si no queremos estropear los registros, necesitamos 14 bytes.  La conclusi贸n es que 14 bytes en la escala del c贸digo de m谩quina es bastante, y si el c贸digo tiene alguna funci贸n de c贸digo auxiliar con un cuerpo vac铆o, es probable que tenga menos de 14 bytes de longitud.  No s茅 toda la verdad, pero pas茅 un tiempo detr谩s del desensamblador mientras pensaba, escrib铆a y depuraba el c贸digo, y not茅 que todas las funciones est谩n alineadas en un l铆mite de 16 bytes (construcci贸n de depuraci贸n sin optimizaciones, no estoy seguro sobre el c贸digo optimizado).  Y esto significa que entre el comienzo de cualquiera de las dos funciones habr谩 al menos 16 bytes, lo que es suficiente para que los "atasquemos".  Google superficial condujo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> , sin embargo, no estoy seguro, tuve suerte, o hoy todos los compiladores hacen esto.  En cualquier caso, en caso de duda, simplemente declare un par de variables al comienzo de la funci贸n stub para que sea lo suficientemente grande. </p><br><p>  Entonces, tenemos el primer grano, un mecanismo para redirigir las funciones de la versi贸n anterior a la nueva. </p><br><h4 id="poisk-funkciy-v-skopmilirovannoy-programme">  Buscar funciones en un programa copiado </h4><br><p>  Ahora necesitamos obtener de alguna manera las direcciones de todas las funciones (no solo exportadas) de nuestro programa o de una biblioteca din谩mica arbitraria.  Esto se puede hacer simplemente usando la API del sistema si los caracteres no est谩n recortados de su aplicaci贸n.  En Linux, estos son api de <code>elf.h</code> y <code>link.h</code> , en macOS, <code>loader.h</code> y <code>nlist.h</code> . </p><br><ul><li>  Usando <code>dl_iterate_phdr</code> revisamos todas las bibliotecas cargadas y, de hecho, el programa </li><li>  Encuentra la direcci贸n donde se carga la biblioteca </li><li>  De la secci贸n <code>.symtab</code> toda la informaci贸n sobre los caracteres, a saber, el nombre, el tipo, el 铆ndice de la secci贸n en la que se encuentra, el tama帽o y tambi茅n calculamos su direcci贸n "real" en funci贸n de la direcci贸n virtual y la direcci贸n de carga de la biblioteca </li></ul><br><p>  Hay una sutileza.  Al descargar un archivo elf, el sistema no carga la secci贸n <code>.symtab</code> (corregir si est谩 mal), y la secci贸n <code>.dynsym</code> no nos conviene, ya que no podemos extraer caracteres con la visibilidad <code>STV_INTERNAL</code> y <code>STV_HIDDEN</code> .  En pocas palabras, no veremos tales funciones: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp namespace { int someUsefulFunction(int value) // &lt;----- { return value * 2; } }</span></span></code> </pre> <br><p>  y tales variables: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// some_file.cpp void someDefaultFunction() { static int someVariable = 0; // &lt;----- ... }</span></span></code> </pre> <br><p>  Por lo tanto, en el p谩rrafo 3, no estamos trabajando con el programa que <code>dl_iterate_phdr</code> dio, sino con el archivo que hemos descargado del disco y analizado por alg煤n analizador elfo (o en la api simple).  As铆 que no nos perdemos nada.  En macOS, el procedimiento es similar, solo los nombres de las funciones de la API del sistema son diferentes. </p><br><p>  Despu茅s de eso, filtramos todos los caracteres y guardamos solo: </p><br><ul><li>  Las funciones que se pueden volver a cargar son caracteres del tipo <code>STT_FUNC</code> ubicados en la secci贸n <code>.text</code> , que no son de tama帽o cero.  Tal filtro omite solo las funciones cuyo c贸digo est谩 realmente contenido en este programa o biblioteca </li><li>  Las variables est谩ticas cuyos valores desea transferir son caracteres de tipo <code>STT_OBJECT</code> ubicados en la secci贸n <code>.bss</code> </li></ul><br><h2 id="edinicy-translyacii">  Unidades de difusi贸n </h2><br><p>  Para volver a cargar el c贸digo, necesitamos saber d贸nde obtener los archivos de c贸digo fuente y c贸mo compilarlos. </p><br><p>  En la primera implementaci贸n, le铆 esta informaci贸n de la secci贸n <code>.debug_info</code> , que contiene informaci贸n de depuraci贸n en formato DWARF.  Para que cada unidad de compilaci贸n (ET) dentro de DWARF obtenga una l铆nea de compilaci贸n para este ET, debe pasar <code>-grecord-gcc-switches</code> durante la compilaci贸n.  Enano, analic茅 la biblioteca libdwarf, que viene incluida con <code>libelf</code> .  Adem谩s del comando de compilaci贸n de DWARF, puede obtener informaci贸n sobre las dependencias de nuestros ET en otros archivos.  Pero rechac茅 esta implementaci贸n por varias razones: </p><br><ul><li>  Las bibliotecas son bastante pesadas. </li><li>  Analizar una aplicaci贸n DWARF compilada a partir de ~ 500 ET, con an谩lisis de dependencias, tom贸 un poco m谩s de 10 segundos </li></ul><br><p>  10 segundos para iniciar la aplicaci贸n es demasiado.  Despu茅s de pensarlo, reescrib铆 la l贸gica de analizar DWARF para analizar <code>compile_commands.json</code> .  Este archivo se puede generar simplemente agregando <code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code> a su CMakeLists.txt.  Por lo tanto, obtenemos toda la informaci贸n que necesitamos. </p><br><h2 id="obrabotka-zavisimostey">  Manejo de dependencias </h2><br><p>  Como abandonamos DWARF, necesitamos encontrar otra opci贸n, c贸mo manejar las dependencias entre archivos.  Realmente no quer铆a analizar archivos con mis manos y buscar <code>include</code> en ellos, y 驴qui茅n sabe m谩s sobre las dependencias que el compilador en s铆? </p><br><p>  Hay una serie de opciones en clang y gcc que generan los llamados depfiles casi gratis.  Estos archivos utilizan los sistemas de compilaci贸n make y ninja para resolver dependencias entre archivos.  Los archivos tienen un formato muy simple: </p><br><pre> <code class="plaintext hljs">CMakeFiles/lib_efsw.dir/libs/efsw/src/efsw/DirectorySnapshot.cpp.o: \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/base.hpp \ /home/ddovod/_private/_projects/jet/live/libs/efsw/src/efsw/sophist.h \ /home/ddovod/_private/_projects/jet/live/libs/efsw/include/efsw/efsw.hpp \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/c++/7.3.0/string \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/c++config.h \ /usr/bin/../lib/gcc/x86_64-linux-gnu/7.3.0/../../../../include/x86_64-linux-gnu/c++/7.3.0/bits/os_defines.h \ ...</code> </pre> <br><p>  El compilador coloca estos archivos al lado de los archivos de objetos para cada ET, nos queda analizarlos y colocarlos en un hashmap.  El an谩lisis total de <code>compile_commands.json</code> + depfiles para el mismo 500 ET lleva un poco m谩s de 1 segundo.  Para que todo funcione, necesitamos agregar el indicador <code>-MD</code> globalmente para todos los archivos de proyecto en la opci贸n de compilaci贸n. </p><br><p>  Hay una sutileza asociada con ninja.  Este sistema de compilaci贸n genera archivos sin importar la presencia del indicador <code>-MD</code> para sus necesidades.  Pero despu茅s de que se generan, los traduce a su formato binario y elimina los archivos de origen.  Por lo tanto, al iniciar ninja, debe pasar el <code>-d keepdepfile</code> .  Adem谩s, por razones desconocidas para m铆, en el caso de make (con la opci贸n <code>-MD</code> ) el archivo se llama <code>some_file.cpp.d</code> , mientras que con ninja se llama <code>some_file.cpp.od</code> .  Por lo tanto, debe verificar ambas versiones. </p><br><h2 id="perenos-staticheskih-peremennyh">  Transferencia Variable Est谩tica </h2><br><p>  Supongamos que tenemos ese c贸digo (un ejemplo muy sint茅tico): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Singleton.hpp class Singletor { public: static Singleton&amp; instance(); }; int veryUsefulFunction(int value); // Singleton.cpp Singleton&amp; Singletor::instance() { static Singleton ins; return ins; } int veryUsefulFunction(int value) { return value * 2; }</span></span></code> </pre> <br><p>  Queremos cambiar la funci贸n <code>veryUsefulFunction</code> a esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><p>  Al recargar, en la biblioteca din谩mica con c贸digo nuevo, adem谩s de <code>veryUsefulFunction</code> , la variable <code>static Singleton ins;</code>  , y el m茅todo <code>Singletor::instance</code> .  Como resultado, el programa comenzar谩 a llamar nuevas versiones de ambas funciones.  Pero las <code>ins</code> est谩ticas en esta biblioteca a煤n no se han inicializado y, por lo tanto, la primera vez que se accede, se llamar谩 al constructor de la clase <code>Singleton</code> .  Por supuesto, no queremos esto.  Por lo tanto, la implementaci贸n transfiere los valores de todas las variables que encuentra en la biblioteca din谩mica ensamblada del c贸digo antiguo a esta biblioteca muy din谩mica con el c贸digo nuevo junto con sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">variables de protecci贸n</a> . </p><br><p>  Hay un momento sutil y generalmente insoluble. <br>  Supongamos que tenemos una clase: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  El m茅todo <code>calledEachUpdate</code> llama 60 veces por segundo.  Lo cambiamos agregando un nuevo campo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calledEachUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_someVar1++; m_someVar2++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_someVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Si una instancia de esta clase se encuentra en la memoria din谩mica o en la pila, despu茅s de volver a cargar el c贸digo, es probable que la aplicaci贸n se bloquee.  La instancia asignada contiene solo la variable <code>m_someVar1</code> , pero despu茅s del reinicio, el m茅todo <code>calledEachUpdate</code> intentar谩 cambiar <code>m_someVar2</code> , cambiando lo que en realidad no pertenece a esta instancia, lo que conduce a consecuencias impredecibles.  En este caso, la l贸gica de transferencia de estado se transfiere al programador, que de alguna manera debe guardar el estado del objeto y eliminar el objeto en s铆 mismo antes de volver a cargar el c贸digo, y crear un nuevo objeto despu茅s del reinicio.  La biblioteca proporciona eventos en forma de m茅todos delegados <code>onCodePreLoad</code> y <code>onCodePostLoad</code> que la aplicaci贸n puede procesar. </p><br><p>  Creo que no s茅 c贸mo (y si) es posible resolver esta situaci贸n de manera general.  Ahora este caso "m谩s o menos normal" funcionar谩 solo para variables est谩ticas, utiliza la siguiente l贸gica: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* oldVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* newVarPtr = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> oldVarSize = ...; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> newVarSize = ...; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(newVarPtr, oldVarPtr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(oldVarSize, newVarSize));</code> </pre> <br><p>  Esto no es muy correcto, pero es lo mejor que se me ocurri贸. </p><br><p>  Como resultado, el c贸digo se comportar谩 de manera impredecible si el tiempo de ejecuci贸n cambia el conjunto y el dise帽o de los campos en las estructuras de datos.  Lo mismo se aplica a los tipos polim贸rficos. </p><br><h2 id="sobiraem-vse-vmeste">  Poniendo todo junto </h2><br><p>  C贸mo funciona todo junto. </p><br><ul><li>  La biblioteca itera sobre los encabezados de todas las bibliotecas cargadas din谩micamente en el proceso y, de hecho, el programa mismo analiza y filtra caracteres. </li><li>  A continuaci贸n, la biblioteca intenta encontrar el archivo <code>compile_commands.json</code> en el directorio de la aplicaci贸n y en los directorios principales de forma recursiva, y extrae toda la informaci贸n necesaria sobre ET desde all铆. </li><li>  Al conocer la ruta de acceso a los archivos de objetos, la biblioteca carga y analiza los archivos. </li><li>  Despu茅s de eso, se calcula el directorio m谩s com煤n para todos los archivos de c贸digo fuente del programa, y la supervisi贸n de este directorio comienza de forma recursiva. </li><li>  Cuando un archivo cambia, la biblioteca busca ver si est谩 en el hashmap de dependencias y, si lo hay, inicia varios procesos de compilaci贸n de los archivos modificados y sus dependencias en segundo plano, utilizando los comandos de compilaci贸n de <code>compile_commands.json</code> . </li><li>  Cuando el programa le pide que vuelva a cargar el c贸digo (en mi aplicaci贸n, se le asigna la combinaci贸n <code>Ctrl+r</code> ), la biblioteca espera la finalizaci贸n de los procesos de compilaci贸n y vincula todos los objetos nuevos a la biblioteca din谩mica. </li><li>  Esta biblioteca se carga en el espacio de direcciones del proceso <code>dlopen</code> funci贸n <code>dlopen</code> . </li><li>  La informaci贸n sobre los s铆mbolos se carga desde esta biblioteca, y toda la intersecci贸n del conjunto de s铆mbolos de esta biblioteca y los s铆mbolos que ya viven en el proceso se vuelve a cargar (si es una funci贸n) o se transfiere (si es una variable est谩tica). </li></ul><br><p>  Esto funciona muy bien, especialmente cuando sabes qu茅 hay debajo del cap贸 y qu茅 esperar, al menos a un alto nivel. </p><br><p>  Personalmente, me sorprendi贸 mucho la falta de una soluci贸n para Linux, 驴alguien est谩 realmente interesado en esto? </p><br><p>  Estar茅 encantado de cualquier cr铆tica, gracias! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Enlace a la implementaci贸n</strong></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435260/">https://habr.com/ru/post/es435260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435250/index.html">C贸mo funciona la Universidad ITMO: un recorrido por nuestro laboratorio ciberf铆sico</a></li>
<li><a href="../es435252/index.html">Jessica Livingston: C贸mo creamos Y Combinator. El componente emocional "</a></li>
<li><a href="../es435254/index.html">Manejo de errores funcionales en Kotlin usando Arrow</a></li>
<li><a href="../es435256/index.html">Calificamos a los reclutadores por letras fr铆as</a></li>
<li><a href="../es435258/index.html">Escribimos nuestro lenguaje de programaci贸n, parte 2: representaci贸n intermedia de programas</a></li>
<li><a href="../es435262/index.html">Li-Fi: el futuro de Internet</a></li>
<li><a href="../es435264/index.html">Edici贸n de precios en RMK. 1C: Gesti贸n comercial 11</a></li>
<li><a href="../es435268/index.html">No me trates doctor</a></li>
<li><a href="../es435270/index.html">Mantenga seguras las llaves SSH</a></li>
<li><a href="../es435272/index.html">Ciclofobia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>