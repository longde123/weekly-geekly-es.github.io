<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥥 ⬆️ ☎️ iOS Storyboards: análisis de los pros y contras, mejores prácticas 🔫 🖐🏽 🧔🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apple creó Storyboards para que los desarrolladores puedan visualizar las pantallas de las aplicaciones de iOS y las relaciones entre ellas. No a todo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS Storyboards: análisis de los pros y contras, mejores prácticas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/456086/"><img src="https://habrastorage.org/webt/xx/gq/7w/xxgq7wvcgxjuew_bku55csqqvlu.png"><br><br>  Apple creó Storyboards para que los desarrolladores puedan visualizar las pantallas de las aplicaciones de iOS y las relaciones entre ellas.  No a todos les gustó esta herramienta, y por una buena razón.  He conocido muchos artículos que critican Storyboards, pero no he encontrado un análisis detallado e imparcial de todos los pros y los contras, teniendo en cuenta las mejores prácticas.  Al final, decidí escribir un artículo así. <br><a name="habracut"></a><br>  Intentaré analizar en detalle las desventajas y ventajas de usar Storyboards.  Después de sopesarlos, puede tomar una decisión significativa si son necesarios en el proyecto o no.  Esta decisión no tiene que ser radical.  Si en algunas situaciones los Storyboards crean problemas, en otras su uso está justificado: ayuda a resolver tareas de manera efectiva y a escribir código simple y fácil de mantener. <br><br>  Comencemos con las deficiencias y analicemos si todas ellas siguen siendo relevantes. <br><br><h2>  Desventajas </h2><br><h3>  1. Los guiones gráficos tienen dificultades para gestionar conflictos al fusionar cambios </h3><br>  Storyboard es un archivo XML.  Es menos legible que el código, por lo que resolver conflictos es más difícil.  Pero esta complejidad también depende de cómo trabajemos con el Storyboard.  Puede simplificar enormemente su tarea si sigue las siguientes reglas: <br><br><ul><li> No coloque la interfaz de usuario completa en un solo guión gráfico, divídalo en varios más pequeños.  Esto permitirá distribuir el trabajo en Storyboards entre los desarrolladores sin riesgo de conflictos, y en caso de que sea inevitable, simplificará la tarea de resolverlos. <br></li><li>  Si necesita usar la misma Vista en varios lugares, selecciónela en una subclase separada con su propio archivo Xib. <br></li><li>  Realice confirmaciones con más frecuencia, ya que es mucho más fácil trabajar con los cambios que vienen en pequeños pedazos. <br></li></ul><br>  El uso de varios guiones gráficos en lugar de uno nos imposibilita ver el mapa completo de la aplicación en un solo archivo.  Pero a menudo esto no es necesario, solo la parte específica en la que estamos trabajando en este momento es suficiente. <br><br><h3>  2. Los guiones gráficos evitan la reutilización del código </h3><br>  Si estamos hablando de usar solo Storyboards sin Xibs en el proyecto, entonces seguramente surgirán problemas.  Sin embargo, los Xibs, en mi opinión, son elementos necesarios cuando se trabaja con Storyboards.  Gracias a ellos, puede crear fácilmente Vistas reutilizables, que también son convenientes para trabajar en código. <br><br>  Primero, cree la clase base <code>XibView</code> , que es responsable de representar la <code>UIView</code> creada en Xib en el Storyboard: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBDesignable</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentView: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> }</code> </pre> <br>  <code>XibView</code> cargará la <code>UIView</code> de Xib en <code>contentView</code> y la agregará como su subvista.  Hacemos esto en el método <code>setup()</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = loadViewFromNib() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } view.frame = bounds view.autoresizingMask = [.flexibleWidth, .flexibleHeight] addSubview(view) contentView = view }</code> </pre> <br>  El método <code>loadViewFromNib()</code> se ve así: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadViewFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nibName = <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: type(of: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nib = <span class="hljs-type"><span class="hljs-type">UINib</span></span>(nibName: nibName, bundle: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">XibView</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nib.instantiate(withOwner: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, options: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).first <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIView</span></span> }</code> </pre> <br>  El método <code>setup()</code> debería llamarse en inicializadores: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) setup() } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(coder: aDecoder) setup() }</code> </pre> <br>  La clase <code>XibView</code> lista.  Las vistas reutilizadas, cuya apariencia se representa en un archivo Xib, se heredarán de <code>XibView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><img src="https://habrastorage.org/webt/j8/ak/ny/j8aknyaa51sdpr6y8kbh7yjfwvs.png"><br>  Si ahora agrega una nueva <code>UIView</code> al Storyboard y establece su clase en <code>RedView</code> , entonces todo se mostrará con éxito: <br><img src="https://habrastorage.org/webt/0l/a-/wa/0la-waqvswrxya3gc8clxvro2iw.png"><br>  La creación de una instancia de <code>RedView</code> en código ocurre de la manera habitual: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> redView = <span class="hljs-type"><span class="hljs-type">RedView</span></span>()</code> </pre> <br>  Otro detalle útil que no todos pueden conocer es la capacidad de agregar colores al directorio <b>.xcassets</b> .  Esto le permite cambiarlos globalmente en todos los Storyboards y Xibs donde se usan. <br><br>  Para agregar color, haga clic en "+" en la parte inferior izquierda y seleccione "Nuevo conjunto de colores": <br><img src="https://habrastorage.org/webt/zm/3u/qi/zm3uqiunozwu020zpfckzd_slbo.png"><br>  Especifique el nombre y el color deseados: <br><img src="https://habrastorage.org/webt/4j/ve/lt/4jveltbjt7fiqalngh6zzg1otr4.png"><br>  El color creado aparecerá en la sección "Colores con nombre": <br><img src="https://habrastorage.org/webt/km/cl/ak/kmclakpy0pduyyudog1_daxmx8o.png"><br>  Además, se puede obtener en el código: <br><br><pre> <code class="swift hljs">innerView.backgroundColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(named: <span class="hljs-string"><span class="hljs-string">"BackgroundColor"</span></span>)</code> </pre><br><h3>  3. No puede usar inicializadores personalizados para <code>UIViewControllers</code> creados en Storyboard </h3><br>  En el caso del Storyboard, no podemos pasar dependencias en los inicializadores de los <code>UIViewControllers</code> .  Por lo general, se ve así: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"detail"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> detailVC = segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = <span class="hljs-type"><span class="hljs-type">Object</span></span>() detailVC.object = object }</code> </pre> <br>  Este código se puede hacer mejor usando algún tipo de constante para representar identificadores o herramientas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SwiftGen</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">R.swift</a> , o tal vez incluso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Realizar</a> .  Pero de esta manera solo nos deshacemos de los literales de cadena y agregamos azúcar sintáctico, y no resolvemos los problemas que surgen: <br><br><ul><li>  ¿Cómo sé cómo <code>DetailViewController</code> configura <code>DetailViewController</code> en el ejemplo anterior?  Si es nuevo en el proyecto y no tiene este conocimiento, deberá abrir un archivo con una descripción de este controlador y estudiarlo. <br></li><li>  Las propiedades <code>DetailViewController</code> establecen después de la inicialización, lo que significa que deben ser opcionales.  Es necesario manejar casos cuando alguna propiedad es <code>nil</code> ; de lo contrario, la aplicación puede bloquearse en el momento más inoportuno.  Puede marcar propiedades como opcionales expandidas implícitamente ( <code>var object: Object!</code> ), Pero la esencia no cambiará. <br></li><li>  Las propiedades deben estar marcadas como <code>var</code> , no <code>let</code> .  Entonces, una situación es posible cuando alguien de afuera quiere cambiarlos.  <code>DetailViewController</code> debería manejar tales situaciones. <br></li></ul><br>  Una solución se describe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este artículo</a> . <br><br><h3>  4. A medida que el Storyboard crece, la navegación en él se vuelve más difícil </h3><br>  Como notamos anteriormente, no es necesario poner todo en un Storyboard, es mejor dividirlo en varios más pequeños.  Con el advenimiento de <b>Storyboard Reference,</b> se ha vuelto muy simple. <br>  Agregue la referencia del guión gráfico de la biblioteca de objetos al guión gráfico: <br><img src="https://habrastorage.org/webt/m7/v4/wc/m7v4wcm7xu_chbm7n6j_mmy1ssq.png"><br>  Establecemos los valores de campo requeridos en el <b>Inspector de atributos</b> : este es el nombre del archivo de Storyboard y, si es necesario, la <b>ID de referencia</b> , que corresponde a la <b>ID de Storyboard de la</b> pantalla deseada.  Por defecto, el <b>Controlador de vista inicial</b> cargará: <br><img src="https://habrastorage.org/webt/0j/2a/ee/0j2aeevobxwbcwd4impkwryj1ye.png"><br>  Si especifica un nombre no válido en el campo Storyboard o hace referencia a una ID de Storyboard inexistente, Xcode le advertirá sobre esto en la etapa de compilación. <br><br><h3>  5. Xcode se ralentiza al cargar guiones gráficos </h3><br>  Si el Storyboard contiene una gran cantidad de pantallas con numerosas restricciones, cargarlo realmente llevará algún tiempo.  Pero, de nuevo, es mejor dividir el Storyboard grande en otros más pequeños.  Por separado, se cargan mucho más rápido y se vuelve más conveniente trabajar con ellos. <br><br><h3>  6. Los guiones gráficos son frágiles, un error puede hacer que la aplicación se bloquee en tiempo de ejecución </h3><br>  Los principales puntos débiles: <br><br><ul><li>  Errores en los <code>UICollectionViewCell</code> <code>UITableViewCell</code> y <code>UICollectionViewCell</code> . <br></li><li>  Errores en segues identificadores. <br></li><li>  Usando una subclase de <code>UIView</code> que ya no existe. <br></li><li>  Sincronización de <code>IBActions</code> e <code>IBOutlets</code> con código. <br></li></ul><br>  Todo esto y algunos otros problemas pueden provocar el bloqueo de la aplicación en tiempo de ejecución, lo que significa que es probable que tales errores caigan en la versión de lanzamiento.  Por ejemplo, cuando establecemos identificadores de celda o segues en el Storyboard, deben copiarse en el código donde sea que se usen.  Al cambiar el identificador en un lugar, se debe cambiar en el resto.  Existe la posibilidad de que simplemente lo olvide o haga un error tipográfico, pero solo aprenda sobre el error mientras la aplicación se está ejecutando. <br><br>  Puede reducir la probabilidad de errores al deshacerse de los literales de cadena en su código.  Para esto, a los <code>UICollectionViewCell</code> <code>UITableViewCell</code> y <code>UICollectionViewCell</code> se les pueden asignar los nombres de las clases de celdas: por ejemplo, el identificador <code>ItemTableViewCell</code> será la cadena "ItemTableViewCell".  En el código, obtenemos la celda así: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span></code> </pre> <br>  Puede agregar la función genérica correspondiente a <code>UITableView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dequeueReusableCell</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">T</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">T</span></span> } }</code> </pre> <br>  Y luego se hace más fácil obtener la célula: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span> = tableView.dequeueReusableCell()</code> </pre> <br>  Si de repente olvida especificar el valor del identificador de celda en el Guión gráfico, Xcode mostrará una advertencia, por lo que no debe ignorarlos. <br><br>  En cuanto a los identificadores de segues, puede usar enumeraciones para ellos.  Creemos un protocolo especial: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>: <span class="hljs-type"><span class="hljs-type">RawRepresentable</span></span> }</code> </pre> <br>  <code>UIViewController</code> que admita este protocolo deberá definir un tipo anidado con el mismo nombre.  Enumera todos los identificadores de <code>UIViewController</code> que este <code>UIViewController</code> puede procesar: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } }</code> </pre> <br>  Además, en la extensión de protocolo <code>SegueHandler</code> , definimos dos funciones: una acepta un <code>UIStoryboardSegue</code> y devuelve el valor <code>SegueIdentifier</code> correspondiente, y el otro simplemente llama a <code>performSegue</code> , tomando la entrada <code>SegueIdentifier</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawValue</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performSegue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withIdentifier segueIdentifier: SegueIdentifier, sender: AnyObject?)</span></span></span></span> { performSegue(withIdentifier: segueIdentifier.rawValue, sender: sender) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">segueIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifier = segue.identifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifierCase = <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>(rawValue: identifier) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid segue identifier \(String(describing: segue.identifier))."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> identifierCase } }</code> </pre> <br>  Y ahora en un <code>UIViewController</code> que admite el nuevo protocolo, puede trabajar con <code>prepare(for:sender:)</code> siguiente manera: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> segueIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: segue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signIn: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signIn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signUp: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signUp"</span></span>) } } }</code> </pre> <br>  Y ejecuta segue así: <br><br><pre> <code class="swift hljs">performSegue(withIdentifier: .signIn, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  Si agrega un nuevo identificador al <code>SegueIdentifier</code> , entonces Xcode ciertamente lo obligará a procesar en <code>switch/case</code> . <br><br>  Otra opción para deshacerse de los literales de cadena como identificadores, segues y otros es utilizar herramientas de generación de código como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">R.swift</a> . <br><br><h3>  7. Los guiones gráficos son menos flexibles que el código. </h3><br>  Si, esto es verdad.  Si la tarea es crear una pantalla compleja con animaciones y efectos que Storyboard no pueda manejar, ¡entonces debe usar el código! <br><br><h3>  8. Los <code>UIViewControllers</code> no permiten cambiar el tipo de <code>UIViewControllers</code> especiales </h3><br>  Por ejemplo, cuando necesita cambiar el tipo de <code>UITableViewController</code> a <code>UICollectionViewController</code> , debe eliminar el objeto, agregar uno nuevo con otro tipo y <code>UITableViewController</code> a configurarlo.  Aunque este no es un caso frecuente, vale la pena señalar que dichos cambios se realizan más rápido en el código. <br><br><h3>  9. Los guiones gráficos agregan dos dependencias adicionales al proyecto.  Pueden contener errores que el desarrollador no puede corregir. </h3><br>  Este es Interface Builder y el analizador de Storyboards.  Tales casos son raros y a menudo pueden ser evitados por otras soluciones. <br><br><h3>  10. Revisión sofisticada del código </h3><br>  Tenga en cuenta que la revisión de código no es realmente una búsqueda de errores.  Sí, se encuentran en el proceso de visualización del código, pero el objetivo principal es identificar las debilidades que pueden crear problemas a largo plazo.  Para Storyboards, este es principalmente el trabajo de <b>Auto Layout</b> .  No debe haber ninguna <b>ambigüedad</b> y <b>fuera de lugar</b> .  Para encontrarlos, simplemente use la búsqueda en el XML de Storyboard para las líneas “ambiguous =“ YES ”” y “misplaced =“ YES ”” o simplemente abra Storyboard en Interface Builder y busque puntos rojos y amarillos: <br><img src="https://habrastorage.org/webt/u4/bw/l5/u4bwl5psqejad5ziovb2bjxy1eq.png"><br>  Sin embargo, esto puede no ser suficiente.  Los conflictos entre restricciones también se pueden detectar mientras se ejecuta la aplicación.  Si ocurre una situación similar, se muestra información sobre esto en la consola.  Tales casos no son infrecuentes, por lo tanto, su búsqueda también debe tomarse en serio. <br><br>  Todo lo demás, hacer coincidir la posición y el tamaño de los elementos con el diseño, la unión correcta de <code>IBOutlets</code> e <code>IBActions</code> , no es para revisión de código. <br><br>  Además, es importante realizar confirmaciones con más frecuencia, entonces será más fácil para el revisor ver los cambios en partes pequeñas.  Podrá profundizar en los detalles sin perderse nada.  Esto, a su vez, tendrá un efecto positivo en la calidad de la revisión del código. <br><br><h3>  Resumen </h3><br>  En la lista de defectos de Storyboards, dejé 4 elementos (en orden descendente de su valor): <br><br><ol><li>  Los guiones gráficos tienen dificultades para gestionar conflictos al fusionar cambios. <br></li><li>  Los guiones gráficos son menos flexibles que el código. <br></li><li>  Los guiones gráficos son frágiles, un error puede provocar un bloqueo en tiempo de ejecución. <br></li><li>  No puede usar inicializadores personalizados para <code>UIViewControllers</code> creados en Storyboard. <br></li></ol><br><h2>  Los beneficios </h2><br><h3>  1. Visualización de la interfaz de usuario y restricciones. </h3><br>  Incluso si es un principiante y acaba de comenzar un proyecto desconocido, puede encontrar fácilmente el punto de entrada a la aplicación y cómo llegar a la pantalla deseada desde ella.  Usted sabe cómo se verá cada botón, etiqueta o campo de texto, qué posición tomarán, cómo los afectan las restricciones, cómo interactúan con otros elementos.  Con unos pocos clics, puede crear fácilmente una nueva <code>UIView</code> , personalizar su apariencia y comportamiento.  El diseño automático nos permite trabajar con <code>UIView</code> forma natural, como si dijéramos: "Este botón debe estar a la izquierda de esa etiqueta y tener la misma altura".  Esta experiencia de interfaz de usuario es intuitiva y efectiva.  Puede intentar dar ejemplos en los que el código bien escrito ahorre más tiempo al crear algunos elementos de la interfaz de usuario, pero a nivel mundial esto no cambia mucho.  Storyboard hace bien su trabajo. <br><br>  Por separado, tenga en cuenta el diseño automático.  Esta es una herramienta muy poderosa y útil, sin la cual sería difícil crear una aplicación que soporte todos los diferentes tamaños de pantalla.  Interface Builder le permite ver el resultado de trabajar con Auto Layout sin iniciar la aplicación, y si algunas restricciones no se ajustan al esquema general, Xcode le advertirá de inmediato.  Por supuesto, hay casos en que Interface Builder no puede proporcionar el comportamiento necesario de una interfaz muy dinámica y compleja, por lo que debe confiar en el código.  Pero incluso en tales situaciones, puede hacerlo en Interface Builder y complementarlo con solo un par de líneas de código. <br><br>  Veamos algunos ejemplos que demuestran las características útiles de Interface Builder. <br><br><h4>  Tablas dinámicas basadas en <code>UIStackView</code> </h4><br>  Cree un nuevo <code>UIViewController</code> , agregue una pantalla completa <code>UIScrollView</code> : <br><img src="https://habrastorage.org/webt/oh/-g/c8/oh-gc88tyx_mhu5zm6iehrnpvrk.png"><br>  En <code>UIScrollView</code> agregue un <code>UIStackView</code> vertical, <code>UIStackView</code> a los bordes y establezca la altura y el ancho igual a <code>UIScrollView</code> .  A esta altura, asigne <b>prioridad = Baja (250)</b> : <br><img src="https://habrastorage.org/webt/hp/dv/v-/hpdvv-gg-hkeh_xy5k2vbbcznr0.png"><br>  A continuación, cree todas las celdas necesarias y agréguelas a <code>UIStackView</code> .  Tal vez sea <code>UIView</code> ordinario en una sola copia, o tal vez <code>UIView</code> , para lo cual creamos nuestro propio archivo Xib.  En cualquier caso, toda la interfaz de usuario de esta pantalla está en el Guión gráfico y, gracias al diseño automático configurado correctamente, el desplazamiento funcionará perfectamente, adaptándose al contenido: <br><br><img src="https://habrastorage.org/webt/vg/pr/dl/vgprdl652o0neubp6d87fvcyupk.gif" width="320" height="588"><br><br>  También podemos hacer que las células se adapten al tamaño de su contenido.  Agregue <code>UILabel</code> a cada celda, <code>UILabel</code> a los bordes: <br><img src="https://habrastorage.org/webt/ei/u0/if/eiu0ifpkzcudjmimrknducpg5f4.png"><br>  Ya está claro cómo se verá todo esto en el tiempo de ejecución.  Puede adjuntar cualquier acción a las celdas, por ejemplo, cambiar a otra pantalla.  Y todo esto sin una sola línea de código. <br>  Además, si configura <code>hidden = true</code> para una <code>UIView</code> desde un <code>UIStackView</code> , no solo se ocultará, sino que tampoco ocupará espacio.  <code>UIStackView</code> recalculará automáticamente sus tamaños: <br><br><img src="https://habrastorage.org/webt/b8/cs/ch/b8cschy8jwotcb1fge4ew2ip43s.gif"><br><br><h4>  Células auto dimensionantes </h4><br>  En el <b>inspector de tamaño de la</b> tabla, establezca <b>Altura de fila = Automática</b> y <b>Estimación</b> en algún valor promedio: <br><img src="https://habrastorage.org/webt/p2/tp/de/p2tpdecyxveakvtukce9maxkrbq.png"><br>  Para que esto funcione, las restricciones deben configurarse correctamente en las celdas mismas y permitir un cálculo preciso de la altura de la celda en función del contenido en tiempo de ejecución.  Si no está claro qué está en juego, hay una muy buena explicación en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación oficial</a> . <br><br>  Como resultado, al iniciar la aplicación, veremos que todo se muestra correctamente: <br><img src="https://habrastorage.org/webt/yi/mb/4q/yimb4q-qt5ydm3_3ynqavuvr4ga.png" width="432" height="702"><br><h4>  Mesa de auto-dimensionamiento </h4><br>  Necesita implementar este comportamiento de tabla: <br><br><img src="https://habrastorage.org/webt/6g/pp/bf/6gppbf-ma4zin0czafyjn3wfj08.gif" width="320" height="588"><br><br>  ¿Cómo lograr un cambio dinámico similar en altura?  A diferencia de <code>UILabel</code> , <code>UIButton</code> y otras subclases de <code>UIView</code> , es un poco más difícil de hacer con una tabla, ya que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tamaño del contenido intrínseco</a> no depende del tamaño de las celdas que contiene.  Ella no puede calcular su altura en función del contenido, pero existe la oportunidad de ayudarla con esto. <br><br>  Tenga en cuenta que en algún momento del video la altura de la tabla deja de cambiar, alcanzando un cierto valor máximo.  Esto se puede lograr estableciendo la <b>restricción de altura de</b> la tabla con el valor <b>Relación = Menor o igual</b> : <br><img src="https://habrastorage.org/webt/xk/47/rc/xk47rcebixtr42k1ka4wqagftyy.png"><br>  En esta etapa, Interface Builder aún no sabe qué altura tendrá la tabla, solo conoce su valor máximo igual a 200 (de la restricción de altura).  Como se señaló anteriormente, el tamaño del contenido intrínseco no es igual al contenido de la tabla.  Sin embargo, tenemos la capacidad de establecer el marcador de posición en el campo <b>Tamaño intrínseco</b> : <br><img src="https://habrastorage.org/webt/tb/i7/eu/tbi7eut1jafonqjknoyabqyev_q.png"><br>  Este valor es válido solo mientras se trabaja con Interface Builder.  Por supuesto, el tamaño del contenido intrínseco no tiene que ser igual a este valor en tiempo de ejecución.  Acabamos de decirle a Interface Builder que todo está bajo control. <br><br>  A continuación, cree una nueva subclase de la tabla <code>CustomTableView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTableView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { invalidateIntrinsicContentSize() } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intrinsicContentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentSize } }</code> </pre> <br>  Uno de esos casos cuando el código es necesario.  Aquí llamamos <code>invalidateIntrinsicContentSize</code> cada vez que cambia el <code>contentSize</code> la tabla.  Esto permitirá que el sistema acepte el nuevo tamaño de contenido intrínseco.  A su vez, devuelve <code>contentSize</code> , obligando a la tabla a ajustar dinámicamente su altura y mostrar un cierto número de celdas sin desplazarse.  El desplazamiento aparece en el momento en que alcanzamos el límite de restricción de altura. <br><br>  Las tres características de Interface Builder se pueden combinar entre sí.  Añaden más flexibilidad a las opciones de organización de contenido sin la necesidad de restricciones adicionales o cualquier <code>UIView</code> . <br><br><h3>  2. La capacidad de ver instantáneamente el resultado de sus acciones. </h3><br>  Si <code>UIView</code> el tamaño de <code>UIView</code> , lo movió un par de puntos a un lado o cambió el color de fondo, verá inmediatamente cómo se verá en tiempo de ejecución sin tener que iniciar la aplicación.  No es necesario preguntarse por qué algunos botones no aparecieron en la pantalla o por qué el comportamiento de <code>UIView</code> no <code>UIView</code> deseado. <br><br>  El uso de <code>@IBInspectable</code> revela este beneficio aún más interesante.  Agregue dos <code>UILabel</code> y dos propiedades a <code>RedView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> titleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { titleLabel.text = title } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitle: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { subtitleLabel.text = subtitle } } }</code> </pre> <br>  Aparecerán dos nuevos campos en el <b>Inspector de atributos</b> para <code>RedView</code> : <code>Title</code> y <code>Subtitle</code> , que marcamos como <code>@IBInspectable</code> : <br><img src="https://habrastorage.org/webt/wv/rh/nn/wvrhnnegpjpyo7zrj7857dlujom.png"><br>  Si intentamos ingresar valores en estos campos, veremos de inmediato cómo se verá todo en el tiempo de ejecución: <br><br><img src="https://habrastorage.org/webt/hn/bd/6u/hnbd6urq0ebbpghnuiaueovz38i.gif"><br><br>  Puede controlar cualquier cosa: <code>cornerRadius</code> , <code>borderWidth</code> , <code>borderColor</code> .  Por ejemplo, ampliamos la clase base <code>UIView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cornerRadius: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.cornerRadius = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.cornerRadius } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderWidth = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderWidth } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderColor: <span class="hljs-type"><span class="hljs-type">UIColor?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderColor = newValue?.cgColor } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderColor != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ? <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(cgColor: layer.borderColor!) : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rotate: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: newValue * .pi/<span class="hljs-number"><span class="hljs-number">180</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br>  Vemos que el Inspector de atributos del objeto <code>RedView</code> adquirido 4 campos nuevos más, con los que ahora también puede jugar: <br><br><img src="https://habrastorage.org/webt/gq/ib/bm/gqibbmd2an0a4zezig2iuifx5tm.gif"><br><br><h3>  3. Vista previa de todos los tamaños de pantalla a la vez </h3><br>  Así que arrojamos los elementos necesarios en la pantalla, ajustamos su apariencia y agregamos las restricciones necesarias.  ¿Cómo descubrimos si el contenido se mostrará correctamente en diferentes tamaños de pantalla?  Por supuesto, puede ejecutar la aplicación en cada simulador, pero tomará mucho tiempo.  Hay una mejor opción: Xcode tiene un modo de vista previa, le permite ver varios tamaños de pantalla a la vez sin iniciar la aplicación. <br><br>  Llamamos al <b>editor Asistente</b> , en él haga clic en el primer segmento de la barra de transición, seleccione <b>Vista previa -&gt; Configuración. Tablero de historia</b> (como ejemplo): <br><img src="https://habrastorage.org/webt/aw/mg/nr/awmgnrb4ajxr49hrygbe70fz5is.png"><br>  Al principio solo vemos una pantalla, pero podemos agregar tanto como sea necesario haciendo clic en "+" en la esquina inferior izquierda y seleccionando los dispositivos necesarios de la lista: <br><img src="https://habrastorage.org/webt/18/3f/eo/183feokkgdpycsxlcr3a1upo8jk.png"><br>  Además, si Storyboard admite varios idiomas, puede ver cómo se verá la pantalla seleccionada con cada uno de ellos: <br><img src="https://habrastorage.org/webt/hy/nf/6g/hynf6gc-nzhc30fxq0ir2a2uzcc.png"><br>  El idioma se puede seleccionar para todas las pantallas a la vez y para cada una individualmente. <br><br><h3>  4. Eliminar el código de la interfaz de usuario de la plantilla </h3><br>  La creación de una interfaz de usuario sin Interface Builder se acompaña de una gran cantidad de código repetitivo o de superclases y extensiones que implican un trabajo de mantenimiento adicional.  Este código puede infiltrarse en otras partes de la aplicación, lo que dificulta la lectura y la búsqueda.  Usar Storyboards y Xibs puede descargar código, haciéndolo más enfocado en la lógica. <br><br><h3>  5. Clases de tamaño </h3><br>  Cada año, aparecen nuevos dispositivos, para los cuales debe adaptar la interfaz de usuario.  El concepto de <b>variaciones</b> de <b>rasgos</b> y, en particular, las <b>clases de tamaño</b> , que le permiten crear una interfaz de usuario para cualquier tamaño y orientación de la pantalla, ayuda en esto. <br><br>  Las clases de tamaño clasifican la altura (h) y el ancho (w) de las pantallas del dispositivo en términos de <b>compacto</b> y <b>regular</b> ( <b>C</b> y <b>R</b> ).  Por ejemplo, el iPhone 8 tiene una clase de tamaño <b>(wC hR)</b> en orientación vertical y <b>(wC hC)</b> en horizontal, y el iPhone 8 Plus tiene <b>(wC hR)</b> y <b>(wR hC),</b> respectivamente.  El resto de los dispositivos se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  En un Storyboard o Xib para cada una de las clases de tamaño, puede almacenar su propio conjunto de datos, y la aplicación usará el apropiado según el dispositivo y la orientación de la pantalla en tiempo de ejecución, identificando así la clase de tamaño actual.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si algunos parámetros de diseño son los mismos para todas las clases de tamaño, se pueden configurar en la categoría " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cualquiera</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", que ya está seleccionada de forma predeterminada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, configure el tamaño de fuente según la clase de tamaño. Seleccionamos el dispositivo iPhone 8 Plus para verlo en Storyboard en orientación vertical y agregamos una nueva condición para </font></font><code>font</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: si el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ancho es Regular</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (establece todo lo demás en "Cualquiera"), entonces el tamaño de la fuente debe ser 37: </font></font><br><img src="https://habrastorage.org/webt/bd/bs/-7/bdbs-7i602wtlxemns-hm3jz3ps.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, si cambiamos la orientación de la pantalla, el tamaño de la fuente aumentar: una nueva condición funcionará, ya que en orientación horizontal, el iPhone 8 Plus tiene clase de tamaño </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hC)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En el Storyboard, dependiendo de la clase de tamaño, también puede ocultar Vistas, habilitar / deshabilitar restricciones, cambiar su valor</font></font><code>constant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y mucho mas Lea más sobre cómo hacer todo esto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la captura de pantalla anterior, vale la pena señalar el panel inferior con la elección del dispositivo para mostrar el diseño. Le permite verificar rápidamente la adaptabilidad de la interfaz de usuario en cualquier dispositivo y para cualquier orientación de pantalla, y también muestra la clase de tamaño de la configuración actual (junto al nombre del dispositivo). Entre otras cosas, hay un botón </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variar para los rasgos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a la derecha </font><font style="vertical-align: inherit;">. Su propósito es permitir variaciones de rasgos solo para una categoría específica de ancho, alto o ancho y alto al mismo tiempo. Por ejemplo, al seleccionar un iPad con una clase de tamaño </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , haga clic en "Variar para los rasgos" y marque la casilla junto a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ancho</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ahora, todos los cambios de diseño posteriores solo se aplicarán a los dispositivos con </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hasta que hagamos clic en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listo para variar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Conclusión </h2><div class="scrollable-table"><table><tbody><tr><th>  # # <br></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desventajas </font></font><br></th><th>  Los beneficios <br></th></tr><tr><td>  1 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conflictos difíciles de gobernar </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualización de UI y restricciones </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No tan flexible como el código </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La capacidad de ver instantáneamente el resultado de tus acciones </font></font><br></td></tr><tr><td>  3 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un error puede provocar un bloqueo en tiempo de ejecución. </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vista previa de todos los tamaños de pantalla a la vez </font></font><br></td></tr><tr><td>  4 4 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No puede usar inicializadores personalizados para </font></font><code>UIViewControllers</code> <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminar el código de la IU de la plantilla </font></font><br></td></tr><tr><td>  5 5 <br></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clases de tamaño </font></font><br></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vimos que los Storyboards tienen sus fortalezas y debilidades. </font><font style="vertical-align: inherit;">Mi opinión es que no debe negarse por completo a usarlos. </font><font style="vertical-align: inherit;">Cuando se usan correctamente, brindan grandes beneficios y ayudan a resolver tareas de manera efectiva. </font><font style="vertical-align: inherit;">Solo necesita aprender a priorizar y olvidar argumentos como "No me gustan los guiones gráficos" o "Estoy acostumbrado a hacer esto".</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456086/">https://habr.com/ru/post/456086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456070/index.html">Cómo atraer usuarios al portal de autoservicio</a></li>
<li><a href="../456072/index.html">Dav1d: el decodificador AV1 más rápido ahora en Firefox por defecto</a></li>
<li><a href="../456078/index.html">Proyección de conflicto corporativo sobre conectividad de red</a></li>
<li><a href="../456082/index.html">Cómo desarrollamos recomendaciones personalizadas de productos</a></li>
<li><a href="../456084/index.html">Kubernetes 1.15: Resumen de lo más destacado</a></li>
<li><a href="../456090/index.html">Introducción a las pruebas unitarias en Unity</a></li>
<li><a href="../456092/index.html">Siete signos preocupantes de que depende del clima, incluso si no lo cree</a></li>
<li><a href="../456094/index.html">Leemos hojas de datos 2: SPI en STM32; Temporizadores e interrupciones PWM en el STM8</a></li>
<li><a href="../456096/index.html">Lo que hace el lector promedio de geektimes mientras se cierne en las nubes</a></li>
<li><a href="../456100/index.html">Ahora en el nuevo empaque: Kingston A400 en formato M.2 se apresura al mercado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>