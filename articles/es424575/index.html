<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äç‚úàÔ∏è ü§≥ üë®‚Äçüë®‚Äçüëß Jeeps de video de cambio r√°pido de tama√±o ü•á üèáüèª üëáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En las aplicaciones para trabajar con im√°genes, la tarea de cambiar el tama√±o de los jeeps (im√°genes comprimidas usando el algoritmo JPEG) es bastante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jeeps de video de cambio r√°pido de tama√±o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424575/">  En las aplicaciones para trabajar con im√°genes, la tarea de cambiar el tama√±o de los jeeps (im√°genes comprimidas usando el algoritmo JPEG) es bastante com√∫n.  En este caso, no puede cambiar el tama√±o inmediatamente y primero debe decodificar los datos originales.  No hay nada complicado y nuevo en esto, pero si necesita hacerlo muchos millones de veces al d√≠a, entonces es especialmente importante optimizar el rendimiento de dicha soluci√≥n, que deber√≠a ser muy r√°pida. <br><br><img src="https://habrastorage.org/webt/ty/1c/gm/ty1cgmvqp5rt915vpx9whsdr5gw.jpeg"><br><a name="habracut"></a><br>  Este problema a menudo se encuentra al organizar el alojamiento remoto para un repositorio de im√°genes, ya que la mayor√≠a de las c√°maras y tel√©fonos disparan en formato JPEG.  Todos los d√≠as, los archivos de fotos de los principales servicios web (redes sociales, foros, alojamiento de fotos y muchos otros) se reponen con un n√∫mero significativo de tales im√°genes, por lo que la cuesti√≥n de c√≥mo almacenar esas im√°genes es extremadamente importante.  Para reducir el tama√±o del tr√°fico saliente y mejorar el tiempo de respuesta a la solicitud de un usuario, muchos servicios web almacenan docenas de archivos para una sola imagen en diferentes resoluciones.  La velocidad de respuesta es buena, pero estas copias ocupan mucho espacio.  Este es un problema importante, aunque hay otras desventajas en este enfoque. <br><br>  La idea de resolver este problema no es almacenar en el servidor muchas opciones para la imagen original en diferentes resoluciones, sino crear din√°micamente la imagen deseada con las dimensiones dadas del original previamente preparado, y lo m√°s r√°pido posible.  Por lo tanto, en tiempo real, puede crear una imagen de la resoluci√≥n deseada e inmediatamente enviarla al usuario.  Es muy importante que la resoluci√≥n de esta imagen se pueda hacer inmediatamente para que el dispositivo del usuario no cambie el tama√±o de la pantalla, ya que simplemente no ser√° necesario. <br><br>  El uso de formatos distintos de JPEG como base para organizar dicho repositorio de im√°genes no parece justificado.  Por supuesto, existen formatos est√°ndar y ampliamente utilizados que ofrecen una mejor compresi√≥n con la misma calidad (JPEG2000, WebP), pero la velocidad de codificaci√≥n y decodificaci√≥n de tales im√°genes es muy baja en comparaci√≥n con JPEG, por lo que tiene sentido elegir JPEG como formato base para almacenar fotos originales, que, si es necesario, se ampliar√° en tiempo real despu√©s de recibir una solicitud del usuario. <br><br>  Por supuesto, adem√°s de los jeeps, cada sitio suele tener im√°genes PNG y GIF, pero generalmente su n√∫mero relativo es peque√±o y las fotos en estos formatos son extremadamente raras.  Por lo tanto, estos formatos no tendr√°n un impacto significativo en la tarea en cuesti√≥n en la mayor√≠a de los casos. <br><br><h2>  Descripci√≥n del algoritmo de cambio de tama√±o sobre la marcha </h2><br>  Por lo tanto, los datos de entrada son archivos JPEG, y para lograr una decodificaci√≥n r√°pida (esto es cierto tanto para la CPU como para la GPU), las im√°genes comprimidas deben tener marcadores de reinicio incorporados.  Estos marcadores se describen en el est√°ndar JPEG y parte de los c√≥decs pueden trabajar con ellos, el resto sabe c√≥mo no notarlos.  Si los jeeps no tienen dichos marcadores, se pueden agregar por adelantado usando la utilidad jpegtran.  Cuando se agregan marcadores, la imagen no cambia, pero el tama√±o del archivo se vuelve un poco m√°s grande.  Como resultado, obtenemos el siguiente esquema de trabajo: <br><br><ol><li>  Obtener datos de imagen de la memoria de la CPU </li><li>  Si hay un perfil de color, cons√≠guelo en la secci√≥n EXIF ‚Äã‚Äãy gu√°rdelo </li><li>  Copie la imagen a la tarjeta de video </li><li>  Decodificar JPEG </li><li>  Hacemos un cambio de tama√±o de acuerdo con el algoritmo de Lanczos (disminuci√≥n) </li><li>  Nitidez </li><li>  Codificamos la imagen usando JPEG </li><li>  Copiar imagen al host </li><li>  Agregue el perfil de color original al archivo resultante. </li></ol><br>  Puede tomar una decisi√≥n m√°s precisa cuando, antes de cambiar el tama√±o, la gamma inversa se superpone en cada componente del p√≠xel para que el cambio de tama√±o est√© en un espacio lineal y luego vuelva a aplicar la gamma, pero despu√©s de la nitidez.  La diferencia real para el usuario es peque√±a, pero existe, y el costo computacional para tal modificaci√≥n es m√≠nimo.  Solo es necesario insertar la superposici√≥n de la gamma inversa y directa en el esquema general de procesamiento. <br><br>  Tambi√©n hay una posible soluci√≥n cuando la decodificaci√≥n de jeeps se realiza en una CPU multin√∫cleo utilizando la biblioteca libjpeg-turbo.  En este caso, cada imagen se decodifica en un flujo de CPU separado, y todas las dem√°s acciones se realizan en la tarjeta de video.  Con una gran cantidad de n√∫cleos de CPU, esto puede suceder a√∫n m√°s r√°pido, pero habr√° una seria p√©rdida de latencia.  Si la latencia al decodificar un jeep en un solo n√∫cleo de CPU es aceptable, entonces esta opci√≥n puede ser muy r√°pida, especialmente en el caso de que los jeeps originales tengan una resoluci√≥n peque√±a.  A medida que aumenta la resoluci√≥n de la imagen original, aumentar√° el tiempo de decodificaci√≥n del jeep en un flujo de CPU, por lo que esta opci√≥n solo puede ser adecuada para resoluciones peque√±as. <br><br><h2>  Requisitos b√°sicos para la tarea de redimensionamiento web </h2><br><ul><li>  Es aconsejable no almacenar docenas de copias de cada imagen en diferentes resoluciones en el servidor, sino crear r√°pidamente la imagen deseada con la resoluci√≥n correcta inmediatamente despu√©s de recibir la solicitud.  Esto es importante para reducir el tama√±o del almacenamiento, ya que de lo contrario tendr√° que almacenar muchas copias diferentes de cada imagen. </li><li>  El problema debe resolverse lo m√°s r√°pido posible.  Esta es una pregunta sobre la calidad del servicio prestado en t√©rminos de reducir el tiempo de respuesta a una solicitud del usuario. </li><li>  La calidad de la imagen enviada debe ser alta. </li><li>  El tama√±o del archivo para la imagen enviada debe ser lo m√°s peque√±o posible, y su resoluci√≥n debe coincidir exactamente con el tama√±o de la ventana en la que aparece.  Los siguientes puntos son importantes aqu√≠: </li></ul><br>  a) Si el tama√±o de la imagen no coincide con el tama√±o de la ventana, el dispositivo del usuario (tel√©fono, tableta, computadora port√°til) cambiar√° el tama√±o del hardware despu√©s de la decodificaci√≥n antes de mostrar la imagen en la pantalla.  En OpenGL, este cambio de tama√±o de hardware se realiza solo de acuerdo con el algoritmo bilineal, que a menudo causa la aparici√≥n de muar√© (manchas) y otros artefactos en las im√°genes que contienen peque√±os detalles. <br><br>  b) Cambiar el tama√±o de la pantalla adem√°s consume energ√≠a del dispositivo. <br><br>  c) Si utiliza una serie de im√°genes preescaladas para resolver el problema, no siempre es posible obtener exactamente el tama√±o correcto, lo que significa que tendr√° que enviar una imagen de mayor resoluci√≥n.  El aumento del tama√±o de la imagen genera m√°s tr√°fico, lo que tambi√©n me gustar√≠a evitar. <br><br><h2>  Descripci√≥n del esquema general de trabajo. </h2><br><ol><li>  Recibimos im√°genes de los usuarios en cualquier formato y en cualquier resoluci√≥n.  Los originales se almacenan en una base de datos separada (si es necesario). </li><li>  Sin conexi√≥n, utilizando ImageMagick o un software similar, guarde el perfil de color, convierta las im√°genes originales originales al formato BMP o PPM est√°ndar, luego cambie el tama√±o a una resoluci√≥n de 1K o 2K y comprima a JPEG, luego agregamos marcadores de reinicio con el intervalo fijo especificado utilizando la utilidad jpegtran. </li><li>  Componemos una base de datos de tales im√°genes 1K o 2K. </li><li>  Al recibir una solicitud del usuario, obtenemos informaci√≥n sobre la imagen y el tama√±o de la ventana donde se debe mostrar esta imagen. </li><li>  Encontramos la imagen en la base de datos y la enviamos al redimensionador. </li><li>  El redimensionador recibe el archivo de imagen, decodifica, redimensiona, enfoca, codifica e inserta el perfil de color original en el jeep resultante.  Despu√©s de eso le da la imagen a un programa externo. </li><li>  En cada tarjeta de video, puede ejecutar varios subprocesos y puede instalar varias tarjetas de video en su computadora, logrando as√≠ una escala de rendimiento. </li><li>  Todo esto se puede hacer sobre la base de las tarjetas de video NVIDIA Tesla (por ejemplo, P40 o V100), ya que las tarjetas de video NVIDIA GeForce no est√°n dise√±adas para un funcionamiento continuo a largo plazo, y NVIDIA Quadro tiene muchas salidas de video que no son necesarias en este caso.  Para resolver este problema, los requisitos para el tama√±o de memoria de la GPU son m√≠nimos. </li><li>  Adem√°s, desde la base de datos con im√°genes preparadas, puede asignar din√°micamente un cach√© para los archivos de uso frecuente.  All√≠ tiene sentido almacenar im√°genes de uso frecuente de acuerdo con las estad√≠sticas del per√≠odo anterior. </li></ol><br><img src="https://habrastorage.org/webt/po/zo/tq/pozotq70cgopg1_g3wvqd8wyzis.jpeg"><br><br><h2>  Par√°metros del programa </h2><br><ol><li>  Ancho y alto de la nueva imagen.  Pueden ser cualquiera y es mejor configurarlos expl√≠citamente. </li><li>  Modo de adelgazamiento JPEG (submuestreo).  Hay tres opciones: 4: 2: 0, 4: 2: 2 y 4: 4: 4, pero generalmente usan 4: 4: 4 o 4: 2: 0.  La calidad m√°xima es 4: 4: 4, el tama√±o de fotograma m√≠nimo es 4: 2: 0.  El adelgazamiento se realiza para componentes de diferencia de color, que la visi√≥n de una persona no percibe tan bien como la luminosidad.  Cada modo de diezmado tiene su propio intervalo √≥ptimo para que los marcadores de reinicio alcancen la velocidad m√°xima de codificaci√≥n o decodificaci√≥n. </li><li>  Calidad de compresi√≥n JPEG y modo de diezmado al crear una base de datos de im√°genes. </li><li>  Sharp se realiza en una ventana de 3x3, se puede controlar sigma (radio). </li><li>  Calidad de compresi√≥n JPEG y modo de decimaci√≥n al codificar la imagen final.  T√≠picamente, una calidad de al menos 90% significa que esta compresi√≥n es "visualmente sin p√©rdida", es decir  Los usuarios no entrenados no deben ver los artefactos del algoritmo JPEG en condiciones de visualizaci√≥n est√°ndar.  Se cree que para un usuario capacitado, se necesita 93-95%.  Cuanto mayor sea este valor, mayor ser√° el tama√±o de la trama enviada al usuario y mayor ser√° el tiempo de decodificaci√≥n y codificaci√≥n. </li></ol><br><h2>  Limitaciones importantes </h2><br>  Reiniciar marcadores.  Podemos decodificar r√°pidamente im√°genes JPEG en una tarjeta de video solo si hay marcadores de reinicio dentro de ella.  En el est√°ndar JPEG oficial, se describen estos marcadores, este es un par√°metro est√°ndar.  Si no hay marcadores de reinicio, entonces es imposible paralelizar la decodificaci√≥n de la imagen en la tarjeta de video, lo que conducir√° a una velocidad muy baja del decodificador.  Por lo tanto, necesitamos una base de datos de im√°genes preparadas en las que existan estos marcadores. <br><br>  Algoritmo fijo para c√≥dec de imagen.  Decodificar y codificar im√°genes usando el algoritmo JPEG es, con mucho, la opci√≥n m√°s r√°pida. <br><br>  La resoluci√≥n de las im√°genes en la base de datos preparada puede ser cualquiera, pero como opciones consideraremos 1K y 2K (puede tomar 4K).  Tambi√©n puede hacer no solo una disminuci√≥n, sino tambi√©n un aumento de las im√°genes al cambiar el tama√±o. <br><br><h2>  Rendimiento de cambio de tama√±o r√°pido </h2><br>  Probamos la aplicaci√≥n para cambiar r√°pidamente el tama√±o del Fastvideo SDK en la tarjeta de video NVIDIA Tesla V100 (OS Windows Server 2016, 64 bits, controlador 24.21.13.9826) en im√°genes de 24 bits 1k_wild.ppm y 2k_wild.ppm con una resoluci√≥n de 1K y 2K (1280x720 y 1920x1080).  Se realizaron pruebas para un n√∫mero diferente de subprocesos que se ejecutan en la misma tarjeta de video.  Esto requiere no m√°s de 110 MB de memoria en la tarjeta de video por transmisi√≥n.  4 transmisiones no necesitan m√°s de 440 MB. <br><br>  Primero, comprimimos la imagen original en JPEG con un 90% de calidad, con un adelgazamiento 4: 2: 0 o 4: 4: 4.  Luego decodificamos y redimensionamos 2 veces en ancho y alto, hacemos una nitidez y luego codificamos nuevamente con un 90% de calidad a 4: 2: 0 o 4: 4: 4.  Los datos de origen est√°n en RAM, la imagen final se coloca all√≠. <br><br>  El tiempo de funcionamiento se cuenta desde el inicio de cargar la imagen original desde la RAM hasta guardar la imagen procesada en la RAM.  El tiempo de inicializaci√≥n del programa y la asignaci√≥n de memoria en la tarjeta de video no est√°n incluidos en las mediciones. <br><br>  Ejemplo de l√≠nea de comando para una imagen 1K de 24 bits <br>  PhotoHostingSample.exe -i 1k_wild.90.444.jpg -o 1k_wild.640.jpg -outputWidth 640 -q 90 -s 444 -sharp_after 0.95 -repeat 200 <br><br><h4>  Punto de referencia para procesar una imagen 1K en un hilo </h4><br>  Decodificaci√≥n (incluida la transferencia de datos a la tarjeta de video): 0.70 ms <br>  Cambiar el tama√±o dos veces (en ancho y en altura): 0.27 ms <br>  Sharp: 0,02 ms <br>  Codificaci√≥n JPEG (incluida la transferencia de datos desde la tarjeta de video): 0.20 ms <br>  <b>Tiempo total por trama: 1.2 ms</b> <br><br><h2>  Rendimiento para 1K </h2><br><table border="1"><tbody><tr><td></td><td>  Calidad </td><td>  Adelgazamiento </td><td>  Redimensionar </td><td>  Corrientes </td><td align="center">  Velocidad de fotogramas (Hz) </td></tr><tr><td>  1 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 veces </td><td>  1 </td><td align="center">  868/682 </td></tr><tr><td>  2 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 veces </td><td>  2 </td><td align="center">  <strong>1039/790</strong> </td></tr><tr><td>  3 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 veces </td><td>  3 </td><td align="center">  <strong>993/831</strong> </td></tr><tr><td>  4 4 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 veces </td><td>  4 4 </td><td align="center">  1003/740 </td></tr></tbody></table><br><br><h2>  Rendimiento para 2K </h2><br><table border="1"><tbody><tr><td></td><td>  Calidad </td><td>  Adelgazamiento </td><td>  Redimensionar </td><td>  Corrientes </td><td align="center">  Velocidad de fotogramas (Hz) </td></tr><tr><td>  1 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 veces </td><td>  1 </td><td align="center">  732/643 </td></tr><tr><td>  2 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 veces </td><td>  2 </td><td align="center">  913/762 </td></tr><tr><td>  3 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 veces </td><td>  3 </td><td align="center">  891/742 </td></tr><tr><td>  4 4 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 veces </td><td>  4 4 </td><td align="center">  <strong>923/763</strong> </td></tr></tbody></table><br><br>  El adelgazamiento 4: 2: 0 para la imagen de origen reduce la velocidad, pero el tama√±o de los archivos de origen y de destino se reduce.  Al cambiar a 4: 2: 0, el grado de paralelismo disminuye 4 veces, ya que ahora el bloque 16x16 se considera como una sola unidad, por lo tanto, en este modo, la velocidad es menor que para 4: 4: 4. <br><br>  El rendimiento est√° determinado principalmente por la etapa de decodificaci√≥n JPEG, porque en esta etapa la imagen tiene la resoluci√≥n m√°xima, y ‚Äã‚Äãla complejidad computacional de esta etapa de procesamiento es m√°s alta que todas las dem√°s. <br><br><h2>  Resumen </h2><br>  Los resultados de la prueba mostraron que para la tarjeta de video NVIDIA Tesla V100, la velocidad de procesamiento de im√°genes de 1K y 2K es m√°xima cuando se lanzan 2-4 transmisiones al mismo tiempo, y var√≠a de 800 a 1000 cuadros por segundo por tarjeta de video.  Procesar im√°genes 1K es m√°s r√°pido que 2K, y trabajar con im√°genes 4: 2: 0 siempre es m√°s lento que con 4: 4: 4.  Para obtener el resultado final del rendimiento, debe determinar con precisi√≥n todos los par√°metros del programa y optimizarlo para un modelo espec√≠fico de la tarjeta de video. <br><br>  La latencia del orden de un milisegundo es un buen resultado.  Hasta donde sabemos, dicha latencia no se puede obtener para una tarea de cambio de tama√±o similar en la CPU (incluso si no hay necesidad de codificar y decodificar jeeps), por lo que este es otro argumento importante a favor del uso de tarjetas de video en soluciones de procesamiento de im√°genes de alto rendimiento. <br><br>  Se pueden requerir hasta 16 tarjetas gr√°ficas NVIDIA Tesla V100 para procesar mil millones de jeeps por d√≠a con resoluciones de 1K o 2K.  Algunos de nuestros clientes ya usan esta soluci√≥n, mientras que otros la prueban en sus tareas. <br><br>  Cambiar el tama√±o de los jeeps en una tarjeta de video puede ser muy √∫til no solo para los servicios web.  Hay una gran cantidad de aplicaciones de procesamiento de im√°genes de alto rendimiento donde dicha funcionalidad puede ser muy solicitada.  Por ejemplo, a menudo es necesario un cambio de tama√±o r√°pido para casi cualquier esquema de procesamiento de im√°genes recibidas de c√°maras antes de mostrar una imagen en un monitor.  Esta soluci√≥n puede funcionar para Windows / Linux en cualquier tarjeta gr√°fica NVIDIA: Tegra K1 / X1 / X2 / Xavier, GeForce GT / GTX / RTX, Quadro, Tesla. <br><br><h2>  Ventajas de una soluci√≥n de cambio de tama√±o r√°pido en una tarjeta gr√°fica </h2><br><ul><li>  Reducci√≥n significativa en el tama√±o de almacenamiento para im√°genes de origen </li><li>  Reducci√≥n de costos primarios para costos de infraestructura (hardware y software) </li><li>  Mejora de la calidad del servicio debido al corto tiempo de respuesta. </li><li>  Reducci√≥n de tr√°fico saliente </li><li>  Menor consumo de energ√≠a en dispositivos de usuario </li><li>  Fiabilidad y velocidad de la soluci√≥n presentada, que ya se ha probado en grandes conjuntos de datos. </li><li>  Tiempo de desarrollo reducido para comercializar dichas aplicaciones para Linux y Windows </li><li>  Escalabilidad de una soluci√≥n que puede funcionar tanto en una sola tarjeta de video como como parte de un cl√∫ster </li><li>  R√°pido retorno de la inversi√≥n para tales proyectos. </li></ul><br><h2>  Quien puede estar interesado </h2><br>  La biblioteca para el cambio r√°pido de tama√±o de jeeps se puede utilizar en servicios web altamente cargados, grandes tiendas en l√≠nea, redes sociales, sistemas de administraci√≥n de fotograf√≠as en l√≠nea, comercio electr√≥nico, en casi cualquier software de administraci√≥n de grandes empresas. <br><br>  Los desarrolladores de software pueden usar esta biblioteca, que proporciona una latencia del orden de varios milisegundos para cambiar el tama√±o de los jeeps con una resoluci√≥n de 1K, 2K y 4K en una tarjeta de video. <br><br>  Aparentemente, este enfoque puede resultar m√°s r√°pido que la soluci√≥n NVIDIA DALI para la decodificaci√≥n r√°pida de jeeps, el cambio de tama√±o y la preparaci√≥n de im√°genes durante la etapa de capacitaci√≥n de redes neuronales para Deep Learning. <br><br><h2>  ¬øQu√© m√°s se puede hacer? </h2><br><ul><li>  Adem√°s de cambiar el tama√±o y el enfoque, puede agregar recorte, giros a 90/180/270, superposici√≥n de marca de agua, control de brillo y contraste al algoritmo existente. </li><li>  Optimizaci√≥n de soluciones para tarjetas gr√°ficas NVIDIA Tesla P40 y V100 </li><li>  Optimizaci√≥n adicional del rendimiento del decodificador JPEG. </li><li>  Modo de r√°faga para decodificar jeeps en una tarjeta de video. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424575/">https://habr.com/ru/post/es424575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424565/index.html">Descripci√≥n general: escaneo 3D de locales inmobiliarios</a></li>
<li><a href="../es424567/index.html">La experiencia de bloquear la publicidad en l√≠nea en la red local de la compa√±√≠a.</a></li>
<li><a href="../es424569/index.html">Contrataci√≥n de programadores. Consejos de programador</a></li>
<li><a href="../es424571/index.html">Das Das Corporate Experiment</a></li>
<li><a href="../es424573/index.html">Vida y muerte de las mitocondrias.</a></li>
<li><a href="../es424577/index.html">JUG.EKB: fusi√≥n utilizando mitaps de desarrollador Java</a></li>
<li><a href="../es424579/index.html">No caiga en la trampa con Oracle JDK 11</a></li>
<li><a href="../es424581/index.html">¬øQuieres ganar una carrera de h√©roes? Obtenga una receta de LANIT</a></li>
<li><a href="../es424583/index.html">No ser√°s un h√©roe si eres un desarrollador</a></li>
<li><a href="../es424585/index.html">CryEngine 5.5 lanzado por Crytek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>