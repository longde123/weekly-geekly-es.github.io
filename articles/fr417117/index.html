<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé© ‚è∞ üõ∏ R√©tro-ing√©nierie de l'√©mulateur NES dans le jeu pour GameCube ü§µüèø üßóüèø üí™üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En cherchant des moyens d'activer les menus du d√©veloppeur laiss√©s dans Animal Crossing, y compris le menu de s√©lection de jeu pour l'√©mulateur NES, j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R√©tro-ing√©nierie de l'√©mulateur NES dans le jeu pour GameCube</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417117/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png" alt="image"></div><br>  En cherchant des moyens d'activer les menus du d√©veloppeur laiss√©s dans Animal Crossing, y compris le menu de s√©lection de jeu pour l'√©mulateur NES, j'ai trouv√© une fonction int√©ressante qui existe dans le jeu original et √©tait constamment active, mais n'a jamais √©t√© utilis√©e par Nintendo. <br><br>  En plus des jeux NES / Famicom en jeu, vous pouvez t√©l√©charger de nouveaux jeux NES √† partir d'une carte m√©moire. <br><br>  J'ai √©galement r√©ussi √† trouver un moyen d'utiliser ce chargeur de d√©marrage ROM pour patcher mon code et mes donn√©es dans le jeu, ce qui vous permet d'ex√©cuter du code via une carte m√©moire. <br><br><h2>  Introduction - Objets de console NES </h2><br>  Les jeux NES ordinaires, qui peuvent √™tre obtenus aupr√®s d'Animal Crossing, sont des meubles s√©par√©s sous la forme d'une console NES avec une cartouche pos√©e dessus. <br><br>  Apr√®s avoir localis√© cet objet dans votre maison et interagir avec lui, vous pouvez ex√©cuter ce seul jeu.  L'image ci-dessous montre Excitebike et Golf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/e33/409/40ee334095bd1151c3c968a84f8cf92b.png"></div><a name="habracut"></a><br>  Il existe √©galement un objet NES Console commun dans lequel il n'y a pas de jeux int√©gr√©s.  Il peut √™tre achet√© aupr√®s de Redd, et parfois obtenu par le biais d'√©v√©nements al√©atoires, par exemple, en lisant sur le tableau d'affichage de la ville que la console est enterr√©e √† un endroit al√©atoire de la ville. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/d20/687/f41d20687aed7d6a4d044a5a5d084045.png"></div><br>  Cet objet ressemble √† une console NES sur laquelle il n'y a pas de cartouches. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/010/9a3/35c0109a32b31deeb202280773f363a0.png"></div><br>  Le probl√®me avec cet objet est qu'il √©tait consid√©r√© comme injouable.  Chaque fois que vous interagissez avec lui, vous voyez juste un message disant que vous n'avez pas de logiciel de jeu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/6d3/3b8/a9e6d33b8e039a2f17c12fd134cf0308.png"></div><br>  Il s'est av√©r√© que cet objet essayait r√©ellement de scanner la carte m√©moire pour des fichiers sp√©cialement con√ßus contenant des images ROM pour NES!  L'√©mulateur NES utilis√© pour ex√©cuter des jeux int√©gr√©s semble √™tre l'√©mulateur NES standard complet pour le GameCube, et est capable de lancer la plupart des jeux. <br><br>  Avant de d√©montrer ces fonctionnalit√©s, je vais expliquer le processus de r√©tro-ing√©nierie. <br><br><h2>  Rechercher le chargeur de d√©marrage ROM sur la carte m√©moire </h2><br><h3>  Nous recherchons un menu d√©veloppeur </h3><br>  Au d√©part, je voulais trouver un code qui active divers menus de d√©veloppeur, tels que le menu de s√©lection de carte ou le menu de s√©lection de jeu pour l'√©mulateur NES.  Le menu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Forest Map Select</a> , gr√¢ce auquel vous pouvez facilement charger instantan√©ment diff√©rents endroits du jeu, √©tait assez simple √† trouver - je viens de chercher la ligne FOREST MAP SELECT qui appara√Æt en haut de l'√©cran (on peut la voir dans diff√©rentes vid√©os et captures d'√©cran sur Internet ) <br><br>  Dans ¬´FOREST MAP SELECT¬ª, il existe des r√©f√©rences crois√©es de donn√©es √† la fonction <code>select_print_wait</code> , ce qui conduit √† un tas d'autres fonctions qui ont √©galement le pr√©fixe <code>select_*</code> , y compris la fonction <code>select_init</code> .  Ils se sont av√©r√©s √™tre des fonctions qui contr√¥lent le menu de s√©lection de carte. <br><br>  La fonction <code>select_init</code> m√®ne √† une autre fonction int√©ressante appel√©e <code>game_get_next_game_dlftbl</code> .  Cette fonction relie tous les autres menus et ¬´sc√®nes¬ª que vous pouvez ex√©cuter: un √©cran avec le logo Nintendo, l'√©cran principal, le menu de s√©lection de carte, le menu d'√©mulateur NES (Famicom), etc.  Il commence au d√©but de la proc√©dure de jeu principale, recherche la fonction d'initialisation de sc√®ne √† ex√©cuter et trouve son entr√©e dans la structure de donn√©es de la table appel√©e <code>game_dlftbls</code> .  Ce tableau contient des liens vers les fonctions de traitement de diverses sc√®nes, ainsi que d'autres donn√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d93/cbc/019/d93cbc0191a754e6bb566525f1a21666.png"></div><br>  Une √©tude attentive du premier bloc de la fonction a montr√© qu'il charge la fonction "next game init", puis commence √† le comparer avec une s√©rie de fonctions init bien connues: <br><br><ul><li> <code>first_game_init</code> </li> <li> <code>select_init</code> </li> <li> <code>play_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>player_select_init</code> </li> <li> <code>save_menu_init</code> </li> <li> <code>famicom_emu_init</code> </li> <li> <code>prenmi_init</code> </li> </ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/785/bae/2e6785bae4c526f3acba034d4f7e4b2e.png"></div><br>  L'un des pointeurs de fonction qu'il recherche est <code>famicom_emu_init</code> , qui est responsable de l'ex√©cution de l'√©mulateur NES / Famicom.  <code>game_get_next_game_init</code> r√©sultat <code>game_get_next_game_init</code> √† <code>famicom_emu_init</code> ou <code>select_init</code> dans le d√©bogueur Dolphin, j'ai pu afficher des menus sp√©ciaux.  L'√©tape suivante consiste √† d√©terminer comment ces pointeurs sont d√©finis de mani√®re normale lors de l'ex√©cution du programme.  La seule chose que fait la fonction <code>game_get_next_game_init</code> est de charger la valeur √† l'offset <code>0xC</code> premier argument dans <code>game_get_next_game_dlftbl</code> . <br><br>  Garder une trace de ces valeurs d√©finies dans diverses structures de donn√©es √©tait un peu ennuyeux, donc je vais aller directement au c≈ìur.  La chose la plus importante que j'ai trouv√©e: <br><br><ul><li>  Lorsque le jeu d√©marre de la mani√®re habituelle, il ex√©cute la s√©quence d'actions suivante: <br><ul><li> <code>first_game_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>play_init</code> </li> </ul></li><li>  <code>player_select_init</code> d√©finit le prochain init sur <code>select_init</code> .  Cet √©cran devrait vous permettre de s√©lectionner un joueur imm√©diatement apr√®s avoir choisi une carte, mais il semble que cela ne fonctionne pas correctement. </li></ul><br>  J'ai √©galement trouv√© une fonction sans nom qui d√©finit la fonction init de l'√©mulateur, mais je n'ai rien trouv√© qui d√©finit la fonction init sur la valeur init du joueur ou du choix de carte. <br><br>  √Ä ce stade, j'ai r√©alis√© que j'avais un autre probl√®me stupide avec la fa√ßon dont je chargeais les noms de fonctions dans l'IDA: en raison de l'expression r√©guli√®re utilis√©e pour couper les lignes dans le fichier de symboles de d√©bogage, j'ai rat√© tous les noms de fonctions commen√ßant par une lettre majuscule .  La fonction mise en <code>famicom_emu_init</code> ressemblait √† des transitions entre les sc√®nes et, bien s√ªr, s'appelait <code>Game_play_fbdemo_wipe_proc</code> . <br><br>  <code>Game_play_fbdemo_wipe_proc</code> g√®re les transitions entre les sc√®nes, telles que les <code>Game_play_fbdemo_wipe_proc</code> d'√©cran et les pannes. <br><br>  Dans certaines conditions, la transition d'√©cran a √©t√© effectu√©e du gameplay habituel √† l'affichage de l'√©mulateur.  C'est lui qui a d√©fini la fonction init de l'√©mulateur. <br><br><h3>  Gestion des objets de la console </h3><br>  En fait, les gestionnaires d'objets de mobilier pour consoles NES font basculer le gestionnaire de transition d'√©cran vers l'√©mulateur.  Lorsqu'un joueur interagit avec l'une des consoles, <code>aMR_FamicomEmuCommonMove</code> est <code>aMR_FamicomEmuCommonMove</code> . <br><br>  Lors de l'appel de la fonction, <code>r6</code> contient la valeur d'index correspondant aux nombres dans les noms des fichiers de jeu NES dans <code>famicom.arc</code> : <br><br><ul><li> <code>01_nes_cluclu3.bin.szs</code> </li> <li> <code>02_usa_balloon.nes.szs</code> </li> <li> <code>03_nes_donkey1_3.bin.szs</code> </li> <li> <code>04_usa_jr_math.nes.szs</code> </li> <li> <code>05_pinball_1.nes.szs</code> </li> <li> <code>06_nes_tennis3.bin.szs</code> </li> <li> <code>07_usa_golf.nes.szs</code> </li> <li> <code>08_punch_wh.nes.szs</code> </li> <li> <code>09_usa_baseball_1.nes.szs</code> </li> <li> <code>10_cluclu_1.qd.szs</code> </li> <li> <code>11_usa_donkey3.nes.szs</code> </li> <li> <code>12_donkeyjr_1.nes.szs</code> </li> <li> <code>13_soccer.nes.szs</code> </li> <li> <code>14_exbike.nes.szs</code> </li> <li> <code>15_usa_wario.nes.szs</code> </li> <li> <code>16_usa_icecl.nes.szs</code> </li> <li> <code>17_nes_mario1_2.bin.szs</code> </li> <li> <code>18_smario_0.nes.szs</code> </li> <li> <code>19_usa_zelda1_1.nes.szs</code> </li> </ul><br>  ( <code>.arc</code> est un format d'archivage de fichiers propri√©taire.) <br><br>  Lorsque <code>r6</code> pas √©gal √† z√©ro, il est transmis dans <code>aMR_RequestStartEmu</code> appel √† <code>aMR_RequestStartEmu</code> .  Dans ce cas, la transition vers l'√©mulateur est d√©clench√©e. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/268/1d7/f782681d712b4098ad6f9269cf2df5cc.png"></div><br>  Cependant, si <code>r6</code> est nul, la fonction <code>aMR_RequestStartEmu_MemoryC</code> est appel√©e √† la <code>aMR_RequestStartEmu_MemoryC</code> .  En d√©finissant la valeur dans le d√©bogueur √† 0, j'ai re√ßu le message ¬´Je n'ai aucun logiciel¬ª.  Je ne me souvenais pas imm√©diatement que je devais v√©rifier l'objet console NES pour m'assurer qu'il r√©initialise la valeur <code>r6</code> , mais il s'est av√©r√© que l'index z√©ro est utilis√© pour l'objet console sans cartouche. <br><br>  Bien que <code>aMR_RequestStartEmu</code> stocke simplement la valeur d'index dans une sorte de structure de donn√©es, <code>aMR_RequestStartEmu_MemoryC</code> effectue des op√©rations beaucoup plus complexes ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d23/844/831/d23844831e1e9f9b8ef5b6a4306948ab.png"></div><br>  Ce troisi√®me bloc de code appelle <code>aMR_GetCardFamicomCount</code> et v√©rifie un r√©sultat diff√©rent de z√©ro, sinon il ignore la plupart des choses int√©ressantes sur le c√¥t√© gauche du graphique de fonction. <br><br>  <code>aMR_GetCardFamicomCount</code> appelle <code>famicom_get_disksystem_titles</code> , qui appelle ensuite <code>memcard_game_list</code> , et ici tout devient tr√®s int√©ressant. <br><br>  <code>memcard_game_list</code> monte la carte m√©moire et commence √† se d√©placer dans le cycle d'√©criture de fichier, en v√©rifiant chacune de certaines valeurs.  En suivant la fonction dans le d√©bogueur, j'ai pu comprendre qu'il comparait les valeurs avec chacun de mes fichiers sur la carte m√©moire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/e17/dd1/da1e17dd1b1acd6552eeeabaedc586fb.png"></div><br>  La fonction d√©cide de t√©l√©charger ou non le fichier, en fonction des r√©sultats de la v√©rification de plusieurs lignes.  Tout d'abord, il v√©rifie la pr√©sence des lignes ¬´GAFE¬ª et ¬´01¬ª, qui sont les identifiants du jeu et de la soci√©t√©.  01 signifie Nintendo, GAFE signifie Animal Crossing.  Je pense que cela signifie GameCube Animal Forest English. <br><br>  Elle v√©rifie ensuite les lignes ¬´DobutsunomoriP_F_¬ª et ¬´SAVE¬ª.  Dans ce cas, la premi√®re ligne doit correspondre, mais pas la seconde.  Il s'est av√©r√© que "DobutsunomoriP_F_SAVE" est le nom du fichier qui stocke les donn√©es des jeux int√©gr√©s pour NES.  Par cons√©quent, tous les fichiers sauf celui-ci seront charg√©s avec le pr√©fixe ¬´DobutsunomoriP_F_¬ª. <br><br>  En utilisant le d√©bogueur Dolphin pour ignorer les comparaisons de cha√Ænes avec "SAVE" et en faisant le truc du jeu pour croire que mon fichier "SAVE" peut √™tre t√©l√©charg√© en toute s√©curit√©, j'ai obtenu ce menu apr√®s avoir utilis√© la console NES: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/1d2/696/1d41d26963aeaf11450155f1d7d53085.png"></div><br>  J'ai r√©pondu ¬´Oui¬ª et j'ai essay√© de charger le fichier de sauvegarde en tant que jeu, apr√®s quoi j'ai vu pour la premi√®re fois l'√©cran de blocage du jeu int√©gr√©: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/662/4cc/41e6624cc68fe28e897cd1803ba1a39a.png"></div><br>  Super!  Maintenant, je sais qu'elle essaie en fait de t√©l√©charger des jeux √† partir d'une carte m√©moire et je peux commencer √† analyser le format des fichiers de sauvegarde pour voir si une vraie ROM peut √™tre t√©l√©charg√©e. <br><br>  La premi√®re chose que j'ai essay√© de faire √©tait d'essayer de trouver o√π le nom du jeu est lu dans le fichier de la carte m√©moire.  En recherchant la ligne ¬´FEFSC¬ª qui √©tait pr√©sente dans le message ¬´Voulez-vous jouer &lt;nom&gt;?¬ª, J'ai trouv√© l'offset auquel il a √©t√© lu dans le fichier: <code>0x642</code> .  J'ai copi√© le fichier de sauvegarde, chang√© le nom du fichier en ¬´DobutsunomoriP_F_TEST¬ª, chang√© les octets √† l'offset <code>0x642</code> en ¬´TEST¬ª et import√© la sauvegarde modifi√©e, apr√®s quoi le nom dont j'avais besoin apparaissait dans le menu. <br><br>  Apr√®s avoir ajout√© quelques fichiers suppl√©mentaires dans ce format, quelques options suppl√©mentaires sont apparues dans le menu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/ca3/668/235ca3668ae0a02ad2609847bdf193c0.png"></div><br><h3>  T√©l√©charger la ROM </h3><br>  Si <code>aMR_GetCardFamicomCount</code> retourn√© diff√©rent de z√©ro, puis la m√©moire est allou√©e sur le tas, <code>famicom_get_disksystem_titles</code> est directement appel√© √† <code>famicom_get_disksystem_titles</code> , apr√®s quoi un tas de d√©calages al√©atoires est sp√©cifi√© dans la structure de donn√©es.  Au lieu de d√©chiffrer o√π ces valeurs seront lues, j'ai commenc√© √† √©tudier la liste des fonctions <code>famicom</code> . <br><br>  Il s'est av√©r√© que j'avais besoin de <code>famicom_rom_load</code> .  Il contr√¥le le chargement de la ROM, soit depuis une carte m√©moire, soit depuis les ressources internes du jeu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/22b/462/99922b462892ef544d45e849da1c54a5.png"></div><br>  La chose la plus importante dans ce bloc "d√©marrage √† partir de la carte m√©moire" est qu'il appelle <br>  <code>memcard_game_load</code> .  Elle monte √† nouveau le fichier sur la carte m√©moire, le lit et analyse.  C'est l√† que les options de format de fichier les plus importantes deviennent apparentes. <br><br><h4>  Valeur de somme de contr√¥le </h4><br>  La premi√®re chose qui se produit apr√®s le t√©l√©chargement du fichier est le calcul de la somme de contr√¥le.  La fonction <code>calcSum</code> est <code>calcSum</code> , qui est un algorithme tr√®s simple qui additionne les valeurs de tous les octets dans les donn√©es de la carte m√©moire.  Les huit derniers bits du r√©sultat doivent √™tre nuls.  Autrement dit, pour r√©ussir cette v√©rification, vous devez additionner les valeurs de tous les octets dans le fichier source, calculer la valeur qui doit √™tre ajout√©e pour que les huit derniers bits deviennent nuls, puis affecter cette valeur √† l'octet de somme de contr√¥le dans le fichier. <br><br>  Si la v√©rification √©choue, vous recevez un message sur l'impossibilit√© de lire correctement la carte m√©moire et rien ne se passe.  Pendant le d√©bogage, tout ce que j'ai √† faire est de sauter cette v√©rification. <br><br><h4>  Copier la ROM </h4><br>  Vers la fin de <code>memcard_game_load</code> , une autre chose int√©ressante se produit.  Il existe plusieurs blocs de code plus int√©ressants entre celui-ci et la somme de contr√¥le, mais aucun d'entre eux ne conduit √† une ramification qui ignore l'ex√©cution de ce comportement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/376/55d/cc837655d2ec1b207b0f7420db856a1e.png"></div><br>  Si une certaine valeur enti√®re de 16 bits lue sur la carte m√©moire n'est pas √©gale √† z√©ro, une fonction est appel√©e qui v√©rifie l'en-t√™te de compression dans le tampon.  Il v√©rifie les formats de compression Nintendo propri√©taires en examinant le d√©but du tampon Yay0 ou Yaz0.  Si l'une de ces lignes est trouv√©e, la fonction de d√©compression est appel√©e.  Sinon, une simple fonction de copie copie est ex√©cut√©e.  Dans tous les cas, apr√®s cela, une variable appel√©e <code>nesinfo_data_size</code> . <br><br>  Un autre indice de contexte ici est que les fichiers ROM pour les jeux NES int√©gr√©s utilisent la compression Yaz0, et cette ligne est pr√©sente dans les en-t√™tes de leurs fichiers. <br><br>  Apr√®s avoir observ√© la valeur v√©rifi√©e pour z√©ro et le tampon pass√© aux fonctions de v√©rification de la compression, j'ai rapidement d√©couvert d'o√π le jeu √©tait lu dans le fichier sur la carte m√©moire.  La v√©rification du z√©ro est effectu√©e pour une partie du tampon de 32 octets copi√© √† partir de l'offset <code>0x640</code> dans le fichier, qui est tr√®s probablement l'en-t√™te ROM.  Cette fonction v√©rifie √©galement d'autres parties du fichier, et c'est en elles que se trouve le nom du jeu (en commen√ßant par le troisi√®me octet de l'en-t√™te). <br><br>  Dans le chemin d'ex√©cution du code que j'ai trouv√©, le tampon ROM est situ√© imm√©diatement apr√®s ce tampon d'en-t√™te de 32 octets. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/01f/34c/7c201f34c3b9427c288654d487acbcbf.png"></div><br>  Ces informations suffisent pour essayer de cr√©er un fichier ROM fonctionnel.  Je viens de prendre l'un des autres fichiers de sauvegarde d'Animal Crossing et de le <code>DobutsunomoriP_F_TEST</code> dans un √©diteur hexad√©cimal pour remplacer le nom du fichier par <code>DobutsunomoriP_F_TEST</code> et effacer toutes les zones o√π je voulais coller les donn√©es. <br><br>  Pour un essai, j'ai utilis√© la ROM du jeu Pinball, qui est d√©j√† dans le jeu, et j'ai ins√©r√© son contenu apr√®s l'en-t√™te de 32 octets.  Au lieu de calculer la valeur de la somme de contr√¥le, j'ai d√©fini des points d'arr√™t de sorte que je saute simplement <code>calcSum</code> et observe √©galement les r√©sultats d'autres v√©rifications qui peuvent conduire √† une branche qui ignore le processus de d√©marrage de la ROM. <br><br>  Enfin, j'ai import√© le nouveau fichier via le gestionnaire de cartes m√©moire Dolphin, red√©marr√© le jeu et essay√© de lancer la console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/d08/799/199d087997375f8666284220e7ffcc62.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/be8/5f5/527be85f54ab8f37609047d323c6b442.png"></div><br>  √áa a march√©!  Il y avait quelques petits bugs graphiques li√©s aux param√®tres de Dolphin, qui affectaient le mode graphique utilis√© par l'√©mulateur NES, mais en g√©n√©ral le jeu fonctionnait tr√®s bien.  (Dans les nouvelles versions de Dolphin, cela devrait fonctionner par d√©faut.) <br><br>  Pour m'assurer que d'autres jeux d√©marrent √©galement, j'ai essay√© d'√©crire plusieurs autres ROM qui n'√©taient pas dans le jeu.  Battletoads a commenc√©, mais a cess√© de fonctionner apr√®s le texte de l'√©cran de d√©marrage (apr√®s d'autres r√©glages, j'ai r√©ussi √† le rendre jouable).  Mega Man, en revanche, fonctionnait parfaitement: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/5a2/7da/9235a27da4d094a496a477cc24cd4846.png"></div><br>  Afin d'apprendre √† g√©n√©rer de nouveaux fichiers ROM qui pourraient √™tre charg√©s sans l'intervention de d√©bogueurs, j'ai d√ª commencer √† √©crire du code et mieux comprendre l'analyse du format de fichier. <br><br><h3>  Format de fichier ROM externe </h3><br>  La partie la plus importante de l'analyse des fichiers se produit √† <code>memcard_game_load</code> .  Il existe six sections principales de blocs d'analyse de code dans cette fonction: <br><br><ul><li>  Somme de contr√¥le </li><li>  Enregistrer le nom du fichier </li><li>  En-t√™te de fichier ROM </li><li>  Tampon inconnu copi√© sans aucun traitement </li><li>  Commentaires texte, ic√¥ne et chargeur de banni√®re (pour cr√©er un nouveau fichier de sauvegarde) </li><li>  Chargeur de d√©marrage ROM </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/194/51e/f0019451e2d0070900f75c62cb83535a.png"></div><br><h4>  Somme de contr√¥le </h4><br>  Les huit derniers bits de la somme de toutes les valeurs d'octets dans le fichier de sauvegarde doivent √™tre nuls.  Voici un code Python simple g√©n√©rant l'octet de somme de contr√¥le n√©cessaire: <br><br><pre> <code class="python hljs">checksum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data_tmp: checksum += byte_val checksum = checksum % (<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-comment"><span class="hljs-comment"># keep it 32 bit checkbyte = 256 - (checksum % 256) new_data_tmp[-1] = checkbyte</span></span></code> </pre> <br>  Il y a probablement un endroit sp√©cial pour stocker l'octet de somme de contr√¥le, mais l'ajouter √† l'espace vide √† la toute fin du fichier de sauvegarde fonctionne tr√®s bien. <br><br><h4>  Nom du fichier </h4><br>  Encore une fois, le nom du fichier de sauvegarde doit commencer par "DobutsunomoriP_F_" et se terminer par quelque chose qui ne contient pas "SAVE".  Ce nom de fichier est copi√© plusieurs fois et dans un cas, la lettre ¬´F¬ª est remplac√©e par ¬´S¬ª.  Ce sera le nom des fichiers de sauvegarde pour le jeu NES ("DobutsunomoriP_S_NAME"). <br><br><h4>  En-t√™te ROM </h4><br>  Une copie directe de l'en-t√™te de 32 octets est charg√©e en m√©moire.  Certaines des valeurs de cet en-t√™te sont utilis√©es pour d√©terminer comment g√©rer les sections suivantes.  Fondamentalement, ce sont des valeurs de taille de 16 bits et des bits de param√®tres compress√©s. <br><br>  Si vous tracez le pointeur copi√© par l'en-t√™te jusqu'au d√©but de la fonction et trouvez la position de son argument, la signature de la fonction ci-dessous montrera qu'elle a en fait le type <code>MemcardGameHeader_t*</code> . <br><br><pre> <code class="python hljs">memcard_game_load(unsigned char *, int, unsigned char **, char *, char *, MemcardGameHeader_t *, unsigned char *, unsigned long, unsigned char *, unsigned long)</code> </pre> <br><h4>  Tampon inconnu </h4><br>  V√©rifie la valeur de taille 16 bits de l'en-t√™te.  S'il n'est pas √©gal √† z√©ro, le nombre d'octets correspondant est directement copi√© du tampon de fichiers vers un nouveau bloc de m√©moire allou√©e.  Cela d√©place le pointeur de donn√©es dans le tampon de fichier afin que la copie puisse continuer √† partir de la section suivante. <br><br><h4>  Banni√®re, ic√¥ne et commentaire </h4><br>  Une autre valeur de taille est v√©rifi√©e dans l'en-t√™te, et si elle n'est pas √©gale √† z√©ro, la fonction de v√©rification de compression de fichier est appel√©e.  Si n√©cessaire, l'algorithme de d√©compression sera lanc√©, apr√®s quoi <code>SetupExternCommentImage</code> est <code>SetupExternCommentImage</code> . <br><br>  Cette fonction fait trois choses: ¬´commentaire¬ª, image de banni√®re et ic√¥ne.  Pour chacun d'eux, il y a un code dans l'en-t√™te ROM montrant comment les g√©rer.  Il existe les options suivantes: <br><br><ol><li>  Utiliser la valeur par d√©faut </li><li>  Copier de la banni√®re / ic√¥ne / section de commentaires dans le fichier ROM </li><li>  Copier √† partir d'un autre tampon </li></ol><br>  Les valeurs par d√©faut du code entra√Ænent le chargement de l'ic√¥ne ou de la banni√®re √† partir de la ressource sur le disque, et le nom du fichier de sauvegarde et le commentaire (description textuelle du fichier) re√ßoivent les valeurs ¬´Animal Crossing¬ª et ¬´NES Cassette Save Data¬ª.  Voici √† quoi √ßa ressemble: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/906/519/045/906519045718e74cf565c2983401692c.png"></div><br>  La deuxi√®me valeur du code copie simplement le nom du jeu √† partir du fichier ROM (une alternative √† "Animal Crossing"), puis essaie de trouver la cha√Æne "] ROM" dans le commentaire du fichier et de la remplacer par "] SAVE".  Apparemment, les fichiers que Nintendo voulait publier √©taient cens√©s √™tre au format des noms ¬´ROM de nom de jeu [NES]¬ª ou quelque chose de similaire. <br><br>  Pour l'ic√¥ne et la banni√®re, le code essaie de d√©terminer le format d'image, d'obtenir une valeur de taille fixe correspondant √† ce format, puis de copier l'image. <br><br>  √Ä la derni√®re valeur de code, le nom et la description du fichier sont copi√©s sans modifications √† partir du tampon, et l'ic√¥ne et la banni√®re sont √©galement charg√©es √† partir du tampon alternatif. <br><br><h4>  ROM </h4><br>  Si vous regardez attentivement la capture d'√©cran de la ROM de copie <code>memcard_game_load</code> , vous pouvez voir que la valeur de 16 bits v√©rifi√©e pour l'√©galit√© √† z√©ro est d√©cal√©e vers la gauche de 4 bits (multipli√©e par 16), puis elle est utilis√©e comme taille de la fonction <code>memcpy</code> si la compression n'est pas d√©tect√©e.  Il s'agit d'une autre valeur de taille pr√©sente dans l'en-t√™te. <br><br>  Si la taille n'est pas √©gale √† z√©ro, les donn√©es ROM sont v√©rifi√©es pour la compression, puis copi√©es. <br><br><h3>  Recherche de tampon et de bogue inconnue </h3><br>  Bien que le t√©l√©chargement de nouvelles ROM soit assez curieux, la chose la plus int√©ressante √† propos de ce chargeur de ROM pour moi √©tait qu'en fait c'est la seule partie du jeu qui re√ßoit des entr√©es utilisateur de taille variable et les copie dans diff√©rents emplacements de m√©moire.  Presque tout le reste utilise des tampons de taille constante.  Des choses comme les noms et les textes des lettres peuvent sembler de longueur diff√©rente, mais essentiellement l'espace vide est simplement rempli d'espaces.  Les cha√Ænes termin√©es par z√©ro sont rarement utilis√©es, ce qui √©vite les bogues de corruption de m√©moire courants, tels que l'utilisation de <code>strcpy</code> avec un tampon trop petit pour copier les cha√Ænes. <br><br>  J'√©tais tr√®s int√©ress√© par la possibilit√© de trouver un exploit du jeu bas√© sur des fichiers de sauvegarde, et il semblait que c'√©tait la meilleure option. <br><br>  La plupart des op√©rations de fichiers ROM d√©crites ci-dessus utilisent des copies de taille constante, √† l'exception d'un tampon inconnu et de donn√©es ROM.  Malheureusement, le code qui traite ce tampon alloue exactement autant d'espace qu'il est n√©cessaire pour le copier, il n'y a donc pas de d√©bordement et la d√©finition de tr√®s grandes tailles de fichiers ROM n'√©tait pas tr√®s utile. <br><br>  Mais je voulais quand m√™me savoir ce qui arrive √† ce tampon, qui est copi√© sans aucun traitement. <br><br><h4>  Gestionnaires d'√©tiquettes d'informations NES </h4><br>  Je suis retourn√© √† <code>famicom_rom_load</code> .  Apr√®s avoir charg√© la ROM √† partir d'une carte m√©moire ou d'un disque, plusieurs fonctions sont appel√©es: <br><br><ul><li> <code>nesinfo_tag_process1</code> </li> <li> <code>nesinfo_tag_process2</code> </li> <li> <code>nesinfo_tag_process3</code> </li> </ul><br>  Apr√®s avoir suivi l'endroit o√π le tampon inconnu est copi√©, je me suis assur√© que cette t√¢che est effectu√©e par ces fonctions.  Ils commencent par un appel √† <code>nesinfo_next_tag</code> , qui ex√©cute un algorithme simple: <br><br><ul><li>  V√©rifie si le pointeur sp√©cifi√© <code>nesinfo_tags_end</code> pointeur dans <code>nesinfo_tags_end</code> .  S'il est inf√©rieur √† <code>nesinfo_tags_end</code> ou que <code>nesinfo_tags_end</code> est nul, il v√©rifie la pr√©sence de la cha√Æne "END" dans l'en-t√™te du pointeur. <br><br><ul><li>  Si "END" est atteint, ou si le pointeur s'est √©lev√© vers ou au-dessus de <code>nesinfo_tags_end</code> , la fonction retourne null. </li><li>  Sinon, l'octet √† l'offset <code>0x3</code> pointeur est ajout√© √† 4 et au pointeur actuel, apr√®s quoi la valeur est retourn√©e. </li></ul></li></ul><br>  Cela nous indique qu'il existe une sorte de format d'√©tiquette √† partir d'un nom √† trois lettres, d'une valeur de taille de donn√©es et des donn√©es elles-m√™mes.  Le r√©sultat est un pointeur sur l'√©tiquette suivante, car l'√©tiquette actuelle est ignor√©e ( <code>cur_ptr + 4</code> ignore le nom √† trois lettres et un octet, et <code>size_byte</code> ignore les donn√©es). <br><br>  Si le r√©sultat n'est pas nul, la fonction de traitement d'√©tiquette effectue une s√©rie de comparaisons de cha√Ænes pour d√©terminer quelle √©tiquette doit √™tre trait√©e.  Certains des noms d'√©tiquette v√©rifi√©s dans <code>nesinfo_tag_process1</code> : VEQ, VNE, GID, GNO, BBR et QDS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/094/08b/0f109408b8d01ec8cf4522445463e378.png"></div><br>  Si une correspondance d'√©tiquette est trouv√©e, du code de gestionnaire est ex√©cut√©.  Certains gestionnaires ne font rien d'autre que d'afficher une √©tiquette dans le message de d√©bogage.  D'autres ont des gestionnaires plus complexes.  Apr√®s avoir trait√© l'√©tiquette, la fonction essaie d'obtenir l'√©tiquette suivante et de poursuivre le traitement. <br><br>  Heureusement, il existe de nombreux messages de d√©bogage d√©taill√©s qui s'affichent lorsque des balises sont d√©tect√©es.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ils sont tous en japonais, ils doivent donc d'abord √™tre d√©cod√©s de Shift-JIS et traduits. Par exemple, un message pour QDS peut indiquer ¬´Chargement d'une zone de sauvegarde de disque¬ª ou ¬´Comme il s'agit de la premi√®re ex√©cution, cr√©ez une zone de sauvegarde de disque¬ª. Les messages pour le BBR se lisent ¬´chargement d'une sauvegarde de la batterie¬ª ou ¬´puisque c'est le premier d√©marrage, nous effectuons un nettoyage¬ª. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces deux codes chargent √©galement certaines valeurs de la section de donn√©es de leurs √©tiquettes et les utilisent pour calculer le d√©calage dans les donn√©es ROM, apr√®s quoi ils effectuent des op√©rations de copie. De toute √©vidence, ils sont charg√©s de d√©terminer les parties de la m√©moire ROM associ√©es √† la conservation de l'√©tat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a √©galement une balise ¬´HSC¬ª avec un message de d√©bogage indiquant qu'elle traite les enregistrements de points. </font><font style="vertical-align: inherit;">Elle obtient un d√©calage en ROM √† partir de ses donn√©es de balise, ainsi que de la valeur d'enregistrement du score d'origine. </font><font style="vertical-align: inherit;">Ces marques peuvent √™tre utilis√©es pour indiquer une place dans la m√©moire du jeu NES pour le stockage des meilleurs scores, √©ventuellement pour les sauvegarder et les restaurer √† l'avenir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces balises cr√©ent un syst√®me de t√©l√©chargement de m√©tadonn√©es ROM assez complexe. </font><font style="vertical-align: inherit;">De plus, beaucoup d'entre eux conduisent √† des appels </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bas√©s sur les valeurs transmises dans les donn√©es d'√©tiquette.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chasse aux insectes </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plupart des balises qui conduisent √† une manipulation de la m√©moire ne sont pas tr√®s utiles pour les exploits, car toutes ont des valeurs de d√©calage et de taille maximales sp√©cifi√©es sous forme d'entiers 16 bits. </font><font style="vertical-align: inherit;">Cela suffit pour travailler avec l'espace d'adressage NES 16 bits, mais pas assez pour √©crire des valeurs cibles utiles, telles que des pointeurs vers des fonctions ou renvoyer des adresses sur la pile dans l'espace d'adressage GameCube 32 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, il existe plusieurs cas o√π les valeurs des d√©calages de taille transmis </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent d√©passer </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> QDS </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QDS charge un d√©calage de 24 bits √† partir de ses donn√©es de balise, ainsi qu'une valeur de taille de 16 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La bonne chose ici est que le d√©calage est utilis√© pour calculer l'adresse de destination de l'op√©ration de copie. L'adresse de base du d√©calage est le d√©but des donn√©es t√©l√©charg√©es, la source de la copie se trouve dans le fichier ROM de la carte m√©moire et la taille est d√©finie par la valeur de taille de 16 bits de l'√©tiquette. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La valeur 24 bits a une valeur maximale </font></font><code>0xFFFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bien sup√©rieure √† ce qui est n√©cessaire pour √©crire en dehors des donn√©es ROM charg√©es. Cependant, il y a certains probl√®mes ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le premier est que bien que la valeur de taille maximale soit √©gale </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, elle est initialement utilis√©e pour r√©initialiser la partition m√©moire. Si la valeur de la taille est trop √©lev√©e (pas beaucoup plus grande </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), cela r√©initialisera la marque ¬´QDS¬ª dans le code du jeu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et c'est l√† que r√©side le probl√®me, car il </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est en fait appel√© deux fois. Pour la premi√®re fois, elle re√ßoit des informations sur l'espace dont elle a besoin pour pr√©parer les donn√©es stock√©es. Les balises QDS et BBR ne sont pas enti√®rement trait√©es lors de la premi√®re ex√©cution. Apr√®s la premi√®re ex√©cution, un emplacement est pr√©par√© pour les donn√©es de sauvegarde et la fonction est √† nouveau appel√©e. Cette fois, les balises QDS et BBR sont enti√®rement trait√©es, mais si les cha√Ænes de nom de balise sont effac√©es de la m√©moire, il est impossible de faire correspondre √† nouveau les balises! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela peut √™tre √©vit√© en d√©finissant une valeur de taille plus petite. Un autre probl√®me est que la valeur de d√©calage ne peut avancer que dans la m√©moire et que les donn√©es ROM NES sont situ√©es dans le tas assez pr√®s de la fin de la m√©moire disponible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s eux, il n'y a que quelques tas, et aucun d'entre eux n'a quelque chose de particuli√®rement utile, comme des pointeurs de fonction √©vidents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cas normal, vous pouvez l'utiliser pour exploiter un d√©bordement de tas, mais dans l'impl√©mentation </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©e pour ce tas, pas mal d'octets de v√©rification de l'√©tat des blocs ont √©t√© ajout√©s </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous pouvons √©craser les valeurs de pointeur dans les blocs de tas suivants. Sans contr√¥les d'int√©grit√©, cela pourrait √™tre utilis√© pour √©crire dans une zone de m√©moire arbitraire lorsqu'il est appel√© </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour un bloc de </font><font style="vertical-align: inherit;">segment de m√©moire </font><font style="vertical-align: inherit;">impliqu√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, l'impl√©mentation utilis√©e ici </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v√©rifie un mod√®le d'octet sp√©cifique ( </font></font><code>0x7373</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) au d√©but des blocs suivant et pr√©c√©dent qu'elle manipulera lorsqu'elle sera appel√©e</font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si elle ne trouve pas ces octets, elle appelle </font></font><code>OSPanic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le jeu se bloque.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/516/68f/447/51668f447b75887250574f1ad1ec1800.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impossible d'influencer la pr√©sence de ces octets √† un emplacement cible, il n'est pas possible d'√©crire ici. </font><font style="vertical-align: inherit;">En d'autres termes, il est impossible d'enregistrer quelque chose dans un endroit arbitraire sans pouvoir enregistrer quelque chose pr√®s de cet endroit. </font><font style="vertical-align: inherit;">Il peut y avoir un moyen de rendre la valeur </font></font><code>0x73730000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stock√©e sur la pile directement en face de l'adresse de retour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et de l'</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> emplacement auquel la valeur se r√©f√®re, que nous voulons √©crire √† l'adresse de destination (elle sera √©galement v√©rifi√©e comme s'il s'agissait d'un pointeur vers un bloc de tas), mais cela c'est difficile √† r√©aliser et √† utiliser dans un exploit.</font></font><br><br><h5> <code>nesinfo_update_highscore</code> </h5> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre fonction concernant les balises QDS, BBR et HSC est la suivante </font></font><code>nesinfo_update_highscore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Les tailles des rep√®res QDS, BBR et OFS (d√©calage) sont utilis√©es pour calculer le d√©calage auquel enregistrer, et le rep√®re HSC inclut l'enregistrement √† cet emplacement. Cette fonction est effectu√©e pour chaque trame trait√©e par l'√©mulateur NES. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La valeur de d√©calage maximale pour chaque √©tiquette dans ce cas, m√™me pour QDS, est √©gale </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cependant, pendant le cycle de traitement des √©tiquettes, les valeurs de dimension des √©tiquettes BBR et QDS </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'accumulent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> r√©ellement </font><font style="vertical-align: inherit;">. Cela signifie que plusieurs marques peuvent √™tre utilis√©es pour calculer presque n'importe quelle valeur de d√©calage. La limitation est le nombre d'√©tiquettes qui peuvent tenir dans la section de donn√©es des √©tiquettes ROM dans un fichier sur une carte m√©moire, et il a √©galement une taille maximale </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'adresse de base √† laquelle le d√©calage est ajout√© est le </font></font><code>0x800C3180</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tampon de sauvegarde des donn√©es. </font><font style="vertical-align: inherit;">Cette adresse est bien inf√©rieure aux donn√©es ROM, ce qui nous donne plus de libert√© dans le choix d'un emplacement d'enregistrement. </font><font style="vertical-align: inherit;">Par exemple, il sera assez simple de r√©√©crire l'adresse de retour dans la pile √† l'adresse </font></font><code>0x812F95DC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, cela n'a pas fonctionn√© non plus. </font><font style="vertical-align: inherit;">Il s'av√®re qu'il </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v√©rifie √©galement la taille cumul√©e des d√©calages de ces √©tiquettes et utilise cette taille pour initialiser l'espace:</font></font><br><br><pre> <code class="cpp hljs">bzero(nintendo_hi_0, ((offset_sum + <span class="hljs-number"><span class="hljs-number">0xB</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x40</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b3/531/0ab/7b35310ab9bae3406ee423acd1c1a1a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec la valeur de d√©calage que j'essayais de calculer, cela a conduit au fait que </font></font><code>0x48D91EC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(76 386 796) octets de m√©moire </font><font style="vertical-align: inherit;">ont √©t√© effac√©s </font><font style="vertical-align: inherit;">, c'est pourquoi le jeu s'est √©cras√© de fa√ßon spectaculaire.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Marque PAT </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'avais d√©j√† commenc√© √† perdre espoir, car toutes ces balises qui effectuaient des appels non prot√©g√©s </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avaient √©chou√© avant m√™me que je ne parvienne √† les utiliser. J'ai d√©cid√© de simplement documenter le but de chaque balise et j'ai progressivement acc√©d√© aux balises </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plupart des gestionnaires d'√©tiquettes </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne d√©marrent jamais, car ils ne fonctionnent que lorsque le pointeur est diff√©rent </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de z√©ro. Rien dans le code n'assigne une valeur diff√©rente de z√©ro √† ce pointeur. Il est initialis√© avec une valeur nulle et n'est plus jamais utilis√©. Lorsque le chargement de la ROM est d√©fini uniquement </font></font><code>nesinfo_data_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il ressemble donc √† du code mort. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, il existe une √©tiquette qui peut toujours fonctionner lorsqu'elle est diff√©rente de z√©ro </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: PAT. Il s'agit de l'√©tiquette la plus difficile d'une fonction </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/8fa/e47/b5a8fae47c7ba7f82b2ee9810a950c6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il l'utilise √©galement comme pointeur </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais ne le v√©rifie jamais pour z√©ro. </font><font style="vertical-align: inherit;">La balise PAT lit son propre tampon de donn√©es de balise, traitant les codes qui calculent les d√©calages. </font><font style="vertical-align: inherit;">Ces d√©calages sont ajout√©s au pointeur </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour calculer l'adresse de destination, puis les octets sont copi√©s du tampon de correctifs vers cet emplacement. </font><font style="vertical-align: inherit;">Cette copie se fait en chargeant et en enregistrant des octets, sans utiliser d'instructions </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, donc je ne l'ai pas remarqu√© auparavant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque tampon de donn√©es de marque PAT a un code de type 8 bits, une taille de patch 8 bits et une valeur de d√©calage 16 bits, suivis des donn√©es de patch.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si le code est 2, la valeur de d√©calage est ajout√©e √† la somme actuelle des d√©calages. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si le code est 9, le d√©calage est d√©cal√© de 4 bits vers le haut et ajout√© √† la somme actuelle des d√©calages. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si le code est 3, la somme des d√©calages est r√©initialis√©e √† 0. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La taille maximale de l'√©tiquette d'information NES est de 255, c'est-√†-dire que la plus grande taille de patch PAT est de 251 octets. </font><font style="vertical-align: inherit;">Cependant, plusieurs marques PAT peuvent √™tre utilis√©es, c'est-√†-dire que vous pouvez patcher plus de 251 octets, ainsi que patcher des espaces non contigus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tant que nous avons une s√©rie de semelles PAT avec le code 2 ou le code 9, le d√©calage du pointeur de destination continue de s'accumuler. </font><font style="vertical-align: inherit;">Lors de la copie des donn√©es de patch, elles sont remises √† z√©ro, mais si vous utilisez une taille de patch z√©ro, cela peut √™tre √©vit√©. </font><font style="vertical-align: inherit;">Il est clair que cela peut √™tre utilis√© pour calculer un d√©calage arbitraire avec un pointeur nul en </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisant de nombreuses marques PAT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, il existe deux autres v√©rifications des valeurs de code ...</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le code est compris entre </font></font><code>0x80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il est ajout√© √† </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis d√©cal√© de 16 bits. </font><font style="vertical-align: inherit;">Ensuite, il est ajout√© √† la valeur de d√©calage 16 bits et utilis√© comme adresse de fin pour le patch.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela nous permet d'attribuer une adresse de destination pour le patch dans la plage de </font></font><code>0x80000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font></font><code>0x807FFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">C'est l√† que la majeure partie du code Animal Crossing r√©side en m√©moire. </font><font style="vertical-align: inherit;">Cela signifie que nous pouvons corriger le code Animal Crossing lui-m√™me en utilisant des √©tiquettes de m√©tadonn√©es ROM √† partir d'un fichier sur une carte m√©moire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'aide d'un petit chargeur de patchs, vous pouvez m√™me facilement t√©l√©charger des patchs plus volumineux d'une carte m√©moire vers n'importe quelle adresse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour une v√©rification rapide, j'ai cr√©√© un patch qui comprenait le ¬´mode zuru 2¬ª (mode d√©veloppeur de jeu, d√©crit dans mon </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article pr√©c√©dent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) lorsqu'un utilisateur charge une ROM √† partir d'une carte de jeu. </font><font style="vertical-align: inherit;">Il s'est av√©r√© que la combinaison de triche des touches active uniquement le mode ¬´zuru mode 1¬ª, qui n'a pas acc√®s aux fonctions du mode 2. Avec ce patch, gr√¢ce √† la carte m√©moire, nous pouvons avoir un acc√®s complet au mode d√©veloppeur sur du mat√©riel r√©el.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/d51/d15/864d51d15fa180ea3fab552a0dd4977b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les marques de patch seront trait√©es au d√©marrage de la ROM. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir charg√© la ROM, vous devez quitter l'√©mulateur NES pour voir le r√©sultat. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/6ea/3a2/6946ea3a20e0290b75eeba8bbf400d10.png"></div><br>  √áa marche! <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format d'√©tiquette d'informations sur le patch </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les marques d'information dans le fichier de sauvegarde qui ex√©cutent ce correctif ressemblent √† ceci: </font></font><br><br> <code>000000 5a 5a 5a 00 50 41 54 08 a0 04 6f 9c 00 00 00 7d &gt;ZZZ.PAT...o....}&lt; <br> 000010 45 4e 44 00 &gt;END.&lt;</code> <br> <br><ul><li> <code>ZZZ \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: marque de d√©part ignor√©e. </font></font><code>0x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est la taille de son tampon de donn√©es: z√©ro.</font></font></li><li> <code>PAT \x08 \xA0 \x04 \x6F\x9C \x00\x00\x00\x7D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: patch </font></font><code>0x80206F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><ul><li> <code>0x08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Correspond √† la taille du tampon d'√©tiquettes. </font></font></li><li> <code>0xA0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsqu'elles sont </font><font style="vertical-align: inherit;">ajout√©es aux </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devenant </font></font><code>0x8020</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, soit les 16 bits sup√©rieurs de l'adresse de destination.</font></font></li><li> <code>0x04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correspond √† la taille des donn√©es de patch ( </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li> <code>0x6F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sont les 16 derniers bits de l'adresse de destination. </font></font></li><li> <code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Est les donn√©es du patch. </font></font></li></ul></li><li> <code>END \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : marque de fin de marqueur. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous voulez exp√©rimenter par vous-m√™me la cr√©ation d'un fichier de sauvegarde de patcher ou de ROM, alors sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/jamchamb/ac-nesrom-save-generator,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j'ai publi√© un code tr√®s simple pour g√©n√©rer des fichiers. </font><font style="vertical-align: inherit;">Un patch comme celui illustr√© ci-dessus peut √™tre g√©n√©r√© avec la commande suivante:</font></font><br><br> <code>$ ./patcher.py Patcher /dev/null zuru_mode_2.gci -p 80206F9c 0000007D</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ex√©cution de code arbitraire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√¢ce √† cette balise, vous pouvez r√©aliser l'ex√©cution de code arbitraire dans Animal Crossing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais voici le dernier obstacle: l'utilisation de correctifs pour les donn√©es fonctionne bien, mais des probl√®mes surviennent lors de la correction des instructions de code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque les patchs sont enregistr√©s, le jeu continue de suivre les anciennes instructions qui √©taient √† sa place. Cela semble √™tre un probl√®me de mise en cache, et en fait c'est le cas. Le CPU GameCube poss√®de des caches d'instructions, comme d√©crit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans les sp√©cifications</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour comprendre comment vous pouvez vider le cache, j'ai commenc√© √† √©tudier les fonctions li√©es au cache de la documentation du SDK GameCube, et j'ai d√©couvert </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cette fonction invalide les blocs d'instructions mis en cache √† l'adresse de m√©moire sp√©cifi√©e, ce qui permet √† la m√©moire d'instructions modifi√©e d'√™tre ex√©cut√©e avec un code mis √† jour.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, sans la possibilit√© d'ex√©cuter le code d'origine, nous ne pouvons toujours pas appeler </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pour une ex√©cution r√©ussie du code, nous avons besoin d'une astuce suppl√©mentaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En √©tudiant l'impl√©mentation </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour la possibilit√© d'utiliser un exploit avec d√©bordement de tas, j'ai appris que les fonctions d'impl√©mentation </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent √™tre d√©sactiv√©es dynamiquement √† l'aide d'une structure de donn√©es appel√©e </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">charge un pointeur sur l'impl√©mentation actuelle </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou √† </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir d'un emplacement statique en m√©moire, puis appelle cette fonction, en passant tous les arguments pass√©s √† </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©mulateur NES utilise activement</font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour allouer et lib√©rer de la m√©moire pour les donn√©es NES li√©es √† la ROM, j'√©tais donc s√ªr qu'il serait lanc√© plusieurs fois √† peu pr√®s en m√™me temps que les marques PAT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">charge un pointeur de la m√©moire et y fait une transition, je peux changer le processus d'ex√©cution du programme en √©crasant simplement le pointeur pour qu'il pointe vers la fonction actuelle </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La mise en cache des outils n'emp√™chera pas cela de se produire, car aucune instruction ne doit √™tre modifi√©e </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le d√©veloppeur du projet de fan D≈çbutsu no Mori e +, nomm√© Cuyler, a √©crit un tel chargeur dans l'assembleur PowerPC et a d√©montr√© son utilisation pour injecter du nouveau code dans cette vid√©o: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.youtube.com/watch?v=BdxN7gP6WIc</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(D≈çbutsu no Mori e + √©tait la derni√®re it√©ration d'Animal Crossing sur le GameCube, qui avait le plus de mises √† jour. Publi√© uniquement au Japon.) Le patch t√©l√©charge du code qui permet au joueur de cr√©er des objets en entrant son identifiant par lettre et en appuyant sur le bouton Z.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BdxN7gP6WIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√¢ce √† cela, vous pouvez t√©l√©charger des mods, des astuces et des homebrews dans une copie r√©guli√®re d'Animal </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crossing sur un vrai GameCube.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417117/">https://habr.com/ru/post/fr417117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417107/index.html">Cr√©ateur du jeu en mode True: d√©couvrez () la programmation gamedev, les probl√®mes VR et les simulations ML</a></li>
<li><a href="../fr417109/index.html">Richard Hamming: Chapitre 10. Th√©orie du codage - I</a></li>
<li><a href="../fr417111/index.html">Conf√©rences en ligne: streaming vs webinaire</a></li>
<li><a href="../fr417113/index.html">Imprimante 3D italienne en Russie: Raise3D N1 Dual - mod√©lisation et prototypage</a></li>
<li><a href="../fr417115/index.html">Enterrer ou graver Flutter.io?</a></li>
<li><a href="../fr417119/index.html">Pagination dans Vue.js</a></li>
<li><a href="../fr417123/index.html">Int√©gration de Spark Streaming et Kafka</a></li>
<li><a href="../fr417125/index.html">RTC Meetup .Net: invitez √† la premi√®re r√©union</a></li>
<li><a href="../fr417127/index.html">Tesla signe un accord pour construire Gigafactory 3 en Chine</a></li>
<li><a href="../fr417129/index.html">Univers de l'esprit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>