<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ¼ ğŸ¼ ğŸš³ Teka-teki Kotlin, Vol. 2: kumpulan teka-teki baru ğŸ’Š ğŸ‘©ğŸ½â€ğŸ’» ğŸ·ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bisakah Anda memprediksi bagaimana kode Kotlin akan berlaku? Apakah akan mengkompilasi apa yang akan dihasilkan dan mengapa? 

 Tidak peduli sebagus a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teka-teki Kotlin, Vol. 2: kumpulan teka-teki baru</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/440974/"><img src="https://habrastorage.org/webt/bj/9x/wi/bj9xwicnsccegyu2fo2xvbvglr0.png"><br><br>  Bisakah Anda memprediksi bagaimana kode Kotlin akan berlaku?  Apakah akan mengkompilasi apa yang akan dihasilkan dan mengapa? <br><br>  Tidak peduli sebagus apa pun bahasa pemrogramannya, ia dapat membuangnya sehingga hanya tersisa untuk menggaruk bagian belakang kepalanya.  Tidak terkecuali Kotlin - Kotlin juga mengandung teka-teki, bahkan ketika kode yang sangat pendek memiliki perilaku yang tidak terduga. <br><br>  Kembali pada tahun 2017, kami menerbitkan di HabrÃ© sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pilihan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">teka-teki</a> semacam itu dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">antonkeks</a> <b>Anton</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Keks</a> .  Dan kemudian dia tampil bersama kami di Mobius dengan pilihan kedua, dan kami sekarang juga menerjemahkannya untuk Habr ke tampilan teks, menyembunyikan jawaban yang benar di bawah spoiler. <br><br>  Kami juga melampirkan rekaman video pidato, jika ada sesuatu yang tidak dapat dipahami dalam teks, Anda juga dapat menghubunginya. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/t387acWEK3o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Bagian pertama dari teka-teki ini ditujukan untuk mereka yang tidak terlalu mengenal Kotlin;  bagian kedua adalah untuk pengembang hardcore Kotlin.  Kami akan memulai semuanya di Kotlin 1.3, bahkan dengan mode progresif diaktifkan.  Kode sumber kusut ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> .  Siapa pun yang datang dengan ide-ide baru, kirim permintaan tarik. <br><br><h2>  Pazzler nomor 1 </h2><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { println(print(â€³Helloâ€³) == print(â€³Worldâ€³) == <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } hello()</code> </pre> <br>  Sebelum kita adalah fungsi halo sederhana, ia menjalankan beberapa cetak.  Dan kami meluncurkan fungsi ini sendiri.  Pertanyaan overclocking sederhana: apa yang harus dicetak? <br><br>  a) HelloWorld <br>  b) HelloWorldfalse <br>  c) HelloWorldtrue <br>  d) Tidak dikompilasi <br><br><div class="spoiler">  <b class="spoiler_title">Jawaban yang benar</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ce/uc/rg/ceucrgqimyvojaud8llfktt0l1s.png"><br><br>  Opsi pertama benar.  Perbandingan dipicu setelah kedua cetakan sudah mulai, tidak bisa mulai lebih awal.  Mengapa kode seperti itu dikompilasi?  Fungsi apa pun selain mengembalikan Tidak ada yang mengembalikan sesuatu.  Karena segala sesuatu di Kotlin adalah ekspresi, bahkan kembali juga merupakan ekspresi.  Jenis pengembalian adalah Tidak, itu digunakan untuk jenis apa pun, sehingga Anda dapat membandingkan seperti ini.  Dan mencetak pengembalian Unit, sehingga Unit dapat dibandingkan dengan Tidak ada berapa kali, dan semuanya berfungsi dengan baik. <br></div></div><br><h2>  Pazzler nomor 2 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { println(n) } printInt(-<span class="hljs-number"><span class="hljs-number">2_147_483_648</span></span>.inc())</code> </pre><br>  Jangan sampai Anda menebak: angka menakutkan adalah integer bertanda 32-bit sekecil mungkin. <br><br>  Semuanya terlihat sederhana di sini.  Kotlin memiliki fungsi ekstensi yang hebat seperti .inc () untuk menambah.  Kita bisa menyebutnya di Int, dan kita bisa mencetak hasilnya.  Apa yang akan terjadi <br><br>  a) -2147483647 <br>  b) -2147483649 <br>  c) 2147483647 <br>  d) Tidak satu pun di atas <br><br><div class="spoiler">  <b class="spoiler_title">Luncurkan!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/se/sa/hy/sesahyqljf-z0kyeil35hpev4ho.png"><br><br>  Seperti yang dapat Anda lihat dari pesan kesalahan, inilah masalah dengan Long.  Tapi kenapa lama? <br><br>  Fungsi ekstensi memiliki prioritas, dan kompiler pertama kali menjalankan inc (), dan kemudian operator minus.  Jika inc () dihapus, maka itu akan menjadi Int, dan semuanya akan berfungsi.  Tapi inc (), mulai lebih dulu, mengubah 2_147_483_648 menjadi Long, karena angka ini tanpa minus tidak lagi berlaku Int.  Ternyata Long, dan baru kemudian minus disebut.  Semua ini tidak lagi dapat diteruskan ke fungsi printInt (), karena memerlukan Int. <br><br>  Jika kita mengubah panggilan printInt ke cetakan biasa, yang dapat menerima Long, maka opsi kedua akan benar. <br><br><img src="https://habrastorage.org/webt/qf/vf/q3/qfvfq3njfzcubm6ax7uvda6g8b4.png"><br><br>  Kami melihat bahwa ini sebenarnya Panjang.  Waspadalah terhadap hal ini: tidak semua potongan puzzle dapat dijalankan dalam kode nyata, tetapi yang ini bisa. <br></div></div><br><h2>  Pazzler nomor 3 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: UInt = <span class="hljs-number"><span class="hljs-number">0</span></span>u println(x--.toInt()) println(--x)</code> </pre><br>  Di Kotlin 1.3 datang fitur-fitur hebat baru.  Selain versi final corutin, kami <br>  sekarang akhirnya memiliki nomor yang tidak ditandatangani.  Ini perlu, terutama jika Anda menulis semacam kode jaringan. <br><br>  Sekarang untuk literal bahkan ada huruf u khusus, kita dapat mendefinisikan konstanta, kita dapat, seperti dalam contoh, pengurangan x dan dikonversi ke Int.  Saya mengingatkan Anda bahwa Int akrab dengan kami. <br><br>  Apa yang akan terjadi <br><br>  a) -1 4294967294 <br>  b) 0 4294967294 <br>  c) 0 -2 <br>  d) Tidak dikompilasi <br><br>  4294967294 adalah jumlah maksimum 32-bit yang dapat diperoleh. <br><br><div class="spoiler">  <b class="spoiler_title">Luncurkan!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uj/up/ch/ujupchn07nkjmqfl8a9hnhbycha.png"><br><br>  Opsi yang benar b. <br><br>  Di sini, seperti pada versi sebelumnya: pertama, toInt () dipanggil pada x, dan baru setelah itu decrement.  Hasil decrement unsigned ditampilkan, dan ini adalah maksimum dari unsignedInt. <br><br>  Yang paling menarik adalah jika Anda menulis seperti ini, kode tidak akan dikompilasi: <br><br><pre> <code class="kotlin hljs">println(x--.toInt()) println(--x.toInt())</code> </pre><br>  Dan bagi saya sangat aneh bahwa baris pertama bekerja, dan yang kedua - tidak, ini tidak masuk akal. <br><br>  Dan dalam versi pra-rilis, opsi yang benar adalah C, yang dilakukan dengan sangat baik di JetBrains yang memperbaiki bug sebelum rilis versi final. <br></div></div><br><h2>  Pazzler nomor 4 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cells = arrayOf(arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbors = cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] print(neighbors)</code> </pre><br>  Kami mengalami kasus ini dalam kode nyata.  Kami di Codeborne melakukan Coding Dojo, menerapkannya bersama di Kotlin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Game of Life</a> .  Seperti yang Anda lihat, sangat tidak nyaman untuk bekerja dengan array multi-level di Kotlin. <br><br>  Dalam Game of Life, bagian penting dari algoritma adalah menentukan jumlah tetangga untuk sebuah sel.  Semua anak kecil di sekitarnya adalah tetangga, dan itu tergantung pada apakah sel hidup atau mati.  Dalam kode ini, Anda dapat menghitung dan menganggap apa yang terjadi. <br><br>  a) 6 <br>  b) 3 <br>  c) 2 <br>  d) Tidak dikompilasi <br><br><div class="spoiler">  <b class="spoiler_title">Ayo lihat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/m2/8_/j0/m28_j0aa1kg9j7aixnsj2trzsrg.png"><br><br>  Jawaban yang benar adalah 3. <br><br>  Faktanya adalah nilai tambah dari baris pertama dipindahkan ke bawah, dan Kotlin berpikir ini adalah unaryPlus ().  Akibatnya, hanya tiga sel pertama yang dijumlahkan.  Jika kita ingin menulis kode ini dalam beberapa baris, kita perlu memindahkan plus ke atas. <br><br>  Ini adalah satu lagi dari "teka-teki buruk."  Ingat, di Kotlin Anda tidak perlu mentransfer pernyataan ke baris baru, jika tidak, pernyataan itu mungkin dianggap tidak wajar. <br><br><img src="https://habrastorage.org/webt/f5/-9/ew/f5-9ewbhsw0ucybzsg-7xkeld1u.png"><br><br>  Saya belum melihat situasi di mana unaryPlus diperlukan dalam kode nyata kecuali DSL.  Ini adalah topik yang sangat aneh. <br><br>  Ini adalah harga yang kami bayar jika tidak ada titik koma.  Jika ya, akan menjadi jelas kapan satu ekspresi berakhir dan yang lain dimulai.  Dan tanpa mereka, kompiler harus membuat keputusan.  Umpan baris untuk kompiler sangat sering berarti bahwa masuk akal untuk mencoba memeriksa saluran secara terpisah. <br><br>  Tetapi ada satu bahasa JavaScript yang sangat keren di mana Anda juga tidak bisa menulis titik koma, dan kode ini akan tetap berfungsi dengan benar. <br></div></div><br><h2>  Pazzler nomor 5 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x?:<span class="hljs-number"><span class="hljs-number">0</span></span> + y println(sum)</code> </pre><br>  Teka-teki ini ditampilkan oleh pembicara KotlinConf Thomas Nild. <br><br>  Kotlin memiliki fitur tipe nullable yang bagus.  Kami memiliki x nullable, dan kami dapat mengubahnya, jika ternyata nol, melalui operator Elvis ke beberapa nilai normal. <br><br>  Apa yang akan terjadi <br><br>  a) 3 <br>  b) 5 <br>  c) 2 <br>  d) 0 <br><br><div class="spoiler">  <b class="spoiler_title">Luncurkan!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1_/zg/-o/1_zg-ozj8sgftbrk2nswebclg30.png"><br><br>  Masalahnya lagi dalam urutan atau prioritas operator.  Jika kami memformat ulang ini, maka format resmi akan melakukan ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x ?: <span class="hljs-number"><span class="hljs-number">0</span></span>+y</code> </pre><br>  Format sudah menunjukkan bahwa 0 + y mulai lebih dulu, dan baru kemudian x?:.  Oleh karena itu, tentu saja, 2 tetap, karena X adalah dua, itu bukan nol. <br></div></div><br><h2>  Pazzler nomor 6 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hops: List&lt;Hops&gt; = emptyList() ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hops</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kind: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> atMinute: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grams: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Recipe</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = Recipe().apply(build) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Recipe.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hops</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Hops</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { hops += Hops().apply(build) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recipe = beer { name = â€³Simple IPAâ€³ hops { name = â€³Cascadeâ€³ grams = <span class="hljs-number"><span class="hljs-number">100</span></span> atMinute = <span class="hljs-number"><span class="hljs-number">15</span></span> } }</code> </pre><br>  Ketika mereka memanggil saya di sini, mereka berjanji akan membuat bir.  Saya akan mencarinya malam ini, saya belum melihatnya.  Kotlin memiliki topik hebat - pembangun.  Dengan empat baris kode, kami menulis DSL kami dan kemudian membuatnya melalui pembangun. <br><br>  Kami membuat, pertama, IPA, tambahkan hop yang disebut Cascade, 100 gram pada menit ke-15, dan kemudian cetak resep ini.  Apa yang kita lakukan <br><br>  a) Resep (nama = IPA Sederhana, hop = [Hop (nama = Cascade, atMinute = 15, gram = 100)]) <br>  b) IllegalArgumentException <br>  c) Tidak dikompilasi <br>  d) Tidak satu pun di atas <br><br><div class="spoiler">  <b class="spoiler_title">Luncurkan!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ji/ci/8p/jici8p8px4kd4hnogzpvcufsrqi.png"><br><br>  Kami mendapat sesuatu yang mirip dengan kerajinan bir, tetapi tidak ada hop di dalamnya, itu menghilang.  Mereka menginginkan IPA, tetapi mendapat Baltik 7. <br><br>  Di sinilah bentrokan penamaan terjadi.  Bidang di Hops sebenarnya disebut jenis, dan dalam nama baris = â€³ Cascade â€³ kami menggunakan nama, yang di-cache dengan nama resep. <br><br>  Kita dapat membuat anotasi BeerLang kita sendiri dan mendaftarkannya sebagai bagian dari BeerLang DSL.  Sekarang kami mencoba menjalankan kode ini, dan tidak boleh dikompilasi dengan kami. <br><br><img src="https://habrastorage.org/webt/eq/i-/a3/eqi-a3r5hjxbpsy7z-rlzqlkqjg.png"><br><br>  Sekarang kita diberitahu bahwa pada prinsipnya nama tidak dapat digunakan dari konteks ini.  Untuk ini, DSLMarker diperlukan karena kompiler di dalam pembangun tidak memungkinkan kami untuk menggunakan bidang eksternal, jika kami memiliki yang sama di dalamnya sehingga tidak ada bentrokan penamaan.  Kode diperbaiki seperti ini, dan kami mendapatkan resep kami. <br><br><img src="https://habrastorage.org/webt/rv/kn/8y/rvkn8ys1t9syngob9ikmtfbgij8.png"><br></div></div><br><h2>  Pazzler nomor 7 </h2><br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(â€³$x TRUEâ€³) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(â€³$x FALSEâ€³) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  Teka-teki ini adalah salah satu karyawan JetBrains.  Kotlin memiliki fitur kapan.  Ini untuk semua kesempatan, memungkinkan Anda untuk menulis kode keren, sering digunakan bersama dengan kelas disegel untuk desain API. <br><br>  Dalam hal ini, kami memiliki fungsi f () yang mengambil Boolean dan mencetak sesuatu tergantung pada true dan false. <br><br>  Apa yang akan terjadi <br><br>  a) BENAR benar;  false false <br>  b) BENAR benar;  BENAR salah <br>  c) FALSE sejati;  false false <br>  d) Tidak satu pun di atas <br><br><div class="spoiler">  <b class="spoiler_title">Ayo lihat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/c6/g0/lo/c6g0loicys30gkbo0bf9cagvk20.png"><br><br>  Kenapa begitu  Pertama, kita menghitung ekspresi x == true: misalnya, dalam kasus pertama, itu akan menjadi benar == benar, yang berarti benar.  Dan kemudian ada juga perbandingan dengan pola yang kita lewati saat itu. <br><br>  Dan ketika x disetel ke false, mengevaluasi x == true akan memberi kita false, namun, sampel juga akan salah - jadi contohnya akan cocok dengan sampel. <br><br>  Ada dua cara untuk memperbaiki kode ini, Pertama adalah menghapus "x ==" dalam kedua kasus: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(â€³$x TRUEâ€³) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(â€³$x FALSEâ€³) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  Opsi kedua adalah menghapus (x) setelah kapan.  Ketika bekerja dengan kondisi apa pun, dan kemudian tidak akan cocok dengan sampel. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(â€³$x TRUEâ€³) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(â€³$x FALSEâ€³) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br></div></div><br><h2>  Pazzler nomor 8 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullSafeLang</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> logo = name[<span class="hljs-number"><span class="hljs-number">0</span></span>].toUpperCase() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = â€³Kotlinâ€³ } print(Kotlin().logo)</code> </pre><br>  Kotlin dipasarkan sebagai bahasa â€œnull safeâ€.  Bayangkan bahwa kita memiliki kelas abstrak, memiliki beberapa nama, serta properti yang mengembalikan logo bahasa ini: huruf pertama dari nama, untuk berjaga-jaga, huruf kapital (tiba-tiba lupa membuat modal awal). <br><br>  Karena bahasanya tidak aman, kami akan mengganti nama dan mungkin harus mendapatkan logo yang benar, yaitu satu huruf.  Apa yang sebenarnya kita dapatkan? <br><br>  a) K <br>  b) NullPointerException <br>  c) IllegalStateException <br>  d) Tidak dikompilasi <br><br><div class="spoiler">  <b class="spoiler_title">Luncurkan!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bb/et/sm/bbetsm3lj5eh356zwho6z4bhzjs.png"><br><br>  Kami mendapat NullPointerException, yang seharusnya tidak kami terima.  Masalahnya adalah konstruktor dari superclass disebut pertama, kode mencoba menginisialisasi logo properti dan mengambil nama char dari nol, dan pada saat ini nama adalah nol, sehingga terjadi NullPointerException. <br><br>  Cara terbaik untuk memperbaikinya adalah dengan melakukan ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = â€³Kotlinâ€³ }</code> </pre><br>  Jika kita menjalankan kode seperti itu, kita mendapat "K".  Sekarang kelas dasar akan memanggil konstruktor dari kelas dasar, itu sebenarnya akan memanggil nama pengambil dan mendapatkan Kotlin. <br><br>  Properti adalah fitur hebat di Kotlin, tetapi Anda harus sangat berhati-hati ketika melakukan override properti, karena sangat mudah untuk melupakan, membuat kesalahan, atau memastikan hal yang salah. <br><br></div></div><br><h2>  Pazzler nomor 9 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = mutableListOf&lt;() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>) { i++ result += { print(â€³$i, $j; â€³) } } result.forEach { it() }</code> </pre><br>  Ada daftar mutable dari beberapa hal menakutkan.  Jika itu mengingatkan Anda pada Scala, maka itu tidak sia-sia, karena itu benar-benar terlihat seperti.  Ada Daftar lambd, kami mengambil dua counter - I dan j, increment dan kemudian melakukan sesuatu dengan mereka.  Apa yang akan terjadi <br><br>  a) 1 1;  2 2;  3 3 <br>  b) 1 3;  2 3;  3 3 <br>  c) 3 1;  3 2;  3 3 <br>  d) tidak ada di atas <br><br><div class="spoiler">  <b class="spoiler_title">Ayo lari</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y8/ap/9j/y8ap9j-cfyyuanfscsg_irflczy.png"><br><br>  Kami mendapatkan 3 1;  3 2;  3 3. Ini terjadi karena saya adalah variabel, dan itu akan mempertahankan nilainya sampai akhir fungsi.  Dan j dilewatkan oleh nilai. <br><br>  Jika alih-alih var i = 0 akan ada val i = 0, ini tidak akan berfungsi, tetapi kemudian kita tidak bisa menambah variabel. <br><br>  Di sini, di Kotlin kami menggunakan penutupan, fitur ini bukan di Jawa.  Ini sangat keren, tetapi dapat menggigit kita jika kita tidak segera menggunakan nilai i, tetapi meneruskannya ke lambda, yang dimulai kemudian dan melihat nilai terakhir dari variabel ini.  Dan j dilewatkan oleh nilai, karena variabel dalam kondisi loop - mereka sama dengan val, mereka tidak mengubah nilainya lagi. <br><br>  Dalam JavaScript, jawabannya adalah â€œ3 3;  3 3;  3 3 ", karena tidak ada yang ditransmisikan oleh nilai. <br><br></div></div><br><h2>  Pazzler nomor 10 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = print(â€³$a, $bâ€³) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = <span class="hljs-number"><span class="hljs-number">4</span></span> foo(c &lt; a, b &gt; d)</code> </pre><br>  Kami memiliki fungsi foo (), mengambil dua Boolean, mencetaknya, semuanya tampak sederhana.  Dan kami memiliki banyak angka, masih untuk melihat angka mana yang lebih besar dari yang lain, dan memutuskan opsi mana yang benar. <br><br>  a) benar, benar <br>  b) salah, salah <br>  c) nol, nol <br>  d) tidak dikompilasi <br><br><div class="spoiler">  <b class="spoiler_title">Kami meluncurkan</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/m5/5c/j6m55cysqvltjnc9x67mxerzglq.png"><br><br>  Tidak dikompilasi. <br><br>  Masalahnya adalah bahwa kompiler berpikir ini mirip dengan parameter generik: dengan &lt;a, b&gt;.  Meskipun sepertinya "c" bukan kelas, tidak jelas mengapa harus memiliki parameter generik. <br><br>  Jika kodenya seperti ini, itu akan berfungsi dengan baik: <br><br><pre> <code class="kotlin hljs">foo(c &gt; a, b &gt; d)</code> </pre><br>  Sepertinya saya ini adalah bug di kompiler.  Tetapi ketika saya pergi ke Andrei Breslav dengan teka-teki seperti itu, dia berkata "ini karena parser seperti itu, mereka tidak ingin terlalu lambat."  Secara umum, ia selalu menemukan penjelasan mengapa. <br><br>  Sayangnya, ini benar.  Dia mengatakan bahwa mereka tidak akan memperbaikinya, karena pengurai di <br>  Kotlin belum tahu semantik.  Parsing terjadi terlebih dahulu, dan kemudian meneruskannya ke komponen kompiler lain.  Sayangnya, ini mungkin akan tetap demikian.  Jadi jangan menulis dua kurung sudut dan kode apa pun di tengah! <br></div></div><br><h2>  Pazzler nomor 11 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) : List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (name, items) = Container(â€³Kotlinâ€³, listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) println(â€³Hello $name, $itemsâ€³)</code> </pre><br>  Mendelegasikan adalah fitur hebat di Kotlin.  Ngomong-ngomong, Andrei Breslav mengatakan bahwa ini adalah fitur yang dengan senang hati akan dia hapus dari bahasa itu, dia tidak lagi menyukainya.  Sekarang, mungkin, kita akan mencari tahu alasannya!  Dan dia juga mengatakan bahwa benda pendamping itu jelek. <br><br>  Tetapi kelas data jelas sangat indah.  Kami memiliki Container kelas data, dibutuhkan nama dan item untuk dirinya sendiri.  Pada saat yang sama, dalam Kontainer, kami menerapkan jenis barang, ini Daftar, dan kami mendelegasikan semua metode untuk item. <br><br>  Lalu kami menggunakan fitur keren lainnya - destructure.  Kami "merusak" elemen nama dan item dari Wadah dan menampilkannya di layar.  Segalanya tampak sederhana dan jelas.  Apa yang akan terjadi <br><br>  a) Halo Kotlin, [1, 2, 3] <br>  b) Halo Kotlin, 1 <br>  c) Halo 1, 2 <br>  d) Halo Kotlin, 2 <br><br><div class="spoiler">  <b class="spoiler_title">Kami meluncurkan</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fn/jt/bb/fnjtbbmz1sikuctkwsxxkmih7vc.png"><br><br>  Opsi yang paling tidak jelas adalah d.  Dia ternyata benar.  Ternyata, item hilang begitu saja dari koleksi item, dan bukan dari awal atau dari akhir, tetapi hanya di tengah.  Mengapa <br><br>  Masalah dengan kerusakan adalah karena delegasi, semua koleksi di Kotlin juga <br>  memiliki opsi sendiri untuk melakukan restrukturisasi.  Saya dapat menulis val (I, j) = listOf (1, 2), dan memasukkan 1 dan 2 ini ke dalam variabel, yaitu, List telah mengimplementasikan fungsi component1 () dan <br>  component2 (). <br><br>  Kelas data juga memiliki component1 () dan component2 ().  Tetapi karena komponen kedua dalam kasus ini adalah pribadi, komponen yang bersifat publik di Daftar menang, jadi elemen kedua diambil dari Daftar, dan kami tiba di sini 2. Moralnya sangat sederhana: jangan lakukan itu, jangan lakukan itu. <br></div></div><br><h2>  Pazzler nomor 12 </h2><br>  Teka-teki berikutnya sangat menakutkan.  Ini adalah orang yang patuh yang entah bagaimana terhubung dengan Kotlin, jadi dia tahu apa yang dia tulis. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Any?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asGeneric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T <span class="hljs-number"><span class="hljs-number">42</span></span>.asGeneric&lt;<span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span>&gt;()!!!! <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-number"><span class="hljs-number">87</span></span> println(a)</code> </pre><br>  Kami memiliki fungsi ekstensi pada nullable Any, yaitu, dapat diterapkan sama sekali untuk apa pun.  Ini adalah fitur yang sangat berguna.  Jika belum ada di proyek Anda, ada baiknya ditambahkan, karena itu dapat memasukkan semua yang Anda inginkan ke dalam apa pun.  Lalu kami mengambil 42 dan membuangnya ke Nothing. <br><br>  Nah, jika kita ingin memastikan bahwa kita telah melakukan sesuatu yang penting, kita bisa melakukannya !!!  tulis !!!!, kompiler Kotlin memungkinkan Anda melakukan ini: jika Anda kehilangan dua tanda seru, tulis setidaknya dua puluh enam. <br><br>  Lalu kita lakukan jika (benar), dan kemudian saya sendiri tidak mengerti apa-apa ... Ayo segera pilih apa yang terjadi. <br><br>  a) 87 <br>  b) Kotlin.Unit <br>  c) ClassCastException <br>  d) Tidak dikompilasi <br><br><div class="spoiler">  <b class="spoiler_title">Menonton</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/g7/l-/_tg7l-vw0wze-y2vu_dix7cnvni.png"><br><br>  Sangat sulit untuk memberikan penjelasan yang logis.  Kemungkinan besar, Unit di sini disebabkan oleh fakta bahwa tidak ada lagi yang mendorong di sana.  Ini adalah kode yang tidak valid, tetapi berfungsi karena kami tidak menggunakan apa pun.  Kami telah mengunggah sesuatu ke Nothing, dan ini adalah tipe khusus yang memberi tahu kompiler bahwa instance dari tipe ini seharusnya tidak pernah muncul.  Kompiler tahu bahwa jika ada kemungkinan Nothing, yang tidak mungkin menurut definisi, maka Anda tidak dapat memeriksa lebih lanjut, ini adalah situasi yang tidak mungkin. <br><br>  Kemungkinan besar, ini adalah bug di kompiler, tim JetBrains bahkan mengatakan bahwa mungkin bug ini akan diperbaiki suatu hari nanti, ini bukan prioritas utama.  Kuncinya adalah bahwa kita menipu kompiler di sini karena pemain ini.  Jika Anda menghapus baris 42.asGeneric &lt;Nothing&gt; () !!!  dan berhenti curang, kode akan berhenti mengkompilasi.  Dan jika kita pergi, kompiler menjadi gila, berpikir bahwa ini adalah ekspresi yang tidak mungkin, dan hal-hal apa pun yang masuk ke sana. <br><br>  Saya mengerti itu.  Mungkin suatu hari nanti seseorang akan menjelaskannya dengan lebih baik. <br><br></div></div><br><h2>  Pazzler nomor 13 </h2><br>  Kami memiliki fitur yang sangat menarik.  Anda dapat menggunakan injeksi dependensi, atau Anda bisa melakukannya tanpa itu, membuat singletones melalui objek dan menjalankan program Anda keren.  Mengapa Anda membutuhkan Koin, Belati atau sesuatu?  Namun, pengujian akan sulit. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any?) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = javaClass.simpleName } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> B : A(C) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> C : A(B) println(Bx) println(Cx)</code> </pre><br>  Kami memiliki kelas A terbuka untuk warisan, dibutuhkan sesuatu di dalam dirinya sendiri, kami membuat dua objek'a, tunggal, B dan C, keduanya diwarisi dari A dan saling melewati di sana.  Artinya, siklus yang sangat baik terbentuk.  Lalu kami mencetak apa yang didapat B dan C. <br><br>  a) nol;  null <br>  b) C;  null <br>  c) ExceptionInInitializerError <br>  d) Tidak dikompilasi <br><br><div class="spoiler">  <b class="spoiler_title">Kami meluncurkan</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lf/ic/tc/lfictczohzri2l2os2w5xpypbfw.png"><br><br>  Opsi yang benar adalah C;  null <br><br>  Orang akan berpikir bahwa ketika objek pertama diinisialisasi, yang kedua belum ada di sana.  Tetapi, ketika kita menyimpulkan ini, C tidak memiliki B. Artinya, urutan terbalik diperoleh: untuk beberapa alasan, kompiler memutuskan untuk menginisialisasi C pertama, dan kemudian ia menginisialisasi B bersama-sama dengan C. Itu terlihat tidak logis, itu akan menjadi logis, sebaliknya akan logis, sebaliknya, nol ;  B. <br><br>  Tetapi kompiler mencoba melakukan sesuatu, itu tidak berhasil, ia meninggalkan nol di sana dan memutuskan untuk tidak memberikan apa pun kepada kami.  Bisa jadi itu juga <br><br>  Jika ada?  pada tipe parameter, hapus ?, maka tidak akan berfungsi. <br><br><img src="https://habrastorage.org/webt/re/mh/6n/remh6n7bggwrm2ig962qbh1uvlu.png"><br><br>  Kita dapat mengatakan baik kepada kompiler bahwa ketika null diselesaikan, dia mencoba, tetapi gagal, tetapi apa?  tidak, dia melempar kami pengecualian bahwa tidak mungkin untuk membuat siklus. <br></div></div><br><h2>  Pazzler â„–14 </h2><br>  Versi 1.3 merilis coroutine baru yang hebat di Kotlin.  Sudah lama saya berpikir bagaimana membuat teka-teki tentang corutin, sehingga seseorang bisa memahaminya.  Saya pikir bagi sebagian orang kode dengan coroutine adalah kusut. <br><br>  Di 1.3, beberapa nama fungsi berubah yang berada di 1.2 di API eksperimental.  Misalnya, buildSequence () diubah namanya menjadi hanya urutan ().  Artinya, kita dapat membuat urutan yang sangat baik dengan fungsi hasil, loop tak terbatas, dan kemudian kita bisa mencoba untuk mendapatkan sesuatu dari urutan ini. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> coroutines.yieldNoOne <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = sequence { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) yield(n++) } println(x.take(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br>  Mereka mengatakan dengan coroutine bahwa semua primitif keren yang ada dalam bahasa lain, seperti hasil, dapat dilakukan sebagai fungsi perpustakaan, karena hasil adalah fungsi penangguhan yang dapat terganggu. <br><br>  Apa yang akan terjadi <br><br>  a) [1, 2, 3] <br>  b) [0, 1, 2] <br>  c) Loop tak terbatas <br>  d) Tidak satu pun di atas <br><br><div class="spoiler">  <b class="spoiler_title">Luncurkan!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dh/p2/s3/dhp2s3ugmoll1vijctjtmlxgmtm.png"><br><br>  Opsi yang benar adalah yang terakhir. <br><br>  Urutan adalah alat malas, dan ketika kita berpegang teguh pada itu, itu juga malas.  Tetapi jika Anda menambahkan toList, maka itu akan benar-benar dicetak [0, 1, 2]. <br><br>  Jawaban yang benar tidak terkait dengan coroutine sama sekali.  Coroutine benar-benar berfungsi, mudah digunakan.  Untuk fungsi urutan dan hasil, Anda bahkan tidak perlu menghubungkan pustaka dengan coroutine, semuanya sudah ada di pustaka standar. <br></div></div><br><h2>  Pazzler â„–15 </h2><br>  Teka-teki ini juga ditundukkan oleh pengembang dari JetBrains.  Ada kode seperti itu: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whatAmI = {-&gt;}.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}() println(whatAmI)</code> </pre><br>  Ketika saya melihatnya pertama kali, selama KotlinConf, saya tidak bisa tidur, saya mencoba memahami apa itu.  Kode samar seperti itu dapat ditulis dalam Kotlin, jadi jika seseorang berpikir Scalaz menakutkan, maka di Kotlin juga mungkin. <br><br>  Mari tebak: <br><br>  a) Kotlin.Unit <br>  b) Kotlin. Tidak ada <br>  c) Tidak dikompilasi <br>  d) Tidak satu pun di atas <br><br><div class="spoiler">  <b class="spoiler_title">Ayo lari</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/xy/o_/fkxyo_vljbjpo9gv1lak7ubr_1a.png"><br><br>  Kami mendapat Unit yang datang entah dari mana. <br><br>  Mengapa  Pertama kita menetapkan variabel lambda: {-&gt;} - ini adalah kode yang valid, Anda dapat menulis lambda kosong.  Tidak memiliki parameter, tidak mengembalikan apa pun.  Dengan demikian, ia mengembalikan Unit. <br><br>  Kami menetapkan lambda ke variabel dan segera menulis ekstensi ke lambda ini, dan kemudian menjalankannya.  Bahkan, itu hanya akan memesan Kotlin.Unit. <br><br>  Kemudian pada lambda ini Anda dapat menulis fungsi ekstensi: <br><br><pre> <code class="kotlin hljs">.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}</code> </pre><br>  Ini dideklarasikan pada tipe Function &lt;*&gt;, dan apa yang kita miliki di atas juga cocok untuk itu.  Sebenarnya itu adalah Function &lt;Unit&gt;, tapi saya tidak menulis Unit yang tidak jelas.  Apakah Anda tahu cara kerja tanda bintang di Kotlin?     ,    Java.    ,    . <br><br>     ,    Unit  {},      ,  void-. ,   ,  .  -,      â€”   . <br></div></div><br>    .    ,  Kotlin â€”  .   iOS-     ,    ,   Kotlin   ! <br><blockquote>       Mobius,  :  <b>Mobius</b>  <b>22-23   </b> .   Kotlin    â€” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> Â«Coroutining Android AppsÂ»        .        ( Android,   iOS),      â€”  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,   <b>1 </b>   . <br><br>  :     ,            â€”  <b>6 </b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440974/">https://habr.com/ru/post/id440974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440958/index.html">Bagaimana saya mencoba memperbaiki pencarian peta untuk driver. Bagian 2</a></li>
<li><a href="../id440960/index.html">Orange Pi 2G-IOT: peta minefield</a></li>
<li><a href="../id440962/index.html">Penyedia komunikasi akan berkewajiban untuk menyimpulkan kontrak untuk koneksi bangunan tempat tinggal</a></li>
<li><a href="../id440966/index.html">Menghubungkan sensor KELLER ke MATLAB</a></li>
<li><a href="../id440972/index.html">Innopolis University akan mengadakan sekolah desain kendaraan otonom internasional pertama Rusia</a></li>
<li><a href="../id440976/index.html">Saya memindai semua Austria dan menemukan ...</a></li>
<li><a href="../id440978/index.html">Termostat ruang Wi-Fi nirkabel yang dapat diprogram dengan monitor kualitas udara dan fitur berguna lainnya</a></li>
<li><a href="../id440980/index.html">Hadiah apa yang menunggu pria pada 23 Februari? Hasil survei</a></li>
<li><a href="../id440984/index.html">Bagaimana pengurangan tingkat perolehan akan mempengaruhi kami (pemegang kartu) - 2</a></li>
<li><a href="../id440986/index.html">Lokomotif: apa yang kita ketahui tentang gerbong kereta self-propelled</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>