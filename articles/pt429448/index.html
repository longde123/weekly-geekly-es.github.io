<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèø üë©üèΩ‚Äçüíº üë®üèΩ‚Äçüåæ N√≥s escrevemos o carregador FPGA no LabVIEW. Parte 2 ‚úíÔ∏è üë©üèæ‚ÄçüöÄ üë®üèΩ‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fa√ßa o download da configura√ß√£o para FPGA via USB ou desmonte o FTDI MPSSE 
 N√≥s escrevemos o carregador FPGA no LabVIEW. Parte 1 


 No primeiro arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√≥s escrevemos o carregador FPGA no LabVIEW. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429448/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fa√ßa o download da configura√ß√£o para FPGA via USB ou desmonte o FTDI MPSSE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√≥s escrevemos o carregador FPGA no LabVIEW.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> </p><br><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><br>  No primeiro artigo, testamos o algoritmo de carregamento no bom e velho C, no segundo artigo, descobrimos como organizar um programa no LabVIEW e implementar uma interface de usu√°rio simples.  Desta vez, vamos nos familiarizar com os novos m√©todos de trabalho no LabVIEW, analisar os recursos de tratamento de erros e concluir o projeto: implementamos o protocolo para carregar o arquivo de configura√ß√£o no FPGA. <a name="habracut"></a><br><br><h2 id="obrabotka-oshibok">  Tratamento de erros </h2><br><p> Abra o c√≥digo fonte, analise a fun√ß√£o MPSSE_open.  Apesar da simplicidade algor√≠tmica (as fun√ß√µes s√£o chamadas uma ap√≥s a outra), √© necess√°rio importar alguns elementos da API do <code>FT_OpenEx</code> : <code>FT_ResetDevice</code> , <code>FT_Purge</code> , <code>FT_SetUSBParameters</code> , <code>FT_SetChars</code> , <code>FT_SetTimeouts</code> , <code>FT_SetLatencyTimer</code> , <code>FT_SetFlowControl</code> , <code>FT_SetBitMode</code>  Como foi mostrado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> , a importa√ß√£o de fun√ß√µes √© realizada usando o n√≥ <code>Call library Function</code> .  Este n√≥ possui terminais dedicados para controle de erros.  O LabVIEW possui uma regra simples: todos os <abbr title="Dispositivo virtual">VIs</abbr> devem rastrear erros e reportar erros retornados pelos terminais de erro.  A maioria dos VIs embutidos segue-o estritamente.  Espero que todos compreendam como √© importante controlar e manipular erros, especialmente no est√°gio de depura√ß√£o, mas h√° outra raz√£o pela qual isso √© t√£o importante que n√£o √© √≥bvio para programadores "cl√°ssicos".  O LabVIEW n√£o possui uma sequ√™ncia estrita de dispositivos no diagrama de blocos: o dispositivo √© executado quando os dados est√£o prontos em suas entradas.  Se os dados da sa√≠da de um VI s√£o transferidos para a entrada de outro VI, fica claro que no in√≠cio o primeiro VI funcionar√°, somente depois do segundo.  Mas e se n√£o houver transfer√™ncia de dados e os VIs executarem a√ß√µes independentes?  Obviamente, voc√™ pode usar a complexa "Estrutura de sequ√™ncia plana", mas √© muito mais conveniente conectar os dispositivos entre si por um fluxo de erros. </p><br><p>  Ao importar fun√ß√µes do D2XX, encontramos dois tipos de erros.  O primeiro - este √© um erro de importa√ß√£o direta - retorna o pr√≥prio bloco de <code>Call library Function</code> .  O segundo √© um erro da pr√≥pria biblioteca; √© retornado por quase todas as fun√ß√µes via <code>FT_STATUS</code> .  Todos os valores poss√≠veis s√£o descritos como enumera√ß√£o no arquivo de cabe√ßalho ftd2xx.h.  Embora seja suficiente saber que o valor <code>FT_OK</code> √© a aus√™ncia de um erro e todos os outros valores s√£o c√≥digos de erro, gostaria de acompanhar n√£o apenas o fato do erro em si, mas tamb√©m o erro que ocorreu e onde exatamente ocorreu. </p><br><p>  No LabVIEW, os dados de erro s√£o propagados atrav√©s de agrupamentos de <code>error</code> .  Este √© um tipo de dados dedicado t√£o especial; o LabVIEW possui muitos VIs e fun√ß√µes para trabalhar com ele.  O cluster de erros consiste em tr√™s elementos: uma vari√°vel l√≥gica - exibe o status, um n√∫mero inteiro assinado - um c√≥digo de erro, uma string - a origem do erro.  O status indica se ocorreu um erro, o c√≥digo de erro determina seu tipo e √© usado por VIs especiais para gerar um relat√≥rio.  A linha fornece uma id√©ia mais detalhada de exatamente onde o erro ocorreu.  No LabVIEW, √© aceito que, se o status for <code>TRUE</code> , isso √© um erro, se o status for <code>FALSE</code> , mas o c√≥digo n√£o √© zero e a linha de descri√ß√£o n√£o est√° vazia, isso √© um <em>aviso</em> , se o status for <code>FALSE</code> , o c√≥digo √© zero e a linha est√° vazia, n√£o h√° erro. </p><br><img src="https://habrastorage.org/webt/pm/ku/gv/pmkugvhr1yzt6uarss9lfnmthuc.png"><br><br><p>  O LabVIEW cont√©m um banco de dados interno no qual cada c√≥digo de erro est√° associado √† sua descri√ß√£o.  Para cada tipo de erro, um intervalo especial de valores de c√≥digo √© alocado.  Por exemplo, para os erros associados √† opera√ß√£o da rede, v√°rios intervalos s√£o alocados: de ‚Äì2147467263 a ‚Äì1967390460, de 61 a 65, de 116 a 118 e 122, 1101, 1114, 1115, 1132 a 1134, de 1139 a 1143 e de 1178 a 1185 Para erros definidos pelo usu√°rio, dois intervalos s√£o reservados de ‚Äì8999 a ‚Äì8000 e de 5000 a 9999. Nesses intervalos, podemos escolher valores para os c√≥digos de erro da biblioteca D2XX. </p><br><p>  Vamos criar um VI que receba o status da fun√ß√£o D2XX como entrada e converta esse status em um cluster de erros do LabVIEW.  A maioria das fun√ß√µes e VIs no LabVIEW, tendo recebido o status <code>TRUE</code> na entrada <code>Error In</code> , n√£o executa seu c√≥digo, mas transmite informa√ß√µes de erro para o terminal <code>Error Out</code> .  Isso permite que voc√™ efetivamente transfira informa√ß√µes sobre a fonte atrav√©s de toda a cadeia para o manipulador de erros, eliminando a execu√ß√£o do c√≥digo no modo de emerg√™ncia.  √â desej√°vel que nossos VIs se comportem de maneira semelhante. </p><br><p>  Vamos organizar a lista de status do D2XX na forma de <code>enum</code> e coloc√°-la em um tipo separado (no artigo anterior, fizemos isso com os tipos de FTDI). </p><br><div class="spoiler">  <b class="spoiler_title">enumera√ß√£o FT_Status</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/mb/bp/kp/mbbpkpzguefjrdg2p4l2n7-rpg0.png"></div></div><br><p>  N√≥s salvamos o novo VI com o nome FT_error.vi.  Adicionamos dois clusters <code>Error In</code> e <code>Error Out</code> painel frontal. Voc√™ pode encontr√°-los no painel "Matriz, matriz e cluster".  N√≥s os conectamos aos terminais no painel de conex√£o nos cantos inferior esquerdo e direito, respectivamente, como j√° mencionado no artigo anterior, este √© o local dos terminais de fluxo de erro adotados pelo LabVIEW.  Adicionamos a estrutura <code>Case</code> ao diagrama de blocos, fornecemos o cluster <code>Error In</code> √† entrada <code>Case selector</code> , ap√≥s o qual a estrutura <code>Case</code> muda de cor e divide dois sub-diagramas: "No Error" - cor verde e "Error" - cor vermelha.  Dentro do caso Error, transferimos o cluster de erros do terminal seletor diretamente para o t√∫nel de sa√≠da na borda direita.  E no caso verde, adicionamos outro <code>Case</code> , dependendo do status, ele determinar√° se deve ser criado um erro (o status n√£o √© igual a FT_OK) ou o deixa como est√°: pule o cluster de erros de entrada para sair sem alterar. </p><br><p>  Para converter tecnicamente o c√≥digo de erro em um cluster, voc√™ pode usar o VI <code>Error Cluster From Error Code VI</code> .  Este <abbr title="Instrumento Sub Virtual. Ele √© um Subpribor">SubVI</abbr> adiciona uma cadeia de chamadas √† descri√ß√£o do erro, para que possamos determinar n√£o apenas o <strong>que</strong> aconteceu, mas tamb√©m <strong>onde</strong> aconteceu. </p><br><p>  Para selecionar o texto correspondente ao status de entrada (FT_Status), use o bloco de propriedades: selecione "RingText.Text".  O texto do erro √© enviado para a entrada da <code>error message</code> de <code>Error Cluster From Error Code VI</code> . <br>  N√£o se esque√ßa de desenhar um √≠cone "falante". </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xx/xw/ub/xxxwubdzodjs1jfaywcbjamsrtg.png"><br>  <em>Painel frontal do sub-instrumento</em> </p><br><p><img src="https://habrastorage.org/webt/ja/wu/te/jawuteahiriyixrjpcgbm91esjo.png"><br>  <em>Diagrama de blocos.</em>  <em>Erro de entrada</em> </p><br><p><img src="https://habrastorage.org/webt/yd/qf/lp/ydqflp1m-zexy_zvvdx8drixu9e.png"><br>  <em>Diagrama de blocos.</em>  <em>N√£o h√° erro na entrada e o status √© FT_OK</em> </p><br><p><img src="https://habrastorage.org/webt/1h/wp/7m/1hwp7mcprzgv3mf9oz3jenbco4q.png"><br>  <em>Diagrama de blocos.</em>  <em>N√£o h√° erro na entrada, mas o status √© diferente de FT_OK</em> </p><br></div></div><br><p>  Para testar o FT_error, voc√™ pode criar um VI vazio, adicionar o VI criado l√° e ver como o valor ser√° alterado na inicializa√ß√£o se v√°rios status forem aplicados. </p><br><div class="spoiler">  <b class="spoiler_title">Teste FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rn/_r/be/rn_rbewvlb--au_hi3nosghkjmk.png"><br>  <em>Painel frontal (frontal) do dispositivo</em> </p><br><p><img src="https://habrastorage.org/webt/ju/44/fz/ju44fzmyx2aly2-fraydjrkyffg.png"><br>  <em>Diagrama de blocos</em> </p></div></div><br><p>  Agora, ap√≥s qualquer chamada de fun√ß√£o da API do D2XX, usaremos o SubVI FT_error.vi.  Um cluster de erros passar√° por todos os VIs na hierarquia de chamadas. </p><br><p>  Nos VIs de n√≠vel superior, devemos decidir o que fazer com o erro detectado: voc√™ pode exibir uma mensagem na caixa de di√°logo, grav√°-la no arquivo de relat√≥rio, ignor√°-la ou simplesmente "silenciosamente" finalizar o aplicativo.  A caixa de di√°logo √© a maneira mais f√°cil e popular de relatar erros.  Tamb√©m √© conveniente para um programador iniciante, pois n√£o h√° nada a fazer.  Em cada VI, o modo <strong>autom√°tico de tratamento de erros</strong> √© ativado por padr√£o ( <strong>Ative o tratamento autom√°tico de erros</strong> , localizado na categoria Execu√ß√£o do menu Propriedades do VI).  Funciona assim: se o terminal <code>Error Out</code> n√£o estiver conectado em nenhum lugar de algum n√≥ e ocorrer um erro nesse n√≥, o LabVIEW interrompe o aplicativo e exibe uma caixa de di√°logo.  Se o terminal <code>Error Out</code> do n√≥ estiver conectado, o fluxo de erros ser√° propagado conforme programado e nenhuma a√ß√£o adicional ocorrer√°.  No entanto, a janela de mensagem pode ser acessada de forma program√°tica, para isso, √© necess√°rio usar os VIs <code>Simple Error Handler</code> <code>General Error Handler</code> e <code>Simple Error Handler</code> (localizados no painel Di√°logo e interface do usu√°rio).  Nesse caso, podemos usar as informa√ß√µes de erro para concluir o programa.  Em um diagrama de blocos, √© algo como isto: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/u9/8y/_p/u98y_paluq1jtgm2gylcaceydgs.png"></a> <br>  <em>Imagem clic√°vel</em> </p><br><p>  Quando ocorrer um erro, o programa ser√° suspenso, uma janela de relat√≥rio ser√° exibida. Ap√≥s fechar a janela, o programa ser√° encerrado corretamente. </p><br><div class="spoiler">  <b class="spoiler_title">Janela de relat√≥rio</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><h2 id="otkryt-i-zakryt-ftdi">  Abrir e fechar FTDI </h2><br><p>  Ent√£o, de volta √† fun√ß√£o <code>MPSSE_open</code> .  Crie um novo <abbr title="Instrumento virtual">VI</abbr> .  Primeiro de tudo, adicione os terminais para o fluxo de erros.  Adicione uma estrutura de sele√ß√£o e selecione Entrada de <code>Error In</code> no seletor.  No caso verde, importamos as fun√ß√µes na ordem e com os par√¢metros como no prot√≥tipo de Sishny.  Todos os n√≥s do n√≥ da <code>Call Library Function Node</code> conectados em uma cadeia por um fluxo de erros.  No estojo vermelho atrav√©s do t√∫nel, conectamos o <code>Error In</code> ao terminal de sa√≠da do erro. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/4p/qq/zx/4pqqzxgwcgsbb-jcvepvyaj6jam.png"></a> <br>  <em>Imagem clic√°vel</em> </p><br><p><img src="https://habrastorage.org/webt/5z/uq/k6/5zuqk6hmya20zgu9ddnciwgj5a0.png"><br>  <em>VI MPSSE_open.vi</em> </p><br><p>  Uma linha com a descri√ß√£o de FTDI ( <code>Description</code> ) √© fornecida √† entrada do SubVI, na sa√≠da √© <code>Handle</code> e um chip FTDI inicializado no modo MPSSE. </p><br><p>  Vamos criar um vice-presidente que termine de trabalhar com o FTDI e voc√™ j√° poder√° verificar o desempenho no hardware. </p><br><div class="spoiler">  <b class="spoiler_title">FT_Close.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1e/te/g3/1eteg3uh0t2t16y9yho_kxjbufe.png"><br>  <em>Diagrama de blocos</em> </p><br><p><img src="https://habrastorage.org/webt/ki/ez/tt/kiezttogb-2n4zl1qe893hfc55w.png"><br>  <em>Painel frontal</em> </p></div></div><br><p>  No artigo anterior, para depurar a interface, criamos o stub VI SP_FT_MPSSE_FPGA.vi, agora √© hora de preench√™-lo.  Adicione MPSSE_open.vi e FT_Close.vi ao seu diagrama de blocos.  Nesse est√°gio, √© bastante dif√≠cil avaliar se a inicializa√ß√£o estava correta; no entanto, o valor diferente de zero de <code>Handle</code> na sa√≠da do MPSSE_open.vi e a aus√™ncia de um erro nos dizem muito. </p><br><p><img src="https://habrastorage.org/webt/ci/rn/q5/cirnq5ik2_g5p-wbz3cmfcxzquo.png"><br>  <em>Fluxograma SP_FT_MPSSE_FPGA.vi</em> </p><br><p>  Para ver o valor de <code>Handle</code> voc√™ pode usar a "Janela de inspe√ß√£o do probe".  Esta √© uma ferramenta de depura√ß√£o conveniente que permite exibir o valor dos dados em qualquer fio (quase qualquer) durante a execu√ß√£o do dispositivo.  Para definir a amostra na linha, voc√™ precisa selecionar "Sonda" no menu de contexto desta linha.  A janela "Probe Watch Window" ser√° aberta e um n√∫mero com o n√∫mero da amostra aparecer√° na linha.  Na imagem acima, √© "3". </p><br><div class="spoiler">  <b class="spoiler_title">Janela de inspe√ß√£o do probe</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yq/qv/u_/yqqvu_pkihohde2in-uy7sttt-i.png"><br>  <em>Na linha Al√ßa, o valor 698389336</em> </p></div></div><br><p>  √ìtimo!  Iniciamos os VIs de n√≠vel superior, conectamos a placa de depura√ß√£o ao computador.  Uma descri√ß√£o do chip FTDI conectado aparece na lista "Selecionar um dispositivo", clique no bot√£o "Programa" e ... nada acontece.  Somente na janela "Probe Watch" o valor <code>Handle</code> exibido.  E isso √© bom. </p><br><p>  Desligamos o painel, a lista de dispositivos √© limpa.  Clique em "Programa".  √â aqui que a janela do relat√≥rio de erros √© exibida. </p><br><div class="spoiler">  <b class="spoiler_title">Janela de relat√≥rio</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><p>  Depois de clicar no bot√£o "Continuar", o VI conclui seu trabalho. </p><br><p>  √â proibido pressionar o bot√£o se nenhum dispositivo for encontrado.  Modificamos o manipulador de eventos "Timeout" do caso.  Deixe-me lembr√°-lo de que os chips FTDI conectados a um PC s√£o verificados duas vezes por segundo, se forem detectados e puderem ser usados ‚Äã‚Äãpara programar FPGAs, seus descritores ser√£o adicionados √† <code>Devices list</code> atrav√©s da propriedade <code>Strings[]</code> .  Criamos a propriedade <code>Disabled</code> para "Programming" e, se nenhum dispositivo adequado for encontrado, desligue e escure√ßa o bot√£o. </p><br><div class="spoiler">  <b class="spoiler_title">Tempo limite do caso</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wx/nf/5n/wxnf5n-ttwqqrsmbtydmttzcghw.png"></a> <br>  <em>Imagem clic√°vel</em> </p></div></div><br><h2 id="osvaivaem-gpio">  Dominando o GPIO </h2><br><p>  Depois que o MPSSE √© ativado, o trabalho √© realizado atrav√©s do chamado "c√≥digo operacional", e somente <code>FT_Write</code> , <code>FT_Read</code> e <code>FT_Queue</code> s√£o usados ‚Äã‚Äãnas fun√ß√µes da API do <code>FT_Write</code> (para descobrir o status do buffer do receptor).  Criamos o VI correspondente ao longo da trilha que criamos: FT_Write.vi, FT_Read.vi, FT_Queue.vi. </p><br><div class="spoiler">  <b class="spoiler_title">Um pouco de rotina</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tw/or/ku/tworkua4o2qj3bntqoer1jb4o0u.png"><br>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/8k/pm/4s/8kpm4sdeaqgzlsctp-106wvtdz0.png"><br>  <em>Diagrama de blocos.</em>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/i0/px/18/i0px189plvqpokb3sijjuxtxbei.png"><br>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ku/hm/xw/kuhmxw1j66symp05f0ergjkriag.png"><br>  <em>Diagrama de blocos.</em>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/bf/2s/q_/bf2sq_t4uinirm94vmh-ugkzqzy.png"><br>  <em>FT_Queue.vi</em> </p><br><p><img src="https://habrastorage.org/webt/5p/zm/dv/5pzmdvtnhtdq0ivxzfs0t32nfjk.png"><br>  <em>Diagrama de blocos.</em>  <em>FT_Queue.vi</em> </p></div></div><br><p>  Agora, a partir desses tr√™s tijolos, apresentamos os VIs para ler a porta paralela e escrever nela.  O valor √© convenientemente representado como uma matriz de vari√°veis ‚Äã‚Äãbooleanas. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Set_LByte.vi e MPSSE_Get_LByte.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/oy/uh/8l/oyuh8lrdyniwp6ub2pvgwrxtlvw.png"><br>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/g4/ab/u-/g4abu-lurodnce0udnamj1ftsjm.png"><br>  <em>Diagrama de blocos.</em>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/7g/s9/5d/7gs95ddkb8pg9fjzt-s0vflzes4.png"><br>  <em>MPSSE_Get_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ki/dm/n_/kidmn_ewfihbrokreabs90538p0.png"><br>  <em>Diagrama de blocos.</em>  <em>MPSSE_Get_LByte.vi</em> </p><br><p>  Confesso que tive pregui√ßa de criar uma lista nomeada para todos os c√≥digos operacionais, ent√£o os deixei na forma de N√∫meros M√°gicos. </p></div></div><br><p>  Conforme declarado no primeiro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> , o protocolo de inicializa√ß√£o Passive Serial FPGA nada mais √© do que um SPI com manipula√ß√£o adicional de sinalizador.  Um total de cinco <em>partes</em> √© usado: as <em>linhas DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> devem ser configuradas como sa√≠das, as <em>linhas nSTATUS</em> , <em>CONF_DONE</em> como entradas. </p><br><div class="spoiler">  <b class="spoiler_title">Pinagem do layout da tabela</b> <div class="spoiler_text"><table><thead><tr><th>  Pino FPGA </th><th>  Nome do PIN </th><th>  Pin </th><th>  MPSSE </th><th>  Dire√ß√£o </th><th>  padr√£o </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38. </td><td>  TCK / SK </td><td>  Fora </td><td>  0 0 </td></tr><tr><td>  DADOS [0] </td><td>  BDBUS1 </td><td>  39. </td><td>  TDI / DO </td><td>  Fora </td><td>  1 </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40. </td><td>  TDO / DI </td><td>  Fora </td><td>  1 </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41. </td><td>  TMS / CS </td><td>  Em </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  Em </td><td>  1 </td></tr></tbody></table></div></div><br><p>  Precisamos de um vice-presidente que possa alterar o valor da perna selecionada sem afetar todas as outras.  Primeiro, crie <code>Enum</code> com n√∫meros de s√©rie das pernas na porta, salve-o como "Strict Type Def" no arquivo SP_LBYTE_BITS.ctl.  Criamos um novo VI, adicionamos os terminais de fluxo de erro conhecidos.  Lemos o valor atual da porta paralela usando MPSSE_Get_LByte.vi, usamos a fun√ß√£o <code>Replace Array Subset</code> para modificar o bit desejado e gravamos o valor de volta na porta (MPSSE_Set_LByte.vi). </p><br><div class="spoiler">  <b class="spoiler_title">SP_Set_Flag.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/y7/d3/ap/y7d3aps-9ima93quyatag0ggkui.png"><br>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/jn/ae/h4/jnaeh4ewehebgcba9fstkxnxa4o.png"><br>  <em>Diagrama de blocos.</em>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ud/mt/jx/udmtjxpekkcskrmisie8t2h4hfw.png"><br>  <em>Enum SP_LBYTE_BITS.ctl</em> </p></div></div><br><p>  Para iniciar a configura√ß√£o, o MPSSE deve gerar uma transi√ß√£o de baixa para alta na linha <em>nCONFIG</em> .  Assim que o FPGA estiver pronto para receber dados, ele formar√° um alto n√≠vel na linha <em>nSTATUS</em> .  Nesta fase, tudo est√° pronto para o experimento em ferro.  No diagrama de blocos SP_FT_MPSSE_FPGA.v, adicionamos a linha de controle <em>nCONFIG</em> - ap√≥s a inicializa√ß√£o do MPSSE, fornecemos um n√≠vel baixo e depois alto.  Ap√≥s cada opera√ß√£o (para depura√ß√£o), lemos o status dos trechos da porta. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5q/8g/u1/5q8gu1k9oezxomhdblxqyjbxxas.png"><br>  <em>Durante a inicializa√ß√£o</em> </p><br><p><img src="https://habrastorage.org/webt/nj/qv/bv/njqvbvi3dibaezauuqh4t2thdo8.png"><br>  <em>Diagrama de blocos</em> </p></div></div><br><p>  Em geral, durante o lan√ßamento do VI, √© claro que o FPGA responde √† transi√ß√£o na linha <em>nCONFIG</em> - zero √© definido na perna <em>nSTATUS</em> e depois uma.  Mas n√£o ser√° sup√©rfluo monitorar isso com um oscilosc√≥pio.  Quase todos os oscilosc√≥pios de dois canais com acionamento por disparo (espera) s√£o adequados.  Canal <strong>A</strong> (faixa azul) Coloquei no ponto de controle do circuito <em>nCONFIG</em> , canal <strong>B</strong> (faixa vermelha) - cadeia <em>nSTATUS</em> .  O gatilho est√° definido para a extremidade descendente do canal <strong>A.</strong> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ca/b9/ti/cab9tizq5kpbnbguzew2avmi_je.png"></a> <br>  <em>A imagem √© clic√°vel.</em>  <em>Com os detalhes!</em> </p><br><h2 id="rabota-s-faylom">  Trabalhar com arquivo </h2><br><p>  O FPGA est√° pronto para aceitar o arquivo de configura√ß√£o.  Estamos prontos para transferir o arquivo para o FPGA? </p><br><p>  O LabVIEW cont√©m um extenso conjunto de ferramentas para trabalhar com arquivos.  N√£o posso dizer que a funcionalidade seja suficiente para absolutamente toda a gama de tarefas; no entanto, opera√ß√µes b√°sicas como <em>leitura</em> e <em>escrita</em> s√£o realizadas de maneira f√°cil e agrad√°vel.  O conjunto b√°sico de VIs para trabalhar com arquivos pode ser encontrado no painel "File I / O".  Para resolver o problema, voc√™ precisa abrir o arquivo de configura√ß√£o, avaliar seu tamanho (precisamos saber quantos bytes enviar o FPGA), l√™-lo e fech√°-lo.  Tudo √© simples e um ap√≥s o outro.  Usamos os <code>refnum</code> <code>Open/Create/Replace File</code> , <code>Get File Size</code> , <code>Read from Binary File</code> , <code>Close File</code> , combin√°-los com a cadeia de fluxo de erro e <code>refnum</code> - um n√∫mero, como um descritor de arquivo, √© criado quando o arquivo √© aberto e deve ser transferido para a entrada de outros VIs que trabalham com esse arquivo. </p><br><p>  At√© o momento, n√£o temos nenhum lugar para descartar os dados lidos, mas se voc√™ realmente deseja verificar a operacionalidade da cadeia, pode criar um indicador do tipo <code>String</code> e configur√°-lo um pouco.  No menu de contexto, ative a op√ß√£o "Hex Display", ative a barra de rolagem vertical (Itens Vis√≠veis -&gt; Barra de Rolagem Vertical) e, ap√≥s o lan√ßamento, observamos o conte√∫do do arquivo de configura√ß√£o bin√°ria. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7w/r8/dy/7wr8dyzaxomkxwmqioien0rn2om.png"><br>  <em>Painel frontal</em>  <em>Examinamos o conte√∫do do arquivo</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qf/8l/vv/qf8lvvjj6xtwo_be0aiu-3aa2co.png"></a> <br>  <em>Diagrama de blocos.</em>  <em>Karinka clic√°vel</em> </p></div></div><br><p>  Duas linhas paralelas independentes de c√≥digo formadas no diagrama de blocos do VI, portanto, cadeias de erro separadas s√£o usadas para elas.  Para reduzir os fluxos paralelos em um terminal <code>Error Out</code> , a fun√ß√£o <code>Merge Errors</code> <code>Error Out</code> √© usada.  Esta fun√ß√£o procura erros de entrada de cima para baixo (sim, pode haver mais de dois terminais de entrada, √© esticada pelo mouse) e retorna o primeiro que encontrar.  Se n√£o houver erros, ele retornar√° a primeira mensagem de aviso.  Se n√£o houver avisos, n√£o haver√° erro na sa√≠da.  √â importante observar que a ordem de conex√£o das entradas <code>Merge Errors</code> determina a prioridade dos erros e, se ocorrer um erro imediato em duas cadeias, o erro mais baixo ser√° ignorado.  Isso deve ser tratado com cuidado. </p><br><p>  Se tentarmos pressionar o bot√£o "Programa" no VI de n√≠vel superior sem selecionar um arquivo, a entrada SP_FT_MPSSE_FPGA.vi receber√° um caminho vazio, o que causar√° o erro "Erro 1430. LabVIEW: (Hex 0x596) O caminho est√° vazio ou relativo. Voc√™ deve usar um caminho absoluto ".  Como meu amigo de inf√¢ncia diz: "Ninharia, isso √© algo mundano!"  E esse erro n√£o √© um erro, mas a falta de aten√ß√£o do usu√°rio.  N√£o interromperemos o programa e juraremos com uma janela com uma cruz vermelha; simplesmente removemos o erro com esse c√≥digo do fluxo e, na caixa de di√°logo, recomendamos que o usu√°rio decida o arquivo.  Para filtrar o erro, use o VI "Limpar erros" na paleta "Caixa de di√°logo e interface do usu√°rio".  Para exibir a mensagem - "Caixa de di√°logo com um bot√£o". </p><br><p><img src="https://habrastorage.org/webt/o2/nf/bm/o2nfbmdreh3hdppvxsabj7hsgt4.png"></p><br><div class="spoiler">  <b class="spoiler_title">Diagrama de blocos</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/-6/ik/cp/-6ikcptiqxx7uloza1v2g5y6wdo.png"></a> <br>  <em>Imagem clic√°vel</em> </p></div></div><br><h2 id="zagruzka-konfiguracii">  Download da configura√ß√£o </h2><br><p>  Para transfer√™ncia serial de dados, o processador MPSSE precisa enviar o c√≥digo operacional 0x18, os argumentos do comando ser√£o o comprimento da sequ√™ncia transmitida (dois bytes, come√ßando pelo mais baixo) e a pr√≥pria sequ√™ncia de dados.  O comprimento √© codificado menos um.  Vamos enviar o bloco de dados como o VI MPSSE_send. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Send.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/my/du/hi/myduhilu9cbsm8f3j_ceduagppq.png"><br>  <em>MPSSE_Send.vi</em> </p><br><p><img src="https://habrastorage.org/webt/fv/13/9m/fv139mrjy-t8l8cz-u82btswts8.png"><br>  <em>Diagrama de blocos</em> </p></div></div><br><p>  O tamanho do buffer de entrada ( <code>Array Size</code> ) √© convertido em um tipo de byte duplo <code>U16</code> , subtra√≠mos um, trocamos os bytes alto e baixo (bytes de <code>Swap Bytes</code> ) - voc√™ precisa enviar o comprimento come√ßando pelo mais baixo e converter o n√∫mero de byte duplo em um array de byte √∫nico (convers√£o de <code>Type Cast</code> ). </p><br><p>  A fun√ß√£o <code>Type Cast</code> merece aten√ß√£o especial.  Esse √© um conversor de tipo universal, cuja engenhosidade √†s vezes √© muito surpreendente.  Em suma, ent√£o: </p><br><p><img src="https://habrastorage.org/webt/k9/qp/0t/k9qp0tiyjs2ajjgisnhbfuaonpe.png"><br>  <em>Visualmente para o programador</em> </p><br><p>  No entanto, isso n√£o √© apenas converter dados para um tipo diferente, √© tamb√©m uma interpreta√ß√£o heur√≠stica.  Esta fun√ß√£o permite realizar a convers√£o entre tipos de dados incompat√≠veis, enquanto a fun√ß√£o n√£o hesita em alinhar os dados de entrada e at√© remover as partes "extras".  Se o tipo de dados solicitado exigir mais mem√≥ria que os dados de entrada, a fun√ß√£o alocar√° a quantidade que falta.  Para um desenvolvedor iniciante, o LabVIEW <code>Type Cast</code> pode se tornar um salva-vidas, mas com o crescimento, √© melhor recusar esse conversor - ele fica muito escondido da vista e pode se tornar uma fonte de erros inesperados.  √â melhor usar m√©todos de convers√£o mais expl√≠citos, como <code>Coerce To Type</code> . </p><br><p>  Ao inicializar o processador MPSSE, configuramos o tamanho m√°ximo permitido do buffer para transfer√™ncia de dados para 65536 bytes; portanto, devemos dividir o arquivo de configura√ß√£o em fragmentos cujo tamanho n√£o exceda o tamanho especificado.  Usaremos a fun√ß√£o <code>Array Subset</code> , essa fun√ß√£o seleciona uma subarray da matriz, come√ßando com o elemento <code>index</code> e um <code>length</code> longo.  N√≥s o dividiremos em um loop <code>While</code> , aumentaremos cada itera√ß√£o do √≠ndice em 65536. Entre as itera√ß√µes, passaremos o valor pelo registro de deslocamento.  Assim que n√£o √© poss√≠vel extrair 65536 bytes da matriz principal, pegamos tudo o que resta, enviamos e paramos o ciclo. </p><br><p>  De acordo com o protocolo de download, ap√≥s a transfer√™ncia de todos os dados, mais dois pulsos de clock devem ser aplicados para iniciar a inicializa√ß√£o do FPGA.  Para fazer isso, ap√≥s o loop, enviamos outro byte "vazio". </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vp/y4/wr/vpy4wrsts1szqayvnquvjtb2nzw.png"></a> <br>  <em>Imagem clic√°vel</em> </p></div></div><br><p>  Para entender o sucesso do firmware, consideramos os sinalizadores e, se <em>CONF_DONE estiver</em> definido como um, <em>relatamos o</em> n√≠vel superior VI de que tudo est√° OK. </p><br><p>  O programa est√° completo.  Resta garantir que o FPGA esteja piscando com sucesso e a placa pisque alegremente com os LEDs. </p><br><h2 id="pro-imenovanie-vp">  Sobre a nomea√ß√£o de vice-presidente </h2><br><p>     ,             ,       LabVIEW, ,      SubVI.              .        : </p><br><ul><li>    ‚Äî  ,     FTDI,           API D2XX.            "FT",  FT_Close.vi  FT_Read.vi. </li><li>   ‚Äî     MPSSE.        "MPSSE". : MPSSE_open.vi, MPSSE_Set_LByte.vi, MPSSE_Get_LByte.vi. </li><li>   ‚Äî    "Passive Serial"  MPSSE.     "S". , SP_FT_MPSSE_FPGA.vi ( ,   )  SP_LBYTE_BITS.ctl. </li><li>  .   .    , . </li></ul><br><p>     ( ),             .          <em>subVI</em> . </p><br><h2 id="zaklyuchenie">  </h2><br><p>  ,     ,           . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/i0/fq/ffi0fqqs7gbi3aczbucvusrw2qi.jpeg"></p></div></div><br><p>         ,        LabVIEW,        .    ,     ,        ,         (    ).         . </p><br><h2 id="materialy-po-teme">  Materiais relacionados </h2><br><ol><li>  . LabVIEW:  .  Per.  .  .  .‚Äì .: <br>  , 2008 ‚Äì 400 .: . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">labview_mpsse</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> .    </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429448/">https://habr.com/ru/post/pt429448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../In146152/index.html">‡§ü‡•à‡§≤‡•á‡§Ç‡§ü ‡§Æ‡•à‡§™ ‡§∞‡§ø‡§ú‡•ç‡§Ø‡•Ç‡§Æ‡•á ‡§µ‡§ø‡§ú‡§º‡•Å‡§Ö‡§≤‡§æ‡§á‡§ú‡§º‡§∞ - ‡§∞‡§ø‡§≤‡•Ä‡§ú‡§º ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§∞‡§æ‡§∏‡•ç‡§§‡•á ‡§™‡§∞ ‡§è‡§°‡§µ‡•á‡§Ç‡§ö‡§∞‡•ç‡§∏</a></li>
<li><a href="../pt429420/index.html">O PlayStation Classic usa o emulador PCSX ReARMed para opera√ß√£o, sem solu√ß√µes propriet√°rias</a></li>
<li><a href="../pt429422/index.html">UHCI, ou o primeiro USB</a></li>
<li><a href="../pt429424/index.html">Robotaxi da Daimler e Bosch aparecer√° na Calif√≥rnia</a></li>
<li><a href="../pt429426/index.html">QGIS e exporta√ß√£o de ladrilhos</a></li>
<li><a href="../pt429450/index.html">T√©cnicas de programa√ß√£o generalizada em Rust: como traduzimos Exonum de Iron para actix-web</a></li>
<li><a href="../pt429452/index.html">O Pent√°gono come√ßou a desclassificar o malware de outras pessoas</a></li>
<li><a href="../pt429456/index.html">J√° √© uma hist√≥ria: onde a cultura de startups come√ßou nos anos 30</a></li>
<li><a href="../pt429458/index.html">Como fiz anima√ß√µes do Sistema Solar para um filho da segunda s√©rie</a></li>
<li><a href="../pt429460/index.html">Resumo do relat√≥rio ‚ÄúO que sabemos sobre microsservi√ßos‚Äù (HL2018, Avito, Vadim Madison)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>