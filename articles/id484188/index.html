<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ğŸ½ ğŸ‘‚ğŸ¿ ğŸ¤·ğŸ½ Standar Desain Basis Data â– ğŸ‘ ğŸ‘¨ğŸ½â€ğŸš’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pindah dari satu proyek ke proyek, sayangnya, kita dihadapkan dengan kurangnya standar seragam untuk desain database, terlepas dari kenyataan bahwa SQ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Standar Desain Basis Data</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484188/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/zj/ej/pazjejv8zvpor7tzaggxr54csd4.jpeg"></div><br>  Pindah dari satu proyek ke proyek, sayangnya, kita dihadapkan dengan kurangnya standar seragam untuk desain database, terlepas dari kenyataan bahwa SQL telah ada selama beberapa dekade.  Saya menduga alasannya adalah sebagian karena sebagian besar pengembang tidak memahami arsitektur database.  Selama bertahun-tahun bekerja dalam mempekerjakan pengembang, saya hanya bertemu beberapa kali dengan mereka yang dapat menormalkan database dengan benar.  Jujur, ini bisa menjadi tugas yang sulit, tetapi banyak pengembang yang saya wawancarai, bahkan fasih dalam SQL, tidak memiliki keterampilan desain database. <br><br>  Artikel ini bukan tentang normalisasi DB.  Jika Anda ingin mempelajari ini, di <a href="https://youtu.be/y1tcbhWLiUM">sini</a> saya secara singkat memberi tahu Anda dasar-dasarnya. <br><br>  Jika Anda memiliki database yang berfungsi, maka Anda perlu menjawab pertanyaan Anda: "standar apa yang dapat diterapkan untuk memfasilitasi <i>penggunaan</i> database ini?".  Jika standar-standar ini digunakan secara luas, maka akan mudah bagi Anda untuk menggunakan database, karena Anda tidak harus mempelajari dan mengingat set standar baru setiap kali Anda mulai bekerja dengan database baru. <br><a name="habracut"></a><br><h1>  Penamaan CamelCase atau garis bawah? </h1><br>  Saya terus-menerus menemukan database di mana tabel diberi nama dengan gaya <code>CustomerOrders</code> atau <code>customer_orders</code> .  Mana yang lebih baik untuk digunakan?  Mungkin Anda ingin menerapkan standar yang sudah ada, tetapi jika Anda membuat database baru, maka saya sarankan menggunakan garis bawah untuk meningkatkan aksesibilitas.  Ungkapan "di bawah nilai" memiliki arti yang berbeda dibandingkan dengan "undervalue", tetapi dengan garis bawah, yang pertama akan selalu di bawah <code>under_value</code> , dan yang kedua akan di bawah <code>undervalue</code> .  Dan ketika menggunakan CamelCase kita mendapatkan <code>Undervalue</code> dan <code>UnderValue</code> , yang identik dalam hal SQL case-insensitive.  Selain itu, jika Anda memiliki masalah penglihatan dan terus-menerus bereksperimen dengan headset dan pin untuk menekankan kata-kata, maka menggarisbawahi <i>jauh</i> lebih mudah dibaca. <br><br>  Akhirnya, CamelCase sulit dibaca bagi mereka yang bahasa Inggrisnya bukan bahasa asli. <br>  Singkatnya, ini bukan rekomendasi yang ketat, tetapi preferensi pribadi. <br><br><h1>  Bentuk jamak atau tunggal dalam nama tabel? </h1><br>  Para ahli teori database telah berdebat sejak lama tentang apakah tabel harus tunggal (pelanggan) atau jamak (pelanggan).  Biarkan saya memotong simpul Gordian ini tanpa masuk lebih dalam ke teori, hanya dengan bantuan pragmatisme: nama-nama tabel jamak kurang mungkin bertentangan dengan kata kunci yang dipesan. <br><br>  Apakah Anda memiliki pengguna - <code>users</code> ?  SQL memiliki kata kunci <code>user</code> .  Apakah Anda memerlukan tabel kendala?  <code>constraint</code> adalah kata yang dilindungi undang-undang.  Kata <code>audit</code> <br>  dicadangkan, tetapi apakah Anda memerlukan tabel <code>audit</code> ?  Cukup gunakan bentuk <i>jamak</i> dari kata benda, dan kemudian sebagian besar kata-kata yang dipesan tidak akan mengganggu Anda dalam SQL.  Bahkan PostgreSQL, yang memiliki parser SQL yang sangat baik, telah tersandung di tabel <code>user</code> . <br><br>  Cukup gunakan bentuk jamak, dan kemungkinan konflik akan jauh lebih rendah. <br><br><h1>  Jangan beri nama kolom dengan ID sebagai "id" </h1><br>  Saya sendiri telah berdosa selama bertahun-tahun.  Suatu kali saya bekerja dengan seorang klien di Paris, dan DBA mengeluh tentang saya ketika saya memberi kolom <code>id</code> nama <code>id</code> .  Saya pikir dia hanya seorang pedant.  Memang, nama kolom <code>customers.id</code> adalah unik, dan <code>customers.customer_id</code> adalah pengulangan informasi. <br><br>  Dan kemudian saya harus men-debug ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thread.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> email <span class="hljs-keyword"><span class="hljs-keyword">thread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> email selected <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> selected.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> recipient <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipient.id = thread.recipient_id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station_area sa <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> sa.id = recipient.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station st <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> st.id = sa.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star origin <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> origin.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star destination <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> destination.id = st.id <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ( route.from_id = origin.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> route.to_id = destination.id ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> selected.id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( thread.sender_id = ? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( thread.recipient_id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( origin.id = destination.id <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( route.distance <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() &gt;= thread.datesent + ( route.distance * <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 seconds'</span></span> ) )))) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> datesent <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, thread.parent_id <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span></code> </pre> <br>  Perhatikan masalahnya?  Jika SQL menggunakan nama id lengkap, seperti <code>email_id</code> , <code>star_id</code> atau <code>station_id</code> , maka bug akan segera <i>keluar saat saya menulis kode ini</i> , dan tidak lebih kemudian, ketika saya mencoba memahami apa yang saya lakukan salah. <br><br>  Bantulah diri Anda sendiri dan gunakan nama lengkap untuk ID.  Terima kasih nanti <br><br><h1>  Nama kolom </h1><br>  Beri kolom nama deskriptif sebanyak mungkin.  Katakanlah kolom <code>temperature</code> tidak ada hubungannya dengan ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> temperature &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  Saya tinggal di Prancis, dan bagi kami suhu 32 derajat akan "terlalu dingin".  Karena itu, lebih baik memberi nama kolom <code>fahrenheit</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fahrenheit &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  Sekarang semuanya sudah jelas. <br><br>  Jika Anda memiliki batasan kunci asing, berikan nama yang sama ke kolom di kedua sisi pembatasan bila memungkinkan.  Berikut ini adalah SQL yang masuk akal, masuk akal: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.owner = s.person_id;</code> </pre> <br>  Kode ini benar-benar baik-baik saja.  Tetapi ketika Anda melihat definisi tabel, Anda akan melihat bahwa <code>some_other_table.owner</code> memiliki batasan kunci asing dengan <code>companies.company_id</code> .  Jadi intinya SQL ini salah.  Itu perlu untuk menggunakan nama yang identik: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.company_id = s.person_id;</code> </pre> <br>  Sekarang segera jelas bahwa kami memiliki bug, Anda hanya perlu memeriksa satu baris kode dan tidak merujuk ke definisi tabel. <br><br>  Namun, saya ingin mencatat bahwa ini tidak selalu bisa dilakukan.  Jika Anda memiliki tabel dengan gudang sumber dan tujuan, maka Anda mungkin ingin membandingkan <code>source_id</code> dengan <code>destination_id</code> dengan <code>warehouse_id</code> .  Dalam hal ini, lebih baik memberi nama <code>source_warehouse_id</code> dan <code>destination_warehouse_id</code> . <br><br>  Perhatikan juga bahwa dalam contoh di atas, <code>owner</code> akan mendeskripsikan tujuannya lebih baik daripada <code>company_id</code> .  Jika ini membingungkan Anda, Anda dapat memberi nama kolom <code>owning_company_id</code> .  Maka nama akan memberi tahu Anda tujuan kolom. <br><br><h1>  Hindari Nilai NULL </h1><br>  Nasihat ini diketahui oleh banyak pengembang basis data yang berpengalaman, tetapi, sayangnya, mereka tidak cukup sering membicarakannya: tanpa alasan yang baik, jangan izinkan nilai NULL dalam basis data. <br>  Ini adalah topik yang penting namun agak rumit.  Pertama, kita membahas teori, kemudian pengaruhnya pada arsitektur database, dan sebagai kesimpulan kita akan menganalisis contoh praktis masalah serius yang disebabkan oleh adanya nilai-nilai NULL. <br><br><h2>  Jenis basis data </h2><br>  Basis data dapat berisi data dari berbagai <i>jenis</i> : INTEGER, JSON, DATETIME, dll. Jenis ini dikaitkan dengan kolom dan nilai apa pun yang ditambahkan harus sesuai dengan jenis ini. <br><br>  Tapi apa jenisnya?  Ini adalah nama, satu set nilai yang valid dan satu set operasi yang valid.  Mereka membantu kita menghindari perilaku yang tidak diinginkan.  Misalnya, apa yang terjadi di Jawa jika Anda mencoba membandingkan string dan angka? <br><br><pre> <code class="sql hljs">CustomerAccount.java:5: error: bad operand types for binary operator '&gt;' if ( current &gt; threshold ) { ^ first type: String second type: int</code> </pre> <br>  Bahkan jika Anda tidak memperhatikan bahwa <code>current &gt; threshold</code> membandingkan jenis yang tidak ada bandingnya, kompiler akan menangkap ini untuk Anda. <br><br>  Ironisnya, database yang menyimpan data Anda - dan merupakan garis pertahanan terakhir Anda terhadap korupsi data - bekerja sangat buruk dengan tipe!  Hanya menjijikkan.  Misalnya, jika tabel <code>customers</code> Anda memiliki kunci pengganti, Anda dapat melakukan ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, birthdate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> customer_id &gt; weight;</code> </pre> <br>  Tentu saja, ini tidak masuk akal dan pada kenyataannya Anda akan mendapatkan kesalahan kompilasi.  Banyak bahasa pemrograman membuatnya lebih mudah untuk menangkap kesalahan tipe seperti itu, tetapi dengan database, yang terjadi adalah sebaliknya. <br><br>  Ini adalah situasi normal di dunia basis data, mungkin karena <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">standar SQL pertama dirilis pada tahun 1992</a> .  Komputer lambat pada tahun-tahun itu, dan segala sesuatu yang rumit dalam implementasinya tidak diragukan lagi memperlambat database. <br><br>  Dan kemudian nilai NULL muncul di tempat kejadian.  Standar SQL mengimplementasikannya dengan benar hanya di satu tempat, dalam <code>IS NOT NULL</code> <code>IS NULL</code> dan <code>IS NOT NULL</code> .  Karena nilai NULL tidak diketahui menurut definisi, Anda tidak dapat memiliki operator yang dirancang untuk itu.  Jadi ada <code>IS NULL</code> dan <code>IS NOT NULL</code> bukannya <code>= NULL</code> dan <code>!= NULL</code> .  Dan setiap perbandingan nilai NULL mengarah ke tampilan nilai NULL baru. <br><br>  Jika ini terdengar aneh bagi Anda, akan jauh lebih mudah jika Anda menulis "tidak dikenal" daripada NULL: <br><br><blockquote>  Membandingkan nilai-nilai <s>NULL yang</s> tidak diketahui menghasilkan nilai-nilai <s>NULL yang</s> tidak diketahui. </blockquote><br>  Ya, sekarang saya mengerti! <br><br><h2>  Apa yang dimaksud dengan nilai nol? </h2><br>  Berbekal remah-remah teori, kami mempertimbangkan konsekuensi praktisnya. <br><br>  Anda perlu membayar bonus $ 500 untuk semua karyawan yang gajinya untuk tahun ini berjumlah lebih dari $ 50 ribu. Anda menulis kode ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_number, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> salary &gt; <span class="hljs-number"><span class="hljs-number">50000</span></span>;</code> </pre> <br>  Dan Anda baru saja dipecat, karena bos Anda menghasilkan lebih dari $ 50 ribu, tetapi gajinya tidak ada di basis data (di kolom <code>employees.salary</code> Kolom NULL adalah NULL), dan operator pembanding tidak dapat membandingkan NULL dengan 50.000. <br><br>  Mengapa ada NULL di kolom ini?  Mungkin gaji itu rahasia.  Mungkin informasinya belum tiba.  Mungkin ini konsultan dan tidak dibayar.  Mungkin dia memiliki upah per jam, bukan gaji.  Ada <i>banyak</i> alasan mengapa data mungkin hilang. <br><br>  Ada atau tidaknya informasi dalam kolom menunjukkan bahwa itu tergantung pada sesuatu yang <i>lain</i> , dan bukan pada denormalisasi kunci utama dan basis data.  Dengan demikian, kolom di mana mungkin ada nilai NULL adalah kandidat yang baik untuk membuat tabel baru.  Dalam hal ini, Anda mungkin memiliki tabel <code></code> , <code></code> <code>_</code> , <code>__</code> , dll. Anda masih dipecat karena menggabungkan gaji secara membabi buta dan atasan Anda tidak memilikinya.  Tetapi kemudian pangkalan Anda mulai memberi Anda informasi yang cukup untuk menyarankan bahwa masalahnya lebih dari sekadar masalah gaji. <br><br>  Dan ya, itu adalah contoh yang bodoh, tapi itu yang terakhir. <br><br><h2>  Nilai NULL mengarah pada situasi yang secara logis tidak mungkin </h2><br>  Tampaknya bagi Anda bahwa saya bertele-tele sehubungan dengan nilai-nilai NULL.  Namun, mari kita lihat contoh lain yang jauh lebih dekat dengan kenyataan. <br><br>  Beberapa tahun yang lalu, saya bekerja di London untuk pendaftar domain dan mencoba memahami mengapa kueri SQL 80-baris mengembalikan data yang salah.  Dalam situasi itu, informasi pasti dikembalikan, tetapi ini tidak terjadi.  Saya malu untuk mengakuinya, tetapi saya butuh waktu sehari untuk memahami bahwa alasannya adalah kombinasi dari beberapa kondisi: <br><br><ul><li>  Saya menggunakan OUTER JOIN. <br></li><li>  Mereka dapat dengan mudah menghasilkan nilai NULL. <br></li><li>  Nilai NULL dapat menyebabkan SQL memberikan jawaban yang salah. <br></li></ul><br>  Banyak pengembang tidak menyadari aspek yang terakhir, jadi mari kita lihat contoh dari buku <a href="https://www.amazon.com/Database-Depth-Relational-Theory-Practitioners/dp/0596100124/">Database In Depth</a> .  Diagram sederhana dari dua tabel: <br><br> <code>suppliers</code> <br> <div class="scrollable-table"><table><tbody><tr><td>  supplier_id <br></td><td>  kota <br></td></tr><tr><td>  s1 <br></td><td>  London <br></td></tr></tbody></table></div><br> <code>parts</code> <br> <br><div class="scrollable-table"><table><tbody><tr><td>  part_id <br></td><td>  kota <br></td></tr><tr><td>  p1 <br></td><td>  Tidak <br></td></tr></tbody></table></div><br>  Sulit untuk menemukan contoh yang lebih sederhana. <br><br>  Kode ini mengembalikan <code>p1</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts;</code> </pre> <br>  Apa yang akan dilakukan kode ini? <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> city = city;</code> </pre> <br>  Ini tidak akan mengembalikan apa pun, karena Anda tidak dapat membandingkan nilai NULL, bahkan dengan NULL lain atau NULL yang sama.  Itu terlihat aneh karena kota di setiap jalur harus sama, bahkan jika kita tidak mengetahuinya, kan?  Lalu apa yang akan mengembalikan kode berikut?  Cobalah untuk memahami ini sebelum membaca lebih lanjut. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s.supplier_id, p.part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> suppliers s, parts p <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.city &lt;&gt; s.city <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> p.city &lt;&gt; <span class="hljs-string"><span class="hljs-string">'Paris'</span></span>;</code> </pre> <br>  Kami tidak mendapatkan string sebagai tanggapan, karena kami tidak dapat membandingkan kota <code>NULL</code> ( <code>p.city</code> ), dan karena itu tidak ada cabang dari <code>WHERE</code> mengarah pada <code>true</code> . <br><br>  Namun, kita tahu bahwa kota yang tidak dikenal adalah Paris atau bukan Paris.  Jika Paris, maka kondisi pertama akan benar ( <code>&lt;&gt; 'London'</code> ).  Jika bukan Paris, maka kondisi kedua akan benar ( <code>&lt;&gt; 'Paris'</code> ).  Jadi, <code>WHERE</code> harus <code>true</code> , tetapi tidak, dan sebagai hasilnya, SQL menghasilkan hasil yang mustahil secara logis. <br><br>  Itu adalah bug yang saya temui di London.  Setiap kali Anda menulis SQL yang bisa menghasilkan atau mengandung nilai NULL, Anda berisiko mendapatkan hasil yang salah.  Ini jarang terjadi, tetapi sangat sulit untuk diidentifikasi. <br><br><h1>  Ringkasan </h1><br><ul><li>  Gunakan <code>__</code> alih-alih <code>CamelCase</code> . <br></li><li>  Nama tabel harus dalam bentuk jamak. <br></li><li>  Berikan nama yang diperluas untuk bidang dengan pengidentifikasi ( <code>item_id</code> bukan <code>id</code> ). <br></li><li>  Hindari nama kolom yang ambigu. <br></li><li>  Jika memungkinkan, beri nama kolom dengan kunci asing dengan cara yang sama dengan kolom yang mereka rujuk. <br></li><li>  Jika memungkinkan, tambahkan BUKAN NULL ke semua definisi kolom. <br></li><li>  Kapan pun memungkinkan, hindari menulis SQL yang dapat menghasilkan nilai NULL. <br></li></ul><br>  Meski tidak sempurna, panduan desain basis data ini akan membuat hidup Anda lebih mudah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484188/">https://habr.com/ru/post/id484188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484176/index.html">Menerapkan Template Status dalam Persatuan</a></li>
<li><a href="../id484178/index.html">Saklar Ethernet Cerdas untuk Planet Bumi</a></li>
<li><a href="../id484180/index.html">Rostelecom virtual PBX: apa dan bagaimana bisa dilakukan melalui API</a></li>
<li><a href="../id484182/index.html">Xenobots: nanorobots hidup dari sel katak</a></li>
<li><a href="../id484186/index.html">LDAP - "otentikasi" adalah antipattern</a></li>
<li><a href="../id484192/index.html">Mudah dan mudah untuk menerapkan aplikasi pada Tarantool Cartridge (bagian 2)</a></li>
<li><a href="../id484194/index.html">Kubernet diterjemahkan menjadi anak-anak</a></li>
<li><a href="../id484196/index.html">Merekam suara JS dari mikrofon atau komentar suara</a></li>
<li><a href="../id484198/index.html">Sisi sebaliknya dari koin: siapa yang menang dan kalah pada pertumbuhan saham Tesla</a></li>
<li><a href="../id484200/index.html">Cara menetapkan tujuan untuk mencapainya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>