<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞ üö£üèº ‚öõÔ∏è O que fazer quando o processador n√£o tem nada para fazer? üë©üèæ‚Äçüè´ üôÖüèæ üë®üèΩ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seria razo√°vel supor que para o kernel seria muito f√°cil n√£o fazer nada - mas n√£o √©. Na confer√™ncia Kernel Recipes 2018 , Rafael Vysotsky falou sobre ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que fazer quando o processador n√£o tem nada para fazer?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427419/"><img src="https://habrastorage.org/getpro/habr/post_images/4d6/056/8ed/4d60568ede6023ffb669539747f5e46f.jpg" align="left">  Seria razo√°vel supor que para o kernel seria muito f√°cil n√£o fazer nada - mas n√£o √©.  Na confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kernel Recipes 2018</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rafael Vysotsky</a> falou sobre o que os processadores fazem, quando n√£o t√™m nada para fazer, como o kernel o processa, qual √© sua estrat√©gia atual e como seu trabalho recente no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ciclo inativo</a> melhorou a situa√ß√£o energ√©tica de sistemas que n√£o fazem nada. . <br><br>  O ciclo de inatividade, um dos subsistemas de kernel suportados pelo Vysotsky, controla o que a CPU faz quando n√£o precisa executar nenhum processo.  Vysotsky forneceu todas as defini√ß√µes com muita precis√£o: uma CPU √© uma entidade que pode receber instru√ß√µes da mem√≥ria e execut√°-las simultaneamente com outras entidades no mesmo sistema que lidam com a mesma coisa.  No sistema mais simples de processador √∫nico com um n√∫cleo, esse n√∫cleo √© a CPU.  Se o processador tiver v√°rios n√∫cleos, cada um deles ser√° uma CPU.  Se cada um dos n√∫cleos tiver v√°rias interfaces para executar instru√ß√µes simultaneamente - a Intel chama esse sistema de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hyperthreading</a> " -, cada um desses threads ser√° uma CPU. <br><a name="habracut"></a><br>  A CPU est√° ociosa quando n√£o possui tarefas a serem executadas.  Ou, mais precisamente, o kernel do Linux possui v√°rias classes internas para envio, uma das quais √© uma classe inativa especial.  Se n√£o houver tarefas nesta CPU em nenhuma das classes, exceto na classe de inatividade, a CPU ser√° considerada inativa.  Se o equipamento n√£o permitir isso, a CPU ter√° que executar instru√ß√µes in√∫teis at√© que o trabalho real aconte√ßa.  No entanto, esse √© um uso extremamente ineficiente de eletricidade, e √© por isso que a maioria dos processadores suporta v√°rios estados de baixa energia nos quais o n√∫cleo os transfere at√© que sejam necess√°rios para realizar um trabalho √∫til. <br><br>  Voc√™ n√£o pode simplesmente entrar ou sair de um estado de ina√ß√£o.  Leva tempo para entrar e sair e, al√©m disso, quando voc√™ entra nesse estado, o consumo de energia do estado atual aumenta um pouco e, quando voc√™ sai, consome o estado em que o processador entra.  E, quanto mais profundo o estado de inatividade, menos energia o processador consome, o custo de entrar e sair desses estados aumenta.  Isso significa que, no caso de curtos per√≠odos de inatividade, o melhor uso dos recursos do computador ser√° uma ina√ß√£o superficial;  por per√≠odos mais longos, o custo de mudan√ßa para um estado de ina√ß√£o mais profundo ser√° justificado por um aumento na quantidade de energia economizada.  Portanto, √© do interesse do kernel prever por quanto tempo o processador ficar√° ocioso antes de decidir a profundidade do estado de inatividade necess√°rio.  Essa √© a tarefa do ciclo de ina√ß√£o. <br><br>  Nesse ciclo, o planejador percebe que a CPU est√° ociosa, pois n√£o possui nenhuma tarefa que possa ser atribu√≠da a ela.  Em seguida, o planejador chama o regulador, que tenta fornecer a melhor previs√£o do estado de ina√ß√£o apropriado, no qual voc√™ pode inserir.  Agora no kernel existem dois controles, menu e escada.  Eles s√£o usados ‚Äã‚Äãem casos diferentes, mas ambos tentam fazer aproximadamente a mesma coisa: monitorar o estado do sistema quando a CPU entra em estado inativo e o tempo gasto em inatividade.  Isso √© feito para prever por quanto tempo a CPU entrar√° em um estado de inatividade e, portanto, qual o estado mais adequado para essa situa√ß√£o. <br><br>  Este trabalho √© especialmente complicado pelo timer do agendador da CPU.  O agendador inicia esse cron√¥metro para dividir o tempo de acesso √† CPU: se v√°rias tarefas precisam ser executadas em um processador, cada uma delas pode ser realizada apenas um pouco e, em seguida, adiada periodicamente em favor de outra tarefa.  Esse cron√¥metro n√£o precisa ser executado em uma CPU ociosa, pois n√£o h√° tarefas entre as quais a CPU precise ser dividida.  Al√©m disso, se o timer puder executar em uma CPU ociosa, isso impedir√° que o controlador selecione estados ociosos profundos, limitando os intervalos durante os quais a CPU est√° ociosa.  Portanto, em kernels at√© 4,16, o agendador desligou o timer antes de chamar o regulador.  Quando a CPU acordou com a interrup√ß√£o, o planejador decidiu se havia alguma tarefa necess√°ria para a execu√ß√£o e, se houver, reiniciou o cron√¥metro. <br><br>  Se o controlador predizer um longo per√≠odo de inatividade, e esse per√≠odo realmente for longo, o controlador "vencer√°": a CPU entra em um estado de profunda inatividade e a energia √© economizada.  Mas se o regulador prev√™ um longo per√≠odo de inatividade, e esse per√≠odo acaba sendo curto, ent√£o o regulador "perde", pois o custo de entrar em profunda ina√ß√£o n√£o compensa economizando energia por um curto per√≠odo de inatividade.  Pior ainda, quando o regulador prev√™ um curto tempo de inatividade, ele ‚Äúperde‚Äù independentemente do tempo de inatividade: se o per√≠odo acabou sendo longo, ele perdeu a oportunidade de economizar e, se curto, os custos de parar e reiniciar o temporizador foram desperdi√ßados.  Ou, em outras palavras, como os recursos s√£o gastos em parar e iniciar o cron√¥metro, n√£o faz sentido par√°-lo quando o controlador prev√™ um curto tempo de inatividade. <br><br>  Vysotsky decidiu tentar alterar a opera√ß√£o do regulador, mas chegou √† conclus√£o de que o principal problema √© que o temporizador √© parado antes que o regulador seja chamado, ou seja, antes que o estado de inatividade recomendado seja conhecido.  Ele retornou um ciclo inativo no kernel 4.17 para que a decis√£o de interromper o cron√¥metro fosse tomada depois que o regulador fez sua recomenda√ß√£o.  Se ele previu um longo tempo de inatividade, o temporizador para para n√£o ativar a CPU antes do tempo.  Se o tempo de inatividade for considerado curto, o cron√¥metro ser√° deixado para evitar o desperd√≠cio de recursos em desligamentos.  Isso significa que o temporizador tamb√©m desempenha uma fun√ß√£o de seguran√ßa, despertando a CPU, se o tempo de inatividade for mais longo do que o previsto, e dando ao regulador uma segunda chance para a decis√£o certa. <br><br>  Quando uma CPU inativa √© ativada por uma interrup√ß√£o, seja um cron√¥metro impar√°vel ou outro evento, o agendador toma uma decis√£o imediatamente sobre a disponibilidade do trabalho.  Se houver trabalho, o temporizador reinicia conforme necess√°rio.  Caso contr√°rio, o controlador √© chamado.  Como isso significa que agora o regulador pode ser chamado quando o temporizador est√° funcionando e quando n√£o est√° funcionando, o regulador deve ser chamado para levar isso em considera√ß√£o. <br><br>  Tendo estudado a tabela de vit√≥rias e derrotas, Vysotsky acredita que suas mudan√ßas melhorar√£o o cen√°rio.  No caso de prever um longo per√≠odo de inatividade, o temporizador ainda para, ent√£o nada muda aqui;  vencemos se o tempo de inatividade for longo e perdemos se for curto.  Mas se for previsto um curto per√≠odo de inatividade, vencemos: se o per√≠odo realmente for curto, economizaremos a interrup√ß√£o e o in√≠cio do cron√¥metro e, se for longo, um cron√¥metro ininterrupto nos acordar√° e nos dar√° a oportunidade de fazer outra previs√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/c12/2dc/989c122dcc3ec2c085e65f4e057c05a0.jpg"></div><br>  Como a teoria dos jogos n√£o pode servir como um substituto completo para a situa√ß√£o real, Vysotsky testou essa abordagem em muitos sistemas.  O gr√°fico acima √© t√≠pico para todos os sistemas testados;  mostra a depend√™ncia de tempo do consumo de energia em um sistema inativo.  A linha verde √© o antigo ciclo de ina√ß√£o, a linha vermelha √© a nova.  De acordo com o novo esquema, menos energia √© consumida e, al√©m disso, √© mais previs√≠vel.  Nem todas as CPUs testadas tiveram uma lacuna t√£o grande entre as linhas, no entanto, todas elas mostraram uma linha vermelha plana sob verde irregular.  Como Vysotsky disse, √© menos prov√°vel que esse novo esquema preveja curtos per√≠odos de inatividade, mas, com mais freq√º√™ncia, acaba sendo certo quanto √† sua curta dura√ß√£o. <br><br>  Respondendo a uma pergunta da plat√©ia, Vysotsky disse que este trabalho depende da arquitetura.  Em particular, os processadores da Intel se beneficiar√£o disso, uma vez que eles t√™m uma variedade bastante grande de estados de inatividade, dos quais o regulador pode escolher aquele que lhe dar√° a melhor chance de sucesso se a previs√£o estiver correta;  mas os processadores ARM tamb√©m se beneficiar√£o com o novo circuito. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/648/97d/331/64897d33160279143469c00ef7041157.png"></div><br>  Uma queda de 20% no consumo de energia quando ociosa pode parecer uma conquista insignificante, mas na verdade n√£o √©.  Qualquer sistema que queira lidar razoavelmente bem com as cargas de pico deve ter uma reserva de energia no modo normal, que se manifestar√° durante a inatividade.  O gr√°fico acima mostra o uso do processador durante o ano no meu servidor, que trata de correio, transfer√™ncia de arquivos, VPN, NTP, etc.  Amarelo significa tempo simples.  Economizar 20% dessa energia seria apreciado pelo meu provedor e, para o planeta, seria melhor. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427419/">https://habr.com/ru/post/pt427419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427407/index.html">Meta-agrupamento com minimiza√ß√£o de erros e por que acho que o c√©rebro funciona dessa maneira</a></li>
<li><a href="../pt427409/index.html">O livro "O brilhante √°gil. Gerenciamento flex√≠vel de projetos com Agile, Scrum e Kanban ¬ª</a></li>
<li><a href="../pt427413/index.html">Lutando por recursos, parte 4: √ìtimo</a></li>
<li><a href="../pt427415/index.html">Usamos o Node.js para trabalhar com arquivos grandes e conjuntos de dados brutos.</a></li>
<li><a href="../pt427417/index.html">Com humor, cerca de disquetes de 20 cm (nos anos 70 existiam apenas)</a></li>
<li><a href="../pt427421/index.html">Como os sites de genealogia facilitam a captura de assassinos</a></li>
<li><a href="../pt427423/index.html">City2Share: carros e- e aut√¥nomos nos centros log√≠sticos de Munique</a></li>
<li><a href="../pt427427/index.html">Como eles chegam √† TI: sobre estagi√°rios e vendedores (o resultado da pesquisa ‚ÄúMy Circle‚Äù)</a></li>
<li><a href="../pt427429/index.html">Estruturas da GUI - por thread</a></li>
<li><a href="../pt427431/index.html">Como o Android funciona, parte 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>