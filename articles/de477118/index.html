<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äç‚öñÔ∏è üë©üèø‚Äçüè≠ üí∫ MIRO ist eine offene Indoor-Roboterplattform. Teil 5 - Softwarekomponente: ARDUINO (AVR), wir klettern "unter der Haube" üò≥ üö∞ üî∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schauen wir uns diesmal die Implementierung einiger Schl√ºsselbibliotheksmethoden f√ºr ARDUINO (AVR) an, die f√ºr das Bewegen des MIRO-Roboters verantwor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIRO ist eine offene Indoor-Roboterplattform. Teil 5 - Softwarekomponente: ARDUINO (AVR), wir klettern "unter der Haube"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477118/"><img src="https://habrastorage.org/webt/m-/j7/gm/m-j7gmvwywlwzlopp5x-27y_jta.png" alt="Bild"><br><br>  Schauen wir uns diesmal die Implementierung einiger Schl√ºsselbibliotheksmethoden f√ºr ARDUINO (AVR) an, die f√ºr das Bewegen des MIRO-Roboters verantwortlich sind.  Dieser Teil wird f√ºr alle interessant sein, die sich fragen, wie die Linear- und Winkelgeschwindigkeit des Roboters auf der ARDUINO gesteuert werden kann, der mit Motoren mit den einfachsten Encodern ausgestattet ist. <br><a name="habracut"></a><br>  Inhaltsverzeichnis: <a href="https://habr.com/ru/post/472380/">Teil 1</a> , <a href="https://habr.com/ru/post/472802/">Teil 2</a> , <a href="https://habr.com/ru/post/473368/">Teil 3</a> , <a href="https://habr.com/ru/post/475512/">Teil 4</a> , <a href="https://habr.com/ru/post/477118/">Teil 5</a> . <br><br>  Die Methoden, die f√ºr das Fahren mit dem Kilometerz√§hler verantwortlich sind, sind immer noch ein Problem, wenn es darum geht zu erkl√§ren, wie, was und warum.  Das Erste, was Sie √ºber die Steuerung der Roboterbewegung wissen m√ºssen, ist die einfache und offensichtliche Tatsache, dass die Kollektormotoren des Roboters ohne zus√§tzliche Einstellung niemals mit der gleichen Geschwindigkeit rotieren.  Unterschiedliche Kupplung, unterschiedliche Leistungseigenschaften der Fahrerkan√§le, leicht unterschiedliche Elektromotoren und Schmierung im Getriebe. <br><br>  Die zweite Tatsache, die Sie verstehen und kennen sollten, ist das Vorhandensein von Tr√§gheit im Motor, selbst bei einer ausreichend gro√üen √úbersetzung.  Das hei√üt  Wenn die Spannung an den Motorklemmen unterbrochen wird, bewegt sich das Rad, auch wenn es nicht belastet ist, um einige Grad weiter.  Die Gr√∂√üe dieser zus√§tzlichen Drehung h√§ngt von der Belastungskraft auf das Rad, von der Drehzahl vor dem Abbau der Belastung und von denselben unsichtbaren Faktoren wie der Art und Menge des Schmiermittels im Getriebe ab. <br><br>  Diese Tatsachen bestimmen die Implementierung einer Gruppe von Methoden in Bezug auf die Bewegung eines Fahrgestells, das mit Kilometerz√§hlersensoren ausgestattet ist (im Fall von MIRO digitale Codierer f√ºr jedes Rad). <br><br>  Wie wir im vierten Teil herausgefunden haben, gibt es im Softwaremodell die <b>Chassis-</b> Klasse, die die Rotationssteuerung einzelner Chassis-Motoren implementiert.  Ich m√∂chte betonen - nicht die Steuerung der Bewegung des Fahrgestells, des Wagens, sondern die Steuerung der Motoren des Wagens.  Die direkte Steuerung des Wagens ist in den Klassen <b>Robot</b> und <b>Miro</b> implementiert. <br><br>  Fangen wir von oben an.  Im Folgenden sehen Sie eine Methode der <b>Miro-</b> Klasse, die die Bewegung eines Roboters um eine bestimmte Distanz ( <b>dist</b> , <b>meter</b> ) mit einer bestimmten linearen <b>Geschwindigkeit</b> ( <b>lin_speed</b> , m / s) und Winkelgeschwindigkeit ( <b>ang_speed</b> , deg / s) <b>implementiert</b> .  <b>Der</b> Parameter <b>en_break</b> wird <b>derzeit</b> noch nicht ber√ºcksichtigt. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Miro::moveDist(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lin_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ang_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> en_break) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAngSpeed[WHEEL_COUNT]; _wheelSetAngSpeed[LEFT] = MIRO_PI2ANG * (lin_speed - (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; _wheelSetAngSpeed[RIGHT] = MIRO_PI2ANG * (lin_speed + (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAng[WHEEL_COUNT]; _wheelSetAng[RIGHT] = _wheelSetAngSpeed[RIGHT] * dist / lin_speed; _wheelSetAng[LEFT] = _wheelSetAngSpeed[LEFT] * dist / lin_speed; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;chassis.wheelRotateAng(_wheelSetAngSpeed, _wheelSetAng, en_break); }</code> </pre> <br>  Bei dieser Methode werden zun√§chst die ERFORDERLICHEN Winkelgeschwindigkeiten f√ºr den linken und den rechten Motor berechnet.  Nach ziemlich offensichtlichen Formeln ist das kein Problem, abzuleiten.  Es ist lediglich zu beachten, dass die lineare Geschwindigkeit in der Methode in Metern pro Sekunde und die Winkelgeschwindigkeit in Grad pro Sekunde (nicht im Bogenma√ü) angegeben wird.  Daher berechnen wir die Konstante <b>MIRO_PI2ANG = 57,29 = 180 / pi vor.</b>  <b>ROBOT_DIAMETER</b> - Abstand zwischen dem linken und rechten Rad des Roboters (in Metern), <b>WHEEL_RADIUS</b> - Radius (auch in Metern).  Alle numerischen Konstanten f√ºr solche F√§lle sind in der Datei defs.h enthalten, und die benutzerdefinierten Parameter f√ºr Roboter und Chassis befinden sich in der Datei config.h. <br><br>  Danach wird der Winkel berechnet, um den jedes Rad gedreht werden muss, damit der Roboter die Distanz <b>dist</b> (auch in Metern) zur√ºcklegt. <br><br>  In diesem Stadium erhalten wir also, mit welcher Geschwindigkeit und in welchem ‚Äã‚ÄãWinkel Sie jedes Rad des Roboterchassis drehen m√ºssen.  Anschlie√üend wird die <b>wheelRotateAng ()</b> -Methode des <b>Geh√§useobjekts</b> aufgerufen. <br><br>  Die <b>wheelRotateAng-</b> Methode <b>(float * speed, float * ang, bool en_break)</b> wird verwendet, um die Roboterr√§der mit den Winkelgeschwindigkeiten, die vom <b>speed []</b> -Array (in m / s) angegeben werden, um die Winkel zu drehen, die vom <b>ang []</b> -Array (in Grad) angegeben werden.  Der letzte Parameter <b>en_break</b> (den wir bereits fr√ºher getroffen haben) legt die Anforderung f√ºr ein hartes Anhalten der R√§der nach einer <b>Kurvenfahrt</b> fest, indem eine kurzfristige R√ºckw√§rtsspannung an sie angelegt wird.  Dies ist erforderlich, um die Tr√§gheit des Roboters zu unterdr√ºcken und zu verhindern, dass er sich bereits nach dem Entfernen der Steuerspannung von den Motoren √ºber den erforderlichen Abstand hinaus bewegt.  Zur vollen Zufriedenheit gibt es nat√ºrlich die <b>wheelRotateAngRad ()</b> -Methode, die der <b>wheelRotateAng ()</b> -Methode √§hnelt, mit dem Unterschied, dass die Werte f√ºr Drehwinkel und Winkelgeschwindigkeiten im Bogenma√ü und im Bogenma√ü pro Sekunde als Parameter verwendet werden. <br><br>  Der Algorithmus der <b>wheelRotateAng ()</b> -Methode lautet wie folgt. <br><br>  1. Zun√§chst wird die √úbereinstimmung der Werte von <b>speed []</b> und <b>ang [] mit</b> einigen Randbedingungen √ºberpr√ºft.  Offensichtlich unterliegt das Fahrgestell physischen Einschr√§nkungen sowohl hinsichtlich der maximalen Winkeldrehgeschwindigkeit der R√§der als auch hinsichtlich der minimalen (minimalen Abfahrgeschwindigkeit).  Au√üerdem d√ºrfen die Winkel in <b>Ang []</b> nicht kleiner sein als der minimale feste Drehwinkel, der durch die Genauigkeit der Encoder bestimmt wird. <br><br>  2. Als n√§chstes wird die Drehrichtung jedes Rades berechnet.  Offensichtlich durch das Produktzeichen <b>ang [i] * speed [i]</b> ; <br><br>  3. Die "Rotationsdistanz" <b>Dw [i]</b> f√ºr jedes Rad wird berechnet - die Anzahl der Encoder-Abtastungen, die durchgef√ºhrt werden m√ºssen, um sich um den angegebenen <b>Ang [i]</b> zu drehen. <br>  Dieser Wert wird durch die Formel bestimmt: <br><br>  <b>Dw [i] = ang [i] * WHEEL_SEGMENTS / 360</b> , <br>  Dabei ist <b>WHEEL_SEGMENTS</b> die Anzahl der Segmente des <b>Encoderrads</b> (volle Umdrehung). <br><br>  4. Der Spannungswert am Motortreiber wird aufgezeichnet. <br><br><div class="spoiler">  <b class="spoiler_title">√úber die Spannung an Motoren</b> <div class="spoiler_text">  * <i>PWM wird zur Steuerung der Motordrehung verwendet. Um die an jeden Motor gelieferte Spannung zu ermitteln, muss die Versorgungsspannung des Motortreibers bekannt sein.</i>  <i>Im MIRO-Roboter ist der Fahrer direkt mit dem Batteriestromkreis verbunden.</i>  <i>Funktion float getVoltage ();</i>  <i>Gibt die Spannung von einem Spannungsteiler mit dem Faktor VOLTAGE_DIVIDER zur√ºck.</i>  <i>ADC-Referenzspannung: 5V.</i>  <i>Momentan ist der Wert von VOLTAGE_DIVIDER im Roboter 2 und die Spannung von einer Bank (1S) der Batterie wird an den ADC-Eingang (PIN_VBAT) angelegt.</i>  <i>Dies ist nicht ganz richtig, da sich die Batterieb√§nke auf unterschiedliche Weise entladen und das Gleichgewicht verlieren k√∂nnen. Wie die Praxis jedoch gezeigt hat, funktioniert die L√∂sung durchaus, wenn eine Batterie mit Ausgleich konstant geladen wird.</i>  <i>In Zukunft planen wir einen normalen Teiler mit zwei Dosen Batterie.</i> <br></div></div><br>  5. Gem√§√ü der Kalibrierungstabelle f√ºr jedes Rad wird der Anfangswert des PWM-Signals bestimmt, der die Drehung des Rads mit der erforderlichen <b>Geschwindigkeitsgeschwindigkeit [i]</b> sicherstellt.  Welche Art von Kalibriertabelle und woher kam sie - wir werden sie weiter analysieren. <br><br>  6. Die Drehung der Motoren wird gem√§√ü den berechneten Werten f√ºr Geschwindigkeit und Drehrichtung gestartet.  Im Text der Klassenimplementierung ist daf√ºr die private Methode <b>_wheel_rotate_sync ()</b> verantwortlich. <br><br>  Wir gehen noch tiefer.  Die <b>_wheel_rotate_sync ()</b> -Methode arbeitet nach dem folgenden Algorithmus: <br><br>  1. In einer Endlosschleife wird gepr√ºft, ob f√ºr jedes Rad der Z√§hler der Geberantworten f√ºr die <b>Umdrehungsentfernung Dw [i] erreicht wurde</b> .  Wenn einer der Z√§hler <b>Dw [i]</b> erreicht ist, stoppen alle R√§der und verlassen den Zyklus und verlassen dann die Funktion (Schritt 5).  Dies geschieht aus folgenden Gr√ºnden.  Aufgrund der Genauigkeit der Messung des Drehwinkels ist es eine sehr h√§ufige Situation, wenn der berechnete Abstand <b>Dw [i]</b> eines Rades erhalten wird, indem ein nicht ganzzahliger Wert auf eine kleinere Seite und <b>Dw [j] des</b> zweiten Rades auf eine gr√∂√üere Seite <b>gerundet werden</b> .  Dies f√ºhrt dazu, dass nach dem Anhalten eines der R√§der das zweite Rad weiter dreht.  Bei einem Fahrgestell mit Differentialantrieb (und vielen anderen) f√ºhrt dies zu einer ungeplanten "Drehung" des Roboters am Ende der Aufgabe.  Um die r√§umliche Bewegung des gesamten Fahrgestells zu organisieren, m√ºssen daher alle Motoren gleichzeitig gestoppt werden. <br><br>  2. Wird <b>Dw [i]</b> nicht erreicht, wird in der Schleife gepr√ºft, <b>ob</b> der Encoder die n√§chste Operation <b>ausf√ºhrt</b> (die Variable <b>_syncloop [w]</b> , die vom Encoder-Interrupt aktualisiert und in dieser Endlosschleife zur√ºckgesetzt wird).  Wenn die n√§chste Kreuzung auftritt, berechnet das Programm das Modul der aktuellen Winkelgeschwindigkeit jedes Rads (Grad / s) gem√§√ü der offensichtlichen Formel: <br><br>  <b>W [i] = (360 ¬∑ tau [i]) / WHEEL_SEGMENTS</b> , <br>  wo: <br>  <b>tau [i]</b> - der Durchschnittswert der Zeit zwischen den letzten beiden Antworten der Encoder.  Die "Tiefe" des Mittelungsfilters wird durch <b>MEAN_DEPTH bestimmt</b> und ist standardm√§√üig 8. <br><br>  3. Basierend auf den berechneten Raddrehzahlen werden die absoluten Fehler als Differenz zwischen der eingestellten und der tats√§chlichen Winkelgeschwindigkeit berechnet. <br><br>  4. Basierend auf den berechneten Fehlern wird die Steueraktion (PWM-Signalwert) f√ºr jeden Motor korrigiert. <br><br>  5. Nach Erreichen von <b>Dw [i] werden</b> die Motoren im Falle eines aktiven <b>Abschaltvorgangs</b> mit Kurzzeitumkehrspannung beaufschlagt.  Die Dauer dieses Effekts wird anhand der Kalibrierungstabelle (siehe unten) bestimmt und liegt normalerweise zwischen 15 und 40 ms. <br><br>  6. Die Motoren werden vollst√§ndig <b>entlastet</b> und <b>_wheel_rotate_sync () wird beendet</b> . <br><br>  Ich habe bereits zweimal eine bestimmte Kalibrierungstabelle erw√§hnt.  In der Bibliothek befindet sich daher eine spezielle Wertetabelle, die im EEPROM des Roboterspeichers gespeichert ist und Datens√§tze mit drei verwandten Werten enth√§lt: <br><br>  1. Spannung an den Motorklemmen.  Sie wird berechnet, indem der Wert des PWM-Signals in die tats√§chliche Spannung umgewandelt wird.  Hierzu wird in Schritt 4 der Methode <b>wheelRotateAng ()</b> die tats√§chliche Spannung am <b>Motorfahrer</b> erfasst. <br><br>  2. Die Winkelgeschwindigkeit des Rades (ohne Last), die einer gegebenen Spannung entspricht. <br><br>  3. Die Dauer des Hard-Stop-Signals, die dieser Winkelgeschwindigkeit entspricht. <br>  Standardm√§√üig betr√§gt die Gr√∂√üe der Kalibrierungstabelle 10 Datens√§tze (bestimmt durch die Konstante <b>WHEEL_TABLE_SIZE</b> in der Datei <b>config.h</b> ) - 10 Dreifache der Werte ‚ÄûSpannung - Winkelgeschwindigkeit - Dauer des Stoppsignals‚Äú. <br><br>  Um die Werte aus 2 und 3 Eintr√§gen in dieser Tabelle zu ermitteln, wird eine spezielle Methode verwendet - <b>wheelCalibrate (Byte Wheel)</b> . <br><br>  Schauen wir uns das etwas genauer an.  Diese Methode implementiert eine Folge von Aktionen, um die fehlenden Werte in der Motor / Rad-Kalibrierungstabelle zu ermitteln sowie die minimale Startwinkelgeschwindigkeit und die maximale Radwinkelgeschwindigkeit zu ermitteln. <br><br>  Zur Kalibrierung wird der Roboter auf einen St√§nder montiert, alle Raddrehungen w√§hrend der Kalibrierung werden ohne Last ausgef√ºhrt. <br><br>  1. Zuerst m√ºssen Sie die Mindeststartgeschwindigkeit bestimmen.  Das geht ganz einfach.  In einem Zyklus wird die Steuer-PWM ab 0 mit einem Inkrement von 1 dem Motor zugef√ºhrt. Bei jedem Schritt wartet das Programm eine gewisse Zeit, bestimmt durch die Konstante <b>WHEEL_TIME_MAX</b> (normale <b>Verz√∂gerung ()</b> ).  Nach Ablauf der Wartezeit wird gepr√ºft, ob der Start abgeschlossen ist (durch √Ñndern des Wertes des Geberz√§hlers).  Ist die Umlenkung beendet, wird die Winkelgeschwindigkeit des Rades berechnet.  Zur Erh√∂hung der Sicherheit wird zum Wert der PWM, die dieser Startgeschwindigkeit entspricht, der Wert 10 addiert, wodurch sich das erste Wertepaar "Spannung am Motor" - "Winkelgeschwindigkeit" ergibt. <br><br>  2. Nachdem die Startgeschwindigkeit ermittelt wurde, wird der PWM-Schritt berechnet, um die Kalibrierungstabelle gleichm√§√üig zu f√ºllen. <br><br>  3. Im Zyklus wird das Rad f√ºr jeden neuen PWM-Wert um 2 volle Umdrehungen gedreht und die Winkelgeschwindigkeit wird nach einem Algorithmus gemessen, der der <b>_wheel_rotate_sync ()</b> -Methode √§hnelt.  Im gleichen Zyklus wird auch durch sukzessive Approximation der optimale Wert der Dauer des Hard-Stop-Signals gemessen.  Zun√§chst wird offensichtlich gro√üer Wert darauf gelegt.  Und dann wird es im "Turn-Stop" -Modus getestet.  Als Optimum wird der Maximalwert der Stoppsignaldauer gew√§hlt, bei dem der eingestellte ‚ÄûAbbiegedistanz‚Äú nicht √ºberschritten wird.  Mit anderen Worten, ein solcher Wert der Signaldauer, bei dessen Zufuhr zum Motor einerseits die Tr√§gheit unterdr√ºckt wird, und andererseits keine kurzfristige R√ºckw√§rtsbewegung vorliegt (die vom selben Geber festgelegt wird). <br><br>  4. Nach Abschluss der Kalibrierung wird die Steuerspannung f√ºr den kalibrierten Motor nicht mehr angelegt und die Kalibrierungstabelle f√ºr dieses Rad wird im EEPROM aufgezeichnet. <br><br>  Ich habe alle m√∂glichen Kleinigkeiten der Umsetzung ausgelassen und versucht, das Wesentliche festzustellen.  M√∂glicherweise stellen Sie fest, dass die <b>Methoden wheelRotateAng ()</b> und <b>wheelRotateAngRad ()</b> Funktionen blockieren.  Dies ist der Preis f√ºr die Genauigkeit der Bewegung und eine relativ einfache Integration in Benutzerskizzen.  Es w√§re m√∂glich, einen kleinen Task-Manager mit festem Timing zu erstellen, dies w√ºrde jedoch erfordern, dass der Benutzer seine Funktionalit√§t streng in das zugewiesene Zeitkontingent einbettet. <br><br>  F√ºr eine nicht blockierende Anwendung verf√ºgt die API √ºber die Funktion <b>wheelRotate (float * speed)</b> .  Es f√ºhrt, wie aus der Parameterliste ersichtlich, einfach die Drehung der R√§der mit den eingestellten Drehzahlen durch.  Die Drehzahl wird in der <b>Sync ()</b> -Methode des Robotergeh√§uses angepasst, die in der <b>Sync ()</b> -Methode des gleichnamigen Miro-Klassenobjekts aufgerufen wird.  Entsprechend den Anforderungen an die Struktur der Benutzerskizze sollte diese Methode bei jeder Iteration der Hauptschleife <b>() der</b> ARDUINO-Skizze aufgerufen werden. <br><br>  In Schritt 4 habe ich in der Beschreibung der <b>_wheel_rotate_sync () -</b> Methode die "Steuerkorrektur" des Motors erw√§hnt.  Wie haben Sie es erraten?  Dies ist der PID-Regler.  Nun, genauer gesagt PD-Controller.  Wie Sie wissen (in der Tat - nicht immer), ist der beste Weg, die Koeffizienten des Reglers zu bestimmen, die Auswahl.  In der Konfigurationsdatei config.h gibt es eine Definition: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEBUG_WHEEL_PID</span></span></code> </pre><br>  Wenn Sie es <b>auskommentieren</b> , wird beim Aufrufen der <b>moveDist ()</b> -Methode der Miro-Klasse das folgende invertierte Diagramm des relativen Fehlers bei der Steuerung der Winkelgeschwindigkeit eines der Roboterr√§der (links) in der Roboterkonsole angezeigt. <br><br> <a href=""><img src="https://habrastorage.org/webt/_v/4i/hr/_v4ihrxfnzpq-fvnofq_3kjkcz0.png"></a> <br><br>  Hat nichts √§hnliches)?  Nach unten ist die Zeit (jeder Balken ist ein Schritt des Regelzyklus) und der Fehlerwert wird rechts gespeichert (wobei das Vorzeichen erhalten bleibt).  Hier sind zwei Paare von Graphen auf der gleichen Skala mit unterschiedlichen Koeffizienten des PD-Controllers.  "Buckel" sind nur die "Wellen" des √úberschie√üens.  Die Zahlen auf den horizontalen Balken sind ein relativer Fehler (unter Beibehaltung des Vorzeichens).  Einfache Visualisierung des Reglers zur manuellen Anpassung der Koeffizienten.  Im Laufe der Zeit hoffe ich, ein automatisches Setup durchzuf√ºhren, aber f√ºrs Erste. <br><br>  Hier ist so ein Adok :-) <br><br>  Schauen wir uns zum Schluss ein Beispiel an.  Direkt aus der API_Miro_moveDist-Bibliothek: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Miro.h&gt; using namespace miro; byte PWM_pins[2] = { 5, 6 }; byte DIR_pins[2] = { 4, 7 }; byte ENCODER_pins[2] = { 2, 3 }; Miro robot(PWM_pins, DIR_pins, ENCODER_pins); int laps = 0; void setup() { Serial.begin(115200); } void loop() { for (unsigned char i = 0; i &lt; 4; i++) { robot.moveDist(robot.getOptLinSpeed(), 0, 1, true); delay(500); robot.rotateAng(0.5*robot.getOptAngSpeed(), -90, true); delay(500); } Serial.print("Laps: "); Serial.println(laps); laps++; }</span></span></span></span></code> </pre><br>  Aus dem Programmtext sollte alles klar sein.  Wie es funktioniert - im Video. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Bd96kgY2YsY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  600 x 600 mm Fliesen und 5 mm Fliesenabst√§nde.  Theoretisch sollte der Roboter ein Quadrat mit einer Seitenl√§nge von 1 Meter umrunden.  Nat√ºrlich ‚Äûschwebt‚Äú die Flugbahn davon.  Aus Gr√ºnden der Fairness ist es jedoch erw√§hnenswert, dass es in der Version des Roboters, die ich zu Testzwecken verlassen habe, ziemlich drehende Motoren gibt, die nur schwer langsam zu fahren sind.  Aber bei hoher Geschwindigkeit und Schlupf gibt es einen Ort, an dem man sein kann, und Tr√§gheit ist nicht einfach zu bew√§ltigen.  Motoren mit einer h√∂heren Getriebe√ºbersetzung (wie sie auch bei unseren MIRO-Robotern nur w√§hrend des Tests nicht zur Verf√ºgung standen) sollten sich etwas besser verhalten. <br><br>  Wenn es unverst√§ndliche Momente gibt, kl√§re, diskutiere und verbessere ich diese gerne.  Feedback ist generell interessant. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477118/">https://habr.com/ru/post/de477118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477098/index.html">Wir k√ºmmern uns um die Video√ºbertragung in 4K-Aufl√∂sung bei 60 Hz √ºber einen USB-C-Hub</a></li>
<li><a href="../de477100/index.html">Technischer Marathon von Microsoft Dynamics 365</a></li>
<li><a href="../de477104/index.html">KI-unterst√ºtztes IntelliSense f√ºr die Codebasis Ihres Teams</a></li>
<li><a href="../de477110/index.html">Unterhaltsame Planung</a></li>
<li><a href="../de477114/index.html">Implementierung des MSH-Interpreters</a></li>
<li><a href="../de477120/index.html">Kontinuierliche Blutzuckermesssoftware f√ºr Windows</a></li>
<li><a href="../de477122/index.html">Das Gehirn der Firma. Teil 3</a></li>
<li><a href="../de477124/index.html">Bitcoin im K√§fig?</a></li>
<li><a href="../de477126/index.html">Admin in 5 Minuten. Frontend - React-Admin, Backend - Flask-RESTful</a></li>
<li><a href="../de477128/index.html">Habra Detektiv am Wochenende</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>