<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçò üõåüèΩ üßì Einf√ºhrung von werf 1.0 stable: Was hat GitOps damit zu tun, Status und Pl√§ne üë©üèæ‚Äç‚úàÔ∏è üëéüèø ü•õ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="werf ist ein Open-Source- GitOps-CLI-Dienstprogramm zum Erstellen und Bereitstellen von Anwendungen f√ºr Kubernetes. werf unterst√ºtzt das Zusammenstell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung von werf 1.0 stable: Was hat GitOps damit zu tun, Status und Pl√§ne</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/481306/"><img src="https://habrastorage.org/webt/3x/gd/dm/3xgddmaqs9o_1evxjgalmlsczzo.png"><br><br>  <a href="https://werf.io/">werf</a> ist ein <a href="https://github.com/flant/werf">Open-Source-</a> GitOps-CLI-Dienstprogramm zum Erstellen und Bereitstellen von Anwendungen f√ºr Kubernetes.  werf unterst√ºtzt das Zusammenstellen von Anwendungsimages mit Dockerfile oder einem eigenen integrierten Collector (basierend auf YAML-Syntax, mit Ansible-Unterst√ºtzung und inkrementellem Neuaufbau basierend auf Git).  Helm-kompatibles Konfigurationsformat wird verwendet, um die Anwendung bereitzustellen.  Der Anwendungscode, die Konfiguration der gesammelten Bilder und die Rollout-Konfiguration der Anwendung werden in einem Git-Repository gespeichert. <br><br>  Die lang erwartete <a href="">stabile Version 1.0</a> ist die Basisversion des Dienstprogramms, das durch Funktionen vervollst√§ndigt wird <i>(die genaue Versionsnummer der ersten stabilen Version ist 1.0.6)</i> .  In der Basisversion unterst√ºtzt werf den gesamten Zyklus der Anwendungsbereitstellung und -wartung.  Dies umfasst das Zusammenstellen von Anwendungsimages, das Bereitstellen auf Kubernetes und das Bereinigen nicht verwendeter Images. <a name="habracut"></a><br><br>  Es ist wichtig, dass in Version 1.0 alle Vorg√§nge an einem Projekt ( <code>build</code> , <code>deploy</code> , <code>cleanup</code> ) von einem Host aus ausgef√ºhrt werden.  Dies bedeutet, dass ein fester Mitarbeiter im CI-System verwendet werden muss.  Gleichzeitig gibt es keine Einschr√§nkungen hinsichtlich der Parallelit√§t von Aufgaben: Werf l√∂st dieses Problem vollst√§ndig.  Sie k√∂nnen auch verschiedene Projekte auf verschiedene Mitarbeiter verteilen. <br><br>  In diesem Artikel, der sich mit der Ver√∂ffentlichung befasst, werden wir uns n√§her mit dem befassen, was diese Version bietet und was nicht, sowie mit unseren Pl√§nen f√ºr zuk√ºnftige Versionen.  Beginnen wir jedoch mit dem Verst√§ndnis des Begriffs ‚ÄûGitOps‚Äú und der Rolle von werf in den Prozessen der kontinuierlichen Integration und Anwendungsbereitstellung (CI / CD). <br><br><h2>  Warum werf ist GitOps </h2><br>  Was verstehen wir unter GitOps und welche Bereiche deckt werf ab? <br><br>  Der Begriff ‚ÄûGitOps‚Äú wurde vor etwa 2,5 Jahren von Weaveworks gepr√§gt, und wir haben k√ºrzlich einen Artikel seiner Autoren √ºbersetzt, der die Essenz dieses neuen Ph√§nomens f√ºr den Blog enth√ºllt.  Nach unserem Verst√§ndnis ist die Hauptidee und Hauptbedeutung von GitOps, dass <b>Git eine ‚Äûeinzige Quelle der Wahrheit‚Äú ist</b> .  Git speichert: <br><br><ul><li>  Anwendungscode </li><li>  alle Abh√§ngigkeiten; </li><li>  Informationen zum Sammeln von Containern; </li><li>  Informationen zur Bereitstellung auf Kubernetes; </li><li>  usw. </li></ul><br>  Und dann gibt es etwas, das die <b>Realit√§t mit den Git-√Ñnderungen in Einklang</b> bringt.  Dieser Ansatz kann nicht nur implementiert werden, indem ein Operator in Kubernetes installiert wird, der Git √ºberwacht, sondern auch ein Konsolendienstprogramm verwendet, das von jedem CI-System aus aufgerufen werden kann.  Aus unserer Sicht ist der Ansatz mit dem CLI-Dienstprogramm au√üerdem nicht mit unn√∂tigen Einschr√§nkungen verbunden: Wir k√∂nnen CI mit jedem Tool und mit einer beliebigen Anzahl von Nuancen ausf√ºhren, indem wir ein CLI-Dienstprogramm aufrufen, das die ‚ÄûRealit√§t‚Äú (dh Kubernetes) mit dem Status von Git synchronisiert . <br><br>  werf bietet eine √ºbergeordnete CLI-Oberfl√§che mit grundlegenden Befehlen zum <code>werf build-and-publish</code> und Ver√∂ffentlichen von Abbildern, Bereitstellen von Anwendungen und Bereinigen von Abbildern: <code>werf build-and-publish</code> , <code>werf deploy</code> , <code>werf dismiss</code> , <code>werf cleanup</code> .  Es wird davon ausgegangen, dass diese grundlegenden Befehle in ein bestimmtes CI-System eingebettet sind und die erforderliche Synchronisation mit der Realit√§t erm√∂glichen.  Dar√ºber hinaus bietet werf eine CLI-Oberfl√§che auf niedriger Ebene f√ºr die Verwaltung verschiedener Subsysteme - siehe die <a href="https://ru.werf.io/documentation/cli/management/stages/build.html">Verwaltungsbefehle auf niedriger Ebene</a> in der Dokumentation. <br><br>  Es spielt keine Rolle, ob das eingebaute CI / die eingebaute CD nach dem Push- oder Pull-Modell funktioniert <i>(lesen Sie mehr dar√ºber <a href="https://habr.com/ru/company/flant/blog/456754/">hier</a> )</i> , da <b>werf in jedes Modell eingebaut werden kann</b> .  Gleichzeitig schlie√üt werf Probleme wie die Arbeit mit separaten Low-Level-Dienstprogrammen wie <code>git</code> , docker und kubernetes api-server, die der ‚Äûfehlende Teil‚Äú f√ºr die Konfiguration einer einheitlichen CI / CD-Anwendung sind. <br><br><h2>  Was ist werf 1.0 stabil </h2><br><h3>  1. Montage, Ver√∂ffentlichung und Reinigung von Bildern </h3><br>  Wenn Ihre Anwendung das Erstellen von Docker-Images erfordert, k√∂nnen Sie mit werf 1.0: <br><br><ul><li>  Beschreiben Sie die Regeln zum Zusammenstellen von Images (Sie k√∂nnen mehrere haben) in einer einzigen <code>werf.yaml</code> Konfiguration. </li><li>  Sammeln Sie Bilder und ver√∂ffentlichen Sie sie in der Docker-Registrierung </li><li>  Reinigen Sie die Docker-Registrierung regelm√§√üig f√ºr benutzerdefinierte Richtlinien. </li></ul><br>  werf unterst√ºtzt <b>zwei M√∂glichkeiten, die Assembly zu beschreiben</b> : Verbinden von <code>werf.yaml</code> <b>vorhandenen Docker-Dateien</b> und Anweisungen f√ºr <b>den Stapel-Collector</b> .  Das Bauen mit Stapel hat seine Vorteile: Eine schnellere inkrementelle Neuerstellung, wenn der Anwendungscode in Git ge√§ndert wird, Ansible-Syntax f√ºr Assemblierungen verwendet wird und andere.  Weitere Informationen zu diesem Kollektor und zur Syntax finden Sie <a href="https://ru.werf.io/documentation/reference/build_process.html">in der Dokumentation</a> . Ein Beispiel f√ºr seine Verwendung finden Sie im <a href="https://ru.werf.io/documentation/guides/advanced_build/first_application.html">Handbuch</a> . <br><br>  In Bezug auf Git-Commits, -Zweige und -Tags stehen verschiedene Schemata zum Taggen / Versionswechsel von gesammelten Bildern zur Verf√ºgung. <br><br>  Das Zusammenstellen von Images ist eine optionale Phase der Anwendungsbereitstellung und kann √ºbersprungen werden, wenn keine eigenen zusammengestellten Images vorhanden sind. <br><br><h3>  2. Stage Storage auf nur einem Host </h3><br>  werf f√ºhrt das konzept der stufenspeicherung ein.  Die wichtigsten werf-Befehle verwenden den Stufenspeicher wie folgt: <br><br><ul><li>  Montageergebnisse speichern - Docker-Bilder im Stage Store </li><li>  Verwenden Sie Bilder aus dem Stage Store als Cache zum Wiederherstellen und Zusammenstellen neuer Bilder. </li><li>  Verwenden Sie das Repository, um Informationen zu den gesammelten Bildern f√ºr deren weitere Verwendung abzurufen (z. B. bei der √úbermittlung einer Anwendung an Kubernetes). </li></ul><br>  Bei der Bereitstellung einer einzelnen Anwendung sollte f√ºr alle Teams ein einstufiger Speicher verwendet werden (Zusammenstellung, Ver√∂ffentlichung, Image-Bereinigung, Anwendungsbereitstellung). <br><br>  In Version 1.0 kann nur der lokale <code>--stages-storage=:local</code> fungieren (der entsprechende Parameter f√ºr die Befehle lautet: <code>--stages-storage=:local</code> ).  Bei Verwendung von <code>:local</code> Abschnitte auf der Festplatte gespeichert.  Die Folge davon: <b>Werf 1.0</b> kann nur <b>auf einem Host verwendet werden,</b> um die Bereitstellung einer <b>einzelnen Anwendung</b> <b>zu</b> organisieren.  Dieser Host muss zwischen den Befehlsstarts Daten speichern, damit werf ordnungsgem√§√ü funktioniert. <br><br>  In Version 1.0 gibt es keine Unterst√ºtzung f√ºr das Speichern von Phasen in einem externen Speicher, mit denen Sie eine verteilte Assembly organisieren k√∂nnten.  Eine solche Funktion wird jedoch in zuk√ºnftigen Versionen von werf erscheinen <i>(siehe unten f√ºr weitere Details)</i> . <br><br><h3>  3. Stellen Sie die Anwendung bereit und √ºberpr√ºfen Sie die Verf√ºgbarkeit </h3><br>  Um die Anwendung einzuf√ºhren, beschreibt der Benutzer das Diagramm in einem mit Helm kompatiblen Format: eine Reihe von Kubernetes-Manifesten und Vorlagenparametern. <br><br>  werf startet die Anwendung in Kubernetes und stellt sicher, dass sie gestartet wird und funktioniert, bevor der Rollout-Vorgang f√ºr die Anwendung abgeschlossen ist.  Dies umfasst die Ausgabe von Komponentenprotokollen und die sofortige Reaktion auf Rollout-Fehler, wenn ein Fehler aufgetreten ist. Der Rollout-Befehl wird mit einem Code ungleich Null gel√∂scht.  Wenn <b>wir also das</b> werf-Rollout in CI / CD verwenden, erhalten <b>wir ein angemessenes Feedback von der Software</b> : Die Anwendung wird heruntergeladen oder nicht, und es gibt gen√ºgend Informationen, um Probleme zu debuggen und zu beheben (ohne andere Dienstprogramme ausf√ºhren zu m√ºssen, um Probleme wie <code>kubectl</code> zu finden). <br><br>  werf ist voll kompatibel mit bestehenden Helm 2 Installationen, aber werf hat mehrere Vorteile gegen√ºber.  Als Mechanismus zum Aktualisieren von Ressourcen verwendet Kubernetes beispielsweise <a href="https://ru.werf.io/documentation/reference/deploy_process/resources_update_methods_and_adoption.html">Patches zum Zusammenf√ºhren in drei Richtungen.</a> Au√üerdem besteht die M√∂glichkeit, Feedback zu erhalten, wenn die Anwendung an den Cluster √ºbermittelt wird.  Eine vollst√§ndige Liste der Unterschiede finden Sie auf <a href="https://ru.werf.io/documentation/reference/deploy_process/differences_with_helm.html">dieser Seite</a> . <br><br><h3>  4. Die Beziehung der gesammelten Bilder zum √úbermittlungsprozess der Anwendung </h3><br>  werf integriert die gesammelten Bilder in ein einziges System, markiert und versioniert sie und liefert die Anwendung an Kubernetes.  Bilder, die werf sammelt, k√∂nnen in Ressourcenbeschreibungsvorlagen von Kubernetes verwendet werden. <br><br>  Aufgrund dieser Funktionen k√∂nnen wir sagen, dass <b>werf eine √ºbergeordnete Schnittstelle</b> als Helm, Docker und andere Builder und Dienstprogramme f√ºr die separate Bereitstellung <b>bietet</b> .  Diese Schnittstelle erm√∂glicht es Ihnen, werf einfach in ein bestehendes CI / CD-System zu integrieren und nicht die Probleme zu l√∂sen, alle verwendeten Komponenten zu kombinieren - er √ºbernimmt diese Aufgabe. <br><br><h3>  5. Integration in vorhandene CI / CD-Systeme </h3><br>  In Version 1.0 ist die automatische Integration nur mit <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/gitlab_ci.html">dem GitLab CI-System</a> verf√ºgbar.  Dazu wird der <code>werf ci-env</code> bereitgestellt.  Es empf√§ngt die erforderlichen Informationen vom CI / CD-System und konfiguriert werf automatisch so, dass es in der CI-Umgebung ordnungsgem√§√ü funktioniert. <br><br>  Weitere Informationen zur Integration in ein CI / CD-System finden Sie in den Handb√ºchern ( <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/overview.html">√úbersicht</a> , <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/gitlab_ci.html">GitLab CI-Besonderheiten</a> , <a href="https://ru.werf.io/documentation/guides/unsupported_ci_cd_integration.html">Integration in andere Systeme</a> ). <br><br><h3>  6. Plattform√ºbergreifende Entwicklung f√ºr Linux, Windows und macOS </h3><br>  werf 1.0 ist eine statisch verkn√ºpfte Bin√§rdatei, die unabh√§ngig von Docker- und Helm-Versionen funktioniert.  Externe Abh√§ngigkeiten vom Hostsystem: <br><br><ul><li>  Lokaler Docker-Daemon </li><li>  Git-Dienstprogramm. </li></ul><br>  werf kann auf allen Betriebssystemen und Umgebungen von GNU / Linux, Windows oder macOS ausgef√ºhrt werden.  Dar√ºber hinaus ist das Ergebnis der Assemblierung unabh√§ngig vom verwendeten System dasselbe: Dieselbe Signatur der Cachestufen, dieselbe F√ºllung der Stufen, unabh√§ngig davon, auf welchem ‚Äã‚ÄãSystem diese Stufe erfasst wurde.  √Ñnderungen in der Konfiguration f√ºr die Arbeit in verschiedenen Systemen sind ebenfalls nicht erforderlich. <br><br>  Daher bietet werf 1.0 plattform√ºbergreifende Tools zum Erstellen und Bereitstellen von Anwendungen f√ºr Kubernetes. <br><br>  Hier ist auch zu beachten, dass werf Standard-Docker-Images f√ºr die Arbeit in einer Linux-Umgebung sammelt, <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/">Windows-Container</a> in Version 1.0 <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/">jedoch</a> nicht unterst√ºtzt werden. <br><br><h3>  7. Funktionalit√§t mit Tests abdecken </h3><br>  Derzeit werden 60% des werf-Codes durch Integrationstests und Unit-Tests abgedeckt. <br><br>  werf wird auf allen unterst√ºtzten Betriebssystemen (Linux, Windows und macOS) mit GitHub Actions getestet, um den Start zu organisieren.  Einige Details zu den Tests finden Sie auch unter <a href="https://codeclimate.com/github/flant/werf">Code Climate</a> . <br><br><h3>  8. Versionierung werf </h3><br>  Zum Zeitpunkt der Ver√∂ffentlichung von Version 1.0 wurden im Projekt <a href="https://github.com/flant/werf/releases">ungef√§hr 700 Ver√∂ffentlichungen</a> vorgenommen. <br><br>  werf nutzt ein erweitertes release-system mit stabilit√§tskan√§len: <i>alpha</i> , <i>beta</i> , <i>ea (early access)</i> , <i>stable</i> und <i>rock-solid</i> .  Dieser Beitrag f√§llt zeitlich mit der Ver√∂ffentlichung der ersten Version 1.0 im <i>Stable-</i> Channel zusammen.  Instabile √Ñnderungen an der Version durchlaufen zun√§chst eine Kette von Kan√§len und enden schlie√ülich in einem sehr <i>soliden Zustand</i> .  Releases werden oft gemacht (manchmal mehrere pro Tag) und √Ñnderungen werden kontinuierlich in "kleinen Portionen" geliefert. <br><br>  Stabilit√§tskan√§le und viele h√§ufige Releases erm√∂glichen Ihnen ein kontinuierliches Feedback zu neuen √Ñnderungen, die M√∂glichkeit, diese schnell zur√ºckzusetzen und generell eine hohe Stabilit√§t der Software bei gleichzeitig akzeptabler Entwicklungsgeschwindigkeit sicherzustellen. <br><br>  Der wichtige Punkt ist, dass beim Wechsel zwischen den Versionen 1.0-&gt; 1.1, 1.1-&gt; 1.2 √Ñnderungen an werf m√∂glich sind, die einen manuellen Eingriff des Benutzers erfordern (dies kann ein Migrationsskript sein oder nur Anweisungen f√ºr die manuelle Ausf√ºhrung, die in der Version beschrieben werden).  Durch die Aktualisierung der Versionen in 1.0 (1.0.1, 1.0.2, ... 1.0.6-alpha.1, 1.0.6-beta.2 usw.) wird sichergestellt, dass solche manuellen √Ñnderungen nicht erforderlich sind. <br><br>  Weitere Informationen zum Versprechen der Abw√§rtskompatibilit√§t finden Sie <a href="https://github.com/flant/werf">hier</a> . <br><br><h2>  Weitere Pl√§ne </h2><br>  Hier sind die wichtigsten Arbeitsbereiche f√ºr zuk√ºnftige Versionen und ungef√§hre Bedingungen f√ºr deren Implementierung: <br><br><h3>  1. Lokale Entwicklung und Bereitstellung von Anwendungen mit werf </h3><br>  Das Hauptziel besteht darin, eine einzige einheitliche Konfiguration f√ºr die sofortige Bereitstellung von Anwendungen sowohl lokal als auch in der Produktion ohne komplexe Aktionen zu erstellen. <br><br>  Werf ben√∂tigt auch eine Betriebsart, in der es bequem ist, den Anwendungscode zu bearbeiten und sofort Feedback von einer funktionierenden Anwendung zum Debuggen zu erhalten. <br><br>  <i>Version 1.1, Januar-Februar 2020</i> <br><br><h3>  2. Inhaltsbasiertes Tagging </h3><br>  Kennzeichnen von Bildern, wenn sie ver√∂ffentlicht werden, ausschlie√ülich basierend auf dem Inhalt dieses Bildes.  Im Gegensatz zu Modi mit Bindung an Git-Commits werden in diesem Modus unn√∂tige Neuerstellungen vollst√§ndig beseitigt.  Git-commit-id ist kein universeller Bezeichner f√ºr Arbeitsbauminhalte (obwohl es davon abh√§ngt). <br><br>  In dem Fall, dass der Anwendungscode nicht ge√§ndert wurde, aber ein neues Commit durchgef√ºhrt wurde, erstellt der aktuelle Tag-Modus f√ºr Git-Commits ein Bild mit einem neuen Namen, wenn es ver√∂ffentlicht wird.  Dies f√ºhrt auch zu einem Ressourcen-Rollback, wenn dieses Image in Kubernetes verwendet wird.  Gleichzeitig hat sich der Inhalt des Bildes selbst nicht ver√§ndert. <br><br>  Um diese Probleme zu l√∂sen, wird werf eine neue Art der Kennzeichnung einf√ºhren, die auf Berechnungen der Pr√ºfsummen des Anwendungsinhalts <b>basiert</b> - die <b>inhaltsbasierte Kennzeichnung</b> . <br><br>  <i>Version 1.1, Februar-M√§rz 2020</i> <br><br><h3>  3. Der √úbergang zu Helm 3 </h3><br>  Es beinhaltet die Umstellung auf die neue <a href="https://habr.com/ru/company/flant/news/t/475722/">Helm 3-</a> Codebasis und eine bew√§hrte und bequeme M√∂glichkeit, vorhandene Installationen zu migrieren. <br><br>  <i>Version 1.1, Februar-M√§rz 2020</i> <br><br><h3>  4. Paralleler Zusammenbau von Bildern </h3><br>  Derzeit sammelt werf 1.0 alle in <code>werf.yaml</code> deklarierten Stufen von Bildern und Artefakten nacheinander.  Erfordert die F√§higkeit, den B√ºhnenmontageprozess zu parallelisieren. <br><br>  <i>Version: 1.1, Januar-Februar 2020</i> <br><br><h3>  5. Verteilte Assemblierung von Bildern </h3><br>  Im Moment kann werf 1.0 nur auf einem dedizierten Host verwendet werden <i>(siehe den obigen Punkt √ºber den Stage-Speicher auf nur einem Host)</i> . <br><br>  Wenn die Assembly auf mehreren Hosts gestartet wird und diese Hosts ihren Status zwischen Assemblys (tempor√§ren L√§ufern) nicht beibehalten, muss werf die M√∂glichkeit implementieren, die Docker-Registrierung als Stage-Repository zu verwenden, um die M√∂glichkeiten der verteilten Assembly zu er√∂ffnen. <br><br>  Zuvor hatte das werf-Projekt, als es auch dapp hie√ü, eine solche Gelegenheit.  Wir sind jedoch auf eine Reihe von Problemen gesto√üen, die bei der Implementierung dieser Funktion in werf ber√ºcksichtigt werden m√ºssen. <br><br>  <i>Version 1.2: M√§rz-April 2020</i> <br><br><h3>  6. Jsonnet zur Beschreibung der Kubernetes-Konfiguration </h3><br>  werf unterst√ºtzt die Konfigurationsbeschreibung f√ºr Kubernetes im <a href="https://jsonnet.org/">Jsonnet-</a> Format.  Gleichzeitig bleibt werf mit Helm kompatibel und es kann ein Beschreibungsformat ausgew√§hlt werden. <br><br>  Der Grund ist die Tatsache, dass die Go-Sprachvorlagen nach Ansicht vieler Leute eine gro√üe Eingabeschwelle haben und die Codeverst√§ndlichkeit dieser Vorlagen ebenfalls darunter leidet. <br><br>  Andere Optionen zur Implementierung von Kubernetes-Konfigurationsbeschreibungssystemen (wie z. B. Kustomize) werden ebenfalls in Betracht gezogen. <br><br>  <i>Version 1.1: Januar-Februar 2020</i> <br><br><h3>  7. Arbeiten Sie in Kubernetes </h3><br>  Zweck: Sicherstellen der Zusammenstellung von Images und der Bereitstellung von Anwendungen mithilfe von L√§ufern in Kubernetes.  Das hei√üt  Die Montage neuer Images, deren Ver√∂ffentlichung, Reinigung und Bereitstellung kann direkt von Kubernetes-Pods erfolgen. <br><br>  Um diese Funktion nutzen zu k√∂nnen, m√ºssen Sie zun√§chst die M√∂glichkeit haben, Bilder verteilt zu verteilen <i>(siehe Abschnitt oben)</i> . <br><br>  Es erfordert auch Unterst√ºtzung f√ºr den Build-Betriebsmodus ohne den Docker-D√§mon (d. H. Ein Kaniko-√§hnliches Build oder ein <i>Build im Benutzerbereich</i> ). <br><br>  Werf wird Kubernetes Builds nicht nur mit dem Dockerfile unterst√ºtzen, sondern auch mit seinem Stapel Builder mit inkrementellen Neuerstellungen. <br><br>  <i>Version 1.2: April-Mai 2020</i> <br><br><h3>  8. Andere </h3><br>  Es ist auch geplant: <br><br><ul><li>  Ansible-Versions-Upgrade und die M√∂glichkeit, verschiedene Ansible-Versionen zu verwenden </li><li>  Unterst√ºtzung f√ºr angemessene Rollen; </li><li>  Unterst√ºtzung f√ºr beliebige Assemblerstufen in Stapel (derzeit unterst√ºtzt werf einen statischen Satz von Stufen: <code>beforeInstall</code> , <code>install</code> , <code>beforeSetup</code> , <code>setup</code> ); </li><li>  verbesserte <code>werf.yaml</code> Syntax, Umstellung auf <code>configVersion: 2</code> (unter anderem mit den beiden vorherigen Punkten verbunden), Unterst√ºtzung der OpenAPI-Spezifikation; </li><li>  Git LFS-Unterst√ºtzung in Stapel zum Speichern gro√üer Dateien in Git; </li><li>  Verbesserung der Bildbereinigungsmechanismen (unkritische Fehler in der aktuellen Version werden mit Bildern in Verbindung gebracht, die in der <code>werf.yaml</code> Konfiguration im Hauptzweig des Masters nicht deklariert sind - diese Bilder werden durch regelm√§√üige Bereinigung gel√∂scht); </li><li>  Richtigeres Arbeiten mit gemeinsam genutzten Kubernetes-Namespaces, wenn mehrere Anwendungen in einem Namespace bereitgestellt werden. </li><li>  Automatisches Rollback der Anwendung auf die neueste Arbeitsversion bei fehlgeschlagener Bereitstellung. </li></ul><br><h2>  Total </h2><br>  Ich werde mich kurz fassen.  Wir sind: <br><br><ul><li>  lange ging bis zum Aufkommen der Version 1.0; </li><li>  ber√ºcksichtigte viel reale Erfahrung; </li><li>  Wir pr√§sentieren Ihnen ein bew√§hrtes Dienstprogramm mit stabiler Funktionalit√§t, das durch Zehntausende von Rollouts verifiziert wurde. </li></ul><br>  Die Ver√∂ffentlichung von Version 1.0 markiert den Beginn einer neuen Entwicklungsphase von werf, in der grundlegend neue Funktionen hinzugef√ºgt werden.  Befolgen Sie die Nachrichten!  Und schlie√üen Sie sich <a href="https://t.me/werf_ru">dem werf_ru tg-Kanal an</a> , an dessen Leben sowohl direkte werf-Entwickler als auch unsere Ingenieure und Benutzer des Versorgungsunternehmens au√üerhalb der Firma Flant beteiligt sind. <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://habr.com/ru/company/flant/news/t/478716/">Werf hat Dokumentation in russischer Sprache</a> "; </li><li>  Eine Reihe von Hinweisen zu Neuerungen in werf: <br><ul><li>  " <a href="https://habr.com/ru/company/flant/blog/476646/">3-Wege-Fusion in Werf: Einsatz in Kubernetes mit Helm" auf Steroiden</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/468049/">Mit werf komplexe Helm-Charts ausrollen</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/465131/">Unterst√ºtzung f√ºr monorepo und multirepo in werf und was hat die Docker Registry damit zu tun</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/463613/">Jetzt k√∂nnen Sie Docker-Bilder in werf mit der √ºblichen Docker-Datei zusammenstellen</a> "; </li></ul></li><li>  " <a href="https://habr.com/ru/company/flant/blog/460351/">Werf ist unser CI / CD-Tool in Kubernetes (Rezension und Videobericht)</a> "; </li><li>  ‚Äû <a href="https://habr.com/ru/company/flant/blog/458878/">Was ist GitOps?</a>  " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481306/">https://habr.com/ru/post/de481306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481290/index.html">HOW-to / Network- und VLAN-Einstellungen auf einem dedizierten Hetzner- und Mikrotik-Server</a></li>
<li><a href="../de481294/index.html">Die 10 besten Tools zur Softwaretestautomatisierung</a></li>
<li><a href="../de481296/index.html">Wie schreibe ich Code, der wiederverwendet wird?</a></li>
<li><a href="../de481302/index.html">"About, yes not a cluster" oder wie wir DBMS importiert haben</a></li>
<li><a href="../de481304/index.html">Amerikanische Flagge sortieren</a></li>
<li><a href="../de481312/index.html">Santa's Lost Gifts: Ank√ºndigung einer IT-Quest f√ºr den 6. Januar</a></li>
<li><a href="../de481314/index.html">DIY Crawler Plattform f√ºr Roboter und Unterhaltung</a></li>
<li><a href="../de481316/index.html">Erstellen eines Microservice-Blogs - Teil 4 Post-Service</a></li>
<li><a href="../de481318/index.html">Hacking mit Unicode (am Beispiel von GitHub)</a></li>
<li><a href="../de481320/index.html">Vier technische Innovationen, die das Gesundheitswesen jetzt neu gestalten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>