<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍘 🛌🏽 🧓 Einführung von werf 1.0 stable: Was hat GitOps damit zu tun, Status und Pläne 👩🏾‍✈️ 👎🏿 🥛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="werf ist ein Open-Source- GitOps-CLI-Dienstprogramm zum Erstellen und Bereitstellen von Anwendungen für Kubernetes. werf unterstützt das Zusammenstell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung von werf 1.0 stable: Was hat GitOps damit zu tun, Status und Pläne</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/481306/"><img src="https://habrastorage.org/webt/3x/gd/dm/3xgddmaqs9o_1evxjgalmlsczzo.png"><br><br>  <a href="https://werf.io/">werf</a> ist ein <a href="https://github.com/flant/werf">Open-Source-</a> GitOps-CLI-Dienstprogramm zum Erstellen und Bereitstellen von Anwendungen für Kubernetes.  werf unterstützt das Zusammenstellen von Anwendungsimages mit Dockerfile oder einem eigenen integrierten Collector (basierend auf YAML-Syntax, mit Ansible-Unterstützung und inkrementellem Neuaufbau basierend auf Git).  Helm-kompatibles Konfigurationsformat wird verwendet, um die Anwendung bereitzustellen.  Der Anwendungscode, die Konfiguration der gesammelten Bilder und die Rollout-Konfiguration der Anwendung werden in einem Git-Repository gespeichert. <br><br>  Die lang erwartete <a href="">stabile Version 1.0</a> ist die Basisversion des Dienstprogramms, das durch Funktionen vervollständigt wird <i>(die genaue Versionsnummer der ersten stabilen Version ist 1.0.6)</i> .  In der Basisversion unterstützt werf den gesamten Zyklus der Anwendungsbereitstellung und -wartung.  Dies umfasst das Zusammenstellen von Anwendungsimages, das Bereitstellen auf Kubernetes und das Bereinigen nicht verwendeter Images. <a name="habracut"></a><br><br>  Es ist wichtig, dass in Version 1.0 alle Vorgänge an einem Projekt ( <code>build</code> , <code>deploy</code> , <code>cleanup</code> ) von einem Host aus ausgeführt werden.  Dies bedeutet, dass ein fester Mitarbeiter im CI-System verwendet werden muss.  Gleichzeitig gibt es keine Einschränkungen hinsichtlich der Parallelität von Aufgaben: Werf löst dieses Problem vollständig.  Sie können auch verschiedene Projekte auf verschiedene Mitarbeiter verteilen. <br><br>  In diesem Artikel, der sich mit der Veröffentlichung befasst, werden wir uns näher mit dem befassen, was diese Version bietet und was nicht, sowie mit unseren Plänen für zukünftige Versionen.  Beginnen wir jedoch mit dem Verständnis des Begriffs „GitOps“ und der Rolle von werf in den Prozessen der kontinuierlichen Integration und Anwendungsbereitstellung (CI / CD). <br><br><h2>  Warum werf ist GitOps </h2><br>  Was verstehen wir unter GitOps und welche Bereiche deckt werf ab? <br><br>  Der Begriff „GitOps“ wurde vor etwa 2,5 Jahren von Weaveworks geprägt, und wir haben kürzlich einen Artikel seiner Autoren übersetzt, der die Essenz dieses neuen Phänomens für den Blog enthüllt.  Nach unserem Verständnis ist die Hauptidee und Hauptbedeutung von GitOps, dass <b>Git eine „einzige Quelle der Wahrheit“ ist</b> .  Git speichert: <br><br><ul><li>  Anwendungscode </li><li>  alle Abhängigkeiten; </li><li>  Informationen zum Sammeln von Containern; </li><li>  Informationen zur Bereitstellung auf Kubernetes; </li><li>  usw. </li></ul><br>  Und dann gibt es etwas, das die <b>Realität mit den Git-Änderungen in Einklang</b> bringt.  Dieser Ansatz kann nicht nur implementiert werden, indem ein Operator in Kubernetes installiert wird, der Git überwacht, sondern auch ein Konsolendienstprogramm verwendet, das von jedem CI-System aus aufgerufen werden kann.  Aus unserer Sicht ist der Ansatz mit dem CLI-Dienstprogramm außerdem nicht mit unnötigen Einschränkungen verbunden: Wir können CI mit jedem Tool und mit einer beliebigen Anzahl von Nuancen ausführen, indem wir ein CLI-Dienstprogramm aufrufen, das die „Realität“ (dh Kubernetes) mit dem Status von Git synchronisiert . <br><br>  werf bietet eine übergeordnete CLI-Oberfläche mit grundlegenden Befehlen zum <code>werf build-and-publish</code> und Veröffentlichen von Abbildern, Bereitstellen von Anwendungen und Bereinigen von Abbildern: <code>werf build-and-publish</code> , <code>werf deploy</code> , <code>werf dismiss</code> , <code>werf cleanup</code> .  Es wird davon ausgegangen, dass diese grundlegenden Befehle in ein bestimmtes CI-System eingebettet sind und die erforderliche Synchronisation mit der Realität ermöglichen.  Darüber hinaus bietet werf eine CLI-Oberfläche auf niedriger Ebene für die Verwaltung verschiedener Subsysteme - siehe die <a href="https://ru.werf.io/documentation/cli/management/stages/build.html">Verwaltungsbefehle auf niedriger Ebene</a> in der Dokumentation. <br><br>  Es spielt keine Rolle, ob das eingebaute CI / die eingebaute CD nach dem Push- oder Pull-Modell funktioniert <i>(lesen Sie mehr darüber <a href="https://habr.com/ru/company/flant/blog/456754/">hier</a> )</i> , da <b>werf in jedes Modell eingebaut werden kann</b> .  Gleichzeitig schließt werf Probleme wie die Arbeit mit separaten Low-Level-Dienstprogrammen wie <code>git</code> , docker und kubernetes api-server, die der „fehlende Teil“ für die Konfiguration einer einheitlichen CI / CD-Anwendung sind. <br><br><h2>  Was ist werf 1.0 stabil </h2><br><h3>  1. Montage, Veröffentlichung und Reinigung von Bildern </h3><br>  Wenn Ihre Anwendung das Erstellen von Docker-Images erfordert, können Sie mit werf 1.0: <br><br><ul><li>  Beschreiben Sie die Regeln zum Zusammenstellen von Images (Sie können mehrere haben) in einer einzigen <code>werf.yaml</code> Konfiguration. </li><li>  Sammeln Sie Bilder und veröffentlichen Sie sie in der Docker-Registrierung </li><li>  Reinigen Sie die Docker-Registrierung regelmäßig für benutzerdefinierte Richtlinien. </li></ul><br>  werf unterstützt <b>zwei Möglichkeiten, die Assembly zu beschreiben</b> : Verbinden von <code>werf.yaml</code> <b>vorhandenen Docker-Dateien</b> und Anweisungen für <b>den Stapel-Collector</b> .  Das Bauen mit Stapel hat seine Vorteile: Eine schnellere inkrementelle Neuerstellung, wenn der Anwendungscode in Git geändert wird, Ansible-Syntax für Assemblierungen verwendet wird und andere.  Weitere Informationen zu diesem Kollektor und zur Syntax finden Sie <a href="https://ru.werf.io/documentation/reference/build_process.html">in der Dokumentation</a> . Ein Beispiel für seine Verwendung finden Sie im <a href="https://ru.werf.io/documentation/guides/advanced_build/first_application.html">Handbuch</a> . <br><br>  In Bezug auf Git-Commits, -Zweige und -Tags stehen verschiedene Schemata zum Taggen / Versionswechsel von gesammelten Bildern zur Verfügung. <br><br>  Das Zusammenstellen von Images ist eine optionale Phase der Anwendungsbereitstellung und kann übersprungen werden, wenn keine eigenen zusammengestellten Images vorhanden sind. <br><br><h3>  2. Stage Storage auf nur einem Host </h3><br>  werf führt das konzept der stufenspeicherung ein.  Die wichtigsten werf-Befehle verwenden den Stufenspeicher wie folgt: <br><br><ul><li>  Montageergebnisse speichern - Docker-Bilder im Stage Store </li><li>  Verwenden Sie Bilder aus dem Stage Store als Cache zum Wiederherstellen und Zusammenstellen neuer Bilder. </li><li>  Verwenden Sie das Repository, um Informationen zu den gesammelten Bildern für deren weitere Verwendung abzurufen (z. B. bei der Übermittlung einer Anwendung an Kubernetes). </li></ul><br>  Bei der Bereitstellung einer einzelnen Anwendung sollte für alle Teams ein einstufiger Speicher verwendet werden (Zusammenstellung, Veröffentlichung, Image-Bereinigung, Anwendungsbereitstellung). <br><br>  In Version 1.0 kann nur der lokale <code>--stages-storage=:local</code> fungieren (der entsprechende Parameter für die Befehle lautet: <code>--stages-storage=:local</code> ).  Bei Verwendung von <code>:local</code> Abschnitte auf der Festplatte gespeichert.  Die Folge davon: <b>Werf 1.0</b> kann nur <b>auf einem Host verwendet werden,</b> um die Bereitstellung einer <b>einzelnen Anwendung</b> <b>zu</b> organisieren.  Dieser Host muss zwischen den Befehlsstarts Daten speichern, damit werf ordnungsgemäß funktioniert. <br><br>  In Version 1.0 gibt es keine Unterstützung für das Speichern von Phasen in einem externen Speicher, mit denen Sie eine verteilte Assembly organisieren könnten.  Eine solche Funktion wird jedoch in zukünftigen Versionen von werf erscheinen <i>(siehe unten für weitere Details)</i> . <br><br><h3>  3. Stellen Sie die Anwendung bereit und überprüfen Sie die Verfügbarkeit </h3><br>  Um die Anwendung einzuführen, beschreibt der Benutzer das Diagramm in einem mit Helm kompatiblen Format: eine Reihe von Kubernetes-Manifesten und Vorlagenparametern. <br><br>  werf startet die Anwendung in Kubernetes und stellt sicher, dass sie gestartet wird und funktioniert, bevor der Rollout-Vorgang für die Anwendung abgeschlossen ist.  Dies umfasst die Ausgabe von Komponentenprotokollen und die sofortige Reaktion auf Rollout-Fehler, wenn ein Fehler aufgetreten ist. Der Rollout-Befehl wird mit einem Code ungleich Null gelöscht.  Wenn <b>wir also das</b> werf-Rollout in CI / CD verwenden, erhalten <b>wir ein angemessenes Feedback von der Software</b> : Die Anwendung wird heruntergeladen oder nicht, und es gibt genügend Informationen, um Probleme zu debuggen und zu beheben (ohne andere Dienstprogramme ausführen zu müssen, um Probleme wie <code>kubectl</code> zu finden). <br><br>  werf ist voll kompatibel mit bestehenden Helm 2 Installationen, aber werf hat mehrere Vorteile gegenüber.  Als Mechanismus zum Aktualisieren von Ressourcen verwendet Kubernetes beispielsweise <a href="https://ru.werf.io/documentation/reference/deploy_process/resources_update_methods_and_adoption.html">Patches zum Zusammenführen in drei Richtungen.</a> Außerdem besteht die Möglichkeit, Feedback zu erhalten, wenn die Anwendung an den Cluster übermittelt wird.  Eine vollständige Liste der Unterschiede finden Sie auf <a href="https://ru.werf.io/documentation/reference/deploy_process/differences_with_helm.html">dieser Seite</a> . <br><br><h3>  4. Die Beziehung der gesammelten Bilder zum Übermittlungsprozess der Anwendung </h3><br>  werf integriert die gesammelten Bilder in ein einziges System, markiert und versioniert sie und liefert die Anwendung an Kubernetes.  Bilder, die werf sammelt, können in Ressourcenbeschreibungsvorlagen von Kubernetes verwendet werden. <br><br>  Aufgrund dieser Funktionen können wir sagen, dass <b>werf eine übergeordnete Schnittstelle</b> als Helm, Docker und andere Builder und Dienstprogramme für die separate Bereitstellung <b>bietet</b> .  Diese Schnittstelle ermöglicht es Ihnen, werf einfach in ein bestehendes CI / CD-System zu integrieren und nicht die Probleme zu lösen, alle verwendeten Komponenten zu kombinieren - er übernimmt diese Aufgabe. <br><br><h3>  5. Integration in vorhandene CI / CD-Systeme </h3><br>  In Version 1.0 ist die automatische Integration nur mit <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/gitlab_ci.html">dem GitLab CI-System</a> verfügbar.  Dazu wird der <code>werf ci-env</code> bereitgestellt.  Es empfängt die erforderlichen Informationen vom CI / CD-System und konfiguriert werf automatisch so, dass es in der CI-Umgebung ordnungsgemäß funktioniert. <br><br>  Weitere Informationen zur Integration in ein CI / CD-System finden Sie in den Handbüchern ( <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/overview.html">Übersicht</a> , <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/gitlab_ci.html">GitLab CI-Besonderheiten</a> , <a href="https://ru.werf.io/documentation/guides/unsupported_ci_cd_integration.html">Integration in andere Systeme</a> ). <br><br><h3>  6. Plattformübergreifende Entwicklung für Linux, Windows und macOS </h3><br>  werf 1.0 ist eine statisch verknüpfte Binärdatei, die unabhängig von Docker- und Helm-Versionen funktioniert.  Externe Abhängigkeiten vom Hostsystem: <br><br><ul><li>  Lokaler Docker-Daemon </li><li>  Git-Dienstprogramm. </li></ul><br>  werf kann auf allen Betriebssystemen und Umgebungen von GNU / Linux, Windows oder macOS ausgeführt werden.  Darüber hinaus ist das Ergebnis der Assemblierung unabhängig vom verwendeten System dasselbe: Dieselbe Signatur der Cachestufen, dieselbe Füllung der Stufen, unabhängig davon, auf welchem ​​System diese Stufe erfasst wurde.  Änderungen in der Konfiguration für die Arbeit in verschiedenen Systemen sind ebenfalls nicht erforderlich. <br><br>  Daher bietet werf 1.0 plattformübergreifende Tools zum Erstellen und Bereitstellen von Anwendungen für Kubernetes. <br><br>  Hier ist auch zu beachten, dass werf Standard-Docker-Images für die Arbeit in einer Linux-Umgebung sammelt, <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/">Windows-Container</a> in Version 1.0 <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/">jedoch</a> nicht unterstützt werden. <br><br><h3>  7. Funktionalität mit Tests abdecken </h3><br>  Derzeit werden 60% des werf-Codes durch Integrationstests und Unit-Tests abgedeckt. <br><br>  werf wird auf allen unterstützten Betriebssystemen (Linux, Windows und macOS) mit GitHub Actions getestet, um den Start zu organisieren.  Einige Details zu den Tests finden Sie auch unter <a href="https://codeclimate.com/github/flant/werf">Code Climate</a> . <br><br><h3>  8. Versionierung werf </h3><br>  Zum Zeitpunkt der Veröffentlichung von Version 1.0 wurden im Projekt <a href="https://github.com/flant/werf/releases">ungefähr 700 Veröffentlichungen</a> vorgenommen. <br><br>  werf nutzt ein erweitertes release-system mit stabilitätskanälen: <i>alpha</i> , <i>beta</i> , <i>ea (early access)</i> , <i>stable</i> und <i>rock-solid</i> .  Dieser Beitrag fällt zeitlich mit der Veröffentlichung der ersten Version 1.0 im <i>Stable-</i> Channel zusammen.  Instabile Änderungen an der Version durchlaufen zunächst eine Kette von Kanälen und enden schließlich in einem sehr <i>soliden Zustand</i> .  Releases werden oft gemacht (manchmal mehrere pro Tag) und Änderungen werden kontinuierlich in "kleinen Portionen" geliefert. <br><br>  Stabilitätskanäle und viele häufige Releases ermöglichen Ihnen ein kontinuierliches Feedback zu neuen Änderungen, die Möglichkeit, diese schnell zurückzusetzen und generell eine hohe Stabilität der Software bei gleichzeitig akzeptabler Entwicklungsgeschwindigkeit sicherzustellen. <br><br>  Der wichtige Punkt ist, dass beim Wechsel zwischen den Versionen 1.0-&gt; 1.1, 1.1-&gt; 1.2 Änderungen an werf möglich sind, die einen manuellen Eingriff des Benutzers erfordern (dies kann ein Migrationsskript sein oder nur Anweisungen für die manuelle Ausführung, die in der Version beschrieben werden).  Durch die Aktualisierung der Versionen in 1.0 (1.0.1, 1.0.2, ... 1.0.6-alpha.1, 1.0.6-beta.2 usw.) wird sichergestellt, dass solche manuellen Änderungen nicht erforderlich sind. <br><br>  Weitere Informationen zum Versprechen der Abwärtskompatibilität finden Sie <a href="https://github.com/flant/werf">hier</a> . <br><br><h2>  Weitere Pläne </h2><br>  Hier sind die wichtigsten Arbeitsbereiche für zukünftige Versionen und ungefähre Bedingungen für deren Implementierung: <br><br><h3>  1. Lokale Entwicklung und Bereitstellung von Anwendungen mit werf </h3><br>  Das Hauptziel besteht darin, eine einzige einheitliche Konfiguration für die sofortige Bereitstellung von Anwendungen sowohl lokal als auch in der Produktion ohne komplexe Aktionen zu erstellen. <br><br>  Werf benötigt auch eine Betriebsart, in der es bequem ist, den Anwendungscode zu bearbeiten und sofort Feedback von einer funktionierenden Anwendung zum Debuggen zu erhalten. <br><br>  <i>Version 1.1, Januar-Februar 2020</i> <br><br><h3>  2. Inhaltsbasiertes Tagging </h3><br>  Kennzeichnen von Bildern, wenn sie veröffentlicht werden, ausschließlich basierend auf dem Inhalt dieses Bildes.  Im Gegensatz zu Modi mit Bindung an Git-Commits werden in diesem Modus unnötige Neuerstellungen vollständig beseitigt.  Git-commit-id ist kein universeller Bezeichner für Arbeitsbauminhalte (obwohl es davon abhängt). <br><br>  In dem Fall, dass der Anwendungscode nicht geändert wurde, aber ein neues Commit durchgeführt wurde, erstellt der aktuelle Tag-Modus für Git-Commits ein Bild mit einem neuen Namen, wenn es veröffentlicht wird.  Dies führt auch zu einem Ressourcen-Rollback, wenn dieses Image in Kubernetes verwendet wird.  Gleichzeitig hat sich der Inhalt des Bildes selbst nicht verändert. <br><br>  Um diese Probleme zu lösen, wird werf eine neue Art der Kennzeichnung einführen, die auf Berechnungen der Prüfsummen des Anwendungsinhalts <b>basiert</b> - die <b>inhaltsbasierte Kennzeichnung</b> . <br><br>  <i>Version 1.1, Februar-März 2020</i> <br><br><h3>  3. Der Übergang zu Helm 3 </h3><br>  Es beinhaltet die Umstellung auf die neue <a href="https://habr.com/ru/company/flant/news/t/475722/">Helm 3-</a> Codebasis und eine bewährte und bequeme Möglichkeit, vorhandene Installationen zu migrieren. <br><br>  <i>Version 1.1, Februar-März 2020</i> <br><br><h3>  4. Paralleler Zusammenbau von Bildern </h3><br>  Derzeit sammelt werf 1.0 alle in <code>werf.yaml</code> deklarierten Stufen von Bildern und Artefakten nacheinander.  Erfordert die Fähigkeit, den Bühnenmontageprozess zu parallelisieren. <br><br>  <i>Version: 1.1, Januar-Februar 2020</i> <br><br><h3>  5. Verteilte Assemblierung von Bildern </h3><br>  Im Moment kann werf 1.0 nur auf einem dedizierten Host verwendet werden <i>(siehe den obigen Punkt über den Stage-Speicher auf nur einem Host)</i> . <br><br>  Wenn die Assembly auf mehreren Hosts gestartet wird und diese Hosts ihren Status zwischen Assemblys (temporären Läufern) nicht beibehalten, muss werf die Möglichkeit implementieren, die Docker-Registrierung als Stage-Repository zu verwenden, um die Möglichkeiten der verteilten Assembly zu eröffnen. <br><br>  Zuvor hatte das werf-Projekt, als es auch dapp hieß, eine solche Gelegenheit.  Wir sind jedoch auf eine Reihe von Problemen gestoßen, die bei der Implementierung dieser Funktion in werf berücksichtigt werden müssen. <br><br>  <i>Version 1.2: März-April 2020</i> <br><br><h3>  6. Jsonnet zur Beschreibung der Kubernetes-Konfiguration </h3><br>  werf unterstützt die Konfigurationsbeschreibung für Kubernetes im <a href="https://jsonnet.org/">Jsonnet-</a> Format.  Gleichzeitig bleibt werf mit Helm kompatibel und es kann ein Beschreibungsformat ausgewählt werden. <br><br>  Der Grund ist die Tatsache, dass die Go-Sprachvorlagen nach Ansicht vieler Leute eine große Eingabeschwelle haben und die Codeverständlichkeit dieser Vorlagen ebenfalls darunter leidet. <br><br>  Andere Optionen zur Implementierung von Kubernetes-Konfigurationsbeschreibungssystemen (wie z. B. Kustomize) werden ebenfalls in Betracht gezogen. <br><br>  <i>Version 1.1: Januar-Februar 2020</i> <br><br><h3>  7. Arbeiten Sie in Kubernetes </h3><br>  Zweck: Sicherstellen der Zusammenstellung von Images und der Bereitstellung von Anwendungen mithilfe von Läufern in Kubernetes.  Das heißt  Die Montage neuer Images, deren Veröffentlichung, Reinigung und Bereitstellung kann direkt von Kubernetes-Pods erfolgen. <br><br>  Um diese Funktion nutzen zu können, müssen Sie zunächst die Möglichkeit haben, Bilder verteilt zu verteilen <i>(siehe Abschnitt oben)</i> . <br><br>  Es erfordert auch Unterstützung für den Build-Betriebsmodus ohne den Docker-Dämon (d. H. Ein Kaniko-ähnliches Build oder ein <i>Build im Benutzerbereich</i> ). <br><br>  Werf wird Kubernetes Builds nicht nur mit dem Dockerfile unterstützen, sondern auch mit seinem Stapel Builder mit inkrementellen Neuerstellungen. <br><br>  <i>Version 1.2: April-Mai 2020</i> <br><br><h3>  8. Andere </h3><br>  Es ist auch geplant: <br><br><ul><li>  Ansible-Versions-Upgrade und die Möglichkeit, verschiedene Ansible-Versionen zu verwenden </li><li>  Unterstützung für angemessene Rollen; </li><li>  Unterstützung für beliebige Assemblerstufen in Stapel (derzeit unterstützt werf einen statischen Satz von Stufen: <code>beforeInstall</code> , <code>install</code> , <code>beforeSetup</code> , <code>setup</code> ); </li><li>  verbesserte <code>werf.yaml</code> Syntax, Umstellung auf <code>configVersion: 2</code> (unter anderem mit den beiden vorherigen Punkten verbunden), Unterstützung der OpenAPI-Spezifikation; </li><li>  Git LFS-Unterstützung in Stapel zum Speichern großer Dateien in Git; </li><li>  Verbesserung der Bildbereinigungsmechanismen (unkritische Fehler in der aktuellen Version werden mit Bildern in Verbindung gebracht, die in der <code>werf.yaml</code> Konfiguration im Hauptzweig des Masters nicht deklariert sind - diese Bilder werden durch regelmäßige Bereinigung gelöscht); </li><li>  Richtigeres Arbeiten mit gemeinsam genutzten Kubernetes-Namespaces, wenn mehrere Anwendungen in einem Namespace bereitgestellt werden. </li><li>  Automatisches Rollback der Anwendung auf die neueste Arbeitsversion bei fehlgeschlagener Bereitstellung. </li></ul><br><h2>  Total </h2><br>  Ich werde mich kurz fassen.  Wir sind: <br><br><ul><li>  lange ging bis zum Aufkommen der Version 1.0; </li><li>  berücksichtigte viel reale Erfahrung; </li><li>  Wir präsentieren Ihnen ein bewährtes Dienstprogramm mit stabiler Funktionalität, das durch Zehntausende von Rollouts verifiziert wurde. </li></ul><br>  Die Veröffentlichung von Version 1.0 markiert den Beginn einer neuen Entwicklungsphase von werf, in der grundlegend neue Funktionen hinzugefügt werden.  Befolgen Sie die Nachrichten!  Und schließen Sie sich <a href="https://t.me/werf_ru">dem werf_ru tg-Kanal an</a> , an dessen Leben sowohl direkte werf-Entwickler als auch unsere Ingenieure und Benutzer des Versorgungsunternehmens außerhalb der Firma Flant beteiligt sind. <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://habr.com/ru/company/flant/news/t/478716/">Werf hat Dokumentation in russischer Sprache</a> "; </li><li>  Eine Reihe von Hinweisen zu Neuerungen in werf: <br><ul><li>  " <a href="https://habr.com/ru/company/flant/blog/476646/">3-Wege-Fusion in Werf: Einsatz in Kubernetes mit Helm" auf Steroiden</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/468049/">Mit werf komplexe Helm-Charts ausrollen</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/465131/">Unterstützung für monorepo und multirepo in werf und was hat die Docker Registry damit zu tun</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/463613/">Jetzt können Sie Docker-Bilder in werf mit der üblichen Docker-Datei zusammenstellen</a> "; </li></ul></li><li>  " <a href="https://habr.com/ru/company/flant/blog/460351/">Werf ist unser CI / CD-Tool in Kubernetes (Rezension und Videobericht)</a> "; </li><li>  „ <a href="https://habr.com/ru/company/flant/blog/458878/">Was ist GitOps?</a>  " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481306/">https://habr.com/ru/post/de481306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481290/index.html">HOW-to / Network- und VLAN-Einstellungen auf einem dedizierten Hetzner- und Mikrotik-Server</a></li>
<li><a href="../de481294/index.html">Die 10 besten Tools zur Softwaretestautomatisierung</a></li>
<li><a href="../de481296/index.html">Wie schreibe ich Code, der wiederverwendet wird?</a></li>
<li><a href="../de481302/index.html">"About, yes not a cluster" oder wie wir DBMS importiert haben</a></li>
<li><a href="../de481304/index.html">Amerikanische Flagge sortieren</a></li>
<li><a href="../de481312/index.html">Santa's Lost Gifts: Ankündigung einer IT-Quest für den 6. Januar</a></li>
<li><a href="../de481314/index.html">DIY Crawler Plattform für Roboter und Unterhaltung</a></li>
<li><a href="../de481316/index.html">Erstellen eines Microservice-Blogs - Teil 4 Post-Service</a></li>
<li><a href="../de481318/index.html">Hacking mit Unicode (am Beispiel von GitHub)</a></li>
<li><a href="../de481320/index.html">Vier technische Innovationen, die das Gesundheitswesen jetzt neu gestalten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>