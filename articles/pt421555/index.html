<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéª üèÅ üì≥ Projeto WideNES - v√° al√©m dos limites da tela do NES üïû üë®‚Äçüíª üêì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em meados dos anos 80, o Nintendo Entertainment System (NES) era um console obrigat√≥rio. O melhor som, os melhores gr√°ficos e os melhores jogos entre ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Projeto WideNES - v√° al√©m dos limites da tela do NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421555/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif" alt="imagem"></div><br>  Em meados dos anos 80, o Nintendo Entertainment System (NES) era um console obrigat√≥rio.  O melhor som, os melhores gr√°ficos e os melhores jogos entre todos os consoles da √©poca - o console expandiu os limites do poss√≠vel.  At√© agora, projetos como <em>Super Mario Bros.</em>  , <em>The Legend of Zelda</em> e <em>Metroid</em> s√£o considerados alguns dos melhores jogos de todos os tempos. <br><br>  Mais de 30 anos ap√≥s o lan√ßamento do NES, os jogos cl√°ssicos s√£o √≥timos, o que n√£o pode ser dito sobre o hardware no qual eles trabalharam.  Com uma resolu√ß√£o de apenas 256x240, o console do NES n√£o podia fornecer jogos com espa√ßo suficiente.  No entanto, os destemidos desenvolvedores conseguiram se encaixar nos mundos incr√≠veis e inesquec√≠veis dos jogos da NES: as masmorras labir√≠nticas de <em>The Legend of Zelda</em> , vastos espa√ßos do planeta em <em>Metroid</em> , n√≠veis brilhantes de <em>Super Mario Bros.</em>  .  No entanto, devido √†s limita√ß√µes de hardware do NES, os jogadores nunca poderiam ir al√©m de 256x240 ... <br><br>  At√© recentemente. <br><br>  Apresento a voc√™s o projeto <strong>wideNES</strong> - uma nova maneira de jogar cl√°ssicos do NES! <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/921/157/9b0/9211579b0ba7322cf563254fcd26c9cc.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/433/ea0/dcd433ea06a9dec672c3457d76ee2181.gif"></div><br>  <strong>O wideNES</strong> √© uma nova tecnologia para marcar de maneira <em>autom√°tica</em> e <em>interativa</em> os jogos da NES <em>em tempo real</em> . <br><br>  Quando os jogadores se movimentam pelo n√≠vel, wideNES registra a tela, construindo gradualmente um mapa da parte explorada do mundo.  Nos n√≠veis subsequentes, o wideNES sincroniza a jogabilidade na tela com o mapa gerado, essencialmente permitindo que os jogadores vejam mais ‚Äúolhando‚Äù al√©m dos limites da tela do NES!  O melhor de tudo √© que a maneira como voc√™ marca jogos wideNES √© <em>totalmente universal</em> , o que permite que uma ampla variedade de jogos NES funcione com wideNES sem nenhuma configura√ß√£o! <br><br>  Mas como tudo isso funciona? <br><br><hr><br>  Se voc√™ quiser verificar a largura do NES antes de ler o artigo, por favor!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ANESE</a> √© o emulador de NES que escrevi e atualmente √© o √∫nico emulador que implementa wideNES.  No entanto, vale ressaltar que a ANESE <em>n√£o</em> √© <em>o</em> melhor emulador de NES do mundo, em termos de precis√£o da UI e da emula√ß√£o.  A maioria dos recursos (incluindo a inclus√£o do wideNES) est√° dispon√≠vel apenas na linha de comando e, embora muitos jogos populares funcionem bem, outros podem se comportar de maneiras inesperadas. <br><br><hr><br><h2>  Como o wideNES funciona </h2><br>  Antes de se aprofundar nos detalhes, √© importante explicar brevemente como o NES renderiza gr√°ficos. <br><br><h3>  Transfer√™ncia de pixels usando PPU </h3><br>  O cora√ß√£o do NES √© o vener√°vel processador MOS 6502. No final dos anos 70 e in√≠cio dos anos 80, 6502 eram usados ‚Äã‚Äãem <em>todos os lugares</em> e trabalhavam em m√°quinas lend√°rias como o Commodore 64, o Apple II e muitos outros.  Era barato, f√°cil de programar e poderoso o <em>suficiente</em> para ser perigoso. <br><br>  Como complemento do 6502 no console do NES, havia um poderoso coprocessador gr√°fico chamado <em>Picture Processing Unit</em> (PPU).  Comparado aos coprocessadores de v√≠deo simples usados ‚Äã‚Äãem sistemas mais antigos, o PPU √© uma grande melhoria em termos de usabilidade.  Por exemplo, cinco anos antes do lan√ßamento do NES, o processador Atari 2600 6502 foi usado para transmitir instru√ß√µes gr√°ficas ao coprocessador <em>para cada linha raster</em> , o que deixou pouco tempo para o processador executar a l√≥gica do jogo.  Para compara√ß√£o: o PPU precisava de apenas alguns comandos <em>por quadro</em> , e isso deu a 6502 tempo suficiente para criar uma jogabilidade interessante e inovadora. <br><br>  A PPU √© um chip incr√≠vel, sua maneira de renderizar gr√°ficos √© quase como o trabalho das GPUs modernas, e uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√©rie</a> completa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de artigos ser√° necess√°ria</a> para explicar completamente suas fun√ß√µes.  Como o wideNES usa apenas um pequeno subconjunto de fun√ß√µes da PPU, √© suficiente consider√°-las apenas brevemente: <br><br><ul><li>  Resolu√ß√£o: 256x240 pixels, 60 Hz </li><li>  Funciona independentemente da CPU <br><ul><li>  Comunica-se com a CPU usando <em>E / S com mapeamento de mem√≥ria</em> (intervalo de endere√ßos 0x2000 - 0x2007) </li></ul></li><li>  2 camadas de renderiza√ß√£o: camada <strong>sprite</strong> e camada de <strong>fundo</strong> <ul><li>  <strong>Camada de Sprite</strong> <br><ul><li>  Cada sprite individual pode ser colocado em qualquer lugar da tela. </li><li>  √ìtimo para objetos em movimento: jogador, inimigos, conchas </li><li>  At√© 64 sprites de 8x8 pixels </li></ul></li><li>  <strong>Camada de fundo</strong> <br><ul><li>  Amarrado a uma grade </li><li>  √ìtimo para elementos est√°ticos: plataformas, grandes obst√°culos, decora√ß√µes </li><li>  Mem√≥ria de v√≠deo √© suficiente para armazenar 64x30 blocos de tamanho 8x8 pixels <br><ul><li>  Verdadeira resolu√ß√£o <em>interna de</em> 512x240, com uma janela de visualiza√ß√£o de 256x240 </li><li>  Suporta <strong><em>rolagem de hardware</em></strong> para alterar a janela de visualiza√ß√£o de 256x240 <br><ul><li>  O registro PPUSCROLL (endere√ßo 0x2005) controla o deslocamento da viewport em X / Y </li></ul></li></ul></li></ul></li></ul></li></ul><br>  Depois de lidar com essa breve vis√£o geral, vamos para o mais interessante: como o wideNES funciona? <br><br><h3>  Ideia principal </h3><br>  No final de cada quadro, a CPU envia as informa√ß√µes de altera√ß√£o para a PPU.  Isso inclui novas posi√ß√µes de sprite, novos dados de n√≠vel e, o que √© cr√≠tico para wideNES, <em>novas compensa√ß√µes de viewport</em> .  Como o wideNES funciona no emulador, √© muito f√°cil acompanhar os valores gravados no registro PPUSCROLL, o que significa que √© incrivelmente f√°cil calcular o quanto a tela se moveu entre dois quadros! <br><br>  Hmm, o que acontecer√° se, em vez de desenhar cada novo quadro <em>diretamente em cima do</em> quadro antigo, novos quadros ser√£o desenhados <em>sobrepostos</em> no quadro anterior, mas mudados para o valor atual de rolagem?  Ent√£o, com o tempo, uma parte cada vez maior do n√≠vel permanecer√° na tela, construindo gradualmente uma imagem completa do n√≠vel! <br><br>  Para verificar se essa ideia teve algum valor, rapidamente esbocei a primeira implementa√ß√£o. <br><br>  Compilando ... <br>  A iniciar ... <br>  Baixar <em>Super Mario Bros.</em>  ... <br><br>  Voila! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/7cb/c7f/1ed7cbc7ff1998d1f5f19af6ca09bb54.gif"></div><br>  Funcionou! <br><br>  Parece ser ... <br><br><hr><br><h3>  Outra abordagem: por que n√£o extrair n√≠veis diretamente dos arquivos ROM? </h3><br>  Mesmo sem considerar os detalhes da implementa√ß√£o, torna-se √≥bvio que essa t√©cnica tem uma s√©ria limita√ß√£o: um mapa do jogo completo pode ser coletado apenas quando o jogador explora independentemente o jogo inteiro. <br><br>  E se houvesse alguma maneira de extrair n√≠veis de ROMs NES <em>cruas</em> ?! <br><br>  Essa t√©cnica pode existir? <br><br>  Bem, provavelmente n√£o. <br><br>  Se voc√™ jogar dois jogos para o NES, poder√° garantir que eles tenham apenas uma coisa em comum: ambos trabalham para o NES.  Tudo o resto pode ser completamente diferente!  Essa incompatibilidade √© um desastre real, porque os jogos NES t√™m essencialmente um n√∫mero infinito de op√ß√µes para armazenar dados de n√≠vel! <br><br>  Algumas pessoas extra√≠ram n√≠veis completos por engenharia reversa, da maneira como armazenam os dados de n√≠veis de <em>alguns</em> jogos (√†s vezes com a cria√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">editores de mapas com todos os</a> recursos!), Mas essa √© uma tarefa dif√≠cil, exigindo muito trabalho, perseveran√ßa e intelig√™ncia. <br><br>  Para extrair dados de n√≠vel da ROM, √© necess√°rio determinar quais partes da ROM s√£o c√≥digo (n√£o dados), e isso √© dif√≠cil, porque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">encontrar todo o c√≥digo em um arquivo bin√°rio √© equivalente a um problema de parada</a> ! <br><br>  O WideNES usa uma abordagem muito mais simples: em vez de adivinhar como o jogo empacotou os dados de n√≠vel na ROM, o wideNES apenas inicia o jogo e acompanha a sa√≠da! <br><br><hr><br><h3>  Rolando al√©m de 255 </h3><br>  O NES √© um sistema de 8 bits, ou seja, o registro PPUSCROLL pode receber apenas valores de 8 bits.  Isso limita o deslocamento m√°ximo de rolagem a 255 pixels, ou seja, o n√∫mero m√°ximo de 8 bits.  N√£o √© por acaso que a resolu√ß√£o da tela do NES √© de 240x256 pixels, ou seja, a troca de 255 pixels <em>√© suficiente</em> para rolar a tela inteira. <br><br>  Mas o que acontece ao rolar <em>al√©m de</em> 255? <br><br>  Primeiramente, os jogos redefinem o registro PPUSCROLL para 0. Isso explica por que o <em>SMB √©</em> transportado para o in√≠cio quando Mario se move muito para a direita. <br><br>  Em seguida, para compensar as restri√ß√µes PPUSCROLL de 8 bits, os jogos atualizam outro registro PPU: PPUCTRL (endere√ßo 0x2000).  Os 2 bits inferiores do PPUCTRL definem o "ponto inicial" da cena atual em incrementos de tela cheia.  Por exemplo, escrever um valor 1 desloca a janela de visualiza√ß√£o para a direita em 256 pixels, enquanto um valor 2 desloca a janela de visualiza√ß√£o em 240 pixels.  O deslocamento PPUCTRL √© empurrado para a <em>pilha</em> com o registro PPUSCROLL, que permite rolar a tela horizontalmente dentro de 512 pixels ou verticalmente dentro de 480 pixels. <br><br>  Mas construa, existe apenas mem√≥ria de v√≠deo suficiente para telas de dois n√≠veis?  O que acontece quando a janela de exibi√ß√£o rola muito para a direita e "vai al√©m" da VRAM?  Para lidar com esse caso, o PPU implementa a convolu√ß√£o: todas as partes da janela de exibi√ß√£o fora da mem√≥ria de v√≠deo selecionada s√£o simplesmente recolhidas na borda oposta da mem√≥ria de v√≠deo. <br><br>  Essa dobragem, combinada com a manipula√ß√£o inteligente de registros PPUSCROLL e PPUCTRL, permite que os jogos NES criem a ilus√£o de mundos infinitamente altos / largos!  Gra√ßas ao carregamento lento de parte do n√≠vel fora da janela de visualiza√ß√£o e √† rolagem gradual para dentro, os jogadores nunca percebem que dentro do VRAM eles realmente ‚Äúcorrem em c√≠rculos‚Äù! <br><br>  Uma excelente ilustra√ß√£o do wiki nesdev mostra como <em>Super Mario Bros.</em>  usa essas propriedades para criar n√≠veis maiores que duas telas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif"></div><br>  Vamos voltar √† pergunta que estamos discutindo: como o wideNES lida com a rolagem al√©m de 256? <br><br>  Bem, francamente, o wideNES <em>ignora completamente o</em> registro PPUCTRL e apenas acompanha a diferen√ßa do PPUSCROLL entre os quadros! <br><br>  Se o PPUSCROLL saltar inesperadamente para cerca de 256, o que geralmente significa que o personagem do jogador foi movido para a esquerda / para cima na tela e se ele saltar inesperadamente para cerca de 0, isso geralmente significa que o jogador foi movido para a direita / para baixo na tela. <br><br>  Embora essa heur√≠stica possa parecer simples - e √© - de fato, ela funciona muito bem! <br><br>  Depois de implementar essa heur√≠stica, <em>Super Mario Bros.</em>  , <em>Metroid</em> e muitos outros jogos funcionaram quase perfeitamente! <br><br>  Fiquei emocionado, ent√£o fui em frente e carreguei mais um cl√°ssico do NES - <em>Super Mario Bros.</em>  <em>3</em> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a21/1ee/233/a211ee233bcdea56af5b983f9b8715cf.gif"></div><br>  Hmm ... N√£o √© muito bonito. <br><br><h3>  Ignorando elementos est√°ticos da tela </h3><br>  Muitos jogos possuem elementos de interface do usu√°rio est√°ticos nas bordas da tela.  No caso do <em>SMB3,</em> esta √© a coluna √† esquerda e a barra de status est√° na parte inferior do status. <br><br>  Por padr√£o, as amostras wideNES com incrementos de 16 pixels nas bordas da tela, ou seja, todos os elementos est√°ticos nas bordas s√£o amostrados!  N√£o √© bom! <br><br>  Para contornar esse problema, o wideNES implementa regras e heur√≠sticas que tentam reconhecer e mascarar automaticamente elementos de tela est√°ticos. <br><br>  Em geral, os jogos NES usam tr√™s tipos diferentes de elementos de tela est√°ticos: HUDs, m√°scaras e barras de status. <br><br><h4>  HUD - sem problemas </h4><br>  Se um jogo imp√µe um HUD no topo de um n√≠vel, √© prov√°vel que o HUD consista em v√°rios sprites.  Exemplo: HUD no <em>Metroid</em> . <br><br>  Felizmente, esses HUDs n√£o causam problemas, porque o wideNES atualmente simplesmente ignora a camada de sprite.  √ìtimo! <br><br><h4>  M√°scaras - em nenhum lugar mais f√°cil </h4><br>  A PPU possui um recurso que permite aos jogos mascarar os 8 pixels mais √† esquerda da camada de plano de fundo.  √â ativado configurando o segundo bit do registrador (endere√ßo 0x2001).  Muitos jogos usam esse recurso, mas explicar <em>por</em> que o fazem est√° al√©m do escopo deste artigo. <br><br>  Reconhecer a m√°scara inclu√≠da √© incrivelmente simples: wideNES apenas mant√©m o controle do valor PPUMASK e ignora os 8 pixels mais √† esquerda quando o segundo bit √© definido no registro! <br><br>  Parece que a implementa√ß√£o desta regra simples <em>resolveu o</em> problema com o <em>SMB3</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/6ce/6ce/8e56ce6ce6e3f59203422816794e21de.gif"></div><br>  ... bem, ou <em>quase</em> eliminado. <br><br><h4>  As barras de status s√£o as mais dif√≠ceis </h4><br>  Devido √†s limita√ß√µes da PPU a qualquer momento na tela, n√£o pode haver mais do que 64 sprites;  al√©m disso, a qualquer momento em <em>cada linha de varredura, n√£o</em> pode haver mais do que 8 sprites.  Essa restri√ß√£o impede que os desenvolvedores criem HUDs complexos a partir de sprites e os for√ßa a usar partes da camada de segundo plano para exibir informa√ß√µes. <br><br>  Al√©m das m√°scaras, n√£o h√° maneira f√°cil no PPU de separar a camada de segundo plano na √°rea de jogo e na √°rea de status.  Portanto, os desenvolvedores fizeram truques, levando a v√°rias maneiras <em>pouco ortodoxas</em> de criar pain√©is de status ... <br><br>  O WideNES usa v√°rias heur√≠sticas para reconhecer diferentes tipos de pain√©is de status, mas para economizar tempo, considerarei apenas um dos mais interessantes: rastreamento de IRQ no meio do quadro. <br><br><h3>  Rastreamento IRQ de quadro intermedi√°rio </h3><br>  Diferentemente das GPUs modernas, com grandes buffers de quadro interno, as PPUs <em>geralmente n√£o t√™m um buffer de quadro!</em>  Para economizar espa√ßo, o PPU armazena cenas como uma grade de blocos de 64x32 de 8x8 pixels.  Em vez de pr√©-calcular os dados de pixel, os blocos s√£o armazenados como <em>ponteiros</em> para a Mem√≥ria CHR (Mem√≥ria de Caracteres), que cont√©m todos os dados de pixel. <br><br>  Desde que o NES foi desenvolvido nos anos 80, o PPU foi criado sem levar em conta as modernas tecnologias de exibi√ß√£o.  Em vez de renderizar o quadro inteiro ao mesmo tempo, o PPU emite o sinal de v√≠deo NTSC, que deve ser exibido em uma tela CRT que exibe v√≠deo <em>pixel por pixel</em> , <em>linha por linha</em> , de cima para baixo, de cima para baixo, de cima para baixo, da esquerda para a direita. <br><br>  Por que tudo isso √© importante? <br><br>  Como o PPU renderiza os quadros de cima para baixo, linha por linha, voc√™ pode enviar instru√ß√µes de PPU para o <em>meio do quadro</em> para criar efeitos de v√≠deo que s√£o imposs√≠veis com qualquer outra abordagem!  Esses efeitos podem ser simples (por exemplo, alterar a paleta) ou bastante complexos (por exemplo, voc√™ adivinhou, criando barras de status!). <br><br>  Para explicar como uma grava√ß√£o PPU de quadro intermedi√°rio pode criar barras de status, gravei um despejo de fatia de v√≠deo PPU e CHR Memory bruto para um √∫nico quadro <em>SMB3</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf6/565/049/cf6565049202c1a832222de6edb291c3.png"></div><br>  Tudo parece bem, nada de especial ... mas basta olhar para a barra de status!  Ela est√° completamente distorcida! <br><br>  Agora olhe para o mesmo despejo bruto, mas feito ap√≥s a linha 196 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5df/8e4/be6/5df8e4be6a32dcefa00429da5fbb4755.png"></div><br>  Sim, o n√≠vel parece horr√≠vel, mas a barra de status est√° √≥tima! <br><br>  O que est√° acontecendo aqui? <br><br>  <em>O SMB3</em> define um cron√¥metro para acionar o IRQ (interrup√ß√£o) exatamente ap√≥s renderizar a linha raster 195. Passa as seguintes instru√ß√µes para o manipulador de IRQ: <br><br><ul><li>  Defina PPUSCROLL como (0,0) (para que a barra de status permane√ßa no lugar) </li><li>  Substitu√≠mos o cart√£o lado a lado na Mem√≥ria CHR (ordenamos os gr√°ficos da barra de status) </li></ul><br>  Como o restante da camada j√° est√° renderizado, a PPU n√£o "atualiza" novamente o quadro.  Em vez disso, continuar√° a renderizar com essas op√ß√µes, exibindo uma bela barra de status sem distor√ß√£o! <br><br>  Vamos voltar ao wideNES: observando todos os IRQs no meio do quadro e lembrando a linha de varredura na qual eles ocorreram, o wideNES pode ignorar todas as linhas de varredura subsequentes no registro!  Se ocorrer IRQ na linha de varredura acima de 240/2, todas <em>as</em> linhas <em>anteriores</em> ser√£o ignoradas, porque a interrup√ß√£o antecipada da linha de varredura significa que a barra de status pode estar <em>na parte superior da</em> tela. <br><br>  Depois de implementar essa heur√≠stica, <em>Super Mario Bros.</em>  <em>3</em> ganhou perfeito! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/146/44a/b08/14644ab0880d7a2827bcad22d028a0be.gif"></div><br><hr><br>  Considerei brevemente a possibilidade de usar uma biblioteca de vis√£o computacional, como o OpenCV, para reconhecer pain√©is de status (ou outras √°reas principalmente est√°ticas da tela), mas, como resultado, decidi abandon√°-la.  Usar uma biblioteca de vis√£o computacional enorme, complexa e opaca √© contr√°ria aos ideais do wideNES, no qual tento usar regras e heur√≠sticas compactas, simples e transparentes para obter resultados. <br><br><hr><br><h3>  Reconhecimento de cena </h3><br>  Com exce√ß√£o de alguns exemplos importantes (por exemplo, <em>Metroid</em> ), os jogos para o NES geralmente <em>n√£o</em> passam em um n√≠vel imenso e inextric√°vel.  Pelo contr√°rio, a maioria dos jogos de NES √© dividida em muitas pequenas ‚Äúcenas‚Äù independentes com portas ou telas de transi√ß√£o entre elas. <br><br>  Como wideNES n√£o tem o conceito de ‚Äúcenas‚Äù, coisas ruins acontecem ao mudar de cena ... <br><br>  Por exemplo, aqui est√° a primeira transi√ß√£o da cena de <em>Castlevania</em> , onde Simon Belmont entra no castelo de Dr√°cula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/b5b/8e4/7f7b5b8e4edf5c31dd19682b333d75c9.gif"></div><br>  Uau, tudo est√° ruim!  wideNES reescreveu completamente a √∫ltima parte do n√≠vel com a primeira tela de um novo n√≠vel! <br><br>  Obviamente, o wideNES precisa de alguma maneira de reconhecer as mudan√ßas de cena.  Mas qual? <br><br>  <em>Hashing Perceptivo!</em> <br><br>  Diferentemente das fun√ß√µes hash <em>criptogr√°ficas</em> , que tendem a distribuir uniformemente dados de entrada semelhantes pelo espa√ßo de informa√ß√µes de sa√≠da, as fun√ß√µes de hash <em>perceptivas</em> tentam manter dados de entrada semelhantes "pr√≥ximos" um do outro no espa√ßo de dados de sa√≠da.  Portanto, os hashes perceptivos s√£o ideais para reconhecer imagens semelhantes! <br><br>  As fun√ß√µes perceptivas de hash podem ser incrivelmente complexas, algumas delas s√£o capazes de reconhecer imagens semelhantes se uma delas foi girada, dimensionada, esticada e as cores alteradas nela.  Felizmente, o wideNES n√£o requer fun√ß√µes complexas de hash porque √© garantido que cada quadro tenha o mesmo tamanho.  Portanto, wideNES usa o mais simples dos hashes perceptivos existentes: <em>somando todos os pixels na tela!</em> <br><br>  √â simples, mas funciona muito bem! <br><br>  Por exemplo, veja como as transi√ß√µes entre cenas se destacam se voc√™ tra√ßar o hash perceptivo ao longo do tempo em <em>The Legend of Zelda</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/799/5e3/f077995e3d509802139543805d7ae61b.png"></div><br>  Atualmente, o wideNES usa um limite fixo entre valores de hash perceptivos para concluir a transi√ß√£o entre cenas, mas o resultado est√° longe de ser ideal.  Jogos diferentes usam paletas diferentes, e h√° muitos casos em que o wideNES pensa que ocorreu uma transi√ß√£o, mas na verdade n√£o foi.  Idealmente, o wideNES deve usar um valor de limite din√¢mico, mas at√© agora o valor fixo o far√°. <br><br>  Depois de implementar essa nova heur√≠stica, o wideNES reconhece com sucesso a entrada de Simon de <em>Castlevania</em> no castelo e, consequentemente, cria uma nova tela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/6da/e81/6446dae81018592433a99f4f50a8b4d0.gif"></div><br>  E com essa decis√£o, colocamos em pr√°tica a √∫ltima pe√ßa importante do quebra-cabe√ßa wideNES. <br><br>  Tendo implementado a serializa√ß√£o mais simples, finalmente consegui rodar o jogo para o NES, jogar em v√°rios n√≠veis e gerar automaticamente mapas de n√≠veis! <br><br><h2>  O que espera wideNES no futuro? </h2><br>  O wideNES consiste em duas partes separadas: <em>o kernel</em> wideNES, que s√£o as pr√≥prias regras / heur√≠sticas subjacentes √† tecnologia, e a implementa√ß√£o espec√≠fica do wideNES dentro do emulador ANESE. <br><br><h3>  Aprimoramento do <em>n√∫cleo</em> WideNES </h3><br>  Em primeiro lugar, o wideNES √© propenso a um reconhecimento muito agressivo das transi√ß√µes entre as cenas.  O n√∫mero de falsos positivos pode ser minimizado usando um algoritmo de hash perceptivo mais adequado ou alternando para valores de limiar din√¢mico entre hashes perceptivos. <br><br>  Tamb√©m √© necess√°rio trabalho adicional para reconhecer elementos de tela est√°ticos.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Megaman IV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tem um IRQ no meio do quadro, mas n√£o h√° barra de status, e √© por isso que o wideNES ignora por engano a parte s√≥lida do campo de jogo. Embora esse caso espec√≠fico possa ser corrigido pelo ajuste manual, √© melhor usar heur√≠sticas mais inteligentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns jogos do NES rolam a tela de maneiras "√∫nicas". Um dos exemplos mais not√°veis ‚Äã‚Äã√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que usa PPUSCROLL para rolagem horizontal, mas usa um registro completamente diferente para rolagem vertical - PPUADDR. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© um jogo bastante popular, ent√£o o NES implementa heur√≠sticas especificamente para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Existem outros jogos com modos de rolagem "√∫nicos" semelhantes, que tamb√©m exigem heur√≠sticas individuais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seria √∫til encontrar uma maneira de ‚Äúcosturar‚Äù cenas id√™nticas. Por exemplo, se um usu√°rio jogar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario Bros.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≠vel 1, mas rasteja no cano para entrar na caverna subterr√¢nea com moedas, o wideNES criar√° duas cenas separadas para o N√≠vel 1: cena A, n√≠vel at√© Mario entrar na zona com moedas e cena B, n√≠vel, a partir do momento quando Mario sai do cano e sobe para o mastro. Se o jogo for reiniciado e o N√≠vel 1 for repetido </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entrar no canal, o wideNES simplesmente atualizar√° a cena A, que conter√° um mapa de n√≠vel completo, mas a cena B ser√° interrompida.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, o wideNES deve acompanhar as transi√ß√µes entre as cenas. </font><font style="vertical-align: inherit;">Sem esses dados, n√£o ser√° poss√≠vel construir um gr√°fico de transi√ß√£o entre as cenas para gerar mapas mundiais de jogos que </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consistem em um √∫nico mundo grande.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Melhorando a implementa√ß√£o do wideNES na ANESE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualmente wideNES √© implementado apenas no emulador NES que escrevi sob o nome ANESE. O ANESE √© um </font><font style="vertical-align: inherit;">emulador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> espartano: a maioria das op√ß√µes est√° oculta por tr√°s dos sinalizadores da CLI, e a √∫nica interface do usu√°rio implementada √© a sobreposi√ß√£o de sele√ß√£o de arquivo mais simples! Ele ainda est√° </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muito</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> longe do n√≠vel de "produ√ß√£o". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m da falta de UI, ANESE e wideNES, melhorias na compatibilidade e velocidade n√£o prejudicariam. ANESE √© o primeiro emulador que escrevi, e √© percept√≠vel! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem alguns problemas de compatibilidade - muitos jogos n√£o funcionam corretamente ou nem iniciam. Felizmente, a imperfei√ß√£o da ANESE n√£o significa que wideNES seja uma tecnologia ruim. O wideNES √© baseado em princ√≠pios comprovados que ser√£o f√°ceis de implementar em outros emuladores!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em termos de velocidade, ANESE e wideNES n√£o s√£o perfeitos, e mesmo em PCs relativamente poderosos, o desempenho √†s vezes pode ficar abaixo de 60fps! A ANESE e a wideNES precisam implementar muitas otimiza√ß√µes. Al√©m da melhoria geral do kernel ANESE, √© necess√°rio melhorar a grava√ß√£o de quadros NES, a renderiza√ß√£o de mapas e a amostragem de hash.</font></font><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No artigo, falei sobre os principais aspectos do wideNES, mas n√£o consegui descrever muitos recursos pequenos. Por exemplo, wideNES armazena um mapa dos valores de hash e rolagem verdadeiros de cada quadro, que s√£o usados ‚Äã‚Äãpara ativar cenas repetidas. Esse e muitos outros recursos s√£o descritos no c√≥digo-fonte amplamente comentado do wideNES, publicado na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p√°gina do projeto wideNES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhar no wideNES foi uma experi√™ncia verdadeiramente surpreendente, mas com a abordagem do novo semestre acad√™mico da Universidade Waterloe, duvido que, no futuro pr√≥ximo, seja capaz de continuar desenvolvendo o wideNES. No momento, as principais fun√ß√µes do wideNES est√£o funcionando e fico feliz por poder escrever este post descrevendo algumas de suas tecnologias!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente usar wideNES e compartilhe seus sentimentos! </font><font style="vertical-align: inherit;">Fa√ßa o download da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANESE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , inicie o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario Bros. </font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e jogue-os de uma nova maneira!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421555/">https://habr.com/ru/post/pt421555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421545/index.html">Revis√£o do PocketBook 616 - o bolso 2018 mais econ√¥mico com fun√ß√£o de luz de fundo</a></li>
<li><a href="../pt421547/index.html">Aceita√ß√£o independente do data center</a></li>
<li><a href="../pt421549/index.html">Estamos escrevendo documenta√ß√£o t√©cnica: um guia para o leigo</a></li>
<li><a href="../pt421551/index.html">Dominando Vuex - De Zero a Her√≥i</a></li>
<li><a href="../pt421553/index.html">Compartilhamos conte√∫do tecnol√≥gico: reunimos todos os nossos materiais em um site</a></li>
<li><a href="../pt421557/index.html">Li√ß√£o aberta "Programa√ß√£o ass√≠ncrona em Java"</a></li>
<li><a href="../pt421559/index.html">Arquitetura da interface do usu√°rio do componente no aplicativo iOS</a></li>
<li><a href="../pt421563/index.html">Pode ser necess√°rio sentar-se de maneira diferente para se livrar da dor nas costas.</a></li>
<li><a href="../pt421565/index.html">Como rob√¥s human√≥ides rudes podem engan√°-lo</a></li>
<li><a href="../pt421567/index.html">Discuss√£o: ac√∫stica port√°til incomum - um carro esportivo, r√°dio retr√¥ e "botas de √°udio"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>