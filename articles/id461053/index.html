<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüåæ ü§ß üö≤ Kami menghubungkan peta online ke navigator di smartphone. Bagian 2 - kartu vektor üëë ü§∂üèΩ üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami sedang menulis aplikasi server yang akan menghasilkan ubin raster PNG berdasarkan peta vektor online. Gunakan memo web dengan Dalang untuk mendap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menghubungkan peta online ke navigator di smartphone. Bagian 2 - kartu vektor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461053/"><p>  Kami sedang menulis aplikasi server yang akan menghasilkan ubin raster PNG berdasarkan peta vektor online.  Gunakan memo web dengan Dalang untuk mendapatkan data peta. </p><a name="habracut"></a><br><h3 id="soderzhanie">  Konten: </h3><br><p>  1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta raster standar</a> <br>  2 - Lanjutan.  Menulis rasterizer sederhana untuk peta vektor <br>  3 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kasus khusus.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami menghubungkan kartu OverpassTurbo</a> </p><br><h3 id="prodolzhenie">  Lanjutan </h3><br><p>  Jadi kita sampai pada topik yang paling menarik.  Bayangkan kita menemukan situs dengan peta yang ingin kita tambahkan ke navigator kita.  Kami melakukan segalanya sesuai dengan instruksi dari bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> .  Kami membuka tampilan konten situs, dan tidak ada gambar!  Tentu saja  Nah, beberapa ikon dan hanya itu.  Dan beberapa file teks lainnya dengan daftar koordinat. </p><br><p>  Selamat, kami menemukan peta vektor.  Secara kasar, ini diterjemahkan secara real time oleh browser Anda.  Jadi dia tidak membutuhkan ubin yang disiapkan sama sekali.  Di satu sisi, sejauh ini tidak banyak peta vektor.  Tetapi teknologi ini sangat menjanjikan dan seiring waktu mereka dapat menjadi berkali-kali lipat.  Yah, kita sudah menemukannya.  Namun, apa yang kita lakukan sekarang? </p><br><p>  Pertama, Anda dapat mencoba mengunduh peramban dari versi yang sangat, sangat lama.  Satu yang tidak mendukung fungsi yang diperlukan untuk membuat peta.  Mungkin saja Anda akan diperlihatkan versi situs yang berbeda.  Dengan peta raster.  Nah, apa yang perlu Anda lakukan dengannya sudah Anda ketahui. </p><br><p>  Namun, jika trik ini tidak berhasil, tetapi Anda masih benar-benar ingin mendapatkan kartu ini, dan, lebih lagi, tidak di browser ponsel cerdas, yaitu di navigator Anda, maka ada caranya. </p><br><h3 id="osnovnaya-ideya">  Ide utama </h3><br><p>  Kami akan melanjutkan dari kenyataan bahwa kami ingin mendapatkan peta yang dapat dibuka di salah satu navigator.  Maka kita membutuhkan adaptor - sejenis perantara yang akan menghasilkan ubin untuk kita dalam format PNG. </p><br><p>  Ternyata yang Anda butuhkan <del>  menciptakan sepeda </del>  kembangkan mesin lain untuk memvisualisasikan data vektor.  Nah, atau Anda dapat menulis skrip yang akan pergi ke situs, membiarkannya menggambar peta vektor sendiri.  Dan kemudian dia akan menunggu unduhan, mengambil tangkapan layar, memotong dan kembali ke pengguna.  Mungkin saya akan memilih opsi kedua. </p><br><p>  Untuk mengambil tangkapan layar, saya akan menggunakan "browser kendali jarak jauh" - Chrome Tanpa Kepala.  Anda dapat mengontrolnya menggunakan pustaka simpul node js.  Anda dapat mempelajari dasar-dasar bekerja dengan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> . </p><br><h3 id="hello-world-ili-sozdaem-i-nastraivaem-proekt">  Halo Dunia!  Atau buat dan sesuaikan proyek </h3><br><p>  Jika Anda belum menginstal Node.js, buka halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">ini</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">ini</a> , pilih sistem operasi Anda dan selesaikan instalasi sesuai dengan instruksi. </p><br><p>  Buat folder baru untuk proyek dan buka di terminal. </p><br><pre><code class="plaintext hljs">$ cd /Mapshoter_habr</code> </pre> <br><p>  Kami memulai manajer menciptakan proyek baru </p><br><pre> <code class="plaintext hljs">$ npm init</code> </pre> <br><p>  Di sini Anda dapat menentukan nama proyek ( <strong>nama paket</strong> ), nama file untuk memasukkan aplikasi ( <strong>titik masuk</strong> ) dan nama penulis ( <strong>penulis</strong> ).  Untuk semua permintaan lainnya, kami menyetujui parameter default: kami tidak memasukkan apa pun dan cukup tekan <strong>Enter</strong> .  Di akhir - tekan <strong>y</strong> dan <strong>Enter</strong> . </p><br><p>  Selanjutnya, instal kerangka kerja yang diperlukan untuk pekerjaan.  Ekspres untuk membuat server dan Dalang untuk bekerja dengan browser. </p><br><pre> <code class="plaintext hljs">$ npm install express $ npm i puppeteer</code> </pre> <br><p>  Akibatnya, file file konfigurasi proyek <strong>package.json</strong> muncul di folder proyek.  Dalam kasus saya, ini: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapshoter_habr"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"nnngrach"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.17.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"puppeteer"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.18.1"</span></span> } }</code> </pre> <br><p>  Saya akan menambahkan baris awal ke bagian skrip untuk meluncurkan aplikasi kami dengan lebih nyaman. </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> },</code> </pre> <br><p>  Sekarang buat dua file dengan implementasi fungsi dasar.  File pertama adalah titik masuk ke aplikasi.  Dalam kasus saya, <strong>router.js</strong> .  Dia akan membuat server dan melakukan routing. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const express = require( 'express' ) const mapshoter = require( './mapshoter' ) //  ,       const PORT = process.env.PORT || 5000 //     const app = express() app.listen( PORT, () =&gt; { console.log( '    ', PORT ) }) //       // http://siteName.com/x/y/z app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { //      const x = req.params.x const y = req.params.y const z = req.params.z //      const screenshot = await mapshoter.makeTile( x, y, z ) //        const imageBuffer = Buffer.from( screenshot, 'base64' ) //    res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) //    res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Sekarang buat file kedua.  Dia akan mengontrol browser dan mengambil screenshot.  Saya menyebutnya <strong>mapshoter.js</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   const browser = await puppeteer.launch() //       const page = await browser.newPage() await page.goto( 'https://www.google.ru/' ) //    const screenshot = await page.screenshot() //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Jalankan skrip kami dan periksa kinerjanya.  Untuk melakukan ini, ketik konsol: </p><br><p> <code>$ npm start</code> </p> <br><p>  Muncul pesan yang mengatakan "Server dibuat pada port 5000".  Sekarang buka browser di komputer Anda dan pergi ke alamat lokal server kami.  Alih-alih koordinat <strong>x, y, z,</strong> Anda dapat memasukkan angka apa saja.  Saya memasukkan 1, 2, 3. </p><br><p> <code>http://localhost:5000/1/2/3</code> </p> <br><p>  Jika semuanya dilakukan dengan benar, tangkapan layar situs Google akan muncul. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66a/8db/ca5/66a8dbca5b15566f395ec6bf4163279c.png" alt="gambar"></p><br><p>  Tekan Ctrl + C di konsol untuk menghentikan skrip kami. </p><br><p>  Selamat, dasar dari aplikasi kita sudah siap!  Kami membuat server yang menerima permintaan html kami, mengambil tangkapan layar, dan mengembalikan gambar kepada kami.  Sekarang saatnya beralih ke implementasi detail. </p><br><h3 id="rasschitaem-koordinaty">  Hitung koordinatnya </h3><br><p>  Idenya adalah browser akan membuka situs dengan peta dan memasukkan koordinat tempat yang kita butuhkan di bilah pencarian.  Setelah mengklik tombol "Temukan", tempat ini akan persis di tengah layar.  Jadi akan mudah untuk memotong area yang kita butuhkan. </p><br><p>  Tetapi pertama-tama, Anda perlu menghitung koordinat pusat ubin berdasarkan nomor seri.  Saya akan melakukan ini berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">rumus</a> untuk menemukan sudut kiri atas.  Saya memasukkannya ke dalam fungsi <strong>getCoordinates ()</strong> . </p><br><p>  Dan karena untuk beberapa situs, selain pusat ubin, Anda juga perlu menentukan perbatasannya, maka saya akan mencarinya juga.  Baiklah, mari kita buat modul terpisah untuk perhitungan ini dengan nama <strong>geoTools.js</strong> .  Ini kodenya: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   function getCoordinates( x, y, z ) { const n = Math.pow( 2, z ) const lon = x / n * 360.0 - 180.0 const lat = 180.0 * ( Math.atan( Math.sinh( Math.PI * ( 1 - 2 * y / n) ) ) ) / Math.PI return { lat: lat, lon: lon } } //          function getCenter( left, rigth, top, bottom ) { let lat = ( left + rigth ) / 2 let lon = ( top + bottom ) / 2 return { lat: lat, lon: lon } } //        function getAllCoordinates( stringX, stringY, stringZ ) { //      const x = Number( stringX ) const y = Number( stringY ) const z = Number( stringZ ) //     //    -  -  const topLeft = getCoordinates( x, y, z ) const bottomRight = getCoordinates( x+1, y+1, z ) //   const center = getCenter( topLeft.lat, bottomRight.lat, topLeft.lon, bottomRight.lon ) //   const bBox = { latMin: bottomRight.lat, lonMin: topLeft.lon, latMax: topLeft.lat, lonMax: bottomRight.lon } return { bBox: bBox, center: center } } module.exports.getAllCoordinates = getAllCoordinates</span></span></code> </pre> <br><p>  Sekarang kita siap untuk mulai mengimplementasikan skrip untuk bekerja dengan browser.  Mari kita lihat beberapa skenario bagaimana ini bisa dilakukan. </p><br><h3 id="scenariy-1--poisk-s-pomoschyu-api">  Skenario 1 - Pencarian API </h3><br><p>  Mari kita mulai dengan case paling sederhana, ketika Anda cukup memasukkan koordinat di URL halaman peta.  Misalnya, seperti ini: </p><br><p> <code>https://nakarte.me/#m=5/50.28144/89.30666&amp;l=O/Wp</code> </p> <br><p>  Mari kita lihat skripnya.  Cukup ganti, hapus seluruh konten file <strong>mapshoter.js</strong> dan rekatkan kode di bawah ini. </p><br><p>  Dalam versi ini, ketika memulai browser, kami menentukan parameter tambahan yang akan memungkinkannya untuk memulai dan bekerja di server Linux, seperti Heroku.  Juga sekarang kita akan mengurangi ukuran jendela sehingga ubin peta sesedikit mungkin pas di layar.  Dengan demikian, kami meningkatkan kecepatan pemuatan halaman. </p><br><p>  Selanjutnya, kami menghitung koordinat tengah ubin yang diinginkan.  Kami menempelkannya ke URL dan mengkliknya.  Ubin muncul tepat di tengah layar.  Potong sepotong 256x256 piksel.  Ini akan menjadi ubin yang kami butuhkan.  Tetap hanya mengembalikannya ke pengguna. </p><br><p>  Sebelum beralih ke kode, saya perhatikan bahwa untuk kejelasan, semua penanganan kesalahan telah dihapus dari skrip. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,    Heroku const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) //        //       const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) //         URL const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" //   URL  ,    await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) //    const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Sekarang jalankan skrip kami dan lihat peta untuk bagian ini. </p><br><p> <code>http://localhost:5000/24/10/5</code> </p> <br><p>  Jika semuanya dilakukan dengan benar, maka server harus mengembalikan ubin seperti itu: </p><br><p><img src="https://habrastorage.org/webt/gg/t5/gr/ggt5grzq5iuw26bjt2zdhckeoic.png"></p><br><p>  Untuk memastikan kami tidak mencampur apa pun saat memotong, bandingkan ubin kami dengan yang asli dari OpenStreetMaps.org </p><br><p><img src="https://habrastorage.org/webt/32/kp/fs/32kpfsblzjzrx3c16ap3gjpfgx4.png"></p><br><h3 id="scenariy-2--poisk-s-pomoschyu-interfeysa-sayta">  Skenario 2 - Cari menggunakan antarmuka situs </h3><br><p>  Namun, tidak selalu memungkinkan untuk mengontrol kartu melalui saluran peramban.  Nah, dalam kasus seperti itu, skrip kami akan berperilaku seperti pengguna yang nyata.  Dia akan mencetak koordinat di kotak pencarian dan klik tombol Cari.  Setelah itu, ia akan menghapus penanda titik yang ditemukan, yang biasanya muncul di tengah layar.  Dan kemudian dia akan mengklik tombol untuk menambah atau mengurangi skala sampai dia mencapai yang diinginkan.  Kemudian akan mengambil tangkapan layar dan mengembalikannya kepada pengguna. </p><br><p>  Saya perhatikan bahwa biasanya setelah pencarian skala yang sama ditetapkan.  15, misalnya.  Dalam contoh kita, ini tidak selalu terjadi.  Karenanya, kami akan mengenali level zoom dari parameter elemen html pada halaman. </p><br><p>  Juga dalam contoh ini, kita akan mencari elemen antarmuka menggunakan pemilih XPath.  Tapi bagaimana Anda mengenalinya? </p><br><p>  Untuk melakukan ini, buka halaman yang diperlukan di browser dan buka toolbar pengembang ( <strong>Ctll + Alt + I</strong> untuk Google Chrome).  Tekan tombol untuk memilih item.  Kami mengklik elemen yang Anda minati (saya mengklik bidang pencarian). </p><br><p><img src="https://habrastorage.org/webt/rb/wu/37/rbwu37fuodlucpg4q_xqfsfk-my.png"></p><br><p>  Daftar item menggulir ke item yang Anda klik dan itu disorot dengan warna biru.  Klik tombol dengan tiga titik di sebelah kiri nama. </p><br><p>  Dari menu pop-up, pilih Salin.  Selanjutnya, jika Anda membutuhkan pemilih biasa, lalu klik <strong>Salin pemilih</strong> .  Tetapi untuk contoh yang sama, kami akan menggunakan item <strong>Salin XPath</strong> . </p><br><p><img src="https://habrastorage.org/webt/p9/wo/t-/p9wot-lbr6ho7ttgvmsb9yrfica.png"></p><br><p>  Sekarang ganti konten file <strong>mapshoter.js</strong> dengan kode ini.  Di dalamnya, saya telah mengumpulkan pemilih untuk semua elemen antarmuka yang diperlukan. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const searchFieldXPath = '//*[@id="map"]/div[1]/div[1]/div/input' const zoomPlusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[1]' const zoomMinusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[2]' const directionButonXPath = '//*[@id="gtm-poi-card-get-directions"]' const deletePinButonXPatch = '//*[@id="map"]/div[1]/div/div/div[1]/div[2]/div/div[4]/div/div[4]' //         () const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `lat=${coordinates.center.lat} lng=${coordinates.center.lon}` //      const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) const page = await browser.newPage() await page.setViewport( { width: 1100, height: 450 } ) //         const pageUrl = 'https://www.waze.com/en/livemap?utm_campaign=waze_website' await page.goto( pageUrl, { waitUntil: 'networkidle2', timeout: 10000 } ) //    ,      await click( searchFieldXPath, page ) //        await page.keyboard.type( centerCoordinates ) //  Enter    page.keyboard.press( 'Enter' ); //  500     await page.waitFor( 500 ) //       //       await click( directionButonXPath, page ) await page.waitFor( 100 ) await click( deletePinButonXPatch, page ) await page.waitFor( 100 ) //       //        while( z &gt; await fetchCurrentZoom( page )) { await click( zoomPlusXPath, page ) await page.waitFor( 300 ) } while( z &lt; await fetchCurrentZoom( page )) { await click( zoomMinusXPath, page ) await page.waitFor( 300 ) } //    const cropOptions = { fullPage: false, clip: { x: 422, y: 97, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   await browser.close() return screenshot } //  : //        async function click( xPathSelector, page ) { await page.waitForXPath( xPathSelector ) const foundedElements = await page.$x( xPathSelector ) if ( foundedElements.length &gt; 0 ) { await foundedElements[0].click() } else { throw new Error( "XPath element not found: ", xPathSelector ) } } //         html  async function fetchCurrentZoom( page ) { const xPathSelector = '//*[@id="map"]/div[2]' await page.waitForXPath( xPathSelector ) const elems = await page.$x(xPathSelector) const elementParams = await page.evaluate((...elems) =&gt; { return elems.map(e =&gt; e.className); }, ...elems); const zoom = elementParams[0].split('--zoom-').pop() return zoom } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Jalankan skrip kami dan ikuti tautannya.  Jika semuanya dilakukan dengan benar, maka skrip akan kembali kepada kami seperti ubin ini. </p><br><p> <code>http://localhost:5000/1237/640/11</code> </p> <br><p><img src="https://habrastorage.org/webt/3c/oo/0l/3coo0lmxp12svhu_m16vecfbjsw.png"></p><br><h3 id="optimizaciya">  Optimasi </h3><br><p>  Pada prinsipnya, dua metode yang dijelaskan di atas cukup untuk terhubung ke banyak situs dengan peta vektor.  Tetapi jika Anda tiba-tiba membutuhkan akses ke beberapa peta baru, Anda hanya perlu sedikit memodifikasi skrip dalam file mapshoter.js.  Artinya, metode ini membuatnya sangat mudah untuk menambahkan kartu baru.  Ini dari kelebihannya. </p><br><p>  Namun ada juga kekurangannya.  Dan yang utama adalah kecepatan kerja.  Bandingkan saja.  Rata-rata, dibutuhkan sekitar 0,5 detik untuk mengunduh satu ubin raster biasa.  Saat menerima satu ubin dari skrip kami saat ini membutuhkan waktu sekitar 8 detik. </p><br><p>  Tapi itu belum semuanya!  Kami menggunakan simpul single-threaded js dan permintaan panjang kami pada akhirnya akan memblokir utas utama, yang dari luar akan terlihat seperti antrian sinkron biasa.  Dan ketika kami mencoba mengunduh peta untuk seluruh layar (di mana, misalnya, 24 ubin ditempatkan), yaitu, ada risiko menemukan masalah. </p><br><p>  Dan satu hal lagi.  Beberapa navigator memiliki batas waktu: mereka akan berhenti memuat setelah 30 detik.  Dan ini berarti bahwa dengan implementasi saat ini hanya 3-4 ubin akan memiliki waktu untuk memuat.  Baiklah, mari kita lihat apa yang bisa kita lakukan. </p><br><p>  Mungkin cara yang paling jelas adalah dengan hanya menambah jumlah server tempat skrip kita dijalankan.  Misalnya, jika kita memiliki 10 server, maka mereka akan memiliki waktu untuk memproses ubin untuk seluruh layar dalam 30 detik.  (Jika Anda tidak ingin membayar banyak uang, Anda bisa mendapatkannya dengan mendaftarkan beberapa akun gratis di Heroku) </p><br><p>  Kedua, masih mungkin untuk mengimplementasikan multithreading pada node js menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">worker_threads</a> .  Menurut pengamatan saya, pada server dengan prosesor single-core pada akun Heroku gratis, saya berhasil memulai tiga utas.  Tiga aliran dengan browser terpisah di masing-masing, yang dapat bekerja secara bersamaan tanpa saling menghalangi.  Dalam keadilan, saya perhatikan bahwa sebagai hasil dari peningkatan beban pada prosesor, kecepatan unduhan satu ubin bahkan sedikit meningkat.  Namun, jika Anda mencoba mengunduh peta untuk seluruh layar, maka setelah 30 detik lebih dari setengah peta akan memiliki waktu untuk memuat.  Lebih dari 12 ubin.  Sudah lebih baik. </p><br><p>  Ketiga  Dalam implementasi skrip saat ini, dengan setiap permintaan, kami menghabiskan waktu mengunduh browser Chrome, dan kemudian menyelesaikannya.  Sekarang kita akan membuat browser terlebih dahulu dan akan mentransfer tautan ke sana di mapshoter.js.  Akibatnya, kecepatan tidak akan berubah untuk permintaan pertama.  Tetapi untuk semua kecepatan unduhan berikutnya dari satu ubin dikurangi menjadi 4 detik.  Dan setelah 30 detik seluruh peta memiliki waktu untuk memuat - semua 24 ubin yang ditempatkan di layar saya. </p><br><p>  Nah, jika Anda menerapkan semua ini, maka skrip dapat menjadi sangat layak.  Jadi mari kita mulai.  Untuk pekerjaan yang lebih sederhana dengan multithreading, saya akan menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">node-worker-threads-pool</a> - semacam wrapper over worker_threads.  Mari kita instal. </p><br><p> <code>$ npm install node-worker-threads-pool --save</code> </p> <br><p>  Perbaiki file router.js.  Tambahkan padanya penciptaan kumpulan utas.  Utas akan menjadi 3 buah.  Kode mereka akan dijelaskan dalam file <strong>worker.js</strong> , kita akan melihatnya nanti.  Sementara itu, hapus peluncuran modul tangkapan layar secara langsung.  Sebagai gantinya, kami akan menambahkan tugas baru ke kumpulan utas.  Mereka akan mulai memprosesnya ketika ada utas yang dibebaskan. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'express'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.listen( PORT, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'    '</span></span>, PORT ) }) <span class="hljs-comment"><span class="hljs-comment">//   . const { StaticPool } = require( 'node-worker-threads-pool' ) const worker = "./worker.js" const workersPool = new StaticPool({ size: 3, task: worker, workerData: "no" }) app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { const x = req.params.x const y = req.params.y const z = req.params.z //       //       const screenshot = await workersPool.exec( { x, y, z } ) const imageBuffer = Buffer.from( screenshot, 'base64' ) res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Sekarang lihat file <strong>pekerja.js</strong> .  Setiap kali tugas baru <strong>tiba, metode parentPort.on ()</strong> akan diluncurkan.  Sayangnya, ia tidak dapat menangani fungsi async / menunggu.  Jadi kita akan menggunakan fungsi adaptor dalam bentuk metode <strong>doMyAsyncCode ()</strong> . </p><br><p>  Di dalamnya dalam format yang mudah dibaca, kita akan menempatkan logika pekerja.  Yaitu, luncurkan browser (jika belum berjalan) dan aktifkan metode untuk mengambil tangkapan layar.  Saat memulai, kami akan memberikan tautan ke browser yang berjalan ke metode ini. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort, workerData } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapshoter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./mapshoter'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//     var browser = "empty" //         //    ,     parentPort.on( "message", ( params ) =&gt; { doMyAsyncCode( params ) .then( ( result) =&gt; { parentPort.postMessage( result ) }) }) //  ,    async/aswit //     async function doMyAsyncCode( params ) { //      await prepareEnviroment() //     const screenshot = await mapshoter.makeTile( params.x, params.y, params.z, browser ) return screenshot } //  .     ,    async function prepareEnviroment( ) { if ( browser === "empty" ) { const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} browser = await puppeteer.launch( herokuDeploymentParams ) } }</span></span></code> </pre> <br><p>  Untuk lebih jelasnya, mari kita kembali ke versi pertama <strong>mapshoter.js</strong> .  Itu tidak akan banyak berubah.  Sekarang pada parameter input, ia akan menerima tautan ke browser, dan ketika skrip berakhir, itu tidak akan mematikan browser, tetapi cukup tutup tab yang dibuat. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z, browserLink </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const browser = await browserLink //      const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   .   . await page.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Pada prinsipnya, itu saja.  Sekarang Anda dapat mengunggah hasilnya ke server dengan cara apa pun yang nyaman bagi Anda.  Misalnya melalui buruh pelabuhan.  Jika Anda ingin melihat hasil yang sudah selesai, Anda dapat mengklik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">tautan ini</a> .  Anda juga dapat menemukan kode proyek lengkap di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">GitHub</a> saya. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Sekarang mari kita evaluasi hasilnya.  Di satu sisi, meskipun semua trik dilakukan, kecepatan unduh masih sangat rendah.  Selain itu, karena rem, kartu seperti itu tidak nyaman untuk digulir. </p><br><p>  Di sisi lain, skrip ini berupaya dengan kartu yang sebelumnya tidak mungkin terhubung ke navigator di smartphone.  Tidak mungkin solusi ini akan diterapkan sebagai metode utama untuk memperoleh data kartografi.  Tapi di sini sebagai tambahan, dengan bantuan yang, jika perlu, akan mungkin untuk membuka beberapa kartu eksotis - sangat mungkin. </p><br><p>  Juga, keuntungan dari skrip ini termasuk fakta bahwa mudah untuk bekerja dengannya.  Mudah untuk menulis.  Dan, yang paling penting, dapat dengan mudah dikerjakan ulang untuk menghubungkan kartu online lainnya. </p><br><p>  Nah, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada artikel selanjutnya</a> saya akan membahas hal itu saja.  Saya akan mengubah skrip menjadi semacam API untuk bekerja dengan peta interaktif OverpassTurbo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461053/">https://habr.com/ru/post/id461053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461043/index.html">Manajemen konflik dalam tindakan penyeimbangan tim atau kebutuhan vital?</a></li>
<li><a href="../id461045/index.html">Dapatkan ekstrak dari Rosreestr melalui FSIS USRN dan python. Bagian 1</a></li>
<li><a href="../id461047/index.html">Menulis atau tidak menulis. Surat kepada pihak berwenang selama acara</a></li>
<li><a href="../id461049/index.html">ONYX BOOX Faust - Dia yang mencari tidak dipaksa untuk berkeliaran</a></li>
<li><a href="../id461051/index.html">10 kesalahan paling umum yang saya temui di Go-proyek</a></li>
<li><a href="../id461055/index.html">Tantangan Rekko 2019: bagaimana itu</a></li>
<li><a href="../id461057/index.html">Saluran telegram tentang pengembangan game</a></li>
<li><a href="../id461059/index.html">Menulis Aplikasi Android untuk Penggemar Film - Bagian 1 (Prototyping)</a></li>
<li><a href="../id461061/index.html">Paduan magnesium, batas kembar, dan pemisahan</a></li>
<li><a href="../id461063/index.html">Interaksi R dengan database pada contoh Microsoft SQL Server dan DBMS lainnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>