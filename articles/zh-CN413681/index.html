<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍶 😟 👩🏾‍🤝‍👨🏿 在Go上开发高度可靠的服务器的技术 🔀 🐉 🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Web程序员有时会面临甚至会吓到专业人员的任务。 我们谈论的是开发无权犯错的服务器应用程序，涉及失败成本极高的项目。 该材料的作者（我们今天出版的翻译）将讨论如何处理此类任务。 

  

 您的项目需要什么级别的可靠性？ 
 在深入研究开发高度可靠的服务器应用程序的细节之前，您应该问自己，您的项目...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Go上开发高度可靠的服务器的技术</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/413681/">  Web程序员有时会面临甚至会吓到专业人员的任务。 我们谈论的是开发无权犯错的服务器应用程序，涉及失败成本极高的项目。 该材料的作者（我们今天出版的翻译）将讨论如何处理此类任务。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/2r/ma/ty/2rmaty9ihtz7cjzhhvzqgm5e7ia.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">您的项目需要什么级别的可靠性？</font> </h2><br> 在深入研究开发高度可靠的服务器应用程序的细节之前，您应该问自己，您的项目是否真的需要可实现的最高可靠性。 对于大多数错误不特别可怕的项目，开发针对错误场景类似于普遍灾难的工作场景设计的系统的过程可能会变得不合理地复杂。 <br><br> 如果错误的代价没有变得很高，则可以接受一种方法，开发人员会在执行该方法时尽最大的努力来确保项目的可操作性，如果出现问题，他只是理解它们即可。 现代化的监控工具和持续的软件部署过程使您能够快速发现生产问题并几乎立即修复它们。 在许多情况下，这就足够了。 <br><br> 在我今天从事的项目中，事实并非如此。 我们正在谈论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区块链</a>的实现-分布式服务器基础架构，用于在信任度较低的环境中安全执行代码，同时达成共识。 该技术的一种应用是数字货币。 这是错误成本极高的系统的经典示例。 在这种情况下，项目开发人员确实需要使其非常非常可靠。 <br><br> 但是，在其他一些项目中，即使它们与财务无关，追求最高的代码可靠性也是有意义的。 维修经常中断的代码库的成本可以很快达到天文数字。 在解决问题的成本仍然很低的情况下，能够在开发过程的早期阶段发现问题的能力，对于及时投入时间和精力投入高度可靠的系统的开发方法，似乎是一种真正的回报。 <br><br><h2>  <font color="#3AC1EF">也许解决方案是TDD？</font> </h2><br> 通过测试进行开发（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试驱动开发</a> ，TDD）通常被认为是解决不良代码的最佳方法。  TDD是一种纯粹的开发方法，在该应用程序中首先编写测试，然后才编写测试-仅当检查项目的测试停止产生错误时，才将代码添加到项目中。 这个过程保证了100％的代码覆盖了测试，并且常常给人一种错觉，认为代码在其使用的所有可能变体中都经过测试。 <br><br> 但是，事实并非如此。  TDD是一种很棒的方法，在某些领域效果很好，但是仅仅开发真正可靠的代码还不够。 甚至更糟的是，TDD激发开发人员错误的信心，并且这种方法的应用可能导致这样的事实，即他出于懒惰而不会编写测试来检查系统的故障，这种情况从常识的角度来看几乎是不可能的。 我们稍后再讨论。 <br><br><h2>  <font color="#3AC1EF">测试是可靠性的关键</font> </h2><br> 实际上，在编写代码之前还是之后创建测试都无关紧要，是否使用TDD之类的开发方法。 最主要的是进行测试。 测试是最好的防御性防御，可以保护您的代码免受生产问题的影响。 <br><br> 由于我们将非常频繁地运行测试，因此理想情况下，在将每行添加到代码中之后，都必须使测试自动化。 我们对代码质量的信心绝不能以手动检查为基础。 问题是人们容易犯错误。 一个人连续多次完成相同的艰巨任务后，对细节的关注就会减弱。 <br><br> 测试应该很快。 非常快 <br><br> 如果完成测试套件需要花费几秒钟以上的时间，那么开发人员很可能会懒惰并在不进行测试的情况下将代码添加到项目中。 速度是Go的最大优势之一。 这种语言的开发工具包是现有工具中最快的工具包之一。 几秒钟内即可完成编译，重建和测试项目。 <br><br> 此外，测试是开源项目的重要驱动力之一。 例如，这适用于与区块链技术相关的所有事物。 这里的开源几乎是一种宗教。 为了使使用它的人有信心，该代码库必须是开放的。 例如，这允许进行审核，创建分散的氛围，其中没有某些实体可以控制项目。 <br><br> 如果该项目不包括质量测试，则等待外部开发人员对该开源项目做出重大贡献是没有道理的。 外部项目参与者需要一种机制来快速检查他们编写的内容与项目中已添加内容的兼容性。 实际上，整套测试应在收到将新代码添加到项目的每个请求后自动执行。 如果应该通过这种请求添加到项目中的内容破坏了某些内容，则测试应立即报告此情况。 <br><br> 用测试完全覆盖代码库是一个欺骗性但重要的指标。 用测试实现100％代码覆盖率的目标似乎过高，但是考虑一下，事实证明，如果测试未完全覆盖代码，则部分代码未经验证即被发送到生产环境，这是以前从未执行过的。 <br><br> 用测试完全覆盖代码不一定意味着项目中有足够的测试，也不意味着这些测试绝对提供使用代码的所有选项。 可以放心地说，如果项目没有100％包含在测试中，则开发人员将无法确定代码的绝对可靠性，因为从未对代码的某些部分进行过测试。 <br><br> 尽管如此，在某些情况下测试太多。 理想情况下，每种可能的错误都应导致一项测试失败。 如果测试数量过多，也就是说，不同的测试会检查相同的代码片段，则修改现有代码并更改现有系统行为将导致以下事实：为了使现有测试与新代码相对应，将花费太多时间来处理它们。 。 <br><br><h2>  <font color="#3AC1EF">为什么Go是高度可靠项目的绝佳选择？</font> </h2><br>  Go是一种静态类型的语言。 类型是一起执行的各种代码之间的约定。 在项目组装过程中没有自动类型检查的情况下，如果您需要遵守严格的规则来覆盖测试代码，则我们将不得不实施测试以自行验证这些“合同”。 例如，这发生在基于JavaScript的服务器和客户端项目中。 编写仅针对类型检查的复杂测试意味着大量的额外工作，在Go的情况下，可以避免这些工作。 <br><br>  Go是一种简单而教条的语言。 如您所知，Go包含许多编程语言的传统思想，例如经典的OOP继承。 复杂性是可靠代码的最大敌人。 问题往往隐藏在复杂结构的关节处。 这体现在以下事实中：尽管使用某种设计的典型选项很容易测试，但测试开发人员甚至可能不会想到奇怪的边界情况。 最后，该项目将减少其中一种情况。 从这个意义上说，教条主义也是有用的。 在Go中，通常只有一种执行动作的方法。 这似乎是阻碍程序员自由进取的一个因素，但是当只能以一种方式完成某件事时，很难做错什么。 <br><br>  Go简洁但富有表现力。 可读的代码更易于分析和审核。 如果代码过于冗长，其主要目的可能会淹没在辅助结构的“噪音”中。 如果代码过于简洁，则其中的程序可能难以阅读和理解。  Go在简洁和表现力之间保持平衡。 例如，像Java或C ++这样的语言中，辅助结构并不多。 同时，Go结构（例如与错误处理等领域相关的结构）非常清晰且非常详细，从而简化了程序员的工作，并帮助他确保例如已经检查了所有可能的事情。 <br><br>  Go崩溃后具有清晰的错误处理和恢复机制。 完善的运行时错误处理机制是高度可靠的代码的基石。  Go对于返回和分发错误具有严格的规则。 在诸如Node.js的环境中，混合使用来控制程序流的方法（例如回调，promise和异步函数）通常会导致未处理的错误，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未处理的对promise的拒绝</a> 。 在类似事件发生后恢复程序几乎<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是不可能的</a> 。 <br><br>  Go具有广泛的标准库。 依赖项是一种风险，尤其是当它们的来源是对代码的可靠性没有给予足够重视的项目时。 投入生产的服务器应用程序包含所有依赖项。 而且，如果出现问题，完成的应用程序的开发人员将对此负责，而不是由创建该应用程序的人之一负责。 结果，在为小型项目而编写的项目不堪重负的环境中，创建可靠的应用程序更加困难。 <br><br> 依赖项也是一种安全风险，因为项目的漏洞级别与其最<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不安全的依赖项</a>的漏洞级别相对应。 广泛的标准库Go由其开发人员维护，状态良好，它的存在减少了对外部依赖项的需求。 <br><br> 开发速度高。 像Node.js这样的环境的关键特征是其极短的开发周期。 编写代码花费的时间更少，因此，程序员的工作效率更高。 <br><br>  Go也有很高的发展速度。 一组用于构建项目的工具足够快，可以立即查看实际的代码。 编译时间非常短；结果，在Go上运行的代码被视为未经编译但已被解释。 而且，该语言具有足够的抽象，例如垃圾回收系统，它使开发人员可以直接努力实现其项目的功能，而不用解决辅助任务。 <br><br><h2>  <font color="#3AC1EF">实际实验</font> </h2><br> 既然我们已经表达了足够的一般要点，现在该看一下代码了。 我们需要一个足够简单的示例，以便在研究它时，我们可以专注于开发方法，但是与此同时，它应该足够先进，以便我们在探讨它时可以谈一谈。 我认为从日常工作中获取一些东西是最容易的。 因此，我建议分析服务器的创建，该服务器处理类似于金融交易的事物。 该服务器的用户将能够检查与其帐户关联的帐户余额。 此外，他们将能够将资金从一个帐户转移到另一个帐户。 <br><br> 我们将尽量不使该示例复杂化。 我们的系统将有一台服务器。 我们不会与认证和密码系统联系。 这些是工作项目的组成部分。 但是，我们需要关注此类项目的核心，以展示如何使其尽可能可靠。 <br><br><h3>  <font color="#3AC1EF">a将复杂的项目分为便于管理的部分</font> </h3><br> 复杂性是可靠性的最大敌人。 处理复杂系统时，最好的方法之一就是应用众所周知的“分而治之”原则。 该任务需要分为几个小子任务，并分别解决每个子任务。 哪一方来处理我们的任务？ 我们将遵循<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">共同责任</a>的原则。 我们项目的每个部分都应该有自己的责任范围。 <br><br> 这个想法非常适合流行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微服务</a>架构。 我们的服务器将包含单独的服务。 每个服务将有一个明确定义的职责范围以及一个与其他服务进行交互的清晰描述的界面。 <br><br> 以这种方式构造服务器后，我们将能够决定每个服务的工作方式。 所有服务都可以在同一过程中一起执行，您可以从每个服务中创建单独的服务器并使用RPC建立它们之间的交互，还可以将服务分开并在单独的计算机上运行它们。 <br><br> 我们不会使任务复杂化，我们将选择最简单的选项。 即，所有服务将在同一过程中执行，它们将直接交换信息，例如库。 如有必要，将来可以轻松地查看和更改此体系结构解决方案。 <br><br> 那么我们需要什么服务？ 我们的服务器可能过于简单，无法将其划分为多个部分，但是出于教育目的，我们仍将其划分。 我们需要响应旨在检查余额和执行交易的客户端HTTP请求。 其中一项服务可以与客户端的HTTP接口配合使用。  <code>PublicApi</code>称之为<code>PublicApi</code> 。 另一个服务将拥有有关系统状态的信息-资产负债表。  <code>StateStorage</code>称之为<code>StateStorage</code> 。 第三项服务将结合上述两者，并实现旨在改变余额的“合同”逻辑。 第三项服务的任务将是合同的执行。  <code>VirtualMachine</code>称之为<code>VirtualMachine</code> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/a04/79b/8a2a0479b551df5fd2a3c46e67bb46a7.png"></div><br>  <i><font color="#999999">应用服务器架构</font></i> <br><br> 将这些服务的代码放在项目文件夹<code>/services/publicapi</code> ， <code>/services/virtualmachine</code>和<code>/services/statestorage</code> 。 <br><br><h3>  <font color="#3AC1EF">▍明确服务职责</font> </h3><br> 在实施服务的过程中，我们希望能够单独使用它们。 甚至有可能在不同的程序员之间分配这些服务的开发。 由于服务是相互依赖的，并且我们希望并行化它们的开发，因此我们需要开始对它们用于相互交互的接口进行清晰的定义。 使用这些接口，我们可以为每个接口之外的所有内容准备存根，从而自动测试服务。 <br><br> 如何描述界面？ 一种选择是记录所有内容，但是文档具有过时的特性，在处理项目的过程中，文档和代码之间的差异开始累积。 另外，我们可以使用Go接口声明。 这是一个有趣的选项，但是最好描述该接口，以便此描述不依赖于特定的编程语言。 在一个非常实际的情况下，这对我们很有用，如果在进行项目的过程中决定使用其他语言来实现其某些服务，则其功能将更适合解决他们的问题。 <br><br> 描述接口的一种方法是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">protobuf</a> 。 这是用于描述消息和服务端点的简单语言和独立于语言的协议。 <br><br> 让我们从<code>StateStorage</code>服务的接口开始。 我们将以键值视图结构的形式呈现应用程序的状态。 这是<code>statestorage.proto</code>文件的代码： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> statestorage; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> StateStorage { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> WriteKey (WriteKeyInput) returns (WriteKeyOutput); <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> ReadKey (ReadKeyInput) returns (ReadKeyOutput); } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> WriteKeyInput { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> key = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> value = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> WriteKeyOutput { } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> ReadKeyInput { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> key = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> ReadKeyOutput { <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br> 尽管客户端通过<code>PublicApi</code>服务使用HTTP，但它也不会干扰通过与上述相同的方式（ <code>publicapi.proto</code>文件）描述的明文接口： <br><br><pre> <code class="hljs pgsql">syntax = "proto3"; package publicapi; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "protocol/transactions.proto"; service PublicApi { rpc Transfer (TransferInput) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> (TransferOutput); rpc GetBalance (GetBalanceInput) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> (GetBalanceOutput); } message TransferInput { protocol.<span class="hljs-keyword"><span class="hljs-keyword">Transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; } message TransferOutput { string success = <span class="hljs-number"><span class="hljs-number">1</span></span>; int32 result = <span class="hljs-number"><span class="hljs-number">2</span></span>; } message GetBalanceInput { protocol.Address <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; } message GetBalanceOutput { string success = <span class="hljs-number"><span class="hljs-number">1</span></span>; int32 result = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br> 现在我们需要描述<code>Transaction</code>和<code>Address</code>数据结构（ <code>transactions.proto</code>文件）： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> protocol; <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Address { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> username = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Transaction { <span class="hljs-attribute"><span class="hljs-attribute">Address</span></span> from = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">Address</span></span> to = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> amount = <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br> 在该项目中，服务的原始描述位于<code>/types/services</code>文件夹中，而通用数据结构的描述位于<code>/types/protocol</code>文件夹中。 <br><br> 接口说明准备好后，就可以将其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译</a>为Go代码。 <br><br> 这种方法的优点是，与接口描述不匹配的代码根本不会出现在编译结果中。 使用替代方法将需要我们编写特殊的测试来验证代码是否与接口描述匹配。 <br><br> 完整定义，生成的Go文件和编译说明可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到。 这得益于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Square Engineering</a>及其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">goprotowrap</a>的开发。 <br><br> 请注意，在我们的项目中，未实现传输层RPC，并且服务之间的数据交换看起来像普通的库调用。 当我们准备在不同服务器上分发服务时，可以向系统添加诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gRPC</a>的传输层。 <br><br><h3>  <font color="#3AC1EF">project项目中使用的测试类型</font> </h3><br> 由于测试是高度可靠的代码的关键，因此我建议我们首先讨论将为项目编写的测试。 <br><br><h4> 单元测试 </h4><br> 单元测试是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试金字塔</a>的核心。 我们将单独测试每个模块。 什么是模块？ 在Go中，我们可以将模块视为包中的独立文件。 例如，如果我们有文件<code>/services/publicapi/handlers.go</code> ，则将其单元测试放在<code>/services/publicapi/handlers_test.go</code>的同一包中。 <br><br> 最好将单元测试与测试代码放在同一程序包中，以使测试可以访问未导出的变量和函数。 <br><br><h4> 服务测试 </h4><br> 以下测试类型有不同的名称。 这些就是所谓的服务，集成或组件测试。 他们的本质是采取几个模块并测试他们的联合工作。 这些测试比测试金字塔中的单元测试高一个级别。 在我们的案例中，我们将使用集成测试来测试整个服务。 这些测试确定服务的规格。 例如，用于<code>StateStorage</code>服务的测试将放置在<code>/services/statestorage/spec</code>文件夹中。 <br><br> 最好将这些测试放在与所测试的代码所处的程序包不同的程序包中，以便仅通过导出的接口来访问此代码的功能。 <br><br><h4> 端到端测试 </h4><br> 这些测试位于测试金字塔的顶部，它们可以帮助检查整个系统及其所有服务。 这样的测试描述了系统的端到端e2e规范，因此我们将它们放在<code>/e2e/spec</code>文件夹中。 <br><br> 端对端测试以及服务测试必须放在与测试代码所在的软件包不同的软件包中，以便只能通过导出的接口来操作系统。 <br><br> 首先应该编写哪些测试？ 从“金字塔”的基础开始，然后向上移动？ 还是从顶部开始然后向下走？ 这些方法中的任何一种都有生命权。 自上而下方法的好处是首先为整个系统创建规范。 通常在工作之初就讨论整个系统的功能是最容易的。 即使我们错误地将系统划分为单独的服务，系统规格也将保持不变。 此外，这将帮助我们理解较低级别的操作是错误的。 <br><br> 自上而下的方法的缺点是，端到端测试是在创建整个要开发的系统时在所有其他测试之后使用的测试。 这意味着它们将长时间产生错误。 在为我们的项目编写测试时，我们将使用这种方法。 <br><br><h3>  <font color="#3AC1EF">▍测试开发</font> </h3><br><h4> 端到端测试开发 </h4><br> 在创建测试之前，我们需要确定是否要编写测试而不使用任何辅助工具或使用某种框架。 依赖于框架，将其用作开发依赖项，比依赖于投入生产的代码中的框架的危险要小。 在我们的案例中，由于标准的Go库不具有不错的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BDD</a>支持，并且这种格式非常适合描述规范，因此我们将选择一个工作选项，其中包括使用框架。 <br><br> 有许多伟大的框架可以满足我们的需求。 其中包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GoConvey</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ginkgo</a> 。 <br><br> 就个人而言，我喜欢结合使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ginkgo</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gomega</a> （糟糕的名称，但要做什么）的组合，这些组合使用语法结构如<code>Describe()</code>和<code>It()</code> 。 <br><br> 我们的测试是什么样的？ 例如，这是对用户余额检查机制（ <code>sanity.go</code>文件）的测试： <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> spec <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _ = Describe(<span class="hljs-string"><span class="hljs-string">"Sanity"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( node services.Node ) BeforeEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { node = services.NewNode() node.Start() }) AfterEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { node.Stop() }) It(<span class="hljs-string"><span class="hljs-string">"should show balances with GET /api/balance"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { resp, err := http.Get(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/balance?from=user1"</span></span>) Expect(err).ToNot(HaveOccurred()) Expect(resp.StatusCode).To(Equal(http.StatusOK)) Expect(ResponseBodyAsString(resp)).To(Equal(<span class="hljs-string"><span class="hljs-string">"0"</span></span>)) }) })</code> </pre> <br> 由于可以通过HTTP从外部访问服务器，因此我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://golang.org/pkg/net/">http.Get</a>使用其Web API。 事务测试呢？ 这是相应测试的代码： <br><br><pre> <code class="hljs lisp">It(<span class="hljs-string"><span class="hljs-string">"should transfer funds with POST /api/transfer"</span></span>, func() { resp, err <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> http.Get(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/transfer?from=user1&amp;to=user2&amp;amount=17"</span></span>) Expect(<span class="hljs-name"><span class="hljs-name">err</span></span>).ToNot(<span class="hljs-name"><span class="hljs-name">HaveOccurred</span></span>()) Expect(<span class="hljs-name"><span class="hljs-name">resp</span></span>.StatusCode).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-name"><span class="hljs-name">http</span></span>.StatusOK)) Expect(<span class="hljs-name"><span class="hljs-name">ResponseBodyAsString</span></span>(<span class="hljs-name"><span class="hljs-name">resp</span></span>)).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-string"><span class="hljs-string">"-17"</span></span>)) resp, err = http.Post(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/balance?from=user2"</span></span>, <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) Expect(<span class="hljs-name"><span class="hljs-name">err</span></span>).ToNot(<span class="hljs-name"><span class="hljs-name">HaveOccurred</span></span>()) Expect(<span class="hljs-name"><span class="hljs-name">resp</span></span>.StatusCode).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-name"><span class="hljs-name">http</span></span>.StatusOK)) Expect(<span class="hljs-name"><span class="hljs-name">ResponseBodyAsString</span></span>(<span class="hljs-name"><span class="hljs-name">resp</span></span>)).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-string"><span class="hljs-string">"17"</span></span>)) })</code> </pre><br> 测试代码完美地描述了它们的本质，甚至可以代替文档。 如您所见，我们承认存在负的用户帐户余额。 这是我们项目的功能。 如果禁止，则此决定将反映在测试中。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>完整的测试代码 <br><br><h4> 服务测试开发 </h4><br> 现在，在开发了端到端测试之后，我们沿测试金字塔走了下来，然后继续创建服务测试。 这些测试是针对每种单独的服务开发的。 我们选择一个依赖于另一个服务的服务，因为这种情况比为独立服务开发测试更有趣。 <br><br> 让我们从<code>VirtualMachine</code>服务开始。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里，</a>您可以找到带有此服务原型说明的界面。 由于<code>VirtualMachine</code>服务依赖于<code>StateStorage</code>服务并对其进行调用，因此我们需要为<code>StateStorage</code>服务创建一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模拟对象</a> ，以便<code>StateStorage</code>测试<code>VirtualMachine</code>服务。 存根对象允许我们在测试期间控制<code>StateStorage</code>响应。 <br><br> 如何在Go中实现存根对象？ 这可以完全通过语言来完成，而无需辅助工具，或者您可以诉诸于适当的库，此外，这将使在测试过程中使用语句成为可能。 为此，我更喜欢使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">go-mock</a>库。 <br><br> 我们将存根代码放在文件<code>/services/statestorage/mock.go</code> 。 最好将存根对象与它们模仿的实体放在同一位置，以使它们可以访问未导出的变量和函数。 此阶段的存根是服务的示意性实现，但是，随着服务的发展，我们可能需要开发存根的实现。 这是存根对象（ <code>mock.go</code>文件）的代码： <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> statestorage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MockService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mock.Mock } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.Called() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.Called() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStarted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.Called().Bool(<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input *statestorage.WriteKeyInput)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*statestorage.WriteKeyOutput, error)</span></span></span></span> { ret := s.Called(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret.Get(<span class="hljs-number"><span class="hljs-number">0</span></span>).(*statestorage.WriteKeyOutput), ret.Error(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input *statestorage.ReadKeyInput)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*statestorage.ReadKeyOutput, error)</span></span></span></span> { ret := s.Called(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret.Get(<span class="hljs-number"><span class="hljs-number">0</span></span>).(*statestorage.ReadKeyOutput), ret.Error(<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br> 如果将各个服务的开发交给不同的程序员，则首先创建存根并将其传递给团队是有意义的。 <br><br> 让我们回到为<code>VirtualMachine</code>开发服务测试的过程。 我应该在这里检查什么情况？ 最好专注于服务<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">接口</a>和每个端点的设计测试。 我们使用代表<code>"GetBalance"</code>方法的参数为<code>CallContract()</code>端点实现测试。 以下是相应的代码（ <code>contracts.go</code>文件）： <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> spec <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _ = Describe(<span class="hljs-string"><span class="hljs-string">"Contracts"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( service uut.Service stateStorage *_statestorage.MockService ) BeforeEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service = uut.NewService() stateStorage = &amp;_statestorage.MockService{} service.Start(stateStorage) }) AfterEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service.Stop() }) It(<span class="hljs-string"><span class="hljs-string">"should support 'GetBalance' contract method"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { stateStorage.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, &amp;statestorage.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}).Return(&amp;statestorage.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">100</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) addr := protocol.Address{Username: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>} out, err := service.CallContract(&amp;virtualmachine.CallContractInput{Method: <span class="hljs-string"><span class="hljs-string">"GetBalance"</span></span>, Arg: &amp;addr}) Expect(err).ToNot(HaveOccurred()) Expect(out.Result).To(BeEquivalentTo(<span class="hljs-number"><span class="hljs-number">100</span></span>)) Expect(stateStorage).To(ExecuteAsPlanned()) }) })</code> </pre><br> 请注意，我们正在测试的服务<code>VirtualMachine</code>通过简单的依赖项注入机制在<code>Start()</code>方法中获得了指向其依赖项<code>StateStorage</code>的指针。 这是我们传递存根对象的实例的地方。 另外，请注意<code>stateStorage.When("ReadKey", &amp;statestorage.ReadKeyInput{Key…</code> ，在这里告诉存根对象访问它时的行为。当<code>ReadKey</code>方法时，它应该返回一个值100.然后，在<code>Expect(stateStorage).To(ExecuteAsPlanned())</code> ，我们检查此命令是否仅被调用一次。 <br><br> 类似的测试成为该服务的规范。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到<code>VirtualMachine</code>服务的全套测试。 我们项目的其他服务的测试套件可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到。 <br><br><h4> 单元测试开发 </h4><br> 也许<code>"GetBalance"</code>方法的合同的实现太简单了，所以<code>"GetBalance"</code>谈谈实现稍微复杂一些的<code>"Transfer"</code>方法。 用这种方法表示的将资金从一个帐户转移到另一个帐户的合同需要读取资金的发送者和接收者的余额数据，以计算新的余额并记录应用程序状态下发生的情况。 所有这些的服务测试与我们刚刚实现的服务测试（ <code>transactions.go</code>文件）非常相似： <br><br><pre> <code class="hljs lisp">It(<span class="hljs-string"><span class="hljs-string">"should support 'Transfer' transaction method"</span></span>, func() { stateStorage.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">100</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) stateStorage.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">50</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) stateStorage.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">90</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.WriteKeyOutput{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) stateStorage.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">60</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.WriteKeyOutput{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> protocol.Transaction{From: <span class="hljs-symbol"><span class="hljs-symbol">&amp;protocol</span></span>.Address{Username: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}, To: <span class="hljs-symbol"><span class="hljs-symbol">&amp;protocol</span></span>.Address{Username: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>}, Amount: <span class="hljs-number"><span class="hljs-number">10</span></span>} out, err <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> service.ProcessTransaction(<span class="hljs-name"><span class="hljs-name">&amp;virtualmachine</span></span>.ProcessTransactionInput{Method: <span class="hljs-string"><span class="hljs-string">"Transfer"</span></span>, Arg: <span class="hljs-symbol"><span class="hljs-symbol">&amp;t</span></span>}) Expect(<span class="hljs-name"><span class="hljs-name">err</span></span>).ToNot(<span class="hljs-name"><span class="hljs-name">HaveOccurred</span></span>()) Expect(<span class="hljs-name"><span class="hljs-name">out</span></span>.Result).To(<span class="hljs-name"><span class="hljs-name">BeEquivalentTo</span></span>(<span class="hljs-number"><span class="hljs-number">90</span></span>)) Expect(<span class="hljs-name"><span class="hljs-name">stateStorage</span></span>).To(<span class="hljs-name"><span class="hljs-name">ExecuteAsPlanned</span></span>()) })</code> </pre> <br> 在处理项目的过程中，我们最终开始创建其内部机制，并在文件<code>processor.go</code>创建一个模块，其中包含合同的实现。 这是原始版本（ <code>processor.go</code>文件）： <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> virtualmachine <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processTransfer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fromUsername </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, toUsername </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, amount </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { fromBalance, err := s.stateStorage.ReadKey(&amp;statestorage.ReadKeyInput{Key: fromUsername}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } toBalance, err := s.stateStorage.ReadKey(&amp;statestorage.ReadKeyInput{Key: toUsername}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } _, err = s.stateStorage.WriteKey(&amp;statestorage.WriteKeyInput{Key: fromUsername, Value: fromBalance.Value - amount}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } _, err = s.stateStorage.WriteKey(&amp;statestorage.WriteKeyInput{Key: toUsername, Value: toBalance.Value + amount}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromBalance.Value - amount, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br> 此设计满足了服务测试，但是在我们的案例中，集成测试仅包含对基本方案的测试。 那么临界情况和潜在的失败呢？ 如您所见，我们对<code>StateStorage</code>任何调用<code>StateStorage</code>可能失败。 如果需要通过测试覆盖100％的代码，我们需要检查所有这些情况。 单元测试非常适合实施此类测试。 <br><br> 由于我们将使用不同的输入数据多次调用该函数，并模拟参数以到达代码的所有分支，因此，为了使此过程更高效，我们可以采用基于表的测试。  Go倾向于避免异国情调的单元测试框架。 我们可以拒绝<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">银杏</a> ，但可能我们应该离开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gomega</a> 。 因此，此处执行的检查将类似于我们先前测试中执行的检查。 这是测试代码（文件<code>processor_test.go</code> ）： <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> virtualmachine import ... var transferTable = []struct{ to <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //  ,    read1Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       read2Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       write1Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       write2Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> int32 //   errs bool //        }{ {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>}, } func TestTransfer(t *testing.T) { Ω := NewGomegaWithT(t) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tt := range transferTable { s := NewService() ss := &amp;_statestorage.MockService{} s.Start(ss) ss.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, &amp;statestorage.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}).Return(&amp;statestorage.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">100</span></span>}, tt.read1Err) ss.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, &amp;statestorage.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>}).Return(&amp;statestorage.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">50</span></span>}, tt.read2Err) ss.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, &amp;statestorage.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">90</span></span>}).Return(&amp;statestorage.WriteKeyOutput{}, tt.write1Err) ss.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, &amp;statestorage.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">60</span></span>}).Return(&amp;statestorage.WriteKeyOutput{}, tt.write2Err) <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>, err := s.(*service).processTransfer(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>, tt.to, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tt.errs { Ω.Expect(err).To(HaveOccurred()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Ω.Expect(err).ToNot(HaveOccurred()) Ω.Expect(<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>).To(BeEquivalentTo(tt.<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>)) } } }</code> </pre> <br>     «Ω» —  ,    —    (     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gomega</a> ).          . <br><br>        ,        TDD,          ,     ,     .       <code>processTransfer()</code>         . <br><br>       <code>VirtualMachine</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . <br><br>    100%   .    ,    .             . <br><br>   ,        ?   .        , ,    ,     . <br><br><h3> <font color="#3AC1EF">▍  -</font> </h3><br>              .         ?  HTTP-  Go     (goroutine).     ,  —        ,     . ,      ,  ,   . <br><br>           -               . ,   ,   ,          ,        .  -     <code>/e2e/stress</code> .   - ( <code>stress.go</code> ): <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> stress import ... const NUM_TRANSACTIONS = <span class="hljs-number"><span class="hljs-number">20000</span></span> const NUM_USERS = <span class="hljs-number"><span class="hljs-number">100</span></span> const TRANSACTIONS_PER_BATCH = <span class="hljs-number"><span class="hljs-number">200</span></span> const BATCHES_PER_SEC = <span class="hljs-number"><span class="hljs-number">40</span></span> var <span class="hljs-number"><span class="hljs-number">_</span></span> = Describe(<span class="hljs-string"><span class="hljs-string">"Transaction Stress Test"</span></span>, func() { var ( node services.Node ) BeforeEach(func() { node = services.NewNode() node.Start() }) AfterEach(func() { node.Stop() }) It(<span class="hljs-string"><span class="hljs-string">"should handle lots and lots of transactions"</span></span>, func() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  HTTP-     transport := http.Transport{ IdleConnTimeout: time.Second*<span class="hljs-number"><span class="hljs-number">20</span></span>, MaxIdleConns: TRANSACTIONS_PER_BATCH*<span class="hljs-number"><span class="hljs-number">10</span></span>, MaxIdleConnsPerHost: TRANSACTIONS_PER_BATCH*<span class="hljs-number"><span class="hljs-number">10</span></span>, } client := &amp;http.Client{Transport: &amp;transport} //      ledger := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[string]int32{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_USERS; i++ { ledger[fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"user%d"</span></span>, i+<span class="hljs-number"><span class="hljs-number">1</span></span>)] = <span class="hljs-number"><span class="hljs-number">0</span></span> } //     HTTP   rand.Seed(<span class="hljs-number"><span class="hljs-number">42</span></span>) done := make(chan error, TRANSACTIONS_PER_BATCH) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_TRANSACTIONS / TRANSACTIONS_PER_BATCH; i++ { log.Printf(<span class="hljs-string"><span class="hljs-string">"Sending %d transactions... (batch %d out of %d)"</span></span>, TRANSACTIONS_PER_BATCH, i+<span class="hljs-number"><span class="hljs-number">1</span></span>, NUM_TRANSACTIONS / TRANSACTIONS_PER_BATCH) time.Sleep(time.Second / BATCHES_PER_SEC) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; TRANSACTIONS_PER_BATCH; j++ { from := randomizeUser() to := randomizeUser() amount := randomizeAmount() ledger[from] -= amount ledger[to] += amount go sendTransaction(client, from, to, amount, &amp;done) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; TRANSACTIONS_PER_BATCH; j++ { err := &lt;- done Expect(err).ToNot(HaveOccurred()) } } //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_USERS; i++ { user := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"user%d"</span></span>, i+<span class="hljs-number"><span class="hljs-number">1</span></span>) resp, err := client.Get(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/balance?from=%s"</span></span>, user)) Expect(err).ToNot(HaveOccurred()) Expect(resp.StatusCode).To(Equal(http.StatusOK)) Expect(ResponseBodyAsString(resp)).To(Equal(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, ledger[user]))) } }) }) func randomizeUser() string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"user%d"</span></span>, rand.Intn(NUM_USERS)+<span class="hljs-number"><span class="hljs-number">1</span></span>) } func randomizeAmount() int32 { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rand.Int31n(<span class="hljs-number"><span class="hljs-number">1000</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span> } func sendTransaction(client *http.Client, from string, to string, amount int32, done *chan error) { url := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/transfer?from=%s&amp;to=%s&amp;amount=%d"</span></span>, from, to, amount) resp, err := client.Post(url, <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, nil) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == nil { ioutil.ReadAll(resp.Body) resp.Body.Close() } *done &lt;- err }</code> </pre> <br>    ,  -   .           (       <code>rand.Seed(42)</code> )  ,    .         .     ,            ,  — ,     . <br><br>    -  HTTP   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>          TCP- (     ,     ,           ).  ,  ,              200     <code>IdleConnection</code>    TCP-   .       ,      100. <br><br>  …   : <br><br><pre> <code class="hljs go">fatal error: concurrent <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> writes goroutine <span class="hljs-number"><span class="hljs-number">539</span></span> [running]: runtime.throw(<span class="hljs-number"><span class="hljs-number">0x147bf</span></span>60, <span class="hljs-number"><span class="hljs-number">0x15</span></span>) /usr/local/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/<span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">616</span></span> +<span class="hljs-number"><span class="hljs-number">0x81</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc4207159d</span></span>8 sp=<span class="hljs-number"><span class="hljs-number">0xc4207159b8</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x102ca01</span></span> runtime.mapassign_faststr(<span class="hljs-number"><span class="hljs-number">0x13f</span></span>5140, <span class="hljs-number"><span class="hljs-number">0xc4201ca0c0</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4203a8097</span></span>, <span class="hljs-number"><span class="hljs-number">0x6</span></span>, <span class="hljs-number"><span class="hljs-number">0x1012001</span></span>) /usr/local/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/hashmap_fast.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">703</span></span> +<span class="hljs-number"><span class="hljs-number">0x3e9</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc420715a48</span></span> sp=<span class="hljs-number"><span class="hljs-number">0xc4207159d</span></span>8 pc=<span class="hljs-number"><span class="hljs-number">0x100d</span></span>879 services/statestorage.(*service).WriteKey(<span class="hljs-number"><span class="hljs-number">0xc42000c060</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4209e6800</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4206491a0</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>) services/statestorage/methods.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span> +<span class="hljs-number"><span class="hljs-number">0x10c</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc420715a88</span></span> sp=<span class="hljs-number"><span class="hljs-number">0xc420715a48</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x138339c</span></span> services/virtualmachine.(*service).processTransfer(<span class="hljs-number"><span class="hljs-number">0xc4201ca090</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4203a8097</span></span>, <span class="hljs-number"><span class="hljs-number">0x6</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4203a80a1</span></span>, <span class="hljs-number"><span class="hljs-number">0x6</span></span>, <span class="hljs-number"><span class="hljs-number">0x2a4</span></span>, <span class="hljs-number"><span class="hljs-number">0xc420715b30</span></span>, <span class="hljs-number"><span class="hljs-number">0x1012928</span></span>, <span class="hljs-number"><span class="hljs-number">0x40</span></span>) services/virtualmachine/processor.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span> +<span class="hljs-number"><span class="hljs-number">0x16e</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc420715ad</span></span>0 sp=<span class="hljs-number"><span class="hljs-number">0xc420715a88</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x13840ee</span></span> services/virtualmachine.(*service).ProcessTransaction(<span class="hljs-number"><span class="hljs-number">0xc4201ca090</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4209e67c0</span></span>, <span class="hljs-number"><span class="hljs-number">0x30</span></span>, <span class="hljs-number"><span class="hljs-number">0x1433660</span></span>, <span class="hljs-number"><span class="hljs-number">0x12a1d</span></span>01) Ginkgo ran <span class="hljs-number"><span class="hljs-number">1</span></span> suite in <span class="hljs-number"><span class="hljs-number">1.288879763s</span></span> Test Suite Failed</code> </pre> <br>  ?   <code>StateStorage</code>       ( <code>map</code> ),   . ,     ,            .     ,           <code>map</code>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sync.map</a> .     . <br><br>     <a href="">processTransfer()</a> .         ,   —      .         , ,         ,        ,     .     ,          <code>processTransfer()</code> . <a href=""></a>  . <br><br>    ,   . ,    ,     . <br><br><pre> <code class="hljs go">e2e/stress/transactions.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">44</span></span> Expected &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">-7498</span></span> to equal &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">-7551</span></span> e2e/stress/transactions.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">82</span></span> ------------------------------ Ginkgo ran <span class="hljs-number"><span class="hljs-number">1</span></span> suite in <span class="hljs-number"><span class="hljs-number">5.251593179s</span></span> Test Suite Failed</code> </pre> <br>       ,    . ,   ,          ( ,           ).    ,   <a href=""></a> ,    . <br><br>  —  .    TDD         .   ?           ,       100%?!   ,    —      .    <code>processTransfer()</code>      ,       ,    . <br><br>             .  ,       <a href=""></a>   ,   . <a href=""></a>    . <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> , ,  ,     -,      ,      ,  ?     ?   — . <br><br>       ,     -.  ,  «»  <code>processTransfer()</code>      .  ,  ,    <a href=""></a> .         ,   — .    ,      -       .     ,        ,        . <br><br>     . ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> .  ,     <code>StateStorage</code>   <code>WriteKey</code> ,     , , ,     <code>WriteKeys</code>    ,         ,       . <br><br>   ,        :          .            « ».       -,        ,  ,     ,    ,      .   —     .     ,   ,    —      . <br><br>       ,       —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  GitHub.          .  ,   ,    , , ,     ,      . <br><br>  <b>亲爱的读者们！</b>        ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413681/">https://habr.com/ru/post/zh-CN413681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413669/index.html">三星IT学校：教学生如何开发移动应用程序</a></li>
<li><a href="../zh-CN413673/index.html">关于节点新旧版本的性能问题</a></li>
<li><a href="../zh-CN413675/index.html">小丑2018：匿名Java开发人员俱乐部</a></li>
<li><a href="../zh-CN413677/index.html">ROS在EduMIP自平衡机器人上启动</a></li>
<li><a href="../zh-CN413679/index.html">角度6。 PWA。 延迟加载模块。 在Firebase中自动部署</a></li>
<li><a href="../zh-CN413683/index.html">ILV已解锁700万个IP地址。 保持锁定400万</a></li>
<li><a href="../zh-CN413689/index.html">Debian + Postfix + Dovecot +多域+ SSL + IPv6 + OpenVPN +多接口+ SpamAssassin-learn +绑定</a></li>
<li><a href="../zh-CN413691/index.html">开始</a></li>
<li><a href="../zh-CN413693/index.html">手工制作：可自行完成网上交易的可编程键盘</a></li>
<li><a href="../zh-CN413695/index.html">Messenger安全性：为什么将消息存储在区块链上可能是一个好主意</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>