<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛅 😢 🏅 Lerne OpenGL. Lektion 7.2 - Zeichnen von Text 👨🏿‍🤝‍👨🏼 💛 ♟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Irgendwann in Ihrem Grafikabenteuer möchten Sie Text über OpenGL ausgeben. Entgegen dem, was Sie vielleicht erwarten, ist es mit einer Bibliothek auf ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lerne OpenGL. Lektion 7.2 - Zeichnen von Text</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473990/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Bild" align="left" width="300">  Irgendwann in Ihrem Grafikabenteuer möchten Sie Text über OpenGL ausgeben.  Entgegen dem, was Sie vielleicht erwarten, ist es mit einer Bibliothek auf niedriger Ebene wie OpenGL ziemlich schwierig, eine einfache Zeile auf dem Bildschirm zu erhalten.  Wenn Sie nicht mehr als 128 verschiedene Zeichen zum Zeichnen von Text benötigen, ist dies nicht schwierig.  Schwierigkeiten treten auf, wenn die Zeichen nicht mit Höhe, Breite und Versatz übereinstimmen.  Je nachdem, wo Sie wohnen, benötigen Sie möglicherweise mehr als 128 Zeichen.  Aber was ist, wenn Sie Sonderzeichen, mathematische oder musikalische Zeichen möchten?  Sobald Sie verstehen, dass das Zeichnen von Text nicht die einfachste Aufgabe ist, werden Sie feststellen, dass er höchstwahrscheinlich nicht zu einer so einfachen API wie OpenGL gehören sollte. </p><br><p> Da OpenGL keine Möglichkeit zum Rendern von Text bietet, liegen alle Schwierigkeiten in diesem Fall bei uns.  Da es kein grafisches Grundelement "Symbol" gibt, müssen wir es selbst erfinden.  Es gibt bereits vorgefertigte Beispiele: Zeichnen Sie ein Symbol über <code>GL_LINES</code> , erstellen Sie 3D-Modelle von Symbolen oder zeichnen Sie Symbole auf flachen Vierecken im dreidimensionalen Raum. </p><br><p>  Meistens sind Entwickler <s>zu faul, um</s> <s>Kaffee</s> <s>zu</s> <s>trinken und</s> die letzte Option zu wählen.  Das Zeichnen dieser strukturierten Vierecke ist nicht so schwierig wie die Auswahl der richtigen Textur.  In diesem Tutorial lernen wir einige Möglichkeiten kennen und schreiben unseren erweiterten, aber flexiblen Textrenderer mit FreeType. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Teil 1. Erste Schritte</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fenstererstellung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Fenster</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Dreieck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transformationen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koordinatensysteme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kamera</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 2. Grundbeleuchtung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farben</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlagen der Beleuchtung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehrere Lichtquellen</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 3. Laden Sie 3D-Modelle herunter</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assimp-Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesh-Polygon-Klasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3D-Modellklasse</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 4. Erweiterte OpenGL-Funktionen</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tiefentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schablonentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farbmischung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesichter schneiden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bildpuffer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubische Karten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Datenverarbeitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte GLSL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geometrischer Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Instanz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glätten</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 5. Erweiterte Beleuchtung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Beleuchtung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blinn Fong Modell</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gammakorrektur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Omnidirektionale Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normale Zuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parallaxenabbildung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blüte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgeschobenes Rendern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 6. Züchterrechte</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theorie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analytische Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diffuse Bestrahlung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiegelexposition</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 7. Übung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debuggen</a> </li><li>  <strong>Textwiedergabe</strong> </li></ol></div></div></div></div><br><h1 id="klassika-rastrovye-shrifty">  Klassiker: Raster-Schriftarten </h1><br><p>  Es war einmal <s>in der Zeit der Dinosaurier.</s> Zum Rendern <s>von</s> Text gehörte das Auswählen (oder Erstellen) einer Schriftart für die Anwendung und das Kopieren der gewünschten Zeichen auf eine große Textur, die als Bitmap-Schriftart bezeichnet wird.  Diese Textur enthält alle notwendigen Zeichen in bestimmten Teilen.  Diese Zeichen werden Glyphen genannt.  Jeder Glyphe ist ein bestimmter Bereich von Texturkoordinaten zugeordnet.  Jedes Mal, wenn Sie einen Charakter zeichnen, wählen Sie eine bestimmte Glyphe aus und zeichnen nur den gewünschten Teil auf einem flachen Quad. </p><br><p><img src="https://habrastorage.org/webt/0q/dd/sm/0qddsmwzcxldp9s0kvohcz2qgea.png"></p><br><p>  Hier können Sie sehen, wie wir den Text "OpenGL" rendern würden.  Wir nehmen die Rasterschrift und probieren die erforderlichen Glyphen aus der Textur aus. Dabei wählen wir sorgfältig die Texturkoordinaten aus, die wir über mehrere Vierecke zeichnen.  Wenn Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mischen aktivieren</a> und den Hintergrund transparent halten, wird eine Zeichenfolge auf dem Bildschirm angezeigt.  Diese Bitmap-Schriftart wurde mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codehead-Bitmap-Schriftgenerator</a> generiert. </p><br><p>  Dieser Ansatz hat Vor- und Nachteile.  Dieser Ansatz ist einfach zu implementieren, da Bitmap-Schriftarten bereits gerastert sind.  Dies ist jedoch nicht immer bequem.  Wenn Sie eine andere Schriftart benötigen, müssen Sie eine neue Bitmap-Schriftart generieren.  Darüber hinaus werden durch Erhöhen der Zeichengröße schnell pixelige Kanten angezeigt.  Darüber hinaus sind Bitmap-Schriftarten häufig an einen kleinen Zeichensatz gebunden, sodass Unicode-Zeichen höchstwahrscheinlich nicht angezeigt werden. </p><br><p>  Diese Technik war vor nicht allzu langer Zeit beliebt (und bleibt immer noch beliebt), da sie sehr schnell ist und auf jeder Plattform funktioniert.  Bisher gibt es jedoch andere Ansätze zum Rendern von Text.  Eine davon ist das Rendern von TrueType-Schriftarten mit FreeType. </p><br><h1 id="sovremennost-freetype">  Moderne: FreeType </h1><br><p>  FreeType ist eine Bibliothek, die Schriftarten herunterlädt, in Bitmaps rendert und Unterstützung für einige schriftartenbezogene Vorgänge bietet.  Diese beliebte Bibliothek wird unter Mac OS X, Java, Qt, PlayStation, Linux und Android verwendet.  Die Möglichkeit, TrueType-Schriftarten zu laden, macht diese Bibliothek attraktiv genug. </p><br><p>  Eine TrueType-Schriftart ist eine Sammlung von Glyphen, die nicht durch Pixel, sondern durch mathematische Formeln definiert sind.  Wie bei Vektorbildern kann ein gerastertes Schriftbild basierend auf der bevorzugten Schriftgröße generiert werden.  Mit TrueType-Schriftarten können Sie problemlos Glyphen unterschiedlicher Größe ohne Qualitätsverlust rendern. </p><br><p>  FreeType kann von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Website</a> heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Sie können FreeType entweder selbst kompilieren oder gegebenenfalls vorkompilierte Versionen auf der Site verwenden.  Denken Sie daran, Ihr Programm mit <code>freetype.lib</code> zu <code>freetype.lib</code> und sicherzustellen, dass der Compiler weiß, wo er nach den Header-Dateien suchen muss. </p><br><p>  Fügen Sie dann die richtigen Header-Dateien hinzu: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ft2build.h&gt; #include FT_FREETYPE_H</span></span></span></span></code> </pre> <br><blockquote>  Da FreeType etwas seltsam gestaltet ist (lassen Sie mich zum Zeitpunkt des Schreibens des Originals wissen, wenn sich etwas geändert hat), können Sie seine Header-Dateien nur im Stammverzeichnis des Ordners mit den Header-Dateien ablegen.  <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> FreeType auf andere Weise verbinden (z. B. <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> ), kann dies zu einem Konflikt mit der Header-Datei führen. </blockquote><p>  Was macht FreeType?  Lädt TrueType-Schriftarten und generiert für jede Glyphe ein Bitmap-Bild und berechnet einige Glyphenmetriken.  Wir können Bitmap-Bilder zum Generieren von Texturen und Positionieren jedes Glyphen in Abhängigkeit von den empfangenen Metriken erhalten. </p><br><p>  Um eine Schriftart herunterzuladen, müssen wir FreeType initialisieren und die Schriftart als Gesicht laden (wie FreeType die Schriftart nennt).  In diesem Beispiel laden wir die TrueType-Schriftart <code>arial.ttf</code> , die aus dem Ordner C: / Windows / Fonts kopiert wurde. </p><br><pre> <code class="cpp hljs">FT_Library ft; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Init_FreeType(&amp;ft)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Could not init FreeType Library"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; FT_Face face; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_New_Face(ft, <span class="hljs-string"><span class="hljs-string">"fonts/arial.ttf"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;face)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Failed to load font"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Jede dieser FreeType-Funktionen gibt im Fehlerfall einen Wert ungleich Null zurück. </p><br><p>  Nachdem wir die <s>Gesichtsschrift</s> geladen haben, müssen wir die gewünschte Schriftgröße angeben, die wir extrahieren werden: </p><br><pre> <code class="cpp hljs">FT_Set_Pixel_Sizes(face, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>);</code> </pre> <br><p>  Diese Funktion legt die Breite und Höhe des Glyphen fest.  Durch Setzen der Breite auf 0 (Null) ermöglicht FreeType die Berechnung der Breite in Abhängigkeit von der eingestellten Höhe. </p><br><p>  Face FreeType enthält eine Sammlung von Glyphen.  Wir können einige Glyphen <code>FT_Load_Char</code> indem <code>FT_Load_Char</code> aufrufen.  Hier versuchen wir die Glyphe <code>X</code> zu laden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Load_Char(face, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, FT_LOAD_RENDER)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYTPE: Failed to load Glyph"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Indem wir <code>FT_LOAD_RENDER</code> als eines der Download-Flags <code>FT_LOAD_RENDER</code> , <code>FT_LOAD_RENDER</code> wir FreeType an, eine 8-Bit-Graustufen-Bitmap zu erstellen, die wir dann wie <code>FT_LOAD_RENDER</code> erhalten können: </p><br><pre> <code class="cpp hljs">face-&gt;glyph-&gt;bitmap;</code> </pre> <br><p>  Mit FreeType geladene Glyphen haben nicht die gleiche Größe wie bei Bitmap-Schriftarten.  Eine mit FreeType generierte Bitmap ist die Mindestgröße für eine bestimmte Schriftgröße und reicht nur für ein Zeichen aus.  Zum Beispiel ein Bitmap-Bild eines Glyphen <code>.</code>  viel kleiner als die Bitmap von Glyphe <code>X</code>  Aus diesem Grund lädt FreeType auch einige Metriken herunter, die angeben, welche Größe und wo sich ein einzelnes Zeichen befinden soll.  Unten sehen Sie ein Bild, das zeigt, welche Metriken FreeType für jede Glyphe berechnet. </p><br><p><img src="https://habrastorage.org/webt/ux/2y/kh/ux2ykhrgznafueqwujrjdqgun9q.png"></p><br><p>  Jedes Symbol befindet sich auf der Grundlinie (horizontale Linie mit einem Pfeil).  Einige befinden sich genau auf der Grundlinie ( <code>X</code> ), andere unter ( <code>g</code> , <code>p</code> ).  Diese Metriken bestimmen genau die Offsets, um Glyphen genau auf der Grundlinie zu positionieren, die Größe der Glyphen anzupassen und herauszufinden, wie viele Pixel Sie zum Zeichnen des nächsten Glyphen übrig lassen müssen.  Das Folgende ist eine Liste der Metriken, die wir verwenden werden: </p><br><ul><li>  <strong>width</strong> : <code>face-&gt;glyph-&gt;bitmap.width</code> in Pixel, Zugriff über <code>face-&gt;glyph-&gt;bitmap.width</code> </li><li>  <strong>height</strong> : <code>face-&gt;glyph-&gt;bitmap.rows</code> in Pixel, Zugriff über <code>face-&gt;glyph-&gt;bitmap.rows</code> </li><li>  <strong>BearingX</strong> : horizontaler Versatz des oberen linken Punkts des Glyphen relativ zum Ursprung, Zugriff über <code>face-&gt;glyph-&gt;bitmap_left</code> </li><li>  <strong>BearingY</strong> : Vertikaler Versatz des oberen linken Punkts des Glyphen relativ zum Ursprung, Zugriff über <code>face-&gt;glyph-&gt;bitmap_top</code> </li><li>  <strong>Voraus</strong> : horizontaler Versatz des Beginns der nächsten Glyphe in 1/64 Pixel relativ zum Ursprung, Zugriff über <code>face-&gt;glyph-&gt;advance.x</code> </li></ul><br><p>  Wir können jedes Mal, wenn wir es auf dem Bildschirm zeichnen möchten, eine Glyphe eines Symbols laden, seine Metriken abrufen und eine Textur generieren, aber es ist keine gute Methode, Texturen für jedes Symbol in jedem Frame zu erstellen.  Besser, wir speichern die generierten Daten irgendwo und fordern sie an, wenn wir sie brauchen.  Wir definieren eine bequeme Struktur, die wir in <code>std::map</code> speichern werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> {</span></span> GLuint TextureID; <span class="hljs-comment"><span class="hljs-comment">// ID   glm::ivec2 Size; //   glm::ivec2 Bearing; //      GLuint Advance; //       }; std::map&lt;GLchar, Character&gt; Characters;</span></span></code> </pre> <br><p>  In diesem Artikel werden wir unser Leben vereinfachen und nur die ersten 128 Zeichen verwenden.  Für jedes Zeichen generieren wir eine Textur und speichern die erforderlichen Daten in einer Struktur vom Typ <code>Character</code> , die wir den <code>Characters</code> Typ <code>std::map</code> hinzufügen.  Somit werden alle zum Zeichnen eines Zeichens erforderlichen Daten für die zukünftige Verwendung gespeichert. </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Disable byte-alignment restriction for (GLubyte c = 0; c &lt; 128; c++) { // Load character glyph if (FT_Load_Char(face, c, FT_LOAD_RENDER)) { std::cout &lt;&lt; "ERROR::FREETYTPE: Failed to load Glyph" &lt;&lt; std::endl; continue; } // Generate texture GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D( GL_TEXTURE_2D, 0, GL_RED, face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows, 0, GL_RED, GL_UNSIGNED_BYTE, face-&gt;glyph-&gt;bitmap.buffer ); // Set texture options glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Now store character for later use Character character = { texture, glm::ivec2(face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows), glm::ivec2(face-&gt;glyph-&gt;bitmap_left, face-&gt;glyph-&gt;bitmap_top), face-&gt;glyph-&gt;advance.x }; Characters.insert(std::pair&lt;GLchar, Character&gt;(c, character)); // Characters[c] = character; }</span></span></code> </pre> <br><p>  Innerhalb der Schleife erhalten wir für jedes der ersten 128 Zeichen eine Glyphe, generieren eine Textur, legen ihre Einstellungen fest und speichern die Metriken.  Es ist interessant festzustellen, dass wir <code>GL_RED</code> als Argumente für <code>internalFormat</code> und Texturen <code>format</code> .  Eine durch Glyphen erzeugte Bitmap ist ein 8-Bit-Graustufenbild, von dem jedes Pixel 1 Byte belegt.  Aus diesem Grund speichern wir den Bitmap-Puffer als Texturfarbwert.  Dies wird erreicht, indem eine Textur erstellt wird, in der jedes Byte der roten Komponente der Farbe entspricht.  Wenn wir 1 Byte zur Darstellung von Texturfarben verwenden, vergessen Sie nicht die Einschränkungen von OpenGL: </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  OpenGL erfordert, dass alle Texturen einen Versatz von 4 Byte haben, d. H.  Ihre Größe muss ein Vielfaches von 4 Bytes sein (z. B. 8 Bytes, 4000 Bytes, 2048 Bytes) oder (und) sie sollten 4 Bytes pro Pixel verwenden (z. B. im RGBA-Format), aber da wir 1 Byte pro Pixel verwenden, können sie unterschiedlich sein Breite.  Durch Einstellen des Ausrichtungsversatzes beim Entpacken (gibt es eine bessere Übersetzung?) Auf 1 beseitigen wir die Versatzfehler, die zu Segfaults führen können. </p><br><p>  Wenn wir mit der Schriftart selbst fertig sind, sollten wir die FreeType-Ressourcen löschen: </p><br><pre> <code class="cpp hljs">FT_Done_Face(face); <span class="hljs-comment"><span class="hljs-comment">//     face FT_Done_FreeType(ft); //   FreeType</span></span></code> </pre> <br><h4 id="sheydery">  Shader </h4><br><p>  Verwenden Sie zum Zeichnen von Glyphen den folgenden Vertex-Shader: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec4 vertex; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;vec2 pos, vec2 tex_coord&gt; out vec2 TexCoords; uniform mat4 projection; void main() { gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); TexCoords = vertex.zw; }</span></span></span></span></code> </pre> <br><p>  Wir kombinieren <code>vec4</code> und Texturkoordinaten in einem <code>vec4</code> .  Der Vertex-Shader berechnet das Koordinatenprodukt mit der Projektionsmatrix und überträgt die Texturkoordinaten an den Fragment-Shader: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core in vec2 TexCoords; out vec4 color; uniform sampler2D text; uniform vec3 textColor; void main() { vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); color = vec4(textColor, 1.0) * sampled; }</span></span></code> </pre> <br><p>  Der Fragment-Shader akzeptiert zwei globale Variablen - ein monochromes Bild des Glyphen und die Farbe des Glyphen selbst.  Zuerst probieren wir den Farbwert des Glyphen aus.  Da die Texturdaten in der roten Komponente der Textur gespeichert sind, wird nur die <code>r</code> Komponente als Transparenzwert abgetastet.  Durch Ändern der Transparenz der Farbe wird die resultierende Farbe für den Hintergrund der Glyphe transparent und für die wahren Pixel der Glyphe undurchsichtig.  Wir multiplizieren auch RGB-Farben mit der Variablen textColor, um die Farbe des Texts zu ändern. </p><br><p>  Damit unser Mechanismus funktioniert, müssen Sie das Mischen aktivieren: </p><br><pre> <code class="cpp hljs">glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre> <br><p>  Als Projektionsmatrix haben wir eine orthographische Projektionsmatrix.  Zum Zeichnen von Text ist tatsächlich keine perspektivische Matrix erforderlich, und die Verwendung der orthografischen Projektion ermöglicht es uns auch, alle Scheitelpunktkoordinaten in Bildschirmkoordinaten anzugeben, wenn wir die Matrix wie folgt einstellen: </p><br><pre> <code class="cpp hljs">glm::mat4 projection = glm::ortho(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">800.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">600.0f</span></span>);</code> </pre> <br><p>  Wir setzen den unteren Rand der Matrix auf <code>0.0f</code> , den oberen auf die Höhe des Fensters.  Infolgedessen nimmt die <code>y</code> Koordinate Werte vom unteren Bildschirmrand ( <code>y = 0</code> ) bis zum oberen Bildschirmrand ( <code>y = 600</code> ) an.  Dies bedeutet, dass der Punkt <code>(0, 0)</code> und die untere linke Ecke des Bildschirms anzeigt. </p><br><p>  Erstellen Sie abschließend VBO und VAO, um die Vierecke zu zeichnen.  Hier reservieren wir genügend Speicher in VBO, damit wir die Daten aktualisieren können, um Zeichen zu zeichnen. </p><br><pre> <code class="cpp hljs">GLuint VAO, VBO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat) * <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_DYNAMIC_DRAW); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Ein flaches Viereck erfordert 6 Eckpunkte mit 4 Gleitkommazahlen, daher reservieren wir <code>6 * 4 = 24</code> Speicher-Floats.  Da wir die Scheitelpunktdaten häufig ändern werden, weisen wir den Speicher mit <code>GL_DYNAMIC_DRAW</code> . </p><br><h4 id="vyvod-stroki-teksta-na-ekran">  Zeigen Sie eine Textzeile auf dem Bildschirm an </h4><br><p>  Um eine Textzeile anzuzeigen, extrahieren wir die dem Symbol entsprechende Zeichenstruktur und berechnen die Abmessungen des Vierecks aus den Metriken des Symbols.  Aus den berechneten Abmessungen des Vierecks erstellen wir im <code>glBufferSubData</code> einen Satz von 6 Scheitelpunkten und aktualisieren die Scheitelpunktdaten mit <code>glBufferSubData</code> . </p><br><p>  <code>RenderText</code> Funktion, die eine Zeichenfolge zeichnet: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader &amp;s, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Activate corresponding render state s.Use(); glUniform3f(glGetUniformLocation(s.Program, "textColor"), color.x, color.y, color.z); glActiveTexture(GL_TEXTURE0); glBindVertexArray(VAO); // Iterate through all characters std::string::const_iterator c; for (c = text.begin(); c != text.end(); c++) { Character ch = Characters[*c]; GLfloat xpos = x + ch.Bearing.x * scale; GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale; GLfloat w = ch.Size.x * scale; GLfloat h = ch.Size.y * scale; // Update VBO for each character GLfloat vertices[6][4] = { { xpos, ypos + h, 0.0, 0.0 }, { xpos, ypos, 0.0, 1.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos, ypos + h, 0.0, 0.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos + w, ypos + h, 1.0, 0.0 } }; // Render glyph texture over quad glBindTexture(GL_TEXTURE_2D, ch.textureID); // Update content of VBO memory glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glBindBuffer(GL_ARRAY_BUFFER, 0); // Render quad glDrawArrays(GL_TRIANGLES, 0, 6); // Now advance cursors for next glyph (note that advance is number of 1/64 pixels) x += (ch.Advance &gt;&gt; 6) * scale; // Bitshift by 6 to get value in pixels (2^6 = 64) } glBindVertexArray(0); glBindTexture(GL_TEXTURE_2D, 0); }</span></span></code> </pre> <br><p>  Der Inhalt der Funktion ist relativ klar: die Berechnung von Ursprung, Größe und Eckpunkten des Vierecks.  Beachten Sie, dass wir jede Metrik mit der <code>scale</code> multipliziert haben.  Aktualisieren Sie danach VBO und zeichnen Sie ein Quad. </p><br><p>  Diese Codezeile erfordert einige Aufmerksamkeit: </p><br><pre> <code class="cpp hljs">GLfloat ypos = y - (ch.Size.y - ch.Bearing.y);</code> </pre> <br><p>  Einige Zeichen, wie z. B. <code>p</code> und <code>g</code> , werden deutlich unterhalb der Grundlinie gezeichnet. <code>RenderText</code> bedeutet, dass das Quad deutlich unter dem <code>y</code> Parameter der <code>RenderText</code> Funktion liegen sollte.  Der genaue Versatz <code>y_offset</code> kann aus <code>y_offset</code> ausgedrückt werden: </p><br><p><img src="https://habrastorage.org/webt/2m/kp/g2/2mkpg2lb3jrfhl-zt9elefuopek.png"></p><br><p>  Um den Versatz zu berechnen, benötigen wir <s>gerade Arme,</s> um den Abstand herauszufinden, in dem sich das Symbol unterhalb der Grundlinie befindet.  Dieser Abstand wird durch den roten Pfeil angezeigt.  Offensichtlich ist <code>y_offset = bearingY - height</code> und <code>ypos = y + y_offset</code> . </p><br><p>  Wenn alles richtig gemacht wurde, können Sie den Text wie folgt auf dem Bildschirm anzeigen: </p><br><pre> <code class="cpp hljs">RenderText(shader, <span class="hljs-string"><span class="hljs-string">"This is sample text"</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); RenderText(shader, <span class="hljs-string"><span class="hljs-string">"(C) LearnOpenGL.com"</span></span>, <span class="hljs-number"><span class="hljs-number">540.0f</span></span>, <span class="hljs-number"><span class="hljs-number">570.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.9f</span></span>));</code> </pre> <br><p>  Das Ergebnis sollte folgendermaßen aussehen: </p><br><p><img src="https://habrastorage.org/webt/dq/xs/uf/dqxsufeshmfga1wyzr1dl8amjes.png"></p><br><p>  Ein Beispielcode ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> (Link zur Website des ursprünglichen Autors). </p><br><p>  Deaktivieren Sie die Überblendung, um zu verstehen, welche Vierecke gezeichnet werden: </p><br><p><img src="https://habrastorage.org/webt/up/uc/fh/upucfh3hztm2du_zx7uc2wtiaby.png"></p><br><p>  Aus dieser Figur ist ersichtlich, dass sich die meisten Vierecke auf einer imaginären Grundlinie befinden, obwohl einige Zeichen wie <code>(</code> und <code>p</code> nach unten verschoben sind. </p><br><h1 id="chto-zhe-dalee">  Was kommt als nächstes? </h1><br><p>  Dieser Artikel zeigte, wie TrueType-Schriftarten mit FreeType gerendert werden.  Dieser Ansatz ist flexibel, skalierbar und effizient bei verschiedenen Zeichencodierungen.  Dieser Ansatz kann jedoch für Ihre Anwendung zu schwer sein, da für jedes Zeichen eine Textur erstellt wird.  Produktive Bitmap-Schriftarten werden bevorzugt, da wir für alle Glyphen eine Textur haben.  Der beste Ansatz besteht darin, die beiden Ansätze zu kombinieren und den besten Ansatz zu wählen: Generieren Sie im laufenden Betrieb eine Rasterschrift aus Glyphen, die mit FreeType heruntergeladen wurden.  Dies erspart dem Renderer zahlreiche Texturwechsel und erhöht je nach Texturverpackung die Leistung. </p><br><p>  FreeType hat jedoch noch einen weiteren Nachteil: Glyphen mit fester Größe. Dies bedeutet, dass mit zunehmender Größe der gerenderten Glyphe möglicherweise Schritte auf dem Bildschirm angezeigt werden und die Glyphe beim Drehen möglicherweise verschwommen aussieht.  Valve hat dieses Problem vor einigen Jahren mithilfe signierter Distanzfelder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20120815035559/">gelöst</a> (Link zum Webarchiv).  Sie haben es sehr gut gemacht und es in 3D-Anwendungen gezeigt. </p><br><p>  <strong>PS</strong> : Wir haben ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegramm Conf</a> für die Koordination der Überweisungen.  Wenn Sie ernsthaft bei der Übersetzung helfen möchten, sind Sie herzlich willkommen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473990/">https://habr.com/ru/post/de473990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473980/index.html">Technologie und die reale Welt: 4 Start-ups, die die Zukunft der Innenarchitektur verändern</a></li>
<li><a href="../de473982/index.html">NB-IoT: Wie funktioniert es? Teil 3: SCEF - ein einziges Zugriffsfenster auf Betreiberdienste</a></li>
<li><a href="../de473984/index.html">Data Science Digest (Oktober 2019)</a></li>
<li><a href="../de473986/index.html">„Mein Traum ist es, eine Person durch die Bäume zu sehen“ - Gründerin von Lisa Alert über moderne Suchtechnologien</a></li>
<li><a href="../de473988/index.html">Optimierung der Serververteilung über die Racks</a></li>
<li><a href="../de473992/index.html">Überblick über moderne Protokolle in industriellen Automatisierungssystemen</a></li>
<li><a href="../de473994/index.html">Modernes Skriptladen</a></li>
<li><a href="../de473998/index.html">Niederlande oder hin und zurück</a></li>
<li><a href="../de474000/index.html">IQBX - elektromechanischer Designer für Kreise und Heimwerker [Konzeptidee]</a></li>
<li><a href="../de474004/index.html">Von Norilsk nach Riad: Ein echtes Beispiel für Kingston Industrial Temperature microSD UHS-I-Speicherkarten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>