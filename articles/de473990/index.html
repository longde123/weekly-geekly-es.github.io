<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÖ üò¢ üèÖ Lerne OpenGL. Lektion 7.2 - Zeichnen von Text üë®üèø‚Äçü§ù‚Äçüë®üèº üíõ ‚ôüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Irgendwann in Ihrem Grafikabenteuer m√∂chten Sie Text √ºber OpenGL ausgeben. Entgegen dem, was Sie vielleicht erwarten, ist es mit einer Bibliothek auf ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lerne OpenGL. Lektion 7.2 - Zeichnen von Text</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473990/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Bild" align="left" width="300">  Irgendwann in Ihrem Grafikabenteuer m√∂chten Sie Text √ºber OpenGL ausgeben.  Entgegen dem, was Sie vielleicht erwarten, ist es mit einer Bibliothek auf niedriger Ebene wie OpenGL ziemlich schwierig, eine einfache Zeile auf dem Bildschirm zu erhalten.  Wenn Sie nicht mehr als 128 verschiedene Zeichen zum Zeichnen von Text ben√∂tigen, ist dies nicht schwierig.  Schwierigkeiten treten auf, wenn die Zeichen nicht mit H√∂he, Breite und Versatz √ºbereinstimmen.  Je nachdem, wo Sie wohnen, ben√∂tigen Sie m√∂glicherweise mehr als 128 Zeichen.  Aber was ist, wenn Sie Sonderzeichen, mathematische oder musikalische Zeichen m√∂chten?  Sobald Sie verstehen, dass das Zeichnen von Text nicht die einfachste Aufgabe ist, werden Sie feststellen, dass er h√∂chstwahrscheinlich nicht zu einer so einfachen API wie OpenGL geh√∂ren sollte. </p><br><p> Da OpenGL keine M√∂glichkeit zum Rendern von Text bietet, liegen alle Schwierigkeiten in diesem Fall bei uns.  Da es kein grafisches Grundelement "Symbol" gibt, m√ºssen wir es selbst erfinden.  Es gibt bereits vorgefertigte Beispiele: Zeichnen Sie ein Symbol √ºber <code>GL_LINES</code> , erstellen Sie 3D-Modelle von Symbolen oder zeichnen Sie Symbole auf flachen Vierecken im dreidimensionalen Raum. </p><br><p>  Meistens sind Entwickler <s>zu faul, um</s> <s>Kaffee</s> <s>zu</s> <s>trinken und</s> die letzte Option zu w√§hlen.  Das Zeichnen dieser strukturierten Vierecke ist nicht so schwierig wie die Auswahl der richtigen Textur.  In diesem Tutorial lernen wir einige M√∂glichkeiten kennen und schreiben unseren erweiterten, aber flexiblen Textrenderer mit FreeType. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Teil 1. Erste Schritte</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fenstererstellung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Fenster</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Dreieck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transformationen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koordinatensysteme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kamera</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 2. Grundbeleuchtung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farben</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlagen der Beleuchtung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehrere Lichtquellen</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 3. Laden Sie 3D-Modelle herunter</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assimp-Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesh-Polygon-Klasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3D-Modellklasse</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 4. Erweiterte OpenGL-Funktionen</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tiefentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schablonentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farbmischung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesichter schneiden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bildpuffer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubische Karten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Datenverarbeitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte GLSL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geometrischer Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Instanz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gl√§tten</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 5. Erweiterte Beleuchtung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Beleuchtung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blinn Fong Modell</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gammakorrektur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Omnidirektionale Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normale Zuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parallaxenabbildung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bl√ºte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgeschobenes Rendern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 6. Z√ºchterrechte</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theorie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analytische Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diffuse Bestrahlung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiegelexposition</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 7. √úbung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debuggen</a> </li><li>  <strong>Textwiedergabe</strong> </li></ol></div></div></div></div><br><h1 id="klassika-rastrovye-shrifty">  Klassiker: Raster-Schriftarten </h1><br><p>  Es war einmal <s>in der Zeit der Dinosaurier.</s> Zum Rendern <s>von</s> Text geh√∂rte das Ausw√§hlen (oder Erstellen) einer Schriftart f√ºr die Anwendung und das Kopieren der gew√ºnschten Zeichen auf eine gro√üe Textur, die als Bitmap-Schriftart bezeichnet wird.  Diese Textur enth√§lt alle notwendigen Zeichen in bestimmten Teilen.  Diese Zeichen werden Glyphen genannt.  Jeder Glyphe ist ein bestimmter Bereich von Texturkoordinaten zugeordnet.  Jedes Mal, wenn Sie einen Charakter zeichnen, w√§hlen Sie eine bestimmte Glyphe aus und zeichnen nur den gew√ºnschten Teil auf einem flachen Quad. </p><br><p><img src="https://habrastorage.org/webt/0q/dd/sm/0qddsmwzcxldp9s0kvohcz2qgea.png"></p><br><p>  Hier k√∂nnen Sie sehen, wie wir den Text "OpenGL" rendern w√ºrden.  Wir nehmen die Rasterschrift und probieren die erforderlichen Glyphen aus der Textur aus. Dabei w√§hlen wir sorgf√§ltig die Texturkoordinaten aus, die wir √ºber mehrere Vierecke zeichnen.  Wenn Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mischen aktivieren</a> und den Hintergrund transparent halten, wird eine Zeichenfolge auf dem Bildschirm angezeigt.  Diese Bitmap-Schriftart wurde mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codehead-Bitmap-Schriftgenerator</a> generiert. </p><br><p>  Dieser Ansatz hat Vor- und Nachteile.  Dieser Ansatz ist einfach zu implementieren, da Bitmap-Schriftarten bereits gerastert sind.  Dies ist jedoch nicht immer bequem.  Wenn Sie eine andere Schriftart ben√∂tigen, m√ºssen Sie eine neue Bitmap-Schriftart generieren.  Dar√ºber hinaus werden durch Erh√∂hen der Zeichengr√∂√üe schnell pixelige Kanten angezeigt.  Dar√ºber hinaus sind Bitmap-Schriftarten h√§ufig an einen kleinen Zeichensatz gebunden, sodass Unicode-Zeichen h√∂chstwahrscheinlich nicht angezeigt werden. </p><br><p>  Diese Technik war vor nicht allzu langer Zeit beliebt (und bleibt immer noch beliebt), da sie sehr schnell ist und auf jeder Plattform funktioniert.  Bisher gibt es jedoch andere Ans√§tze zum Rendern von Text.  Eine davon ist das Rendern von TrueType-Schriftarten mit FreeType. </p><br><h1 id="sovremennost-freetype">  Moderne: FreeType </h1><br><p>  FreeType ist eine Bibliothek, die Schriftarten herunterl√§dt, in Bitmaps rendert und Unterst√ºtzung f√ºr einige schriftartenbezogene Vorg√§nge bietet.  Diese beliebte Bibliothek wird unter Mac OS X, Java, Qt, PlayStation, Linux und Android verwendet.  Die M√∂glichkeit, TrueType-Schriftarten zu laden, macht diese Bibliothek attraktiv genug. </p><br><p>  Eine TrueType-Schriftart ist eine Sammlung von Glyphen, die nicht durch Pixel, sondern durch mathematische Formeln definiert sind.  Wie bei Vektorbildern kann ein gerastertes Schriftbild basierend auf der bevorzugten Schriftgr√∂√üe generiert werden.  Mit TrueType-Schriftarten k√∂nnen Sie problemlos Glyphen unterschiedlicher Gr√∂√üe ohne Qualit√§tsverlust rendern. </p><br><p>  FreeType kann von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Website</a> heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Sie k√∂nnen FreeType entweder selbst kompilieren oder gegebenenfalls vorkompilierte Versionen auf der Site verwenden.  Denken Sie daran, Ihr Programm mit <code>freetype.lib</code> zu <code>freetype.lib</code> und sicherzustellen, dass der Compiler wei√ü, wo er nach den Header-Dateien suchen muss. </p><br><p>  F√ºgen Sie dann die richtigen Header-Dateien hinzu: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ft2build.h&gt; #include FT_FREETYPE_H</span></span></span></span></code> </pre> <br><blockquote>  Da FreeType etwas seltsam gestaltet ist (lassen Sie mich zum Zeitpunkt des Schreibens des Originals wissen, wenn sich etwas ge√§ndert hat), k√∂nnen Sie seine Header-Dateien nur im Stammverzeichnis des Ordners mit den Header-Dateien ablegen.  <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> FreeType auf andere Weise verbinden (z. B. <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> ), kann dies zu einem Konflikt mit der Header-Datei f√ºhren. </blockquote><p>  Was macht FreeType?  L√§dt TrueType-Schriftarten und generiert f√ºr jede Glyphe ein Bitmap-Bild und berechnet einige Glyphenmetriken.  Wir k√∂nnen Bitmap-Bilder zum Generieren von Texturen und Positionieren jedes Glyphen in Abh√§ngigkeit von den empfangenen Metriken erhalten. </p><br><p>  Um eine Schriftart herunterzuladen, m√ºssen wir FreeType initialisieren und die Schriftart als Gesicht laden (wie FreeType die Schriftart nennt).  In diesem Beispiel laden wir die TrueType-Schriftart <code>arial.ttf</code> , die aus dem Ordner C: / Windows / Fonts kopiert wurde. </p><br><pre> <code class="cpp hljs">FT_Library ft; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Init_FreeType(&amp;ft)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Could not init FreeType Library"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; FT_Face face; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_New_Face(ft, <span class="hljs-string"><span class="hljs-string">"fonts/arial.ttf"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;face)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Failed to load font"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Jede dieser FreeType-Funktionen gibt im Fehlerfall einen Wert ungleich Null zur√ºck. </p><br><p>  Nachdem wir die <s>Gesichtsschrift</s> geladen haben, m√ºssen wir die gew√ºnschte Schriftgr√∂√üe angeben, die wir extrahieren werden: </p><br><pre> <code class="cpp hljs">FT_Set_Pixel_Sizes(face, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>);</code> </pre> <br><p>  Diese Funktion legt die Breite und H√∂he des Glyphen fest.  Durch Setzen der Breite auf 0 (Null) erm√∂glicht FreeType die Berechnung der Breite in Abh√§ngigkeit von der eingestellten H√∂he. </p><br><p>  Face FreeType enth√§lt eine Sammlung von Glyphen.  Wir k√∂nnen einige Glyphen <code>FT_Load_Char</code> indem <code>FT_Load_Char</code> aufrufen.  Hier versuchen wir die Glyphe <code>X</code> zu laden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Load_Char(face, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, FT_LOAD_RENDER)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYTPE: Failed to load Glyph"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Indem wir <code>FT_LOAD_RENDER</code> als eines der Download-Flags <code>FT_LOAD_RENDER</code> , <code>FT_LOAD_RENDER</code> wir FreeType an, eine 8-Bit-Graustufen-Bitmap zu erstellen, die wir dann wie <code>FT_LOAD_RENDER</code> erhalten k√∂nnen: </p><br><pre> <code class="cpp hljs">face-&gt;glyph-&gt;bitmap;</code> </pre> <br><p>  Mit FreeType geladene Glyphen haben nicht die gleiche Gr√∂√üe wie bei Bitmap-Schriftarten.  Eine mit FreeType generierte Bitmap ist die Mindestgr√∂√üe f√ºr eine bestimmte Schriftgr√∂√üe und reicht nur f√ºr ein Zeichen aus.  Zum Beispiel ein Bitmap-Bild eines Glyphen <code>.</code>  viel kleiner als die Bitmap von Glyphe <code>X</code>  Aus diesem Grund l√§dt FreeType auch einige Metriken herunter, die angeben, welche Gr√∂√üe und wo sich ein einzelnes Zeichen befinden soll.  Unten sehen Sie ein Bild, das zeigt, welche Metriken FreeType f√ºr jede Glyphe berechnet. </p><br><p><img src="https://habrastorage.org/webt/ux/2y/kh/ux2ykhrgznafueqwujrjdqgun9q.png"></p><br><p>  Jedes Symbol befindet sich auf der Grundlinie (horizontale Linie mit einem Pfeil).  Einige befinden sich genau auf der Grundlinie ( <code>X</code> ), andere unter ( <code>g</code> , <code>p</code> ).  Diese Metriken bestimmen genau die Offsets, um Glyphen genau auf der Grundlinie zu positionieren, die Gr√∂√üe der Glyphen anzupassen und herauszufinden, wie viele Pixel Sie zum Zeichnen des n√§chsten Glyphen √ºbrig lassen m√ºssen.  Das Folgende ist eine Liste der Metriken, die wir verwenden werden: </p><br><ul><li>  <strong>width</strong> : <code>face-&gt;glyph-&gt;bitmap.width</code> in Pixel, Zugriff √ºber <code>face-&gt;glyph-&gt;bitmap.width</code> </li><li>  <strong>height</strong> : <code>face-&gt;glyph-&gt;bitmap.rows</code> in Pixel, Zugriff √ºber <code>face-&gt;glyph-&gt;bitmap.rows</code> </li><li>  <strong>BearingX</strong> : horizontaler Versatz des oberen linken Punkts des Glyphen relativ zum Ursprung, Zugriff √ºber <code>face-&gt;glyph-&gt;bitmap_left</code> </li><li>  <strong>BearingY</strong> : Vertikaler Versatz des oberen linken Punkts des Glyphen relativ zum Ursprung, Zugriff √ºber <code>face-&gt;glyph-&gt;bitmap_top</code> </li><li>  <strong>Voraus</strong> : horizontaler Versatz des Beginns der n√§chsten Glyphe in 1/64 Pixel relativ zum Ursprung, Zugriff √ºber <code>face-&gt;glyph-&gt;advance.x</code> </li></ul><br><p>  Wir k√∂nnen jedes Mal, wenn wir es auf dem Bildschirm zeichnen m√∂chten, eine Glyphe eines Symbols laden, seine Metriken abrufen und eine Textur generieren, aber es ist keine gute Methode, Texturen f√ºr jedes Symbol in jedem Frame zu erstellen.  Besser, wir speichern die generierten Daten irgendwo und fordern sie an, wenn wir sie brauchen.  Wir definieren eine bequeme Struktur, die wir in <code>std::map</code> speichern werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> {</span></span> GLuint TextureID; <span class="hljs-comment"><span class="hljs-comment">// ID   glm::ivec2 Size; //   glm::ivec2 Bearing; //      GLuint Advance; //       }; std::map&lt;GLchar, Character&gt; Characters;</span></span></code> </pre> <br><p>  In diesem Artikel werden wir unser Leben vereinfachen und nur die ersten 128 Zeichen verwenden.  F√ºr jedes Zeichen generieren wir eine Textur und speichern die erforderlichen Daten in einer Struktur vom Typ <code>Character</code> , die wir den <code>Characters</code> Typ <code>std::map</code> hinzuf√ºgen.  Somit werden alle zum Zeichnen eines Zeichens erforderlichen Daten f√ºr die zuk√ºnftige Verwendung gespeichert. </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Disable byte-alignment restriction for (GLubyte c = 0; c &lt; 128; c++) { // Load character glyph if (FT_Load_Char(face, c, FT_LOAD_RENDER)) { std::cout &lt;&lt; "ERROR::FREETYTPE: Failed to load Glyph" &lt;&lt; std::endl; continue; } // Generate texture GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D( GL_TEXTURE_2D, 0, GL_RED, face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows, 0, GL_RED, GL_UNSIGNED_BYTE, face-&gt;glyph-&gt;bitmap.buffer ); // Set texture options glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Now store character for later use Character character = { texture, glm::ivec2(face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows), glm::ivec2(face-&gt;glyph-&gt;bitmap_left, face-&gt;glyph-&gt;bitmap_top), face-&gt;glyph-&gt;advance.x }; Characters.insert(std::pair&lt;GLchar, Character&gt;(c, character)); // Characters[c] = character; }</span></span></code> </pre> <br><p>  Innerhalb der Schleife erhalten wir f√ºr jedes der ersten 128 Zeichen eine Glyphe, generieren eine Textur, legen ihre Einstellungen fest und speichern die Metriken.  Es ist interessant festzustellen, dass wir <code>GL_RED</code> als Argumente f√ºr <code>internalFormat</code> und Texturen <code>format</code> .  Eine durch Glyphen erzeugte Bitmap ist ein 8-Bit-Graustufenbild, von dem jedes Pixel 1 Byte belegt.  Aus diesem Grund speichern wir den Bitmap-Puffer als Texturfarbwert.  Dies wird erreicht, indem eine Textur erstellt wird, in der jedes Byte der roten Komponente der Farbe entspricht.  Wenn wir 1 Byte zur Darstellung von Texturfarben verwenden, vergessen Sie nicht die Einschr√§nkungen von OpenGL: </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  OpenGL erfordert, dass alle Texturen einen Versatz von 4 Byte haben, d. H.  Ihre Gr√∂√üe muss ein Vielfaches von 4 Bytes sein (z. B. 8 Bytes, 4000 Bytes, 2048 Bytes) oder (und) sie sollten 4 Bytes pro Pixel verwenden (z. B. im RGBA-Format), aber da wir 1 Byte pro Pixel verwenden, k√∂nnen sie unterschiedlich sein Breite.  Durch Einstellen des Ausrichtungsversatzes beim Entpacken (gibt es eine bessere √úbersetzung?) Auf 1 beseitigen wir die Versatzfehler, die zu Segfaults f√ºhren k√∂nnen. </p><br><p>  Wenn wir mit der Schriftart selbst fertig sind, sollten wir die FreeType-Ressourcen l√∂schen: </p><br><pre> <code class="cpp hljs">FT_Done_Face(face); <span class="hljs-comment"><span class="hljs-comment">//     face FT_Done_FreeType(ft); //   FreeType</span></span></code> </pre> <br><h4 id="sheydery">  Shader </h4><br><p>  Verwenden Sie zum Zeichnen von Glyphen den folgenden Vertex-Shader: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec4 vertex; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;vec2 pos, vec2 tex_coord&gt; out vec2 TexCoords; uniform mat4 projection; void main() { gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); TexCoords = vertex.zw; }</span></span></span></span></code> </pre> <br><p>  Wir kombinieren <code>vec4</code> und Texturkoordinaten in einem <code>vec4</code> .  Der Vertex-Shader berechnet das Koordinatenprodukt mit der Projektionsmatrix und √ºbertr√§gt die Texturkoordinaten an den Fragment-Shader: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core in vec2 TexCoords; out vec4 color; uniform sampler2D text; uniform vec3 textColor; void main() { vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); color = vec4(textColor, 1.0) * sampled; }</span></span></code> </pre> <br><p>  Der Fragment-Shader akzeptiert zwei globale Variablen - ein monochromes Bild des Glyphen und die Farbe des Glyphen selbst.  Zuerst probieren wir den Farbwert des Glyphen aus.  Da die Texturdaten in der roten Komponente der Textur gespeichert sind, wird nur die <code>r</code> Komponente als Transparenzwert abgetastet.  Durch √Ñndern der Transparenz der Farbe wird die resultierende Farbe f√ºr den Hintergrund der Glyphe transparent und f√ºr die wahren Pixel der Glyphe undurchsichtig.  Wir multiplizieren auch RGB-Farben mit der Variablen textColor, um die Farbe des Texts zu √§ndern. </p><br><p>  Damit unser Mechanismus funktioniert, m√ºssen Sie das Mischen aktivieren: </p><br><pre> <code class="cpp hljs">glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre> <br><p>  Als Projektionsmatrix haben wir eine orthographische Projektionsmatrix.  Zum Zeichnen von Text ist tats√§chlich keine perspektivische Matrix erforderlich, und die Verwendung der orthografischen Projektion erm√∂glicht es uns auch, alle Scheitelpunktkoordinaten in Bildschirmkoordinaten anzugeben, wenn wir die Matrix wie folgt einstellen: </p><br><pre> <code class="cpp hljs">glm::mat4 projection = glm::ortho(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">800.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">600.0f</span></span>);</code> </pre> <br><p>  Wir setzen den unteren Rand der Matrix auf <code>0.0f</code> , den oberen auf die H√∂he des Fensters.  Infolgedessen nimmt die <code>y</code> Koordinate Werte vom unteren Bildschirmrand ( <code>y = 0</code> ) bis zum oberen Bildschirmrand ( <code>y = 600</code> ) an.  Dies bedeutet, dass der Punkt <code>(0, 0)</code> und die untere linke Ecke des Bildschirms anzeigt. </p><br><p>  Erstellen Sie abschlie√üend VBO und VAO, um die Vierecke zu zeichnen.  Hier reservieren wir gen√ºgend Speicher in VBO, damit wir die Daten aktualisieren k√∂nnen, um Zeichen zu zeichnen. </p><br><pre> <code class="cpp hljs">GLuint VAO, VBO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat) * <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_DYNAMIC_DRAW); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Ein flaches Viereck erfordert 6 Eckpunkte mit 4 Gleitkommazahlen, daher reservieren wir <code>6 * 4 = 24</code> Speicher-Floats.  Da wir die Scheitelpunktdaten h√§ufig √§ndern werden, weisen wir den Speicher mit <code>GL_DYNAMIC_DRAW</code> . </p><br><h4 id="vyvod-stroki-teksta-na-ekran">  Zeigen Sie eine Textzeile auf dem Bildschirm an </h4><br><p>  Um eine Textzeile anzuzeigen, extrahieren wir die dem Symbol entsprechende Zeichenstruktur und berechnen die Abmessungen des Vierecks aus den Metriken des Symbols.  Aus den berechneten Abmessungen des Vierecks erstellen wir im <code>glBufferSubData</code> einen Satz von 6 Scheitelpunkten und aktualisieren die Scheitelpunktdaten mit <code>glBufferSubData</code> . </p><br><p>  <code>RenderText</code> Funktion, die eine Zeichenfolge zeichnet: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader &amp;s, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Activate corresponding render state s.Use(); glUniform3f(glGetUniformLocation(s.Program, "textColor"), color.x, color.y, color.z); glActiveTexture(GL_TEXTURE0); glBindVertexArray(VAO); // Iterate through all characters std::string::const_iterator c; for (c = text.begin(); c != text.end(); c++) { Character ch = Characters[*c]; GLfloat xpos = x + ch.Bearing.x * scale; GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale; GLfloat w = ch.Size.x * scale; GLfloat h = ch.Size.y * scale; // Update VBO for each character GLfloat vertices[6][4] = { { xpos, ypos + h, 0.0, 0.0 }, { xpos, ypos, 0.0, 1.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos, ypos + h, 0.0, 0.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos + w, ypos + h, 1.0, 0.0 } }; // Render glyph texture over quad glBindTexture(GL_TEXTURE_2D, ch.textureID); // Update content of VBO memory glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glBindBuffer(GL_ARRAY_BUFFER, 0); // Render quad glDrawArrays(GL_TRIANGLES, 0, 6); // Now advance cursors for next glyph (note that advance is number of 1/64 pixels) x += (ch.Advance &gt;&gt; 6) * scale; // Bitshift by 6 to get value in pixels (2^6 = 64) } glBindVertexArray(0); glBindTexture(GL_TEXTURE_2D, 0); }</span></span></code> </pre> <br><p>  Der Inhalt der Funktion ist relativ klar: die Berechnung von Ursprung, Gr√∂√üe und Eckpunkten des Vierecks.  Beachten Sie, dass wir jede Metrik mit der <code>scale</code> multipliziert haben.  Aktualisieren Sie danach VBO und zeichnen Sie ein Quad. </p><br><p>  Diese Codezeile erfordert einige Aufmerksamkeit: </p><br><pre> <code class="cpp hljs">GLfloat ypos = y - (ch.Size.y - ch.Bearing.y);</code> </pre> <br><p>  Einige Zeichen, wie z. B. <code>p</code> und <code>g</code> , werden deutlich unterhalb der Grundlinie gezeichnet. <code>RenderText</code> bedeutet, dass das Quad deutlich unter dem <code>y</code> Parameter der <code>RenderText</code> Funktion liegen sollte.  Der genaue Versatz <code>y_offset</code> kann aus <code>y_offset</code> ausgedr√ºckt werden: </p><br><p><img src="https://habrastorage.org/webt/2m/kp/g2/2mkpg2lb3jrfhl-zt9elefuopek.png"></p><br><p>  Um den Versatz zu berechnen, ben√∂tigen wir <s>gerade Arme,</s> um den Abstand herauszufinden, in dem sich das Symbol unterhalb der Grundlinie befindet.  Dieser Abstand wird durch den roten Pfeil angezeigt.  Offensichtlich ist <code>y_offset = bearingY - height</code> und <code>ypos = y + y_offset</code> . </p><br><p>  Wenn alles richtig gemacht wurde, k√∂nnen Sie den Text wie folgt auf dem Bildschirm anzeigen: </p><br><pre> <code class="cpp hljs">RenderText(shader, <span class="hljs-string"><span class="hljs-string">"This is sample text"</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); RenderText(shader, <span class="hljs-string"><span class="hljs-string">"(C) LearnOpenGL.com"</span></span>, <span class="hljs-number"><span class="hljs-number">540.0f</span></span>, <span class="hljs-number"><span class="hljs-number">570.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.9f</span></span>));</code> </pre> <br><p>  Das Ergebnis sollte folgenderma√üen aussehen: </p><br><p><img src="https://habrastorage.org/webt/dq/xs/uf/dqxsufeshmfga1wyzr1dl8amjes.png"></p><br><p>  Ein Beispielcode ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> (Link zur Website des urspr√ºnglichen Autors). </p><br><p>  Deaktivieren Sie die √úberblendung, um zu verstehen, welche Vierecke gezeichnet werden: </p><br><p><img src="https://habrastorage.org/webt/up/uc/fh/upucfh3hztm2du_zx7uc2wtiaby.png"></p><br><p>  Aus dieser Figur ist ersichtlich, dass sich die meisten Vierecke auf einer imagin√§ren Grundlinie befinden, obwohl einige Zeichen wie <code>(</code> und <code>p</code> nach unten verschoben sind. </p><br><h1 id="chto-zhe-dalee">  Was kommt als n√§chstes? </h1><br><p>  Dieser Artikel zeigte, wie TrueType-Schriftarten mit FreeType gerendert werden.  Dieser Ansatz ist flexibel, skalierbar und effizient bei verschiedenen Zeichencodierungen.  Dieser Ansatz kann jedoch f√ºr Ihre Anwendung zu schwer sein, da f√ºr jedes Zeichen eine Textur erstellt wird.  Produktive Bitmap-Schriftarten werden bevorzugt, da wir f√ºr alle Glyphen eine Textur haben.  Der beste Ansatz besteht darin, die beiden Ans√§tze zu kombinieren und den besten Ansatz zu w√§hlen: Generieren Sie im laufenden Betrieb eine Rasterschrift aus Glyphen, die mit FreeType heruntergeladen wurden.  Dies erspart dem Renderer zahlreiche Texturwechsel und erh√∂ht je nach Texturverpackung die Leistung. </p><br><p>  FreeType hat jedoch noch einen weiteren Nachteil: Glyphen mit fester Gr√∂√üe. Dies bedeutet, dass mit zunehmender Gr√∂√üe der gerenderten Glyphe m√∂glicherweise Schritte auf dem Bildschirm angezeigt werden und die Glyphe beim Drehen m√∂glicherweise verschwommen aussieht.  Valve hat dieses Problem vor einigen Jahren mithilfe signierter Distanzfelder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20120815035559/">gel√∂st</a> (Link zum Webarchiv).  Sie haben es sehr gut gemacht und es in 3D-Anwendungen gezeigt. </p><br><p>  <strong>PS</strong> : Wir haben ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegramm Conf</a> f√ºr die Koordination der √úberweisungen.  Wenn Sie ernsthaft bei der √úbersetzung helfen m√∂chten, sind Sie herzlich willkommen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473990/">https://habr.com/ru/post/de473990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473980/index.html">Technologie und die reale Welt: 4 Start-ups, die die Zukunft der Innenarchitektur ver√§ndern</a></li>
<li><a href="../de473982/index.html">NB-IoT: Wie funktioniert es? Teil 3: SCEF - ein einziges Zugriffsfenster auf Betreiberdienste</a></li>
<li><a href="../de473984/index.html">Data Science Digest (Oktober 2019)</a></li>
<li><a href="../de473986/index.html">‚ÄûMein Traum ist es, eine Person durch die B√§ume zu sehen‚Äú - Gr√ºnderin von Lisa Alert √ºber moderne Suchtechnologien</a></li>
<li><a href="../de473988/index.html">Optimierung der Serververteilung √ºber die Racks</a></li>
<li><a href="../de473992/index.html">√úberblick √ºber moderne Protokolle in industriellen Automatisierungssystemen</a></li>
<li><a href="../de473994/index.html">Modernes Skriptladen</a></li>
<li><a href="../de473998/index.html">Niederlande oder hin und zur√ºck</a></li>
<li><a href="../de474000/index.html">IQBX - elektromechanischer Designer f√ºr Kreise und Heimwerker [Konzeptidee]</a></li>
<li><a href="../de474004/index.html">Von Norilsk nach Riad: Ein echtes Beispiel f√ºr Kingston Industrial Temperature microSD UHS-I-Speicherkarten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>