<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÆ üÜò ü§¥üèø Usar o BSP no Doom √© realmente uma jogada engenhosa? ü§¢ üë®üèø‚Äç‚öñÔ∏è ‚óÄÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O auge da tecnologia da √©poca. 

 Em 1993, a id Software lan√ßou o Doom , um jogo de tiro em primeira pessoa que rapidamente se transformou em fen√¥meno...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usar o BSP no Doom √© realmente uma jogada engenhosa?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/268/1a6/7cd/2681a67cd1d82d83879143c036a95ca4.jpg"></div><br>  <i>O auge da tecnologia da √©poca.</i> <br><br>  Em 1993, a id Software lan√ßou o <em>Doom</em> , um jogo de tiro em primeira pessoa que rapidamente se transformou em fen√¥meno.  Hoje acredita-se que este seja um dos jogos que tiveram o maior impacto na hist√≥ria. <br><br>  Dez anos ap√≥s o lan√ßamento do <em>Doom</em> , em 2003, o jornalista David Kouchner publicou um livro da id Software chamado <a rel="nofollow" href="https://www.amazon.com/dp/0812972155/%3Ftag%3Darstech20-20"><em>Masters of Doom</em></a> , que desde ent√£o se tornou uma descri√ß√£o can√¥nica do processo de cria√ß√£o do <em>Doom</em> .  Li <em>Masters of Doom h√°</em> alguns anos e n√£o me lembro de quase nada, mas uma hist√≥ria de um livro sobre o programador John Carmack foi preservada em minha mem√≥ria.  Minha descri√ß√£o n√£o ser√° totalmente precisa (veja abaixo para mais detalhes), mas, resumindo, no est√°gio inicial do desenvolvimento de <em>Doom</em> , Carmack percebeu que o renderizador em 3D que ele escreveu para o jogo come√ßou a desacelerar ao renderizar certos n√≠veis.  Isso era inaceit√°vel, porque <em>Doom</em> tinha que se tornar um jogo ativo e at√© fren√©tico.  Percebendo que o problema do renderizador era t√£o fundamental que ele precisaria procurar um algoritmo de renderiza√ß√£o mais ideal, Carmack come√ßou a ler artigos de pesquisa.  Como resultado, ele implementou uma t√©cnica chamada BSP (binary space particitioning), que nunca havia sido usada em videogames antes e, portanto, acelerou significativamente o mecanismo <em>Doom</em> . <br><br>  Essa hist√≥ria de como Carmack aplicou pesquisas cient√≠ficas de ponta em videogames sempre me impressionou.  Na minha opini√£o, foi gra√ßas a isso que Carmack se tornou uma figura t√£o lend√°ria.  Ele merece ser conhecido como um programador de videogame arquet√≠pico e brilhante por v√°rias raz√µes, mas como principal, sempre me lembro do epis√≥dio com a leitura de artigos cient√≠ficos e a parti√ß√£o bin√°ria do espa√ßo. <br><a name="habracut"></a><br>  Obviamente, essa hist√≥ria √© impressionante, porque o termo "parti√ß√£o bin√°ria do espa√ßo" parece ser algo complicado n√£o apenas para implementa√ß√£o, mas tamb√©m para compreens√£o.  Por um longo tempo, presumi que o Carmack deu um salto intelectual, mas como n√£o sabia o que √© uma parti√ß√£o bin√°ria de espa√ßo, e qu√£o nova era essa t√©cnica quando Carmack decidiu us√°-la, n√£o tive muita certeza.  Qu√£o engenhosa foi a adi√ß√£o de uma parti√ß√£o de espa√ßo bin√°rio ao <em>Doom</em> em uma escala de Homer Simpson a Albert Einstein? <br><br>  Tamb√©m me perguntei de onde o BSP veio e como a id√©ia chegou ao Carmack.  Portanto, este post ser√° dedicado n√£o apenas a John Carmack e <em>Doom</em> , mas tamb√©m ao hist√≥rico da estrutura de dados da "√°rvore de parti√ß√£o de espa√ßo bin√°rio" (ou √°rvore BSP).  Verificou-se que a √°rvore BSP, como muitos outros aspectos das ci√™ncias computacionais, se origina em pesquisas conduzidas pelos militares. <br><br>  Sim, est√° certo: o E1M1, o primeiro n√≠vel de <em>Doom</em> , apareceu gra√ßas √† For√ßa A√©rea dos EUA. <br><br><h2>  Tarefa VSD </h2><br>  A √°rvore BSP √© uma solu√ß√£o para uma das tarefas mais dif√≠ceis em computa√ß√£o gr√°fica.  Para renderizar uma cena tridimensional, o renderizador deve determinar o que √© vis√≠vel e o que n√£o √© vis√≠vel a partir do ponto atual.  Isso n√£o √© particularmente dif√≠cil se voc√™ tiver muito tempo, mas um mecanismo de jogo que se preze em tempo real deve determinar as partes vis√≠veis e invis√≠veis do mundo pelo menos 30 vezes por segundo. <br><br>  Essa tarefa geralmente √© chamada de tarefa de determina√ß√£o da superf√≠cie vis√≠vel (VSD).  O programador Michael Abrash, que trabalhou com Carmack no <em>Quake</em> (o pr√≥ximo jogo de software ap√≥s <em>Doom</em> ), escreveu sobre a tarefa VSD em seu famoso livro <a href="http://www.jagregory.com/abrash-black-book/"><em>Graphics Programming Black Book</em></a> : <br><br><blockquote>  Quero falar sobre a tarefa mais dif√≠cil, na minha opini√£o, de gr√°ficos 3D: determinar superf√≠cies vis√≠veis (desenhar a superf√≠cie desejada em cada pixel) e seu parente pr√≥ximo - a tarefa de sele√ß√£o (o mais r√°pido poss√≠vel, lan√ßar pol√≠gonos invis√≠veis para acelerar a determina√ß√£o de superf√≠cies vis√≠veis).  Por uma quest√£o de brevidade, denotarei pela abrevia√ß√£o VSD a defini√ß√£o de superf√≠cies vis√≠veis e o recorte. <br><br>  Por que considero o VSD a tarefa 3D mais dif√≠cil?  Embora problemas de rasteriza√ß√£o, como o mapeamento de textura, tamb√©m sejam tarefas surpreendentes e importantes, s√£o tarefas de uma escala bastante finita, cuja solu√ß√£o √© alterada para a apar√™ncia de aceleradores 3D nos equipamentos;  al√©m disso, eles s√≥ aumentam quando a resolu√ß√£o da tela √© aumentada, o que √© bastante suport√°vel. <br><br>  Por outro lado, o VSD √© uma tarefa ilimitada e agora dezenas de solu√ß√µes s√£o usadas para resolv√™-lo.  Ainda mais importante, o desempenho ing√™nuo do VSD √© dimensionado diretamente com a complexidade da cena, que geralmente aumenta como uma fun√ß√£o quadrada ou c√∫bica, tornando-se rapidamente o fator limitante na renderiza√ß√£o de mundos realistas. </blockquote><br>  Abrash escreveu sobre a complexidade do problema de VSD no final dos anos 90, alguns anos depois que o <em>Doom</em> provou que as pessoas comuns querem poder jogar jogos graficamente pesados ‚Äã‚Äãem seus computadores dom√©sticos.  No in√≠cio dos anos 90, quando a id Software estava apenas come√ßando a publicar jogos, eles tiveram que trabalhar efetivamente em computadores inadequados: as m√°quinas dom√©sticas foram projetadas para trabalhar com texto, planilhas e outros aplicativos similares.  Para atingir esse objetivo, a empresa teve que se aproximar da fic√ß√£o, especialmente no caso de v√°rios jogos em 3D publicados pela id Software antes do <em>Doom</em> .  Nesses jogos, o design de todos os n√≠veis era limitado de maneira a simplificar a solu√ß√£o do problema de VSD. <br><br>  Por exemplo, no <em>Wolfenstein 3D</em> , o jogo que a id Software lan√ßou pouco antes do <em>Doom</em> , cada n√≠vel consistia em paredes alinhadas ao longo dos eixos.  Em outras palavras, no universo Wolfenstein poderia haver paredes norte / sul ou paredes leste / oeste, e nenhuma outra.  Al√©m disso, as paredes podem ser colocadas a dist√¢ncias fixas na grade - todos os corredores t√™m uma largura de uma c√©lula da grade, ou duas, etc., mas nunca 2,5 c√©lulas.  Embora isso significasse que a equipe da id Software poderia criar n√≠veis quase iguais, essa restri√ß√£o tornou muito f√°cil para Carmack escrever um renderizador para <em>Wolfenstein</em> . <br><br>  <em>O</em> renderizador <em>Wolfenstein</em> resolveu o problema do VSD movendo raios (marchas de raios) para o mundo virtual a partir da tela.  Normalmente, renderizadores renderizados em raio s√£o renderizadores de emiss√£o de raios - eles geralmente s√£o lentos porque a solu√ß√£o do problema VSD no raycaster exige encontrar a primeira interse√ß√£o entre o raio e algum objeto no mundo, o que exige muita computa√ß√£o.  Mas como todas as paredes de <em>Wolfenstein</em> est√£o alinhadas com uma grade, os √∫nicos lugares onde uma viga pode atravessar a parede ser√£o as linhas de grade.  Portanto, √© suficiente para o renderizador verificar cada um desses pontos de interse√ß√£o.  Se o renderizador come√ßar verificando o ponto de interse√ß√£o mais pr√≥ximo do ponto de vista do jogador, depois verificar o segundo em proximidade, e assim por diante, e terminar quando encontrar a primeira parede, o problema do VSD ser√° resolvido da maneira mais trivial.  O feixe simplesmente avan√ßou de cada pixel at√© encontrar algo, o que √© muito barato em termos de velocidade do clock do processador.  E como todas as paredes t√™m a mesma altura, basta emitirmos raios para cada <em>coluna de</em> pixels. <br><br>  Essa simplifica√ß√£o da renderiza√ß√£o tornou <em>Wolfenstein</em> r√°pido o suficiente para trabalhar em computadores dom√©sticos fracos da √©poca, quando n√£o havia placas gr√°ficas especializadas.  Mas essa abordagem n√£o funcionaria no <em>Doom</em> , porque a equipe de identifica√ß√£o decidiu que em seu novo jogo haveria elementos novos como paredes diagonais, escadas e tetos com diferentes alturas.  A marcha dos raios n√£o era mais adequada, ent√£o Carmack escreveu um tipo diferente de renderizador.  O renderizador <em>Wolfenstein</em> , onde o feixe foi usado para cada coluna de pixels, foi repelido da imagem, e o renderizador <em>Doom</em> deveria ser repelido de objetos.  Isso significava que, em vez de percorrer os pixels da tela e determinar sua cor, o renderizador do <em>Doom</em> precisava iterar sobre os objetos na cena e projetar cada um deles na tela. <br><br>  Nesse renderizador, uma maneira simples de resolver o problema do VSD √© usar um buffer z.  Cada vez que projetamos um objeto na tela, uma verifica√ß√£o √© realizada para cada pixel que queremos desenhar.  Se a parte do objeto a ser desenhado estiver mais pr√≥xima do player do que o objeto j√° desenhado no pixel, poderemos reescrever suas informa√ß√µes.  Caso contr√°rio, voc√™ precisar√° deixar o pixel inalterado.  Essa abordagem √© simples, mas o buffer z requer muita mem√≥ria, e o renderizador ainda pode gastar v√°rios rel√≥gios do processador em projetar geometria de n√≠vel que o player n√£o ver√°. <br><br>  No in√≠cio dos anos 90, a solu√ß√£o z-buffer teve mais uma desvantagem: em PCs compat√≠veis com IBM, usando um sistema de adaptador de v√≠deo chamado VGA, gravar no buffer do quadro de sa√≠da era uma opera√ß√£o dispendiosa.  Portanto, o tempo gasto na renderiza√ß√£o de pixels, que ser√£o substitu√≠dos simplesmente, reduziu bastante o desempenho do renderizador. <br><br>  Como a grava√ß√£o no buffer de quadros era t√£o cara, o renderizador ideal era come√ßar desenhando os objetos mais pr√≥ximos do player, depois os objetos imediatamente atr√°s deles, e assim por diante, at√© a grava√ß√£o em cada pixel da tela.  Nesse est√°gio, o renderizador deveria ter entendido que era hora de parar, economizando o tempo que passava explorando objetos distantes que o jogador n√£o via.  Mas encomendar objetos de cena dessa maneira, do mais pr√≥ximo ao mais distante, √© o mesmo que resolver o problema de VSD.  A quest√£o novamente se coloca diante de n√≥s: o que um jogador pode ver? <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HQYsFshbkYw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Inicialmente, Carmack tentou resolver esse problema, contando com o esquema de n√≠veis de <em>Doom</em> .  Seu renderizador come√ßou desenhando as paredes da sala em que o jogador est√° localizado e depois despejou-se nas salas vizinhas para desenhar paredes nessas salas, que podiam ser vis√≠veis na sala atual.  Se cada sala fosse convexa, isso resolveria o problema de VSD.  As salas n√£o convexas podem ser divididas em "setores" convexos.  Voc√™ pode ver como essa t√©cnica de renderiza√ß√£o pode parecer uma forte desacelera√ß√£o no <a href="https://youtu.be/HQYsFshbkYw%3Ft%3D822">v√≠deo acima</a> , onde um usu√°rio do YouTuber com o apelido Bisqwit demonstra seu pr√≥prio renderizador que funciona de acordo com o mesmo algoritmo geral.  Esse algoritmo foi usado com sucesso no jogo 3D Duke Nukem, lan√ßado tr√™s anos ap√≥s o <em>Doom</em> , quando os processadores se tornaram mais poderosos.  Mas em 1993, na √©poca, o renderizador <em>Doom que</em> usava esse algoritmo teve problemas com n√≠veis complexos.  Isso foi especialmente √≥bvio quando os setores foram incorporados um ao outro, e essa foi a √∫nica maneira de criar, por exemplo, escadas circulares.  Escadas circulares exigiam v√°rias descidas recursivas para o setor j√° desenhado, reduzindo drasticamente a velocidade do motor. <br><br>  Na mesma √©poca, quando a equipe de identifica√ß√£o percebeu que o mecanismo <em>Doom</em> poderia estar muito lento, foi solicitado √† id Software que <em>portasse o Wolfenstein 3D</em> para a Super Nintendo.  O SNES era ainda menos poderoso do que os PCs compat√≠veis com a IBM da √©poca, e o renderizador <em>Wolfenstein</em> com tecnologia de marca√ß√£o de raios, apesar de sua simplicidade, n√£o era executado nos equipamentos da Super Nintendo com velocidade suficiente.  Portanto, Carmack come√ßou a procurar um algoritmo melhor.  De fato, foi para a porta Super Nintendo de <em>Wolfenstein</em> que Carmack primeiro explorou e implementou o particionamento de espa√ßo bin√°rio.  Em <em>Wolfenstein</em> , era bem simples, porque todas as paredes eram paralelas aos eixos;  <em>Doom torna</em> mais dif√≠cil.  Mas Carmack percebeu que as √°rvores BSP tamb√©m resolveriam problemas de velocidade no <em>Doom</em> . <br><br><h2>  Divis√£o de espa√ßo bin√°rio </h2><br>  O particionamento de espa√ßo bin√°rio simplifica a solu√ß√£o para o problema de VSD, dividindo previamente a cena 3D.  Por enquanto, basta voc√™ entender por que a parti√ß√£o √© √∫til: se voc√™ desenhar uma linha (que na verdade √© um avi√£o em 3D) durante toda a cena, sabendo em que lado da linha o player ou a c√¢mera est√°, ent√£o tamb√©m saberemos que nada √© o outro lado da linha n√£o poder√° obstruir os objetos da linha em que a c√¢mera est√° localizada.  Se voc√™ repetir o processo v√°rias vezes, obteremos uma cena 3D, dividida em v√°rias se√ß√µes.  Isso n√£o ser√° uma melhoria em rela√ß√£o √† cena original, exceto que agora sabemos mais sobre como diferentes partes da cena podem se sobrepor. <br><br>  Os primeiros a escrever sobre essa divis√£o da cena 3D foram os pesquisadores que tentaram descobrir para a For√ßa A√©rea dos EUA se os gr√°ficos de computador s√£o progressivos o suficiente para serem usados ‚Äã‚Äãem simuladores de v√¥o.  Eles publicaram suas descobertas em um relat√≥rio de 1969 intitulado "Pesquisa sobre o uso de imagens geradas por computador na simula√ß√£o visual".  O relat√≥rio concluiu que a computa√ß√£o gr√°fica pode ser usada para treinar pilotos;  Ao mesmo tempo, os pesquisadores alertaram que a implementa√ß√£o do sistema seria complicada pela tarefa do VSD: <br><br><blockquote>  Uma das tarefas mais importantes que precisar√£o ser resolvidas ao calcular imagens em tempo real √© a tarefa priorit√°ria ou linhas ocultas.  Em nossa percep√ß√£o visual cotidiana do mundo √† nossa volta, a pr√≥pria natureza resolve esse problema com simplicidade trivial;  o ponto de um objeto opaco se sobrep√µe a todos os outros pontos que est√£o ao longo da mesma linha de vis√£o e est√£o mais distantes.  No caso de um computador, essa tarefa √© muito dif√≠cil.  A quantidade de computa√ß√£o necess√°ria para determinar a prioridade, no caso geral, cresce exponencialmente com o aumento da complexidade do ambiente e logo excede a carga computacional associada √† pesquisa de imagens de objetos levando em considera√ß√£o a perspectiva. </blockquote><br>  Uma solu√ß√£o mencionada por esses pesquisadores, que eles disseram ter sido usada anteriormente em um projeto da NASA, baseia-se na cria√ß√£o do que chamarei de "matriz de sobreposi√ß√£o".  Os pesquisadores apontam que um avi√£o que divide uma cena em duas partes pode ser usado para resolver "qualquer conflito de prioridades" entre objetos em lados opostos do avi√£o.  No caso geral, pode ser necess√°rio adicionar esses planos √† cena explicitamente, mas para uma certa estrutura geom√©trica, voc√™ pode confiar nas faces existentes dos objetos.  Pesquisadores demonstram o exemplo abaixo, onde <em>p1</em> , <em>p2</em> e <em>p3</em> est√£o dividindo superf√≠cies.  Se o ponto de vista da c√¢mera estiver na frente ou no lado "verdadeiro" de um desses planos, ent√£o <em>pi</em> ser√° 1. A matriz mostra a rela√ß√£o entre os tr√™s objetos, dependendo dos tr√™s planos de separa√ß√£o e da localiza√ß√£o do ponto de vista da c√¢mera - se o objeto <em>ai</em> sobrepuser o objeto <em>aj</em> , ent√£o o elemento <em>aij da</em> matriz ser√° igual a 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/7b5/fda/d247b5fdab1c47b5772d3a3c922c1664.png"></div><br>  Os pesquisadores propuseram implementar essa matriz em hardware e recalcul√°-la em cada quadro.  De fato, a matriz deve atuar como um comutador grande ou como um tipo de z-buffer embutido.  Ao renderizar o objeto atual, o v√≠deo n√£o √© exibido para partes do objeto quando 1 est√° na coluna do objeto, mas o objeto de linha correspondente √© desenhado. <br><br>  Uma desvantagem s√©ria dessa abordagem √© que √© necess√°ria uma matriz de tamanho <em>n <sup>2</sup></em> para descrever uma cena com <em>n</em> objetos.  Portanto, os pesquisadores decidiram verificar se √© poss√≠vel apresentar a matriz de sobreposi√ß√£o na forma de uma ‚Äúlista de prioridades‚Äù, que ter√° um tamanho de apenas <em>n</em> e especificar a ordem em que os objetos devem ser desenhados.  Eles imediatamente perceberam que em certas cenas, por exemplo, na mostrada acima, √© imposs√≠vel concluir a ordena√ß√£o (uma vez que existe um ciclo de sobreposi√ß√£o), por isso dedicaram muito tempo √† defini√ß√£o matem√°tica de cenas ‚Äúcertas‚Äù e ‚Äúerradas‚Äù.  No final, eles chegaram √† conclus√£o de que, pelo menos para as cenas ‚Äúcertas‚Äù (e o designer da cena pode facilmente evitar os casos ‚Äúerrados‚Äù), uma lista de prioridades pode ser gerada.  Mas eles deixaram a gera√ß√£o da lista como um exerc√≠cio para o leitor.  Parece que a principal contribui√ß√£o deste trabalho de 1969 √© indicar que pelo menos <em>teoricamente</em> deveria haver a possibilidade de usar planos de divis√£o para organizar objetos na cena. <br><br>  E somente em um artigo de 1980 intitulado "Na gera√ß√£o vis√≠vel de superf√≠cies por estruturas de √°rvores priorit√°rias" foi demonstrado um algoritmo espec√≠fico para isso.  Neste artigo, escrito por Henry Fuchs, Zvi Kedem e Bruce Naylor, a √°rvore do BSP foi descrita pela primeira vez.  Os autores afirmam que sua nova estrutura de dados √© "uma solu√ß√£o, uma abordagem alternativa, usada pela primeira vez h√° dez anos, mas devido a algumas dificuldades n√£o t√£o difundidas" - e, portanto, respondem √† decis√£o escolhida no trabalho da For√ßa A√©rea dos EUA em 1969.  Ap√≥s a constru√ß√£o de uma √°rvore BSP, ela pode ser facilmente usada para organizar objetos com prioridade na cena. <br><br>  Fuchs, Kedem e Naylor forneceram uma descri√ß√£o bastante clara da opera√ß√£o da √°rvore do BSP, mas tentarei fornecer uma descri√ß√£o menos formal, mas breve. <br><br>  Come√ßamos selecionando um pol√≠gono na cena e fazemos do plano no qual o pol√≠gono se encontra um plano divisor.  Esse pol√≠gono √∫nico tamb√©m se torna o n√≥ raiz da √°rvore.  Os pol√≠gonos restantes da cena estar√£o em um ou no outro lado do plano de divis√£o da raiz.  Pol√≠gonos no lado "frontal" ou no meio espa√ßo "frontal" do plano aparecem na sub√°rvore esquerda do n√≥ raiz e pol√≠gonos no lado "traseiro" ou no meio espa√ßo "traseiro" do plano aparecem na sub√°rvore direita.  Em seguida, repetimos recursivamente esse processo, selecionando pol√≠gonos das sub√°rvores esquerda e direita como as novas superf√≠cies divis√≥rias para seus pr√≥prios meios-espa√ßos, que geram mais meios-espa√ßos e sub√°rvores.  O processo termina quando os pol√≠gonos terminam. <br><br>  Digamos que queremos renderizar a geometria da cena de tr√°s para a frente.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Isso √© chamado de "algoritmo do artista" porque significa que os pol√≠gonos mais distantes da c√¢mera ser√£o preenchidos com pol√≠gonos mais pr√≥ximos da c√¢mera, criando a renderiza√ß√£o correta.) Para realizar isso, basta percorrer nossa √°rvore BSP em ordem; a decis√£o sobre se a sub√°rvore esquerda ou direita deve ser desenhada √© tomada com base no local do ponto de vista da c√¢mera - no meio espa√ßo frontal ou traseiro em rela√ß√£o ao plano de divis√£o associado a este n√≥. Ou seja, em cada n√≥ da √°rvore, primeiro renderizamos todos os pol√≠gonos no lado "distante" do plano, depois o pol√≠gono no plano de separa√ß√£o e, em seguida, os pol√≠gonos no lado "pr√≥ximo" do plano. Os pol√≠gonos "Pr√≥ximo" e "Distante" s√£o definidos em rela√ß√£o ao ponto de vista da c√¢mera. Isso resolve o problema de VSD porque, como aprendemos alguns par√°grafos atr√°s,os pol√≠gonos do lado oposto do plano de separa√ß√£o n√£o podem se sobrepor a nada no lado frontal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O diagrama abaixo mostra a constru√ß√£o e a travessia de uma √°rvore BSP que descreve uma cena 2D simples. </font><font style="vertical-align: inherit;">Em 2D, linhas divis√≥rias s√£o usadas em vez de dividir planos, mas a ideia b√°sica permanece a mesma.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f72/00b/aac/f7200baac3a914eb6fe62ca131b1e3cc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/564/e28/9bf/564e289bf6d44182b3db68c8ad7178c0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/07a/f5a/63807af5af2f3bfa8c7ec73a81c36035.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um recurso muito conveniente da √°rvore do BSP que Fuchs, Kedem e Naylor enfatizam v√°rias vezes √© que ele precisa ser constru√≠do apenas uma vez. </font><font style="vertical-align: inherit;">Isso parece surpreendente, mas uma √°rvore BSP pode ser usada para renderizar a cena, independentemente do ponto de vista da c√¢mera. </font><font style="vertical-align: inherit;">A √°rvore do BSP permanece utiliz√°vel at√© que os pol√≠gonos da cena se movam. </font><font style="vertical-align: inherit;">√â por isso que a √°rvore do BSP √© t√£o √∫til para renderiza√ß√£o em tempo real - todo o trabalho complexo de construir uma √°rvore pode ser feito antecipadamente, e n√£o no momento da renderiza√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuchs, Kedem e Naylor relatam que novas pesquisas requerem a cria√ß√£o de uma "boa" √°rvore de BSP. A qualidade da √°rvore do BSP depende de quais pol√≠gonos voc√™ escolhe para definir os planos de separa√ß√£o. Anteriormente, pulei esse ponto, mas se voc√™ usar um plano que cruza outros pol√≠gonos ao dividir, para que o algoritmo BSP funcione, √© necess√°rio dividir os pol√≠gonos cruzados em dois, de modo que uma metade se refira a um meio espa√ßo e a outra √† outra. Se isso acontecer com frequ√™ncia, a constru√ß√£o de uma √°rvore BSP aumenta significativamente o n√∫mero de pol√≠gonos na cena.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruce Naylor, um dos autores de um artigo de 1980, escreveu mais tarde sobre esse assunto em seu artigo de 1993, Construindo boas √°rvores de particionamento. </font><font style="vertical-align: inherit;">De acordo com o colega de Carmack e co-fundador da id Software, John Romero, este artigo foi um dos trabalhos que Carmack leu quando tentou implementar √°rvores BSP no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Årvores BSP no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que, no primeiro rascunho do renderizador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">Carmack tentou definir a ordem de renderiza√ß√£o da geometria de n√≠vel, preenchendo o renderizador da sala onde o jogador est√° nas salas vizinhas. As √°rvores do BSP eram uma maneira mais conveniente de determinar essa ordem, porque evitavam o problema do renderizador ter que visitar repetidamente uma sala (ou setor), desperdi√ßando ciclos do processador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúAdicionar √°rvores BSP ao </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù na pr√°tica significava adicionar um gerador de √°rvores BSP ao editor de n√≠vel do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Depois de concluir a cria√ß√£o do n√≠vel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma √°rvore BSP foi gerada a partir da geometria do n√≠vel. Segundo Fabien Sanglar, o processo de gera√ß√£o pode levar at√© oito segundos para um n√≠vel e 11 minutos para todos os n√≠veis do primeiro </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O processo de gera√ß√£o foi t√£o demorado em parte devido ao fato de que o algoritmo de gera√ß√£o Carmack BSP est√° tentando encontrar uma √°rvore "boa" do BSP usando v√°rias heur√≠sticas. Um atraso de oito segundos seria imperdo√°vel durante o jogo, mas ap√≥s a gera√ß√£o preliminar parecia bastante aceit√°vel, dado o aumento no desempenho que as √°rvores do BSP forneceram ao renderizador. A √°rvore BSP gerada de um n√≠vel individual foi salva como parte dos dados do n√≠vel carregados no jogo quando foi lan√ßado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carmack fez uma mudan√ßa importante no algoritmo de √°rvore BSP descrito em um artigo de 1980: ap√≥s o lan√ßamento do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e lendo a √°rvore BSP do n√≠vel atual na mem√≥ria, o renderizador usa essa √°rvore para desenhar objetos n√£o de frente para frente, mas de frente para tr√°s. Em um artigo de 1980, Fuchs, Kedem e Naylor demonstraram como uma √°rvore BSP pode ser usada para implementar o algoritmo de um artista com renderiza√ß√£o consecutiva, mas uma grande quantidade de repinturas ocorre no algoritmo do artista, o que pode ser caro em PCs compat√≠veis com IBM. Portanto, o renderizador do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> come√ßa com uma geometria mais pr√≥xima do jogador e, em seguida, desenha o mais distante. Essa ordem inversa √© f√°cil de implementar usando uma √°rvore BSP, porque voc√™ pode simplesmente tomar uma decis√£o de retorno em cada n√≥ da √°rvore. Para impedir que geometria mais distante seja desenhada em cima, o renderizador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa um tipo de buffer z impl√≠cito, que fornece muitos dos benef√≠cios de um buffer z regular, enquanto consome muito menos mem√≥ria. H√° uma matriz que rastreia a sobreposi√ß√£o na dimens√£o horizontal e outras duas matrizes que rastreiam a sobreposi√ß√£o na dire√ß√£o vertical acima e abaixo da tela. O renderizador do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> poderia </font><font style="vertical-align: inherit;">ficar </font><font style="vertical-align: inherit;">sem usar um buffer z verdadeiro, porque o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , estritamente falando, n√£o era um jogo completamente tridimensional. Estruturas de dados menos caras funcionavam porque </font><font style="vertical-align: inherit;">alguns elementos n√£o eram poss√≠veis </font><font style="vertical-align: inherit;">no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a matriz de sobreposi√ß√£o horizontal funcionava porque n√£o havia paredes inclinadas e as matrizes de sobreposi√ß√£o vertical funcionavam porque n√£o havia paredes nas quais, por exemplo, havia duas localizadas um acima das outras janelas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/23c/5de/a7423c5dead349917bd826ee3efa70b9.png"></div><br> <i><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom II</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , t√£o complexo quanto seu antecessor.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/82b/b4a/3a782bb4a5a2c4a44e5821c897239533.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas ningu√©m reclamou da repeti√ß√£o de sangue.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/0e4/443/3d00e4443a7e46c3418e11dac4eec839.png"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma nova palavra nas tecnologias Quake A</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √∫nica tarefa complicada que resta √© como integrar os caracteres m√≥veis do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na geometria est√°tica dos n√≠veis desenhados usando a √°rvore BSP. </font><font style="vertical-align: inherit;">Os inimigos no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o podiam fazer parte da √°rvore do BSP porque estavam se movendo; </font><font style="vertical-align: inherit;">A √°rvore BSP funciona apenas com geometria fixa. </font><font style="vertical-align: inherit;">Portanto, o renderizador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro desenha a geometria est√°tica do n√≠vel, rastreando (usando outra estrutura de dados com efici√™ncia de mem√≥ria) os segmentos da tela em que o desenho foi executado. Em seguida, ele desenha os inimigos de tr√°s para frente, truncando-os ao longo dos segmentos da tela que os sobrep√µem. Esse processo n√£o √© t√£o ideal quanto a renderiza√ß√£o com uma √°rvore BSP, mas como geralmente h√° menos inimigos que a geometria, a velocidade n√£o √© um problema aqui. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar √°rvores BSP no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> foi uma grande vit√≥ria. Obviamente, Carmack foi perspicaz o suficiente para perceber que as √°rvores BSP seriam a solu√ß√£o ideal. Mas essa decis√£o foi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">engenhosa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em </font></font><a href="http://fabiensanglard.net/gebbdoom/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seu excelente livro sobre o mecanismo de jogo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabien Sanglar cita John Romero, que disse que o artigo de Bruce Naylor, ‚ÄúConstruindo boas √°rvores de particionamento‚Äù, era principalmente sobre o uso de √°rvores BSP para aparar as faces traseiras de modelos 3D. De acordo com Romero, Carmack achou que o algoritmo ainda poderia ser √∫til para o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ent√£o ele o implementou. Isso √© bastante louv√°vel para Carmack, porque ele implica que ele viu a utilidade das √°rvores BSP em videogames em tempo real, mesmo quando outras pessoas ainda usavam essa t√©cnica para renderizar cenas est√°ticas. A mesma hist√≥ria lisonjeira est√° em </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masters of Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Kouchner sugeriu que Carmack leu o artigo de Naylor e se perguntou: "e se voc√™ puder usar a √°rvore BSP para criar n√£o apenas uma imagem 3D, mas um mundo virtual inteiro?" </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essas descobertas ignoram a hist√≥ria da √°rvore BSP. Quando os pesquisadores da For√ßa A√©rea dos EUA perceberam que dividir uma cena poderia ajudar a acelerar a renderiza√ß√£o, eles estavam interessados </font><em><font style="vertical-align: inherit;">na</font></em><font style="vertical-align: inherit;"> acelera√ß√£o da renderiza√ß√£o em </font><em><font style="vertical-align: inherit;">tempo</font></em><font style="vertical-align: inherit;"> real</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque no final eles tentaram criar um simulador de v√¥o. O exemplo do simulador de v√¥o √© mencionado novamente em um artigo de 1980. Fuchs, Kedem e Naylor escrevem que a √°rvore BSP pode ser √∫til em um simulador de v√¥o que os pilotos usam para fazer v√°rios pousos no mesmo aeroporto. Como a geometria do aeroporto nunca muda, uma √°rvore BSP pode ser gerada apenas uma vez. Obviamente, eles estavam pensando em simula√ß√£o em tempo real. Na introdu√ß√£o do artigo, eles at√© explicam suas pesquisas testando a possibilidade de usar um sistema gr√°fico em tempo real para criar imagens em n√£o mais que 1/30 segundo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou seja, Carmack n√£o foi o primeiro a pensar em usar √°rvores BSP em simula√ß√£o gr√°fica em tempo real. Obviamente, prever que as √°rvores BSP podem ser usadas dessa maneira e implementar isso s√£o coisas completamente diferentes. Mas mesmo com a implementa√ß√£o, o Carmack poderia ter mais informa√ß√µes b√°sicas do que se pensa. O </font></font><a href="https://en.wikipedia.org/wiki/Binary_space_partitioning"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo do WSP sobre √°rvores do BSP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sugere que Carmack se referiu ao artigo de 1991 de Chen e Gordon, bem como ao livro de 1990 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computer Graphics: Principles and Practice</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Embora essa declara√ß√£o n√£o seja suportada por uma cita√ß√£o, ela pode ser verdadeira. Um artigo de 1991 de Chen e Gordon descreve a renderiza√ß√£o de frente para tr√°s usando √°rvores BSP, que √© essencialmente a mesma solu√ß√£o usada pelo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, at√© a estrutura de dados "buffer z impl√≠cito", que n√£o permite desenhar pol√≠gonos distantes sobre os vizinhos. O artigo fornece uma excelente vis√£o geral das √°rvores BSP, bem como o pseudoc√≥digo para construir e exibir uma √°rvore. (Gra√ßas √† maravilhosa biblioteca da minha universidade, eu pude percorrer a edi√ß√£o de 1990.) O livro </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computa√ß√£o Gr√°fica: Princ√≠pios e Pr√°tica</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© um trabalho cl√°ssico sobre computa√ß√£o gr√°fica, para que Carmack tamb√©m possa ter um.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6f/134/2a9/b6f1342a90a1ce11fafca1f265f65fda.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≠vel E1M1 do subsetor: Hangar.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seja como for, Carmack enfrentou uma nova tarefa - ‚ÄúComo posso criar um jogo de tiro em primeira pessoa que seja executado em um computador com um processador que nem sequer √© capaz de executar opera√ß√µes de ponto flutuante?‚Äù - conduziu sua pr√≥pria pesquisa e provou que as √°rvores BSP s√£o Essa √© uma estrutura de dados √∫til para videogames em tempo real. Ainda acho que esse √© um resultado impressionante, mesmo que a √°rvore do BSP tenha sido inventada dez anos antes e tenha sido estudada teoricamente em detalhes suficientes no momento em que Carmack leu sobre isso. Talvez a principal conquista que devemos elogiar seja o mecanismo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como um todo, que se tornou um √≥timo exemplo de c√≥digo. Eu j√° falei sobre isso uma vez, mas repito que o livro de Fabien Sanglar sobre o mecanismo de jogo</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Livro Negro do Game Engine: DOOM</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) √© uma excelente vis√£o geral de todos os componentes importantes do mecanismo do jogo e sua intera√ß√£o. </font><font style="vertical-align: inherit;">N√£o devemos esquecer que a tarefa VSD foi apenas uma das muitas tarefas que Carmack teve que resolver para que o mecanismo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funcionasse </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">E que ele foi capaz de, al√©m de tudo, ler sobre a complexa estrutura de dados desconhecida pela maioria dos programadores e implement√°-la. </font><font style="vertical-align: inherit;">Isso diz muito sobre o n√≠vel de seu conhecimento t√©cnico e compromisso com o ideal.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482614/">https://habr.com/ru/post/pt482614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482598/index.html">Falsifica√ß√£o de fotos do grupo Dyatlov</a></li>
<li><a href="../pt482604/index.html">5 personagens da d√©cada de 1920 que, depois de 100 anos, surgiram nas nuvens</a></li>
<li><a href="../pt482608/index.html">AMA com Habr # 15. Ano Novo e o lan√ßamento mais curto! Bate-papo</a></li>
<li><a href="../pt482610/index.html">Lan√ßamento da tela Transflective TFT no SSD1283A com STM32</a></li>
<li><a href="../pt482612/index.html">Tocando no busi-board de engenharia, Ano Novo e volunt√°rios</a></li>
<li><a href="../pt482616/index.html">Foreve Elon 2019/2020 (reuni√£o online do NY2020)</a></li>
<li><a href="../pt482620/index.html">Slurm: Habr, boas festas ...</a></li>
<li><a href="../pt482622/index.html">Simula√ß√£o de corrida na chuva</a></li>
<li><a href="../pt482626/index.html">Monitorando aplicativos com o Logger.</a></li>
<li><a href="../pt482628/index.html">Assista "Pequena Aranha Verde do Tempo"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>